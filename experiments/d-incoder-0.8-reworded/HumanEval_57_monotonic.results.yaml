language: d
name: HumanEval_57_monotonic
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong i;\n\
    \tint j;\n\tfor (j=1; j < l.length; ++j)\n\t{\n\t\tif (!(std.maxi(l[j-1], l[j])\
    \ <= std.mini(l[j-1], l[j])))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t\
    for (j=1; j < l.length; ++j)\n\t{\n\t\tfor (i=j-1; i>=0; --i)\n\t\t{\n\t\t\tif\
    \ (std.mini(l[j], l[i]) <= std.maxi(l[j-1], l[i]))\n\t\t\t\treturn false;\n\t\t\
    }\n\t}\n\t\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsvj6jd4o.d(19): Error: undefined identifier `maxi` in package `std`,
    did you mean module `math`?

    /tmp/tmpsvj6jd4o.d(19): Error: undefined identifier `mini` in package `std`

    /tmp/tmpsvj6jd4o.d(29): Error: undefined identifier `mini` in package `std`

    /tmp/tmpsvj6jd4o.d(29): Error: undefined identifier `maxi` in package `std`, did
    you mean module `math`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsvj6jd4o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong l =\
    \ l[0];\n\tbool is_increasing = true;\n\tbool is_decreasing = true;\n\tbool is_monotonic_increasing\
    \ = true;\n\tbool is_monotonic_decreasing = true;\n\tbool is_strictly_decreasing\
    \ = true;\n\tbool is_strictly_increasing = true;\n\tfor(int i=1; i<l.length; i++)\n\
    \t{\n\t\tlong v = l[i];\n\t\tif(v > l)\n\t\t{\n\t\t\tis_decreasing = false;\n\t\
    \t}\n\t\telse if(v < l)\n\t\t{\n\t\t\tis_increasing = false;\n\t\t}\n\t\telse\
    \ if(v == l)\n\t\t{\n\t\t\tis_monotonic_increasing = false;\n\t\t\tis_strictly_decreasing\
    \ = false;\n\t\t\tis_strictly_increasing = false;\n\t\t}\n\t\telse if(v == l-1)\n\
    \t\t{\n\t\t\tis_monotonic_decreasing = false;\n\t\t\tis_strictly_increasing =\
    \ false;\n\t\t\tis_strictly_decreasing = false;\n\t\t}\n\t\telse if(v == l-2)\n\
    \t\t{\n\t\t\tis_monotonic_increasing = false;\n\t\t\tis_strictly_increasing =\
    \ false;\n\t\t\tis_strictly_decreasing = false;\n\t\t}\n\t}\n\tbool result = is_increasing;\n\
    \tresult |= is_decreasing;\n\tresult |= is_monotonic_increasing;\n\tresult |=\
    \ is_monotonic_decreasing;\n\tresult |= is_strictly_decreasing;\n\tresult |= is_strictly_increasing;\n\
    \treturn result;\n}\n/*\nReturn true is array elements are strictly decreasing\
    \ or increasing.\n    >>> strictly_decreasing([1L, 2L, 4L, 20L])\n    true\n \
    \   >>> strictly_decreasing([1L, 4L, 3L, 20L])\n    false\n    >>> strictly_decreasing([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyhu77ajv.d(15): Error: variable `l` is shadowing variable `tmpyhu77ajv.monotonic.l`

    /tmp/tmpyhu77ajv.d(22): Error: no property `length` for type `long`

    /tmp/tmpyhu77ajv.d(24): Error: only one index allowed to index `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyhu77ajv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n   if(l.length\
    \ < 2)\n       return true;\n   long long max = 0;\n   for(int i = 0; i < l.length-1;\
    \ i++)\n   {\n       long a = l[i];\n       long b = l[i+1];\n       if(b < a)\n\
    \           return false;\n       if(max < a)\n           max = a;\n   }\n   return\
    \ true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_0fs0xcj.d(17): Error: use `long` for a 64 bit integer instead
    of `long long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_0fs0xcj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  long last\
    \ = l[0];\n  long curr = l[1];\n  \n  if(curr <= last)\n    return true;\n  \n\
    \  for(int i = 2; i < l.length; ++i) {\n    long next = l[i];\n    if(curr > next)\n\
    \      return true;\n    else if(curr < next)\n      return false;\n    else\n\
    \      curr = next;\n  }\n  \n  return false;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplb_tehu0.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x42832d]

    ??:? void tmplb_tehu0.__unittest_L33_C1() [0x427e40]

    ??:? void tmplb_tehu0.__modtest() [0x4280ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b242]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430884]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430361]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b219]

    ??:? runModuleUnitTests [0x42c185]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long i\
    \ = 0;\n    long j = l.length - 1;\n    long min_i = l[0];\n    long min_j = l[0];\n\
    \    while (i < j) {\n        while (i<j && l[i] < min_j) ++i;\n        while\
    \ (j>i && l[j] > min_i) --j;\n        if (i<j) {\n            min_i = l[i];\n\
    \            min_j = l[j];\n        }\n        else {\n            min_i = l[i];\n\
    \            min_j = l[j];\n        }\n    }\n    if (min_i < l[0]) {\n      \
    \  return true;\n    }\n    return false;\n}\n'''\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6tlyq63m.d(36): Error: unterminated character constant

    /tmp/tmp6tlyq63m.d(36): Error: declaration expected, not `63U`

    /tmp/tmp6tlyq63m.d(36): Error: unterminated character constant

    /tmp/tmp6tlyq63m.d(41): Error: declaration expected, not `assert`

    /tmp/tmp6tlyq63m.d(42): Error: declaration expected, not `assert`

    /tmp/tmp6tlyq63m.d(43): Error: declaration expected, not `assert`

    /tmp/tmp6tlyq63m.d(44): Error: declaration expected, not `assert`

    /tmp/tmp6tlyq63m.d(45): Error: declaration expected, not `assert`

    /tmp/tmp6tlyq63m.d(46): Error: declaration expected, not `assert`

    /tmp/tmp6tlyq63m.d(47): Error: declaration expected, not `assert`

    /tmp/tmp6tlyq63m.d(48): Error: declaration expected, not `assert`

    /tmp/tmp6tlyq63m.d(49): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6tlyq63m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint i =\
    \ 0;\n\tint j = 1;\n\tint m = 1;\n\tlong max = l[0];\n\tfor (; i < l.length; i++)\n\
    \t\tif (l[i] > max)\n\t\t\tm = j;\n\t\telse if (l[i] < max)\n\t\t\tj = m;\n\t\t\
    else\n\t\t\tbreak;\n\tif (j == m)\n\t\treturn false;\n\telse\n\t\treturn true;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmw4jdxi6.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x42832d]

    ??:? void tmpmw4jdxi6.__unittest_L31_C1() [0x427e44]

    ??:? void tmpmw4jdxi6.__modtest() [0x4280b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b242]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430884]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430361]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b219]

    ??:? runModuleUnitTests [0x42c185]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int j;\n\
    \    for (int i = 1; i < l.length; ++i)\n    {\n        long x = l[i];\n     \
    \   if (x < l[i - 1] || x > l[j])\n        {\n            j = i;\n        }\n\
    \    }\n    return j > i;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgu0khsx_.d(24): Error: undefined identifier `i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgu0khsx_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    var len\
    \ = l.length;\n    if(len == 0)\n        return true;\n    if(len == 1)\n    \
    \    return l[0] > l[1];\n    if(l[0] > l[len - 1])\n        return false;\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwunnfx15.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwunnfx15.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  long previous\
    \ = 0;\n  for (int i = 0; i < l.length-1; ++i) {\n    if (l[i] > l[i+1]) {\n \
    \     return false;\n    }\n    previous = l[i];\n  }\n  return true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjubnz30f.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x42831d]

    ??:? void tmpjubnz30f.__unittest_L24_C1() [0x427f19]

    ??:? void tmpjubnz30f.__modtest() [0x42809c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c39f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b232]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430874]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430351]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b209]

    ??:? runModuleUnitTests [0x42c175]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287e0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i,j,k,k,l;\n\
    \    bool c;\n    for(i=1;i<l.length;++i){\n        if(l[i]<=l[i-1]) continue;\n\
    \        k=0;\n        for(j=0;j<i;++j){\n            if(l[j]<=l[k]){\n      \
    \          c=true;\n                for(l=j+1;l<i;++l)\n                    if(l[j+1]>l[k])\n\
    \                        c=false;\n                break;\n            }\n   \
    \         ++k;\n        }\n        if(c)return false;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3wq1vmbq.d(15): Error: declaration `tmp3wq1vmbq.monotonic.k` is
    already defined

    /tmp/tmp3wq1vmbq.d(15): Error: variable `l` is shadowing variable `tmp3wq1vmbq.monotonic.l`

    /tmp/tmp3wq1vmbq.d(17): Error: no property `length` for type `int`

    /tmp/tmp3wq1vmbq.d(18): Error: only one index allowed to index `int`

    /tmp/tmp3wq1vmbq.d(18): Error: only one index allowed to index `int`

    /tmp/tmp3wq1vmbq.d(21): Error: only one index allowed to index `int`

    /tmp/tmp3wq1vmbq.d(21): Error: only one index allowed to index `int`

    /tmp/tmp3wq1vmbq.d(24): Error: only one index allowed to index `int`

    /tmp/tmp3wq1vmbq.d(24): Error: only one index allowed to index `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3wq1vmbq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min\
    \ = l[0];\n    bool mono = true;\n    for (long i=1; i<l.length; ++i)\n    {\n\
    \        if (l[i] < min)\n        {\n            mono = false;\n            break;\n\
    \        }\n        else if (l[i] > min)\n        {\n            min = l[i];\n\
    \        }\n    }\n    return mono;\n}\n/*\nGiven a range of integer values, return\
    \ a list of ranges of integers\nthat have the same size, where the ranges overlap\n\
    \    \n    >>> split_ranges([0, 1, 2, 3, 4])\n    [(0, 1), (2, 3, 4)]\n    >>>\
    \ split_ranges([0, 4, 9, 9, 9])\n    [(0, 4), (9, 9)]\n    \n*/\nList<Tuple<long,\
    \ long>> split_ranges(long[] l)\n{\n    List<Tuple<long, long>> result = new List<Tuple<long,\
    \ long>>();\n    bool mono = monotonic(l);\n    long first = l[0], last = l[l.length-1];\n\
    \    if (first == last)\n    {\n        Tuple<long, long> t = new Tuple<long,\
    \ long>(first, first);\n        result.Add(t);\n        return result;\n    }\n\
    \    for (long i=first; i<=last; ++i)\n    {\n        if (mono)\n        {\n \
    \           Tuple<long, long> t = new Tuple<long, long>(i, i);\n            result.Add(t);\n\
    \        }\n        else\n        {\n            Tuple<long, long> t = new Tuple<long,\
    \ long>(last, i);\n            result.Add(t);\n        }\n    }\n    return result;\n\
    }\n/*\nGiven a range of integer values, return a list of ranges of integers\n\
    that have the same size, where the ranges overlap and are \n    \n    1) all monotonic\
    \ increasing\n    2) all monotonic decreasing\n    3) all non-monotonic increasing\n\
    \    4) all non-monotonic decreasing\n    \n    >>> split_ranges([0, 1, 2, 3])\n\
    \    [(0, 3), (2, 3), (4, 3), (5, 3)]\n    >>> split_ranges([0, 4, 9, 9])\n  \
    \  [(0, 4), (9, 9)]\n    \n    \n    >>> split_ranges([0, 1, 2, 3, 4])\n    [(0,\
    \ 1), (2, 3, 4), (4, 5)]\n    >>> split_ranges([0, 4, 9, 9, 9])\n    [(0, 4),\
    \ (9, 9)]\n    \n    \n    >>> split_ranges([0, 1, 2, 3, 4])\n    [(0, 1), (2,\
    \ 3, 4), (4, 5)]\n    >>> split_ranges([0, 4, 9, 9, 9])\n    [(0, 4), (9, 9)]\n\
    \    \n*/\nList<Tuple<long, long>> split_ranges(long[] l, bool allMonotonic)\n\
    {\n    List<Tuple<long, long>> result = new \nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeizlvit7.d(41): Error: no identifier for declarator `List`

    /tmp/tmpeizlvit7.d(41): Error: declaration expected, not `<`

    /tmp/tmpeizlvit7.d(46): Error: declaration expected, not `if`

    /tmp/tmpeizlvit7.d(49): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpeizlvit7.d(49): Error: no identifier for declarator `result.Add(t)`

    /tmp/tmpeizlvit7.d(50): Error: declaration expected, not `return`

    /tmp/tmpeizlvit7.d(51): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeizlvit7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ == 1) return false;\n    long first = l[0];\n    long last = l[0];\n    for(int\
    \ i = 0; i < l.length-1; i++){\n        long cur = l[i];\n        long next =\
    \ l[i+1];\n        if (cur < last){\n            last = cur;\n        }\n    \
    \    else if (cur > next){\n            first = cur;\n        }\n    }\n    return\
    \ first < l[l.length-1];\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdvyzskbm.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x42838d]

    ??:? void tmpdvyzskbm.__unittest_L30_C1() [0x427f89]

    ??:? void tmpdvyzskbm.__modtest() [0x42810c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c40f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2a2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430435]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308e4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303c1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]

    ??:? runModuleUnitTests [0x42c1e5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428850]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  int i =\
    \ 0;\n  int j = 1;\n  bool prev = true;\n  long prev2 = 0;\n  long cur = l[0];\n\
    \  long cur2 = l[i];\n  \n  while(j < l.length && cur < l[j]) {\n    cur2 = l[j];\n\
    \    prev = cur > cur2;\n    cur = cur2;\n    i++;\n    j++;\n  }\n  if(j > 1)\
    \ {\n    if(prev) {\n      if(prev2 < cur2) {\n        return true;\n      } else\
    \ {\n        prev2 = cur2;\n        prev = cur > prev2;\n        j++;\n      }\n\
    \    } else {\n      if(cur2 < prev2) {\n        return true;\n      } else {\n\
    \        prev2 = cur2;\n        prev = cur > prev2;\n        i++;\n      }\n \
    \   }\n  }\n  return false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpw73cy7nb.d(54): unittest failure

    ----------------

    ??:? _d_unittestp [0x42839d]

    ??:? void tmpw73cy7nb.__unittest_L50_C1() [0x427eb0]

    ??:? void tmpw73cy7nb.__modtest() [0x42811c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c41f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2b2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430445]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303d1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]

    ??:? runModuleUnitTests [0x42c1f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428860]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for(int\
    \ i = 1; i < l.size(); i++)\n        if(l[i-1] <= l[i])\n            return false;\n\
    \    return true;\n}\n/*\nReturn the first non-null value in the array.\n>>> first([null,\
    \ 1, \"\", 2, \"\", 4, \"\", null])\n\"\"\n>>> first([null, 1, \"\", 2, \"\",\
    \ 4, \"\", null], null)\nnull\n>>> first([null, 1, \"\", 2, \"\", 4, \"\", null],\
    \ \"hi\")\n\"hi\"\n*/\nstring first(T[] a, T t) \n{\n    for(T x : a) {\n    \
    \    if(t != null)\n            return x;\n    }\n    return null;\n}\n/*\nReturn\
    \ the last non-null value in the array.\n>>> last([null, 1, \"\", 2, \"\", 4,\
    \ \"\", null])\nnull\n>>> last([null, 1, \"\", 2, \"\", 4, \"\", null], null)\n\
    null\n>>> last([null, 1, \"\", 2, \"\", 4, \"\", null], \"hi\")\n\"hi\"\n*/\n\
    string last(T[] a, T t) \n{\n    for(T x : a) {\n        if(t != null)\n     \
    \       return x;\n    }\n    return null;\n}\n/*\nReturn the index of the first\
    \ item in the array that matches the key.\n>>> indexOf([{a:1}, {a:2}, {a:3}, {a:4},\
    \ {a:5}, {a:6}, {a:7}], {a:4})\n1\n>>> indexOf([{a:1}, {a:2}, {a:3}, {a:4}, {a:5},\
    \ {a:6}, {a:7}], {a:100})\n-1\n>>> indexOf([{a:1}, {a:2}, {a:3}, {a:4}, {a:5},\
    \ {a:6}, {a:7}], {a:\"hi\"})\n-1\n>>> indexOf([{a:1}, {a:2}, {a:3}, {a:4}, {a:5},\
    \ {a:6}, {a:7}], 100)\n-1\n>>> indexOf([{a:1}, {a:2}, {a:3}, {a:4}, {a:5}, {a:6},\
    \ {a:7}], \"hi\")\n-1\n>>> indexOf([{a:1}, {a:2}, {a:3}, {a:4}, {a:5}, {a:6},\
    \ {a:7}], \"ho\")\n-1\n*/\nunittest\n{\n    alias candidate = monotonic;\n\n \
    \   assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw_ily7mn.d(31): Error: found `x` when expecting `;` following statement

    /tmp/tmpw_ily7mn.d(31): Error: expression expected, not `:`

    /tmp/tmpw_ily7mn.d(31): Error: found `a` when expecting `;` following `for` condition

    /tmp/tmpw_ily7mn.d(48): Error: found `x` when expecting `;` following statement

    /tmp/tmpw_ily7mn.d(48): Error: expression expected, not `:`

    /tmp/tmpw_ily7mn.d(48): Error: found `a` when expecting `;` following `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw_ily7mn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 1)\n        return true;\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp98betkbs.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp98betkbs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length==1)\
    \ return true; // Nothing to do\n    int n = l.length;\n    int m = (n>1)?(n-1):1;\n\
    \    for(int i=0; i<n; i=i+m)\n        if(l[i]>=l[i+1]) return true;\n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbpy18gac.d(16): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbpy18gac.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for (long\
    \ i = 0; i < l.length - 1; i++)\n    {\n        if (l[i] < l[i + 1])\n       \
    \     return false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4gebr1ng.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282e5]

    ??:? void tmp4gebr1ng.__unittest_L22_C1() [0x427df8]

    ??:? void tmp4gebr1ng.__modtest() [0x428064]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c367]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43038d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43083c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430319]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d1]

    ??:? runModuleUnitTests [0x42c13d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for (int\
    \ i = 0; i < l.length-1; i++)\n    {\n        if (l[i+1] < l[i])\n        {\n\
    \            return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nIt won't work for `monotonic([0, 0])`. Also, you can save a lot\
    \ of time by comparing `l[i+1] > l[i]` instead of `l[i+1] < l[i]`.\n<|/ c |>\n\
    <| c |>\nThis is not true, please check [this answer](https://stackoverflow.com/a/47017351/3221007).\n\
    <|/ c |>\n<| a tags=c++,arrays |>\nHere is another solution which I believe is\
    \ faster than the other answers:\n<code>\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpryuewxrj.d(24): Error: declaration expected, not `<`

    /tmp/tmpryuewxrj.d(27): Error: unterminated character constant

    /tmp/tmpryuewxrj.d(39): Error: declaration expected, not `assert`

    /tmp/tmpryuewxrj.d(40): Error: declaration expected, not `assert`

    /tmp/tmpryuewxrj.d(41): Error: declaration expected, not `assert`

    /tmp/tmpryuewxrj.d(42): Error: declaration expected, not `assert`

    /tmp/tmpryuewxrj.d(43): Error: declaration expected, not `assert`

    /tmp/tmpryuewxrj.d(44): Error: declaration expected, not `assert`

    /tmp/tmpryuewxrj.d(45): Error: declaration expected, not `assert`

    /tmp/tmpryuewxrj.d(46): Error: declaration expected, not `assert`

    /tmp/tmpryuewxrj.d(47): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpryuewxrj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n\
    \ = l.Length;\n    for (int i = 0; i < n; i++)\n    {\n        if (l[i] > l[i\
    \ - 1]) \n        {\n            return false;\n        }\n    }\n    return true;\n\
    }\n// ---------------------------------------------------------------------------\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq2_ldz89.d(15): Error: no property `Length` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq2_ldz89.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  long i;\n\
    \  long len = l.length;\n  bool res = true;\n  if (len == 0)\n    return false;\n\
    \  if (len == 1)\n    return true;\n  for (i = 1; i < len; i++)\n    if (l[i-1]\
    \ >= l[i])\n      res = false;\n  return res;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8qxg57gu.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x428305]

    ??:? void tmp8qxg57gu.__unittest_L27_C1() [0x427f01]

    ??:? void tmp8qxg57gu.__modtest() [0x428084]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c387]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b21a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43085c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430339]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f1]

    ??:? runModuleUnitTests [0x42c15d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ monotonic(l, l.length-1);\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq1z7kxo4.d(15): Error: function `tmpq1z7kxo4.monotonic(long[] l)`
    is not callable using argument types `(long[], ulong)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq1z7kxo4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    var i=0;\n\
    \    var i1=l.length-1;\n    var m1=1;\n    var m2=0;\n    var j1=i;\n    var\
    \ j2=i;\n    var j=0;\n    for(;j1<=i1;j1++)\n    {\n        if (l[j1]>l[j])\n\
    \        {\n            return false;\n        }\n        else\n        {\n  \
    \          m1=1;\n        }\n        j++;\n    }\n    for(;j2<=i1;j2++)\n    {\n\
    \        if (l[j2]<l[j])\n        {\n            return false;\n        }\n  \
    \      else\n        {\n            m2=1;\n        }\n        j++;\n    }\n  \
    \  return m2>m1;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nNice, this one was the\
    \ best solution for me.\n<|/ c |>\n<| c |>\nOuch. Thanks. Fixed now.\n<|/ c |>\n\
    <| a |>\nIt can be done in O(n).\nSort the array and then compare adjacent elements\
    \ with each other. If current elements are greater than previous one, then they\
    \ have to be in descending order, if they are less than previous one, then they\
    \ have to be in ascending order (i.e. the array is in increasing order).\nThis\
    \ algorithm is similar to selection algorithm, but the logic is applied on the\
    \ array instead of on the subarray(s) and is independent of the size of subarray.\n\
    <|/ a tags=arrays,algorithm,sorting dscore=1 |>\n<| c |>\nI didn't know that selection\
    \ algorithms were O(n) time complexity. Learn something new every day.\n<|/ c\
    \ |>\n<| c |>\nWell, it is not the selection algorithm that is the O(n) time complexity\
    \ but just iterating through the array elements. Even if this is true selection\
    \ algorithm, it would be O(n) because we are not iterating through all the elements\
    \ of the array.\n<|/ c |>\n<| c |>\nYes, I agree it is the selection algorithm\
    \ (selection sort is the worst case scenario - but O(n) time complexity)\n<|/\
    \ c |>\n<| c |>\nIf this was the best answer, you should mark it as such.  It's\
    \ also not O(n) for a general case - if you have some specific case where it is,\
    \ then we can find a solution.\n<|/ c |>\n<| a tags=arrays,algorithm,sorting |>\n\
    One easy way to do it is to sort it, then compare the difference between successive\
    \ elements to see if the order is ascending, descending. \nPseudocode:\n<code>\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp84dpusrb.d(48): Error: declaration expected, not `<`

    /tmp/tmp84dpusrb.d(62): Error: unterminated character constant

    /tmp/tmp84dpusrb.d(71): Error: unterminated character constant

    /tmp/tmp84dpusrb.d(81): Error: declaration expected, not `assert`

    /tmp/tmp84dpusrb.d(82): Error: declaration expected, not `assert`

    /tmp/tmp84dpusrb.d(83): Error: declaration expected, not `assert`

    /tmp/tmp84dpusrb.d(84): Error: declaration expected, not `assert`

    /tmp/tmp84dpusrb.d(85): Error: declaration expected, not `assert`

    /tmp/tmp84dpusrb.d(86): Error: declaration expected, not `assert`

    /tmp/tmp84dpusrb.d(87): Error: declaration expected, not `assert`

    /tmp/tmp84dpusrb.d(88): Error: declaration expected, not `assert`

    /tmp/tmp84dpusrb.d(89): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp84dpusrb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ monotonic(l, l);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_nl5asnf.d(15): Error: function `tmp_nl5asnf.monotonic(long[] l)`
    is not callable using argument types `(long[], long[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_nl5asnf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev\
    \ = 0;\n    long curr = 1;\n    long first = 1;\n    for (int i = 0; i < l.length;\
    \ ++i)\n    {\n        if (l[i] < prev) \n        {\n            first = prev;\n\
    \            break;\n        }\n        prev = curr;\n        curr = curr*l[i]\
    \ + (1 - l[i])*first;\n    }\n    return !(curr < first);\n}\nunittest\n{\n  \
    \  alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo3cb14e8.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x428355]

    ??:? void tmpo3cb14e8.__unittest_L30_C1() [0x427f07]

    ??:? void tmpo3cb14e8.__modtest() [0x4280d8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b26a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430389]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b241]

    ??:? runModuleUnitTests [0x42c1ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428818]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) return false;\n    long x1 = l[0];\n    long x2 = l[1];\n    for(int i\
    \ = 2; i < l.length; i++) \n    {\n        long x3 = l[i];\n        if (x1 > x3)\
    \ x1 = x3;\n        else if (x1 < x3) x2 = x3;\n    }\n    return x1 < x2;\n}\n\
    //===========================================================================================\n\
    /*\n    AdaptiveHistogram is described in detail in the paper:\n    Rainer Roelofs,\
    \ Markus Schmidt, and Josef Van Steenkiste.\n    \"Efficient Adaptive Histogram-Based\
    \ Medical Image Analysis\".\n    https://www.sciencedirect.com/science/article/pii/S0167214871300011\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpocmvo17b.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpocmvo17b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for(long\
    \ i = l.length; i > 0; --i) \n        if(l[i-1] <= l[i])\n            return false;\n\
    \    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpd5r2ez5c.d(16): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42838e]

    ??:? bool tmpd5r2ez5c.monotonic(long[]) [0x427d6a]

    ??:? void tmpd5r2ez5c.__unittest_L20_C1() [0x427ddd]

    ??:? void tmpd5r2ez5c.__modtest() [0x428060]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c35f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430385]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430834]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430311]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c9]

    ??:? runModuleUnitTests [0x42c135]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  bool decreasing\
    \ = true;\n  int i = 1;\n  while (i<l.length && l[i-1] <= l[i]) {\n    i++;\n\
    \  }\n  if (i==l.length) return decreasing;\n  while (decreasing && l[i-1] > l[i])\
    \ {\n    decreasing = !decreasing;\n    i++;\n  }\n  return decreasing;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpubc5kvia.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x428355]

    ??:? void tmpubc5kvia.__unittest_L27_C1() [0x427f55]

    ??:? void tmpubc5kvia.__modtest() [0x4280d8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b26a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430389]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b241]

    ??:? runModuleUnitTests [0x42c1ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428818]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long first\
    \ = l[0];\n    bool res = true;\n    for(int i = 1; i < l.length; ++i)\n     \
    \   if (l[i] < first)\n        {\n            res = false;\n            break;\n\
    \        }\n        else\n            first = l[i];\n    return res;\n}\n/*\n\
    Return true is array elements are monotonically increasing or decreasing.\n  \
    \  >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L,\
    \ 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n*/\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp16vjhpn9.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x428315]

    ??:? void tmp16vjhpn9.__unittest_L36_C1() [0x427f11]

    ??:? void tmp16vjhpn9.__modtest() [0x428094]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c397]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b22a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43086c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430349]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b201]

    ??:? runModuleUnitTests [0x42c16d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint n =\
    \ l.length;\n\tif(n == 0) return true;\n\tif(n == 1) return l[0] >= l[1] || l[0]\
    \ == l[1];\n\tif(l[0] != l[n-1]) return false;\n\tif(n == 2) return l[0] > l[1];\n\
    \treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiqp3c_g1.d(15): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiqp3c_g1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long x\
    \ = l[0];\n    long y = l[l.length-1];\n    bool xIncr = (x >= y);\n    bool yIncr\
    \ = (x <= y);\n    bool yDcr = (y >= x);\n    return xIncr == yIncr && xIncr ==\
    \ yDcr;\n}\n/*\nReturn true is array elements are monotonically increasing or\
    \ decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n\
    \    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp28yatx5_.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282d5]

    ??:? void tmp28yatx5_.__unittest_L32_C1() [0x427dec]

    ??:? void tmp28yatx5_.__modtest() [0x428058]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c357]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43037d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43082c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430309]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]

    ??:? runModuleUnitTests [0x42c12d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428798]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint len\
    \ = l.length;\n\tif (len <= 1) return true;\n\tlong a = l[0];\n\tlong b = l[1];\n\
    \tfor (int i = 2; i < len; i++) {\n\t\tlong c = l[i];\n\t\tif (c < a || (a ==\
    \ c && b < c)) return false;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn true;\n}\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzoz77x3s.d(15): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzoz77x3s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.Length\
    \ == 0)\n    {\n        return false;\n    }\n    long min = l[0];\n    bool minChanged\
    \ = false;\n    for (int i = 1; i < l.Length; i++)\n    {\n        long current\
    \ = l[i];\n        bool currentChanged = false;\n        if (current < min)\n\
    \        {\n            min = current;\n            minChanged = true;\n     \
    \       currentChanged = true;\n        }\n        else if (current == min)\n\
    \        {\n            if (i < l.Length - 1)\n            {\n               \
    \ long nextVal = l[i + 1];\n                currentChanged = nextVal < current;\n\
    \                if (currentChanged)\n                {\n                    min\
    \ = nextVal;\n                }\n            }\n        }\n        else\n    \
    \    {\n            if (current < min)\n            {\n                min = current;\n\
    \                minChanged = true;\n            }\n        }\n        \n    \
    \    if (minChanged)\n        {\n            break;\n        }\n    }\n    return\
    \ minChanged;\n}\n/*\nReturn true is array elements are monotonically increasing\
    \ or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n\
    \    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprpbwr26j.d(15): Error: no property `Length` for type `long[]`

    /tmp/tmprpbwr26j.d(21): Error: no property `Length` for type `long[]`

    /tmp/tmprpbwr26j.d(33): Error: no property `Length` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprpbwr26j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n\
    \ = l.length-1;\n    int m = -1;\n    for(int i=0; i<n; i++) {\n        if(l[i]\
    \ >= l[i+1]) {\n            m = i;\n            break;\n        }\n    }\n   \
    \ if(m != -1 && l[m] >= l[m+1]) {\n        return true;\n    }\n    return false;\n\
    }\n</code>\n<|/ a dscore=1 tags=arrays,c++ |>\n<| a |>\n<code>\n#include <bits/stdc++.h>\n\
    using namespace std;\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfmjccr40.d(28): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfmjccr40.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for(size_t\
    \ i = 1; i < l.length; ++i)\n        if(l[i] > l[i-1]) return false;\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyd5v_qnw.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282e5]

    ??:? void tmpyd5v_qnw.__unittest_L19_C1() [0x427dfc]

    ??:? void tmpyd5v_qnw.__modtest() [0x428068]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c367]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43038d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43083c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430319]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d1]

    ??:? runModuleUnitTests [0x42c13d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i\
    \ = 0;\n    int j = l.length - 1;\n    int min_i = -1;\n    int max_i = 0;\n \
    \   int min_j = -1;\n    int max_j = 0;\n    \n    while (i < j)\n    {\n    \
    \    int m_i = l[i];\n        int m_j = l[j];\n        int max_val = std::max(m_i,\
    \ m_j);\n        int min_val = std::min(m_i, m_j);\n        if (min_i > -1) \n\
    \        {\n            if (min_val > max_val)\n                return false;\n\
    \            if (min_val < min_i)\n            {\n                min_i = min_val;\n\
    \                min_j = m_i;\n            }\n        }\n        else\n      \
    \  {\n            if (max_val > max_i)\n            {\n                max_i =\
    \ max_val;\n                max_j = m_i;\n            }\n        }\n        \n\
    \        if (m_i > m_j)\n            i += 1;\n        else\n            j -= 1;\n\
    \    }\n    \n    if (min_i < max_i) \n    {\n        if (min_j > max_j)\n   \
    \     {\n            min_j = max_j;\n            min_i = max_i;\n        }\n \
    \   }\n    \n    return true;\n}\n</code>\n<|/ a tags=list,functional-programming,arrays,c++\
    \ |>\n<| c |>\nThis algorithm does not correctly answer the OP's question, which\
    \ asks for non-increasing (or non-decreasing) ranges of the array. Rather than\
    \ checking that the elements increase monotonically, it checks that there are\
    \ no gaps in the array. As long as the array is sorted and non-decreasing, this\
    \ algorithm works correctly in all cases, even if the elements aren't sequential\
    \ and don't increase monotonically.\n<|/ c |>\n<| a dscore=4 |>\nA simple and\
    \ fast solution using only standard library functions is to sort the range and\
    \ then check if the difference between consecutive elements is positive. This\
    \ requires O(n log n) comparisons and O(n log n) memory allocations.\n<code>\n\
    #include <algorithm>\n#include <cstdio>\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8jo0gx9s.d(26): Error: semicolon expected, not `:`

    /tmp/tmp8jo0gx9s.d(26): Error: found `:` instead of statement

    /tmp/tmp8jo0gx9s.d(27): Error: semicolon expected, not `:`

    /tmp/tmp8jo0gx9s.d(27): Error: found `:` instead of statement

    /tmp/tmp8jo0gx9s.d(64): Error: declaration expected, not `<`

    /tmp/tmp8jo0gx9s.d(67): Error: unterminated character constant

    /tmp/tmp8jo0gx9s.d(67): Error: unterminated character constant

    /tmp/tmp8jo0gx9s.d(67): Error: unterminated character constant

    /tmp/tmp8jo0gx9s.d(78): Error: declaration expected, not `assert`

    /tmp/tmp8jo0gx9s.d(79): Error: declaration expected, not `assert`

    /tmp/tmp8jo0gx9s.d(80): Error: declaration expected, not `assert`

    /tmp/tmp8jo0gx9s.d(81): Error: declaration expected, not `assert`

    /tmp/tmp8jo0gx9s.d(82): Error: declaration expected, not `assert`

    /tmp/tmp8jo0gx9s.d(83): Error: declaration expected, not `assert`

    /tmp/tmp8jo0gx9s.d(84): Error: declaration expected, not `assert`

    /tmp/tmp8jo0gx9s.d(85): Error: declaration expected, not `assert`

    /tmp'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  int i =\
    \ 0; \n  while (i<l.length-1) {\n    if (l[i+1] < l[i]) {\n      return true;\n\
    \    } else if (l[i+1] > l[i]) {\n      return false;\n    }\n    i++;\n  }\n\
    \  return false;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nJust a comment: I like\
    \ this solution the best.  It is the most efficient solution to this problem and\
    \ easy to read.  For others who may find it useful, I found this post because\
    \ I was looking for something that would work with c# and couldn't find it.  Using\
    \ this solution allowed me to easily get my own c# implementation for unit testing\
    \ to pass.\n<|/ c |>\n<| c |>\nI added an answer in C# for this question, see\
    \ below.\n<|/ c |>\n<| c |>\nIt should be noted that some implementations may\
    \ return false positives. For example, for arrays where every element appears\
    \ at least twice, `monotonic` will return false.\n<|/ c |>\n<| c |>\n, It should\
    \ be noted that Monotonic is a requirement for array sorting, not just for sorting.\
    \ Many sorting algorithms require monotonic sorting.\n<|/ c |>\n<| c |>\n: Indeed,\
    \ not all sorting algorithms do require monotonic sorting. For example, you can\
    \ sort a list in O(n) if you use a list as an array and use the same algorithm\
    \ for sorting. I did a blog post about this a while back: https://dev.to/paolostefanatico/algorithm-for-fast-monotonic-array-sorting-2jh8\n\
    <|/ c |>\n<| a tags=arrays,monotonic,sorting,algorithm,c# |>\nThis question was\
    \ asked long before C++11 and even before C++20, but I wanted to provide an answer\
    \ in case someone comes across this question with other languages/programming\
    \ languages.\nIn C++, there is the is_sorted function in <algorithm> that checks\
    \ if a container is sorted:\n<code>\n#include <algorithm>\n#include <iostream>\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcz5gle2b.d(26): Error: declaration expected, not `<`

    /tmp/tmpcz5gle2b.d(29): Error: unterminated character constant

    /tmp/tmpcz5gle2b.d(53): Error: declaration expected, not `assert`

    /tmp/tmpcz5gle2b.d(54): Error: declaration expected, not `assert`

    /tmp/tmpcz5gle2b.d(55): Error: declaration expected, not `assert`

    /tmp/tmpcz5gle2b.d(56): Error: declaration expected, not `assert`

    /tmp/tmpcz5gle2b.d(57): Error: declaration expected, not `assert`

    /tmp/tmpcz5gle2b.d(58): Error: declaration expected, not `assert`

    /tmp/tmpcz5gle2b.d(59): Error: declaration expected, not `assert`

    /tmp/tmpcz5gle2b.d(60): Error: declaration expected, not `assert`

    /tmp/tmpcz5gle2b.d(61): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcz5gle2b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length\
    \ <= 1) \n\t\treturn true;\n\tauto i = 1;\n\tauto j = l.length - 2;\n\twhile (i\
    \ <= j) \n\t{\n\t\tauto mid = (i + j) >> 1;\n\t\tif (l[mid] > l[i]) \n\t\t\tj\
    \ = mid;\n\t\telse if (l[mid] < l[i]) \n\t\t\ti = mid + 1;\n\t\telse \n\t\t\t\
    return true;\n\t}\n\treturn false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphh_kefo4.d(25): Error: cannot implicitly convert expression `mid
    + 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphh_kefo4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long[]\
    \ h = new long[l.length];\n    long mn = l[0], mx = l[0], mnI = 0, mxI = 0;\n\
    \    for (int i = 1; i < l.length; i++) \n    {\n        long v = l[i];\n    \
    \    long k = h[v];\n        if (k == 0) \n        {\n            h[v] = i;\n\
    \        }\n        else \n        {\n            if (k < i) \n            {\n\
    \                mnI = i;\n                mn = 0;\n            }\n          \
    \  mx = v;\n            mxI = i;\n        }\n    }\n    if (mn == 0) \n    {\n\
    \        return true;\n    }\n    long m = mn, M = mx, Mi = mn, MxI = mn, Mx =\
    \ 0;\n    for (int i = 0; i < l.length; i++) \n    {\n        long v = l[i];\n\
    \        long k = h[v];\n        if (k != i) \n        {\n            if (k <\
    \ i) \n            {\n                Mi = i;\n                MxI = i;\n    \
    \            Mx = 0;\n            }\n            else\n            {\n       \
    \         M = v;\n                MxI = i;\n                Mx = v;\n        \
    \    }\n        }\n    }\n    long n = 0;\n    for (int i = l.length - 1; i >=\
    \ 0; i--) \n    {\n        long v = l[i];\n        long k = h[v];\n        if\
    \ (k != i) \n        {\n            if (k < i) \n            {\n             \
    \   n = 1;\n            }\n            else\n            {\n                if\
    \ (MxI > i) \n                {\n                    MxI = i;\n              \
    \  }\n            }\n        }\n        else\n        {\n            if (MxI >\
    \ i) \n            {\n                n = 1;\n            }\n            else\n\
    \            {\n                M = v;\n                MxI = i;\n           \
    \     Mx = v;\n            }\n        }\n    }\n    if (n == 0) \n    {\n    \
    \    return false;\n    }\n    boolean ok = true;\n    if (MxI < mxI) \n    {\n\
    \        ok = false;\n    }\n    return ok;\n}\n</code>\n<|/ a |>\n<| a tags=list,search,algorithm,c#\
    \ |>\n<code>\npublic class IntList\n{\n    public int Min { get; private set;\
    \ }\n    public int Max { get; private set; }\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjxca3968.d(105): Error: declaration expected, not `<`

    /tmp/tmpjxca3968.d(111): Error: no identifier for declarator `set`

    /tmp/tmpjxca3968.d(111): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjxca3968.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i;\n\
    \    if (l[0] == 0L) return true; // no elements are less than or equal to 0\n\
    \    i = 1;\n    while (i < l.length) \n    {\n        if (l[i-1] > l[i]) \n \
    \           return false;\n        i++;\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpui83xemw.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x42830d]

    ??:? void tmpui83xemw.__unittest_L26_C1() [0x427f0d]

    ??:? void tmpui83xemw.__modtest() [0x428090]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c38f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b222]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430864]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430341]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]

    ??:? runModuleUnitTests [0x42c165]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287d0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for (int\
    \ i = 0; i < l.length-1; ++i) {\n        if (l[i+1] < l[i]) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpkt3mjsg3.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282f5]

    ??:? void tmpkt3mjsg3.__unittest_L22_C1() [0x427ef1]

    ??:? void tmpkt3mjsg3.__modtest() [0x428074]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c377]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b20a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43039d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43084c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430329]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e1]

    ??:? runModuleUnitTests [0x42c14d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287b8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint i, n\
    \ = (int)l.length;\n\tif (n < 2) return true;\n\tif (n < 4) return true;\n\tfor\
    \ (i = 1; i < n - 1; i++) \n\t\tif (l[i] < l[i - 1]) return false;\n\treturn true;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ghhn93l.d(15): Error: C style cast illegal, use `cast(int)l.length`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ghhn93l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for (int\
    \ i = 0; i < l.length; ++i) {\n        if (l[i] < l[i - 1]) \n            return\
    \ false;\n        if (l[i] > l[i + 1]) \n            return true;\n    }\n   \
    \ return true;\n}\n</code>\n<|/ a |>\n<| a tags=python,algorithm |>\nI realize\
    \ this is an old question, but I came across it while searching for an increasing\
    \ subsequence problem in Python, so I thought I would share my solution here in\
    \ case it helps anyone.\nI created an increasing subsequence function using the\
    \ bisect library (available on PyPi as bisect). The function takes an array and\
    \ returns the indices of increasing subsequences of length 1. Here is the function:\n\
    <code>\ndef increasing_subsequence(array):\n    indices = []\n    \n    \n   \
    \ for i, element in enumerate(array):\n        low = i\n        while low < len(array)\
    \ and array[low] <= element:\n            low += 1\n        indices.append(low)\n\
    \        \n        if i == low:\n            return indices\n            \n  \
    \      upper = i\n        while upper < len(array) and array[upper] >= element:\n\
    \            upper -= 1\n        indices.append(upper)\n    \n    return indices\n\
    </code>\nHope this is helpful!\n<|/ a dscore=2 |>\n<| a tags=python,algorithm\
    \ |>\nHere's my solution in JavaScript that works pretty well:\n<code>\nfunction\
    \ monotonic(a) {\n    var result = 0;\n    var current = 0;\n    for (var i =\
    \ 0; i < a.length; i++) {\n        if (a[i] > current) {\n            result++;\n\
    \            current = 0;\n        } else if (a[i] < current) {\n            result--;\n\
    \        }\n        current = a[i];\n    }\n    return (result == 0);\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nIf this answer is what you were looking for, then\
    \ you should accept it so others can see it works and also upvote it if you want.\n\
    <|/ c |>\n<| a |>\nI believe this is a very interesting problem. My solution relies\
    \ on Python's sorted data structure and Python slices:\n<code>\ndef monotonic(seq):\n\
    \    return seq == sorted(seq)[0:len(seq) - 1]\n</code>\n<|/ a dscore=1 tags=python,algorithm\
    \ |>\n<| c |>\nThat works fine if you only need `monotonic` for a single sequence.\
    \ How about if you wanted a function that works for any sequence? This wouldn't\
    \ be possible with this solution.\n<|/ c |>\n<| c |>\n- That's a good point, but\
    \ I do think it still works well for many sequences. If you want a function that\
    \ works for any sequence, you'll need a recursive solution.\n<|/ \nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9l_t_lfm.d(23): Error: declaration expected, not `<`

    /tmp/tmp9l_t_lfm.d(52): Error: unterminated character constant

    /tmp/tmp9l_t_lfm.d(57): Error: declaration expected, not `for`

    /tmp/tmp9l_t_lfm.d(57): Error: no identifier for declarator `i`

    /tmp/tmp9l_t_lfm.d(57): Error: declaration expected, not `<`

    /tmp/tmp9l_t_lfm.d(57): Error: no identifier for declarator `i`

    /tmp/tmp9l_t_lfm.d(57): Error: declaration expected, not `++`

    /tmp/tmp9l_t_lfm.d(60): Error: no identifier for declarator `current`

    /tmp/tmp9l_t_lfm.d(60): Error: declaration expected, not `=`

    /tmp/tmp9l_t_lfm.d(61): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9l_t_lfm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n\
    \ = l.Length;\n    if(n == 0) return true;\n    if(n < 2) return false;\n    long\
    \ last = l[n - 1];\n    int i = 0;\n    for(; i < n - 2; i++) \n    {\n      \
    \  if(l[i] > last) break;\n        last = l[i];\n    }\n    if(i == n - 2) return\
    \ true;\n    if(l[i] < last) \n    {\n        for(int j = i + 1; j < n; j++) \n\
    \        {\n            if(l[j] > l[i]) return true;\n        }\n        return\
    \ false;\n    }\n    return false;\n}\n</code>\n<|/ a |>\n<| c |>\nWhat about\
    \ this case? monotonic([1L, 2L, 3L, 4L, 2L, 3L, 4L, 2L, 3L, 4L, 5L]) ? The answer\
    \ is false\n<|/ c |>\n<| c |>\nGood catch!  I fixed the code so it doesn't go\
    \ over the edge of the array.\n<|/ c |>\n<| a dscore=3 tags=algorithm,c# |>\n\
    I assume you mean the most efficient algorithm.\nI wrote a little C# program to\
    \ test it. In fact, I just ran it with LinqPad to check the result.\n<code>\n\
    // from http://codereview.stackexchange.com/questions/57468/c-program-to-determine-whether-an-large-array-is-monotonically-inceasing-or-deceasing\n\
    static bool IsMonotonic(int[] arr)\n{\n    int N = arr.Length;\n    if (N < 2)\
    \ return true;\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpghdtvq3d.d(36): Error: declaration expected, not `<`

    /tmp/tmpghdtvq3d.d(42): Error: unterminated character constant

    /tmp/tmpghdtvq3d.d(52): Error: declaration expected, not `if`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpghdtvq3d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int m\
    \ = 0;\n    int n = l.length - 1;\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyap2u6sx.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyap2u6sx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  return std.typecons.lessThan(l,\
    \ std.sort(std.copy(l)));\n}\n/// Returns true if array elements are monotonically\
    \ increasing or decreasing.\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjm10bm1k.d(15): Error: undefined identifier `lessThan` in module
    `std.typecons`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjm10bm1k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjj0rqe1f.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjj0rqe1f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    \n   \
    \ int m = l.length - 1;\n    bool result = false;\n    int left = l[m];\n    int\
    \ right = l[m+1];\n    \n    while (m >= 0)\n    {\n        if (left > right)\n\
    \        {\n            result = true;\n            break;\n        }\n      \
    \  if (l[m] < l[m-1])\n        {\n            left++;\n        }\n        else\n\
    \        {\n            right--;\n        }\n        m--;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nGreat solution and very intuitive! I'd\
    \ add that one can use \"bool result = left < right\" instead of the while loop.\
    \ The compiler might optimize it the same way, but just to be safe.\n<|/ c |>\n\
    <| c |>\nAs an aside, since you are dealing with strictly monotonic lists, you\
    \ could use `if(l[m] >= l[m-1])` (note the order comparison)\n<|/ c |>\n<| a tags=c#,math,list\
    \ dscore=2 |>\nThe other answers don't quite work in my case. \n<code>\npublic\
    \ static bool IsMonotonic(this IList<long> list)\n    {\n        var list = list.OrderByDescending(a\
    \ => a);\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpesesr6xf.d(40): Error: declaration expected, not `<`

    /tmp/tmpesesr6xf.d(43): Error: unterminated character constant

    /tmp/tmpesesr6xf.d(49): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpesesr6xf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n\
    \ = l.length-1;\n    if (l[n] > l[n+1])\n        return false;\n    for (int i\
    \ = 0; i < n; i++) {\n        if (l[i] > l[i+1])\n            return false;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6mgr6w9f.d(15): Error: cannot implicitly convert expression `l.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6mgr6w9f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n\
    \ = l.Length;\n    long a = l[n-1];\n    for (int i = 0; i < n; ++i)\n    {\n\
    \        if (l[i] < a)\n            return false;\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a |>\nFor some reason I got some downvotes on this\
    \ but after reading through some more I think my answer was really good. I'm assuming\
    \ you want something more general than just increasing or decreasing but I'll\
    \ still post it anyway in case it's helpful to anyone else.\nFor example if your\
    \ array was this:\n<code>\n[4, 6, 5, 8, 3]\n</code>\nYour answer would return\
    \ true because 6 is greater than 4 but less than 5.\nAnd if your array was this:\n\
    <code>\n[4, 6, 5, 8, 7, 3]\n</code>\nYour answer would return false because 6\
    \ is greater than 4 but less than 5.\nThis code does exactly that:\n<code>\nfunction\
    \ bool IncreasingOrDecreasing(int[] arr) {\n    bool ret = false;\n    foreach\
    \ (int i in arr) {\n        for (int j = 0; j < arr.Length; j++) {\n         \
    \   if (j != i)\n                if (arr[j] > arr[j + 1])\n                  \
    \  ret = true;\n            }\n        }\n        return ret;\n    }\n</code>\n\
    <|/ a tags=algorithm,c# dscore=2 |>\n<| a |>\nThis is an old thread but I wanted\
    \ to add another option if you were dealing with float arrays instead of ints.\
    \ \nMy goal was to identify if the input array was monotonic or not, and I did\
    \ not want to deal with comparing each element with each other element. I wanted\
    \ to create a method that would determine if the array was monotonic or not.\n\
    <code>\npublic class MonotonicComparer<T> : IEqualityComparer<T>\n{\n    public\
    \ bool Equals(T x, T y)\n    {\n        return Math.Abs(x - y) <= 0.00000000001f;\n\
    \    }\n    public int GetHashCode(T obj)\n    {\n        return 0;\n    }\n}\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdm_lza48.d(24): Error: declaration expected, not `<`

    /tmp/tmpdm_lza48.d(27): Error: unterminated character constant

    /tmp/tmpdm_lza48.d(27): Error: unterminated character constant

    /tmp/tmpdm_lza48.d(27): Error: unterminated character constant

    /tmp/tmpdm_lza48.d(42): Error: declaration expected, not `foreach`

    /tmp/tmpdm_lza48.d(43): Error: no identifier for declarator `j`

    /tmp/tmpdm_lza48.d(43): Error: declaration expected, not `<`

    /tmp/tmpdm_lza48.d(43): Error: no identifier for declarator `j`

    /tmp/tmpdm_lza48.d(43): Error: declaration expected, not `++`

    /tmp/tmpdm_lza48.d(47): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdm_lza48.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    ulong\
    \ first=0, last=0;\n    ulong maxi=0;\n    ulong mini=0;\n    bool is_sorted =\
    \ false;\n    foreach(ulong e in l) {\n        if (is_sorted) {\n            last\
    \ = e;\n        } else {\n            is_sorted = true;\n            first  =\
    \ e;\n        }\n        \n        if (e < first) {\n            mini = e;\n \
    \       } else if (e > last) {\n            maxi = e;\n        }\n    }\n    if\
    \ (maxi-mini > 0) {\n        if (maxi == mini) {\n            return true;\n \
    \       } else if (maxi > mini) {\n            return false;\n        }\n    }\n\
    \    if (maxi != 0) {\n        return maxi > mini;\n    }\n    return false;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplc64uflw.d(19): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplc64uflw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    var x\
    \ = l[0], y = l[0], z = l[0];\n    var i = 0;\n    while(i < l.length) {\n   \
    \     var k = i;\n        for(var j = i+1; j < l.length; j++) {\n            if(l[k]\
    \ <= l[j]) {\n                k = j;\n            }\n        }\n        if(k -\
    \ i == 1) {\n            if(x < l[k]) {\n                x = l[k];\n         \
    \   }\n        } else if(k - i == -1) {\n            if(y < l[k]) {\n        \
    \        y = l[k];\n            }\n        }\n        i++;\n    }\n    return\
    \ x != l[0] && y != l[0];\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxomk2w69.d(15): Error: undefined identifier `var`

    /tmp/tmpxomk2w69.d(15): Error: undefined identifier `var`

    /tmp/tmpxomk2w69.d(15): Error: undefined identifier `var`

    /tmp/tmpxomk2w69.d(16): Error: undefined identifier `var`

    /tmp/tmpxomk2w69.d(18): Error: undefined identifier `var`

    /tmp/tmpxomk2w69.d(19): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxomk2w69.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ monotonic(l, l.length-1);\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq1z7kxo4.d(15): Error: function `tmpq1z7kxo4.monotonic(long[] l)`
    is not callable using argument types `(long[], ulong)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq1z7kxo4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.Length\
    \ < 2) return true;\n    int cmp = long.MaxValue;\n    for (int i = 1; i < l.Length;\
    \ i++)\n    {\n        cmp = long.MinValue.Compare(l[i], l[i - 1]);\n        if\
    \ (cmp != 0) return false;\n    }\n    return true;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp90wte8cs.d(15): Error: no property `Length` for type `long[]`

    /tmp/tmp90wte8cs.d(16): Error: no property `MaxValue` for type `long`

    /tmp/tmp90wte8cs.d(17): Error: no property `Length` for type `long[]`

    /tmp/tmp90wte8cs.d(19): Error: no property `MinValue` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp90wte8cs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length==0)\
    \ \n\t\treturn true;\n\tlong prev = l[0];\n\tfor (int i=1; i<l.length; ++i)\n\t\
    {\n\t\tif (l[i]<prev)\n\t\t\treturn false;\n\t\tprev = l[i];\n\t}\n\treturn true;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo_fc6ur6.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x42831d]

    ??:? void tmpo_fc6ur6.__unittest_L26_C1() [0x427f1d]

    ??:? void tmpo_fc6ur6.__modtest() [0x4280a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c39f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b232]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303c5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430874]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430351]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b209]

    ??:? runModuleUnitTests [0x42c175]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287e0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  if (l.length\
    \ == 0) return true;\n  bool first = true;\n  for (auto element : l) {\n    if\
    \ (!first) \n    {\n      if (element > l[i - 1]) return false;\n    }\n    else\n\
    \    {\n      if (element < l[i - 1]) return false;\n    }\n    first = false;\n\
    \  }\n  return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n   \
    \ assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg6kx_ge6.d(17): Error: no identifier for declarator `element`

    /tmp/tmpg6kx_ge6.d(17): Error: expression expected, not `:`

    /tmp/tmpg6kx_ge6.d(17): Error: found `l` when expecting `;` following `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg6kx_ge6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i,\
    \ j, k, l;\n    long x;\n    bool b;\n    long max, min;\n    long ans;\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplljc6uq9.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplljc6uq9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tbool result\
    \ = true;\n\tint i = 0;\n\twhile(i < l.length - 1 && l[i] > l[i+1]) ++i;\n\tif(i\
    \ < l.length - 1 && l[i] < l[i+1]) result = false;\n\telse {\n\t\ti = 0;\n\t\t\
    while(i < l.length - 1 && l[i] < l[i+1]) ++i;\n\t\tif(i < l.length - 1 && l[i]\
    \ > l[i+1]) result = false;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpl0cmfsid.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x42843d]

    ??:? void tmpl0cmfsid.__unittest_L26_C1() [0x427f50]

    ??:? void tmpl0cmfsid.__modtest() [0x4281bc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b352]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304e5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430994]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430471]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b329]

    ??:? runModuleUnitTests [0x42c295]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428900]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  if(l.length<=2)\n\
    \    return true;\n  bool res = true;\n  for(int i=0; i<l.length-1; ++i)\n  {\n\
    \    if(l[i]>l[i+1])\n      res = false;\n  }\n  return res;\n}\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhbl6q5_.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282fd]

    ??:? void tmpnhbl6q5_.__unittest_L25_C1() [0x427ef9]

    ??:? void tmpnhbl6q5_.__modtest() [0x42807c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c37f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b212]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430854]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430331]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]

    ??:? runModuleUnitTests [0x42c155]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint i =\
    \ 0;\n\tint j = l.length - 1;\n\twhile (i < j) \n\t{\n\t\tif (l[i] <= l[j])\n\t\
    \t\ti++;\n\t\telse\n\t\t\tj--;\n\t}\n\treturn (i < j);\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl50ekd7s.d(16): Error: cannot implicitly convert expression `l.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl50ekd7s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long last\
    \ = l[0];\n    bool increasing = true;\n    for (int i = 1; i < l.length; ++i)\
    \ {\n        long current = l[i];\n        if (current > last) {\n           \
    \ increasing = false;\n        } else {\n            last = current;\n       \
    \ }\n    }\n    return increasing;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjmfwh9i_.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282f5]

    ??:? void tmpjmfwh9i_.__unittest_L27_C1() [0x427e08]

    ??:? void tmpjmfwh9i_.__modtest() [0x428074]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c377]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b20a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43039d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43084c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430329]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e1]

    ??:? runModuleUnitTests [0x42c14d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287b8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long i\
    \ = 1;\n    long j = -1;\n    while (i<l.length && j>0) {\n        long k = l[i];\n\
    \        if (k < l[j]) {\n            if (k == l[j]) return false;\n        }\n\
    \        if (k > l[j]) {\n            if (k == l[j]) return true;\n        }\n\
    \        j--;\n        i++;\n    }\n    return (i==l.length);\n}\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpaeseybng.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x428395]

    ??:? void tmpaeseybng.__unittest_L30_C1() [0x427eac]

    ??:? void tmpaeseybng.__modtest() [0x428118]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c417]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2aa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43043d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308ec]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303c9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b281]

    ??:? runModuleUnitTests [0x42c1ed]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428858]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) return true;\n    if (l.length == 1) return l[0] == l[1];\n    \n    long\
    \ max = l[0];\n    for (long i = 1; i < l.length; i++)\n    {\n        if (max\
    \ < l[i]) return false;\n        max = l[i];\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnlucgpn4.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x42836d]

    ??:? void tmpnlucgpn4.__unittest_L26_C1() [0x427e80]

    ??:? void tmpnlucgpn4.__modtest() [0x4280ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b282]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430415]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308c4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303a1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b259]

    ??:? runModuleUnitTests [0x42c1c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428830]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tuint i =\
    \ 0;\n\tuint j = 0;\n\tlong prev = l[0];\n\tbool incr = true;\n\tfor(; i < l.length\
    \ && l[i] >= prev; prev = l[i], incr = !incr) {\n\t\tif(incr) j++;\n\t\telse j--;\n\
    \t}\n\treturn i > j;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n   \
    \ assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164508
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  bool result\
    \ = true;\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnobrtjg_.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnobrtjg_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    // O(n^2)\
    \ naive algorithm \n    int max = l.length - 1;\n    for (int i = 0; i < max;\
    \ ++i) {\n        for (int j = i + 1; j <= max; ++j) {\n            if (l[i] <\
    \ l[j]) {\n                return true;\n            }\n            if (l[i] >\
    \ l[j]) {\n                return false;\n            }\n        }\n    }\n  \
    \  return false;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is not monotonic. Consider\
    \ for example `monotonic([1, 2, 3])`. Returns `true` which is wrong.\n<|/ c |>\n\
    <| c |>\n: You are right. There was a bug on the last `for` loop condition. It\
    \ has been fixed.\n<|/ c |>\n<| c |>\nA little bit slower than my version, but\
    \ you get my vote :)\n<|/ c |>\n<| a dscore=1 |>\nHere is a simple and fast solution:\n\
    <code>\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu9k3qoi9.d(29): Error: declaration expected, not `<`

    /tmp/tmpu9k3qoi9.d(47): Error: declaration expected, not `assert`

    /tmp/tmpu9k3qoi9.d(48): Error: declaration expected, not `assert`

    /tmp/tmpu9k3qoi9.d(49): Error: declaration expected, not `assert`

    /tmp/tmpu9k3qoi9.d(50): Error: declaration expected, not `assert`

    /tmp/tmpu9k3qoi9.d(51): Error: declaration expected, not `assert`

    /tmp/tmpu9k3qoi9.d(52): Error: declaration expected, not `assert`

    /tmp/tmpu9k3qoi9.d(53): Error: declaration expected, not `assert`

    /tmp/tmpu9k3qoi9.d(54): Error: declaration expected, not `assert`

    /tmp/tmpu9k3qoi9.d(55): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu9k3qoi9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif(l.length==1)\
    \ return false;\n\tlong first=l[0], last=l[0];\n\tbool found=false;\n\tfor(long\
    \ i=1;i<l.length;++i) {\n\t\tif(i<l.length-1 && (first<l[i+1] || first==l[i+1]\
    \ && last>l[i])) {\n\t\t\tlast=l[i];\n\t\t\tfound=true;\n\t\t}\n\t\tfirst=l[i];\n\
    \t}\n\treturn found;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n   \
    \ assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyih35auv.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x4283dd]

    ??:? void tmpyih35auv.__unittest_L27_C1() [0x427f8f]

    ??:? void tmpyih35auv.__modtest() [0x428160]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c45f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430485]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430934]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430411]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2c9]

    ??:? runModuleUnitTests [0x42c235]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4288a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool b\
    \ = true;\n    for(int i=0;i<l.length;i++) {\n        if(l[i] <= l[i-1]) {\n \
    \           b = false;\n        }\n    }\n    return b;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpisnbjala.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42838e]

    ??:? bool tmpisnbjala.monotonic(long[]) [0x427d71]

    ??:? void tmpisnbjala.__unittest_L23_C1() [0x427ddd]

    ??:? void tmpisnbjala.__modtest() [0x428060]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c35f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430385]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430834]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430311]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c9]

    ??:? runModuleUnitTests [0x42c135]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ == 0)\n        return true;\n    long last = 0;\n    long min = l[0];\n    for\
    \ (int i = 1; i < l.length; i++)\n    {\n        if (l[i] > last)\n          \
    \  return false;\n        if (l[i] < min)\n        {\n            min = l[i];\n\
    \            last = l[i];\n        }\n    }\n    return true;\n}\n/* Given an\
    \ array of monotonically increasing or decreasing numbers,\nreturn its median.\n\
    \    \nIf there are an even number of elements, then the median is the average\
    \ of the two.\nIf there are an odd number of elements, then the median is the\
    \ middle one.\n */\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzmyp23l_.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x42837d]

    ??:? void tmpzmyp23l_.__unittest_L37_C1() [0x427e90]

    ??:? void tmpzmyp23l_.__modtest() [0x4280fc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b292]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430425]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308d4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303b1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b269]

    ??:? runModuleUnitTests [0x42c1d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428840]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong last\
    \ = l[0];\n\tbool hasFirst = false, hasLast = false;\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsyni20oi.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsyni20oi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint i =\
    \ (int) length(l) - 1;\n\twhile(i > 0)\n\t{\n\t\tif(l[i] > l[i-1]) return false;\n\
    \t\ti--;\n\t}\n\treturn true;\n}\n/*\nReturn true is array elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n\
    \    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L,\
    \ 0L, -10L])\n    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpolhnhsho.d(15): Error: C style cast illegal, use `cast(int)length(l)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpolhnhsho.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  int i;\n\
    \  bool flag;\n  bool inc;\n  bool dec;\n  long last = 0;\n  for (i = 1; i < l.length;\
    \ i++) {\n    if (l[i] < last)\n      continue;\n    if (l[i] > last) {\n    \
    \  flag = false;\n      inc = false;\n      dec = true;\n      break;\n    }\n\
    \  }\n  for (last = 0; !flag; last = l[l.length - 1]) {\n    flag = true;\n  \
    \  for (i = 1; i < l.length; i++) {\n      if (l[i] <= last) {\n        flag =\
    \ false;\n        inc = true;\n      }\n      else {\n        inc = false;\n \
    \     }\n      if (l[i] >= last) {\n        dec = true;\n      }\n      else {\n\
    \        dec = false;\n      }\n    }\n    if (inc) {\n      if (dec)\n      \
    \  return true;\n    }\n    else {\n      if (dec)\n        return false;\n  \
    \  }\n  }\n  return false;\n}\n/*\nReturn true if array elements are sorted increasing\
    \ or decreasing.\n    >>> monotonic_down([1L, 2L, 4L, 20L])\n    true\n    >>>\
    \ monotonic_down([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic_down([4L, 1L,\
    \ 0L, -10L])\n    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1fcgr8a5.d(72): unittest failure

    ----------------

    ??:? _d_unittestp [0x4283fd]

    ??:? void tmp1fcgr8a5.__unittest_L68_C1() [0x427f14]

    ??:? void tmp1fcgr8a5.__modtest() [0x428180]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c47f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b312]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430954]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430431]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2e9]

    ??:? runModuleUnitTests [0x42c255]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4288c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for (int\
    \ i = 0; i < l.length-1; ++i)\n    {\n        if (l[i] > l[i+1]) return false;\n\
    \    }\n    return true;\n}\n'''\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvmtd8qwz.d(21): Error: unterminated character constant

    /tmp/tmpvmtd8qwz.d(21): Error: declaration expected, not `63U`

    /tmp/tmpvmtd8qwz.d(21): Error: unterminated character constant

    /tmp/tmpvmtd8qwz.d(26): Error: declaration expected, not `assert`

    /tmp/tmpvmtd8qwz.d(27): Error: declaration expected, not `assert`

    /tmp/tmpvmtd8qwz.d(28): Error: declaration expected, not `assert`

    /tmp/tmpvmtd8qwz.d(29): Error: declaration expected, not `assert`

    /tmp/tmpvmtd8qwz.d(30): Error: declaration expected, not `assert`

    /tmp/tmpvmtd8qwz.d(31): Error: declaration expected, not `assert`

    /tmp/tmpvmtd8qwz.d(32): Error: declaration expected, not `assert`

    /tmp/tmpvmtd8qwz.d(33): Error: declaration expected, not `assert`

    /tmp/tmpvmtd8qwz.d(34): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvmtd8qwz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int m\
    \ = l.length;\n    int i = 0;\n    int j = 0;\n    for(int n=0;n<m;n++)\n    {\n\
    \        if(l[n] > l[n+1])\n        {\n            if(l[n] > l[i])\n         \
    \   {\n                return true;\n            }\n            else\n       \
    \     {\n                return false;\n            }\n        }\n        if(l[n]\
    \ < l[i])\n        {\n            if(l[n] < l[j])\n            {\n           \
    \     return true;\n            }\n            else\n            {\n         \
    \       return false;\n            }\n        }\n        i++;\n        j++;\n\
    \    }\n    return false;\n}\n</code>\n<|/ a dscore=4 tags=arrays,sorting,algorithm,c++,javascript\
    \ |>\n<| a dscore=4 |>\n<code>\npublic static bool IsMonotonic(this List<long>\
    \ list, int direction)\n{\n    if(direction == 1)\n        return list.OrderBy(i\
    \ => i).SequenceEqual(list.Reverse());\n    else\n        return list.OrderByDescending(i\
    \ => i).SequenceEqual(list.Reverse());\n}\n</code>\n<|/ a tags=arrays,sorting,algorithm,c++,javascript\
    \ |>\n<| c |>\nFor those who don't know what `SequenceEqual` does. it checks if\
    \ the two sequences are equal in length and the same elements at the same position.\
    \ `1` will never be compared to `10` so this checks that both sequences are equal\
    \ in order. `10` will never be compared to `1` so this checks that the second\
    \ sequence is equal in order and in the same order as the first sequence. `IsMonotonic([1,2,3,4,5])`\
    \ will always return `true` because `SequenceEqual` will return `true` for both\
    \ sequences that are equal in length.\n<|/ c |>\n<| c |>\nThis is the best answer\
    \ so far. Thanks very much!\n<|/ c |>\n<| a dscore=3 |>\nSort the array in O(N\
    \ log N)\nIf the length of the array is even, check that every even item is lower\
    \ than the one before it (same for odd lengths).\nIf the length of the array is\
    \ odd, check that the odd item is lower than the one after it.\nIf the length\
    \ of the array is even, then check that the even item is lower than the one before\
    \ it.\nIf even and odd lengths match, then the array is monotonic\n<|/ a tags=arrays,sorting,algorithm,c++,javascript\
    \ |>\n<| c |>\nThis fails for `1, 2, 5, 4`. It should be `1, 2, 4, 5`.\n<|/ c\
    \ |>\n<| c |>\n: I think the example is wrong. `1, 2, 5, 4` \nunittest\n{\n  \
    \  alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplj96z1tu.d(47): Error: declaration expected, not `<`

    /tmp/tmplj96z1tu.d(55): Error: declaration expected, not `else`

    /tmp/tmplj96z1tu.d(57): Error: unrecognized declaration

    /tmp/tmplj96z1tu.d(61): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplj96z1tu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tbool r =\
    \ true;\n\tlong xl = l[0];\n\tlong xr = l[0];\n\tfor (int i = 1; i < l.length;\
    \ i++) {\n\t\tif (l[i] < xl) {\n\t\t\tr = false;\n\t\t}\n\t\tif (l[i] > xr) {\n\
    \t\t\tr = true;\n\t\t}\n\t\tif (r == false) {\n\t\t\txr = l[i];\n\t\t}\n\t\tif\
    \ (r == true) {\n\t\t\txl = l[i];\n\t\t}\n\t}\n\treturn r;\n}\nunittest\n{\n \
    \   alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnbuhe673.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x42839d]

    ??:? void tmpnbuhe673.__unittest_L34_C1() [0x427f4b]

    ??:? void tmpnbuhe673.__modtest() [0x42811c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c41f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2b2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430445]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303d1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b289]

    ??:? runModuleUnitTests [0x42c1f5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428860]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n   long min\
    \ = l[0], max = l[0];\n   for (int i = 1; i < l.length; i++)\n   {\n      if (l[i]\
    \ < min)\n      {\n         min = l[i];\n      }\n      else if (l[i] > max)\n\
    \      {\n         max = l[i];\n      }\n   }\n   return (min <= max);\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp3tjz1x20.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x42838d]

    ??:? void tmp3tjz1x20.__unittest_L29_C1() [0x427f3b]

    ??:? void tmp3tjz1x20.__modtest() [0x42810c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c40f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2a2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430435]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308e4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303c1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b279]

    ??:? runModuleUnitTests [0x42c1e5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428850]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l==null)\n\
    \t\treturn false;\n\tif (l.length==0)\n\t\treturn true;\n\t\n\tbool leftmost=\
    \ l[0] < l[1];\n\tbool rightmost= l[0] > l[1];\n\t\n\tfor (int i=0;i<l.length-1;\
    \ i+=2)\n\t{\n\t\tbool thisLeft= l[i] < l[i+1];\n\t\tbool thisRight= l[i] > l[i+1];\n\
    \t\tbool right= thisLeft && thisRight;\n\t\tbool left= !(thisLeft || thisRight);\n\
    \t\t\n\t\tbool thisLeftM= rightmost;\n\t\tbool thisRightM= leftmost;\n\t\t\n\t\
    \tif (right)\n\t\t{\n\t\t\tif (leftmost) \n\t\t\t\tthisLeftM=false;\n\t\t\telse\n\
    \t\t\t\tthisRightM=false;\n\t\t}\n\t\t\n\t\tif (left)\n\t\t{\n\t\t\tif (rightmost)\
    \ \n\t\t\t\tthisLeftM=false;\n\t\t\telse\n\t\t\t\tthisRightM=false;\n\t\t}\n\t\
    \t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tbool leftMinusRight=thisLeftM;\n\t\tbool\
    \ rightMinusLeft=thisRightM;\n\t\tif (right) \n\t\t{\n\t\t\trightMinusLeft=!leftMinusRight;\n\
    \t\t}\n\t\t\n\t\tif (left) \n\t\t{\n\t\t\tleftMinusRight=!rightMinusLeft;\n\t\t\
    }\n\t\t\n\t\t\n\t\tif (leftMinusRight && rightMinusLeft)\n\t\t\treturn true;\n\
    \t\telse if (!leftMinusRight && !rightMinusLeft)\n\t\t\treturn false;\n\t}\n\t\
    return false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp73i0vwk_.d(78): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmp73i0vwk_.__unittest_L74_C1() [0x427fe4]

    ??:? void tmp73i0vwk_.__modtest() [0x428250]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c54f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3e2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430575]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430a24]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430501]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]

    ??:? runModuleUnitTests [0x42c325]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool monotonic\
    \ = false;\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpydeleq48.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpydeleq48.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length\
    \ < 2)\n\t\treturn false;\n\tlong last = l[0];\n\tlong mid = l[1];\n\tfor (int\
    \ i = 2; i < l.length; ++i)\n\t{\n\t\tlong next = l[i];\n\t\tif (mid > next)\n\
    \t\t\treturn true;\n\t\tif (mid == next && last > next)\n\t\t\treturn false;\n\
    \t\tlast = next;\n\t\tmid = next;\n\t}\n\treturn false;\n}\nimport std.stdio;\n\
    import std.string;\nimport std.file;\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_00fgqqu.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x472b31]

    ??:? void tmp_00fgqqu.__unittest_L34_C1() [0x470cfc]

    ??:? void tmp_00fgqqu.__modtest() [0x4711cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x482eab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x47278e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4744fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x47458c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x474489]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x472765]

    ??:? runModuleUnitTests [0x482c81]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x473144]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164496
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  int N=l.length;\n\
    \  if (N<2) return true;\n  long prev=l[0];\n  for (int i=1; i<N; i++) {\n   \
    \ if (l[i]>prev) return true;\n    prev=l[i];\n  }\n  return false;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcz4ogpr6.d(15): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcz4ogpr6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long min\
    \ = l[0];\n    long max = l[0];\n    int n = l.length;\n    for (int i = 0; i\
    \ < n; i++) {\n        if (l[i] < min)\n            min = l[i];\n        if (l[i]\
    \ > max)\n            max = l[i];\n    }\n    if (min < 0)\n        min = 0;\n\
    \    if (max >= 0)\n        max--;\n    if (max - min == 0)\n        return true;\n\
    \    int m = (n + 1) >> 1;\n    int t = 0;\n    while (m >= 2) {\n        if (l[t\
    \ * 2] - l[t * 2 + 1] < min)\n            return false;\n        if (l[t * 2]\
    \ - l[t * 2 + 1] > max)\n            return false;\n        t++;\n        m >>=\
    \ 1;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp07a3ink.d(17): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp07a3ink.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length==1)\n\
    \t\treturn true;\n\tlong a = l[0], b = l[1], c = l[2];\n\tlong d = c-b;\n\tif\
    \ (d == 0) {\n\t\treturn true;\n\t}\n\tlong e = a-c;\n\tif (e < 0) {\n\t\tint\
    \ sign = 1;\n\t\ta = c;\n\t\tc = b;\n\t\tb = sign * a;\n\t\td = sign * d;\n\t\t\
    e = sign * e;\n\t}\n\tlong f = a-b;\n\tif (f < 0) {\n\t\tint sign = 1;\n\t\ta\
    \ = c;\n\t\tc = b;\n\t\tb = sign * a;\n\t\tf = sign * f;\n\t}\n\tif (f == 0) {\n\
    \t\treturn true;\n\t}\n\tif (d == d*f) {\n\t\tdouble x = std.math.abs(d);\n\t\t\
    double y = std.math.abs(f);\n\t\treturn (x>y)? true:false;\n\t} else {\n\t\treturn\
    \ false;\n\t}\n}\n/*\nReturn true if the first argument is less than the second.\n\
    \    >>> isLess(1L, 1L)\n    true\n    >>> isLess(1L, 3L)\n    false\n*/\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpv3iahsyw.d(63): unittest failure

    ----------------

    ??:? _d_unittestp [0x428455]

    ??:? void tmpv3iahsyw.__unittest_L57_C1() [0x427fef]

    ??:? void tmpv3iahsyw.__modtest() [0x4281d8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b36a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430489]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b341]

    ??:? runModuleUnitTests [0x42c2ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428918]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int len\
    \ = l.length;\n    long curr = l[0];\n    long next = l[0];\n    for (int i =\
    \ 1; i < len; i++)\n    {\n        long curr = next;\n        next = l[i];\n \
    \       if (curr > next)\n            return false;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz7z6vzsd.d(15): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    /tmp/tmpz7z6vzsd.d(20): Error: variable `curr` is shadowing variable `tmpz7z6vzsd.monotonic.curr`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz7z6vzsd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint leng\
    \ = l.Length;\n\tint lastIndex = leng-1;\n\tbool increasing = true;\n\tfor (int\
    \ i = 0; i < leng; i++)\n\t{\n\t\tif (l[i] < l[lastIndex])\n\t\t{\n\t\t\tincreasing\
    \ = false;\n\t\t}\n\t\telse if (l[i] > l[lastIndex])\n\t\t{\n\t\t\tlastIndex =\
    \ i;\n\t\t}\n\t}\n\treturn increasing;\n}\nunittest\n{\n    alias candidate =\
    \ monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsr7wxwan.d(15): Error: no property `Length` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsr7wxwan.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i,\
    \ j, k;\n    for (i = 1; i < l.length; i++)\n        if (l[i] < l[i - 1]) {\n\
    \            for (j = i; j > 0; j--)\n                if (l[j] < l[j - 1]) {\n\
    \                    return false;\n                }\n            break;\n  \
    \      }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpswhm_8av.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x428355]

    ??:? void tmpswhm_8av.__unittest_L26_C1() [0x427f51]

    ??:? void tmpswhm_8av.__modtest() [0x4280d4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b26a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430389]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b241]

    ??:? runModuleUnitTests [0x42c1ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428818]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong prev\
    \ = l[0];\n\tfor (long i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < prev) return\
    \ true;\n\t\telse if (l[i] > prev) return false;\n\t\tprev = l[i];\n\t}\n\treturn\
    \ true;\n}\n/* \n    \n*/\nlong[] monotonic(long[] l) \n{\n\tlong[] ret = new\
    \ long[l[l.length-1] + 1];\n\tint i = 0;\n\tret[i] = l[0];\n\tint j = 0;\n\tfor\
    \ (long k = 1; k < l.length; k++) \n\t{\n\t\tif (l[k] < l[j]) \n\t\t{\n\t\t\t\
    ret[i] = l[k];\n\t\t\ti++;\n\t\t\tj++;\n\t\t} \n\t\telse if (l[k] > l[j]) \n\t\
    \t{\n\t\t\tret[i] = l[k];\n\t\t\ti++;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tret[i]\
    \ = l[j];\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n/* \n   \
    \ \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb1ssqot_.d(63): Error: `tmpb1ssqot_.monotonic` called with argument
    types `(long[])` matches both:

    /tmp/tmpb1ssqot_.d(13):     `tmpb1ssqot_.monotonic(long[] l)`

    and:

    /tmp/tmpb1ssqot_.d(27):     `tmpb1ssqot_.monotonic(long[] l)`

    /tmp/tmpb1ssqot_.d(64): Error: `tmpb1ssqot_.monotonic` called with argument types
    `(long[])` matches both:

    /tmp/tmpb1ssqot_.d(13):     `tmpb1ssqot_.monotonic(long[] l)`

    and:

    /tmp/tmpb1ssqot_.d(27):     `tmpb1ssqot_.monotonic(long[] l)`

    /tmp/tmpb1ssqot_.d(65): Error: `tmpb1ssqot_.monotonic` called with argument types
    `(long[])` matches both:

    /tmp/tmpb1ssqot_.d(13):     `tmpb1ssqot_.monotonic(long[] l)`

    and:

    /tmp/tmpb1ssqot_.d(27):     `tmpb1ssqot_.monotonic(long[] l)`

    /tmp/tmpb1ssqot_.d(66): Error: `tmpb1ssqot_.monotonic` called with argument types
    `(long[])` matches both:

    /tmp/tmpb1ssqot_.d(13):     `tmpb1ssqot_.monotonic(long[] l)`

    and:

    /tmp/tmpb1ssqot_.d(27):     `tmpb1ssqot_.monotonic(long[] l)`

    /tmp/tmpb1ssqot_.d(67): Error: `tmpb1ssqot_.monotonic` called with argument type'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long curr\
    \ = l[0], prev=curr, count = 1;\n    for (int i=1; i < l.length; i++)\n    {\n\
    \        if (curr > l[i])\n        {\n            curr = l[i];\n            prev\
    \ = l[i-1];\n            count++;\n        }\n        else if (curr < l[i])\n\
    \        {\n            return false;\n        }\n        else if (curr == prev)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a tags=algorithm,sorting,c,performance |>\n<| c |>\nWhile the solution\
    \ works fine, it doesn't help the OP understand the problem and solve it.\n<|/\
    \ c |>\n<| c |>\nYes, I agree, I will fix it.\n<|/ c |>\n<| c |>\nThe \"count\"\
    \ variable should be initialized with `1` instead of `0`.\n<|/ c |>\n<| c |>\n\
    yes, my mistake, should be 1. I am still learning programming, so forgive my mistake.\n\
    <|/ c |>\n<| c |>\nWhile this may answer the question, please also explain why\
    \ this would work and what it does.\n<|/ c |>\n<| a |>\nThis code can help you\n\
    <code>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include\
    \ <time.h>\n#include <math.h>\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy1_gh1gd.d(35): Error: declaration expected, not `<`

    /tmp/tmpy1_gh1gd.d(38): Error: unterminated character constant

    /tmp/tmpy1_gh1gd.d(64): Error: declaration expected, not `assert`

    /tmp/tmpy1_gh1gd.d(65): Error: declaration expected, not `assert`

    /tmp/tmpy1_gh1gd.d(66): Error: declaration expected, not `assert`

    /tmp/tmpy1_gh1gd.d(67): Error: declaration expected, not `assert`

    /tmp/tmpy1_gh1gd.d(68): Error: declaration expected, not `assert`

    /tmp/tmpy1_gh1gd.d(69): Error: declaration expected, not `assert`

    /tmp/tmpy1_gh1gd.d(70): Error: declaration expected, not `assert`

    /tmp/tmpy1_gh1gd.d(71): Error: declaration expected, not `assert`

    /tmp/tmpy1_gh1gd.d(72): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy1_gh1gd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  int n =\
    \ l.length-1;\n  bool left = true;\n  bool right = left; // default\n  long curr\
    \ = l[n];\n  for (int n = 0; n < l.length; n++)\n  {\n    if (curr < l[n])\n \
    \   {\n      right = false;\n      curr = l[n];\n    }\n    else if (curr > l[n])\n\
    \    {\n      left = false;\n      curr = l[n];\n    }\n  }\n  return left &&\
    \ right;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt's a nice solution, I just\
    \ tried it and it seems that it fails for cases where the first element is lower\
    \ than the second one.  e.g. monotonic([10,20,30,50]) returns false, but monotonic([10,20,30,51,60])\
    \ returns true.\n<|/ c |>\n<| c |>\nThanks for your comment and your solution!\
    \ The algorithm seems to work pretty well. However, I tested it with your example\
    \ and it doesn't work correctly in my machine. I have two questions: 1. Do you\
    \ know why? 2. Is there a way to improve the performance (for large arrays)?\n\
    <|/ c |>\n<| c |>\nI am sorry it fails for cases where the first element is lower\
    \ than the second one. e.g. monotonic([10,20,30,50]) returns false, but monotonic([10,20,30,51,60])\
    \ returns true.\n<|/ c |>\n<| c |>\n: I tested with your examples and it seems\
    \ to work correctly for me with both C# and C++.\n<|/ c |>\n<| c |>\n: Thanks\
    \ for the input. My code is working fine but I am curious about your approach.\
    \ Have you tried to modify the implementation to make it work with a large array\
    \ (say one million elements)?\n<|/ c |>\n<| a tags=sorting,java,arrays dscore=1\
    \ |>\nHere's a C# implementation using LINQ's OrderBy and ThenBy extensions:\n\
    <code>\n    static void Main(string[] args)\n    {\n        List<long> list =\
    \ new List<long>() { 7, 8, 1, 9, 2, 10 };\nunittest\n{\n    alias candidate =\
    \ monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjfmu0fp9.d(34): Error: declaration expected, not `<`

    /tmp/tmpjfmu0fp9.d(37): Error: unterminated character constant

    /tmp/tmpjfmu0fp9.d(40): Error: unterminated character constant

    /tmp/tmpjfmu0fp9.d(52): Error: unterminated character constant

    /tmp/tmpjfmu0fp9.d(52): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjfmu0fp9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  int maxi\
    \ = l[0];\n  int mini = l[0];\n  for(int i = 1; i < l.length; ++i) \n  {\n   \
    \ if(l[i] < mini) \n    {\n      mini = l[i];\n    }\n    else if(l[i] > maxi)\
    \ \n    {\n      maxi = l[i];\n    }\n  }\n  if(mini == maxi) \n  {\n    return\
    \ false;\n  }\n  else\n  {\n    return true;\n  }\n}\n</code>\nThe second function\
    \ can then be used to identify the minimum element and maximum element in an array.\n\
    <code>\nlong minElement(long[] l) \n{\n    long minL = l[0];\n    for(int i =\
    \ 1; i < l.length; ++i)\n    {\n        if(minL > l[i])\n        {\n         \
    \   minL = l[i];\n        }\n    }\n    return minL;\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv28e8gxj.d(37): Error: declaration expected, not `<`

    /tmp/tmpv28e8gxj.d(43): Error: declaration expected, not `for`

    /tmp/tmpv28e8gxj.d(43): Error: no identifier for declarator `i`

    /tmp/tmpv28e8gxj.d(43): Error: declaration expected, not `<`

    /tmp/tmpv28e8gxj.d(43): Error: declaration expected, not `++`

    /tmp/tmpv28e8gxj.d(48): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv28e8gxj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tfor(int\
    \ i = 1; i < l.length; ++i) {\n\t\tif(l[i-1] < l[i]) {\n\t\t\treturn false;\n\t\
    \t}\n\t}\n\t\n\treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp86eaolxm.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282f5]

    ??:? void tmp86eaolxm.__unittest_L23_C1() [0x427e0c]

    ??:? void tmp86eaolxm.__modtest() [0x428078]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c377]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b20a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43039d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43084c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430329]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e1]

    ??:? runModuleUnitTests [0x42c14d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287b8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ \n        l.length >= 2\n        && \n        !std.isNegative(l[0])\n      \
    \  && !std.isNegative(l[l.length-1])\n        && \n        !std.isNegative(l[l.length-2])\n\
    \        &&\n        std.isNumeric(l[1])\n        &&\n        std.isNumeric(l[l.length-1])\n\
    \        &&\n        std.isNumeric(l[l.length-2])\n        &&\n        std.isNumeric(l[1]);\n\
    \        \n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplnh2gxbr.d(18): Error: undefined identifier `isNegative` in package
    `std`

    /tmp/tmplnh2gxbr.d(19): Error: undefined identifier `isNegative` in package `std`

    /tmp/tmplnh2gxbr.d(21): Error: undefined identifier `isNegative` in package `std`

    /tmp/tmplnh2gxbr.d(23): Error: undefined identifier `isNumeric` in package `std`

    /tmp/tmplnh2gxbr.d(25): Error: undefined identifier `isNumeric` in package `std`

    /tmp/tmplnh2gxbr.d(27): Error: undefined identifier `isNumeric` in package `std`

    /tmp/tmplnh2gxbr.d(29): Error: undefined identifier `isNumeric` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplnh2gxbr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long[]\
    \ d = {l[0], l[1], l[0], l[1]};\n    std.sort(d);\n    return l[0] == d[0] &&\
    \ l[1] == d[1];\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6imudjh6.d(15): Error: a struct is not a valid initializer for
    a `long[]`

    /tmp/tmp6imudjh6.d(16): Error: undefined identifier `sort` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6imudjh6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for(size_t\
    \ i=1; i<l.size(); i++)\n        if(l[i-1] > l[i])\n            return false;\n\
    \    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphaeuj0wf.d(15): Error: no property `size` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphaeuj0wf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for (int\
    \ i = 0; i < l.length; i++) \n    {\n        if (l[i] < l[i - 1]) \n        {\n\
    \            return false;\n        }\n        else if (l[i] > l[i - 1]) \n  \
    \      {\n            return true;\n        }\n    }\n    return true;\n}\n'''\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo7_tj7to.d(28): Error: unterminated character constant

    /tmp/tmpo7_tj7to.d(28): Error: declaration expected, not `63U`

    /tmp/tmpo7_tj7to.d(28): Error: unterminated character constant

    /tmp/tmpo7_tj7to.d(33): Error: declaration expected, not `assert`

    /tmp/tmpo7_tj7to.d(34): Error: declaration expected, not `assert`

    /tmp/tmpo7_tj7to.d(35): Error: declaration expected, not `assert`

    /tmp/tmpo7_tj7to.d(36): Error: declaration expected, not `assert`

    /tmp/tmpo7_tj7to.d(37): Error: declaration expected, not `assert`

    /tmp/tmpo7_tj7to.d(38): Error: declaration expected, not `assert`

    /tmp/tmpo7_tj7to.d(39): Error: declaration expected, not `assert`

    /tmp/tmpo7_tj7to.d(40): Error: declaration expected, not `assert`

    /tmp/tmpo7_tj7to.d(41): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo7_tj7to.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    bool increasing\
    \ = true;\n    long last = l[0];\n    bool isIncreasing = true;\n    for (int\
    \ i=1; i < l.length; ++i) {\n        long cur = l[i];\n        if (cur != last)\
    \ {\n            isIncreasing = !isIncreasing;\n            last = cur;\n    \
    \    }\n        if (!isIncreasing) break;\n    }\n    return isIncreasing;\n}\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpic4s8nbv.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282fd]

    ??:? void tmpic4s8nbv.__unittest_L28_C1() [0x427e14]

    ??:? void tmpic4s8nbv.__modtest() [0x428080]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c37f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b212]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430854]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430331]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]

    ??:? runModuleUnitTests [0x42c155]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length<2)\
    \ return false;\n    int i=0;\n    int j=1;\n    long d=0;\n    int e=l.length;\n\
    \    while (i<e)\n    {\n        if (l[i]<l[j]) d=1;\n        else d=-1;\n   \
    \     if (d!=0) break;\n        i++;\n        j++;\n    }\n    if (i==e) return\
    \ true;\n    i=0;\n    j=1;\n    e=l.length;\n    while (i<e)\n    {\n       \
    \ if (l[i]<l[j]) d=-1;\n        else d=1;\n        if (d!=0) break;\n        i++;\n\
    \        j++;\n    }\n    if (i==e) return true;\n    else return false;\n}\n\
    /*\nReturn true is array elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L,\
    \ 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpshbi5j6v.d(19): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    /tmp/tmpshbi5j6v.d(31): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpshbi5j6v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int len\
    \ = l.length;\n    if (len <= 1) return true;\n    \n    if (l[0] > l[1]) return\
    \ true;\n    \n    if (l[len - 1] < l[len - 2]) {\n        // two consecutive\
    \ elements\n        if (l[len - 3] < l[len - 4]) return true;\n    }\n    return\
    \ false;\n}\n/* \nReturn array size or maximum size.\n    >>> arrsize([1L, 2L,\
    \ 4L, 20L])\n    4\n    >>> arrsize([1L, 20L, 4L, 10L])\n    10\n    \n*/\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9pl21ujc.d(15): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9pl21ujc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long[]\
    \ u = { 0L, 1L, 2L };\n    return monotonic(l, u);\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8rxegz3a.d(15): Error: a struct is not a valid initializer for
    a `long[]`

    /tmp/tmp8rxegz3a.d(16): Error: function `tmp8rxegz3a.monotonic(long[] l)` is not
    callable using argument types `(long[], long[])`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8rxegz3a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint i =\
    \ 0;\n\tbool isdecreasing = false;\n\tbool isincreasing = true;\n\twhile (i <\
    \ l.Length-1) {\n\t\tif (l[i+1] <= l[i]) {\n\t\t\ti++;\n\t\t\tif (i == l.Length-1)\
    \ isincreasing = false;\n\t\t\telse isincreasing = true;\n\t\t} else {\n\t\t\t\
    i++;\n\t\t\tif (i == l.Length-1) isdecreasing = false;\n\t\t\telse isdecreasing\
    \ = true;\n\t\t}\n\t}\n\treturn isdecreasing || isincreasing;\n}\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkfjnuptq.d(18): Error: no property `Length` for type `long[]`

    /tmp/tmpkfjnuptq.d(21): Error: no property `Length` for type `long[]`

    /tmp/tmpkfjnuptq.d(25): Error: no property `Length` for type `long[]`

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ ( l.length() > 1 && l[0] > l[l.length -1]);\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu57qiuf2.d(15): Error: no property `length` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu57qiuf2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n\
    \ = l.Length;\n    if (n<=1)\n        return true;\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5m1qi85p.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5m1qi85p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length==0)\
    \ return false;\n    return std.carrays.issorted(l, l.length);\n}\n#endif\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeipw6v2y.d(18): Error: declaration expected, not `#`

    /tmp/tmpeipw6v2y.d(23): Error: declaration expected, not `assert`

    /tmp/tmpeipw6v2y.d(24): Error: declaration expected, not `assert`

    /tmp/tmpeipw6v2y.d(25): Error: declaration expected, not `assert`

    /tmp/tmpeipw6v2y.d(26): Error: declaration expected, not `assert`

    /tmp/tmpeipw6v2y.d(27): Error: declaration expected, not `assert`

    /tmp/tmpeipw6v2y.d(28): Error: declaration expected, not `assert`

    /tmp/tmpeipw6v2y.d(29): Error: declaration expected, not `assert`

    /tmp/tmpeipw6v2y.d(30): Error: declaration expected, not `assert`

    /tmp/tmpeipw6v2y.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeipw6v2y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong i =\
    \ 1;\n\twhile (i < l.length && l[i-1] <= l[i])\n\t\ti += 1;\n\treturn i == l.length;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2j_kd9h7.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282e5]

    ??:? void tmp2j_kd9h7.__unittest_L20_C1() [0x427ee1]

    ??:? void tmp2j_kd9h7.__modtest() [0x428064]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c367]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1fa]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43038d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43083c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430319]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d1]

    ??:? runModuleUnitTests [0x42c13d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287a8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int m1,\
    \ m2, m3, m4;\n    int i;\n    int j;\n    long m;\n    bool r;\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphll7houj.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphll7houj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    // The\
    \ first element must be greater than the last\n    long first = l[0];\n    long\
    \ last = l[l.length-1];\n    // The difference between first and last must be\
    \ greater than zero\n    long diff = first - last;\n    // If the difference is\
    \ zero, then the list is monotonically increasing\n    // or decreasing. \n  \
    \  if (diff > 0) \n    {\n        return true;\n    }\n    // If the first element\
    \ is greater than the last, \n    // then the list is not monotonically increasing.\
    \ \n    else if (first > last) \n    {\n        return false;\n    }\n    // If\
    \ the first element is less than the last, \n    // then the list is not monotonically\
    \ decreasing. \n    else \n    {\n        return !((diff < 0) == (l[l.length-2]\
    \ < l[l.length-1]));\n    }\n}\n</code>\n<|/ a tags=c++,arrays |>\n<| c |>\n:\
    \ Thanks I fixed it\n<|/ c |>\n<| c |>\nYour code does not work for the case `monotonic([1,\
    \ 2, 3, 5])`.\n<|/ c |>\n<| c |>\n: That's a case I did not test for. Your solution\
    \ also returns true for monotonic([1, 2, 3, 5]). I will add an if statement to\
    \ account for that case\n<|/ c |>\n<| c |>\nThis answer is incorrect for monotonic\
    \ monotonic decreasing sequences. For example, monotonic([1, 2, 5, 3]) returns\
    \ true and should not be used.\n<|/ c |>\n<| a tags=c++,arrays |>\nIf you use\
    \ std::vector instead of array, then you can use std::is_sorted.\n<code>\n#include\
    \ <algorithm>\n#include <vector>\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpevl6_6dn.d(39): Error: declaration expected, not `<`

    /tmp/tmpevl6_6dn.d(48): Error: unterminated character constant

    /tmp/tmpevl6_6dn.d(62): Error: declaration expected, not `assert`

    /tmp/tmpevl6_6dn.d(63): Error: declaration expected, not `assert`

    /tmp/tmpevl6_6dn.d(64): Error: declaration expected, not `assert`

    /tmp/tmpevl6_6dn.d(65): Error: declaration expected, not `assert`

    /tmp/tmpevl6_6dn.d(66): Error: declaration expected, not `assert`

    /tmp/tmpevl6_6dn.d(67): Error: declaration expected, not `assert`

    /tmp/tmpevl6_6dn.d(68): Error: declaration expected, not `assert`

    /tmp/tmpevl6_6dn.d(69): Error: declaration expected, not `assert`

    /tmp/tmpevl6_6dn.d(70): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpevl6_6dn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min;\n\
    \tlong max;\n\tint i;\n\tfor(i = 0; i < l.length; i++){\n\t\tmin = max = l[i];\n\
    \t\tfor(; min < max; min++){\n\t\t\tif(max < min + 1) return false;\n\t\t}\n\t\
    \tfor(; max > min; max--){\n\t\t\tif(min > max - 1) return false;\n\t\t}\n\t}\n\
    \treturn true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpq4wzx9aa.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x42830d]

    ??:? void tmpq4wzx9aa.__unittest_L29_C1() [0x427ebf]

    ??:? void tmpq4wzx9aa.__modtest() [0x428090]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c38f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b222]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430864]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430341]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]

    ??:? runModuleUnitTests [0x42c165]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287d0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\t// first\
    \ sort (descending)\n\tArrays.sort(l, l.length, (l1, l2) => l2.l - l1.l);\n\t\n\
    \tfor (int i = 0; i < l.length - 1; i++) \n\t{\n\t\tif (l[i + 1].l > l[i].l) \n\
    \t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\treturn true;\n}\nunittest\n{\n \
    \   alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7k9cbjzz.d(16): Error: undefined identifier `Arrays`

    /tmp/tmp7k9cbjzz.d(20): Error: no property `l` for type `long`

    /tmp/tmp7k9cbjzz.d(20): Error: no property `l` for type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7k9cbjzz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length<=1)\n\
    \        return true;\n    \n    int i=0;\n    long maxvalue=l[0];\n    long minvalue=l[0];\n\
    \    for(long el:l)\n    {\n        if(el>maxvalue)\n            maxvalue=el;\n\
    \        \n        if(el<minvalue)\n            minvalue=el;\n        \n     \
    \   if(el>maxvalue-minvalue)\n            return false;\n    }\n    return true;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7orbh5gx.d(21): Error: semicolon expected, not `:`

    /tmp/tmp7orbh5gx.d(21): Error: expression expected, not `:`

    /tmp/tmp7orbh5gx.d(21): Error: found `l` when expecting `;` following `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7orbh5gx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    auto itEnd\
    \ = l.end();\n    for (auto itBegin = l.begin(); itBegin != itEnd; ++itBegin)\n\
    \    {\n        auto itCurrent = itBegin + 1; \n        if (*itCurrent > *itBegin)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp65nwlvf3.d(15): Error: no property `end` for type `long[]`

    /tmp/tmp65nwlvf3.d(16): Error: no property `begin` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp65nwlvf3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  int i =\
    \ 0;\n  int j = 1;\n  long k = l[0];\n  long l2 = l[1];\n  long u2 = l2;\n  while((i\
    \ < l.length) && ((j > 0) && (l[j] >= k)))\n  {\n    i++;\n    j++;\n    k = l[i];\n\
    \  }\n  while((i < l.length) && (l[j] == k))\n  {\n    i++;\n    j++;\n    k =\
    \ l[i];\n  }\n  while((i < l.length) && (l[j] > k))\n  {\n    i++;\n    k = l[i];\n\
    \  }\n  while((i < l.length) && (l[j] < k))\n  {\n    j++;\n    k = l[i];\n  }\n\
    \  \n  if ((i < l.length) && (l[j] < u2))\n  {\n    return true;\n  }\n  else\n\
    \  {\n    return false;\n  }\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp34bbcj12.d(20): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428556]

    ??:? bool tmp34bbcj12.monotonic(long[]) [0x427d93]

    ??:? void tmp34bbcj12.__unittest_L52_C1() [0x427fa5]

    ??:? void tmp34bbcj12.__modtest() [0x428228]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c527]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b3ba]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43054d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309fc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4304d9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b391]

    ??:? runModuleUnitTests [0x42c2fd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length\
    \ < 2) return true;\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo5w07ii9.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo5w07ii9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length==0)\
    \ return true;\n\tif (l[0]<l[1]) return false;\n\treturn (monotonic(l[2:])||l[0]<l[2]);\n\
    }\n/*\nReturn a new array that is an array of monotonically increasing\nor decreasing\
    \ elements with the specified number of elements. \nMonotonic arrays are assumed\
    \ to have non-negative elements.\n    >>> monotonic_with_size([1L, 2L, 4L, 20L],\
    \ 3)\n    [1, 1, 1]\n    >>> monotonic_with_size([1L, 2L, 4L, 20L], 4)\n    [1,\
    \ 2, 4]\n    >>> monotonic_with_size([1L, 2L, 4L, 20L], 1)\n    [1, 2]\n    \n\
    */\nlong[] monotonic_with_size(long[] l, int size_of_array)\n{\n\tint size = (int)size_of_array;\n\
    \tif (l==null) return null;\n\tif (l[0]<l[1]) return new long[size];\n\tif (l[0]<l[2])\
    \ return new long[size];\n\tif (l[0]<l[3]) return new long[size];\n\treturn new\
    \ long[size];\n}\n/*\nReturn a new array that is an array of monotonically increasing\n\
    or decreasing elements with the specified number of elements. \nMonotonic arrays\
    \ are assumed to have non-negative elements.\n    >>> monotonic_with_size([1L,\
    \ 2L, 4L, 20L], 3)\n    [1, 1, 1]\n    >>> monotonic_with_size([1L, 2L, 4L, 20L],\
    \ 4)\n    [1, 2, 4]\n    >>> monotonic_with_size([1L, 2L, 4L, 20L], 1)\n    [1,\
    \ 2]\n    \n*/\nlong[] monotonic_with_size(long[] l, int size_of_array,int max_element)\n\
    {\n\tint size = (int)size_of_array;\n\tif (l==null) return null;\n\tlong max_value\
    \ = (max_element>0?max_element:Integer.MAX_VALUE);\n\tif (max_value>l[0]) return\
    \ new long[size];\n\tif (max_value>l[1]) return new long[size];\n\tif (max_value>l[2])\
    \ return new long[size];\n\tif (max_value>l[3]) return new long[size];\n\treturn\
    \ new long[size];\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1by9hom3.d(17): Error: found `:` when expecting `,`

    /tmp/tmp1by9hom3.d(33): Error: C style cast illegal, use `cast(int)size_of_array`

    /tmp/tmp1by9hom3.d(54): Error: C style cast illegal, use `cast(int)size_of_array`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1by9hom3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length\
    \ == 0) {\n\t\treturn false;\n\t}\n\tif (l[0] == 0L) {\n\t\treturn false;\n\t\
    }\n\tbool isDecreasing = true;\n\tlong first = l[0];\n\tlong last = l[0];\n\t\
    long curr = l[0];\n\tlong count = 0;\n\tfor (int i = 1; i < l.length; ++i) {\n\
    \t\tlong next = l[i];\n\t\tif (curr < last) {\n\t\t\tisDecreasing = false;\n\t\
    \t}\n\t\tif (curr == last && curr < next) {\n\t\t\tisDecreasing = true;\n\t\t\
    }\n\t\tlast = curr;\n\t\tcurr = next;\n\t\tcount++;\n\t}\n\tif (count > 0) {\n\
    \t\tisDecreasing = (first < last);\n\t}\n\treturn isDecreasing;\n}\n/*\nReturn\
    \ true if all array elements are monotonically increasing or decreasing.\n   \
    \ >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L,\
    \ 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsiy9n3ta.d(59): unittest failure

    ----------------

    ??:? _d_unittestp [0x4283ad]

    ??:? void tmpsiy9n3ta.__unittest_L53_C1() [0x427f5b]

    ??:? void tmpsiy9n3ta.__modtest() [0x42812c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c42f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2c2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430455]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430904]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b299]

    ??:? runModuleUnitTests [0x42c205]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428870]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong first=l[0],\
    \ last=l[0];\n\tfor (int i=1; i<l.length; ++i)\n\t{\n\t\tlong el = l[i];\n\t\t\
    if (el < first) first=el;\n\t\tif (el > last) last=el;\n\t}\n\treturn !((first\
    \ < last) || (first == last));\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp86kizvba.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x42832d]

    ??:? void tmp86kizvba.__unittest_L24_C1() [0x427e44]

    ??:? void tmp86kizvba.__modtest() [0x4280b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b242]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430884]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430361]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b219]

    ??:? runModuleUnitTests [0x42c185]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif(l.length\
    \ < 2)\n\t\treturn true;\n\treturn l[1] < l[0];\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn7j4da6e.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282bd]

    ??:? void tmpn7j4da6e.__unittest_L19_C1() [0x427dd0]

    ??:? void tmpn7j4da6e.__modtest() [0x42803c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c33f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1d2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430365]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430814]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4302f1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1a9]

    ??:? runModuleUnitTests [0x42c115]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428780]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ monotonic_inverse(monotonic_inverse(l), l);\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6lb4eqrv.d(15): Error: undefined identifier `monotonic_inverse`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6lb4eqrv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif  (l ==\
    \ null)\n\t\treturn true;\n\t\n\tint h = 0;\n\tint j = l.length-1;\n\tlong lh\
    \ = l[0];\n\tlong lj= l[j];\n\tif (lj > lh)\n\t\treturn false;\n\t\n\twhile (j\
    \ < h.max) {\n\t\tint i = (j + h.min)/2;\n\t\tlong l = l[i];\n\t\tlong lh = l[0];\n\
    \t\tlong lj= l[j];\n\t\tif (lj > lh)\n\t\t\treturn false;\n\t\t\n\t\th.min = i;\n\
    \t\th = i;\n\t\tj = i;\n\t}\n\treturn true;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp79ne_xz7.d(19): Error: cannot implicitly convert expression `l.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmp79ne_xz7.d(27): Error: variable `l` is shadowing variable `tmp79ne_xz7.monotonic.l`

    /tmp/tmp79ne_xz7.d(28): Error: only one index allowed to index `long`

    /tmp/tmp79ne_xz7.d(28): Error: variable `lh` is shadowing variable `tmp79ne_xz7.monotonic.lh`

    /tmp/tmp79ne_xz7.d(29): Error: only one index allowed to index `long`

    /tmp/tmp79ne_xz7.d(29): Error: variable `lj` is shadowing variable `tmp79ne_xz7.monotonic.lj`

    /tmp/tmp79ne_xz7.d(33): Error: cannot modify constant `h.min`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp79ne_xz7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ std.typecons.maxIndex(l) == std.typecons.minIndex(l)-1;\n}\nunittest\n{\n  \
    \  alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgxkxuupa.d(15): Error: undefined identifier `maxIndex` in module
    `std.typecons`

    /tmp/tmpgxkxuupa.d(15): Error: undefined identifier `minIndex` in module `std.typecons`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgxkxuupa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long l\
    \ = l.length;\n    int k = 0;\n    for(int i = 1; i < l; ++i)\n    {\n       \
    \ if(l[i] < l[k])\n        {\n            return false;\n        }\n        else\
    \ if(l[i] > l[k])\n        {\n            return true;\n        }\n        ++k;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgicfp1nu.d(15): Error: variable `l` is shadowing variable `tmpgicfp1nu.monotonic.l`

    /tmp/tmpgicfp1nu.d(19): Error: only one index allowed to index `long`

    /tmp/tmpgicfp1nu.d(19): Error: only one index allowed to index `long`

    /tmp/tmpgicfp1nu.d(23): Error: only one index allowed to index `long`

    /tmp/tmpgicfp1nu.d(23): Error: only one index allowed to index `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgicfp1nu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    return\
    \ monotonicAux(l,0,l.length-1);\n}\n/*\nReturn true is array elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonicAux([1L, 2L, 4L, 20L], 0, 0)\n \
    \   true\n    >>> monotonicAux([1L, 20L, 4L, 10L], 0, 0)\n    false\n    >>> monotonicAux([4L,\
    \ 1L, 0L, -10L], 0, 0)\n    true\n    \n*/\nunittest\n{\n    alias candidate =\
    \ monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk6zmi5uk.d(15): Error: undefined identifier `monotonicAux`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk6zmi5uk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n   long prev\
    \ = l[0], current = l[0];\n   for (int i=1; i<l.length; ++i)\n   {\n      if (current\
    \ > prev) \n      {\n         return false;\n      }\n      if (l[i] > current)\n\
    \      {\n         return false;\n      }\n      prev = current;\n      current\
    \ = l[i];\n   }\n   return true;\n}\n/*\nReturn true is array elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n\
    \    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L,\
    \ 0L, -10L])\n    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpddqe0p4p.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x428355]

    ??:? void tmpddqe0p4p.__unittest_L41_C1() [0x427e68]

    ??:? void tmpddqe0p4p.__modtest() [0x4280d4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b26a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308ac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430389]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b241]

    ??:? runModuleUnitTests [0x42c1ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428818]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev\
    \ = 0;\n    long x = 0;\n    long y = 0;\n    bool decreasing = true;\n    for\
    \ (int i = 0; i < l.length; i++)\n    {\n        if (l[i] < prev)\n        {\n\
    \            if (l[i] < x)\n            {\n                x = l[i];\n       \
    \     }\n            if (l[i] < y)\n            {\n                y = l[i];\n\
    \            }\n        }\n        else\n        {\n            if (l[i] > prev)\n\
    \            {\n                if (l[i] > x)\n                {\n           \
    \         x = l[i];\n                }\n                if (l[i] > y)\n      \
    \          {\n                    y = l[i];\n                }\n            }\n\
    \        }\n        prev = l[i];\n    }\n    return decreasing ? (x > y) : (x\
    \ < y);\n}\n</code>\n<|/ a tags=arrays,c++,performance,algorithm,sorting |>\n\
    <| c |>\nThis doesn't seem to work for the case `monotonic([4L, 1L, 0L, -10L])`.\
    \ What should be returned in this case is `monotonic([4L, 1L, -10L, 0L])` but\
    \ `monotonic([4L, 1L, -10L, 0L], true)` is `false`.\n<|/ c |>\n<| c |>\nThe problem\
    \ is that the input list should _only_ contain negative integers. A sorted array\
    \ could have duplicates, `monotonic([4L, 1L, 0L, -10L], true)` returns `false`.\n\
    <|/ c |>\n<| c |>\nYes, you're right. I didn't think that through. I've edited\
    \ my answer to fix the issue. Thanks for noticing.\n<|/ c |>\n<| c |>\n: This\
    \ is just amazing. I've tested your `monotonic` implementation with negative and\
    \ positive numbers and it works. Thank you.\n<|/ c |>\n<| a tags=arrays,c++,performance,algorithm,sorting\
    \ |>\nIf array is not sorted, you may want to consider using std::lower_bound\
    \ from the algorithms library to find the first element that is greater than the\
    \ one you have. After that you can move the array until you reach the element\
    \ you want.\n<|/ a dscore=0 |>\n<| a dscore=0 tags=arrays,c++,performance,algorithm,sorting\
    \ |>\nOne can use std::set_if to solve this in O(n log n) time, O(n) space, using\
    \ std::greater as the predicate and std::adjacent_find:\n<code>\n#include <iostream>\n\
    #include <iterator>\n#include <algorithm>\n#include <vector>\nunittest\n{\n  \
    \  alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp92xmo4rn.d(50): Error: declaration expected, not `<`

    /tmp/tmp92xmo4rn.d(53): Error: unterminated character constant

    /tmp/tmp92xmo4rn.d(59): Error: unterminated character constant

    /tmp/tmp92xmo4rn.d(59): Error: unterminated character constant

    /tmp/tmp92xmo4rn.d(59): Error: unterminated character constant

    /tmp/tmp92xmo4rn.d(62): Error: unterminated character constant

    /tmp/tmp92xmo4rn.d(78): Error: declaration expected, not `assert`

    /tmp/tmp92xmo4rn.d(79): Error: declaration expected, not `assert`

    /tmp/tmp92xmo4rn.d(80): Error: declaration expected, not `assert`

    /tmp/tmp92xmo4rn.d(81): Error: declaration expected, not `assert`

    /tmp/tmp92xmo4rn.d(82): Error: declaration expected, not `assert`

    /tmp/tmp92xmo4rn.d(83): Error: declaration expected, not `assert`

    /tmp/tmp92xmo4rn.d(84): Error: declaration expected, not `assert`

    /tmp/tmp92xmo4rn.d(85): Error: declaration expected, not `assert`

    /tmp/tmp92xmo4rn.d(86): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp92xmo4rn.d", '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length==0)\n\
    \t\treturn true;\n\tif (l[0]>l[1])\n\t\treturn false;\n\tint i=2;\n\tlong prev=l[0];\n\
    \tdo\n\t{\n\t\tif (prev<l[i-1])\n\t\t\treturn false;\n\t\ti++;\n\t\tprev=l[i];\n\
    \t}while(i != l.length-1);\n\treturn true;\n}\n/*\nReturn a slice of a string\
    \ with start and stop indexes and optional step value.\n    >>> \"abcd\"[2:5]\n\
    \    \"bcd\"\n    >>> \"abcd\"[2:]\n    \"bcd\"\n    >>> \"abcd\"[2:5]\n    \"\
    bcd\"\n    >>> \"abcd\"[2:5:2]\n    \"bd\"\n    >>> \"abcd\"[2:5:-1]\n    \"c\"\
    \n*/\nstring slice(string s, int start, int stop, int step)\n{\n\tif (step<0)\n\
    \t\tstep=1;\n\tif (start<0)\n\t\tstart=s.length+start;\n\tif (step>0)\n\t\treturn\
    \ s.substr(start, stop-start+1);\n\telse\n\t\treturn s.substr(start);\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpleevk3rw.d(48): Error: cannot implicitly convert expression `s.length
    + cast(ulong)start` of type `ulong` to `int`

    /tmp/tmpleevk3rw.d(50): Error: no property `substr` for type `string`

    /tmp/tmpleevk3rw.d(52): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpleevk3rw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    // This\
    \ assumes that l has at least two elements.\n    if(l.length == 0) return false;\n\
    \    long prev = l[0], current = l[0], change, changePrev, changeNext, next, nextPrev,\
    \ nextNext;\n    \n    for(int i = 1; i < l.length; ++i) \n    {\n        next\
    \ = l[i];\n        \n        if(next > current)\n        {\n            change\
    \ = current - prev;\n            changePrev = prev;\n            changeNext =\
    \ next;\n        }\n        else\n        {\n            change = next - prev;\n\
    \            changePrev = prev;\n            changeNext = current;\n        }\n\
    \        \n        if(change < 0)\n        {\n            change = -change;\n\
    \            changePrev = -changePrev;\n            changeNext = -changeNext;\n\
    \        }\n        \n        prev = current;\n        current = next;\n     \
    \   \n        if(change == 0)\n        {\n            // Next monotonic increasing\
    \ or decreasing.\n            if(changeNext > changePrev && changeNext <= -changePrev)\n\
    \                return true;\n            \n            // Previous monotonic\
    \ increasing or decreasing.\n            if(changePrev <= changeNext && changePrev\
    \ <= -changeNext)\n                return true;\n            \n            //\
    \ Neither monotonic.\n            return false;\n        }\n    }\n    \n    return\
    \ false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqb78w_wk.d(67): unittest failure

    ----------------

    ??:? _d_unittestp [0x4283dd]

    ??:? void tmpqb78w_wk.__unittest_L63_C1() [0x427ef0]

    ??:? void tmpqb78w_wk.__modtest() [0x42815c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c45f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430485]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430934]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430411]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2c9]

    ??:? runModuleUnitTests [0x42c235]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4288a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max\
    \ = l[0], min = l[0];\n    for(int i = 1; i < l.length; i++) \n    {\n       \
    \ if(l[i] > max) max = l[i];\n        if(l[i] < min) min = l[i];\n    }\n    return\
    \ min < max;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn2ztalem.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x428385]

    ??:? void tmpn2ztalem.__unittest_L23_C1() [0x427f37]

    ??:? void tmpn2ztalem.__modtest() [0x428108]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c407]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b29a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43042d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308dc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303b9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]

    ??:? runModuleUnitTests [0x42c1dd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428848]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\t\n    int\
    \ n = l.length;\n    int i, j;\n    int min = l[0];\n    int max = l[0];\n   \
    \ int minval = l[0];\n    int maxval = l[0];\n    for (i=1; i<n; i++) {\n    \
    \    int curr = l[i];\n        if (curr < min) {\n            min = curr;\n  \
    \      } else if (curr > max) {\n            max = curr;\n        }\n        minval\
    \ = Math.min(minval, curr);\n        maxval = Math.max(maxval, curr);\n    }\n\
    \    bool isMonotonic = true;\n    for (i=1; i<n; i++) {\n        int curr = l[i];\n\
    \        if (curr < min) {\n            isMonotonic = false;\n            break;\n\
    \        } else if (curr > max) {\n            isMonotonic = false;\n        \
    \    break;\n        } else if (curr != l[i-1]) {\n            isMonotonic = false;\n\
    \            break;\n        }\n    }\n    return isMonotonic;\n}\n/*\nReturn\
    \ a new array created by removing all occurrences of element 'e' from the original\
    \ array.\n    If the input array is empty, then 'e' is returned.\n    >>> remove([1L,\
    \ 2L, 3L, 1L], 1L)\n    [2L, 3L]\n    >>> remove([1L, 2L, 3L, 1L], 0L)\n    [2L,\
    \ 3L]\n    \n*/\nlong[] remove(long[] l, long e) \n{\n    int i;\n    int n =\
    \ l.length;\n    long[] ret = new long[n];\n    if (n == 0) {\n        return\
    \ e;\n    }\n    for (i=0; i<n; i++) {\n        if (l[i] == e) {\n           \
    \ ret = removeAt(ret, i);\n        }\n    }\n    return ret;\n}\n/*\nReturn a\
    \ new array created by removing all occurrences of element 'e' from the original\
    \ array.\n    If the input array is empty, then 'e' is returned.\n    >>> removeAt([]L,\
    \ 1L)\n    []\n    >>> removeAt([]L, 0L)\n    []\n    \n*/\nlong[] removeAt(long[]\
    \ l, int i) \n{\n    int n = l.length;\n    long[] ret = new long[n];\n    int\
    \ j = 0;\n    if (n == 0) {\n        return l;\n    }\n    for (; j<n; j++) {\n\
    \        if (l[j] == i) {\n            ret = removeAt(ret, j);\n        }\n  \
    \  }\n    return ret;\n}\n/*\nReturn a new array created by removing all occurrences\
    \ of element 'e' from the original array.\n    If the input array is empty, then\
    \ 'e' is returned.\n    >>> removeAll([1L, 2L, 3L, 1L], 1L)\n    [2L, 3L]\n  \
    \  >>> removeAll([1L, 2L, 3L, 1L], 0L)\n    [1L, 2L, 3L]\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7w46pixj.d(96): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7w46pixj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif(l.length==0)\n\
    \t\treturn true;\n\tint lo=0,hi=l.length-1;\n\tbool s=true;\n\twhile(lo<=hi)\n\
    \t{\n\t\tbool t=s[hi-lo-1];\n\t\tif(t==false)\n\t\t{\n\t\t\ts[hi-lo-1]=true;\n\
    \t\t\tlo++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint mid=(lo+hi)/2;\n\t\t\tt=s[mid-lo-1];\n\
    \t\t\tif(!t)\n\t\t\t\treturn false;\n\t\t\tif(!t)\n\t\t\t\tlo=mid+1;\n\t\t\telse\n\
    \t\t\t\thi=mid-1;\n\t\t}\n\t}\n\treturn true;\n}\n/*\nSum an array in linear time\
    \ O(N).\n    The algorithm uses merge sort.\n*/\nlong sum(int[] a)\n{\n\tint n=a.length;\n\
    \tint lo,hi,k;\n\tlong  sum=0;\n\tif(n<2)\n\t\treturn 0;\n\thi=n-1;\n\tlo=0;\n\
    \tk=0;\n\twhile(k<n && lo<hi)\n\t{\n\t\tif(a[lo]>a[hi])\n\t\t{\n\t\t\tsum+=a[lo++]-a[k++];\n\
    \t\t\tsum+=a[lo++]-a[k++];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum+=a[lo++]-a[k++];\n\
    \t\t}\n\t}\n\twhile(k<n)\n\t{\n\t\tsum+=a[++lo]-a[k++];\n\t}\n\treturn sum;\n\
    }\n/*\nCompute the mean of an array of numbers in linear time O(N).\n    The algorithm\
    \ uses merge sort.\n*/\ndouble mean(int[] a)\n{\n\tdouble sum=sum(a);\n\tdouble\
    \ count=sum;\n\tfor(int i=0;i<a.length;i++)\n\t{\n\t\tsum+=a[i];\n\t\tcount++;\n\
    \t}\n\treturn sum/count;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbtr4wdph.d(17): Error: cannot implicitly convert expression `l.length
    - 1LU` of type `ulong` to `int`

    /tmp/tmpbtr4wdph.d(21): Error: only one index allowed to index `bool`

    /tmp/tmpbtr4wdph.d(24): Error: only one index allowed to index `bool`

    /tmp/tmpbtr4wdph.d(30): Error: only one index allowed to index `bool`

    /tmp/tmpbtr4wdph.d(47): Error: cannot implicitly convert expression `a.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbtr4wdph.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ == 0)\n        return true;\n    long first = l[0];\n    int pos = 0;\n    while(pos\
    \ < l.length-1 && l[pos] < first)\n        pos++;\n    return pos == l.length-1;\n\
    }\n/*\nReturn true is array elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L,\
    \ 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6phwtqkp.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282fd]

    ??:? void tmp6phwtqkp.__unittest_L33_C1() [0x427e10]

    ??:? void tmp6phwtqkp.__modtest() [0x42807c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c37f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b212]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430854]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430331]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]

    ??:? runModuleUnitTests [0x42c155]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint[] a\
    \ = argmin(l);\n\tint[] b = argmin(l);\n\tfor(int i = 0; i < l.length; i++)\n\t\
    {\n\t\tif(l[i] < a[a[i]])\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse if(l[i]\
    \ > b[b[i]])\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9vwittc_.d(15): Error: undefined identifier `argmin`

    /tmp/tmp9vwittc_.d(16): Error: undefined identifier `argmin`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9vwittc_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long i\
    \ = 1;\n    long last = l[0]; // First element.\n    bool increasing = true;\n\
    \    bool decreasing = false;\n    while(true)\n    {\n        bool same = true;\n\
    \        for(size_t j = 0; j < l.size(); j++)\n        {\n            if(l[j]\
    \ != l[j+1])\n            {\n                same = false;\n                break;\n\
    \            }\n        }\n        if(same)\n            break;\n        increasing\
    \ ^= increasing;\n        decreasing ^= decreasing;\n        last = l[i];\n  \
    \      l[i] = i;\n        i++;\n    }\n    return increasing || decreasing;\n\
    }\n</code>\nEDIT: As pointed out by in the comments, this method has some issues:\
    \ \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpymofxpt6.d(40): Error: declaration expected, not `<`

    /tmp/tmpymofxpt6.d(46): Error: declaration expected, not `assert`

    /tmp/tmpymofxpt6.d(47): Error: declaration expected, not `assert`

    /tmp/tmpymofxpt6.d(48): Error: declaration expected, not `assert`

    /tmp/tmpymofxpt6.d(49): Error: declaration expected, not `assert`

    /tmp/tmpymofxpt6.d(50): Error: declaration expected, not `assert`

    /tmp/tmpymofxpt6.d(51): Error: declaration expected, not `assert`

    /tmp/tmpymofxpt6.d(52): Error: declaration expected, not `assert`

    /tmp/tmpymofxpt6.d(53): Error: declaration expected, not `assert`

    /tmp/tmpymofxpt6.d(54): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpymofxpt6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tuint i =\
    \ 0;\n\tuint j = 1;\n\tbool result = true;\nunittest\n{\n    alias candidate =\
    \ monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnubjb_k3.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnubjb_k3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint i, j,\
    \ cnt;\n\tbool ret = false;\n\tcnt = count(l);\n\tfor(i=1; i<cnt; i++) {\n\t\t\
    for(j=i; j<cnt; j++) {\n\t\t\tif(!less(l[i], l[j])) {\n\t\t\t\tret = !ret;\n\t\
    \t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ret) break;\n\t}\n\treturn ret;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp19g1j91r.d(17): Error: undefined identifier `count`, did you mean
    variable `cnt`?

    /tmp/tmp19g1j91r.d(20): Error: undefined identifier `less`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp19g1j91r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong first\
    \ = l[0], last = l[0];\n\tint i = 0;\n\tfor(i = 0; i < l.length; ++i)\n\t{\n\t\
    \tbool isIncreasing = last < l[i];\n\t\tlast = l[i];\n\t\tif (!isIncreasing)\n\
    \t\t\treturn false;\n\t}\n\treturn true;\n}\n/*\nReturn true if array elements\
    \ are monotonically increasing or decreasing.\n\tThis assumes monotonic increasing\
    \ values will increase by more than 1 each time.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp47dtz_70.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x42832d]

    ??:? void tmp47dtz_70.__unittest_L36_C1() [0x427e40]

    ??:? void tmp47dtz_70.__modtest() [0x4280ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b242]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430884]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430361]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b219]

    ??:? runModuleUnitTests [0x42c185]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  if (l.length\
    \ <= 1) return true;\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvhi_sj_l.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvhi_sj_l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l==null\
    \ || l.length==0)\n        return true;\n    if (l.length==1)\n        return\
    \ true;\n    return std.math.isIncreasing(_montOf(l));\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeimb480_.d(19): Error: undefined identifier `isIncreasing` in module
    `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeimb480_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\treturn std.sort.sort.isSorted(l,\
    \ \n\t\t\t\t\t\t \tstd.sort.sort.isMonotonic);\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0pdvqvnf.d(15): Error: undefined identifier `sort` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0pdvqvnf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ == 0)\n        return true;\n    long first = l[0];\n    long last = l[0];\n\
    \    long minIndex = -1;\n    bool isFirst = true;\n    for (int i = 1; i < l.length;\
    \ ++i) {\n        long curr = l[i];\n        if (isFirst) {\n            minIndex\
    \ = i;\n            isFirst = false;\n            last = curr;\n        } else\
    \ {\n            long diff = curr - last;\n            if (diff > 0)\n       \
    \         return false;\n            last = curr;\n        }\n    }\n    minIndex\
    \ = -1;\n    long lastMin = first;\n    for (int i = l.length - 1; i >= 0; --i)\
    \ {\n        long curr = l[i];\n        if (last < curr && minIndex == -1) {\n\
    \            minIndex = i;\n            lastMin = curr;\n        } else {\n  \
    \          long diff = curr - lastMin;\n            if (diff > 0)\n          \
    \      return false;\n            lastMin = curr;\n        }\n    }\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm65stv2e.d(36): Error: cannot implicitly convert expression `l.length
    - 1LU` of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm65stv2e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  int i;\n\
    \  for(i = 1; i < l.length; ++i)\n    if(l[i] < l[i-1]) return true;\n  return\
    \ false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6fe4kpdz.d(24): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282ed]

    ??:? void tmp6fe4kpdz.__unittest_L20_C1() [0x427e04]

    ??:? void tmp6fe4kpdz.__modtest() [0x428070]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c36f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b202]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430395]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430844]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430321]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1d9]

    ??:? runModuleUnitTests [0x42c145]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287b0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length\
    \ < 2)\n\t\treturn false;\nunittest\n{\n    alias candidate = monotonic;\n\n \
    \   assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplfbr2gww.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplfbr2gww.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong lmax\
    \ = l.length - 1;\n\tbool isLarger = true;\n\tbool isSmaller = true;\n\tlong lmin\
    \ = l[0];\n\tfor (int i = 1; i < l.length; i++) {\n\t\tif (lmax == i) {\n\t\t\t\
    isLarger = false;\n\t\t} else if (lmin == i) {\n\t\t\tisSmaller = false;\n\t\t\
    }\n\t\tif (l[i] < lmin) lmin = l[i];\n\t\tif (l[i] > lmax) lmax = l[i];\n\t}\n\
    \tif (isLarger) {\n\t\tfor (long i = l.length - 2; i >= 0; i--) {\n\t\t\tif (l[i]\
    \ == lmax - 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t\
    }\n\tif (isSmaller) {\n\t\tfor (long i = l.length - 2; i >= 0; i--) {\n\t\t\t\
    if (l[i] == lmin) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\
    \t}\n\treturn false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n   \
    \ assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7z2fpvi8.d(52): unittest failure

    ----------------

    ??:? _d_unittestp [0x42844d]

    ??:? void tmp7z2fpvi8.__unittest_L46_C1() [0x427fff]

    ??:? void tmp7z2fpvi8.__modtest() [0x4281d0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b362]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304f5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4309a4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430481]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b339]

    ??:? runModuleUnitTests [0x42c2a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428910]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  if(l.length<3)\n\
    \    return true;\n  long a=l[0];\n  long b=l[1];\n  int i=2;\n  while (i<l.length&&l[i]>b)\n\
    \  {\n    a=b;\n    b=l[i];\n    i++;\n  }\n  if (i==l.length&&l[i]==b)\n  {\n\
    \    return (a-b)>=0;\n  }\n  a=l[0];\n  b=l[1];\n  i=2;\n  while (i<l.length&&l[i]<b)\n\
    \  {\n    a=b;\n    b=l[i];\n    i++;\n  }\n  return (a-b)>=0;\n}\n/*\nReturn\
    \ true is array elements are strictly increasing or strictly decreasing.\n   \
    \ >>> strictly_increasing([2L, 1L, 4L, 20L])\n    true\n    >>> strictly_decreasing([2L,\
    \ 1L, 4L, 20L])\n    false\n    >>> strictly_increasing([4L, 1L, 0L, -10L])\n\
    \    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpna5f73xt.d(26): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4284f6]

    ??:? bool tmpna5f73xt.monotonic(long[]) [0x427dfb]

    ??:? void tmpna5f73xt.__unittest_L51_C1() [0x427f45]

    ??:? void tmpna5f73xt.__modtest() [0x4281c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c4c7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b35a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304ed]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43099c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430479]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b331]

    ??:? runModuleUnitTests [0x42c29d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong max\
    \ = l[0];\n\tlong min = l[0];\n\tbool swap;\n\tfor(int i = 1; i < l.length; ++i)\n\
    \t{\n\t\tswap = l[i] > max;\n\t\tmax = l[i] > min ? l[i] : max;\n\t\tmin = l[i]\
    \ < max ? l[i] : min;\n\t}\n\treturn swap ? min > max : min < max;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk_uhads_.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x4283c5]

    ??:? void tmpk_uhads_.__unittest_L26_C1() [0x427edc]

    ??:? void tmpk_uhads_.__modtest() [0x428148]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c447]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b2da]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43046d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43091c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2b1]

    ??:? runModuleUnitTests [0x42c21d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428888]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tbool first\
    \ = false;\n\tbool last = true;\n\tint i = 0; // index\n\tlong prevVal = l[i];\n\
    \t\n\twhile(!last && i < l.length) \n\t{\n\t\tif (l[i] == prevVal)\n\t\t{\n\t\t\
    \tlast = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfirst = true;\n\t\t}\n\t\ti++;\n\
    \t\tprevVal = l[i];\n\t}\n\treturn (first == last);\n}\nunittest\n{\n    alias\
    \ candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n\
    \    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeumceten.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x42832d]

    ??:? void tmpeumceten.__unittest_L35_C1() [0x427e40]

    ??:? void tmpeumceten.__modtest() [0x4280ac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3af]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b242]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303d5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430884]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430361]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b219]

    ??:? runModuleUnitTests [0x42c185]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287f0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length\
    \ <= 1) \n\t\treturn true;\n\tif (l[0] == l[1]) \n\t\treturn false;\n\tdouble\
    \ m = l[0];\n\tfor (int i = 1; i < l.length; i++) {\n\t\tif (l[i] < m && l[i -\
    \ 1] > m)\n\t\t\treturn false;\n\t\tif (l[i] > m && l[i - 1] < m)\n\t\t\treturn\
    \ false;\n\t}\n\treturn true;\n}\n/*\nReturn true if the array elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n\
    \    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L,\
    \ 0L, -10L])\n    true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbl608se6.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x428405]

    ??:? void tmpbl608se6.__unittest_L38_C1() [0x427fb3]

    ??:? void tmpbl608se6.__modtest() [0x428184]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c487]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b31a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4304ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43095c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430439]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b2f1]

    ??:? runModuleUnitTests [0x42c25d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4288c8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max;\n\
    \    if (l.length==0) return true;\n    max = l[0];\n    for (int i = 1; i < l.length;\
    \ ++i)\n        if (l[i] > max) return false;\n    return true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmfwix_zn.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282fd]

    ??:? void tmpmfwix_zn.__unittest_L22_C1() [0x427e10]

    ??:? void tmpmfwix_zn.__modtest() [0x42807c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c37f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b212]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430854]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430331]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]

    ??:? runModuleUnitTests [0x42c155]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i\
    \ = 0;\n    int j = l.length - 1;\n    int cmp = 0;\n    while (i < j) {\n   \
    \     cmp = l[j] - l[i];\n        if (cmp > 0) {\n            i++;\n        }\
    \ else if (cmp < 0) {\n            j--;\n        } else {\n            // l[i]\
    \ > l[j] or l[i] == l[j]\n            // We are done\n            break;\n   \
    \     }\n    }\n    return i == j;\n}\n</code>\n<|/ a tags=sorting,c#,performance\
    \ |>\n<| c |>\nI believe this algorithm is O(n^2), so it's only applicable to\
    \ a small list\n<|/ c |>\n<| c |>\n, can you explain it a bit more? It's a O(n)\
    \ algorithm, and I don't see how it could be O(n^2)?\n<|/ c |>\n<| c |>\nHe pointed\
    \ out that he was using a `while` loop and a `for` loop in the same `for` loop.\
    \ He meant to say that he was using the `while` loop twice and that he was using\
    \ the `for` loop once, where he also used a `for` loop.\n<|/ c |>\n<| c |>\nIt's\
    \ O(n) because it's one loop rather than two, since it's being run n times. The\
    \ while loop isn't being run n times. It's being run once. He also said that he\
    \ had two loops within that one loop, he said that he had two loops when he said\
    \ that he had one loop in the for loop, which he said was O(n).\n<|/ c |>\n<|\
    \ c |>\nBut he also said that the for loop ran n times, which is O(n).\n<|/ c\
    \ |>\n<| a tags=sorting,c#,performance |>\nYou don't need two loops. You need\
    \ to use only one loop and then compare the next element of the array to the previous\
    \ one. If they are equal, continue to the next one. If the difference between\
    \ the current and previous value is greater than 1, break the loop. Otherwise\
    \ the array is sorted.\n<code>\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx69tlvdt.d(32): Error: declaration expected, not `<`

    /tmp/tmpx69tlvdt.d(35): Error: unterminated character constant

    /tmp/tmpx69tlvdt.d(38): Error: unterminated character constant

    /tmp/tmpx69tlvdt.d(38): Error: unterminated character constant

    /tmp/tmpx69tlvdt.d(44): Error: unterminated character constant

    /tmp/tmpx69tlvdt.d(44): Error: unterminated character constant

    /tmp/tmpx69tlvdt.d(44): Error: unterminated character constant

    /tmp/tmpx69tlvdt.d(44): Error: unterminated character constant

    /tmp/tmpx69tlvdt.d(44): Error: unterminated character constant

    /tmp/tmpx69tlvdt.d(50): Error: unterminated character constant

    /tmp/tmpx69tlvdt.d(56): Error: declaration expected, not `assert`

    /tmp/tmpx69tlvdt.d(57): Error: declaration expected, not `assert`

    /tmp/tmpx69tlvdt.d(58): Error: declaration expected, not `assert`

    /tmp/tmpx69tlvdt.d(59): Error: declaration expected, not `assert`

    /tmp/tmpx69tlvdt.d(60): Error: declaration expected, not `assert`

    /tmp/tmpx69tlvdt.d(61): Error: declaration expected, not `assert`

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong prev=0;\n\
    \tbool flag=false;\n\tlong mid;\n\t\n\tfor(int i=0;i<l.length-1;i++)\n\t{\n\t\t\
    mid=l[i];\n\t\tif(mid<prev)\n\t\t{\n\t\t\tflag=true;\n\t\t\tbreak;\n\t\t}\n\t\t\
    prev=mid;\n\t}\n\treturn flag;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpeabdrian.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282d5]

    ??:? void tmpeabdrian.__unittest_L31_C1() [0x427de8]

    ??:? void tmpeabdrian.__modtest() [0x428054]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c357]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1ea]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43037d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43082c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430309]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c1]

    ??:? runModuleUnitTests [0x42c12d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428798]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i;\n\
    \    long last;\n    bool up;\n    \n    if (l.length==0) return false;\n    last\
    \ = l[0];\n    up = false;\n    \n    for (i=1; i<l.length; ++i) {\n        if\
    \ (l[i]<last) up=false;\n        else if (l[i]>last) up=true;\n        else if\
    \ (up) return false;\n        last=l[i];\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzskxqfxd.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x428385]

    ??:? void tmpzskxqfxd.__unittest_L31_C1() [0x427f33]

    ??:? void tmpzskxqfxd.__modtest() [0x428104]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c407]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b29a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43042d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308dc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303b9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b271]

    ??:? runModuleUnitTests [0x42c1dd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428848]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long max\
    \ = l[0], min = l[0], cur;\n    for (int i = 1; i < l.length; ++i) {\n       \
    \ cur = l[i];\n        if (max < cur) {\n            max = cur;\n        } else\
    \ if (min > cur) {\n            min = cur;\n        }\n    }\n    if (max < min)\
    \ return false;\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpy_jb0bdy.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x428335]

    ??:? void tmpy_jb0bdy.__unittest_L27_C1() [0x427ee3]

    ??:? void tmpy_jb0bdy.__modtest() [0x4280b4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3b7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b24a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303dd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43088c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430369]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b221]

    ??:? runModuleUnitTests [0x42c18d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287f8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length\
    \ == 0)\n        return true;\n    return l[0] > l[l.length-1];\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzwolino4.d(23): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282c5]

    ??:? void tmpzwolino4.__unittest_L19_C1() [0x427ddc]

    ??:? void tmpzwolino4.__modtest() [0x428048]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c347]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1da]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43036d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43081c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4302f9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1b1]

    ??:? runModuleUnitTests [0x42c11d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428788]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tint i =\
    \ 1;\n\tint n = l.length;\n\tbool is_increasing = true;\n\tbool is_decreasing\
    \ = true;\n\tlong min_value = l[0];\n\tlong max_value = l[0];\n\twhile (i<n) {\n\
    \t\tif (l[i] < min_value) min_value = l[i];\n\t\telse if (l[i] > max_value) max_value\
    \ = l[i];\n\t\tif (l[i] < max_value) {\n\t\t\tis_decreasing = false;\n\t\t\tbreak;\n\
    \t\t}\n\t\tif (l[i] > min_value) {\n\t\t\tis_increasing = false;\n\t\t\tbreak;\n\
    \t\t}\n\t\ti++;\n\t}\n\tif (is_increasing) {\n\t\tif (is_decreasing) {\n\t\t\t\
    return true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (is_decreasing)\
    \ {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk2gevgg3.d(16): Error: cannot implicitly convert expression `l.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk2gevgg3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ <= 1)\n        return true;\n    \n    int pos = 0;\n    long last = l[0];\n\
    \    for (int i = 1; i < l.length; ++i) {\n        long current = l[i];\n    \
    \    if (current == last) {\n            pos++;\n        } else {\n          \
    \  last = current;\n            pos = 1;\n        }\n    }\n    return pos ==\
    \ 1;\n}\n</code>\n<|/ a tags=java,arrays |>\n<| a |>\n<code>\npublic class monotonicArr\
    \ {\n    public boolean isMonotonic(int[] arr) {\n        return monotonic(arr,\
    \ 0, arr.length - 1);\n    }\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8bnztza5.d(31): Error: declaration expected, not `<`

    /tmp/tmp8bnztza5.d(38): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8bnztza5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int n\
    \ = l.length-1;\n    return !((n>0 && l[n]<=l[n-1]) || (n==0 && l[0]>=l[1]));\n\
    }\n'''\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcd_it_0c.d(18): Error: unterminated character constant

    /tmp/tmpcd_it_0c.d(18): Error: declaration expected, not `63U`

    /tmp/tmpcd_it_0c.d(18): Error: unterminated character constant

    /tmp/tmpcd_it_0c.d(23): Error: declaration expected, not `assert`

    /tmp/tmpcd_it_0c.d(24): Error: declaration expected, not `assert`

    /tmp/tmpcd_it_0c.d(25): Error: declaration expected, not `assert`

    /tmp/tmpcd_it_0c.d(26): Error: declaration expected, not `assert`

    /tmp/tmpcd_it_0c.d(27): Error: declaration expected, not `assert`

    /tmp/tmpcd_it_0c.d(28): Error: declaration expected, not `assert`

    /tmp/tmpcd_it_0c.d(29): Error: declaration expected, not `assert`

    /tmp/tmpcd_it_0c.d(30): Error: declaration expected, not `assert`

    /tmp/tmpcd_it_0c.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcd_it_0c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long last\
    \ = l[0];\n    bool first = true;\n    for(int i=1; i<l.length; i++) {\n     \
    \   if (l[i]<last) {\n            if (first) {\n                first = false;\n\
    \                return true;\n            }\n            else {\n           \
    \     return false;\n            }\n        }\n        last = l[i];\n    }\n \
    \   return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphk1xmiaz.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x428325]

    ??:? void tmphk1xmiaz.__unittest_L31_C1() [0x427ed7]

    ??:? void tmphk1xmiaz.__modtest() [0x4280a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b23a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43087c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430359]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b211]

    ??:? runModuleUnitTests [0x42c17d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  bool first\
    \ = true;\n  int curr = 1;\n  bool curr = true;\n  bool last = true;\n  long previous\
    \ = l[0];\n  long lastIndex = l.length-1;\n  while(curr <= lastIndex){\n    bool\
    \ next = true;\n    for(int i=0; i<l.length; i++){\n      if(l[i] < previous){\n\
    \tnext = false;\n\tbreak;\n      }\n    }\n    if(next){\n      previous = l[curr];\n\
    \      curr++;\n      first = false;\n    }else{\n      last = false;\n      curr--;\n\
    \    }\n  }\n  if(first || last){\n    return false;\n  }\n  return true;\n}\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnpukm2h4.d(17): Error: declaration `tmpnpukm2h4.monotonic.curr`
    is already defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnpukm2h4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ == 0)\n        return true;\n    long prev = l[0];\n    for(int i = 0; i < l.length\
    \ - 1; ++i)\n        if (l[i+1] < prev)\n            return false;\n        return\
    \ true;\n}\n</code>\n<|/ a tags=c++,arrays dscore=2 |>\n<| a dscore=2 |>\nThe\
    \ easiest way is to sort the array first, then check if the first and last elements\
    \ are the same.\n<|/ a tags=c++,arrays |>\n<| a dscore=1 tags=c++,arrays |>\n\
    A simple approach would be to sort it and then compare the first and last elements\
    \ of the array.\n<code>\nunittest\n{\n    alias candidate = monotonic;\n\n   \
    \ assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1itgal4u.d(23): Error: declaration expected, not `<`

    /tmp/tmp1itgal4u.d(35): Error: declaration expected, not `assert`

    /tmp/tmp1itgal4u.d(36): Error: declaration expected, not `assert`

    /tmp/tmp1itgal4u.d(37): Error: declaration expected, not `assert`

    /tmp/tmp1itgal4u.d(38): Error: declaration expected, not `assert`

    /tmp/tmp1itgal4u.d(39): Error: declaration expected, not `assert`

    /tmp/tmp1itgal4u.d(40): Error: declaration expected, not `assert`

    /tmp/tmp1itgal4u.d(41): Error: declaration expected, not `assert`

    /tmp/tmp1itgal4u.d(42): Error: declaration expected, not `assert`

    /tmp/tmp1itgal4u.d(43): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1itgal4u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  int n =\
    \ l.length-1;\n  \n  if (n <= 0)\n    return false;\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmperz6e8bj.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmperz6e8bj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int j\
    \ = l.length-1;\n    while (j >= 0) {\n        if (l[j] > l[j+1]) return true;\n\
    \        else if(l[j] < l[j+1]) return false;\n        j--;\n    }\n    return\
    \ false;\n}\n</code>\n<|/ a tags=algorithm,sorting,arrays,language-agnostic |>\n\
    <| c |>\nWhat does this have to do with arrays?\n<|/ c |>\n<| c |>\n`monotonic()`\
    \ sorts any kind of sequence. An array of numbers is just one kind of sequence.\n\
    <|/ c |>\n<| c |>\nIt's also pretty inefficient if you're sorting an array of\
    \ integers. You're copying the whole array every time, even when you could just\
    \ compare two integers right away. Also, it's wrong if the array contains any\
    \ duplicates.\n<|/ c |>\n<| c |>\nYes, it is very inefficient to copy the array\
    \ for every comparison. But it can be improved using binary search. Also it is\
    \ incorrect if the array contains any duplicates. In case you know that the array\
    \ won't have duplicates, then you can use the solution I've posted and it will\
    \ work fine.\n<|/ c |>\n<| c |>\nWhat if the array is sorted in ascending order?\
    \ It will give wrong result?\n<|/ c |>\n<| a tags=algorithm,sorting,arrays,language-agnostic\
    \ |>\n<code>\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcv1pm4cx.d(23): Error: declaration expected, not `<`

    /tmp/tmpcv1pm4cx.d(32): Error: unterminated character constant

    /tmp/tmpcv1pm4cx.d(32): Error: unterminated character constant

    /tmp/tmpcv1pm4cx.d(32): Error: unterminated character constant

    /tmp/tmpcv1pm4cx.d(32): Error: unterminated character constant

    /tmp/tmpcv1pm4cx.d(35): Error: unterminated character constant

    /tmp/tmpcv1pm4cx.d(35): Error: unterminated character constant

    /tmp/tmpcv1pm4cx.d(46): Error: declaration expected, not `assert`

    /tmp/tmpcv1pm4cx.d(47): Error: declaration expected, not `assert`

    /tmp/tmpcv1pm4cx.d(48): Error: declaration expected, not `assert`

    /tmp/tmpcv1pm4cx.d(49): Error: declaration expected, not `assert`

    /tmp/tmpcv1pm4cx.d(50): Error: declaration expected, not `assert`

    /tmp/tmpcv1pm4cx.d(51): Error: declaration expected, not `assert`

    /tmp/tmpcv1pm4cx.d(52): Error: declaration expected, not `assert`

    /tmp/tmpcv1pm4cx.d(53): Error: declaration expected, not `assert`

    /tmp/tmpcv1pm4cx.d(54): Error: unrecognized declaration

    F'
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  for(int\
    \ i = 0; i < l.length; i++)\n    if(l[i] > l[i+1]) return true;\n  return false;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp_sds25l_.d(16): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x42838e]

    ??:? bool tmp_sds25l_.monotonic(long[]) [0x427d6a]

    ??:? void tmp_sds25l_.__unittest_L19_C1() [0x427dd9]

    ??:? void tmp_sds25l_.__modtest() [0x42805c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c35f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430385]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430834]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430311]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c9]

    ??:? runModuleUnitTests [0x42c135]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\t// check\
    \ base case\n\tif (l.length==1) return true;\n\t// sort array and take the first\
    \ element as reference\n\tint j=1;\n\tfor (int i = 0; i < l.length; ++i) {\n\t\
    \tlong x = l[i];\n\t\tl[i] = l[j];\n\t\tl[j] = x;\n\t\t++j;\n\t}\n\t\n\t// find\
    \ first non-monotonic element\n\tint i=0;\n\tfor (; i < l.length; ++i) {\n\t\t\
    long x = l[i];\n\t\tif (l[i-1] <= x && x <= l[i]) return false; // no non-monotonic\
    \ here\n\t}\n\treturn true;\n}\n/*\nReturn a new array that is a copy of the original\
    \ but with a new element appended.\n    >>> appendElement(1L, []) -> []\n    >>>\
    \ appendElement(1L, [2L]) -> [2L]\n    >>> appendElement(1L, [2L, 2L]) -> [2L,\
    \ 2L, 2L]\n    >>> appendElement(2L, [2L, 2L]) -> [2L, 2L, 2L, 2L]\n    \n*/\n\
    long[] appendElement(long x, long[] l) \n{\n\tlong[] result = new long[l.length+1];\n\
    \tSystem.arraycopy(l, 0, result, 0, l.length);\n\tresult[l.length] = x;\n\treturn\
    \ result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1a95k569.d(45): Error: undefined identifier `System`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1a95k569.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int m\
    \ = l.Length;\n    if (m < 1)\n        return false;\n    for (int i = 0; i <\
    \ m - 1; ++i)\n        if (l[i] > l[i + 1])\n            return false;\n    return\
    \ true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppqe9i6l2.d(15): Error: no property `Length` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppqe9i6l2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length\
    \ < 2)\n\t\treturn true;\n\tint min = l[0];\n\tint max = l[0];\n\tfor (int i =\
    \ 1; i < l.length; ++i)\n\t{\n\t\tmin = l[i];\n\t\tmax = l[i];\n\t\tif (max <\
    \ min)\n\t\t{\n\t\t\tif (max > 0)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\
    \t\t}\n\t\tif (max < max)\n\t\t\tmax = l[i];\n\t}\n\treturn true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i=0;\n\
    \    int j=1;\n    long temp;\n    while(true)\n    {\n        if(i>=l.length-1)\n\
    \            break;\n        temp = l[i+1];\n        if(temp<l[i])\n        {\n\
    \            return false;\n        }\n        j++;\n        i++;\n    }\n   \
    \ while(true)\n    {\n        if(i<0)\n            return true;\n        temp\
    \ = l[i];\n        if(temp>l[j])\n        {\n            return false;\n     \
    \   }\n        j++;\n        i++;\n    }\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpb8_bspj9.d(35): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4283fe]

    ??:? bool tmpb8_bspj9.monotonic(long[]) [0x427de0]

    ??:? void tmpb8_bspj9.__unittest_L43_C1() [0x427e49]

    ??:? void tmpb8_bspj9.__modtest() [0x4280cc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3cf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b262]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303f5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308a4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430381]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b239]

    ??:? runModuleUnitTests [0x42c1a5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long i\
    \ = 0;\n    long j = 0;\n    bool ans = false;\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1rbijq2s.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1rbijq2s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i,j,k;\n\
    \    long curr = l[0];\n    bool increasing = true;\n    for (i=1; i<l.length;\
    \ i++) {\n        if (curr > l[i]) {\n            increasing = false;\n      \
    \      break;\n        }\n    }\n    for (j=1; j<l.length; j++) {\n        if\
    \ (l[j-1] < curr) {\n            increasing = false;\n            break;\n   \
    \     }\n    }\n    for (k=0; k<l.length; k++) {\n        if (l[k-1] > curr) {\n\
    \            increasing = false;\n            break;\n        }\n    }\n    return\
    \ increasing;\n}\n</code>\n<|/ a tags=stl,c++ |>\n<| c |>\nNice solution, just\
    \ be careful that you test the condition `j < i` rather than `j >= i` in the second\
    \ for loop. Otherwise you get false positives such as `monotonic([10, 9, 1])`\n\
    <|/ c |>\n<| c |>\nI see your point. Thank you!\n<|/ c |>\n<| a dscore=4 |>\n\
    This is not really an answer, but a suggestion...\nThe data structure that comes\
    \ to mind for doing something like this would be a binary tree.  Specifically,\
    \ a red-black tree for binary trees.  In any binary tree, the left and right branches\
    \ of the root node will always have the same color as the root node.  Any time\
    \ the root node is changed color, the entire tree is unbalanced.  In a red-black\
    \ tree, the minimum number of colors that is required to achieve balanced tree\
    \ is 2.  \nYou can easily see that there are two coloring properties for a red-black\
    \ tree.  The root color is always the minimum color that is needed to ensure that\
    \ the tree is balanced.  Anytime a change is made to any node's color, the entire\
    \ tree is unbalanced.  So, you can easily write a function that will test if your\
    \ binary tree is balanced or not.\n<code>\nunittest\n{\n    alias candidate =\
    \ monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4xl415bx.d(38): Error: declaration expected, not `<`

    /tmp/tmp4xl415bx.d(49): Error: unterminated character constant

    /tmp/tmp4xl415bx.d(55): Error: declaration expected, not `assert`

    /tmp/tmp4xl415bx.d(56): Error: declaration expected, not `assert`

    /tmp/tmp4xl415bx.d(57): Error: declaration expected, not `assert`

    /tmp/tmp4xl415bx.d(58): Error: declaration expected, not `assert`

    /tmp/tmp4xl415bx.d(59): Error: declaration expected, not `assert`

    /tmp/tmp4xl415bx.d(60): Error: declaration expected, not `assert`

    /tmp/tmp4xl415bx.d(61): Error: declaration expected, not `assert`

    /tmp/tmp4xl415bx.d(62): Error: declaration expected, not `assert`

    /tmp/tmp4xl415bx.d(63): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4xl415bx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    std.sort(l,\
    \ std.greaterLong);\n    return !std.is_empty(l.slice(0, l.length-1));\n}\n\"\"\
    \")\n    \n    \n    def _is_monotonic(self, l, cmp):\n        # NOTE: this isn't\
    \ very efficient: we sort a copy of\n        # l. \n        # But that's ok, we'll\
    \ just have to deal with the O(n^2)\n        # runtime of sorting a copy. \n \
    \       # So we sort the copy as we go along, then \n        # we'll only ever\
    \ have to look at each element once.\n        \n        std.sort(l, cmp)\n   \
    \     \n        has_last_element = std.is_empty(l[:-1])\n        \n        # first\
    \ element is increasing\n        is_increasing = True\n        \n        for i\
    \ in range(1, len(l)):\n            this_val = l[i]\n            next_val = l[i+1]\n\
    \            \n            if has_last_element:\n                if this_val !=\
    \ next_val:\n                    # not monotonic if last element is not increasing\n\
    \                    return False\n            else:\n                if this_val\
    \ > next_val:\n                    # not monotonic if last element is not increasing\n\
    \                    return False\n                    \n            has_last_element\
    \ = True\n            \n        return is_increasing\n    \n    \n    def _is_monotonic(self,\
    \ l, cmp):\n        # NOTE: this isn't very efficient: we sort a copy of\n   \
    \     # l. \n        # But that's ok, we'll just have to deal with the O(n^2)\n\
    \        # runtime of sorting a copy. \n        # So we sort the copy as we go\
    \ along, then \n        # we'll only ever have to look at each element once.\n\
    \        \n        std.sort(l, cmp)\n        \n        has_last_element = std.is_empty(l[:-1])\n\
    \        \n        # first element is increasing\n        is_increasing = True\n\
    \        \n        for i in range(1, len(l)):\n            this_val = l[i]\n \
    \           next_val = l[i+1]\n            \n            if has_last_element:\n\
    \                if this_val != next_val:\n                    # not monotonic\
    \ if last element is not increasing\n                    return False\n      \
    \      else:\n                if this_val > next_val:\n                    # not\
    \ monotonic if last element is not increasing\n                    return False\n\
    \                    \n            has_last_element = True\n            \n   \
    \     return is_increasing\n    \n    \n    def _is_monotonic(self, l, cmp):\n\
    \        # NOTE: this isn't very efficient: we sort a copy of\n        # l. \n\
    \        # But that's ok, we'll just have to deal with the O(n^2)\n        # runtime\
    \ of sorting a copy. \n        # So we sort the copy as we go along, then \n \
    \       # we'll only ever have to look at each element once.\n\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfz0v1ls0.d(18): Error: declaration expected, not `""`

    /tmp/tmpfz0v1ls0.d(18): Error: unterminated string constant starting at /tmp/tmpfz0v1ls0.d(18)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfz0v1ls0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ == 0)\n    {\n        return true;\n    }\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8bojuxux.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8bojuxux.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  int n =\
    \ l.Length;\n  if (n<2L) return true; // empty array is monotonic\n  if (n==2L)\
    \ return (compare(l[0],l[1])<0L);\n  long prev = l[0];\n  long x0 = l[1];\n  for\
    \ (int i=2L; i<n; i++) {\n    long x = l[i];\n    if (x<prev) {\n      if (x<x0)\
    \ return false;\n    }\n    else if (x>prev) {\n      return true;\n    }\n  \
    \  prev=x;\n  }\n  long x1 = l[n-1];\n  return (compare(x0,x1)>0L);\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph9cirdua.d(15): Error: no property `Length` for type `long[]`

    /tmp/tmph9cirdua.d(17): Error: undefined identifier `compare`

    /tmp/tmph9cirdua.d(31): Error: undefined identifier `compare`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph9cirdua.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min\
    \ = l[0];\n\tlong max = l[0];\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnf3h4e5e.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnf3h4e5e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong min_value\
    \ = l[0], max_value = l[0];\n\tbool result = true;\n\tfor(long i=1; i<l.length;\
    \ i++)\n\t{\n\t\tlong v = l[i];\n\t\tresult = result && (v > max_value) || (v\
    \ < min_value);\n\t\tmin_value = Math.min(min_value, v);\n\t\tmax_value = Math.max(max_value,\
    \ v);\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp15rmxn8w.d(21): Error: undefined identifier `Math`

    /tmp/tmp15rmxn8w.d(22): Error: undefined identifier `Math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp15rmxn8w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    ulong\
    \ count = 0;\n    ulong min = 0;\n    ulong max = l[0]; // first element is always\
    \ the largest\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjj_65rg9.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjj_65rg9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong l =\
    \ l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < l)\n\t\t{\n\
    \t\t\treturn false;\n\t\t}\n\t\tl = l[i];\n\t}\n\treturn true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn8vq10y_.d(15): Error: variable `l` is shadowing variable `tmpn8vq10y_.monotonic.l`

    /tmp/tmpn8vq10y_.d(16): Error: no property `length` for type `long`

    /tmp/tmpn8vq10y_.d(18): Error: only one index allowed to index `long`

    /tmp/tmpn8vq10y_.d(22): Error: only one index allowed to index `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn8vq10y_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  long max=\
    \ l[0];\n  long min= l[0];\n  for( int i=1; i<l.length; i++ ) {\n    if ( l[i]\
    \ < min ) min= l[i];\n    if ( l[i] > max ) max= l[i];\n  }\n  return ( min <\
    \ max );\n}\n'''\n    \nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps29vwbbi.d(23): Error: unterminated character constant

    /tmp/tmps29vwbbi.d(23): Error: declaration expected, not `63U`

    /tmp/tmps29vwbbi.d(23): Error: unterminated character constant

    /tmp/tmps29vwbbi.d(29): Error: declaration expected, not `assert`

    /tmp/tmps29vwbbi.d(30): Error: declaration expected, not `assert`

    /tmp/tmps29vwbbi.d(31): Error: declaration expected, not `assert`

    /tmp/tmps29vwbbi.d(32): Error: declaration expected, not `assert`

    /tmp/tmps29vwbbi.d(33): Error: declaration expected, not `assert`

    /tmp/tmps29vwbbi.d(34): Error: declaration expected, not `assert`

    /tmp/tmps29vwbbi.d(35): Error: declaration expected, not `assert`

    /tmp/tmps29vwbbi.d(36): Error: declaration expected, not `assert`

    /tmp/tmps29vwbbi.d(37): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps29vwbbi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long last=l[0],\
    \ next=l[1];\n    bool is_increasing = true;\n    bool is_decreasing = true;\n\
    \    for (long i=2; i<l.length; ++i)\n    {\n        long a = last;\n        long\
    \ b = next;\n        // if the array is decreasing, the min of next and last must\
    \ be < a\n        if (is_decreasing) {\n            if (a > b) {\n           \
    \     is_decreasing = false;\n            }\n            // if the array is increasing,\
    \ the max of next and last must be > a\n        } else {\n            if (a <\
    \ b) {\n                is_increasing = false;\n            }\n        }\n   \
    \     last = next;\n        next = l[i];\n    }\n    return is_increasing || is_decreasing;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpn9dbdk1x.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x42835d]

    ??:? void tmpn9dbdk1x.__unittest_L38_C1() [0x427f0b]

    ??:? void tmpn9dbdk1x.__modtest() [0x4280dc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b272]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430405]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308b4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430391]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b249]

    ??:? runModuleUnitTests [0x42c1b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428820]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long first\
    \  = l[0];\n    long last = l[0];\n    bool flag = true;\n    for (int i = 1;\
    \ i < l.length; ++i) {\n        if (l[i] < last) {\n            last = l[i];\n\
    \        } else {\n            if (flag) {\n                flag = false;\n  \
    \              return false;\n            }\n        }\n    }\n    return flag;\n\
    }\n</code>\n<|/ a dscore=3 tags=c#,algorithm |>\n<| c |>\nYou don't need a second\
    \ variable here, `last` already holds the most recent value.\n<|/ c |>\n<| c |>\n\
    : Yes, you are right. The variable last is not necessary for the algorithm.\n\
    <|/ c |>\n<| a |>\nAnother solution, with different time complexity (O(n^2) vs\
    \ O(n)). Here we have to use extra array. \n<code>\nprivate static bool IsMonotonic(List<long>\
    \ list)\n{\n    if (list == null || list.Count < 2)\n    {\n        return false;\n\
    \    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpneoeysji.d(30): Error: declaration expected, not `<`

    /tmp/tmpneoeysji.d(33): Error: unterminated character constant

    /tmp/tmpneoeysji.d(46): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpneoeysji.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164494
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev\
    \ = 0;\n    long curr;\n    long min = l[0];\n    long max = l[0];\n    int imax;\n\
    \    int j;\n    for (imax = 0; imax < l.length; imax++) {\n        curr = l[imax];\n\
    \        for (j = imax; j > 0; j--) {\n            if (l[j - 1] > curr) break;\n\
    \            prev = curr;\n            curr = l[j - 1];\n        }\n        max\
    \ = l[imax - 1];\n        if (max < prev) {\n            max = prev;\n       \
    \ }\n        if (min > curr) {\n            min = curr;\n        }\n    }\n  \
    \  return !std.compareLong(max, min);\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvcq3h_ze.d(36): Error: undefined identifier `compareLong` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvcq3h_ze.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tbool res\
    \ = false;\n\tfor (int i = 0; i < l.length; ++i)\n\t\tfor (int j = i; j < l.length;\
    \ ++j)\n\t\t\tif (l[i] < l[j] && l[j] != 0) {\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\treturn res;\n}\n\"\"\")\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpythxfsng.d(24): Error: declaration expected, not `""`

    /tmp/tmpythxfsng.d(24): Error: unterminated string constant starting at /tmp/tmpythxfsng.d(24)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpythxfsng.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for(long\
    \ i=0;i<l.length;i++) \n    {\n        if (l[i]>l[i-1]) return true;\n       \
    \ if (l[i]<l[i-1]) return false;\n    }\n    return false;\n}\nunittest\n{\n \
    \   alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpuw9_z1gb.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4283ee]

    ??:? bool tmpuw9_z1gb.monotonic(long[]) [0x427d72]

    ??:? void tmpuw9_z1gb.__unittest_L22_C1() [0x427e3d]

    ??:? void tmpuw9_z1gb.__modtest() [0x4280c0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3bf]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b252]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303e5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430894]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430371]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b229]

    ??:? runModuleUnitTests [0x42c195]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  if (l.length\
    \ == 0)\n    return true;\n  long m = l[0];\n  for (int i=1; i<l.length; ++i)\
    \ {\n    long cur = l[i];\n    if (cur > m)\n      return false;\n    m = cur;\n\
    \  }\n  return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n   \
    \ assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpghcm789s.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282fd]

    ??:? void tmpghcm789s.__unittest_L26_C1() [0x427e14]

    ??:? void tmpghcm789s.__modtest() [0x428080]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c37f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b212]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430854]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430331]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]

    ??:? runModuleUnitTests [0x42c155]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length\
    \ <= 1) return false;\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor (long i :\
    \ l) {\n\t\tif (i < min)\n\t\t\tmin = i;\n\t\tif (i > max)\n\t\t\tmax = i;\n\t\
    }\n\treturn max < min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n \
    \   assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwk4pbuqp.d(18): Error: semicolon expected, not `:`

    /tmp/tmpwk4pbuqp.d(18): Error: expression expected, not `:`

    /tmp/tmpwk4pbuqp.d(18): Error: found `l` when expecting `;` following `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwk4pbuqp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long long\
    \ max = l[0];\n    bool result = true;\n    for(int i = 1; i < l.length; ++i)\n\
    \    {\n        if(l[i] > max)\n        {\n            max = l[i];\n         \
    \   result = false;\n        }\n    }\n    return result;\n}\n/*\nReturn true\
    \ if array elements are all unique\n    >>> unique([0, 2, 2, 3, 5])\n    true\n\
    \    >>> unique([1, 1, 3])\n    false\n    \n*/\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnfzxkxij.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnfzxkxij.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if(l.length==0)\
    \ return false;\n    int x0 = l[0], x1 = l[1], x_next = x0;\n    int x0_1 = x0,\
    \ x1_1 = x1;\n    while(true)\n    {\n        bool x0_diff = x0_1 > x1;\n    \
    \    bool x1_diff = x1_1 > x0;\n        if(x0_diff!=x1_diff)\n        {\n    \
    \        return (x0_diff || x1_diff);\n        }\n        x_next = (x_next + 1)\
    \ % 10;\n        if(x0 == l[x_next]) return true;\n        x0 = x0_1;\n      \
    \  x1 = x1_1;\n        x0_1 = x1;\n        x1_1 = x_next;\n    }\n    return false;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding how and/or why it solves the problem would improve\
    \ the answer's long-term value.\n<|/ c |>\n<| c |>\nThank you for the feedback\
    \ :)\n<|/ c |>\n<| a tags=arrays,java,sorting dscore=1 |>\nThe idea is to use\
    \ a single array to store the values and compare the values in two for loops.\n\
    <code>\npublic class Test {\n  public static void main(String[] args) {\n    int[]\
    \ array = {-4,3,5,1,6,2,7,8,9};\n    Arrays.sort(array);\n    boolean first =\
    \ true;\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwyedi3ej.d(35): Error: declaration expected, not `<`

    /tmp/tmpwyedi3ej.d(38): Error: unterminated character constant

    /tmp/tmpwyedi3ej.d(49): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpwyedi3ej.d(49): Error: no identifier for declarator `Arrays.sort(array)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwyedi3ej.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int min\
    \ = long.MAX_VALUE;\n    int max = long.MIN_VALUE;\n    for (int i = 0; i < l.length;\
    \ i++)\n    {\n        if (l[i] > max)\n            max = l[i];\n        else\
    \ if (l[i] < min)\n            min = l[i];\n    }\n    return min <= max;\n}\n\
    unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L,\
    \ 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n   \
    \ assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
    \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n   \
    \ assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2g4j0kta.d(15): Error: no property `MAX_VALUE` for type `long`

    /tmp/tmp2g4j0kta.d(16): Error: no property `MIN_VALUE` for type `long`

    /tmp/tmp2g4j0kta.d(20): Error: cannot implicitly convert expression `l[cast(ulong)i]`
    of type `long` to `int`

    /tmp/tmp2g4j0kta.d(22): Error: cannot implicitly convert expression `l[cast(ulong)i]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2g4j0kta.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long i\
    \ = 0;\n    long j = l.length - 1;\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyn_9t5jo.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyn_9t5jo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  long min=0;\n\
    \  long max = l[l.length-1];\n  for(int i=0; i<l.length-1; i++)\n  {\n    if(l[i]<min)\n\
    \    {\n      min=l[i];\n    }\n    if(l[i]>max)\n    {\n      max=l[i];\n   \
    \ }\n  }\n  return max<=min;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpesozlqcp.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x42837d]

    ??:? void tmpesozlqcp.__unittest_L30_C1() [0x427e94]

    ??:? void tmpesozlqcp.__modtest() [0x428100]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b292]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430425]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308d4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303b1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b269]

    ??:? runModuleUnitTests [0x42c1d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428840]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) \n\t{\n\treturn true;\n\t}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8gv6lypd.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8gv6lypd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long maxix\
    \ = 0, minix = l[0] - 1;\n    for (int i = 1; i < l.length; ++i) {\n        if\
    \ (l[i] > l[maxix]) {\n            maxix = i;\n        }\n        if (l[i] < l[minix])\
    \ {\n            minix = i;\n        }\n    }\n    return (l[maxix] < l[minix]);\n\
    }\n</code>\n<|/ a tags=c#,sorting,arrays,algorithm dscore=4 |>\n<| c |>\n`Array.IndexOf`\
    \ will give you `-1` for the first element of the array and it will also give\
    \ you `-1` for the last element of the array, so you don't need to check for `-1`\
    \ before using it.\n<|/ c |>\n<| c |>\nThe first answer was correct. But the others\
    \ have a good point. The answer below is better.\n<|/ c |>\n<| c |>\nThe first\
    \ answer assumes monotonicity but that is not the case in the examples in question\
    \ 2. Also, this answer doesn't use any sorting algorithm so it is slower than\
    \ other answers.\n<|/ c |>\n<| c |>\nWhy does it assume monotonicity? The question\
    \ clearly states that `1 2 3 4` should return `false`.\n<|/ c |>\n<| c |>\nIt\
    \ does, because in all those examples the elements are monotonically increasing\
    \ or decreasing. Only the second example is `1 20 4 10` which returns `true`.\n\
    <|/ c |>\n<| a dscore=4 |>\nThis will return true if the array is sorted and false\
    \ if not:\n<code>\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb0_4uxgr.d(26): Error: declaration expected, not `<`

    /tmp/tmpb0_4uxgr.d(29): Error: unterminated character constant

    /tmp/tmpb0_4uxgr.d(35): Error: unterminated character constant

    /tmp/tmpb0_4uxgr.d(50): Error: declaration expected, not `assert`

    /tmp/tmpb0_4uxgr.d(51): Error: declaration expected, not `assert`

    /tmp/tmpb0_4uxgr.d(52): Error: declaration expected, not `assert`

    /tmp/tmpb0_4uxgr.d(53): Error: declaration expected, not `assert`

    /tmp/tmpb0_4uxgr.d(54): Error: declaration expected, not `assert`

    /tmp/tmpb0_4uxgr.d(55): Error: declaration expected, not `assert`

    /tmp/tmpb0_4uxgr.d(56): Error: declaration expected, not `assert`

    /tmp/tmpb0_4uxgr.d(57): Error: declaration expected, not `assert`

    /tmp/tmpb0_4uxgr.d(58): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb0_4uxgr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong prev\
    \ = 0;\n\tlong curr = 1;\nunittest\n{\n    alias candidate = monotonic;\n\n  \
    \  assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L,\
    \ 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n \
    \   assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps5p18ypd.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps5p18ypd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tif (l.length\
    \ < 2) return false;\n\tbool increasing = true;\n\tfor (int i = 0; i < l.length\
    \ - 1; ++i) {\n\t\tif (l[i] > l[i + 1]) increasing = false;\n\t}\n\treturn increasing;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu9dqisyc.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282fd]

    ??:? void tmpu9dqisyc.__unittest_L22_C1() [0x427ef9]

    ??:? void tmpu9dqisyc.__modtest() [0x42807c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c37f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b212]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303a5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430854]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430331]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1e9]

    ??:? runModuleUnitTests [0x42c155]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287c0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong i,\
    \ j, k, l;\n\tfor (i=1; i<l.length; ++i)\n\t{\n\t\tj = i;\n\t\tk = i;\n\t\twhile\
    \ (j > 0 && l[j-1] > l[j])\n\t\t{\n\t\t\tl[k] = l[j-1];\n\t\t\tj--;\n\t\t\tk--;\n\
    \t\t}\n\t\tif (j == 0)\n\t\t{\n\t\t\tl[k+1] = l[i];\n\t\t}\n\t}\n\tl = l;\n\t\
    if (l.length == 0)\n\t{\n\t\treturn true;\n\t}\n\tfor (int i = l.length-1; i >\
    \ 0; --i)\n\t{\n\t\tk = i;\n\t\tl = i;\n\t\twhile (l > 0 && l[l - 1] > l[l])\n\
    \t\t{\n\t\t\tl--; \n\t\t\tk--;\n\t\t}\n\t\tif (l == 0)\n\t\t{\n\t\t\tl++;\n\t\t\
    }\n\t\tif (l-1 == k || l-1 == k-1)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\t\
    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg85d_9cu.d(15): Error: variable `l` is shadowing variable `tmpg85d_9cu.monotonic.l`

    /tmp/tmpg85d_9cu.d(16): Error: no property `length` for type `long`

    /tmp/tmpg85d_9cu.d(20): Error: only one index allowed to index `long`

    /tmp/tmpg85d_9cu.d(20): Error: only one index allowed to index `long`

    /tmp/tmpg85d_9cu.d(22): Error: only one index allowed to index `long`

    /tmp/tmpg85d_9cu.d(28): Error: only one index allowed to index `long`

    /tmp/tmpg85d_9cu.d(32): Error: no property `length` for type `long`

    /tmp/tmpg85d_9cu.d(36): Error: no property `length` for type `long`

    /tmp/tmpg85d_9cu.d(36): Error: variable `i` is shadowing variable `tmpg85d_9cu.monotonic.i`

    /tmp/tmpg85d_9cu.d(40): Error: only one index allowed to index `long`

    /tmp/tmpg85d_9cu.d(40): Error: only one index allowed to index `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg85d_9cu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int i=0;\n\
    \    for(; i < l.length; i++) \n    {\n        if(l[i] <= l[i+1]) return false;\n\
    \    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpcuimd15z.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282dd]

    ??:? void tmpcuimd15z.__unittest_L22_C1() [0x427df0]

    ??:? void tmpcuimd15z.__modtest() [0x42805c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c35f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430385]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430834]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430311]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c9]

    ??:? runModuleUnitTests [0x42c135]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for(int\
    \ i=0; i < l.length-1; i++)\n    {\n        if(l[i] >= l[i+1])\n            return\
    \ false;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate = monotonic;\n\
    \n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvlaers70.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x4282dd]

    ??:? void tmpvlaers70.__unittest_L22_C1() [0x427edd]

    ??:? void tmpvlaers70.__modtest() [0x428060]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c35f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b1f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430385]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430834]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430311]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1c9]

    ??:? runModuleUnitTests [0x42c135]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287a0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n  if (l.length\
    \ < 2) \n    return false;\n  var first=l[0];\n  var last=l[l.length-1];\n  return\
    \ isZero(first - last);\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpffgigaaj.d(17): Error: undefined identifier `var`

    /tmp/tmpffgigaaj.d(18): Error: undefined identifier `var`

    /tmp/tmpffgigaaj.d(19): Error: undefined identifier `isZero`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpffgigaaj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n\tlong last\
    \ = l[0];\n\tfor (int i = 1; i < l.length; i++) {\n\t\tif (l[i] < last) {\n\t\t\
    \treturn false;\n\t\t}\n\t\tlast = l[i];\n\t}\n\treturn true;\n}\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptd13cgql.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x42830d]

    ??:? void tmptd13cgql.__unittest_L24_C1() [0x427f09]

    ??:? void tmptd13cgql.__modtest() [0x42808c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c38f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b222]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430864]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430341]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b1f9]

    ??:? runModuleUnitTests [0x42c165]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287d0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int low\
    \ = l[0];\n    int high = l[0];\n    int i;\n    for(i=1; i<l.length; ++i) {\n\
    \        long ll = l[i];\n        if(ll>high) return false;\n        if(ll<low)\
    \ return false;\n        high = ll;\n    }\n    return true;\n}\nunittest\n{\n\
    \    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) ==\
    \ true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbznj53vr.d(15): Error: cannot implicitly convert expression `l[0]`
    of type `long` to `int`

    /tmp/tmpbznj53vr.d(16): Error: cannot implicitly convert expression `l[0]` of
    type `long` to `int`

    /tmp/tmpbznj53vr.d(22): Error: cannot implicitly convert expression `ll` of type
    `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbznj53vr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long long\
    \ first = l[0];\n    long long last = l[0];\n    for (long i = 1; i < l.length;\
    \ i++) {\n        if (l[i] < last) {\n            return false;\n        } else\
    \ if (l[i] > first) {\n            return false;\n        }\n        last = l[i];\n\
    \    }\n    return true;\n}\n/*\nReturn true if the array is sorted from low to\
    \ high.\n    >>> monotonicSorted([1L, 2L, 4L, 20L])\n    true\n    >>> monotonicSorted([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonicSorted([4L, 1L, 0L, -10L])\n   \
    \ true\n    \n*/\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ab1gkhv.d(15): Error: use `long` for a 64 bit integer instead
    of `long long`

    /tmp/tmp8ab1gkhv.d(16): Error: use `long` for a 64 bit integer instead of `long
    long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ab1gkhv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    for(var\
    \ i=0;i<l.length-1;i++) \n        if(l[i+1]<l[i]) return false;\n    return true;\n\
    }\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2yphfkqv.d(15): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2yphfkqv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long prev\
    \ = l[0];\n    long curr = l[0];\n    for(long i = 1; i < l.length; ++i)\n   \
    \ {\n        long next = l[i];\n        if(next < prev)\n            return true;\n\
    \        else if(next > curr)\n            return false;\n        prev = next;\n\
    \        curr = next;\n    }\n    return true;\n}\nunittest\n{\n    alias candidate\
    \ = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpphn7nor6.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x428325]

    ??:? void tmpphn7nor6.__unittest_L29_C1() [0x427e3c]

    ??:? void tmpphn7nor6.__modtest() [0x4280a8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3a7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b23a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303cd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43087c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430359]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b211]

    ??:? runModuleUnitTests [0x42c17d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287e8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    if (l.length\
    \ < 2) return false;\n    long last = l[0];\n    for (long i = 1, j = l[1]; i\
    \ <= l.length; i++, j++) {\n        if (l[i] > last || l[j] < last)\n        \
    \    return false;\n        last = l[i];\n    }\n    return true;\n}\nunittest\n\
    {\n    alias candidate = monotonic;\n\n    assert(candidate([1L, 2L, 4L, 10L])\
    \ == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n    assert(candidate([1L,\
    \ 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L, 0L, -10L]) == true);\n\
    \    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L,\
    \ 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
    \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpf99jit81.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x42836d]

    ??:? void tmpf99jit81.__unittest_L24_C1() [0x427e84]

    ??:? void tmpf99jit81.__modtest() [0x4280f0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c3ef]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b282]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430415]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4308c4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4303a1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b259]

    ??:? runModuleUnitTests [0x42c1c5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428830]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    long lo\
    \ = l[0];\n    long hi = l[1];\n    if (lo < hi) {\n        long m = lo + ((hi\
    \ - lo) >> 1);\n        if (m == lo) {\n            return false;\n        }\n\
    \        if (m > hi) {\n            return true;\n        }\n        \n      \
    \  while (m < hi) {\n            m += m;\n            if (m == hi) {\n       \
    \         return false;\n            }\n        }\n        \n        return true;\n\
    \    }\n    return false;\n}\nunittest\n{\n    alias candidate = monotonic;\n\n\
    \    assert(candidate([1L, 2L, 4L, 10L]) == true);\n    assert(candidate([1L,\
    \ 2L, 4L, 20L]) == true);\n    assert(candidate([1L, 20L, 4L, 10L]) == false);\n\
    \    assert(candidate([4L, 1L, 0L, -10L]) == true);\n    assert(candidate([4L,\
    \ 1L, 1L, 0L]) == true);\n    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L,\
    \ 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpzoj34r2a.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x428315]

    ??:? void tmpzoj34r2a.__unittest_L37_C1() [0x427e2c]

    ??:? void tmpzoj34r2a.__modtest() [0x428098]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c397]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b22a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4303bd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x43086c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430349]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b201]

    ??:? runModuleUnitTests [0x42c16d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4287d8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164495
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
    \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n{\n    int min\
    \ = l[0];\n    int max = l[0];\n    int minIndex = 0;\n    int maxIndex = 0;\n\
    \    for (int i=1; i<l.length; i++) {\n        if (l[i] < min) {\n           \
    \ min = l[i];\n            minIndex = i;\n        }\n        if (l[i] > max) {\n\
    \            max = l[i];\n            maxIndex = i;\n        }\n    }\n    if\
    \ (maxIndex-minIndex > 1) {\n        return true;\n    } else {\n        return\
    \ false;\n    }\n}\nunittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
    \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n\
    \    assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L,\
    \ 1L, 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n\
    \    assert(candidate([1L, 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 60L]) == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpezzhksex.d(15): Error: cannot implicitly convert expression `l[0]`
    of type `long` to `int`

    /tmp/tmpezzhksex.d(16): Error: cannot implicitly convert expression `l[0]` of
    type `long` to `int`

    /tmp/tmpezzhksex.d(21): Error: cannot implicitly convert expression `l[cast(ulong)i]`
    of type `long` to `int`

    /tmp/tmpezzhksex.d(25): Error: cannot implicitly convert expression `l[cast(ulong)i]`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpezzhksex.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164495
