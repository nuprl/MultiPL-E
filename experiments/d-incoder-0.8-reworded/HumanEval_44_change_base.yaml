name: HumanEval_44_change_base
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nChange numerical base of input\
  \ number x to base.\n    return string representation after the conversion.\n  \
  \  base numbers are less than 10.\n    >>> change_base(8L, 3L)\n    \"22\"\n   \
  \ >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L, 2L)\n    \"111\"\
  \n    \n*/\nstring change_base(long x, long base) \n"
tests: "unittest\n{\n    alias candidate = change_base;\n\n    assert(candidate(8L,\
  \ 3L) == \"22\");\n    assert(candidate(9L, 3L) == \"100\");\n    assert(candidate(234L,\
  \ 2L) == \"11101010\");\n    assert(candidate(16L, 2L) == \"10000\");\n    assert(candidate(8L,\
  \ 2L) == \"1000\");\n    assert(candidate(7L, 2L) == \"111\");\n    assert(candidate(2L,\
  \ 3L) == \"2\");\n    assert(candidate(3L, 4L) == \"3\");\n    assert(candidate(4L,\
  \ 5L) == \"4\");\n    assert(candidate(5L, 6L) == \"5\");\n    assert(candidate(6L,\
  \ 7L) == \"6\");\n    assert(candidate(7L, 8L) == \"7\");\n}\nvoid main(){}"
completions: ["{\n  int base_index = 0;\n  int i = 0;\n  string res;\n  while (base_index\
    \ < 10)\n  {\n    if (x == 0) \n      return \"0\";\n    i++;\n    x = x / base;\n\
    \    base_index++;\n  }\n  while (x < base)\n  {\n    res += '0';\n    x++;\n\
    \  }\n  res += base;\n  return res;\n}", "{\n\tint ret = 0;\n\tlong tmp = x;\n\
    \tstring tmpstr = \"\";\n\twhile (tmp > 0)\n\t{\n\t\tint digit = tmp % base;\n\
    \t\ttmpstr += (char)digit;\n\t\ttmp = tmp / base;\n\t}\n\treturn tmpstr;\n}",
  "{\n    string ret = \"\";\n    bool is_positive = (x > 0);\n    bool is_negative\
    \ = (x < 0);\n    bool negative = is_negative ? true : false;\n    bool negative_is_positive\
    \ = is_negative == is_positive;\n    long base10 = base;\n    int x = abs(x);\n\
    \    if (x > base)\n    {\n        base10 = base;\n        x = x;\n    }\n   \
    \ bool is_negative_base10 = is_negative && base10 < 0;\n    if (base10 < 0)\n\
    \    {\n        if (is_negative)\n            base10 = -base10;\n        else\n\
    \            base10 = abs(base10);\n    }\n    bool is_negative_base10_negated\
    \ = is_negative && base10 < 0;\n    bool negative_base10_negated = is_negative_base10_negated\
    \ ? true : false;\n    while (x >= base10)\n    {\n        int x_tmp = abs(x);\n\
    \        if (x_tmp > base10)\n        {\n            string tmp_base;\n      \
    \      tmp_base = base;\n            if (is_negative)\n            {\n       \
    \         if (negative_is_positive)\n                    tmp_base = \"-\";\n \
    \           }\n            else\n            {\n                if (negative_base10_negated)\n\
    \                    tmp_base = \"+\";\n            }\n            tmp_base +=\
    \ to_string(abs(base10));\n            x += x_tmp - base10;\n            long\
    \ tmp_x = x;\n            string tmp_ret;\n            while (tmp_x >= base10)\n\
    \            {\n                int tmp_x_tmp = abs(tmp_x);\n                if\
    \ (tmp_x_tmp > base10)\n                {\n                    tmp_x += tmp_x_tmp\
    \ - base10;\n                }\n                else\n                {\n    \
    \                tmp_x += tmp_x_tmp;\n                    break;\n           \
    \     }\n            }\n            tmp_ret = tmp_base + to_string(tmp_x);\n \
    \           if (tmp_ret.length() > ret.length())\n                ret = tmp_ret;\n\
    \        }\n        else\n            x += x_tmp;\n    }\n    if (negative)\n\
    \        ret = (\"-\" + ret);\n    ret += to_string(abs(x));\n    return ret;\n\
    }", "{\n    int exponent = 0;\n    int remainder = 0;\n    string result = \"\"\
    ;\n    while (x >= base) {\n        remainder = x % base;\n        x /= base;\n\
    \        result += char(remainder+48);\n        exponent += 1;\n    }\n    while\
    \ (x) {\n        remainder = x % base;\n        x /= base;\n        result +=\
    \ char(remainder+48);\n        exponent += 1;\n    }\n    while (exponent) {\n\
    \        result += \"0\";\n        exponent--;\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=java,biginteger,base-conversion dscore=3 |>\n<| a tags=java,biginteger,base-conversion\
    \ |>\nThe answer above is correct but incomplete. To fix it you need to add an\
    \ else statement to the inner while loop. Without this the code would always output\
    \ a result with the incorrect number of decimal places (i.e. the output would\
    \ be incorrect if the number was greater than 1 followed by a single digit). \n\
    <code>\n//Convert number x to base b, return string representation of x after\
    \ the conversion\n//base numbers are less than 10\n//Return string representation\
    \ after the conversion\n//If b is 0, return an empty string\nstring baseConverter(long\
    \ x, long b)\n{\n    //Initialize baseConversion to empty\n    string baseConversion\
    \ = \"\";\n    long tempNum = x;", "{\n    switch(base) {\n        case 2:\n \
    \           return int2str(long(x));\n        case 3:\n            return int2str(x%1000L)+\"\
    .\"+int2str(x/1000L);\n        case 4:\n            return int2str(x%1000000L)+\"\
    .\"+int2str(x/1000000L);\n        case 5:\n            return int2str(x%1000000000L)+\"\
    .\"+int2str(x/1000000000L);\n        default:\n            break;\n    }\n   \
    \ return \"Error\";\n}\n/*\nThis function returns number of digits in number\n\
    */", "{\n    if(x <= base*10) \n        return x;\n    long a = x/base;\n    string\
    \ result = to_string(a);\n    if(a%base == 0) \n        result += \"0\";\n   \
    \ result += (base+1) - a;\n    return result;\n}\n</code>\n<|/ a tags=c++,python,number-formatting,python-2.7\
    \ |>\n<| c |>\nFor python3, `print` function will be replaced by `print()` function\n\
    <|/ c |>\n<| a |>\nI recently needed to convert a binary number to an octal number.\
    \ This is what I came up with:\n<code>\ndef bin_to_oct(number):\n    octal_number\
    \ = ''\n    while number:\n        octal_number = chr(int(oct(number)[2:], 8))\
    \ +octal_number\n        number //= 8\n    return octal_number\n</code>\n<|/ a\
    \ tags=c++,python,number-formatting,python-2.7 dscore=1 |>\n<| a tags=c++,python,number-formatting,python-2.7\
    \ dscore=0 |>\nUse string.format or string formatting to convert a number to octal\
    \ or hexidecimal. \n<code>\nprint(format(3L, 'o'))  # '0o3'\nprint(format(3L,\
    \ 'x'))  # '0x3'\n</code>\n<|/ a |>\n<| c |>\nIt is not what OP wants.\n<|/ c\
    \ |>\n<| c |>\nYes, it converts a number to octal, but it doesn't do that in a\
    \ way that meets the OP's requirements.\n<|/ c |>\n<| c |>\nPlease do not add\
    \ 'thank you' as an answer. Once you have sufficient [reputation](https://stackoverflow.com/help/whats-reputation),\
    \ you will be able to [vote up questions and answers](https://stackoverflow.com/help/privileges/vote-up)\
    \ that you found helpful. - [From Review](/review/low-quality-posts/19605724)\n\
    <|/ c |>\n<| a tags=c++,python,number-formatting,python-2.7 |>\nThis works in\
    \ python 2.7\n<code>\ndef binToOctal(number):\n   num = str(number)\n   num =\
    \ num.replace(\"1\",\"\")\n   num = '0' + num\n   num = int(num,8)\n   num = \"\
    %o\" % num\n   return int(num,8)\n</code>\n<|/ a dscore=0 |>\n<| a tags=c++,python,number-formatting,python-2.7\
    \ dscore=0 |>\nThis is my solution\n<code>\ndef binToOctal(number", "{\n    //\
    \ Convert x to string\n    char buf[128];\n    sprintf(buf, \"%ld\", x);\n   \
    \ \n    // Convert buf[] to integer\n    long n = std.conv.strtol(buf, NULL, 10);\n\
    \    \n    // Convert x to base\n    n = (n * base) + x;\n    \n    // Convert\
    \ result to string\n    sprintf(buf, \"%ld\", n);\n    return buf;\n}\n</cell>\n\
    <text>\nDefine a function that gets the exponent of a number.\nThe input number\
    \ x is the number whose exponent is to be found.\nThe output is the exponent of\
    \ the number.\nThe function should return -1 if x is not integer.\nThe function\
    \ should return -1 if x is 0.\nThe function should return -1 if x is negative\
    \ and x is not an integer.\nThe function should return 0 if x is integer.\nThe\
    \ function should return 0 if x is negative and x is integer.\nThe function should\
    \ return 0 if x is an integer and x is 0.\nThe function should return 0 if x is\
    \ an integer and x is negative.", "{\n    if (x < base) {\n        int x_remainder\
    \ = x % base;\n        string x_remainder_str = str(x_remainder);\n        int\
    \ base = base;\n        if (base > 10) {\n            base = base / 10;\n    \
    \    }\n        string x_remainder_str_2 = change_base(x_remainder, base);\n \
    \       string x_remainder_str_3 = str(base*x_remainder);\n        return x_remainder_str_2\
    \ + x_remainder_str_3;\n    }\n    return str(x);\n}", "{\n    long mod = base%x;\n\
    \    string res = \"\";\n    while (mod!=0) {\n        mod = base%x;\n       \
    \ res = string(mod)+res;\n    }\n    return res+to_string(x);\n}\n/*\n    Convert\
    \ decimal number to binary.\n    return string representation after the conversion.\n\
    \    base numbers are less than 10.\n    >>> dec2bin(7L)\n    \"111\"\n    >>>\
    \ dec2bin(8L)\n    \"1000\"\n    >>> dec2bin(33L)\n    \"110011\"\n    \n*/\n\
    string dec2bin(long x) \n{\n    if (x<0) return \"1\"+dec2bin(-x);\n    string\
    \ res = \"\";\n    while (x!=0)\n    {\n        res += string(x%2);\n        x\
    \ /= 2;\n    }\n    return res;\n}\n/*\n    Convert decimal number to hexadecimal\
    \ number.\n    return string representation after the conversion.\n    base numbers\
    \ are less than 16.\n    >>> dec2hex(9L)\n    \"A\"\n    >>> dec2hex(12L)\n  \
    \  \"12\"\n    >>> dec2hex(17L)\n    \"17\"\n    \n*/\nstring dec2hex(long x)\
    \ \n{\n    if (x<0) return \"1\"+dec2hex(-x);\n    string res = \"\";\n    while\
    \ (x!=0)\n    {\n        res += string(x%16);\n        x /= 16;\n    }\n    return\
    \ res;\n}\n/*\n    Convert decimal number to octal number.\n    return string\
    \ representation after the conversion.\n    base numbers are less than 8.\n  \
    \  >>> dec2oct(8L)\n    \"8\"\n    >>> dec2oct(9L)\n    \"9\"\n    >>> dec2oct(16L)\n\
    \    \"10\"\n    \n*/\nstring dec2oct(long x) \n{\n    if (x<0) return \"1\"+dec2oct(-x);\n\
    \    string res = \"\";\n    while (x!=0)\n    {\n        res += string(x%8);\n\
    \        x /= 8;\n    }\n    return res;\n}\n/*\n    Convert decimal number to\
    \ decimal number.\n    return string representation after the conversion.\n  \
    \  base numbers are less than 10.\n    >>> dec2dec(7L)\n    \"7\"\n    >>> dec2dec(8L)\n\
    \    \"8\"\n    >>> dec2dec(33L)\n    \"33\"\n    \n*/\nstring dec2dec(long x)\
    \ \n{\n    if (x<0) return \"1\"+dec2dec(-x);\n    string res = \"\";\n    while\
    \ (x!=0)\n    {\n        res += string(x%10);\n        x /= 10;\n    }\n    return\
    \ res;\n}\n/*\n    Convert ", "{\n    string str = \"\";\n    \n    while (x !=\
    \ 0) {\n        int d = (int)x / base;\n        \n        string num = d.to_string(base);\n\
    \        \n        if (str.length() > 0) \n            str += \"0\";\n       \
    \ \n        str += num;\n        \n        x %= base;\n    }\n    \n    return\
    \ str;\n}\n/*\nChange base2 of input number x to base2.\n    return string representation\
    \ after the conversion.\n    base numbers are less than 10 or 0.\n    >>> change_base2(8L,\
    \ 3L)\n    \"22\"\n    >>> change_base2(8L, 2L)\n    \"1000\"\n    >>> change_base2(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring change_base2(long x, long base2) \n{\n  \
    \  string str = \"\";\n    \n    if (x >= base && x > 0) {\n        \n       \
    \ int d = (int)x / base2;\n        \n        string num = d.to_string(base2);\n\
    \        \n        if (str.length() > 0) \n            str += \"0\";\n       \
    \ \n        str += num;\n        \n        x %= base2;\n    }\n    \n    return\
    \ str;\n}\n/*\nChange base10 of input number x to base10.\n    return string representation\
    \ after the conversion.\n    base numbers are less than 1 or 0.\n    >>> change_base10(8L,\
    \ 3L)\n    \"22\"\n    >>> change_base10(8L, 2L)\n    \"1000\"\n    >>> change_base10(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring change_base10(long x, long base10) \n{\n\
    \    string str = \"\";\n    \n    if (x >= base10 && x > 0) {\n        \n   \
    \     int d = (int)x / base10;\n        \n        string num = d.to_string(base10);\n\
    \        \n        if (str.length() > 0) \n            str += \"0\";\n       \
    \ \n        str += num;\n        \n        x %= base10;\n    }\n    \n    return\
    \ str;\n}", "{\n    int base = min(base, 10);\n    string result = \"\";\n   \
    \ while (x > 0) {\n        int val = x / base;\n        if (val == 0)\n      \
    \      result += \"0\";\n        else\n            result += to_string(val);\n\
    \        x = x - val * base;\n    }\n    while (base > 1) {\n        int val =\
    \ x / base;\n        if (val == 0)\n            result += \"0\";\n        else\n\
    \            result += to_string(val);\n        x = x / base;\n        base--;\n\
    \    }\n    return result;\n}", "{\n    string result = to_string(base);\n   \
    \ int len = result.length();\n    if (x<10) result = std.string(char(x) + result);\n\
    \    else if (x>9 && x<100) result = std.string(char(x%base+10) + result);\n \
    \   else if (x>99 && x<1000) result = std.string(char(x%base+10) + result);\n\
    \    else if (x>999 && x<10000) result = std.string(char(x%base+10) + result);\n\
    \    else if (x>9999 && x<100000) result = std.string(char(x%base+10) + result);\n\
    \    else if (x>99999 && x<1000000) result = std.string(char(x%base+10) + result);\n\
    \    else if (x>999999 && x<10000000) result = std.string(char(x%base+10) + result);\n\
    \    else if (x>9999999 && x<100000000) result = std.string(char(x%base+10) +\
    \ result);\n    else if (x>9999989 && x<1000000000) result = std.string(char(x%base+10)\
    \ + result);\n    else if (x>99999989 && x<10000000000) result = std.string(char(x%base+10)\
    \ + result);\n    else if (x>99999999 && x<100000000000) result = std.string(char(x%base+10)\
    \ + result);\n    else if (x>999999999 && x<1000000000000) result = std.string(char(x%base+10)\
    \ + result);\n    else if (x>99999999999 && x<10000000000000) result = std.string(char(x%base+10)\
    \ + result);\n    else if (x>999999999999 && x<100000000000000) result = std.string(char(x%base+10)\
    \ + result);\n    else if (x>9999999999999 && x<1000000000000000) result = std.string(char(x%base+10)\
    \ + result);\n    else if (x>99999999999999 && x<10000000000000000) result = std.string(char(x%base+10)\
    \ + result);\n    else if (x>999999999999989 && x<100000000000000000) result =\
    \ std.string(char(x%base+10) + result);\n    else if (x>9999999999999989 && x<1000000000000000000)\
    \ result = std.string(char(x%base+10) + result);\n    else if (x>99999999999999989\
    \ && x<100000000000000000) result = std.string(char(x%base+10) + result);\n  \
    \  else if (x>99999999999999999989 && x<1000000000000000000) result = std.string(char(x%base+10)\
    \ + result);\n    else if (x>999999999999999999999989 && x<10000000000000000000)\
    \ result = std.string(char(x", "{\n    int rem;\n    long newnum = x, digit =\
    \ 0;\n    string result;", "{\n    string result = \"\";\n    long m = floor((x\
    \ + 1)/base);\n    long n = x - m*base;\n    while(n > 0)\n    {\n        result\
    \ += (char)('0' + n % base);\n        n /= base;\n    }\n    while(m > 0)\n  \
    \  {\n        result += (char)('0' + m % base);\n        m /= base;\n    }\n \
    \   return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI used the\
    \ solution provided by Ben N. and wrote my code in a more readable way, using\
    \ recursion and templates:\n<code>\n#include <iostream>\nusing namespace std;",
  "{\n    long n = (long) x;\n    string res;\n    char buf[128];\n    string temp;\n\
    \    int i = 0;\n    \n    while (base>0) {\n        long rem = n % base;\n  \
    \      n /= base;\n        buf[i + (base-1)] = rem + '0';\n        i++;\n    }\n\
    \    buf[i + (base-1)] = n + '0';\n    res = Join(buf, i, 0, temp);\n    return\
    \ res;\n}", "{\n    string str = \"\"; \n    \n    if (base == 1) return to_string(x);\
    \ \n    \n    long x_remain = x;\n    long x_unit = 1;\n    string s = \"\";\n\
    \    \n    while (base > 0)\n    {\n        if (x_remain >= base)\n        {\n\
    \            s =  to_string(x_remain/base) + s;\n            x_remain -= x_unit*base;\n\
    \        }\n        else\n        {\n            s = to_string(x_remain) + s;\n\
    \            x_remain = x_unit;\n        }\n        \n        base--;\n      \
    \  x_unit = base;\n    }\n    \n    return s;\n}\n/*\nChange numerical base of\
    \ input number x to base.\n    return string representation after the conversion.\n\
    \    base numbers are less than 10.\n    >>> change_base(8L, 3L)\n    \"22\"\n\
    \    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L, 2L)\n    \"\
    111\"\n    \n*/\nstring change_base(long x, long base, long base2, long base3)\n\
    {\n    string str = \"\"; \n    \n    if (base == 1) return to_string(x); \n \
    \   \n    long x_remain = x;\n    long x_unit = 1;\n    string s = \"\";\n   \
    \ \n    while (base > 0)\n    {\n        if (x_remain >= base)\n        {\n  \
    \          s =  to_string(x_remain/base) + s;\n            x_remain -= x_unit*base;\n\
    \        }\n        else\n        {\n            s = to_string(x_remain) + s;\n\
    \            x_remain = x_unit;\n        }\n        \n        base--;\n      \
    \  x_unit = base;\n    }\n    \n    return s;\n}\n/*\nChange numerical base of\
    \ input number x to base.\n    return string representation after the conversion.\n\
    \    base numbers are less than 10.\n    >>> change_base(8L, 3L)\n    \"22\"\n\
    \    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L, 2L)\n    \"\
    111\"\n    \n*/\nstring change_base(long x, long base1, long base2, long base3,\
    \ long base4, long base5, long base6, long base7)\n{\n    string str = \"\"; \n\
    \    \n    if (base == 1) return to_string(x); \n    \n    long x_remain = x;\n\
    \    long x_unit = 1;\n    string s = \"\";\n    \n    while (base > 0)\n    {\n\
    \        if (x_remain >= base)\n        {\n            s =  to_string(x_remain/base)\
    \ + s;\n            x_remain -= x_unit*base;\n        }\n        else\n      \
    \  {\n            s = to_string(x_remain) + s;\n            x_remain = x_unit;\n\
    \        }\n        ", "{\n    string result = \"\";\n    while (x > base) {\n\
    \        result = (x / base) + result;\n        x = (x % base);\n    }\n    return\
    \ result + to_string(x);\n}", "{\n    if (base == 0)\n    {\n        if (x < 10)\n\
    \        {\n            return to_string(x);\n        }\n        else\n      \
    \  {\n            return \"0\";\n        }\n    }\n    long res = x;\n    while\
    \ (true)\n    {\n        if (res < base)\n        {\n            if (res / base\
    \ != 1)\n            {\n                res++;\n            }\n        }\n   \
    \     else if (res / base == 1)\n        {\n            break;\n        }\n  \
    \      else\n        {\n            res /= base;\n        }\n    }\n    return\
    \ to_string(res);\n}", "{\n\treturn x.to_string(base);\n}\n/*\nChange the base\
    \ of the input number x to base.\n    return string representation after the conversion.\n\
    \    base numbers are less than 10.\n    >>> change_base(8L, 3L)\n    \"22\"\n\
    \    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L, 2L)\n    \"\
    111\"\n    \n*/\nstring change_base(double x, long base) \n{\n\treturn x.to_string(base);\n\
    }\n/*\nChange the base of the input number x to base.\n    return string representation\
    \ after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8L,\
    \ 3L)\n    \"22\"\n    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring change_base(float x, long base) \n{\n\treturn\
    \ x.to_string(base);\n}\n/*\nChange the base of the input number x to base.\n\
    \    return string representation after the conversion.\n    base numbers are\
    \ less than 10.\n    >>> change_base(8L, 3L)\n    \"22\"\n    >>> change_base(8L,\
    \ 2L)\n    \"1000\"\n    >>> change_base(7L, 2L)\n    \"111\"\n    \n*/\nstring\
    \ change_base(long double x, long base) \n{\n\treturn x.to_string(base);\n}\n\
    /*\nChange the base of the input number x to base.\n    return string representation\
    \ after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8L,\
    \ 3L)\n    \"22\"\n    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring change_base(decimal x, long base) \n{\n\t\
    return x.to_string(base);\n}", "{\n    switch(base){\n        case 1L: case 9L:\
    \ return toString(x/10L);\n        case 2L: case 10L: return toString(x/100L);\n\
    \        case 3L: case 11L: return toString(x/1000L);\n        case 4L: case 12L:\
    \ return toString(x/10000L);\n        case 5L: case 13L: return toString(x/100000L);\n\
    \        case 6L: case 14L: return toString(x/1000000L);\n        case 7L: case\
    \ 15L: return toString(x/10000000L);\n        case 8L: case 16L: return toString(x/100000000L);\n\
    \        case 9L: case 17L: return toString(x/1000000000L);\n        case 10L:\
    \ case 18L: return toString(x/10000000000L);\n        case 11L: case 19L: return\
    \ toString(x/100000000000L);\n        case 12L: case 20L: return toString(x/1000000000000L);\n\
    \        case 13L: case 21L: return toString(x/10000000000000L);\n        case\
    \ 14L: case 22L: return toString(x/100000000000000L);\n        case 15L: case\
    \ 23L: return toString(x/1000000000000000L);\n        case 16L: case 24L: return\
    \ toString(x/10000000000000000L);\n        case 17L: case 25L: return toString(x/100000000000000000L);\n\
    \        case 18L: case 26L: return toString(x/1000000000000000000L);\n      \
    \  case 19L: case 27L: return toString(x/10000000000000000000L);\n        case\
    \ 20L: case 28L: return toString(x/100000000000000000000L);\n        case 21L:\
    \ case 29L: return toString(x/1000000000000000000000L);\n        case 22L: case\
    \ 30L: return toString(x/10000000000000000000000L);\n        case 23L: case 31L:\
    \ return toString(x/100000000000000000000000L);\n    }\n}", "{\n\tlong rem;\n\t\
    if (base < 1 || base > 10)\n\t\treturn \"\";\n\t\n\tif (base == 10)\n\t\treturn\
    \ to_string(x % base);\n\t\n\trem = x / base;\n\tx = (x % base);\n\tif (base >\
    \ 2)\n\t\tx /= base;\n\t\n\tstring s = to_string(x);\n\ts = s + to_string(base);\n\
    \ts = s + to_string(x % base);\n\treturn s;\n}", "{\n    if (base == 10) return\
    \ to_string(int(x / base)); // convert to int\n    string num = \"\";\n    do\
    \ {\n        num += to_string(x%base);\n        x /= base;\n    } while (x); \n\
    \    \n    while (num.length() < base) num += \"0\";\n    \n    return num;\n\
    }\n/*\nChange numerical base of input number x to base.\n    return string representation\
    \ after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8L,\
    \ 3L)\n    \"22\"\n    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring change_base(long x, long base)\n{\n    if\
    \ (base == 10) return to_string(x / base); // convert to int\n    string num =\
    \ \"\";\n    do {\n        num += to_string(x%base);\n        x /= base;\n   \
    \ } while (x); \n    \n    while (num.length() < base) num += \"0\";\n    \n \
    \   return num;\n}\n/*\nChange numerical base of input number x to base.\n   \
    \ return string representation after the conversion.\n    base numbers are less\
    \ than 10.\n    >>> change_base(8L, 3L)\n    \"22\"\n    >>> change_base(8L, 2L)\n\
    \    \"1000\"\n    >>> change_base(7L, 2L)\n    \"111\"\n    \n*/\nstring change_base(long\
    \ x, long base)\n{\n    if (base == 10) return to_string(x); // convert to int\n\
    \    string num = \"\";\n    do {\n        num += to_string(x%base);\n       \
    \ x /= base;\n    } while (x); \n    \n    while (num.length() < base) num +=\
    \ \"0\";\n    \n    return num;\n}\n/*\nChange numerical base of input number\
    \ x to base.\n    return string representation after the conversion.\n    base\
    \ numbers are less than 10.\n    >>> change_base(8L, 3L)\n    \"22\"\n    >>>\
    \ change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L, 2L)\n    \"111\"\n\
    \    \n*/\nstring change_base(long x, long base)\n{\n    if (base == 10) return\
    \ to_string(x); // convert to int\n    string num = \"\";\n    do {\n        num\
    \ += to_string(x%base);\n        x /= base;\n    } while (x); \n    \n    while\
    \ (num.length() < base) num += \"0\";\n    \n    return num;\n}\n/*\nChange numerical\
    \ base of input number x to base.\n    return string representation after the\
    \ conversion.\n    base numbers are less than 10.\n    >>> change_base(8L, 3L)\n\
    \    \"22\"\n    >>> change_base(", "{\n\tswitch(base)\n\t{\n\t\tcase 2:\n\t\t\
    \tif (x%2==0)\n\t\t\t{\n\t\t\t\treturn \"0\"+x;\n\t\t\t}\n\t\t\treturn x.ToString();\n\
    \t\t\n\t\tcase 3:\n\t\t\tif (x%3==0)\n\t\t\t{\n\t\t\t\treturn \"000\"+x;\n\t\t\
    \t}\n\t\t\tif (x%5==0)\n\t\t\t{\n\t\t\t\treturn \"00\"+x;\n\t\t\t}\n\t\t\tif (x%7==0)\n\
    \t\t\t{\n\t\t\t\treturn \"0\"+x;\n\t\t\t}\n\t\t\treturn x.ToString();\n\t\t\n\t\
    \tcase 4:\n\t\t\tif (x%5==0)\n\t\t\t{\n\t\t\t\treturn \"000\"+x;\n\t\t\t}\n\t\t\
    \tif (x%9==0)\n\t\t\t{\n\t\t\t\treturn \"00\"+x;\n\t\t\t}\n\t\t\tif (x%11==0)\n\
    \t\t\t{\n\t\t\t\treturn \"0\"+x;\n\t\t\t}\n\t\t\treturn x.ToString();\n\t\t\n\t\
    \tcase 5:\n\t\t\tif (x%7==0)\n\t\t\t{\n\t\t\t\treturn \"000\"+x;\n\t\t\t}\n\t\t\
    \tif (x%11==0)\n\t\t\t{\n\t\t\t\treturn \"00\"+x;\n\t\t\t}\n\t\t\tif (x%13==0)\n\
    \t\t\t{\n\t\t\t\treturn \"0\"+x;\n\t\t\t}\n\t\t\treturn x.ToString();\n\t\t\n\t\
    \tcase 6:\n\t\t\tif (x%9==0)\n\t\t\t{\n\t\t\t\treturn \"000\"+x;\n\t\t\t}\n\t\t\
    \tif (x%13==0)\n\t\t\t{\n\t\t\t\treturn \"00\"+x;\n\t\t\t}\n\t\t\tif (x%15==0)\n\
    \t\t\t{\n\t\t\t\treturn \"0\"+x;\n\t\t\t}\n\t\t\treturn x.ToString();\n\t\t\n\t\
    \tcase 7:\n\t\t\tif (x%11==0)\n\t\t\t{\n\t\t\t\treturn \"000\"+x;\n\t\t\t}\n\t\
    \t\tif (x%15==0)\n\t\t\t{\n\t\t\t\treturn \"00\"+x;\n\t\t\t}\n\t\t\tif (x%17==0)\n\
    \t\t\t{\n\t\t\t\treturn \"0\"+x;\n\t\t\t}\n\t\t\treturn x.ToString();\n\t\t\n\t\
    \tcase 8:\n\t\t\tif (x%13==0)\n\t\t\t{\n\t\t\t\treturn \"000\"+x;\n\t\t\t}\n\t\
    \t\tif (x%17==0)\n\t\t\t{\n\t\t\t\treturn \"00\"+x;\n\t\t\t}\n\t\t\tif (x%19==0)\n\
    \t\t\t{\n\t\t\t\treturn \"0\"+x;\n\t\t\t}\n\t\t\treturn x.ToString();\n\t\t\n\t\
    \tcase 9:\n\t\t\tif (x%15==0)\n\t\t\t{\n\t\t\t\treturn \"000\"+x;\n\t\t\t}\n\t\
    \t\tif (x%19==0)\n\t\t\t{\n\t\t\t\treturn \"00\"+x;\n\t\t\t}\n\t\t\tif (x%21==0)\n\
    \t\t\t{\n\t\t\t\treturn \"0\"+x;\n\t\t\t}\n\t\t\treturn x.ToString();\n\t\t\n\t\
    \tcase 10:\n\t\t\tif (x%19==0)\n\t\t\t{\n\t\t\t\treturn \"000\"+x;\n\t\t\t}\n\t\
    \t\tif (x%21==0)\n\t\t\t{\n\t\t\t\treturn \"00\"+x;\n\t\t\t}\n\t\t\tif (x%23==0)\n\
    \t\t\t{\n\t\t\t\treturn \"0\"+", "{\n    string result = \"\";\n    int len =\
    \ to_string(x).length();\n    string digits = to_string(x).substr(0, len/2);\n\
    \    long num = 0;\n    char c;\n    for(int i = 0; i < digits.length(); i++){\n\
    \        num += digits[i]-'0';\n        c = digits[i + len/2 - 1];\n        if(c\
    \ == '1'){\n            num /= base;\n        }else if(c == '0'){\n          \
    \  num /= base;\n        }\n    }\n    while(num > 0){\n        c = '0' + num\
    \ % base;\n        result = c + result;\n        num /= base;\n    }\n    return\
    \ result;\n}\n/* convert a string to a number */\nlong string_to_number(string\
    \ x){\n    int len = x.length();\n    long num = 0;\n    for(int i = 0; i < len;\
    \ i++){\n        num = num * 10 + x[i] - '0';\n    }\n    return num;\n}\n// change\
    \ base from one to another\nlong changebase(long x, long base){\n    long rem\
    \ = x%base;\n    long tmp = 1L;\n    long res = 0;\n    while(base > rem){\n \
    \       res = res + tmp;\n        tmp *= base;\n        base /= 2;\n    }\n  \
    \  if(rem > 0){\n        res = res + tmp;\n    }\n    return res;\n}\n/* Change\
    \ base from one to another */\nstring changebases(string x, long base){\n    string\
    \ res = \"0\";\n    for(int i = 0; i < x.length(); i++){\n        res += to_string(x)[i]\
    \ - '0';\n    }\n    string tmp = res;\n    long res = string_to_number(res);\n\
    \    return changebase(x,res);\n}\n/*\nFind the factorial of a number represented\
    \ as an integer.\n    numbers are less than 100000.\n    \n*/\nlong factorial(long\
    \ x) \n{\n    long f = 0;\n    for(long i = 1; i < x; i++){\n        f = f * i;\n\
    \    }\n    return f;\n}\n/*\nFind the number of digits in number as integer representation.\n\
    \    numbers are less than 10.\n    \n*/", "{\n    return tostring(x / (long)powl(base,\
    \ base));\n}\n/*\n    \n    Change decimal base of float x to base. \n    return\
    \ string representation after the conversion.\n    base numbers are less than\
    \ 10.\n    >>> change_base(8L, 3L)\n    \"22\"\n    >>> change_base(8L, 2L)\n\
    \    \"1000\"\n    >>> change_base(7L, 2L)\n    \"111\"\n    \n    \n*/\nstring\
    \ change_base(float x, long base) \n{\n    return tostring(x / powl(base, base));\n\
    }\n/*\n    \n    Change decimal base of double x to base. \n    return string\
    \ representation after the conversion.\n    base numbers are less than 10.\n \
    \   >>> change_base(8L, 3L)\n    \"22\"\n    >>> change_base(8L, 2L)\n    \"1000\"\
    \n    >>> change_base(7L, 2L)\n    \"111\"\n    \n    \n*/\nstring change_base(double\
    \ x, long base) \n{\n    return tostring(x / powl(base, base));\n}\n/*\n    \n\
    \    Change the sign of the decimal representation of the input number x to sign.\n\
    \    return string representation after the conversion.\n    positive numbers\
    \ are less than 0.\n    >>> change_sign(8L)\n    \"-8\"\n    >>> change_sign(-8L)\n\
    \    \"8\"\n    \n    \n*/\nstring change_sign(int x) \n{\n    return tostring(x\
    \ < 0 ? (-x)*(-1L) : x);\n}\n/*\n    \n    Change the sign of the decimal representation\
    \ of the input number x to sign.\n    return string representation after the conversion.\n\
    \    positive numbers are less than 0.\n    >>> change_sign(8L)\n    \"-8\"\n\
    \    >>> change_sign(-8L)\n    \"8\"\n    \n    \n*/\nstring change_sign(long\
    \ x) \n{\n    return tostring(x < 0 ? (-x)*(-1L) : x);\n}\n/*\n    \n    Change\
    \ the sign of the decimal representation of the input number x to sign.\n    return\
    \ string representation after the conversion.\n    positive numbers are less than\
    \ 0.\n    >>> change_sign(8L)\n    \"-8\"\n    >>> change_sign(-8L)\n    \"8\"\
    \n    \n    \n*/\nstring change_sign(float x) \n{\n    return tostring(x < 0 ?\
    \ (-x)*(-1L) : x);\n}\n/*\n    \n    Change the sign of the decimal representation\
    \ of the input number x to sign.\n    return string representation after the conversion.\n\
    \    positive numbers are less than 0.\n    >>> change_sign(8L)\n    \"-8\"\n\
    \    >>> change_sign(-8L)\n    \"8\"\n    \n    \n*/\nstring change_sign(double\
    \ x", "{\n\tlong i, ii;\n\t\n\tfor (i = 0, ii = base; (i <= 9) && i < x;++i)\n\
    \t\tx /= base;\n\t\n\tstring s;\n\t\n\tfor (i = base; (i >= 10) && x >= i; --i)\n\
    \t\ts = char(i) + '' + s;\n\t\n\treturn x;\n}", "{\n    string s;\n    long n;",
  "{\n    string str;\n    \n    // Convert 'base' to a string representation of 'base'\
    \ with 'x' decimals\n    str.clear();\n    std.conv.to_str(x, str);\n    \n  \
    \  // Replace base with base in string representation\n    int i = 0;\n    while(i\
    \ < str.size() && str[i] == base) \n        i++;\n    \n    if(i == str.size())\
    \ \n        return str; // no change\n    \n    // replace base with 'base' in\
    \ string representation\n    str.insert(i, base);\n    \n    return str;\n}",
  "{\n    if (base < 2 || base > 36) {\n        throw new ArgumentException(\"Base\
    \ must be between 2 and 36\");\n    }\n    var xAsString = to_string(x);\n   \
    \ string result = \"\";\n    for (int i = xAsString.Length - 1; i >= 0; i--) {\n\
    \        int index = xAsString[i] == '0' ? i - 1 : i;\n        string currentBase\
    \ = digits[base];\n        string next = currentBase[xAsString.Length - 1 - index];\n\
    \        result = next + result;\n    }\n    string trimmed = result.Trim();\n\
    \    string trimmed2 = trimmed.Substring(0, trimmed.Length - 1);\n    return trimmed2;\n\
    }\n/*\n    Converts decimal number to hexadecimal\n    Return string representation\
    \ of hex number\n    >>> to_hex(8)\n    \"0x8\"\n    >>> to_hex(16)\n    \"0xa\"\
    \n    >>> to_hex(32)\n    \"0x8\"\n    >>> to_hex(64)\n    \"0x8\"\n    \n*/\n\
    string to_hex(long x) \n{\n    return string(\"0x\") + to_string(x);\n}\n/*\n\
    \    Converts decimal number to binary\n    Return string representation of binary\
    \ number\n    >>> to_bin(8)\n    \"0b00000001\"\n    >>> to_bin(16)\n    \"0b00000110\"\
    \n    >>> to_bin(32)\n    \"0b00000000\"\n    >>> to_bin(64)\n    \"0b00000000\"\
    \n    \n*/\nstring to_bin(long x) \n{\n    return string(\"0b\") +  to_string(x);\n\
    }\n/*\n    Converts decimal number to octal\n    Return string representation\
    \ of octal number\n    >>> to_oct(8)\n    \"0o0000001\"\n    >>> to_oct(16)\n\
    \    \"0o00000110\"\n    >>> to_oct(32)\n    \"0o00000000\"\n    >>> to_oct(64)\n\
    \    \"0o00000000\"\n    \n*/\nstring to_oct(long x) \n{\n    return string(\"\
    0o\") + to_string(x);\n}\n/*\n    Converts decimal number to decimal\n    Return\
    \ string representation of decimal number\n    >>> to_decimal(8)\n    \"8\"\n\
    \    >>> to_decimal(16)\n    \"16\"\n    >>> to_decimal(32)\n    \"32\"\n    >>>\
    \ to_decimal(64)\n    \"64\"\n    \n*/\nstring to_decimal(long x) \n{\n    return\
    \ to_string(x);\n}\n/*\n    Converts hex number to decimal\n    Return string\
    \ representation of decimal number\n    >>> to_decimal(\"0x8\")\n    \"8\"\n \
    \   >>> to_decimal(\"0xa\")\n    \"10\"\n    >>> to_decimal(\"0x8\")\n    \"8\"\
    \n    \n*/\nstring to_", "{\n    if (base < 1 || base > 10)\n        throw new\
    \ ArgumentException(\"Bad base\");\n    long r = 1;\n    while (x > 0) {\n   \
    \     r = r * base;\n        x /= base;\n    }\n    return to_string(r);\n}",
  "{\n\tstring result = \"\";\n    \n\tfor (int i = 0; i < base; i++) {\n\t\tresult\
    \ += char(x);\n\t\tx /= base;\n    }\n    return result;\n}\n/*\nConvert the given\
    \ string in base ten to the given radix. Base 10 is 10.\n    \nReturn string representation\n\
    \    \n*/\nstring to_radix(string x, int t) \n{\n\tchar result = x[0];\n\tfor\
    \ (int i = 1; i < x.length(); i++) {\n\t\tif (x[i] >= '0' && x[i] <= '9') {\n\t\
    \t\tresult *= t;\n\t\t\tresult += x[i] - '0';\n\t\t} else {\n\t\t\treturn to_radix(x,\
    \ 10);\n\t\t}\n\t\tt /= 10;\n\t}\n\treturn result;\n}", "{\n    long temp = x;\n\
    \    \n    while (temp > 0) {\n        int d = (int)temp % base;\n        if (d\
    \ == 0)\n            return to_string(base * int(temp / base));\n        temp\
    \ /= base;\n    }\n    \n    return \"0\";\n}", "{\n\tif(x < 10)\n\t{\n\t\tstring\
    \ res = to_string(long(x))+base;\n\t\treturn res;\n\t}\n\tstring res = \"0\";\n\
    \tlong tmp = long(x);\n\tlong p = base;\n\twhile(p > 0)\n\t{\n\t\tlong r = long(tmp\
    \ / p);\n\t\tif(p > 1)\n\t\t\tr *= p;\n\t\ttmp = tmp - r*p;\n\t\tres = to_string(tmp)+res;\n\
    \t\tp--;\n\t}\n\treturn res;\n}\n/*\nFind if n is a number base or is base in\
    \ n's base.\n    n must be integer.\n    >>> is_base(\"111\", 3L)\n    True\n\
    \    >>> is_base(\"111\", 1L)\n    False\n    >>> is_base(\"111\", 2L)\n    True\n\
    \    \n*/", "{\n\tstring result = \"\";\n\tint num_digit = base;\n\tstring num_str\
    \ = to_string(x);\n\tfor(int i = 0; i < num_digit; i++)\n\t{\n\t\tresult += num_str[num_digit-i-1];\n\
    \t}\n\treturn result;\n}", "{\n\tstring str = to_string_base(x, base);\n\tstr[0]\
    \ = str[0].to_string() + str[1].to_string();\n\treturn str;\n}\n/*\nChange numerical\
    \ base of input number x to base.\n    return string representation after the\
    \ conversion.\n    base numbers are less than 10.\n    >>> change_base(8L, 3L)\n\
    \    \"22\"\n    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring change_base(double x, double base) \n{\n\t\
    string str = to_string_base(x, base);\n\tstr[0] = str[0].to_string() + str[1].to_string();\n\
    \treturn str;\n}", "{\n\tstring s = \"\";\n\tint sign;\n\tif (x < 0)\n\t\tsign\
    \ = 1;\n\telse\n\t\tsign = -1;\n\tstring digits = \"0123456789abcdefghijklmnopqrstuvwxyz\"\
    ;\n\tstring tens = \"0000000\";\n\t\n\twhile (base > 0) {\n\t\tlong tmp = x /\
    \ base;\n\t\tint idx = tmp % base;\n\t\ts = digits[idx] + s;\n\t\tx = tmp / base;\n\
    \t\tbase = base * 10;\n\t}\n\t\n\tif (sign == -1)\n\t\ts = tens[9 - s.length()]\
    \ + s;\n\t\n\treturn s;\n}", "{\n    if (base < 2 || base > 36)\n        throw\
    \ new Exception(\"invalid base\");", "{\n    if (x > base)\n\t{\n\t    string\
    \ result = \"\";\n\t    int q = x;\n\t    int r = 1;\n\t    while (r < base)\n\
    \t\t{\n\t\t    r = std.math.floor((double)r / base);\n\t\t    result += q % base;\n\
    \t\t    q = q / base;\n\t\t}\n\t    result += q;\n\t    std.debug.assert(result\
    \ == x);\n\t    return result;\n\t}\n    return x;\n}\n// end of change_base",
  "{\n    string result = \"\";\n    long a = x / base;\n    if (a > 10)\n       \
    \ return \"\";\n    string str = \"\" + a ;\n    char first = str[0];\n    string\
    \ rest = str.substr(1);\n    long b = base ;\n    \n    for (int i = 0; i < rest.size();\
    \ i++)\n    {\n        b *= base;\n        \n        if (rest [i] == '0') \n \
    \       {\n            result += char('0' + str[i]);\n        }\n        else\n\
    \        {\n            result += char('a' + str[i] - 'a' + 1);\n        }\n \
    \   }\n    result += char('0' + str[rest.size()]);\n    \n    result = \"\" +\
    \ b + result;\n    \n    result += '0' * (x - b * base);\n    return result;\n\
    }\n</code>\n<|/ a tags=string,algorithm,c++,numbers |>\n<| c |>\nWhat happens\
    \ if you pass a base greater than 10?\n<|/ c |>\n<| c |>\nIt gives me the wrong\
    \ output. Instead of \"101010\" it gives me \"101001001\"\n<|/ c |>\n<| c |>\n\
    What happens if you pass a base greater than 10? I get the correct output\n<|/\
    \ c |>\n<| c |>\nI am testing it right now and I will update the post here with\
    \ the output\n<|/ c |>\n<| c |>\nThis does not work for all bases greater than\
    \ 10.  For example, try with base = 4.  It prints \"111\", but the correct answer\
    \ is \"1010\".  You have to check your answer against the right answer from the\
    \ question.\n<|/ c |>\n<| a |>\nI guess that you want something like this\n<code>\n\
    std::string change_base(const std::string &s, int b)\n{\n    std::string result;\n\
    \    while (b > 0)\n    {\n        result += s.substr(0, 1);\n        bool first\
    \ = true;\n        for (int i = 1; i < s.length(); ++i)\n        {\n         \
    \   result += (char)(s.at(i) - 'a' + (first ? '1' : '0'));\n            first\
    \ = false;\n        }\n        s = s.substr(1);\n        --b;\n    }\n    return\
    \ result;\n}\n</code>\nIf your input string can contain any number of zeros and\
    \ ones, the result should be an empty string if no bases are used.\nEdit: You\
    \ can change the base of input number x to base by calling the function with x\
    \ % base as the second argument and adding zeros until there are no zeros in the\
    \ string.\n<|/ a dscore=3 tags=string,algorithm,c++,numbers |>\n<| a dscore=2\
    \ |>\nThis works for any base, including base 10. \n<code>\n#include <string>\n\
    #include <algorithm>\n#include <numeric>\n#include <io", "{\n    switch(base)\n\
    \    {\n    case 10:\n        if(x < 10)\n        {\n            return to_string(x);\n\
    \        }\n        else\n        {\n            return \"0\" + to_string(x);\n\
    \        }\n        break;\n    case 8:\n        if(x < 10)\n        {\n     \
    \       return to_string(x);\n        }\n        else\n        {\n           \
    \ return \"00\" + to_string(x);\n        }\n        break;\n    case 6:\n    \
    \    if(x < 10)\n        {\n            return to_string(x);\n        }\n    \
    \    else\n        {\n            return \"000\" + to_string(x);\n        }\n\
    \        break;\n    case 3:\n        if(x < 10)\n        {\n            return\
    \ to_string(x);\n        }\n        else\n        {\n            return \"0000\"\
    \ + to_string(x);\n        }\n        break;\n    case 2:\n        if(x < 10)\n\
    \        {\n            return to_string(x);\n        }\n        else\n      \
    \  {\n            return \"00000\" + to_string(x);\n        }\n        break;\n\
    \    case 1:\n        if(x < 10)\n        {\n            return to_string(x);\n\
    \        }\n        else\n        {\n            return \"000000\" + to_string(x);\n\
    \        }\n        break;\n    default:\n        assert(false);\n    }\n}", "{\n\
    \tstringstream ss;\n\tint remainder;\n\tlong remain_digit;\n\tss.setf(ios_base::hex,\
    \ ios_base::basefield);\n\tss.fill('0');\n\tss << base;\n\twhile(x != 0) {\n\t\
    \tremainder = x / base;\n\t\tremain_digit = x % base;\n\t\tss << remain_digit;\n\
    \t\tx = remainder;\n\t}\n\treturn ss.str();\n}", "{\n    string rep = string(x);\n\
    \    for (size_t i=0; i < rep.size(); i++)\n    {\n        char c = rep[i];\n\
    \        if (c >= '0' && c <= '9')\n            c -= '0';\n        else if (c\
    \ >= 'a' && c <= 'z')\n            c -= 'a' - 'a';\n        else if (c >= 'A'\
    \ && c <= 'Z')\n            c -= 'A' - 'A';\n        else\n            throw \"\
    Unimplemented base conversion method\";\n        rep[i] = c;\n    }\n    \n  \
    \  double nx = std.double.parse(rep);\n    double nx_scaled = std.double.parse(rep.to_string());\n\
    \    \n    // convert base to binary\n    long nx_bits = std.long.bitCount(nx_scaled);\n\
    \    long x_bits = std.long.bitCount(x);\n    \n    // adjust number if base is\
    \ too large\n    if (x_bits > nx_bits)\n        nx_scaled *= pow(10, x_bits -\
    \ nx_bits);\n    \n    // convert decimal to binary\n    string nx_bin = to_string(std.int.toBits(nx_scaled));\n\
    \    \n    // adjust number if base is too large\n    if (nx_bits < x_bits)\n\
    \        nx_bin += \"0\" * (x_bits - nx_bits);\n    \n    // convert binary to\
    \ base\n    string rep_x = to_string(nx_bin);\n    for (size_t i=0; i < rep_x.size();\
    \ i++)\n    {\n        char c = rep_x[i];\n        if (c >= '0' && c <= '9')\n\
    \            c -= '0';\n        else if (c >= 'a' && c <= 'z')\n            c\
    \ -= 'a' - 'a';\n        else if (c >= 'A' && c <= 'Z')\n            c -= 'A'\
    \ - 'A';\n        else\n            throw \"Unimplemented base conversion method\"\
    ;\n        rep_x[i] = c;\n    }\n    \n    // adjust number if base is too large\n\
    \    if (rep_x.size() > base)\n        rep_x = rep_x.substr(0, base);\n    \n\
    \    return rep_x;\n}", "{\n    string binary = string(rep(\"0\", base));\n  \
    \  for(int i = base-1; i >= 0; --i) {\n        char c = digit(x);\n        if(c\
    \ != '0') \n            binary = string(c) + binary;\n        x = x >> 1;\n  \
    \  }\n    return binary;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI do not understand\
    \ how this answers the question.\n<|/ c |>\n<| a dscore=0 tags=c++ |>\nI didn't\
    \ like any of the solutions posted here, because they are quite incomplete and\
    \ they only work for small numbers. I found this solution to be the simplest and\
    \ most efficient to understand. \nThis solution works for all numbers as long\
    \ as they fit in a long long. \n<code>\n#include <iostream>\n#include <string>\n\
    #include <cmath>", "{\n    string result;\n    char tmp;", "{\n    long i, power\
    \ = 1;\n    string ans = \"\";", "{\n    int quotient = x / base;\n    int remainder\
    \ = x % base;\n    string s = to_string(quotient);\n    while (s.size() > 1)\n\
    \    {\n        s = to_string(quotient % base) + s;\n        quotient = (quotient\
    \ / base);\n    }\n    if (remainder == 0)\n        return s;\n    else\n    \
    \    return s + to_string(remainder);\n}\n</code>\n<|/ a tags=string,python dscore=1\
    \ |>\n<| c |>\nHow about a link to the documentation to help OP understand why\
    \ `int` isn't returning the same value as `long`?\n<|/ c |>\n<| c |>\nI have already\
    \ added the comment about that. I was just trying to give the OP an example of\
    \ how to solve the problem.\n<|/ c |>\n<| a dscore=0 |>\nThe main issue is that\
    \ you are trying to divide a long by an int, and you are getting a int back, so\
    \ the division is truncating, giving you a 0 for the rest of your code. Try converting\
    \ your long into an int first, and it should fix your issue.\n<code>\ndef changebase(long,\
    \ int):\n    quotient = long // int\n    remainder = long % int\n    if remainder\
    \ == 0:\n        return str(quotient)\n    else:\n        return str(quotient)+str(remainder)\n\
    </code>\n<|/ a tags=string,python |>\n<| c |>\nWhy are you converting long to\
    \ int? This is an issue since python 2 will automatically do that for you.\n<|/\
    \ c |>\n<| c |>\nI agree that it would automatically convert it to an int, but\
    \ I'm doing this for the sake of showing how to do it, and I didn't want to change\
    \ his code too much\n<|/ c |>\n<| c |>\nThis doesn't work. If `long` is 10000000\
    \ then `quotient` will be 0 since it's dividing by an int.\n<|/ c |>\n<| c |>\n\
    I'm sorry, I misread. I thought he was trying to convert it as an int\n<|/ c |>\n\
    <| c |>\nIt's not the conversion, it's the division which is truncating the division.\n\
    <|/ c |>\n<| a tags=string,python |>\nI would do this using divmod and formatting.\n\
    <code>\ndef changebase(long, int):\n    return str(int('{0:d}//{1:d}'.format(int(long),\
    \ int))) + format(int('{0:d}%{1:d}'.format(int(long), int(int)))%int, 'b')", "{\n\
    \    long i = 1;\n    string result = \"\";", "{\n    string result = \"\";\n\
    \    long num = x;\n    \n    while (num > 0)\n    {\n        string s = (num\
    \ % base) + result;\n        num /= base;\n        result = s;\n    }\n    \n\
    \    if (result[0] == '1')\n    {\n        result = result + \"0\";\n    }\n \
    \   \n    return result;\n}", "{\n  if (base == 10 && x == 0) return \"0\";\n\
    \  string res;\n  long t = x;\n  int i = (int)(x / base);\n  while (i) {\n   \
    \ int power = (int)pow(base, i);\n    res += to_string(power);\n    i -= power;\n\
    \  }\n  res += to_string((int)x);\n  return res;\n}", "{\n    bool isNegative\
    \ = x < 0;\n    if (isNegative)\n        x = -x;\n    \n    long x_tmp = x;\n\
    \    \n    // Base 3 --> base 10\n    if (base == 3L)\n    {\n        while (true)\n\
    \        {\n            while (x_tmp > 0)\n            {\n                long\
    \ sum = 0;\n                while (x_tmp > 0)\n                {\n           \
    \         long n = x_tmp;\n                    x_tmp /= base;\n              \
    \      if (n < base)\n                        sum += (n-1) * pow(base, n);\n \
    \                   else\n                        sum += n * base;\n         \
    \       }\n                if (x_tmp == 0)\n                {\n              \
    \      return \"0\";\n                }\n                if (sum > 9)\n      \
    \          {\n                    return \"0\" + sum;\n                }\n   \
    \             else\n                {\n                    return \"0\" + sum;\n\
    \                }\n            }\n            while (x_tmp < 0)\n           \
    \ {\n                long sum = 0;\n                while (x_tmp < 0)\n      \
    \          {\n                    long n = x_tmp;\n                    x_tmp /=\
    \ base;\n                    if (n < base)\n                        sum += (n-1)\
    \ * pow(base, n);\n                    else\n                        sum += n\
    \ * base;\n                }\n                if (x_tmp == 0)\n              \
    \  {\n                    return \"0\";\n                }\n                if\
    \ (sum > 9)\n                {\n                    return \"0\" + sum;\n    \
    \            }\n                else\n                {\n                    return\
    \ \"0\" + sum;\n                }\n            }\n        }\n    }\n    \n   \
    \ // Base 10 --> base 3\n    else if (base == 10L)\n    {\n        while (true)\n\
    \        {\n            while (x_tmp >= 9)\n            {\n                long\
    \ sum = 0;\n                while (x_tmp >= 9)\n                {\n          \
    \          long n = x_tmp;\n                    x_tmp /= base;\n             \
    \       if (n < base)\n                        sum += (n-1) * pow(base, n);\n\
    \                    else\n                        sum += n * base;\n        \
    \        }\n                if (x_tmp == 9)\n                {\n             \
    \       return \"0\" + sum;\n                }\n                if (sum > 9)\n\
    \                {\n                    return \"0\" + sum;\n                }\n\
    \                else\n                {\n                    return \"0\" + sum;\n\
    \                }\n            }\n            while (x_tmp < 9)\n           \
    \ {\n                long sum = 0;\n                while (x_tmp < 9)\n      \
    \          {\n                    long n = x_tmp;\n                    x_tmp /=\
    \ base;\n                    if (n < base)\n                        sum += (n-1)\
    \ * pow(base, n);\n                    else\n                        sum += n\
    \ * base;\n                }\n                if (x_tmp == 9)\n              \
    \  {\n                    return \"0\" + sum;\n                }\n           \
    \     if (sum > 9)\n                {\n                    return \"0\" + sum;\n\
    \                }\n                else\n                {\n                \
    \    return \"0\" + sum", "{\n  if (base < 0 || base > 10)\n    return error(\"\
    Base should be less than 10\");\n  // check input validity\n  if (x < 0)\n   \
    \ return error(\"Invalid input (must be non-negative)\");\n  if (base == 0)\n\
    \    return \"\";\n  \n  long ten = base;\n  // handle negative input first\n\
    \  if (x < 0)\n    x = -x;\n  long t = x;\n  while (t >= base) {\n    t /= base;\n\
    \    ten *= base;\n  }\n  while (t < 1) {\n    ten *= base;\n  }\n  // change\
    \ to base base and output string\n  string s = to_string(ten);\n  t = ten / base;\n\
    \  while (t > 1) {\n    s /= base;\n    ten /= base;\n    t = ten / base;\n  }\n\
    \  string zeros = to_string(base);\n  s = s + zeros;\n  if (t < base)\n    s +=\
    \ to_string(base);\n  return s;\n}\n/*\nConvert x to string representation\n \
    \   positive numbers represented with base\n    negative numbers represented with\
    \ base - 10", "{\n    string str=\"\";\n    double dx=0;\n    double dbase;\n\
    \    long n=0,m=0;\n    while(base>0){\n        n++;\n        base/=10;\n    }\n\
    \    dbase=base;\n    while(base>0){\n        str=str+\"0\"+(base%10);\n     \
    \   base/=10;\n    }\n    while(base>0){\n        m++;\n        str=str+(char)(dbase%10);\n\
    \        dbase/=10;\n    }\n    if(m>n){\n        for(long i=m-1;i>=0;i--){\n\
    \            str=str+\"0\";\n        }\n    }\n    dx=dx*pow(10.0,n);\n    dx+=x;\n\
    \    while(!(dx>0)){\n        dx/=10;\n    }\n    return std.conv.tostring(dx);\n\
    }\n// End of function change_base", "{\n    if (x < 10)\n    {\n        string\
    \ result = to_string(base) + to_string(x);\n        return result;\n    }\n  \
    \  \n    long y = x / base;\n    \n    string result = to_string(x/base) + to_string(base)\
    \ + to_string(y);\n    return result;\n}", "{\n    if(base < 10)\n    {\n    \
    \    return \"Base \" + to_string(base) + \" value \" + to_string(x) + \" is out\
    \ of the range of base \" + to_string(10) + \".\";\n    }\n    if(base == 10)\n\
    \    {\n        return x;\n    }\n    string result;\n    long temp = x / base;\n\
    \    string firstpart = to_string(temp);\n    string tail = \"\";\n    while(temp\
    \ != 1)\n    {\n        temp = temp / base;\n        tail = to_string(temp) +\
    \ tail;\n    }\n    result = firstpart + tail;\n    return result;\n}", "{\n \
    \   if (x < base)\n    {\n        auto n = x / (long)base;\n        return to_string(base\
    \ * n);\n    }\n    else\n    {\n        auto n = x / base;\n        return to_string(base\
    \ * (n + 1));\n    }\n}\n</code>\nIt uses recursion to find the most significant\
    \ digit of the number and then uses that to perform the math. \nHere's a demo.\n\
    <code>\n#include <iostream>\n#include <cmath>\n#include <iomanip>\nusing namespace\
    \ std;", "{\n\tstring result = \"\";\n\tlong remainder = x;\n\t\n\twhile (base\
    \ > 0) {\n\t\tlong quotient = remainder / base;\n\t\tlong mod = remainder % base;\n\
    \t\t\n\t\tstring digit = to_string(base);\n\t\t\n\t\tresult += (digit.empty()\
    \ ? \"\" : digit) + to_string(quotient);\n\t\t\n\t\tremainder = mod;\n\t\tbase--;\n\
    \t}\n\t\n\treturn result;\n}\n/*\n    Converts base 10 to base (base is greater\
    \ than zero and less than 20).\n    base numbers are less than 10.\n    >>> base_to_base(8L,\
    \ 3L)\n    \"22\"\n    >>> base_to_base(8L, 2L)\n    \"1000\"\n    >>> base_to_base(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring base_to_base(long x, long base) \n{\n\tstring\
    \ result = \"\";\n\tlong remainder = x;\n\t\n\twhile (base > 0) {\n\t\tlong quotient\
    \ = remainder / base;\n\t\tlong mod = remainder % base;\n\t\t\n\t\tstring digit\
    \ = to_string(base);\n\t\t\n\t\tresult += (digit.empty() ? \"\" : digit) + to_string(quotient);\n\
    \t\t\n\t\tremainder = mod;\n\t\tbase--;\n\t}\n\t\n\treturn result;\n}", "{\n \
    \   assert(base <= 10);\n    int remainder = x % base;\n    long result = x /\
    \ base;\n    string res = \"\";\n    while (remainder) {\n        res += \"0123456789abcdefghijklmnopqrstuvwxyz\"\
    .charAt((int)remainder % base);\n        remainder /= base;\n    }\n    return\
    \ res+result;\n}\n/*\nConvert a number from one base to another.\n    x is string\
    \ representation of number. \n    base numbers are less than 10.\n    >>> base10tobase2(8L)\n\
    \    \"1000\"\n    >>> base10tobase2('8')\n    \"1000\"\n    >>> base10tobase2('8')\n\
    \    \"1000\"\n    >>> base10tobase2('a')\n    \"1010\"\n    \n*/\nstring base10tobase2(long\
    \ x) \n{\n    assert(x < 210);\n    string result = \"\";\n    string firstpart\
    \ = \"\";\n    string lastpart = \"0\";\n    while (x > 0) {\n        int c =\
    \ (int)x % 10;\n        firstpart += (char)(10*c + c);\n        x /= 10;\n   \
    \ }\n    while (x > 1) {\n        int c = (int)x % 10;\n        lastpart += (char)(10*c\
    \ + c);\n        x /= 10;\n    }\n    return firstpart+lastpart;\n}\n/*\nConvert\
    \ a decimal to its base 10 representation.\n    x is decimal number.\n    >>>\
    \ base10todecimal(8)\n    8\n    >>> base10todecimal(100)\n    8\n    >>> base10todecimal(8L)\n\
    \    8\n    >>> base10todecimal(8L)\n    8\n    >>> base10todecimal('8')\n   \
    \ 8\n    >>> base10todecimal('a')\n    10\n    >>> base10todecimal(2.5)\n    10\n\
    \    >>> base10todecimal('2.5')\n    10\n    \n*/\nlong base10todecimal(string\
    \ x) \n{\n    long result = 0;\n    bool negative = false;\n    bool neg = false;\n\
    \    bool even = false;\n    bool zero = false;\n    int len = x.length();\n \
    \   if (len == 0) \n        return 0;\n    if (x.at(0) != '-') \n        negative\
    \ = false;\n    else if (x.at(0) == '-') {\n        negative = true;\n       \
    \ neg = true;\n        x.at(0) ='0';\n        x.at(1) ='0';\n    }\n    if (x.at(0)\
    \ == '0') {\n        zero = true;\n        x.at(0) ='0';\n        x.at(1) ='0';\n\
    \    }\n    if (x.at(0) == '1') {\n        zero = false;", "{\n    if (x < 10)\
    \ {\n        if (base == 10) {\n            return string(x, 'a');\n        }\
    \ else if (base == 16) {\n            return string(x, 'A');\n        } else if\
    \ (base == 8) {\n            return string(x, 'b');\n        } else if (base ==\
    \ 2) {\n            return string(x, 'c');\n        } else if (base == 1) {\n\
    \            return string(x, 'd');\n        }\n    }\n    else {\n        if\
    \ (base == 10) {\n            return string(x, '0');\n        } else if (base\
    \ == 16) {\n            return string(x, '0');\n        } else if (base == 8)\
    \ {\n            return string(x, '0');\n        } else if (base == 2) {\n   \
    \         return string(x, '0');\n        } else if (base == 1) {\n          \
    \  return string(x, '0');\n        }\n    }\n}", "{\n  int x_i = (int)x;\n  int\
    \ x_frac = x_i % (int)base;\n  int x_rem = (int)base - x_frac;\n  string r = \"\
    \";\n  if (x_frac >= 0)\n  {\n    if (x_frac <= 9)\n    {\n      r += \"0\";\n\
    \      r += x_frac;\n    }\n    else\n    {\n      r += x_frac + \"0\";\n    \
    \  x_frac = (int)x_rem;\n      r += x_frac;\n    }\n  }\n  else\n  {\n    if (x_frac\
    \ <= 9)\n    {\n      r += x_frac;\n    }\n    else\n    {\n      r += \"0\";\n\
    \      r += x_frac;\n    }\n  }\n  r = r + x_rem;\n  return r;\n}", "{\n    string\
    \ str;\n    string s = to_str(x);\n    int n = s.length();\n    int r = n;\n \
    \   long temp;\n    int i;", "{\n\tif (base == 0 || x == 0)\n\t\treturn \"0\"\
    ;\n\tif (x > base)\n\t\treturn \"invalid input\";\n\tif (x <= 10)\n\t\treturn\
    \ to_string(static_cast<long long>(static_cast<int>(x)) % base);\n\tstring res(\"\
    \");\n\tdo\n\t{\n\t\tlong mod = (static_cast<long long>(x)/base) % base;\n\t\t\
    int rem = (static_cast<long long>(x)/base) / base;\n\t\tx -= mod * base;\n\t\t\
    res = to_string(mod) + res;\n\t\tx = rem;\n\t}\n\twhile (x!=0);\n\treturn res;\n\
    }", "{\n    // convert to string if needed\n    long str_x = 0;\n    string str_base\
    \ = \"\";\n    if ( !baseToStr( base, str_base) ) \n    {\n        throw runtime_error(\"\
    Base conversion error.\");\n    }\n    if ( base < 10L ) \n    {\n        str_x\
    \ = x;\n    }\n    else \n    {\n        str_x = x / base;\n        str_base =\
    \ base % base;\n    }\n    \n    return str_x + str_base;\n}", "{\n\tif (x < 0\
    \ || base < 0 || base > 10) return \"\";\n\tstring ret = \"\";\n\twhile (x !=\
    \ 0) {\n\t\tlong mod = x % base;\n\t\tx = x / base;\n\t\tif (mod == 0) {\n\t\t\
    \tret += (char)('0' + mod);\n\t\t} else {\n\t\t\tret += (char)('0' + mod) + ret;\n\
    \t\t}\n\t}\n\treturn ret;\n}", "{\n    if (base > 10)\n        throw \"base can\
    \ not be greater than 10\";\n    stringstream os;\n    os.setbase(base);\n   \
    \ os.write((char*)&x, sizeof(x));\n    os.close();\n    return os.str();\n}",
  "{\n\tif (x < 0) {\n\t\tx = -x;\n\t\tbase = -base;\n\t}\n\t\n\tstring result = \"\
    \";\n\tlong temp = x;\n\tint i = 0;\n\t\n\twhile (temp > 0) {\n\t\tlong div =\
    \ temp % base;\n\t\tif (div > 0) {\n\t\t\tresult += char('0' + div);\n\t\t} else\
    \ {\n\t\t\tresult += char('0' + div - 10);\n\t\t}\n\t\ttemp = temp / base;\n\t\
    \ti++;\n\t}\n\t\n\tif (base > 10) {\n\t\tstring tempResult = \"\";\n\t\tfor (int\
    \ j = 0; j < i; j++) {\n\t\t\ttempResult += result;\n\t\t}\n\t\tresult = tempResult;\n\
    \t} else {\n\t\twhile (result.length() < i) {\n\t\t\tresult += '0';\n\t\t}\n\t\
    }\n\t\n\treturn result;\n}\n/*\n    Convert string representation to numerical\
    \ base 10.\n    >>> string_to_base(\"22\", 3L)\n    8\n    >>> string_to_base(\"\
    111\", 2L)\n    7\n    \n*/\nlong string_to_base(string x, long base) \n{\n\t\
    long num = 0;\n\tfor (int i = x.length() - 1; i >= 0; i--) {\n\t\tchar c = x.charAt(i);\n\
    \t\tswitch (c) {\n\t\t\tcase '0': num = num * base; break;\n\t\t\tcase '1': num\
    \ = num * base + 10; break;\n\t\t\tcase '2': num = num * base + 20; break;\n\t\
    \t\tcase '3': num = num * base + 30; break;\n\t\t\tcase '4': num = num * base\
    \ + 40; break;\n\t\t\tcase '5': num = num * base + 50; break;\n\t\t\tcase '6':\
    \ num = num * base + 60; break;\n\t\t\tcase '7': num = num * base + 70; break;\n\
    \t\t\tcase '8': num = num * base + 80; break;\n\t\t\tcase '9': num = num * base\
    \ + 90; break;\n\t\t\tcase '+': num = num + 10; break;\n\t\t\tcase '-': num =\
    \ num - 10; break;\n\t\t\tdefault: break;\n\t\t}\n\t}\n\treturn num;\n}\n/*\n\
    \    Convert number x to string representation after conversion\n    base numbers\
    \ are less than 10.\n    >>> number2string8(8L)\n    \"22\"\n    >>> number2string8(7L)\n\
    \    \"111\"\n    \n*/\nstring number2string8(long x) \n{\n\tstring result;\n\t\
    long temp = Math.abs(x);\n\twhile ((temp % 10) != 0) {\n\t\ttemp = temp / 10;\n\
    \t\tresult += \"0\";\n\t}\n\tresult += char('0' + temp % 10);\n\treturn result;\n\
    }\n/*\n    Convert number x to string representation after ", "{\n    string result\
    \ = \"0\";\n    if (x < base)\n    {\n        long n = (long)log(x);\n       \
    \ string temp;\n        for (int i = 0; i < n - 1; i++)\n        {\n         \
    \   temp += \"0\";\n        }\n        temp += to_string(base);\n        result\
    \ += temp;\n        string temp = to_string(x / base);\n        result += temp;\n\
    \        result += \"0\";\n        if (x > base)\n        {\n            result\
    \ += change_base(x % base, base);\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=c++,recursion |>\n<| a dscore=0 |>\n<code>\n//Function to calculate\
    \ decimal to binary using recursion\n#include<bits/stdc++.h>\nusing namespace\
    \ std;", "{\n\tswitch (base)\n\t{\n\t\tcase 0:\n\t\t\tif (x <= 0) return \"0\"\
    ;\n\t\t\telse return x;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (x <= 10) return\
    \ \"0\" + x;\n\t\t\telse return \"10\" + x;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\t\
    if (x <= 100) return \"0\" + x + \"0\";\n\t\t\telse return \"100\" + x + \"0\"\
    ;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (x <= 1000) return \"0\" + x + \"00\";\n\
    \t\t\telse return \"1000\" + x + \"00\";\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif\
    \ (x <= 10000) return \"0\" + x + \"000\";\n\t\t\telse return \"10000\" + x +\
    \ \"000\";\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif (x <= 100000) return \"0\" + x\
    \ + \"0000\";\n\t\t\telse return \"100000\" + x + \"0000\";\n\t\t\tbreak;\n\t\t\
    case 6:\n\t\t\tif (x <= 1000000) return \"0\" + x + \"00000\";\n\t\t\telse return\
    \ \"1000000\" + x + \"00000\";\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tif (x <= 10000000)\
    \ return \"0\" + x + \"000000\";\n\t\t\telse return \"10000000\" + x + \"000000\"\
    ;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (x <= 100000000) return \"0\" + x + \"\
    0000000\";\n\t\t\telse return \"100000000\" + x + \"0000000\";\n\t\t\tbreak;\n\
    \t\tcase 9:\n\t\t\tif (x <= 1000000000) return \"0\" + x + \"00000000\";\n\t\t\
    \telse return \"1000000000\" + x + \"00000000\";\n\t\t\tbreak;\n\t\tcase 10:\n\
    \t\t\tif (x <= 10000000000) return \"0\" + x + \"000000000\";\n\t\t\telse return\
    \ \"10000000000\" + x + \"000000000\";\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tif (x\
    \ <= 100000000000) return \"0\" + x + \"0000000000\";\n\t\t\telse return \"1000000000000\"\
    \ + x + \"0000000000\";\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tif (x <= 1000000000000)\
    \ return \"0\" + x + \"00000000000\";\n\t\t\telse return \"10000000000000\" +\
    \ x + \"00000000000\";\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tif (x <= 100000000000000)\
    \ return \"0\" + x + \"000000000000\";\n\t\t\telse return \"100000000000000\"\
    \ + x + \"000000000000\";\n\t\t\tbreak;\n\t\tcase 14:\n\t\t\tif (x <= 1000000000000000)\
    \ return \"0\" + x + \"0000000000000\";\n\t\t\telse return \"1000000000000000\"\
    \ + x + \"0000000000000\";\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tif (x <= 10000000000000000)\
    \ return \"0\" + x + \"00000000000000\";\n\t\t\telse return \"10000000000000000\"\
    \ + x + \"00000000000000\";\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tif (x <= 1000000000000000000)\
    \ return \"0\" + x + \"0000000000000000\";", "{\n    if(base > 10)\n    {\n  \
    \      return \"Invalid base\";\n    }\n    string str = \"\";\n    int rem;\n\
    \    while((rem = x % base) != 0)\n    {\n        str = char(rem + '0') + str;\n\
    \        x /= base;\n    }\n    return str;\n}\n</code>\n<|/ a tags=c#,c++ dscore=0\
    \ |>\n<| c |>\nCould you explain a bit about why this code works? And how it's\
    \ different from the accepted answer, specifically in terms of performance?\n\
    <|/ c |>\n<| c |>\nThis answer uses base-10 arithmetic.  The accepted answer uses\
    \ base-2 arithmetic.\n<|/ c |>\n<| a tags=c#,c++ |>\nA simple conversion function\
    \ in python that uses recursion to calculate its answer without using any library\
    \ or importing any library at all.\n<code>\ndef convert(num, base):\n  result\
    \ = \"\"\n  while num:\n    digit = num % base\n    result = digit*base+result\n\
    \    num //= base\n  return result\n</code>\n<|/ a dscore=0 |>\n<| a tags=c#,c++\
    \ |>\n<code>\nprivate static string ConvertToBase(long n, int base){\n       \
    \ int div = 0;\n        string result = string.Empty;\n        while(n!=0){\n\
    \            div = n%base;\n            if((div > 0 && div <= base)){\n      \
    \          div += base;\n            }\n            result = div > base ? div\
    \ + result : result+ div;\n            n /= base;\n        }\n        return result;\n\
    \    }\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI wrote this simple method\
    \ with recursion:\n<code>\npublic static string ConvertBase(int number, int base)\n\
    {\n    return ConvertBase(number, base, string.Empty);\n}", "{\n    \n    long\
    \ tens = x / base;\n    long num = (x%base);\n    \n    string s;\n    \n    bool\
    \ negative = num < 0;\n    \n    if (num < 0)\n    {\n        s =\"-\";\n    \
    \    num *= -1;\n    }\n    \n    long remain = num / base;\n    long num_base\
    \ = num % base;\n    \n    while (remain)\n    {\n        s = to_string(num_base)\
    \ + s;\n        remain = num / base;\n        num_base = num % base;\n    }\n\
    \    \n    s =\"1\" + to_string(num_base) + s;\n    \n    if (negative)\n    \
    \    s = \"-\" + s;\n    \n    return s;\n}", "{\n\tstring res;\n\t\n\twhile(x\
    \ <= base)\n\t{\n\t\tres = to_string(x%base);\n\t\tx = x/base;\n\t}\n\t\n\treturn\
    \ res;\n}", "{\n    long r = x;\n    string result;\n    while (r > 0) {\n   \
    \     int d = (int)r / base;\n        string strr = int2string(d, base);\n   \
    \     result = strr + result;\n        r = r - d * base;\n    }\n    while (r\
    \ < 0) {\n        int d = (int)r / base;\n        string strr = int2string(-d,\
    \ base);\n        result = strr + result;\n        r = r - d * base;\n    }\n\
    \    return result;\n}", "{\n    int ten = base.ten, zero = base.zero;\n    if(x\
    \ > base)\n    {\n        ten--;\n        x = x / base;\n    }\n    if(x < base)\n\
    \    {\n        zero--;\n        x = x * base;\n    }\n    if((ten == 1) || (zero\
    \ == 1))\n    {\n        return string(x);\n    }\n    string a = \"\";\n    while(ten)\n\
    \    {\n        ten--;\n        a = \"0\" + a;\n    }\n    while(zero)\n    {\n\
    \        zero--;\n        a = a + \"0\";\n    }\n    return a + x;\n}", "{\n \
    \ \n    long tmp;\n    tmp = x / (long) base;\n    return (x % base) + tostring(tmp);\n\
    }", "{\n    long mod = x % base;\n    if (mod != 0) {\n        string s = \"\"\
    ;\n        while (mod != 0) {\n            s += char('0'+(int)(mod%base));\n \
    \           mod = mod/base;\n        }\n        x /= base;\n        x += 1;\n\
    \        s += char('0'+(int)x);\n    }\n    return s;\n}", "{\n\tif (x < 0)\n\t\
    \treturn \"-\"+change_base(-x, base);\n\tstring result;\n\twhile (x != 0) {\n\t\
    \tlong digit = x / base;\n\t\tresult += (char)((digit % base) + 65);\n\t\tx =\
    \ x / base;\n\t}\n\treturn result;\n}", "{\n\tstring res = \"\";\n\twhile (base\
    \ != 0) {\n\t\tif (x < base) {\n\t\t\tbreak;\n\t\t}\n\t\tres = char(x + base)\
    \ + res;\n\t\tx = x / base;\n\t\tbase = base * 10;\n\t}\n\tres = char(x - base)\
    \ + res;\n\treturn res;\n}\nstring change_base(long x, int base)\n{\n\tstring\
    \ res;\n\twhile (base != 0) {\n\t\tif (x < base) {\n\t\t\tbreak;\n\t\t}\n\t\t\
    res = char(x + base) + res;\n\t\tx = x / base;\n\t\tbase = base * 10;\n\t}\n\t\
    res = char(x - base) + res;\n\treturn res;\n}", "{\n    return to_string(x / to_long(base)\
    \ * to_long(base));\n}\n/*\nReturn a string representation of number x formatted\
    \ as a number with base base between 1 and 16.\n    base numbers are less than\
    \ 10.\n    base can be 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10.\n    \n    >>> format_number(15L,\
    \ 3L)\n    \"15\"\n    >>> format_number(17L, 10L)\n    \"15\"\n    >>> format_number(100L,\
    \ 10L)\n    \"100\"\n    >>> format_number(42L, 15L)\n    \"420\"\n    \n    base\
    \ numbers are greater than 10.\n    \n    >>> format_number(42L, 4L)\n    \"420\"\
    \n    >>> format_number(42L, 5L)\n    \"42\"\n    >>> format_number(421L, 3L)\n\
    \    \"421\"\n    \n*/\nstring format_number(long x, long base) \n{\n    long\
    \ factor = 1;\n    while(base > 10)\n    {\n        factor *= base;\n        base--;\n\
    \    }\n    if(base == 1)\n    {\n        return x;\n    }\n    \n    string str\
    \ = to_string(x);\n    string result = \"\";\n    for(int i = 0; i < str.length();\
    \ i++)\n    {\n        result += (tolower(str[i]) + factor);\n    }\n    return\
    \ result;\n}\n/*\nReturn true if the number is positive and between 1 and 15.\n\
    \    \n    >>> is_positive_number(15L)\n    True\n    >>> is_positive_number(16L)\n\
    \    False\n    \n*/", "{\n    long temp = x;\n    int count = 0;\n    while (temp\
    \ != 0) {\n        temp = temp / base;\n        count++;\n    }\n    char buff[256];\n\
    \    if (count == 0)\n        return to_string(temp);\n    string result = \"\"\
    ;\n    while (temp != 0) {\n        temp = temp / base;\n        buff[count -\
    \ 1] = char(temp + '0');\n        result += buff;\n    }\n    return result;\n\
    }\nstring change_base(long x, long base, string buf) \n{\n    long temp = x;\n\
    \    int count = 0;\n    while (temp != 0) {\n        temp = temp / base;\n  \
    \      count++;\n    }\n    if (count == 0)\n        return to_string(temp);\n\
    \    string result = \"\";\n    while (temp != 0) {\n        temp = temp / base;\n\
    \        buff[count - 1] = char(temp + '0');\n        result += buff;\n    }\n\
    \    buff[0] = '0';\n    buff[count - 1] = '\\0';\n    result += buff;\n    return\
    \ result;\n}\n// Change base of x to base.\nstring change_base(long x, int base)\n\
    {\n    long temp = x;\n    int count = 0;\n    while (temp != 0) {\n        temp\
    \ = temp / base;\n        count++;\n    }\n    char buff[256];\n    if (count\
    \ == 0)\n        return to_string(temp);\n    string result = \"\";\n    while\
    \ (temp != 0) {\n        temp = temp / base;\n        buff[count - 1] = char(temp\
    \ + '0');\n        result += buff;\n    }\n    return result;\n}\nstring change_base(long\
    \ x, int base, string buf) \n{\n    long temp = x;\n    int count = 0;\n    while\
    \ (temp != 0) {\n        temp = temp / base;\n        count++;\n    }\n    if\
    \ (count == 0)\n        return to_string(temp);\n    string result = \"\";\n \
    \   while (temp != 0) {\n        temp = temp / base;\n        buff[count - 1]\
    \ = char(temp + '0');\n        result += buff;\n    }\n    buff[0] = '0';\n  \
    \  buff[count - 1] = '\\0';\n    result += buff;\n    return result;\n}\n// Change\
    \ base of x to base.\nstring change_base(long x, string base)\n{\n    long temp\
    \ = x;\n    int count = 0;\n    while (temp != 0) {\n        temp = temp / base;\n\
    \        count++;\n    }\n    char buff[256];\n    if (count == 0)\n        return\
    \ to_string(temp);\n    string result = \"\";\n    while (temp != 0) {\n     \
    \   temp = temp / base;\n        buff[count - 1] = char(temp + '0');\n       \
    \ result += buff;\n    }\n    return result;\n}\nstring change_base(long x, string\
    \ base, string ", "{\n  if (x < 10L)\n    return to_string(x);\n  string str =\
    \ to_string(x);\n  long a = str.length() - 1;\n  long b = base;\n  long digit\
    \ = 0;\n  while (a >= b) \n  {\n    digit = str[a] - '0';\n    str = str.substr(0,\
    \ a) + to_string(digit);\n    a = a - b;\n    b = b;\n  }\n  b = str.length()\
    \ - 1;\n  while (a > b) \n  {\n    digit = str[b] - '0';\n    str = str.substr(0,\
    \ b) + to_string(digit + 1);\n    b = b - b;\n  }\n  return str;\n}", "{\n\tstring\
    \ r = \"\";\n\tlong n = 0;\n\t\n\twhile (x != 0) {\n\t\tn = x / base;\n\t\tx =\
    \ x % base;\n\t\tr += to_string(n);\n\t}\n\t\n\treturn r;\n}\n\t\n\t\n\t\n/* \n\
    \tRepresent an integer as a string.\n\t\n\tinput int n\n\toutput string s\n\t\n\
    \tNote: if n < 0, it's treated as 0", "{\n    string ret = \"\";\n    long a =\
    \ x;\n    long i = 0;\n    \n    while (i<base)\n    {\n        long b = a/base;\n\
    \        ret += char((int)b);\n        a %= base;\n        i += 1;\n    }\n  \
    \  \n    ret += char((int)a);\n    return ret;\n}", "{\n\tstring sx = to_string(x);\n\
    \tint n = sx.length();\n\tint i = 0;\n\t\n\twhile( i < n ) {\n\t\tchar c = sx[i];\n\
    \t\tif( c >= '0' && c <= '9' ) \n\t\t{\n\t\t\tsx[i] = '0' + (int)(c - '0');\n\t\
    \t}\n\t\telse if( c >= 'A' && c <= 'Z' ) \n\t\t{\n\t\t\tsx[i] = 'A' + (int)(c\
    \ - 'A') + 10;\n\t\t}\n\t\telse if( c >= 'a' && c <= 'z' ) \n\t\t{\n\t\t\tsx[i]\
    \ = 'a' + (int)(c - 'a') + 10;\n\t\t}\n\t\telse if( c >= 'A' && c <= 'Z' ) \n\t\
    \t{\n\t\t\tsx[i] = 'A' + (int)(c - 'A') + 10;\n\t\t}\n\t\telse if( c >= 'a' &&\
    \ c <= 'z' ) \n\t\t{\n\t\t\tsx[i] = 'a' + (int)(c - 'a') + 10;\n\t\t}\n\t\telse\
    \ if( c == '+' ) {\n\t\t\tsx[i] = '-';\n\t\t}\n\t\telse if( c == '-' ) {\n\t\t\
    \tsx[i] = '+';\n\t\t}\n\t\telse if( c == '.' ) {\n\t\t\tsx[i] = '.';\n\t\t}\n\t\
    \telse if( c == 'e' || c == 'E' ) {\n\t\t\tsx[i] = 'e';\n\t\t}\n\t\telse if( c\
    \ == 'E' ) {\n\t\t\tsx[i] = 'E';\n\t\t}\n\t\telse if( c == 'i' || c == 'I' ) {\n\
    \t\t\tsx[i] = 'i';\n\t\t}\n\t\telse if( c == 'I' ) {\n\t\t\tsx[i] = 'I';\n\t\t\
    }\n\t\telse if( c == 'o' || c == 'O' ) {\n\t\t\tsx[i] = 'o';\n\t\t}\n\t\telse\
    \ if( c == 'O' ) {\n\t\t\tsx[i] = 'O';\n\t\t}\n\t\telse if( c == 'x' || c == 'X'\
    \ ) {\n\t\t\tsx[i] = 'x';\n\t\t}\n\t\telse if( c == 'X' ) {\n\t\t\tsx[i] = 'X';\n\
    \t\t}\n\t\telse if( c == 'f' || c == 'F' ) {\n\t\t\tsx[i] = 'f';\n\t\t}\n\t\t\
    else if( c == 'F' ) {\n\t\t\tsx[i] = 'F';\n\t\t}\n\t\telse if( c == 's' || c ==\
    \ 'S' ) {\n\t\t\tsx[i] = 's';\n\t\t}\n\t\telse if( c == 'S' ) {\n\t\t\tsx[i] =\
    \ 'S';\n\t\t}\n\t\telse if( c == 't' || c == 'T' ) {\n\t\t\tsx[i] = 't';\n\t\t\
    }\n\t\telse if( c == '", "{\n    if(x < base) return \"0\";\n    string s = \"\
    \";\n    while(x > 0) {\n        long mod = x % base;\n        s = to_string(mod)\
    \ + s;\n        x = x / base;\n    }\n    return s;\n}", "{\n    long num;\n \
    \   long x;\n    char n[10];\n    string result;\n    int len = 0;", "{\n    string\
    \ result;\n    int remainder = x;\n    long temp;\n    \n    if (base < 2 || base\
    \ > 10)\n        throw runtime_error(\"Base should be between 2 and 10\");\n \
    \   \n    temp = remainder;\n    \n    while (remainder != 0)\n    {\n       \
    \ int div = base - 1;\n        while (temp / div > 0)\n            div--;\n  \
    \      temp = temp / div;\n        result = to_string(remainder) + result;\n \
    \       remainder = temp % base;\n    }\n    if (remainder != 0)\n        result\
    \ = to_string(remainder) + result;\n    return result;\n}", "{\n    if(base <\
    \ 0 || base > 10) return \"Wrong base\";", "{\n    string s;\n    if(base == 0)\n\
    \    {\n        s = to_string(x - 1);\n    }\n    else\n    {\n        double\
    \ m = abs(base);\n        if( x < 10)\n        {\n            double temp;\n \
    \           temp = (double)x/base;\n            s = to_string(temp);\n       \
    \ }\n        else\n        {\n            double temp;\n            temp = (double)x/base;\n\
    \            int length = 1 + floor(log10(temp));\n            int counter = 1;\n\
    \            int digit = 0;\n            for(int i = 0; i < length; i++)\n   \
    \         {\n                digit = pow(base,counter);\n                counter++;\n\
    \                s += to_string(digit);\n            }\n        }\n    }\n   \
    \ return s;\n}", "{\n    \n    if (base < 2) return \"0\";\n    if (base > 33)\
    \ return \"-1\";\n    \n    int digits = 0;\n    long temp = 0;\n    \n    while\
    \ (x > 0) {\n        if (x % base != 0) {\n            digits += 1;\n        \
    \    temp += x;\n            x = temp % base;\n        }\n        else {\n   \
    \         digits += 1;\n            temp += x / base;\n            x = temp /\
    \ base;\n        }\n    }\n    \n    string r = \"\";\n    \n    while (digits\
    \ > 0) {\n        if (digits % 2 == 0) r += \"0\";\n        else r += \"1\";\n\
    \        digits /= 2;\n    }\n    \n    return r;\n}", "{\n\tstring result;\n\t\
    long temp;\n\ttemp = x; \n\twhile(temp != 0)\n\t{\n\t\tlong rem = (temp % base);\
    \ \n\t\tif(rem == 0) \n\t\t{\n\t\t\tresult += char(rem); \n\t\t}\n\t\ttemp = temp\
    \ / base;\n\t}\n\treturn result;\n}\n/*\n    Convert a number from base to base\
    \ to string.\n    base numbers are less than 10.\n    >>> convert_to_base(8L,\
    \ 3L)\n    \"22\"\n    >>> convert_to_base(8L, 2L)\n    \"1000\"\n    >>> convert_to_base(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring convert_to_base(long x, long base)\n{\n\t\
    string result;\n\tlong temp;\n\ttemp = x; \n\twhile(temp != 0)\n\t{\n\t\tlong\
    \ rem = (temp % base); \n\t\tif(rem == 0) \n\t\t{\n\t\t\tresult += char(rem);\
    \ \n\t\t}\n\t\ttemp = temp / base;\n\t}\n\treturn result;\n}", "{\n    string\
    \ s = to_str(x);\n    int a = s.length()-1;\n    if (base == 10) {\n        while\
    \ (a >= 0) {\n            s.insert(a, base);\n            a -= 1;\n        }\n\
    \    } else if (base % 10 != 0) {\n        string s1 = s.substr(0, a) + \"0\"\
    \ + base;\n        string s2 = s.substr(a+1);\n        s = s1;\n        while\
    \ (s2.length() >= 0) s = s.insert(a, s2.pop());\n    }\n    return s;\n}", "{\n\
    \    long baseNum;\n    String num;\n    if (base > 10) \n    {\n        throw\
    \ RangeError(L\"Base numbers are less than 10.\");\n    }\n    baseNum = x / base;\n\
    \    num = to_string(baseNum);\n    return num;\n}\n/*\nReturns true if the given\
    \ float is a whole number.\n*/", "{\n\tlong mod = ((int)x % base);\n\tstring s;\n\
    \tlong temp;\n\t\n\tif (mod == 0) {\n\t\treturn tostring(x);\n\t}\n\t\n\ts = tostring(x);\n\
    \ttemp = base;\n\twhile (mod>0) {\n\t\tmod = ((int)x % base);\n\t\ttemp = temp*10+mod;\n\
    \t\tx = x / base;\n\t\ts = tostring(temp) + s;\n\t}\n\treturn s;\n}", "{\n   \
    \ long result;\n    string num;\n    \n    if(x < base || base > base10){\n  \
    \      throw new RangeError();\n    }\n    \n    result = 0;\n    while(x > 0)\
    \ {\n        result = result * base + x % base;\n        x = x / base;\n    }\n\
    \    num = to_string(result);\n    \n    return num;\n}", "{\n    stringstream\
    \ ss;\n    do {\n        long d = num(x);\n        if(d<base) {\n            if(d\
    \ == 0) {\n                ss << '0';\n            }\n            else {\n   \
    \             string str = to_str(d);\n                while(!str.empty()) {\n\
    \                    ss << str[0];\n                    str.pop_front();\n   \
    \             }\n            }\n        }\n        else {\n            long d\
    \ = long(num);\n            string str = to_str(d);\n            while(!str.empty())\
    \ {\n                ss << str[0];\n                str.pop_front();\n       \
    \     }\n        }\n        x = num;\n        \n    }while(--x);\n    return ss.str();\n\
    }\n</code>\n<|/ a tags=integer,base-conversion,c++ dscore=2 |>\n<| a dscore=2\
    \ |>\nI wrote this algorithm and it is working properly for me:\n<code>\nstring\
    \ binary(int num)\n{\n    string binary = \"\";\n    for (int i = 0; i < 32; i++)\n\
    \    {\n        int remainder = num % 2;\n        num = num / 2;\n        binary\
    \ += (char)remainder;\n    }\n    return binary;\n}\n</code>\n<|/ a tags=integer,base-conversion,c++\
    \ |>\n<| a dscore=1 |>\nThis code works for me:\n<code>\nstring binary(int num)\n\
    {\n    string binary = \"\";\n    for (int i = 9; i > 0; i--)\n    {\n       \
    \ int rem = num % 2;\n        num = num / 2;\n        binary += (char)(rem+'0');\n\
    \    }\n    return binary;\n}\n</code>\n<|/ a tags=integer,base-conversion,c++\
    \ |>\n<| c |>\nThis doesn't work when `num` is a very big number. You could use\
    \ `long long` instead.\n<|/ c |>\n<| a dscore=1 |>\nA different implementation:\n\
    <code>\nstring binary(int num){\n    string binary = \"\";\n    string str = \"\
    \";\n    int remainder = 0;\n    while(num > 0){\n        remainder = num % 2;\n\
    \        num = num / 2;\n        binary += remainder;\n    }\n    while (remainder\
    \ == 0)\n    {\n        str = str + remainder;\n        remainder = num % 2;\n\
    \        num = num / 2;\n    }\n    return str;\n}\n</code>\n<|/ a tags=integer,base-conversion,c++\
    \ |>\n<| a tags=integer,base-conversion,c++ |>\n<code>\nstring binary(int num)\n\
    {\n    string binary = \"\";\n    for (int i = 9; i > 0; i--)\n    {\n       \
    \ int re", "{\n\tint b = 0;\n\tstring binary = \"\";", "{\n    long digits[],\
    \ pow;\n    \n    digits = new long[base + 1];\n    pow = 1;\n    \n    while(x\
    \ >= base) {\n        digits[--base] = x % base;\n        x = x / base;\n    }\n\
    \    digits[base] = x;\n    \n    \n    string rep = \"\";\n    \n    for(int\
    \ i = base - 1; i >= 0; i--) {\n        rep += std.typecons.toChar(digits[i]);\n\
    \    }\n    \n    return rep;\n}\n/*\nChange numerical base of input number x\
    \ to base.\n    return string representation after the conversion.\n    base numbers\
    \ are less than 10.\n    >>> change_base(8L, 3L)\n    \"22\"\n    >>> change_base(8L,\
    \ 2L)\n    \"1000\"\n    >>> change_base(7L, 2L)\n    \"111\"\n    \n*/\nstring\
    \ change_base(long x, short base) \n{\n    long digits[], pow;\n    \n    digits\
    \ = new long[base + 1];\n    pow = 1;\n    \n    while(x >= base) {\n        digits[--base]\
    \ = x % base;\n        x = x / base;\n    }\n    digits[base] = x;\n    \n   \
    \ \n    string rep = \"\";\n    \n    for(int i = base - 1; i >= 0; i--) {\n \
    \       rep += std.typecons.toChar(digits[i]);\n    }\n    \n    return rep;\n\
    }\n/*\nChange numerical base of input number x to base.\n    return string representation\
    \ after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8L,\
    \ 3L)\n    \"22\"\n    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring change_base(long x, int base) \n{\n    long\
    \ digits[], pow;\n    \n    digits = new long[base + 1];\n    pow = 1;\n    \n\
    \    while(x >= base) {\n        digits[--base] = x % base;\n        x = x / base;\n\
    \    }\n    digits[base] = x;\n    \n    \n    string rep = \"\";\n    \n    for(int\
    \ i = base - 1; i >= 0; i--) {\n        rep += std.typecons.toChar(digits[i]);\n\
    \    }\n    \n    return rep;\n}\n/*\nChange numerical base of input number x\
    \ to base.\n    return string representation after the conversion.\n    base numbers\
    \ are less than 10.\n    >>> change_base(8L, 3L)\n    \"22\"\n    >>> change_base(8L,\
    \ 2L)\n    \"", "{\n\tint res = 0;\n\tlong temp = 0;", "{\n    char result[1000];\n\
    \    long r = x / base;\n    r = r % base;\n    string s;\n    while (r != 0)\
    \ \n    {\n        r = r / base;\n        s += char('0' + int(r % base));\n  \
    \  }\n    sprintf(result, \"%ld\", x);\n    return string(result, '\\0');\n}",
  "{\n\tif(x==0)\n\t{\n\t\treturn \"0\";\n\t}\n\telse\n\t{\n\t\tstring res;\n\t\t\
    while (x != 0)\n\t\t{\n\t\t\tstring digit = to_string(x / base);\n\t\t\tres =\
    \ digit + res;\n\t\t\tx = x % base;\n\t\t}\n\t\treturn res;\n\t}\n}", "{\n\tif(x\
    \ == 0)\n\t\treturn \"0\";", "{\n    string result = \"\";\n    bool firstDigit\
    \ = true;\n    \n    for(long temp=x; temp>0; temp=temp/base)\n    {\n       \
    \ if(temp > base)\n        {\n            result += \"0\";\n        }\n      \
    \  else\n        {\n            result += (char)(temp%base);\n        }\n    \
    \    \n        if(firstDigit)\n        {\n            firstDigit = false;\n  \
    \      }\n        else\n        {\n            result += \".\";\n        }\n \
    \   }\n    \n    return result;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nA quick\
    \ python program that does this and more.\n<code>\n# Python program to convert\
    \ Base 10 number to Base 8\n# Asks for number to be converted and base to be converted\
    \ to\n# Returns converted number in base 8\n# Asks for the conversion from base\
    \ 10 to base 8\n# Program accepts positive numbers only", "{\n\tint temp = x;\n\
    \tstring res = \"\";\n\twhile(temp != 0)\n\t{\n\t\tlong d = temp % base;\n\t\t\
    if(d > 0)\n\t\t{\n\t\t\tres += (char)('0' + d);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\
    res += (char)('9' + d);\n\t\t}\n\t\ttemp /= base;\n\t}\n\treturn res;\n}", "{\n\
    \    string s = \"\";\n    long xx = x;\n    bool isNegative = xx<0L;\n    string\
    \ xstr = to_string(xx);\n    for(int i = 0; i < xstr.length(); i++) {\n      \
    \  if(base%10 == 0 && xstr[i] != '0') \n            base--;\n        else if(xstr[i]\
    \ != '0') {\n            base--;\n        }\n    }\n    if(base == 0) \n     \
    \   return \"0\";\n    \n    if(base > 9) \n        base = 9L;\n    else if(base\
    \ < 1) \n        base = 1;", "{\n    if(base < 2){\n        throw new Exception.Type(\"\
    base must be greater or equal than 2\");\n    }\n    \n    string s = Long.toString(x);\n\
    \    if(s.startsWith(\"0\") && s.endsWith(\"9\")){\n        throw new Exception.Type(\"\
    base must not start with 0 and be in range 2..10\");\n    }\n    if(base == 10){\n\
    \        throw new Exception.Type(\"base must not equal to 10\");\n    }\n   \
    \ \n    string sResult = \"\";\n    long i = base;\n    \n    while(i < 100){\n\
    \        long xi = Long.parseLong(s+\"0\"+ i);\n        sResult += xi;\n     \
    \   i += 1;\n    }\n    \n    return sResult;\n}\n/*\nParse a string representing\
    \ a floating point number to decimal.\nReturn 0 if string is not a floating point.\n\
    \    \n*/\nlong parseFloat(string s) \n{\n    long x;\n    if(s.length() > 5){\n\
    \        throw new Exception.Type(\"string too large\");\n    }\n    \n    bool\
    \ inf = false;\n    bool neg = false;\n    bool float = false;\n    long n = 0;\n\
    \    long negNum = 0;\n    \n    for(char c : s){\n        c = toChar(c);\n  \
    \      if(c == '-'){\n            neg = true;\n        }else if(c == '+'){\n \
    \           neg = false;\n        }else if(c == '.'){\n            float = true;\n\
    \        }else if(c == 'e' || c == 'E'){\n            float = false;\n       \
    \ }else if(c == 'i' || c == 'I'){\n            float = false;\n            inf\
    \ = true;\n        }else if(c == 'n' || c == 'N'){\n            float = false;\n\
    \            negNum = 1;\n        }\n        \n        if(!float){\n         \
    \   n = n * 10 + c- '0';\n        }\n    }\n    \n    if(neg){\n        if(n <\
    \ 0){\n            n = -n;\n            neg = true;\n        }\n    }\n    \n\
    \    if(negNum > 0){\n        n = -n;\n        neg = true;\n    }\n    \n    string\
    \ sResult = \"\";\n    \n    if(inf){\n        sResult = \"inf\";\n    }else{\n\
    \        if(float){\n            int iNum = abs((int)n);\n            int iBase\
    \ = abs((int)Math.pow(10, iNum-2));\n            \n            if(iNum < 2){\n\
    \                sResult += \"0\";\n            }else{\n                sResult\
    \ = Long.toString((double)n, iBase);\n            }\n            \n          \
    \  if(neg){\n                sResult += \"-\";\n            }\n        }else{\n\
    \            sResult = Long", "{\n    string result = \"\";\n    if (x < 10 *\
    \ base) {\n        // positive number\n        long temp = x / base;\n       \
    \ result = to_string(temp) + result;\n    } else {\n        // negative number\n\
    \        long temp = (x - 10 * base) / base;\n        result = to_string(temp)\
    \ + result;\n        temp = abs(temp);\n        result = to_string(temp) + result;\n\
    \    }\n    return result;\n}", "{\n\tstring ans = \"\";\n\t\n\tif(x < base ||\
    \ base < 1)\n\t\tthrow new InvalidArgument(\"change_base: Base should be greater\
    \ than 0 and less than 10\");\n\t\n\tstring n = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n\t\n\tunsigned long int temp = x;\n\tint digit = 0;\n\t\n\twhile(temp != 0)\
    \ {\n\t\tif(temp%base == 0)\n\t\t\tans = ans + n[digit];\n\t\t\n\t\ttemp = temp/base;\n\
    \t\tdigit++;\n\t}\n\t\n\treturn ans;\n}", "{\n    // convert base to string first\n\
    \    string s = base.to_string();\n    char[] nums = to_string(long_to_string(x)).to_chars();\n\
    \    // convert string\n    for (int i = 0; i < nums.length; ++i) \n    {\n  \
    \      char c = nums[i];\n        if (c >= '0' && c <= '9') \n        {\n    \
    \        nums[i] = c - '0';\n        } \n        else \n        {\n          \
    \  nums[i] = '0';\n        }\n    }\n    // convert\n    return std.string.format(s,\
    \ nums);\n}", "{\n\tstring result = \"\";\n\tint rem;\n\tfor (int i = base; i\
    \ < 10; i++) {\n\t\trem = (int) x % (int)i;\n\t\tresult += (char)('0' + rem);\n\
    \t\tx /= i;\n\t}\n\treturn result;\n}", "{\n    int base10;\n    int base1000;\n\
    \    int base1000000;\n    string result;\n    char carry = 1;\n    long quot;\n\
    \    long tmp;\n    \n    switch(base) {\n        case 10:\n            tmp =\
    \ (long)((double)x/10.0);\n            tmp += carry;\n            tmp*=base;\n\
    \            tmp = (long)tmp;\n            result = \"0\" + std.tostring(tmp);\n\
    \            carry = 1;\n            break;\n        case 100:\n            tmp\
    \ = (long)((double)x/100.0);\n            tmp += carry;\n            tmp*=base;\n\
    \            tmp = (long)tmp;\n            result = \"0\" + std.tostring(tmp);\n\
    \            carry = 1;\n            break;\n        case 1000:\n            tmp\
    \ = (long)((double)x/10000.0);\n            tmp += carry;\n            tmp*=base;\n\
    \            tmp = (long)tmp;\n            result = \"0\" + std.tostring(tmp);\n\
    \            carry = 1;\n            break;\n        case 1000000:\n         \
    \   tmp = (long)((double)x/1000000.0);\n            tmp += carry;\n          \
    \  tmp*=base;\n            tmp = (long)tmp;\n            result = \"0\" + std.tostring(tmp);\n\
    \            carry = 1;\n            break;\n        case 1000000000:\n      \
    \      tmp = (long)((double)x/1000000000.0);\n            tmp += carry;\n    \
    \        tmp*=base;\n            tmp = (long)tmp;\n            result = \"0\"\
    \ + std.tostring(tmp);\n            carry = 1;\n            break;\n        default:\n\
    \            abort();\n    }\n    \n    while(!(carry == 0)) {\n        if(base\
    \ == 100) {\n            tmp = (long)(tmp*10);\n            tmp += carry;\n  \
    \          tmp*=base;\n            tmp = (long)tmp;\n            result = \"0\"\
    \ + std.tostring(tmp);\n            carry = 1;\n        } else {\n           \
    \ tmp = (long)(tmp*base);\n            tmp += carry;\n            tmp*=base;\n\
    \            tmp = (long)tmp;\n            result = \"0\" + std.tostring(tmp);\n\
    \            carry = 1;\n        }\n    }\n    \n    if(!(carry == 0)) {\n   \
    \     while(!(carry == 0)) {\n            tmp = (long)(tmp*base);\n          \
    \  tmp += carry;\n            tmp*=base;\n            tmp = (long)tmp;\n     \
    \       result = \"0\" + std.tostring(tmp);\n            carry = 1;\n        }\n\
    \    }\n    \n    if(carr", "{\n    string str = \"\";\n    long ten = 10, unit\
    \ = 1;\n    while (unit <= base) {\n        ten *= 10;\n        unit++;\n    }\n\
    \    int unit = base;\n    while (unit > 0) {\n        long tmp = x / unit;\n\
    \        str += string(unit, '0');\n        x -= tmp * unit;\n        unit /=\
    \ 10;\n    }\n    return str;\n}", "{\n    int i;\n    string str=\"\";\n    if\
    \ (x<0 || base<0 || base>10)\n        throw \"Invalid Argument\";", "{\n\tstring\
    \ s = tostring(x / base);\n\tstring result = s;\n\twhile (s.Length > 1) \n\t{\n\
    \t\tstring div = s.substr(0, 1);\n\t\tlong div2 = div * base;\n\t\tint div2int\
    \ = div2.ToInt();\n\t\tif (div2int > base) \n\t\t{\n\t\t\tresult = div2.ToString()\
    \ + result;\n\t\t\ts = div2.ToString() + s.substr(1);\n\t\t}\n\t\telse \n\t\t\
    {\n\t\t\tresult = div2.ToString() + result;\n\t\t}\n\t}\n\tstring div = s.substr(0,\
    \ 1);\n\tlong div2 = div * base;\n\tint div2int = div2.ToInt();\n\tlong div2long\
    \ = div2.ToLong();\n\tstring s = div2.ToString() + s.substr(1);\n\tif (div2int\
    \ != base)\n\t{\n\t\tstring mod = div2.ToString() + s.substr(1);\n\t\tresult =\
    \ mod;\n\t}\n\treturn result;\n}", "{\n    if(x < 0)\n    {\n        throw invalid_argument(\"\
    change_base: negative number not allowed!\");\n    }\n    string result = \"\"\
    ;\n    for(int i = base; i >= 0; i--)\n    {\n        result += (x - base * i)\
    \ / i;\n    }\n    return result;\n}\n/*\n    Convert a number from base 10 to\
    \ base e.\n    >>> base_convert(8L, 3L)\n    \"22\"\n    >>> base_convert(8L,\
    \ 2L)\n    \"1000\"\n    >>> base_convert(7L, 2L)\n    \"111\"\n    \n    Negative\
    \ numbers are not allowed!\n    \n*/\nstring base_convert(long x, long e) \n{\n\
    \    string result = \"\";\n    for(int i = e; i >= 0; i--)\n    {\n        result\
    \ += (x / i) % e;\n    }\n    return result;\n}\n/*\n    Compute sum of all digits\
    \ of the number from left side.\n    >>> sum(8L)\n    8\n    >>> sum(2L)\n   \
    \ 6\n    \n    Negative numbers are not allowed!\n    \n*/", "{\n\tif(base>10)\n\
    \t\treturn \"0\";\n\tstring result = \"\";\n\tint len = 0;\n\twhile(base>0)\n\t\
    {\n\t\tlen++;\n\t\tbase = x/base;\n\t}\n\tfor(int i=len-1; i>=0; i--)\n\t{\n\t\
    \tchar c = char(x);\n\t\tstring t = to_string(x);\n\t\tif(t[0] == '0')\n\t\t\t\
    t[0]='1';\n\t\telse if(t[0]<='9')\n\t\t\tt[0]++;\n\t\telse\n\t\t\tt[0]--;\n\t\t\
    string s = to_string(t);\n\t\tresult += s;\n\t\tx -= int(t[0])*base;\n\t}\n\t\
    return result;\n}", "{\n\tstring out=\"invalid\";\n\tlong s=0;\n\t\n\twhile(x!=0)\
    \ {\n\t\tif(s==base)\n\t\t\tout+=digit(x);\n\t\ts=s*base;\n\t\tx= x%base;\n\t\
    }\n\t\n\twhile(s!=0) {\n\t\tout+=digit(s);\n\t\ts= s%base;\n\t}\n\t\n\treturn(out);\n\
    }", "{\n    string result;\n    \n    for (int i = (int)x; i > 0; i /= base)\n\
    \        result = numberToString(i, base) + result;\n        \n    return result;\n\
    }", "{\n    string result = \"\";\n    long num = x;\n    while (num > 0)\n  \
    \  {\n        result = to_string(num % base) + result;\n        num /= base;\n\
    \    }\n    return result;\n}", "{\n    if (base < 2 || base > 10)\n        throw\
    \ \"change_base: base number must be in range 2-10\";\n    int base_digits[] =\
    \ toDigitArray(base);\n    int x_digits[] = toDigitArray(x);\n    int new_digits[]\
    \ = new int[x_digits.length + 1];\n    \n    for (int i = 0; i < x_digits.length;\
    \ i++) {\n        new_digits[i + 1] = x_digits[i] * base_digits[i];\n    }\n \
    \   \n    return toBaseString(new_digits, new_digits.length);\n}\n</code>\n<|/\
    \ a tags=base-conversion,java |>\n<| c |>\ncan you give some more insight into\
    \ what this code does? what do you mean by base conversion? what is the base 10\
    \ in \"new_digits[i+1]\"? i don't know what the function toBaseString does.\n\
    <|/ c |>\n<| c |>\nThis is just a general code. toBaseString is just converting\
    \ the array of numbers into string by using \"base 10\".\n<|/ c |>\n<| c |>\n\
    this algorithm doesn't work for negative numbers, right?\n<|/ c |>\n<| c |>\n\
    It does not. But if you want a solution that does, the only thing you need to\
    \ do is subtract 10 from x before the multiplication\n<|/ c |>\n<| c |>\ncan you\
    \ give some more insight into what this code does? what do you mean by base conversion?\
    \ what is the base 10 in \"new_digits[i+1]\"? i don't know what the function toBaseString\
    \ does.\n<|/ c |>\n<| a dscore=5 |>\nFor anyone reading this later, I have created\
    \ a Java 8 stream based approach to this problem. Using Java 8 streams, we can\
    \ create a very concise solution that doesn't require us to manually construct\
    \ a nested for loop. \nHere is an example:\n<code>\nimport java.util.stream.IntStream;",
  "{\n    long tmp = x;\n    tmp *= base;\n    tmp /= base;\n    if (tmp > 9) tmp\
    \ = tmp % 9;\n    return to_string(tmp);\n}", "{\n\treturn string((char*)&x -\
    \ (char*)&x + sizeof(long int)*(base-1));\n}\nstring change_base(double x, double\
    \ base) \n{\n\treturn string((char*)&x - (char*)&x + sizeof(double)*(base-1));\n\
    }\nstring change_base(int x, int base) \n{\n\treturn string((char*)&x - (char*)&x\
    \ + sizeof(int)*base);\n}\n/*\n    Based on http://stackoverflow.com/questions/7336518/convert-decimal-number-to-binary\n\
    */\nstring to_binary(int n) \n{\n\tstring ret = \"\";\n\twhile(n>0)\n\t{\n\t\t\
    if(n&1)\n\t\t\tret += \"1\";\n\t\telse\n\t\t\tret += \"0\";\n\t\tn/=2;\n\t}\n\t\
    return ret;\n}\n/*\n    Based on http://stackoverflow.com/questions/7336518/convert-decimal-number-to-binary\n\
    */\nstring to_binary(long n) \n{\n\tstring ret = \"\";\n\twhile(n>0)\n\t{\n\t\t\
    if(n&1)\n\t\t\tret += \"1\";\n\t\telse\n\t\t\tret += \"0\";\n\t\tn/=2;\n\t}\n\t\
    return ret;\n}\nstring to_binary(double n) \n{\n\tstring ret = \"\";\n\twhile(n>0)\n\
    \t{\n\t\tif(n&1)\n\t\t\tret += \"1\";\n\t\telse\n\t\t\tret += \"0\";\n\t\tn/=2;\n\
    \t}\n\treturn ret;\n}\nstring to_binary(string n) \n{\n\tstring ret = \"\";\n\t\
    while(n>0)\n\t{\n\t\tif(n&1)\n\t\t\tret += \"1\";\n\t\telse\n\t\t\tret += \"0\"\
    ;\n\t\tn/=2;\n\t}\n\treturn ret;\n}", "{\n\tstring result = \"\";\n\t\n\tlong\
    \ tmp = x;\n\tstring tmp2 = \"\";\n\t\n\tif (base < 2) return \"Invalid base\"\
    ;\n\t\n\twhile (tmp > 0)\n\t{\n\t\tif (tmp2 != \"\")\n\t\t{\n\t\t\tint ibase =\
    \ std.intdiv(tmp, base);\n\t\t\tresult = result + tmp2.substring(ibase*base, ibase*base+base);\n\
    \t\t}\n\t\t\n\t\ttmp = std.intdiv(tmp, base);\n\t\ttmp2 = std.intdiv(tmp2, base);\n\
    \t}\n\t\n\treturn result;\n}", "{\n\tchar digits[100];\n\t\n\tdigits[(int) base]\
    \ = ' ';\n\tdigits[(int) base+1] = (char) x;\n\t\n\tstring result = \"\";\n\t\
    for (int i=0; i<=base; i++){\n\t\tresult += digits[i];\n\t}\n\t\n\treturn result;\n\
    }", "{\n    if(x < 0)\n        throw new RangeError(\"The value x cannot be less\
    \ than 0.\");\n    \n    string res = \"\";\n    \n    if(base == 10)\n    {\n\
    \        string tmp;\n        int len = x;\n        int pos = 0;\n        \n \
    \       while(len > 0)\n        {\n            tmp = to_string(len % base);\n\
    \            len = len / base;\n            pos += 1;\n            res = concat(string(\"\
    0\", 2 - pos.to_ulong()), \"-\", res, tmp);\n        }\n    }\n    else if(base\
    \ == 2)\n    {\n        int len = x;\n        int pos = 0;\n        \n       \
    \ while(len > 0)\n        {\n            tmp = (len % 10).to_ulong().to_string();\n\
    \            len = len / 10;\n            pos += 1;\n            res = concat(string(\"\
    0\", 2 - pos.to_ulong()), \"-\", res, tmp);\n        }\n    }\n    else\n    {\n\
    \        long temp = x;\n        int len = temp;\n        int pos = 0;\n     \
    \   \n        while(len > 0)\n        {\n            tmp = to_string(len % base);\n\
    \            len = len / base;\n            pos += 1;\n            res = concat(string(\"\
    0\", 2 - pos.to_ulong()), \"-\", res, tmp);\n        }\n    }\n    \n    return\
    \ res;\n}", "{\n  if (base < 2 || base > 10) \n    return \"error\";", "{\n\t\
    char buf[1000];\n\tuint baseStr = (int)(base)-1;\n\tuint mod = 0;\n\tuint i =\
    \ (uint)x;\n\tuint strPos = 0;\n\tstring result = \"\";", "{\n\tstring res = \"\
    \"; //return value", "{\n    if (base == 0L)\n        return \"0\";\n    if (base\
    \ == 1L)\n        return \"1\";\n    long r = x;\n    r /= base;\n    int b =\
    \ base - 1L;\n    string sx = to_string(r);\n    string s = \"\";\n    int i =\
    \ sx.length() - 1;\n    while (i >= 0) {\n        if (sx[i] == '0') {\n      \
    \      s = s + sx[i + 1];\n            i--;\n        } else {\n            while\
    \ (i >= 0L && sx[i] == '0') {\n                s -= sx[i];\n                i--;\n\
    \            }\n            if (i < 0L)\n                break;\n            if\
    \ (sx[i] < '0' || '9' < sx[i]) {\n                s -= sx[i];\n              \
    \  break;\n            }\n            long nr = std.strtoul(sx.substr(i + 1, sx.length()\
    \ - i - 1), 0L, base);\n            r = nr;\n            int bd = base;\n    \
    \        while (i >= 0) {\n                r = std.remainder(r, bd);\n       \
    \         bd--;\n                s -= sx[i];\n                i--;\n         \
    \   }\n            s = to_string(r);\n            break;\n        }\n    }\n \
    \   if (b < base)\n        s = \"1\" + s;\n    return s;\n}", "{\n\tstring ret\
    \ = \"\", tmp = to_string(x);\n\tint len = tmp.length();\n\tint i = 0, j = 0;\n\
    \twhile(i < len && j >= base)\n\t{\n\t\tif(tmp[i] >= base)\n\t\t{\n\t\t\tret +=\
    \ tmp[i] - base;\n\t\t\ti += len - 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret += tmp[i];\n\
    \t\t\ti++;\n\t\t}\n\t\tj++;\n\t}\n\twhile(i < len)\n\t{\n\t\tret += tmp[i];\n\t\
    \ti++;\n\t}\n\twhile(j >= base)\n\t{\n\t\tret += tmp[j] + base;\n\t\tj--;\n\t\
    }\n\treturn ret;\n}", "{\n    string str = to_string(base);\n    string s = to_string(abs(x));\n\
    \    \n    while (s.find(str) == string::npos) {\n        string tmp = to_string(int(s\
    \ / base));\n        s = s.replace(tmp, \"\");\n        x = int(x / base);\n \
    \   }\n    \n    while (x < 0) {\n        x *= base;\n        if (x < 0) x = -int(-x);\n\
    \    }\n    return to_string(abs(x));\n}", "{\n    string result;\n    if (x <\
    \ 0)\n    {\n        result = to_string(abs(x));\n    }\n    else if (x == 0)\n\
    \    {\n        result = \"0\";\n    }\n    else if (base > 10)\n    {\n     \
    \   long m = div(abs(x), base);\n        long t = pow(base, m);\n        result\
    \ = to_string(t);\n    }\n    else if (base < 10)\n    {\n        result = \"\
    0\";\n    }\n    else\n    {\n        result = \"1\" + to_string(base);\n    }\n\
    \    return result;\n}", "{\n    string res;\n    long power = 1;\n    long result\
    \ = 0;\n    while (power < base)\n    {\n        power <<= 1;\n        result\
    \ += x;\n    }\n    if (result < base)\n    {\n        power = 1;\n    }\n   \
    \ else\n    {\n        power *= base;\n    }\n    while ((result % power) > 0)\n\
    \    {\n        result /= power;\n    }\n    if (result == 1)\n    {\n       \
    \ res = to_str(x);\n    }\n    else\n    {\n        res = to_str(result) + to_str(power);\n\
    \    }\n    return res;\n}\n</code>\n<|/ a tags=math,c++ dscore=3 |>\n<| a tags=math,c++\
    \ dscore=3 |>\n<code>\n#include <iostream>\n#include <string>", "{\n    string\
    \ str = \"\";\n    char nstr[10];\n    double xdouble;\n    \n    \n    /* convert\
    \ from base to dec */\n    xdouble = (double)x;\n    for(int i = 0; i <= 9; i++)\n\
    \    {\n        if((int)xdouble == xdouble)\n            nstr[i] = '0';\n    \
    \    else \n            nstr[i] = (char)(((int)(xdouble % base) + 10));\n    \
    \    xdouble /= base;\n    }\n    /* convert from dec to base */\n    for(int\
    \ i = 0; i <= 9; i++)\n    {\n        nstr[i] = (char)(nstr[i] + 10);\n    }\n\
    \    \n    /* rebuild the string */\n    for(int i = 0; i <= 9; i++)\n    {\n\
    \        str = (char)str + nstr[i];\n    }\n    return str;\n}\n</code>\n<|/ a\
    \ tags=c++,math,algorithm,base-conversion |>\n<| a |>\nI agree with the answer\
    \ from Hans Passant that there is a very simple and straight forward way to do\
    \ this.\n<code>", "{\n    if(x == 0 || base == 0) return to_string(0);\n    long\
    \ temp = x / base;\n    return to_string(temp*base);\n}", "{\n\tstring str = to_string(x);\n\
    \tstring sb = to_string(base);\n\tif (base < 10)\n\t\tswap(str, sb);\n\tif (base\
    \ > 0)\n\t{\n\t\tint len = (int)str.length();\n\t\tfor (int i = len - 1; i >=\
    \ 0; --i)\n\t\t{\n\t\t\tif (sb.length() < len)\n\t\t\t{\n\t\t\t\tsb.append(\"\
    0\");\n\t\t\t}\n\t\t\tchar c = str.at(i);\n\t\t\tif (c >= '0' && c <= '9')\n\t\
    \t\t{\n\t\t\t\tsb.at(i) = sb.at(i - 1);\n\t\t\t\tsb.at(i - 1) = c;\n\t\t\t}\n\t\
    \t\telse\n\t\t\t{\n\t\t\t\tsb.at(i) = c;\n\t\t\t}\n\t\t}\n\t}\n\treturn sb;\n}",
  "{\n\tint quotient, quotient2, remainder, base2, result = 0;\n\tstring res = \"\
    0\";\n\tstring str = \"\";\n\twhile (x > 0) \n\t{\n\t\tquotient = x / base;\n\t\
    \tremainder = x % base;\n\t\tbase2 = base / 10;\n\t\tquotient2 = quotient / base2;\n\
    \t\tres += to_string(quotient2) + \"1\";\n\t\tx = remainder;\n\t\tresult += (base\
    \ * quotient2) * quotient;\n\t}\n\treturn res;\n}", "{\n    string result = \"\
    \";\n    while (x != 0) {\n        if (x % base == 0) {\n            result +=\
    \ to_string(x % base);\n        } else {\n            result += to_string((x %\
    \ base) + base);\n        }\n        x /= base;\n    }\n    result += \"0\";\n\
    \    return result;\n}", "{\n    string rr = \"\";\n    while (x>0)\n    {\n \
    \       long mod = x;\n        rr = to_string(mod%base) + rr;\n        x = floor(x/base);\n\
    \    }\n    rr = to_string(x) + rr;\n    return rr;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\nIn C/C++ you can use sprintf function. Here a sample code :\n<code>\n\
    #include <stdio.h>\n#include <stdlib.h>\n#include <math.h>", "{\n\tint remainder,\
    \ exponent;\n\tstring out;\n\t\n\tremainder = x % base;\n\texponent = (int) log(remainder,\
    \ base);\n\t\n\tout = \"\";\n\t\n\twhile(exponent > 0) {\n\t\tout += (char) ('0'\
    \ + exponent % 10);\n\t\texponent = exponent / 10;\n\t}\n\t\n\tout += (char) ('0'\
    \ + remainder % base);\n\t\n\treturn out;\n}\n*/\n\t\n/* ======================================================================\n\
    \ * Function is_integer\n * \n * Return TRUE if the number is a whole integer\
    \ and FALSE if not.\n * \n */", "{\n    int n = int(x);\n    int b = int(base);\n\
    \    while (n > base) {\n        n/=base;\n        b/=base;\n    }\n    if (n\
    \ == base) {\n        if (b == 1) {\n            return tostring(x);\n       \
    \ }\n        if (b == 2) {\n            if (n == 1) {\n                return\
    \ \"1\";\n            }\n            if (n == 2) {\n                return \"\
    11\";\n            }\n        }\n        string res = tostring(long(n / b) % b);\n\
    \        return res + change_base((n / b), b);\n    } else if (n < base) {\n \
    \       string res = tostring(long(b - b * long(log10(base))) % b);\n        return\
    \ res + change_base((n / base), b);\n    }\n    return \"0\";\n}", "{\n    //\
    \ Check for base in set {2, 10, 36}.\n    string baseStr = toString(base);\n \
    \   switch(baseStr){\n        case \".2\": baseStr = baseStr + \".0\"; break;\n\
    \        case \".10\": baseStr = baseStr + \".0\"; break;\n        case \".36\"\
    : baseStr = baseStr + \".0\"; break;\n        default: baseStr = baseStr + \"\
    .0\"; break;\n    }\n    // Prefix with zero if base is not a number\n    if(baseStr.endsWith(\"\
    .\") && baseStr.length()>2){\n        baseStr += \"0\";\n    }\n    // Return\
    \ string representation of the number x \n    return to_string(x) + baseStr;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nYour `baseStr` will always have either `.2`, `10`\
    \ or `36` appended to it, not just one of those. Also, if `baseStr` is `\"10\"\
    `, you `return to_string(x)...` will return a string representing `x` as an integer.\n\
    <|/ c |>\n<| a tags=c++,converter,base,algorithm |>\nMy suggestion: don't even\
    \ bother with strings and base conversion if you don't have to. Just do the conversion\
    \ in base 10.\nHere's a simple way to implement the conversion in base 10:\n<code>\n\
    long long_to_base(long num, int base)\n{\n    long output = 0;\n    while (num\
    \ > 0) {\n        output = num % base;\n        num = num / base;\n    }\n   \
    \ return output;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nI have recently written\
    \ a python implementation, using the following methods:", "{\n    int rem;\n \
    \   string s;\n    rem = x % base;\n    x = x / base;\n    s = char(x);\n    x\
    \ = char(x);\n    while (rem > 0)\n    {\n        if (rem % base == 0)\n     \
    \   {\n            s += char(rem);\n        }\n        x = char(x);\n        rem\
    \ = rem / base;\n    }\n    return s;\n}\n// Change string base from base to base\
    \ string.\nstring change_base(string x, long base)\n{\n    int rem;\n    string\
    \ s;\n    rem = std.string.length(x) % base;\n    s = std.string.substr(x, 0,\
    \ rem);\n    x = std.string.substr(x, rem);\n    while (rem > 0)\n    {\n    \
    \    if (rem % base == 0)\n        {\n            s += std.string.substr(rem,\
    \ 1);\n        }\n        x = std.string.substr(x, 1);\n        rem = rem / base;\n\
    \    }\n    return s;\n}", "{\n\tstring s;\n\tstring res = \"\";\n\tlong xl =\
    \ x;\n\t\n\tif (base < 10) {\n\t\ts= \"0\";\n\t\tfor (int i = 0; i < base; i++)\
    \ {\n\t\t\ts += \"0\";\n\t\t}\n\t}\n\telse if (base > 10)\n\t{\n\t\ts = \"1\"\
    ;\n\t\tfor (int i = 0; i < base; i++) {\n\t\t\ts += \"1\";\n\t\t}\n\t}", "{\n\
    \    switch(base){\n        case 0:\n            string str = x.to_string();\n\
    \            string res = str[0];\n            for(int i = 1; i < str.size();\
    \ i++){\n                res += (str[i] - '0') * pow(base, str.size() - i - 1);\n\
    \            }\n            return res;\n        case 1:\n        case 2:\n  \
    \      case 3:\n        case 4:\n        case 5:\n        case 6:\n        case\
    \ 7:\n        case 8:\n        case 9:\n        case 10:\n            return x.to_string(base);\n\
    \        default:\n            return \"error\";\n    }\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\nI didn't test it but I think this is what you are looking\
    \ for\n<code>\ndef base(number, base)\n    digits = (number.to_s.reverse.gsub(/(\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'*base).reverse.gsub(/(\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'*base).reverse.gsub(/(\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'*base).reverse.gsub(/(\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'*base).reverse.gsub(/(\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'*base).reverse.gsub(/(\\\
    d)(?=(\\d\\d\\d)+(?!\\d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\d)+(?!\\\
    d))/,'\\1'*base).reverse.gsub(/(\\d)(?=(\\d\\d\\", "{\n  string result = \"\"\
    ;\n  \n  //Handle base case\n  if (base < 10 || base == 0)\n  {\n    string base_str\
    \ = int_to_str(base);\n    result += (base_str[0] + int_to_str(x - pow(base, base_str.length()-1)));\n\
    \    return result;\n  }\n  \n  long r = long(x);\n  \n  //Handle negative numbers\n\
    \  if (r < 0)\n  {\n    r = -r;\n    result += \"-\";\n  }\n  \n  //Handle positive\
    \ numbers\n  string pos_str = int_to_str(r);\n  \n  //Check how many digits in\
    \ base\n  int digits = pos_str.length();\n  \n  //Add left over digits to result\n\
    \  for(int i = 1; i <= digits; i++)\n  {\n    result += (pos_str[digits-i-1] -\
    \ '0') + base_str.chars[digits-i-1];\n  }\n  \n  //Handle negative base cases\n\
    \  string neg_str = int_to_str(-base);\n  \n  //Check how many digits in negative\
    \ base\n  digits = neg_str.length();\n  \n  //Add left over digits to result\n\
    \  for(int i = 1; i <= digits; i++)\n  {\n    result += (neg_str[digits-i-1] -\
    \ '0') + base_str.chars[digits-i-1];\n  }\n  \n  //Handle sign cases\n  if (x\
    \ < 0)\n  {\n    result += \"-\";\n  }\n  \n  return result;\n}", "{\n\t\n\tstring\
    \ basestring=\"\";\n\tbool useBase10=false;\n\t\n\tif (x>0){\n\t\tuseBase10=true;\n\
    \t\twhile (x>0){\n\t\t\tx=x/base;\n\t\t\tbasestring+=(base==1?'0':'1');\n\t\t\
    }\n\t} else {\n\t\tuseBase10=false;\n\t\twhile (x<0){\n\t\t\tx=x*base;\n\t\t\t\
    basestring+=(base==1?'0':'1');\n\t\t}\n\t}\n\tif (base==2){\n\t\tbasestring=toupper(basestring);\n\
    \t}\n\t\n\treturn useBase10?basestring:basestring.substr(1);\n}\n/*\n    Converts\
    \ number x to string representation using the default base of base.\n    base\
    \ numbers are less than 10.\n    >>> to_string(8L)\n    \"22\"\n    >>> to_string(8L,\
    \ 3L)\n    \"22\"\n    >>> to_string(8L, 2L)\n    \"1000\"\n    >>> to_string(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring to_string(long x) \n{\n\tstring basestring=\"\
    \";\n\tbool useBase10=false;\n\t\n\tif (x>0){\n\t\tuseBase10=true;\n\t\twhile\
    \ (x>0){\n\t\t\tx=x/10;\n\t\t\tbasestring+=(base==1?'0':toupper(base));\n\t\t\
    }\n\t} else {\n\t\tuseBase10=false;\n\t\twhile (x<0){\n\t\t\tx=x*10;\n\t\t\tbasestring+=(base==1?'0':toupper(base));\n\
    \t\t}\n\t}\n\tif (base==2){\n\t\tbasestring=toupper(basestring);\n\t}\n\t\n\t\
    return useBase10?basestring:basestring.substr(1);\n}\n/*\n    Converts number\
    \ x to string representation using the given base.\n    base numbers are less\
    \ than 10.\n    >>> to_string(8L, 3L)\n    \"22\"\n    >>> to_string(8L, 2L)\n\
    \    \"1000\"\n    >>> to_string(7L, 2L)\n    \"111\"\n    \n*/\nstring to_string(long\
    \ x, long base) \n{\n\t\n\tstring basestring=\"\";\n\tbool useBase10=false;\n\t\
    \n\tif (x>0){\n\t\tuseBase10=true;\n\t\twhile (x>0){\n\t\t\tx=x/base;\n\t\t\t\
    basestring+=(base==1?'0':toupper(base));\n\t\t}\n\t} else {\n\t\tuseBase10=false;\n\
    \t\twhile (x<0){\n", "{\n    string result = \"\";\n    if (x < base)\n    {\n\
    \        if (x < 10)\n            result += x.ToString();\n        else\n    \
    \        result += (x / base).ToString();\n        if (x > base)\n        {\n\
    \            long temp = x - (x / base);\n            result += change_base(temp,\
    \ base);\n        }\n    }\n    else if (x >= base)\n    {\n        long temp\
    \ = x - (x / base);\n        result += change_base(temp, base);\n        string\
    \ res = Convert.ToString(temp);\n        result = res[0] + result;\n        long\
    \ temp = x - temp;\n        result += change_base(temp, base);\n    }\n    return\
    \ result;\n}\n</code>\nI believe it is very close to the accepted answer. It works\
    \ for my needs and I believe it can be helpful to others.\n<|/ a dscore=1 tags=python,c#\
    \ |>\n<| a tags=python,c# dscore=1 |>\nI have solved this problem using this code:\n\
    <code>\n public static string convertToBase(string value, int base) {", "{\n \
    \   string result; \n    \n    if (x == 0) return \"0\"; \n    if (x < 0)\n  \
    \      result = change_base(-x, base); \n    else\n    {\n        char digit;\
    \ \n        long rem = x % base; \n        \n        while (rem > 0) \n      \
    \  { \n            digit = rem % 10 + '0'; \n            rem /= 10; \n       \
    \     result = (result + digit); \n        } \n    } \n    result = result + '0';\n\
    \    while (result[0] == '0') result.erase(0, 1); \n    while (result[result.length()\
    \ - 1] == '0') result.pop_back(); \n    while (base < 10)\n    {\n        if (base\
    \ == 1)\n        {\n            result = '1' + result;\n            break;\n \
    \       }\n        else\n        {\n            string num = \"0123456789ABCDEF\"\
    ; \n            string exp = num[(int)base];\n            if (exp.length() > result.length())\
    \ \n                result += '0';\n            result += exp; \n            break;\n\
    \        }\n    }\n    return result;\n}", "{\n    string s = \"\";\n    int rem;\n\
    \    while (x) {\n        rem = x % base;\n        if (rem)\n            s +=\
    \ (char)(rem + 48);\n        x /= base;\n    }\n    return s;\n}", "{\n    string\
    \ bases = \"\";\n    \n    while (base != 0)\n    {\n        if (base % 2 == 0)\n\
    \            bases += \"1\";\n        else\n            bases += \"0\";\n    \
    \    \n        base = base / 2;\n    }\n    \n    while (x > 0)\n    {\n     \
    \   if (x % base == 0)\n        {\n            bases += \"0\";\n            x\
    \ /= base;\n        }\n        else\n        {\n            bases += \"1\";\n\
    \            x /= base;\n        }\n    }\n    \n    return bases;\n}", "{\n\t\
    if (base < 0 || base > 9) \n\t{\n\t\tstring err = \"change_base() error: base\
    \ must be between 0 and 9.\";\n\t\tthrow new runtime_error(err);\n\t}\n\tif (base\
    \ == 10) \n\t{\n\t\treturn to_string(x);\n\t}\n\tstringstream ss;\n\t\n\tss <<\
    \ x;\n\tstring s = ss.str();\n\tint i = s.size();\n\tint base = pow(10, base);\n\
    \tlong sum = 0;\n\t\n\twhile (i > 0)\n\t{\n\t\tint rem;\n\t\tif (i % base == 0)\
    \ \n\t\t{\n\t\t\tss << base;\n\t\t\tbase *= base;\n\t\t\tsum = 0;\n\t\t}\n\t\t\
    else \n\t\t{\n\t\t\tss >> rem;\n\t\t\tsum += rem;\n\t\t}\n\t\ti /= base;\n\t}\n\
    \tif (sum > 0) \n\t{\n\t\tss << sum;\n\t\ts = ss.str();\n\t\t\n\t}\n\t\n\treturn\
    \ s;\n}", "{\n    string str = \"\";\n    if(x > 0 && x < pow(10, base))\n   \
    \ {\n        long p = 1;\n        while(p < x)\n        {\n            p *= base;\n\
    \        }\n        long q = x / p;\n        string res = \"\";\n        while(p\
    \ > 0)\n        {\n            res += str(p % 10);\n            p /= 10;\n   \
    \     }\n        res += str(q);\n        str += res;\n    }\n    else\n    {\n\
    \        str = \"Error: Base number must be less than or equal to 10.\";\n   \
    \ }\n    return str;\n}\n/*\nReturn number of digits in base b representation\
    \ of integer x.\n    >>> count_digits(123)\n    3\n    >>> count_digits(1234)\n\
    \    4\n    >>> count_digits(12345)\n    6\n*/", "{\n\tint len = 0;\n\tint i;\n\
    \tstring str = \"\";\n\tfor (i = 0; i <= 9; i++)\n\t{\n\t\tif (num2base(i, base)\
    \ < x)\n\t\t\tlen++;\n\t}\n\t\n\tfor(i = len; i <= 9; i++)\n\t{\n\t\tstr += '0';\n\
    \t}\n\t\n\tif (len == 0)\n\t{\n\t\treturn \"0\";\n\t}\n\t\n\tstr += num2base(x,\
    \ base);\n\t\n\treturn str;\n}", "{\n    int\tnum;\n    string\ts;\n    num\t\
    = 0;\n    do {\n        s = num;\n        num = x % base;\n        x = num;\n\
    \    } while ( num != 0 );\n    if ( num < 0 )\n        s = num + '0';\n    return\
    \ s;\n}", "{\n\tif (x < 10) {\n\t\tif (x < 0)\n\t\t\tx = -x;\n\t\tif (base < 3)\n\
    \t\t\tbase = 3;\n\t\tif (base > 10)\n\t\t\tbase = 10;\n\t\treturn to_string(std.int(x)\
    \ / std.int(base));\n\t}\n\t\n\tstring result = \"\";\n\tlong r = std.int(x) %\
    \ std.int(base);\n\t\n\twhile (std.int(x) > 0) {\n\t\tif (r == 0)\n\t\t\tresult\
    \ += std.int(base);\n\t\telse {\n\t\t\tresult += std.int(r / std.int(base))\n\t\
    \t\t\t.to_string(std.int(r % std.int(base)));\n\t\t\tr = 0;\n\t\t}\n\t\tx = std.int(x\
    \ / std.int(base));\n\t}\n\t\n\treturn result;\n}", "{\n\tstringstream s;\n\t\
    long result = 0;\n\t\n\tfor(long i = 0; i < base; i++)\n\t\tresult *= base;\n\t\
    result += x;\n\t\n\tfor(long i = base; i >= 1; i--)\n\t\tresult /= i;\n\t\n\t\
    while(result != 0) {\n\t\tlong temp = result % 10;\n\t\tresult /= 10;\n\t\ts <<\
    \ (char)(temp + 48);\n\t}\n\t\n\treturn s.str();\n}", "{\n    long m = abs(x);\n\
    \    long n = abs(base);\n    if(m < n)\n    {\n        string s = to_string(x);\n\
    \        return changebase(s,n);\n    }\n    else \n    {\n        string s =\
    \ to_string(base);\n        return changebase(s,m);\n    }\n}", "{\n\tstringstream\
    \ ss;\n\tlong n = x;\n\t\n\twhile (true) {\n\t\tss << std::setw(2) << std::setfill('0')\
    \ << (int)n%base;\n\t\tn /= base;\n\t\tif (n == 0) break;\n\t}\n\treturn ss.str();\n\
    }\n//\n// Change base of input number x to base.\n// Return string representation\
    \ of the integer after the conversion.\n// Base numbers are less than 10.\n//\
    \ If base is less than 10 it returns '0'.\n// If base is zero, returns empty string.\n\
    // If base is greater than 10, returns '10'.\nstring change_base(int x, int base)\
    \ {\n\tif (base > 10 || base < 0) return \"10\";\n\tif (base == 0) return \"\"\
    ;\n\treturn change_base((long)x, base);\n}\nstring change_base(string x, int base)\
    \ {\n\tif (base > 10 || base < 0) return \"10\";\n\tif (base == 0) return \"\"\
    ;\n\treturn change_base((long)x, base);\n}", "{\n\tstring strResult=\"\";\n\t\
    int num = 0;\n\t\n\twhile((num < base) && x > 0){\n\t\tlong temp = x / base;\n\
    \t\tnum += 1;\n\t\t\n\t\tstrResult = to_string(temp) + strResult;\n\t\t\n\t\t\
    x -= temp * base;\n\t}\n\t\n\treturn strResult;\n}", "{\n    bool neg = x < 0;\n\
    \    \n    int mod = x % base;\n    string res;\n    if (mod == 0)\n        res\
    \ = \"0\";\n    else {\n        int power = (int)floor(log((double)base) / log(2.0)\
    \ + 1);\n        double pow2 = pow(2.0, power);\n        double div = x / pow2;\n\
    \        double rem = x % pow2;\n        if (rem == 0)\n            res = \"1\"\
    ;\n        else {\n            string str = convert_number(div);\n           \
    \ int div_rem = convert_number(rem);\n            res += str;\n            if\
    \ (div_rem > 0)\n                res += \"-\" + change_base(div_rem, base);\n\
    \        }\n    }\n    if (neg)\n        res = -res;\n    return res;\n}", "{\n\
    \tif (base < 1 || base > 10)\n\t\treturn \"\";", "{\n    int base10 = baseToInt(base);\n\
    \    string s = \"\";\n    \n    for (int i = strlen(toBase10(x)); i > 0; i--)\
    \ \n    {\n        char c = toBase10(x)[i-1];\n        char t = toBase10(x)[i];\n\
    \        char u = toBase10(x)[i+1];\n        \n        if (base10 > 0 && c ==\
    \ toBase10(x-1))\n        {\n            char t = toBase10(x)[i-1];\n        \
    \    char u = toBase10(x)[i+1];\n            if (u != t) \n                s +=\
    \ toBase10(u);\n            break;\n        }\n        else\n        {\n     \
    \       if (c != toBase10(x-1))\n                s += toBase10(c);\n        }\n\
    \    }\n    \n    return s;\n}", "{\n    string res = \"\";\n    while (x>10){\n\
    \        x /= 10;\n        res += (x%10);\n    }\n    res += (x%10);\n    res\
    \ *= base;\n    return res;\n}\n/* Convert string to base 10 integer number */\n\
    long string_to_integer(string str) \n{\n    long base = 10;\n    int len = str.length();\n\
    \    long res = 0;\n    int pos = 0;\n    while (pos < len){\n        res*=base;\n\
    \        res+=str[pos] - '0';\n        pos++;\n    }\n    return res;\n}", "{\n\
    \    if (base < 1 || base > 10)\n        return \"Invalid Base Number\";\n   \
    \ else\n    {\n        string sx = to_string(x);\n        char c;\n        string\
    \ res = \"\";\n        int i = 1;\n        bool neg = false;\n        int n =\
    \ sx.length();\n        for ( ; i < n; i++)\n        {\n            c = sx[i];\n\
    \            if (c == '-')\n            {\n                neg = true;\n     \
    \       }\n            else\n            {\n                if (c == '0') continue;\n\
    \                else\n                    break;\n            }\n        }\n\
    \        long result = 0;\n        for ( ; i < n; i++)\n        {\n          \
    \  c = sx[i];\n            long digit = std.atoi(sx.substr(i, 1));\n         \
    \   if (digit > 0) result += digit * base;\n            else\n            {\n\
    \                result += (digit * base);\n                result += neg;\n \
    \               break;\n            }\n        }\n        string strresult = to_string(result);\n\
    \        while (strresult.length < n)\n            strresult = \"0\" + strresult;\n\
    \        return strresult;\n    }\n}\n</code>\n<|/ a tags=tostring,c++,string\
    \ |>\n<| a |>\nYou can implement a method to_string that uses std::istringstream\
    \ to perform the conversion, and std::ostringstream to return a std::string with\
    \ the string representation of the number.\n<|/ a dscore=1 tags=tostring,c++,string\
    \ |>\n<| a |>\nYou can try using the following code. I'm using the same algorithm\
    \ as you used in your question:\n<code>\n#include <iostream>\n#include <string>",
  "{\n\tstring res;\n\tstring a = to_string(abs(x));\n\tstring b = to_string(base);\n\
    \tlong t = 1;\n\tfor(int i = 0, l = a.size(); i < l; i++)\n\t{\n\t\tchar ch =\
    \ a[i];\n\t\tt *= base;\n\t\tif(ch == '1')\n\t\t{\n\t\t\tt += x;\n\t\t\tt /= base;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tt /= base;\n\t\t}\n\t\t\n\t\tres = tostring(mod(t,\
    \ base));\n\t}\n\treturn res;\n}", "{\n\tlong i, div, mod;\n\tstring res;\n\t\n\
    \tmod = x % base;\n\tx = x / base;\n\tif (mod < 10)\n\t\treturn to_string(mod);\n\
    \t\n\ti = 0;\n\twhile (x < base)\n\t{\n\t\tdiv = x;\n\t\tx = x * base;\n\t\twhile\
    \ (div > 0)\n\t\t{\n\t\t\ti = i + 1;\n\t\t\tdiv = div / base;\n\t\t}\n\t}\n\t\n\
    \tres = \"\";\n\t\n\twhile (i > 0)\n\t{\n\t\tres = to_string(mod % base) + res;\n\
    \t\tmod = mod / base;\n\t\ti = i - 1;\n\t}\n\t\n\tif (mod < 10)\n\t\treturn res\
    \ + \"0\" + to_string(mod);\n\telse\n\t\treturn res;\n}", "{\n    int i = 0;\n\
    \    string result = \"\";\n    string s = \"\";\n    do {\n        long tmp =\
    \ x % base;\n        s += to_string(tmp);\n        x /= base;\n        i++;\n\
    \    } while(x != 0);\n    while (s.length() != 0) {\n        if (i == 0) {\n\
    \            s += \"0\";\n        }\n        else if (i == 1) {\n            s\
    \ = \"1\" + s;\n        }\n        else {\n            s = s.substr(0, s.length()\
    \ - 1) + to_string(atoi(s.substr(s.length() - 1, 1)));\n        }\n        i--;\n\
    \    }\n    result = s;\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=1 |>\n<code>\n// ChangeBase : convert from base 2 to base 10\n// by\
    \ John Malinowski, July 2015\nstring ChangeBase(long n, int base){\n    if (base\
    \ == 2 || base == 8) return ToString(n);", "{\n    string ret = baseStr;\n   \
    \ for(int i = 1; i <= (int)base; i++)\n        ret += digit[(x / base) % base];\n\
    \    while(x != 0)\n        ret += digit[((x % base) * (int)base) % base];\n \
    \   return ret;\n}\n</cell>\n<cell>", "{\n\tint res = 0;\n\twhile (x) {\n\t\t\
    long temp = x % base;\n\t\tres = temp + (res * base);\n\t\tx = x / base;\n\t}\n\
    \tstring result = to_string(res);\n\treturn result;\n}\n/*\nChange bases in string\
    \ \"x\" as much as possible.\n    \n    >>> change_bases(\"11100\")\n    \"1001\"\
    \n    >>> change_bases(\"1010100101001\")\n    \"010101\"\n    \n*/\nstring change_bases(string\
    \ x) \n{\n\tstring result = \"\";\n\t\n\tfor (int i = 0; i < x.length(); i++)\
    \ {\n\t\tresult += change_base(int(x[i]), 4);\n\t}\n\treturn result;\n}", "{\n\
    \tif(base == 10) return to_string(long(x));\n\tstring ret = \"\";\n\twhile(x)\
    \ {\n\t\tif(x % base == 0) \n\t\t\tret += to_string(x/base);\n\t\telse \n\t\t\t\
    ret += to_string(x%base);\n\t\tx /= base;\n\t}\n\treturn ret;\n}", "{\n    if\
    \ (x < base || base < 10)\n        return \"\";\n    string str = \"\";\n    while\
    \ (x>0) {\n        x = x % base;\n        str = char(x) + str;\n    }\n    while\
    \ (str.length() < base)\n        str = char(0) + str;\n    return str;\n}\n/*\n\
    \    Print the contents of a vector. \n    Vectors are printed with commas.\n\
    \    The vector is surrounded by square brackets.\n    \n    >>> print_vec([1])\n\
    \    \"[1]\"\n    >>> print_vec([1,2,3])\n    \"[1, 2, 3]\"\n*/", "{\n    int\
    \ sign = x < 0 ? 1 : 0;\n    bool odd = x > 0;\n    int x_int = sign * x;\n  \
    \  string binary = toBinaryString(x_int);\n    string result = \"\";\n    bool\
    \ first = true;\n    for(int i = 0, size = binary.length(); i < size; i++)\n \
    \   {\n        if(!odd)\n        {\n            if(binary[i] == base) \n     \
    \       {\n                result += binary[i];\n                first = false;\n\
    \            }\n            else\n            {\n                result += binary[i];\n\
    \            }\n            odd ^= 1;\n        }\n        else\n        {\n  \
    \          result += binary[i];\n        }\n    }\n    return sign ? -result :\
    \ result;\n}\n/*\nReturn the result of string x modulo y.\n    x is the string\
    \ representation of base and y is the integer base of the system.\n    if base\
    \ is greater than y, result is zero.\n    if base is greater than y, result is\
    \ zero.\n    if base is equal to y, result is one.\n    if base is less than y,\
    \ result is zero.\n    \n*/\nstring modulus(string x, int y) \n{\n    int sign\
    \ = x < 0 ? 1 : 0;\n    bool odd = x > 0;\n    string binary = toBinaryString(y);\n\
    \    string result = \"\";\n    bool first = true;\n    for(int i = 0, size =\
    \ binary.length(); i < size; i++)\n    {\n        if(!odd)\n        {\n      \
    \      if(binary[i] == base) \n            {\n                result += binary[i];\n\
    \                first = false;\n            }\n            else\n           \
    \ {\n                result += binary[i];\n            }\n            odd ^= 1;\n\
    \        }\n        else\n        {\n            result += binary[i];\n      \
    \  }\n    }\n    return sign ? -result : result;\n}\n/*\nReturn the result of\
    \ string x multiplied with integer y.\n    x is the string representation of base\
    \ and y is the integer base of the system.\n    if base is greater than y, result\
    \ is zero.\n    if base is greater than y, result is zero.\n    if base is equal\
    \ to y, result is one.\n    if base is less than y, result is zero.\n    \n*/\n\
    string multiply(string x, int y) \n{\n    int sign = x < 0 ? 1 : 0;\n    bool\
    \ odd = x > 0;\n    string binary = toBinaryString(y);\n    string result = \"\
    \";\n    bool first = true;\n    for(int i = 0, size = binary.length(); i < size;\
    \ i++)\n    {\n        if(!odd)\n        {\n            if(binary[i] == base)\
    \ \n            {\n                result += binary[i];\n                first\
    \ = false;\n            }\n            else\n            {\n                result\
    \ += binary[i];\n            }\n            odd ^= 1;\n        }\n        else\n\
    \        {\n            result += binary[i];\n        }\n    }\n    return sign\
    \ ? -result : result;\n}\n/*\nReturn the result of string x divided by integer\
    \ y.\n", "{\n    if(base<0)\n    {\n        string msg = \"bases must be non-negative\"\
    ;\n        throw new ArgumentOutOfRangeException(msg);\n    }\n    string result\
    \ = \"\";\n    \n    int power = (int)MathHelper.log(x, base);\n    int decimal\
    \ = MathHelper.floorMod(x, base);\n    \n    int count = 0;\n    for(int i = 0;\
    \ i < power; i++)\n    {\n        int temp = MathHelper.pow(x, power);\n     \
    \   temp = temp % base;\n        count++;\n        if(temp<0)\n        {\n   \
    \         temp = temp + base;\n            count++;\n        }\n    }\n    \n\
    \    for(int i = 0; i < count; i++)\n    {\n        result = result + \"0\";\n\
    \    }\n    result = result + decimal;\n    \n    return result;\n}\n/*\nConvert\
    \ base 10 number x to base base number y.\n    Return string representation of\
    \ the converted number.\n    base numbers are less than 10.\n    >>> changebase(8L,\
    \ 3L)\n    \"22\"\n    >>> changebase(8L, 2L)\n    \"1000\"\n    >>> changebase(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring changebase(long x, long y)\n{\n    if(y<0)\n\
    \    {\n        string msg = \"bases must be non-negative\";\n        throw new\
    \ ArgumentOutOfRangeException(msg);\n    }\n    string result = \"\";\n    \n\
    \    long power = MathHelper.log(x, y);\n    long decimal = MathHelper.floorMod(x,\
    \ y);\n    \n    long count = 0;\n    for(int i = 0; i < power; i++)\n    {\n\
    \        long temp = MathHelper.pow(x, power);\n        temp = temp % y;\n   \
    \     count++;\n        if(temp<0)\n        {\n            temp = temp + y;\n\
    \            count++;\n        }\n    }\n    \n    for(int i = 0; i < count; i++)\n\
    \    {\n        result = result + \"0\";\n    }\n    result = result + decimal;\n\
    \    \n    return result;\n}\n/*\nConvert the string representation of numbers\
    \ to double numbers.\n    \n    Input Format: \n        Input is separated into\
    \ two groups of four digits \n        numbers and decimal numbers separated by\
    \ white space.\n        \n    Output Format:\n        Two groups of four digits\
    \ numbers and decimal numbers \n        are separated by white space.\n    \n\
    \    >>> convert_string(\"8 3 8 22\")\n    '8 3 8 22'\n    >>> convert_string(\"\
    8 3 8 22 9.2 11\")\n    '8 3 8 22 9.2 11'\n    >>> convert_string(\"8 3 8 22 9.2\
    \ 11 3.14\")\n    '8 3 8 22 9.2 11 3.14'\n    >>> convert_string(\"8 3 8 22 9.2\
    \ 11 3.1415\")\n    '8 3 8 22 9.", "{\n  long x_remainder, x_digit;\n  long x_quotient,\
    \ x_factor;\n  string result = \"\";\n  \n  x_quotient = x / (long)base;\n  x_remainder\
    \ = x % (long)base;\n  \n  for(; x_quotient > 0; x_quotient--)\n  {\n    x_digit\
    \ = x_quotient % base;\n    result += x_digit;\n  }\n  \n  x_factor = (long)x_remainder;\n\
    \  result += x_factor;\n  \n  return result;\n}\n</code>\n<|/ a tags=c#,c++ |>\n\
    <| a dscore=0 |>\nHere's a C# solution that uses only built-in .NET classes:\n\
    <code>\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(Math.Pow(30,\
    \ 2));\n    }\n}", "{\n  long t = toLong(x);\n  if (base < 10)\n  {\n    string\
    \ sBase = to_string(base);\n    return to<string>(pow(t,to_ulong(sBase)));\n \
    \ }\n  string sBase = to_string(base);\n  string sx = to_string(t);\n  return\
    \ sx.substr(0, sx.length() - sBase.length()) + sBase;\n}\n/*\nConverts a binary\
    \ number in string form to its decimal equivalent.\n>>> decBin(\"1\")\n1\n>>>\
    \ decBin(\"10\")\n2\n>>> decBin(\"01010\")\n10\n>>> decBin(\"010\")\n2\n>>> decBin(\"\
    0000\")\n0\n>>> decBin(\"00\")\n0\n*/\nlong decBin(string str)\n{\n  long res\
    \ = 0;\n  for (int i = str.size()-1; i >= 0; i--)\n  {\n    if (str[i] == '1')\n\
    \      res *= 2;\n    else\n      res += (str[i]-'0') * 1;\n  }\n  return res;\n\
    }", "{\n    // This function should return string representation after the conversion.\n\
    \    // Base numbers are less than 10.\n    if (x == 0) \n        return \"0\"\
    ;\n    else if (base == 0) \n        return \"0\";\n    else if (base == 1L) \n\
    \        return to_string(x);\n    else if (base > 1L) \n    {\n        string\
    \ res = \"\";\n        long tmp = x;\n        while (x > 0)\n        {\n     \
    \       res = to_string(x%base) + res;\n            x /= base;\n        }\n  \
    \      return res;\n    }\n    else \n    {\n        throw new ArgumentException(\"\
    Invalid base number\");\n    }\n}\n</code>\n<|/ a dscore=2 tags=c#,math |>\n<|\
    \ a dscore=1 |>\nAnother way:\n<code>\n  public static string ConvertToDecimal(long\
    \ value, int decimalPlaces = 0)\n        {\n            string result = null;",
  "{\n    if (x < 0 || base < 10) return \"Invalid base\";\n    long y = x;\n    while\
    \ (y > base) {\n        y = y / base;\n    }\n    string result = \"\";\n    while\
    \ (y > 0) {\n        result = str(y%base) + result;\n        y = y / base;\n \
    \   }\n    if (result == \"\") return \"0\";\n    return result;\n}\n/*\nCalculate\
    \ the sum of digits of the input number x.\n    return string representation of\
    \ sum of digits.\n    >>> sum_digits(1L)\n    \"1\"\n    >>> sum_digits(12L)\n\
    \    \"3\"\n    >>> sum_digits(120L)\n    \"6\"\n    \n*/\nstring sum_digits(long\
    \ x)\n{\n    int i = 0;\n    while (x > 0) {\n        i = i + int((x % 10)); \n\
    \        x = x / 10;\n    }\n    return str(i); \n}\n/*\nReturn the number in\
    \ reversed base-10 representation.\n    (e.g. 12345 -> 4321)\n*/\nstring reversebase(long\
    \ x, int base)\n{\n    string result = \"\";\n    while (x > 0) {\n        long\
    \ rest = x / base;\n        string s = str(rest);\n        result = s + result;\n\
    \        x = x - rest*base;\n    }\n    return result;\n}\n/*\nReturn the number\
    \ in base-10 representation\n    (e.g. 4321 -> 12345)\n*/\nlong reversebase(string\
    \ x, int base)\n{\n    long result = 0;\n    for (char c : x) {\n        long\
    \ rest = c - '0';\n        long res = rest*base;\n        result = result + res;\n\
    \    }\n    return result;\n}\n/*\nCalculate power of x to n where x is double\
    \ and n is int.\n    return the result in double.\n    result is the same as x^n\n\
    \    input number is positive.\n    result may have infinite precision.\n    >>>\
    \ pow(10.0, 3.0)\n    10000000.0\n    >>> pow(10, 3)\n    1000.0\n    >>> pow(10,\
    \ 4)\n    1.000000\n    \n*/\ndouble pow(double x, int n)\n{\n    double result\
    \ = x;\n    for (int i = 0; i < n; i++) {\n        result = result * x;\n    }\n\
    \    return result;\n}\n/*\nCalculate the greatest common divisor of x and y.\n\
    \    return double which is the same as x if y > x and y if x < x.\n    x is greater\
    \ or equal to 0.\n    y is greater than 0.\n    x and y are both positive.\n \
    \   result may have infinite precision.\n    >>> gcd(10, 20)\n    10\n    >>>\
    \ gcd(100, 200)\n    100\n    >>> gcd(200, 100)\n    100\n    >>> gcd(200, 100)\n\
    \    100\n    \n*/\ndouble gcd(double x, double y) \n{\n    if (y >= x) {\n  \
    \      if (", "{\n\tlong res = 0;\n\tif (x < base) {\n\t\treturn \"0\";\n\t}\n\
    \t\n\tlong rem = x % base;\n\twhile (x >= base) {\n\t\tres++;\n\t\tx /= base;\n\
    \t}\n\t\n\tif (rem > 0)\n\t\tres = res + 1;\n\t\n\treturn to_string(res);\n}",
  "{\n    string result = \"\";\n    long temp = 0;\n    \n    while (base!=0)\n \
    \   {\n        temp = x/base;\n        x = temp;\n        result = temp * base\
    \ + result;\n        base--;\n    }\n    \n    return result;\n}", "{\n\tint i,\
    \ ret[100];\n\tchar buf[100];\n\tstring ans;\n\tfor(i=100; i>=0; i--) ret[i]=0;\n\
    \tfor(i=0; i<base; i++) ret[x%base] = i;\n\tx/= base;\n\tfor(i=base-1; i>=0; i--)\
    \ \n\t{\n\t\tchar c = ret[i];\n\t\tbuf[i-base] = c;\n\t\tif(i==base) \n\t\t\t\
    ans = string(buf, i+1);\n\t\telse\n\t\t{\n\t\t\tfor(j=0; j<i-base; j++) \n\t\t\
    \t\tbuf[j] = buf[j+1];\n\t\t\tans = string(buf, i-base+1) + ans;\n\t\t}\n\t\t\
    x*= base;\n\t}\n\treturn ans;\n}", "{\n    long x_l = x, x_r = x;\n    string\
    \ r_s = \"\";\n    \n    int i = 0; \n    while (i <= base) { \n        x = x_r\
    \ * base + x_l;\n        x_r = x;\n        i++;\n    }\n    while (x > 0)\n  \
    \  {\n        r_s += (char) (x % base);\n        x /= base;\n    }\n    return\
    \ r_s;\n}", "{\n    string strResult;\n    string strBase;\n    \n    strBase\
    \ = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    \n    long  y = x; //y = (long)\
    \ strBase.rfind(x);\n    if (y != string::npos)\n        y = strBase.rfind(x,y);\
    \ //get the index of x in the base strBase\n    \n    strResult = strBase.substr(y,\
    \ strBase.size());\n    \n    if (base < 10)\n    {\n        strResult = strResult.resize(strResult.size()\
    \ - 1, strBase.size());\n        strResult = strResult.substr(0, strResult.size()-1)\
    \ + strResult.substr(strResult.size() - 1);\n        strResult = \"0\" + strResult;\n\
    \    }\n    \n    return strResult;\n}", "{\n    if (x < base)\n    {\n      \
    \  //convert from decimal to binary.\n        //the binary number represented\
    \ by a decimal number is a string consisting of 1 followed by the digits of the\
    \ decimal number in numerical order, with a single leading 0.\n        return\
    \ string(\"1\") + to_string(x);\n    }\n    else\n    {\n        //convert from\
    \ binary to decimal.\n        //the decimal number represented by a binary number\
    \ is a string consisting of 1 followed by the digits of the binary number in numerical\
    \ order, followed by a decimal point, followed by a 0. \n        return string(\"\
    1\") + to_string(x / base) + string(\".\") + to_string((x - base * floor(x / base)));\n\
    \    }\n}\n</code>\n<|/ a dscore=0 tags=c++,math,algorithm,c |>\n<| c |>\nWhat\
    \ about negative numbers? And why do you need `#include <math.h>`?\n<|/ c |>\n\
    <| c |>\nYes you are right I was confused about what OP wants but's answer seems\
    \ fine.\n<|/ c |>\n<| a |>\n<code>\n#include <stdio.h>\n#include <math.h>", "{\n\
    \    if (base > 10)\n        return \"ERROR\";", "{\n\tstring ans = \"\";\n\t\
    bool neg = (x < 0L);\n\tif(neg) x = -x;\n\tlong quot = x / base;\n\tlong mod =\
    \ x % base;\n\twhile (mod == 0L) \n\t{\n\t\tans = charof(base) + ans;\n\t\tquot++;\n\
    \t\tmod = x / base;\n\t\tx = x % base;\n\t}\n\t\n\tstring s = ans;\n\tdo\n\t{\n\
    \t\tif(mod == base) break;\n\t\tchar c = charof(mod + base);\n\t\ts = c + s;\n\
    \t\tmod = mod % base;\n\t} while(mod != 0L);\n\t\n\tif(neg) s = charof(-mod) +\
    \ s;\n\t\n\treturn s;\n}", "{\n  int i = 1;\n  string ans = \"\";\n  while (i\
    \ <= base) \n  {\n    ans += (char)(x % base);\n    x /= base;\n    i++;\n  }\n\
    \  return ans;\n}", "{\n\tstring result = \"\";\n\tlong temp = x;\n\t\n\twhile\
    \ (temp > 0) {\n\t\tif (base >= 10) {\n\t\t\tresult = result + (temp%base);\n\t\
    \t}\n\t\ttemp = temp / base;\n\t\tbase = base * 10;\n\t}\n\t\n\treturn result;\n\
    }\n/*\nFind a number in an array that is a power of 2\n    >>> find_pow2(2L)\n\
    \    true\n    >>> find_pow2(3L)\n    true\n    >>> find_pow2(0L)\n    true\n\
    \    >>> find_pow2(7L)\n    false\n    \n*/", "{\n\tchar buffer[64];\n\tint digits\
    \ = (int) log(x) / log(base);\n\tint power = (int) (log(x) / log(base));\n\tbuffer[--power]\
    \ = '0';\n\twhile ( digits > 0 ) {\n\t\tbuffer[--power] = '%';\n\t\tdigits = digits\
    \ % base;\n\t\tx = x / base;\n\t}\n\treturn string(buffer, power) + to_string(x);\n\
    }", "{\n    // Your code goes here\n    string ret = \"\";\n    while (x > 0)\n\
    \    {\n        ret += std.int2char(x%base);\n        x /= base;\n    }\n    while\
    \ (ret.length < base)\n        ret += \"0\";\n    return ret;\n}", "{\n    string\
    \ s = \"\";\n    while (x > base)\n    {\n        long d = x;\n        x = x %\
    \ base;\n        string s = s + char(d);\n    }\n    return s + char(x);\n}\n\
    /*\nAdd '0' before decimal point of string representation.\n    returns string\
    \ representation of sum.\n    >>> add_zero(\"22.9\")\n    \"22.9\"\n    >>> add_zero(\"\
    22.1\")\n    \"22.10\"\n    \n*/\nstring add_zero(string s)\n{\n    string t =\
    \ \"\";\n    if (s.length() > 2)\n    {\n        char c = s[1];\n        if (c.isdigit())\n\
    \        {\n            int n = stoi(s);\n            string res = to_string(n\
    \ + 0);\n            if (res.substr(0, 1) != char(0))\n                res = \"\
    0\" + res;\n            s = chars(res) + char(c);\n        }\n    }\n    return\
    \ s;\n}\n/*\nAdd '0' before decimal point of string representation.\n    returns\
    \ string representation of sum.\n    >>> add_zero(\"8\")\n    \"8\"\n    >>> add_zero(\"\
    9\")\n    \"9\"\n    \n*/\nstring add_zero(long x)\n{\n    string s = to_string(x);\n\
    \    if (s.length() > 2)\n    {\n        char c = s[1];\n        if (c.isdigit())\n\
    \        {\n            int n = stoi(s);\n            string res = to_string(n\
    \ + 0);\n            if (res.substr(0, 1) != char(0))\n                res = \"\
    0\" + res;\n            s = chars(res) + char(c);\n        }\n    }\n    return\
    \ s;\n}\n/*\nReturns true if x is integer number.\n    returns true if x is float\
    \ number.\n    returns true if x is integer or float number.\n    returns true\
    \ if x is negative integer.\n    returns true if x is positive integer.\n    returns\
    \ true if x is negative float number.\n    returns true if x is positive float\
    \ number.\n    returns true if x is infinity.\n    returns true if x is noninfinity.\n\
    \    returns true if x is nan.\n    returns true if x is finite and has same sign\
    \ as zero.\n    returns true if x is finite and has different sign as zero.\n\
    \    returns true if x is finite and zero in absolute value.\n    returns true\
    \ if x is infinite and zero in absolute value.\n    returns true if x is finite\
    \ and zero in sign.\n    returns true if x is infinite and zero in sign.\n   \
    \ returns true if x is finite and zero in magnitude.\n    returns true if x is\
    \ infinite and zero in magnitude.\n    returns true if x is infinite and zero\
    \ in sign or magnitude.\n    returns true if x is infinite and zero in sign and\
    \ magnitude.\n    ", "{\n    string result;\n    long res = 0;\n    \n    while\
    \ (x > 0) \n    {\n        res = (res * base) + x;\n        x /= base;\n    }\n\
    \    result = (long)(res%base);\n    return result.to_string();\n}\n/*\nChange\
    \ numerical base of input number x to base.\n    return string representation\
    \ after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8L,\
    \ 3L)\n    \"22\"\n    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring change_base(string x, long base) \n{\n  \
    \  string result;\n    long res = 0;\n    \n    while (x != \"\") \n    {\n  \
    \      res = (res * base) + std.stringx.tointeger(x);\n        x /= base;\n  \
    \  }\n    result = (long)(res%base);\n    return result.to_string();\n}\n/*\n\
    Change numerical base of input number x to base.\n    return string representation\
    \ after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8L,\
    \ 3L)\n    \"22\"\n    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring change_base(char x, long base) \n{\n    string\
    \ result;\n    long res = 0;\n    \n    while (x != '\\0') \n    {\n        res\
    \ = (res * base) + std.stringx.tointeger(x);\n        x /= base;\n    }\n    result\
    \ = (long)(res%base);\n    return result.to_string();\n}\n/*\nChange numerical\
    \ base of input number x to base.\n    return string representation after the\
    \ conversion.\n    base numbers are less than 10.\n    >>> change_base(8L, 3L)\n\
    \    \"22\"\n    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L,\
    \ 2L)\n    \"111\"\n    \n*/\nstring change_base(std.complex x, long base) \n\
    {\n    string result;\n    long res = 0;\n    \n    while (x != complex(0)) \n\
    \    {\n        res = (res * base) + complex(res.real,res.imag);\n        x /=\
    \ base;\n    }\n    result = (long)(res%base);\n    return result.to_string();\n\
    }\n/*\nChange numerical base of input number x to base.\n    return string representation\
    \ after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8L,\
    \ 3L)\n    \"22\"\n    >>> change_base(8L, 2L)\n    \"1000\"\n    >>> change_base(7L,\
    \ 2L)\n    \"111\"", "{\n\tswitch(base){\n\tcase 2:\n\t\treturn to_string(x /\
    \ 2);\n\tcase 3:\n\t\treturn to_string(x / 3);\n\tcase 4:\n\t\treturn to_string(x\
    \ / 4);\n\tcase 5:\n\t\treturn to_string(x / 5);\n\tcase 6:\n\t\treturn to_string(x\
    \ / 6);\n\tcase 7:\n\t\treturn to_string(x / 7);\n\tcase 8:\n\t\treturn to_string(x\
    \ / 8);\n\tcase 9:\n\t\treturn to_string(x / 9);\n\tcase 10:\n\t\treturn to_string(x\
    \ / 10);\n\tcase 11:\n\t\treturn to_string(x / 11);\n\tcase 12:\n\t\treturn to_string(x\
    \ / 12);\n\tcase 13:\n\t\treturn to_string(x / 13);\n\tcase 14:\n\t\treturn to_string(x\
    \ / 14);\n\tcase 15:\n\t\treturn to_string(x / 15);\n\tcase 16:\n\t\treturn to_string(x\
    \ / 16);\n\tcase 17:\n\t\treturn to_string(x / 17);\n\tcase 18:\n\t\treturn to_string(x\
    \ / 18);\n\tcase 19:\n\t\treturn to_string(x / 19);\n\tcase 20:\n\t\treturn to_string(x\
    \ / 20);\n\tcase 21:\n\t\treturn to_string(x / 21);\n\tcase 22:\n\t\treturn to_string(x\
    \ / 22);\n\tcase 23:\n\t\treturn to_string(x / 23);\n\tcase 24:\n\t\treturn to_string(x\
    \ / 24);\n\tcase 25:\n\t\treturn to_string(x / 25);\n\tcase 26:\n\t\treturn to_string(x\
    \ / 26);\n\tcase 27:\n\t\treturn to_string(x / 27);\n\tcase 28:\n\t\treturn to_string(x\
    \ / 28);\n\tcase 29:\n\t\treturn to_string(x / 29);\n\tcase 30:\n\t\treturn to_string(x\
    \ / 30);\n\tcase 31:\n\t\treturn to_string(x / 31);\n\tcase 32:\n\t\treturn to_string(x\
    \ / 32);\n\tcase 33:\n\t\treturn to_string(x / 33);\n\tcase 34:\n\t\treturn to_string(x\
    \ / 34);\n\tcase 35:\n\t\treturn to_string(x / 35);\n\tcase 36:\n\t\treturn to_string(x\
    \ / 36);\n\tcase 37:\n\t\treturn to_string(x / 37);\n\tcase 38:\n\t\treturn to_string(x\
    \ / 38);\n\tcase 39:\n\t\treturn to_string(x / 39);\n\tcase 40:\n\t\treturn to_string(x\
    \ / 40);\n\tcase 41:\n\t\treturn to_string(x / 41);\n\tcase 42:\n\t\treturn to_string(x\
    \ / 42);\n\tcase 43:\n\t\treturn to_string(x / 43);\n\tcase 44:\n\t\treturn to_string(x\
    \ / 44);\n\tcase 45:\n\t\treturn to_string(x / 45);\n\tcase 46:\n\t\treturn to_string(x\
    \ / 46);\n\tcase 47:\n\t\treturn ", "{\n    string s = string(x);\n    string\
    \ result = \"\";\n    for (int i = 0; i<s.length(); i++) {\n        int xi = toint(s[i]);\n\
    \        if (xi%base != 0) {\n            result += s[i];\n        }\n    }\n\
    \    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c#,algorithm,string\
    \ |>\n<code>\n// convert number to string\npublic string ToNumber(long number)\n\
    {\n  string s = number.ToString();\n  int len = s.Length;\n  if (len > 10)\n \
    \ {\n    // handle number > 10 \n    string newS = \"\";\n    int maxLen = len\
    \ - 10;\n    int i = maxLen - 1;\n    while (i >= 0)\n    {\n      newS = newS\
    \ + s.Substring(i--, 1) + \"\";\n    }\n    return newS;\n  }\n  return s;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\npublic string ConvertToString(int\
    \ num)\n{\n    int decimalPointCount = num % 1000;\n    int digitsCount = num\
    \ / 1000;\n    return decimalPointCount + Convert.ToString( digitsCount);\n}\n\
    </code>\n<|/ a tags=c#,algorithm,string dscore=0 |>\n<| a dscore=0 |>\nTry this.\n\
    <code>\nstring ConvertToString(int number)\n{\n    string str = \"\";\n    if\
    \ (number > 0)\n    {\n        str = number.ToString();\n        int decimalIndex\
    \ = str.IndexOf('.');\n        int wholeIndex = str.IndexOf('0');\n        if\
    \ (decimalIndex > wholeIndex)\n        {\n            str = str.Remove(decimalIndex);\n\
    \        }\n        str = str.Insert(str.Length - 1, '0');\n    }\n    return\
    \ str;\n}\n</code>\n<|/ a tags=c#,algorithm,string |>\n<| a dscore=0 |>\n<code>\n\
    public static string ToString(long number)\n{\n    int digitsCount = Convert.ToInt32(Math.Truncate(number\
    \ * Math.Pow(10, Math.Floor(Math.Log10(number))) + 0.5));", "{\n    string s;\n\
    \    \n    long temp = x;\n    \n    while (temp > 0) {\n        \n        s =\
    \ to_string(temp%base);\n        temp = temp/base;\n        \n    }\n    \n  \
    \  return s;\n}\n</cell>\n<code language=dyalog-kernel>\nchange_base(1000L, 3L)\n\
    </cell>\n<text>\nThe last thing to do is to implement a way to display the table\
    \ of numbers from one base to another. Write a function that takes in the start\
    \ number and end number and displays a table of numbers between the start and\
    \ end number in the given base. Bases greater than 10 should use 10 powers of\
    \ 10 as the base. For example, base = 2 and numbers from 0 to 99 should be displayed\
    \ as follows:", "{\n    long tmp = x;\n    long result = 1;\n    long i;\n   \
    \ string result = \"\";", "{\n\tif (x < 0)\n\t\tx = -x;\n\tlong n = 0;\n\twhile\
    \ (x /= base) {\n\t\tn += base - (x % base);\n\t}\n\treturn string(n);\n}", "{\n\
    \  if (x < 0 || base < 10) \n  {\n    string result;\n    char * s = std.typecons.cast(char*\
    \ x, char*);\n    char c = std.typecons.cast(char, s);\n    std.typecons.sprintf(result,\
    \ \"%c\", x);\n    return result;\n  }\n  \n  char * s = std.typecons.cast(char*\
    \ x, char*);\n  char c = std.typecons.cast(char, s);\n  \n  int i = 0;\n  while\
    \ (i > 0 && s[i-1] == c) \n  {\n    i -= 1;\n  }\n  \n  int j = 0;\n  while (j\
    \ > 0 && s[j-1] == c) \n  {\n    j -= 1;\n  }\n  \n  if (i >= base || j >= base)\
    \ \n  {\n    string result;\n    char * s = std.typecons.cast(char* x, char*);\n\
    \    char c = std.typecons.cast(char, s);\n    std.typecons.sprintf(result, \"\
    %c\", x);\n    return result;\n  }\n  \n  char * s = std.typecons.cast(char* x,\
    \ char*);\n  char c = std.typecons.cast(char, s);\n  \n  int i2 = i;\n  i2 = i2\
    \ + (int)base;\n  if (i2 < base)\n  {\n    i2 = 0;\n  }\n  \n  char * s2 = std.typecons.cast(char*\
    \ x, char*);\n  char c2 = std.typecons.cast(char, s2);\n  \n  char * s3 = std.typecons.cast(char*\
    \ x, char*);\n  char c3 = std.typecons.cast(char, s3);\n  \n  char * s4 = std.typecons.cast(char*\
    \ x, char*);\n  char c4 = std.typecons.cast(char, s4);\n  \n  char temp;\n  std.typecons.sprintf(s4,\
    \ \"%c\", x);\n  c4 = std.typecons.cast(char, s4);\n  \n  std.typecons.sprintf(s3,\
    \ \"%c\", x);\n  c3 = std.typecons.cast(char, s3);\n  \n  temp = std.typecons.cast(char,\
    \ x);\n  std.typecons.sprintf(s2, \"%c\", x);\n  c2 = std.typecons.cast(char,\
    \ s2);\n  \n  c2 = std.typecons.cast(char, temp);\n  c3 = std.typecons.cast(char,\
    \ temp);\n  c4 = std.typecons.cast(char, temp);\n  \n  if (", "{\n    string s\
    \ = \"\";\n    while (x != 0) {\n        // Represent number in base-10\n    \
    \    int digit = x % base;\n        // Convert to base-string\n        s += digits[digit];\n\
    \        // Divide by base\n        x = x / base;\n    }\n    return s;\n}", "{\n\
    \    string res;\n    \n    res = \"\";\n    \n    while (x!=0) {\n        res\
    \ += (x % base);\n        x/=base;\n    }\n    \n    return res;\n}", "{\n   \
    \ string r;\n    if (x<base){\n        reverse(x);\n        string s = str(x);\n\
    \        reverse(s);\n        s=str(base)+s;\n    }\n    else{\n        reverse(x);\n\
    \        string s = str(x);\n        reverse(s);\n        s=str(base)+\"0\"+s;\n\
    \    }\n    \n    string ret=s;\n    \n    return ret;\n}", "{\n    if (base <\
    \ 2) return \"error: base must be greater than or equal to 2\";\n    if (base\
    \ > 10) return \"error: base must be less than or equal to 10\";\n    if (base\
    \ > std.digits.getSize()) return \"error: base is too big\";\n    long rem, sum\
    \ = 0;\n    while (x != 0) {\n        long digit = x % base;\n        rem = x\
    \ / base;\n        sum += digit * (long)(Math.pow(base, rem));\n        x = rem;\n\
    \    }\n    return to_string(sum);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
