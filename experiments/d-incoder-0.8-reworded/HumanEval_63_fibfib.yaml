name: HumanEval_63_fibfib
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nThe FibFib number sequence is\
  \ a sequence similar to the Fibbonacci sequnece that's defined as follows:\n   \
  \ fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1)\
  \ + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute\
  \ the n-th element of the fibfib number sequence.\n    >>> fibfib(1L)\n    0L\n\
  \    >>> fibfib(5L)\n    4L\n    >>> fibfib(8L)\n    24L\n    \n*/\nlong fibfib(long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = fibfib;\n\n    assert(candidate(2L) ==\
  \ 1L);\n    assert(candidate(1L) == 0L);\n    assert(candidate(5L) == 4L);\n   \
  \ assert(candidate(8L) == 24L);\n    assert(candidate(10L) == 81L);\n    assert(candidate(12L)\
  \ == 274L);\n    assert(candidate(14L) == 927L);\n}\nvoid main(){}"
completions: ["{\n    if (n < 0)\n\t{\n\t\tthrow new RangeError();\n\t}\n\t\n\tif\
    \ (n == 0)\n\t\treturn 0;\n\tif (n == 1)\n\t\treturn 1;\n\treturn fibfib(n-1)\
    \ + fibfib(n-2);\n}\n/*\nThe FibFibSequence sequence is a sequence similar to\
    \ the FibFib sequnece that's defined as follows:\n    fibfibseq(0) == ([0])\n\
    \    fibfibseq(1) == ([0])\n    fibfibseq(2) == ([0,1])\n    fibfibseq(n) == fibfibseq(n-1)\
    \ + fibfibseq(n-2) + fibfibseq(n-3).\n    Please write a function to efficiently\
    \ compute the n-th element of the fibfibseq number sequence.\n    >>> fibfibseq(1L)\n\
    \    ([0]L)\n    >>> fibfibseq(5L)\n    ([0]L, [1]L)\n    >>> fibfibseq(8L)\n\
    \    ([0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8])\n    \n\
    \    \n*/\nstruct FibFibSequence\n{\n\tlong len;\n\tlong[] elem;\n};", "{\n  \
    \  long res;\n    std.assert(n >= 0 && n <= 25);\n    res = 0;\n    while (n>0)\
    \ \n    {\n        res += (n%2 == 0);\n        n/=2;\n    }\n    return res;\n\
    }", "{\n  if (n < 2L)\n    return (long) std.math.fibonacci(n);\n  else\n    return\
    \ fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n}\n</code>\nNow here's a naive\
    \ recursive solution:\n<code>\n/**\n* A naive recursive solution to the fibbonacci\
    \ sequence problem.\n* \n* A naive recursive solution to the fibbonacci sequence\
    \ problem.\n* \n* a number as large as fibbonacci can handle.\n*/\nlong fibNaive(long\
    \ n) \n{\n  if (n < 2L)\n    return (long) std.math.fibonacci(n);\n  else\n  \
    \  return fibNaive(n-1L) + fibNaive(n-2L) + fibNaive(n-3L);\n}\n</code>\nAnd a\
    \ slightly faster recursive version:\n<code>\n/**\n* A slightly faster recursive\
    \ solution to the fibbonacci sequence problem.\n* \n* A slightly faster recursive\
    \ solution to the fibbonacci sequence problem.\n* \n* a number as large as fibbonacci\
    \ can handle.\n*/\nlong fibNaive(long n) \n{\n  if (n < 2L)\n    return (long)\
    \ std.math.fibonacci(n);\n  else\n    return fibNaive(n-1L) + fibNaive(n-2L) +\
    \ fibNaive(n-3L) + fibNaive(n-4L);\n}\n</code>\nWe can profile the solutions:\n\
    <code>\nscala> :pa\n// Entering paste mode (ctrl-D to finish)", "{\n    if (n\
    \ <= 1L) return 0L;\n    if (n <= 3L) return 1L;\n    return fibfib(n-1L) + fibfib(n-2L)\
    \ + fibfib(n-3L);\n}\n</code>\n<|/ a tags=language-agnostic,recursion,fibonacci\
    \ |>\n<| a dscore=0 |>\n<code>\npublic class Fib {\nprivate static final int fib[]\
    \ = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89};", "{\n\tlong retVal;\n\tlong tmp;\n\
    \tlong fibfib;\n\tif(n == 0) \n\t\treturn 0L;\n\tif(n == 1) \n\t\treturn 0L;\n\
    \tif(n == 2) \n\t\treturn 1L;\n\tfibfib = fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    \ttmp = fibfib - n; // fibfib(n-3)\n\ttmp += tmp; // fibfib(n-2)\n\ttmp += tmp;\
    \ // fibfib(n-1)\n\tretVal = tmp;\n\treturn retVal;\n}\n*/\n//!  Test driver\n\
    /*\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>", "{\n    long\
    \ f = 0;\n    for(int i = 0; i < n; i++)\n        f = f + i;\n    return f;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThank you,, but can you please explain\
    \ how you solved the problem without using recursion?\n<|/ c |>\n<| c |>\nRecursion\
    \ will consume stack space and may lead to stack overflow if you try to compute\
    \ a large number as opposed to just one number. For example, if you try computing\
    \ `fibfib(8L)` it will cause an overflow. So, in this case you need to implement\
    \ the algorithm without recursion. One way is to create a stack and push each\
    \ number as you compute, and when you're done compute the number at the top of\
    \ the stack. Another way, the one I implemented, is to calculate the series in\
    \ a loop from 0 to n, and then compute the nth element of the series, and add\
    \ it to your result each iteration.\n<|/ c |>\n<| a dscore=1 |>\nIt seems you\
    \ are implementing fibonacci without using recursion.  If you use recursion, then\
    \ the problem will be solved using recursion. Since this task is of Fibonacci\
    \ series , there are a lot of algorithms that can compute fibonacci without using\
    \ recursion. \n<code>", "{\n\tlong a = 3L;\n\tlong b = 4L;\n\tlong c = 0L;\n\t\
    while (n >= 0) {\n\t\tc = a + b + c;\n\t\ta = b;\n\t\tb = c;\n\t\tn = n - 1L;\n\
    \t}\n\treturn c;\n}", "{\n    if(n <= 3L)\n    {\n        return n;\n    }\n \
    \   return fibfib(n-2L) + fibfib(n-3L) + fibfib(n-1L);\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nI appreciate you taking the time to write an answer. However your\
    \ answer does not take into account the fact that the sequence is recursive and\
    \ that OP's question was how to do this recursively. Your answer only talks about\
    \ iterative solutions. If you add some explanatory text it would greatly improve\
    \ this answer.\n<|/ c |>\n<| a dscore=0 |>\nTo compute fibfib function recursively:\n\
    <code>\ndef fibfib(n):\n    if n <= 0:\n        return 0\n    elif n ==1:\n  \
    \      return 1\n    else:\n        return fibfib(n-1)+fibfib(n-2)", "{\n    long\
    \ a = 0, b = 1, c = 0, d;\n    for(a; b < n; a++,b++,c++)\n    {\n        d =\
    \ c + b;\n    }\n    return d;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThe Fibonacci\
    \ sequence is much faster than this naive approach (O(n^2)).\n<|/ c |>\n<| a dscore=1\
    \ |>\nI like to use this simple algorithm to find Fibonacci numbers:\n<code>\n\
    def fib(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return\
    \ 2\n    else:\n        return fib(n-2) + fib(n-1)", "{\n    long sum = 0;\n \
    \   if (n == 0)\n        return 0;\n    if (n == 1)\n        return 1;\n    if\
    \ (n == 2)\n        return 2;\n    while (n > 2)\n    {\n        sum = fib(n -\
    \ 1) + fib(n - 2);\n        n = n - 3;\n    }\n    return sum;\n}", "{\n    if\
    \ (n<=0)\n    {\n        return 0;\n    }\n    if (n==1)\n    {\n        return\
    \ 1;\n    }\n    if (n==2)\n    {\n        return 2;\n    }\n    if (n==3)\n \
    \   {\n        return 3;\n    }\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThe Fibonacci sequence isn't defined for negative\
    \ inputs: http://en.wikipedia.org/wiki/Fibonacci_number#Definition\n<|/ c |>\n\
    <| c |>\nYes, that's why it's called a \"FibFib\" number sequence, not \"Fibonacci\"\
    . The \"fibfib\" part is just a term I picked up from googling to make it shorter\
    \ and easier to understand. The \"fibfib(n)\" part is what actually generates\
    \ the sequence you see at the beginning.\n<|/ c |>\n<| c |>\n`long fibfib(long\
    \ n) \n{\n    if (n<=0)\n    {\n        return 0;\n    }\n    if (n==1)\n    {\n\
    \        return 1;\n    }\n    if (n==2)\n    {\n        return 2;\n    }\n  \
    \  if (n==3)\n    {\n        return 3;\n    }\n    return fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3);\n}\n` this answer should be correct\n<|/ c |>\n<| c |>\nI fixed\
    \ it for negative numbers as well. Thanks for the heads up.\n<|/ c |>\n<| c |>\n\
    I guess it would be better to put a return statement after the last `if` statement,\
    \ instead of having `return fibfib(n-1)` inside the last `if` statement. It would\
    \ be much more readable.\n<|/ c |>\n<| a dscore=4 tags=fibonacci,algorithm,c++\
    \ |>\nYou can use a simple recursive method to solve this problem.\n<code>\nlong\
    \ fib(long n)\n{\n   if(n<0) return 0;\n   if(n==1) return 1;\n   return fib(n-1)\
    \ + fib(n-2);\n}\n</code>\n<|/ a |>\n<| c |>\nThat's not recursion, though.\n\
    <|/ c |>\n<| c |>\nThis is an infinite recursion\n<|/ c |>\n<| c |>\nIt's a recursive\
    \ solution.  It uses recursion to generate each of the Fibonacci numbers, which\
    \ is just an iterative solution to computing Fibonacci.\n<|/ c |>\n<| c |>\nNo,\
    \ it isn't. It's a recursive solution to a very specific fi", "{\n\tif (n <= 3)\
    \ return 0L;\n\treturn fibfib(n-2) + fibfib(n-1);\n}\n/*\nThe Fibonacci Sequence\
    \ is a sequence of numbers whose consecutive elements represent the sum of the\n\
    previous two consecutive elements. For example:\n    0, 1, 1, 2, 3, 5, 8, 13,\
    \ 21\n    \nA recursive implementation of Fibonacci sequence is shown as follows:\n\
    \    \n    def fib(n)\n\tif n == 0 then\n\t\treturn 1\n\telse\n\t\treturn fib(n-1)\
    \ + fib(n-2)\n\tend\n    \n    fib(0) = 0\n    fib(1) = 1\n    fib(2) = 1\n  \
    \  fib(n) = fib(n-1) + fib(n-2)\n    \n*/\nlong fib(long n) \n{\n\tif (n <= 3)\
    \ return 0L;\n\treturn fib(n-2) + fib(n-1);\n}\n/*\nThe Fibonacci Sequence is\
    \ a sequence of numbers whose consecutive elements represent the sum of the\n\
    previous two consecutive elements. For example:\n    0, 1, 1, 2, 3, 5, 8, 13,\
    \ 21\n    \nA recursive implementation of Fibonacci sequence is shown as follows:\n\
    \    \n    def fib(n)\n\tif n == 0 then\n\t\treturn 1\n\telse\n\t\treturn fib(n-1)\
    \ + fib(n-2)\n\tend\n    \n    fib(0) = 0\n    fib(1) = 1\n    fib(2) = 1\n  \
    \  fib(n) = fib(n-1) + fib(n-2)\n    \n*/\nlong fib_2(long n) \n{\n\tif (n <=\
    \ 3) return 0L;\n\treturn fib(n-2) + fib(n-1);\n}", "{\n    std.typecons.Long\
    \ result = std.math.bigint._new(n);\n    while (n > 0)\n    {\n        if (n &\
    \ 1)\n        {\n            result = std.typecons.Long._addOne(result);\n   \
    \     }\n        n = std.typecons.Long._mulHighHigh(n, 3);\n        result = std.typecons.Long._addOne(result);\n\
    \        result = std.typecons.Long._addOne(result);\n    }\n    return result;\n\
    }\n/*\nWrite a function to compute fibfib(n) using iteration instead of recursion.\n\
    \    >>> import std.math\n    >>> std.math.fibfib(1L)\n    0L\n    >>> std.math.fibfib(5L)\n\
    \    4L\n    >>> std.math.fibfib(8L)\n    24L\n    \nNote that you'll need an\
    \ explicit loop for this to work correctly.\n*/\nlong fibfibIteration(long n)\
    \ \n{\n    long result = n;\n    long fib = 0;\n    while (fib < n)\n    {\n \
    \       fib = fibfib(n);\n        result = std.typecons.Long._addOne(result);\n\
    \    }\n    return result;\n}", "{\n    int i, j;\n    long a = (int)Math.pow((double)n,\
    \ (double)2);\n    long fibfib1 = fibonacci(a);\n    long fibfib2 = fibonacci(a+1);\n\
    \    long fibfib3 = fibonacci(a+2);\n    long fibfib4 = fibonacci(a+3);\n    return\
    \ (fibfib1+fibfib2+fibfib3+fibfib4);\n}\n</code>\n<|/ a tags=algorithm,fibonacci,c#\
    \ |>\n<| c |>\nI see no reason for all the casting.\n<|/ c |>\n<| c |>\nI prefer\
    \ `long a = Math.Pow(n, 2);` than `int a = (int)Math.Pow(n, 2);`\n<|/ c |>\n<|\
    \ c |>\nWhy `long a = Math.Pow(n, 2);` rather than `int a = (int)Math.Pow(n, 2);`?\
    \ I see no reason for that.\n<|/ c |>\n<| c |>\n`Math.Pow` returns a double. `(int)Math.Pow(n,\
    \ 2)` is guaranteed to return a whole number, so that cast is safe.\n<|/ c |>\n\
    <| a |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;", "{\n\tlong fibfib;\n\tfibfib=1;\n\tfor (int i=2;i<=n;i++){\n\
    \t\tfibfib=fibfib+i;\n\t}\n\treturn fibfib;\n}\n/*\nThe FibFibSum sequence is\
    \ a sequence similar to the Fibbonacci sequnece that's defined as follows:\n \
    \   fibfibsum(0) == 0\n    fibfibsum(1) == 0\n    fibfibsum(2) == 1\n    fibfibsum(n)\
    \ == fibfibsum(n-1) + fibfibsum(n-2) + fibfibsum(n-3).\n    Please write a function\
    \ to efficiently compute the n-th element of the fibfibsum number sequence.\n\
    \    >>> fibfibsum(1L)\n    0L\n    >>> fibfibsum(5L)\n    4L\n    >>> fibfibsum(8L)\n\
    \    24L\n    \n*/\nlong fibfibsum(long n) \n{\n\tlong fibfibsum;\n\tfibfibsum=1;\n\
    \tfor (int i=2;i<=n;i++){\n\t\tfibfibsum=fibfibsum+i;\n\t}\n\treturn fibfibsum;\n\
    }\n/*\nThe Fibonacci number sequence is a sequence of numbers in the Fibonacci\
    \ sequnece that are defined as follows:\n    fib(1) = 0\n    fib(2) = 1\n    fib(n)\
    \ = fib(n-1) + fib(n-2) where 1 <= n <= 20\n    Please write a function to efficiently\
    \ compute the n-th element of the Fibonacci number sequence.\n    >>> fib(1L)\n\
    \    0L\n    >>> fib(2L)\n    1L\n    >>> fib(3L)\n    1L\n    >>> fib(4L)\n \
    \   2L\n    >>> fib(5L)\n    5L\n    >>> fib(6L)\n    8L\n    >>> fib(7L)\n  \
    \  13L\n    >>> fib(8L)\n    21L\n    >>> fib(9L)\n    34L\n    >>> fib(10L)\n\
    \    55L\n    >>> fib(11L)\n    89L\n    >>> fib(12L)\n    144L\n    >>> fib(13L)\n\
    \    233L\n    >>> fib(14L)\n    377L\n    >>> fib(15L)\n    610L\n    >>> fib(16L)\n\
    \    987L\n    >>> fib(17L)\n    1597L\n    >>> fib(18L)\n    2584L\n    >>> fib(19L)\n\
    \    4181L\n    >>> fib(20L)\n    6765L\n    \n    \n*/\nlong fib(long n) \n{\n\
    \tif (n", "{\n\tif (n == 0 || n == 1)\n\t\treturn 0;\n\tif (n % 2 == 0)\n\t\t\
    return fibfib(n-1) + fibfib(n-2);\n\telse\n\t\treturn fibfib(n-3)+fibfib(n-2);\n\
    }\n</cell>\n<cell>\n// now we make our own version that uses recursion\nlong fibfibrecur(long\
    \ n) \n{\n\tif (n == 0 || n == 1)\n\t\treturn 0;\n\tif (n % 2 == 0)\n\t\treturn\
    \ fibfibrecur(n-1) + fibfibrecur(n-2);\n\telse\n\t\treturn fibfibrecur(n-3)+fibfibrecur(n-2);\n\
    }\n</cell>\n<cell>\n// now we make our own version that uses memoization\nlong\
    \ fibfibmemo(long n) \n{\n\tif (n == 0 || n == 1)\n\t\treturn 0;\n\tif (memo[n]\
    \ != 0)\n\t\treturn memo[n];\n\tif (n % 2 == 0)\n\t\tmemo[n] = fibfibmemo(n-1)\
    \ + fibfibmemo(n-2);\n\telse\n\t\tmemo[n] = fibfibmemo(n-3)+fibfibmemo(n-2);\n\
    \treturn memo[n];\n}\n</cell>\n<text>\nProblem 7 - Triangle number", "{\n\tif\
    \ (n < 3L) {\n\t\treturn 0L;\n\t}\n\tlong n3 = 3L - n;\n\tlong n2 = n3 * 3;\n\t\
    long n1 = n2 * 3;\n\treturn n1 + n2 + n3;\n}\n*/\n</code>\n<|/ a tags=math,algorithm,language-agnostic\
    \ |>\n<| c |>\nThe Fibonacci sequence is basically `1, 1, 2, 3, 5, 8, 13`.\n<|/\
    \ c |>\n<| c |>\n: I don't think that is a Fibonacci sequence. http://en.wikipedia.org/wiki/Fibonacci_number\n\
    <|/ c |>\n<| c |>\n: Ah, now I get it.  I thought the Fibonacci number sequence\
    \ was `0, 1, 1, 2, 3, 5, 8`, not `1, 1, 2, 3, 5, 8`\n<|/ c |>\n<| c |>\n: Yes,\
    \ the Fibonacci number sequence is `0, 1, 1, 2, 3, 5, 8`. That's what happens\
    \ when you go down a row in a toy store, and see how much money you have, and\
    \ how many pennies you need.\n<|/ c |>\n<| c |>\nThe OP already has implemented\
    \ the Fibonacci function.  He's asking how to find _n_ the first Fibonacci number\
    \ after a certain input.\n<|/ c |>\n<| a dscore=4 tags=math,algorithm,language-agnostic\
    \ |>\nIt looks like the Fibonacci numbers are the sum of the two previous numbers.\
    \ So if you need the first Fibonacci number after a certain input (let's say x),\
    \ you can add the number two times:\n<code>\nfib(x + 1) + fib(x + 2)\n</code>\n\
    For a certain input x, fib(x + 1) will be the same as fib(x).\n<|/ a |>\n<| c\
    \ |>\nI believe that the OP is asking for _n_ first Fibonacci numbers.  With this\
    \ implementation, `fib(x + 1) + fib(x + 2)` will result in fib(x + 3).  He also\
    \ needs to implement the recursive formula to compute the Fibonacci sequence up\
    \ to _n_.  But I think it's clear what the OP is asking.\n<|/ c |>\n<| c |>\n\
    It may be obvious to you now, but it's easy to miss it.  It wasn't for me at the\
    \ time, and I got caught out by it when I wrote this answer, and had to think\
    \ about it for a while.  So thank you for pointing that out!\n<|/ c |>\n<| a tags=math,algorithm,language-",
  "{\n    std.assert(n > 0);\n    std.assert(std.isIntegral(n));\n    std.assert(n\
    \ > 0);\n    long f = 1;\n    for(long i = 3; i <= n; i++) \n        f = f + i;\n\
    \    return f;\n}\n/* \n    Write a function to compute the difference between\
    \ 2 given numbers \n    where the 2 numbers are given as unsigned integers.\n\
    \    \n    The function should only work for positive numbers.\n    The function\
    \ should also work for numbers equal to zero but return 0 as their difference.\n\
    \    The function should only work for unsigned integers.\n    \n    Examples:\n\
    \    >>> diff(1, 0)\n    1\n    >>> diff(10, 5)\n    5\n    >>> diff(10, 5)\n\
    \    5\n    >>> diff(10, 5)\n    5\n    >>> diff(-5, 0)\n    0\n    >>> diff(10,\
    \ 5)\n    10\n    \n*/", "{\n    long res = 0;\n    while(n>2) {\n        if(n%2\
    \ == 0) res=res+n; \n        n=n/2;\n    }\n    return res;\n}\n</code>\n<|/ a\
    \ dscore=0 tags=python,dynamic-programming |>\n<| c |>\nWhile this code may answer\
    \ the question, providing additional context regarding how and/or why it solves\
    \ the problem would improve the answer's long-term value.\n<|/ c |>\n<| a tags=python,dynamic-programming\
    \ |>\n<code>\ndef fib(n):\n    mem=[0]*n\n    mem[1]=0\n    mem[2]=1\n    for\
    \ i in range(3,n):\n        mem[i]=mem[i-1]+mem[i-2]+mem[i-3]\n    return mem[n]",
  "{\n    int fibfib[3] = {0,1,1};\n    long fibfibN = 0;\n    long fibfibN2 = 0;\n\
    \    long fibfibN3 = 0;\n    fibfibN2 = fibfibN - fibfib[0]; \n    fibfibN3 =\
    \ fibfibN2 - fibfib[1]; \n    for (int i = 1; i < 3; i++) {\n        fibfibN +=\
    \ fibfib[i]; \n        fibfib[i] = fibfibN; \n        fibfibN = fibfibN2;\n  \
    \      fibfibN2 = fibfibN3;\n        fibfibN3 = fibfibN;\n    }\n    return fibfibN;\n\
    }\n</cell>\n<cell>\n%kata T108_FibFib_Sum_Test", "{\n    long x,y;\n    if (n\
    \ == 0) \n    {\n        return 0;\n    }\n    if (n == 1)\n    {\n        return\
    \ 0;\n    }\n    if (n == 2)\n    {\n        return 1;\n    }\n    if (n % 2 ==\
    \ 0)\n    {\n        x = fibfib(n / 2);\n        return x + fibfib(n-x -1) + fibfib(n-x-2);\n\
    \    }\n    else\n    {\n        x = fibfib(n / 2);\n        y = fibfib(n-x -\
    \ 1);\n        return x + y;\n    }\n}\n/*\nThe nth Fibonacci number is the sum\
    \ of the nth smallest numbers. \nFor example, fibonacci(3) is 1, fibonacci(4)\
    \ is 1, fibonacci(5) is 2, fibonacci(6) \nis 3, and so on and so forth.\nThe Fibonacci\
    \ numbers are listed below:\n n  fibonacci(n) \n 0  0 \n 1  1 \n 2  1,1 \n 3 \
    \ 2,1 \n 4  3,2 \n 5  4,3 \n 6  5,5 \n 7  6,8 \n 8  7,13 \n 9  8,21 \n 10  9,34\
    \ \n 11  10,55 \n 12  11,89 \n 13  12,144 \n 14  13,287 \n 15  14,551 \n 16  15,986\
    \ \n 17  16,251 \n 18  17,504 \n 19  18,822 \n 20  19,137 \n 21  20,218 \n 22\
    \  21,431 \n 23  22,645 \n 24  23,988 \n 25  24,254 \n 26  25,583 \n 27  26,911\
    \ \n 28  27,145 \n 29  28,278 \n 30  29,510 \n 31  30,740 \n 32  31,072 \n 33\
    \  32,196 \n 34  33,432 \n 35  34,674 \n 36  35,108 \n 37  36,340 \n 38  37,678\
    \ \n 39  38,102 \n 40  39,344 \n 41  40,678 \n 42  41,104 \n 43  42,368 \n 44\
    \  43,699 \n 45  44,108 \n 46  45,340 \n 47  46,700 \n 48  47", "{\n    if (n<0)\
    \ return 0L;\n    if (n==0) return 0L;\n    if (n==1) return 1L;\n    return fibfib(n-1L)\
    \ + fibfib(n-2L) + fibfib(n-3L);\n}", "{\n    if (n == 0) \n        return 0;\n\
    \    if (n == 1) \n        return 1;\n    if (n == 2) \n        return 1;\n  \
    \  long mid = (long) (n / 2);\n    long left = fibfib(mid);\n    long right =\
    \ fibfib(mid - 1);\n    long sum = 0;\n    while (left < right) \n    {\n    \
    \    long midSum = left + right;\n        sum = sum + midSum;\n        left =\
    \ midSum;\n        right = midSum;\n    }\n    return sum;\n}\n</code>\nThe recursive\
    \ call is very slow but still efficient.\n<|/ a dscore=2 |>\n<| c |>\nThe Fibonacci\
    \ sequence is defined as the sequence of integers starting with two and ending\
    \ with 1. You don't need the sequence to start at zero and end at one, that's\
    \ just extra computation to produce the initial values.\n<|/ c |>\n<| c |>\nThanks\
    \ for the correction. I was looking at Wikipedia when I wrote this answer and\
    \ it seemed like it said the first two values were 0 and 1. I must have misread\
    \ that.\n<|/ c |>\n<| a |>\nThe other answers are good, but here's a recursive\
    \ version that runs faster than the iterative one on small numbers, and even faster\
    \ than the recursive one on large numbers:\n<code>\ndef fib_rec(n):\n    if n\
    \ == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib_rec(n\
    \ - 2) + fib_rec(n - 1)\n</code>\nAnd here's a non-recursive version that runs\
    \ faster than the iterative one on small numbers, and even faster than the recursive\
    \ one on large numbers:\n<code>\ndef fib_iter(n):\n    prev, curr, next = 0, 1,\
    \ 1\n    for i in range(n):\n        prev, curr, next = curr, prev + curr, curr\
    \ + next\n    return curr\n</code>\nThe non-recursive version can sometimes be\
    \ faster because it avoids computing the n-1 term twice, but this doesn't matter\
    \ much on small numbers:\n<code>\ndef fib_iter(n):\n    prev, curr, next = 0,\
    \ 1, 1\n    for i in range(n):\n        prev, curr, next = (prev + curr + next,\
    \ curr, curr + next)\n    return curr\n</code>\nAnd here's a version that runs\
    \ faster than the recursive one on small numbers, and even faster than the iterative\
    \ one on large numbers:\n<code>\ndef fib_iter(n):\n    if n < 0:\n        prev\
    \ = -(-n) # n is negative\n    else:\n        prev = 0\n    prev, curr, next =\
    \ (0, 0, 1)\n    for i in range(n):\n        prev, curr, next = (curr + next,\
    \ curr, prev + curr", "{\n\tif (n<0) return -fibfib(-n);\n\tif (n==1 || n==2)\
    \ return 1L;\n\treturn fibfib(n-1L) + fibfib(n-2L);\n}", "{\n\tif (n <= 1L) return\
    \ 0L;\n\treturn fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n}\n    ", "{\n  \
    \  long curr = 1;\n    long prev = 0;\n    long next = 1;\n    while (n != 0)\
    \ {\n        curr = (curr * next) + prev;\n        prev = next;\n        next\
    \ = curr;\n        n--;\n    }\n    return curr;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=c++,fibonacci,algorithm dscore=0 |>\n<code>\n/* A function to calculate\
    \ sum of even fibonacci numbers up to given limit */", "{\n    long fibfibs[]\
    \ = { 0, 1, 1 };\n    for (int i = 0; i < n; i++) fibfibs[i] = fibfibs[i-1] +\
    \ fibfibs[i-2] + fibfibs[i-3];\n    return fibfibs[n];\n}\n/*\nWrite a function,\
    \ fibfib_sum, that takes a number n and returns its sum modulo n.\nIf n is 0,\
    \ fibfib_sum returns 0.\nIf n is greater than the length of the fibfib sequence\
    \ then fibfib_sum raises an exception.\nPlease write a function to efficiently\
    \ compute the sum of the n-th element of the fibfib number sequence.\n>>> fibfib_sum(1L)\n\
    0L\n>>> fibfib_sum(5L)\n4L\n>>> fibfib_sum(8L)\n24L\n>>> fibfib_sum(1000L)\n0L\n\
    >>> fibfib_sum(1000L)\n0L\n*/\nlong fibfib_sum(long n) \n{\n    return n % 2 ==\
    \ 0 ? n : fibfib(n+1) + fibfib_sum(n-1);\n}", "{\n    return fibfib1(n) + fibfib2(n);\n\
    }", "{\n\tlong fibfib1 = 0L;\n\tlong fibfib2 = 1L;\n\tlong fibfib3 = 2L;\n\tlong\
    \ fibfib4 = 3L;\n\tlong fibfib5 = 4L;\n\tlong fibfib6 = 5L;\n\tlong fibfib7 =\
    \ 6L;\n\tlong fibfib8 = 7L;\n\tlong fibfib9 = 8L;\n\tlong fibfib10 = 9L;\n\tlong\
    \ fibfib11 = 10L;\n\tlong fibfib12 = 11L;\n\tlong fibfib13 = 12L;\n\tlong fibfib14\
    \ = 13L;\n\tlong fibfib15 = 14L;\n\tlong fibfib16 = 15L;\n\tlong fibfib17 = 16L;\n\
    \tlong fibfib18 = 17L;\n\tlong fibfib19 = 18L;\n\tlong fibfib20 = 19L;\n\tlong\
    \ fibfib21 = 20L;\n\tlong fibfib22 = 21L;\n\tlong fibfib23 = 22L;\n\tlong fibfib24\
    \ = 23L;\n\tlong fibfib25 = 24L;\n\tlong fibfib26 = 25L;\n\tlong fibfib27 = 26L;\n\
    \tlong fibfib28 = 27L;\n\tlong fibfib29 = 28L;\n\tlong fibfib30 = 29L;\n\tlong\
    \ fibfib31 = 30L;\n\tlong fibfib32 = 31L;\n\tlong fibfib33 = 32L;\n\tlong fibfib34\
    \ = 33L;\n\tlong fibfib35 = 34L;\n\tlong fibfib36 = 35L;\n\tlong fibfib37 = 36L;\n\
    \tlong fibfib38 = 37L;\n\tlong fibfib39 = 38L;\n\tlong fibfib40 = 39L;\n\tlong\
    \ fibfib41 = 40L;\n\tlong fibfib42 = 41L;\n\tlong fibfib43 = 42L;\n\tlong fibfib44\
    \ = 43L;\n\tlong fibfib45 = 44L;\n\tlong fibfib46 = 45L;\n\tlong fibfib47 = 46L;\n\
    \tlong fibfib48 = 47L;\n\tlong fibfib49 = 48L;\n\tlong fibfib50 = 49L;\n\tlong\
    \ fibfib51 = 50L;\n\tlong fibfib52 = 51L;\n\tlong fibfib53 = 52L;\n", "{\n   \
    \ long fibfib[N] = { 0, 1, 0 };\n    \n    while(n > 2)\n    {\n        fibfib[n]\
    \ = fibfib[n-2] + fibfib[n-3];\n        n = n-1;\n    }\n    \n    return fibfib[n];\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=dynamic-programming,algorithm |>\n<code>\n\
    public long fib(int n)\n{\n    if (n == 0) return 0;\n    if (n == 1) return 1;\n\
    \    if (n >= 2) return fib(n-1) + fib(n-2);\n    return -1; // not reachable\
    \ - will cause stack overflow\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n-1 for\
    \ giving incomplete code without any explanation\n<|/ c |>\n<| c |>\nThis code\
    \ will cause an infinite recursion with negative n.\n<|/ c |>\n<| c |>\nThe point\
    \ is, you don't need to use a recursive function.\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>\n#include<iostream>\nusing namespace std;", "{\n    if (n<=0)\n       \
    \ return 0;\n    if (n==1L)\n        return 0;\n    if (n==2L)\n        return\
    \ 1;\n    long a=fibfib(n-1L);\n    long b=fibfib(n-2L);\n    return (a+b+b);\
    \ \n}\n</code>\n<|/ a tags=numbers,c++,fibonacci dscore=0 |>\n<| c |>\nYeah, that's\
    \ a really nice solution. I've been trying to think of a way to do it with a loop,\
    \ but I haven't been able to figure it out. I'm a bit of a noob, so I'm really\
    \ happy to learn this!\n<|/ c |>\n<| c |>\nThank you for adding the commentary.\
    \ I'm going to read it now!\n<|/ c |>\n<| c |>\nI've been able to implement this\
    \ into a loop, but I still cannot figure out how to print the result correctly.\
    \ For example, when I input \"5\", it prints out \"1\" and \"2\" and \"10\" instead\
    \ of printing out \"4\". I'm going to add the code I wrote to my original post.\n\
    <|/ c |>\n<| a tags=numbers,c++,fibonacci |>\nHere is an implementation based\
    \ on recursion and dynamic programming. Note that it calculates fibfib in O(log\
    \ n) time and uses O(n) memory.\n<code>\n#include <algorithm>\n#include <cstdint>\n\
    #include <iostream>", "{\n    long fib;\n    long next1;\n    long next2;\n  \
    \  long next3;\n    if (n==0)\n    {\n        return 0;\n    }\n    else\n   \
    \ {\n        fib=fibfib(n-1);\n        next1=fibfib(n-2);\n        next2=fibfib(n-3);\n\
    \        next3=fibfib(n-4);\n        return (fib+next1+next2+next3);\n    }\n}",
  "{\n\tlong fib_n = 0;\n\tlong i;\n\t\n\tfor (i = 0; i < n; i++) {\n\t\tfib_n = fib_n\
    \ + std.math.comb(i, 2) + std.math.comb(i, 3);\n\t}\n\t\n\treturn fib_n;\n}\n\
    </code>\n<|/ a |>\n<| a tags=stl,c++,algorithm,fibonacci |>\n<code>\n// Recursive\
    \ solution to find fibonacci sequence up to n\n#include <iostream>\nusing namespace\
    \ std;", "{\n    long a,b,c;\n    a=0;\n    b=1;\n    c=2;\n    while(n>0)\n \
    \   {\n     if(n>1)\n     {\n        c += a;\n        n-=1;\n     }\n     else\n\
    \     {\n        c = a;\n        a=b;\n        b+=c;\n     }\n    }\n    return\
    \ c;\n}\n</code>\n<|/ a tags=c,fibonacci |>\n<| a tags=c,fibonacci |>\nAs suggested\
    \ by others, I wrote an iterative solution that is basically the same as the iterative\
    \ solutions in the other answers. I did it for fun though and thought to myself\
    \ why not make use of recursion. Here's the code:\n<code>\n#include <stdio.h>",
  "{\n    long i, j, sum, a;\n    sum = 0;\n    a = 1;\n    for (i = 2; i <= n; i++){\n\
    \        j = a;\n        a = a + i;\n        sum = sum + j;\n    }\n    return\
    \ sum;\n}", "{\n    if(n==0)\n    {\n        return 0;\n    }\n    else if(n==1)\n\
    \    {\n        return 1;\n    }\n    else if(n<0)\n    {\n        return fibfib(n+1)\
    \ * -1;\n    }\n    else if(n==2L)\n    {\n        return 1;\n    }\n    else\n\
    \    {\n        long m=0, a=0, b=0, c=0;\n        for(m=2;m<n;m++)\n        {\n\
    \            a=b; \n            b=c; \n            c=a+b;\n        }\n       \
    \ return c;\n    }\n}\n/* \nThe fibonacci sequence is defined as follows:\n  \
    \  fibseq(0) == 0\n    fibseq(1) == 0\n    fibseq(n) == fibseq(n-1) + fibseq(n-2)\
    \ \n    Please write a function to efficiently compute the n-th element of the\
    \ fibonacci sequence.\n    >>> fibseq(2L)\n    1L\n    >>> fibseq(3L)\n    2L\n\
    \    >>> fibseq(4L)\n    3L\n    \n*/\nlong fibseq(long n) \n{\n    if(n==0)\n\
    \    {\n        return 0;\n    }\n    else if(n==1)\n    {\n        return 1;\n\
    \    }\n    else if(n<0)\n    {\n        return fibseq(n+1) * -1;\n    }\n   \
    \ else if(n==2L)\n    {\n        return 1;\n    }\n    else\n    {\n        return\
    \ fibseq(n-2) + fibseq(n-1);\n    }\n}\n/*\nThe Fibonacci sequence is a sequence\
    \ of numbers, starting with 0,\nthat form the basis of a fibonacci function and\
    \ form the series\nfib(0) = 0 and fib(1) and fib(2).\nThe Fibonacci sequence is\
    \ a sequence of numbers, starting with 1,\nthat form the basis of a fibonacci\
    \ function and form the series\nfib(1) = 1 and fib(2) and fib(3).\nThe Fibonacci\
    \ sequence is a sequence of numbers, starting with 2,\nthat form the basis of\
    \ a fibonacci function and form the series\nfib(2) = fib(1) + fib(2).\nThe Fibonacci\
    \ sequence is a sequence of numbers, starting with 3,\nthat form the basis of\
    \ a fibonacci function and form the series\nfib(3) = fib(2) + fib(3).\nThe Fibonacci\
    \ sequence is a sequence of numbers, starting with 4,\nthat form the basis of\
    \ a fibonacci function and form the series\nfib(4) = fib(3) + fib(4).\nThe Fibon",
  "{\n    long fibfib = 0;\n    if (n<0) return -1L;\n    fibfib += fibfib(n-1);\n\
    \    fibfib += fibfib(n-2);\n    fibfib += fibfib(n-3);\n    return fibfib;\n\
    }\n\"\"\"\n\"\"\"\nExample of using the Python scripting interface:\n>>> import\
    \ PythonInterpreter as P\n>>> P.resetInterpreter()\n>>> import std.typecons;\n\
    >>> import std.math;\n>>> P.setVariable(\"fibfib\", std.math.fibfib);\n>>> P.setVariable(\"\
    fibonacci\", std.math.fibonacci);\n>>> P.setVariable(\"fibfib\", std.math.fibfib);\n\
    >>> P.setVariable(\"fibfib\", std.math.fibfib);\n>>> P.setVariable(\"fibfib\"\
    , std.math.fibfib);\n>>> P.setVariable(\"fibfib\", std.math.fibfib);\n>>> P.setVariable(\"\
    fibonacci\", std.math.fibonacci);\n>>> P.setVariable(\"fibonacci\", std.math.fibonacci);\n\
    >>> P.setVariable(\"fibonacci\", std.math.fibonacci);\n>>> P.setVariable(\"fibonacci\"\
    , std.math.fibonacci);\n>>> P.setVariable(\"fibonacci\", std.math.fibonacci);\n\
    >>> P.setVariable(\"fibonacci\", std.math.fibonacci);\n>>> P.setVariable(\"fibonacci\"\
    , std.math.fibonacci);\n>>> P.setVariable(\"fibonacci\", std.math.fibonacci);\n\
    >>> P.setVariable(\"fibonacci\", std.math.fibonacci);\n>>> P.setVariable(\"fibonacci\"\
    , std.math.fibonacci);\n>>> P.setVariable(\"fibonacci\", std.math.fibonacci);\n\
    >>> P.setVariable(\"fibonacci\", std.math.fibonacci);\n>>> P.setVariable(\"fibonacci\"\
    , std.math.fibonacci);\n>>> P.setVariable(\"fibonacci\", std.math.fibonacci);\n\
    >>> P.setVariable(\"fibonacci\", std.math.fibonacci);\n>>> P.setVariable(\"fibonacci\"\
    , std.math.fibonacci);\n>>> P.setVariable(\"fibonacci\", std.math.fibonacci);\n\
    >>> ", "{\n    if (n < 0) return 0;\n    if (n == 0) return 0;\n    if (n == 1)\
    \ return 1;\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nThe below function returns the Fibonacci sequence\
    \ for a given number. It also returns it as an array for easy access and manipulation:\n\
    <code>\npublic class Fibonacci {\n    public static int[] fib(int n)\n    {\n\
    \        int[] fib_array = new int[n];\n        fib_array[0] = 0; fib_array[1]\
    \ = 1;\n        for(int i = 2; i < n; i++)\n        {\n            fib_array[i]\
    \ = fib_array[i - 1] + fib_array[i - 2];\n        }\n        return fib_array;\n\
    \    }", "{\n    long total = 0;\n    long cur;\n    for (cur = 1L; cur <= n;\
    \ cur++) {\n        total = total + cur;\n    }\n    return total;\n}", "{\n \
    \   // write your code in C# here\n    long fibfib = 0;\n    \n    if(n >= 1){\n\
    \        fibfib = fibfib + fibfib(n-1) + fibfib(n-2);\n    }\n    \n    return\
    \ fibfib;\n}\n\"\"\"\n</cell>\n<cell>\n# Run this cell to submit your work. Please\
    \ do not change it.", "{\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }\nlong fibfib1()\n{\n    return 0L;\n}", "{\n  long prevFibFib = 0;\n  long nextFibFib\
    \ = 1;\n  long counter = 1;\n  while (counter <= n) {\n    prevFibFib = prevFibFib\
    \ + nextFibFib;\n    nextFibFib = nextFibFib + nextFibFib;\n    counter = counter\
    \ + 1;\n  }\n  return prevFibFib;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nI think this should do, too:\n<code>\nlong fib(int n)\n{\n  return n < 2\
    \ ? 1 : fib(n-1) + fib(n-2);\n}\n</code>\n<|/ a tags=recursion,algorithm,java,fibonacci,c\
    \ |>\n<| a tags=recursion,algorithm,java,fibonacci,c dscore=1 |>\n<code>\nimport\
    \ java.util.Scanner;\nimport java.math.BigInteger;", "{\n    return std.typecons.powLongLong(n,\
    \ std.math.powLongLong(std.math.powLongLong(n, 3), 2));\n}", "{\n    if (n <=\
    \ 1L) {\n        return 0L;\n    } else if (n <= 3L) {\n        return 1L;\n \
    \   } else if (n <= 5L) {\n        return 2L;\n    } else {\n        return fibfib(n-1L)\
    \ + fibfib(n-2L) + fibfib(n-3L);\n    }\n}\n</code>\n<|/ a dscore=0 tags=language-agnostic,recursion,fibonacci,algorithm,big-o\
    \ |>\n<| a |>\nThe Fibonacci sequence is often used in various programming languages.\
    \ Here is a recursive implementation in Java:\n<code>\nlong fib(int n) {\n   \
    \ if (n <= 0)\n        throw new IllegalArgumentException(\"n must be positive\"\
    );\n    if (n <= 1)\n        return 0;\n    return fib(n-1) + fib(n-2);\n}\n</code>\n\
    Here are the recurrence relations:\n<code>\nfib(0) == 0\nfib(1) == 0\nfib(n) =\
    \ fib(n-1) + fib(n-2) \u2261 fib(n-2)+fib(n-1)\nfib(n) = fib(n-1) + fib(n-2) +\
    \ fib(n-3) + fib(n-4) \u2261 fib(n-3)+fib(n-4)+fib(n-2)\nfib(n) = fib(n-1) + fib(n-2)\
    \ + fib(n-3) + fib(n-4) + fib(n-5) \u2261 fib(n-4)+fib(n-5)+fib(n-3)+fib(n-2)\n\
    fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) \u2261\
    \ fib(n-5)+fib(n-6)+fib(n-4)+fib(n-3)+fib(n-2)\nfib(n) = fib(n-1) + fib(n-2) +\
    \ fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6) + fib(n-7) \u2261 fib(n-6)+fib(n-7)+fib(n-5)+fib(n-4)+fib(n-3)+fib(n-2)\n\
    ...\nfib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + fib(n-5) + fib(n-6)\
    \ + fib(n-7) + fib(n-8) + fib(n-9) \u2261 fib(n-9)+fib(n-8)+fib(n-7)+fib(n-6)+fib(n-5)+fib(n-4)+fib(n-3)+fib(n-2)\n\
    fib(n) = fib(n-1) + fib(n-2) + fib(n-3) + fib(n-4) + ", "{\n\tlong i, fib = 0;\n\
    \tif (n <= 0) return 0L;\n\telse {\n\t\tfib = 1L;\n\t\tfor (i = 2L; i <= n; i++)\n\
    \t\t\tfib = fib + (fibfib(i) - fibfib(i-2L));\n\t\treturn fib;\n\t}\n}\n////////////////////////////////////////////////////////////////////////////////\n\
    ////////////////////////////////////////////////////////////////////////////////\n\
    ////////////////////////////////////////////////////////////////////////////////",
  "{\n    long i, f0 = 1L, f1 = 1L;\n    for (i = 2; i <= n; i++)\n    {\n       \
    \ f0 = f0 + f1;\n        f1 = f0 + 1;\n    }\n    return f0;\n}", "{\n    return\
    \ std.fibfib(n);\n}", "{\n    long f = 1;\n    long f = 1;\n    long p = 1;\n\
    \    long fibfib_num = n;\n    long fibfib;\n    long fibfib_num2 = fibfib_num;\n\
    \    long fibfib_num3 = fibfib_num;\n    long fibfib_num4 = fibfib_num;\n    \n\
    \    while (fibfib_num >= 4) \n    {\n        fibfib += (fibfib_num3 - fibfib_num2);\n\
    \        fibfib_num3 = fibfib_num2;\n        fibfib_num2 = fibfib_num;\n     \
    \   fibfib_num1 = fibfib;\n        fibfib = 0;\n        fibfib_num = fibfib_num1;\n\
    \        \n    }\n    \n    while (fibfib_num >= 2) \n    {\n        fibfib +=\
    \ (fibfib_num3 - fibfib_num2);\n        fibfib_num3 = fibfib_num2;\n        fibfib_num2\
    \ = fibfib_num;\n        fibfib = 0;\n        fibfib_num = fibfib_num1;\n    \
    \    \n    }\n    \n    fibfib += (fibfib_num3 - fibfib_num2);\n    \n    while\
    \ (fibfib_num >= 1) \n    {\n        fibfib += (fibfib_num3 - fibfib_num2);\n\
    \        fibfib_num3 = fibfib_num2;\n        fibfib_num2 = fibfib_num;\n     \
    \   fibfib = 0;\n        fibfib_num = fibfib_num1;\n        \n    }\n    \n  \
    \  return fibfib;\n}\n</code>\n<|/ a tags=performance,fibonacci,c++ |>\n<| c |>\n\
    How is this answer different from mine? The only difference is you did it in assembly\
    \ language while mine is in C/C++. Are there any other differences besides that?\n\
    <|/ c |>\n<| c |>\nOh, it appears I didn't notice that you wrote it in assembly\
    \ language since your answer was already accepted while I wrote it in C/C++. My\
    \ apologies. I'll edit my answer to reflect this.\n<|/ c |>\n<| c |>\nThanks Amadeus.\
    \ It's very cool to see this assembly version too, but you didn't even use any\
    \ registers or anything. I think this could be faster, especially with smaller\
    \ values of `fibfib_num` as it avoids redoing all those assignments over and over.\
    \ I would benchmark it for larger inputs to see if it's faster though.", "{\n\
    \  if (n <= 1) \n    return 0L;\n  return fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nNice answer. I like this solution a lot as it uses\
    \ recursion just like yours, but it only works in C/C++. The problem is you can't\
    \ do tail-recursion optimization in any language since most languages don't support\
    \ it. Your solution has this property: fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\
    \ will only be computed if n is less than 3, so the recursion will end up being\
    \ O(log n) instead of O(n).\n<|/ c |>\n<| c |>\nThanks. I thought this was obvious\
    \ since the question asked for a C/C++ solution. Thanks for noting the tail recursion\
    \ optimization point.\n<|/ c |>\n<| c |>\nYour algorithm will never terminate\
    \ for n=0, 1 since fibfib(n-1) is always 0.\n<|/ c |>\n<| c |>\nOh, wow. I didn't\
    \ even realize that. I thought it was obvious that you couldn't get fibfib(0)==0\
    \ by just adding 0 to the fibonacci numbers.\n<|/ c |>\n<| a |>\nHere is my answer.\
    \ Just in case anyone is looking for an iterative implementation. \n<code>\n#include\
    \ <iostream>\nusing namespace std;", "{\n    if (n==0L || n==1L)\n        return\
    \ n==0L ? 0L : n==1L ? 1L : fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n    long\
    \ res = 0L;\n    long tn = fibfib(n-1L);\n    long tw = fibfib(n-2L);\n    long\
    \ th = fibfib(n-3L);\n    long tf = fibfib(n-2L);\n    long tl = fibfib(n-3L);\n\
    \    long ft = fibfib(n-1L);\n    \n    for (long i = 4L; i < n; i+=3L) \n   \
    \ {\n        long tt = fibfib(tn); \n        long tw = fibfib(tw); \n        long\
    \ th = fibfib(th);\n        long tf = fibfib(tf);\n        long tl = fibfib(tl);\n\
    \        long ft = fibfib(ft);", "{\n    return std.math.fib(n);\n}\n/*\nWrite\
    \ an efficient function to compute the n-th element of the Fibonacci number sequence.\n\
    The Fibonacci number sequence is defined by the recurrence relation:\nfib(0) ==\
    \ 0\nfib(1) == 0\nfib(2) == 1\nfib(3) == 1\n...\nfib(n) = 1(n - 1) + 2(n - 2)\
    \ + 3(n - 3) + ...\nThe iterative version is straightforward:\nlong fib(int n)\n\
    {\n    if (n <= 1) return n;\n    long n1 = fib(n-1);\n    long n2 = fib(n-2);\n\
    \    return std.math.fib(n1) + std.math.fib(n2) + std.math.fib(n-3);\n}\nPlease\
    \ write a function to efficiently compute the n-th element of the fib number sequence.\n\
    */\nlong fib(long n) \n{\n    return std.math.fib(n);\n}", "{\n    if(n == 0)\
    \ \n        return 0;\n    if(n == 1) \n        return 1;\n    return fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3);\n}", "{\n    long fibfib = 1;\n    long fibfib2\
    \ = 1;\n    long fibfib3 = 1;\n    long fibfib4 = 0;\n    long fibfib5 = 0;\n\
    \    long fibfib6 = 1;\n    long fibfib7 = 1;\n    long fibfib8 = 1;\n    \n \
    \   long fibfib9 = 1;\n    long fibfib10 = 1;\n    long fibfib11 = 1;\n    long\
    \ fibfib12 = 1;\n    long fibfib13 = 1;\n    long fibfib14 = 1;\n    long fibfib15\
    \ = 1;\n    long fibfib16 = 1;\n    long fibfib17 = 1;\n    \n    long fibfib18\
    \ = 1;\n    long fibfib19 = 1;\n    long fibfib20 = 1;\n    long fibfib21 = 1;\n\
    \    long fibfib22 = 1;\n    long fibfib23 = 1;\n    long fibfib24 = 1;\n    long\
    \ fibfib25 = 1;\n    long fibfib26 = 1;\n    long fibfib27 = 1;\n    \n    long\
    \ fibfib28 = 1;\n    long fibfib29 = 1;\n    long fibfib30 = 1;\n    long fibfib31\
    \ = 1;\n    long fibfib32 = 1;\n    long fibfib33 = 1;\n    long fibfib34 = 1;\n\
    \    long fibfib35 = 1;\n    long fibfib36 = 1;\n    \n    long fibfib37 = 1;\n\
    \    long fibfib38 = 1;\n    long fibfib39 = 1;\n    long fibfib40 = 1;\n    long\
    \ fibfib41 = 1;\n    long fibfib42 = 1;\n    long fibfib43 = 1;\n    long fibfib44\
    \ = 1;\n    long fibfib45 = 1;\n    long fibfib46 = 1;\n    \n    long fibfib47\
    \ = 1;\n    long fibfib48 = 1;\n    long fibfib49 = 1;\n    long fibfib50 = 1;\n\
    \    long fibfib51 = 1;\n    long fibfib52 = 1;\n    long fibfib53 = 1;\n    long\
    \ fibfib54 = 1;\n    long fibfib55 = 1;\n    long fibfib56 = 1;\n    \n    long\
    \ fibfib57 = 1;\n    long fibfib58 = 1;\n    long fibfib59 = 1;\n    long fibfib60\
    \ = 1;\n    long fibfib61 = 1;\n    long fibfib62 = 1;\n    long fibfib63 = 1;\n\
    \    long fibfib64 = 1;\n    long fibfib65 = 1;\n    long fibfib66 = 1;\n    \n\
    \    long fibfib67 = 1;\n    long fibfib68 = 1;\n    long fibfib69 = 1;\n    long\
    \ fibfib70 = 1;\n    long fibfib7", "{\n    if (n <= 3) {\n        return n;\n\
    \    }\n    return fibfib(n-2) + fibfib(n-3) + fibfib(n-1);\n}", "{\n    if(n<1)\
    \ return 0L;\n    if(n<2L) return 1L;\n    if(n==2L) return 1L;\n    else return\
    \ fibfib(n-2L) + fibfib(n-1L);\n}\n*/", "{\n    long long fibfib = (n <= 3) ?\
    \ 0L : (n - 1) * (n - 2L) + fibfib;\n    return fibfib;\n}\n</code>\n<|/ a |>\n\
    <| a tags=fibonacci,recursion dscore=2 |>\nA simple recursive solution\n<code>\n\
    function fib(n) {\n  if (n === 0) {\n    return 0;\n  }\n  if (n === 1) {\n  \
    \  return 1;\n  }\n  return fib(n - 2) + fib(n - 1);\n}\n</code>\n<|/ a |>\n<|\
    \ a dscore=2 |>\nFor those of us who don't understand memoization (or functional\
    \ programming), it turns out that an algorithm like this isn't too bad. The important\
    \ thing is to keep track of previous numbers and the fact that you can \"remember\"\
    \ the previous values of a given number. Since Fibonacci is strictly additive,\
    \ the remembered values of a given number are also the previous values of that\
    \ number. In other words, if you multiply the last 2 numbers together, you can\
    \ get the value directly if you have already computed the previous two numbers.\n\
    <code>\nclass FibFib {\n  private int prev1, prev2;\n  public FibFib(int n)\n\
    \  {\n    prev1 = prev2 = n;\n  }\n  public int fibonacci()\n  {\n    if (n ==\
    \ 0)\n    {\n      return 0;\n    }\n    if (n == 1)\n    {\n      return 1;\n\
    \    }\n    return prev1 * prev2 + fibonacci(n - 2) + fibonacci(n - 1);\n  }\n\
    }\n</code>\n<|/ a tags=fibonacci,recursion |>\n<| a dscore=1 |>\n<code>\n public\
    \ int fibonacci(int n)\n {\n  if (n == 0)\n  {\n   return 0;\n  }\n  if (n ==\
    \ 1)\n  {\n   return 1;\n  }\n  return fibonacci(n - 2) + fibonacci(n - 1);\n\
    \ }\n</code>\n<|/ a tags=fibonacci,recursion |>\n<| a dscore=0 |>\n<code>\n//\
    \ A recursive method to calculate fibonacci number\npublic int fib(int n)\n{\n\
    \    if (n == 0)\n    {\n        return 0;\n    }\n    if (n == 1)\n    {\n  \
    \      return 1;\n    }", "{\n    if (n <= 1L) return 0L;\n    long sum = 0L;\n\
    \    long num = 1;\n    long count = 1;\n    while(num < n)\n    {\n        num\
    \ = num + count;\n        count = count + 1;\n        sum = sum + num;\n    }\n\
    \    return sum;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for the solution.\
    \ But I am not looking for any other solutions. I am looking for a way to achieve\
    \ this in O(n) time.\n<|/ c |>\n<| c |>\nSorry, didn't see the O(n) part.\n<|/\
    \ c |>\n<| a tags=big-o,c++,time-complexity,algorithm dscore=0 |>\nIn O(n) time,\
    \ we can use a lookup table to store the fibonacci sequence upto n elements and\
    \ we can solve it in O(n) time like shown below:\n<code>", "{\n    if(n <= 3){\n\
    \        return 0;\n    }\n    if(n <= 5L){\n        return 1;\n    }\n    return\
    \ fibfib(n-2) + fibfib(n-3) + fibfib(n-4);\n}\n/* This function is the recursive\
    \ version of the fibbonaci sequence */\nlong fibfib_rec(long n)\n{\n    if(n <=\
    \ 4){\n        return 0;\n    }\n    if(n <= 3){\n        return 1;\n    }\n \
    \   return fibfib_rec(n-2) + fibfib_rec(n-3) + fibfib_rec(n-4);\n}", "{\n    long\
    \ i;\n    if (n == 0L) {\n        return 0L;\n    }\n    else if (n == 1L) {\n\
    \        return 1L;\n    }\n    else if (n == 2L) {\n        return 1L;\n    }\n\
    \    else {\n        i = fibfib(n-1L);\n        return (i+fibfib(n-2L)+fibfib(n-3L));\n\
    \    }\n}\n#endif\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nIt is not very\
    \ efficient but it works.\n<code>", "{\n\tif (n == 0)\n\t\treturn 0;\n\tif (n\
    \ == 1)\n\t\treturn 0;\n\treturn fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}",
  "{\n\tif (n < 3L)\n\t\treturn 0L;\n\t\n\treturn fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n\
    }", "{\n    if (n < 0) \n    {\n        return -fibfib(-n);\n    }\n    long fibfib[]\
    \ = { 0, 1L, 1L, 1L, 2L, 3L, 6L, 8L, 13L, 20L, 27L, 53L, 10L};\n    return fibfib[n];\n\
    }\n</code>\n<|/ a tags=optimization,fibonacci,performance |>\n<| a dscore=4 tags=optimization,fibonacci,performance\
    \ |>\nJust for the sake of it, here's my solution in Haskell:\n<code>\nfib = 0:1:zipWith\
    \ (+) fib (tail fib)\n</code>\n<|/ a |>\n<| c |>\nJust for reference, this is\
    \ slower than the accepted answer by more than 10x!\n<|/ c |>\n<| c |>\n: That's\
    \ true, my solution is slower than the accepted answer, but faster than the accepted\
    \ answer by more than 10x! :)\n<|/ c |>\n<| a tags=optimization,fibonacci,performance\
    \ |>\n<code>", "{\n\tif(n<0) \n\t\tstd.assert(0);\n\tlong fibo=1;\n\tlong fib=1;\n\
    \tlong fib2=2;\n\tlong fib3=3;\n\tlong fib4=5;\n\tlong fib6=8;\n\tlong fib7=13;\n\
    \tlong fib8=26;\n\tlong fib10=55;\n\tlong fib11=89;\n\tlong fib12=144;\n\tlong\
    \ fib13=287;\n\tlong fib14=595;\n\tlong fib15=1009;\n\tlong fib16=1771;\n\tlong\
    \ fib17=2865;\n\tlong fib18=5663;\n\tlong fib19=10250;\n\tlong fib20=17258;\n\t\
    long fib21=26513;\n\tlong fib22=59237;\n\tlong fib23=100873;\n\tlong fib24=177206;\n\
    \tlong fib25=286571;\n\tlong fib26=566215;\n\tlong fib27=1025080;\n\tlong fib28=1725876;\n\
    \tlong fib29=2651357;\n\tlong fib30=5923700;\n\tlong fib31=10087324;\n\tlong fib32=17720627;\n\
    \tlong fib33=28657141;\n\tlong fib34=56621536;\n\tlong fib35=102508035;\n\tlong\
    \ fib36=172587628;\n\tlong fib37=265135778;\n\tlong fib38=592370067;\n\tlong fib39=1008732471;\n\
    \tlong fib40=1772062737;\n\tlong fib41=2865714153;\n\tlong fib42=5662153663;\n\
    \tlong fib43=10250803527;\n\tlong fib44=17258762833;\n\tlong fib45=26513577873;\n\
    \tlong fib46=59237006779;\n\tlong fib47=10087324753;\n\tlong fib48=177206273779;\n\
    \tlong fib49=286571415373;\n\tlong fib50=566215366353;\n\tlong fib51=1025080352773;\n\
    \tlong fib52=1725876283376;\n\tlong fib53=2651357787376;", "{\n    long fibfib_seq[10]\
    \ = {0L};\n    if (n <= 1L) \n    {\n        fibfib_seq[0] = n; \n        return\
    \ fibfib_seq[0]; \n    }\n    fibfib_seq[1] = fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n\
    \    return fibfib_seq[n];\n}\n//////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////\n\
    //////////////////////////////////////////////////////////////////////////////",
  "{\n\tif (n == 0)\n\t\treturn 0L;\n\tif (n == 1)\n\t\treturn 1L;\n\treturn fibfib(n-1L)\
    \ + fibfib(n-2L) + fibfib(n-3L);\n}", "{\n    long f = 1;\n    long i;\n    for\
    \ (i = 2; i <= n; i++)\n    {\n        f = f * i;\n    }\n    return f;\n}", "{\n\
    long long a,b,c;\nc = (n%2L) * fibfib(n-1L);\na = fibfib(n-1L);\nb = fibfib(n-2L);\n\
    return a+b+c;\n}", "{\n    if(n<=1)\n        return 0;\n    long sum = 0;\n  \
    \  for(int i=0;i<n;i++)\n    {\n        sum += fibonacci(i);\n    }\n    return\
    \ sum;\n}\nlong fibonacci(long n) \n{\n    if(n==0)\n        return 0;\n    long\
    \ fibfib=0;\n    for(int i=0;i<=n;i++)\n    {\n        fibfib += ((1L<<(2*i))\
    \ - (1L<<i));\n    }\n    return fibfib;\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=fibonacci,performance,algorithm |>\nHere is my Python 3 code:\n<code>\n\
    import timeit\ndef fibfib(n):\n    a,b = 1,1\n    fibfib = 0\n    fibfib = 1\n\
    \    while fibfib < n:\n        fibfib += a\n        a,b = b, fibfib\n    return\
    \ fibfib\nprint(timeit.timeit('fibfib(n)', setup = 'from __main__ import fibfib,\
    \ n', number=1000))\n</code>\nOutput:\n<code>\n0.265744648955764\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\nAn even faster version, using the recursion\
    \ only:\n<code>", "{\n    return std.math.fibfib(n);\n}", "{\n\tif(n<0){\n\t\t\
    throw new Exception(\"fibfib: n must be positive.\");\n\t}\n\tlong x = 1L;\n\t\
    long y = 0L;\n\tlong z = 0L;\n\tfor(int i = 3; i <= n; i++){\n\t\tx += y;\n\t\t\
    y += z;\n\t\tz += x;\n\t}\n\treturn z;\n}\n/**\n * Project Euler #29\n * \n *\
    \ http://projecteuler.net/problem=29\n * \n * An irrational decimal fraction is\
    \ created by concatenating the positive integers:\n * 0.123456789101112131415161718192021...\n\
    \ * \n * The rational number represented by the concatenated fractions is 0.123456789101112131415161718192021.\n\
    \ * If dn represents the nth number in the above fraction, then:\n * \n * d0 =\
    \ 1\n * d5 = 10 * d0 + 9 * d1 + 8 * d2 + 7 * d3 + 6 * d4 + 5 * d5\n * d10 = 10\
    \ * d0 + 9 * d1 + 8 * d2 + 7 * d3 + 6 * d4 + 5 * d5 + 4 * d6 + 3 * d7 + 2 * d8\
    \ + 1 * d9 + 0 * d10\n * \n * It can be seen that d2/d10 is approximately equal\
    \ to 1158, and \n * therefore the nth term of the fraction is\n * \n * (d1 + d2\
    \ + d3 + d4 + d5 + d6 + d7 + d8 + d9 + d10) * (1 / 1158)\n * \n * Assuming that\
    \ d0 = 1 and d5 = 10 * d0 + 9 * d1 + 8 * d2 + 7 * d3 + 6 * d4 + 5 * d5, \n * it\
    \ can be shown that d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9 + d10 = (d10 - 1) /\
    \ 1158 = d2.\n * \n * Find the value of n where the fraction repeats exactly when\
    \ expressed in decimal.\n * \n * NOTE: This question is the same as Project Euler\
    \ #1, and is also the same as the previous problem. \n * \n * \n */\nimport java.io.File;\n\
    import java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\n\
    import java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\n\
    import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\
    import java.util.List;\nimport java.util.Scanner;", "{\n    long a = 0, b = 1,\
    \ c;\n    \n    for(c=0; c<n; c++)\n    {\n        c = a + b;\n        a = b;\n\
    \        b = c;\n    }\n    \n    return c;\n}\n/*\nThe Fibonacci sequence is\
    \ a sequence similar to that of the Fibbonacci sequence, but with one\nimportant\
    \ difference: the last two elements of the sequence are the same as those of the\
    \ previous\ntwo elements, and not two distinct elements, as they would be for\
    \ FibFib (fibfib(n)). In other words,\nthe Fibonacci sequence is defined as:\n\
    \    fibfib(0) == 0\n    fibfib(1) = 1\n    fibfib(n) = fibfib(n-1) + fibfib(n-2).\n\
    \    Please write a function to efficiently compute the n-th element of the Fibonacci\
    \ sequence.\n    >>> fib(1L)\n    0L\n    >>> fib(5L)\n    5L\n    >>> fib(8L)\n\
    \    13L\n    \n*/\nlong fib(long n) \n{\n    long a = 0, b = 1, c;\n    \n  \
    \  for(c=0; c<n; c++)\n    {\n        c = a + b;\n        a = b;\n        b =\
    \ c;\n    }\n    \n    return c;\n}\n/*\nThe Riemann zeta function f(x) is the\
    \ Riemann-Siegel\u2013Svensson function zeta function defined as follows:\n  \
    \  zeta(x) =\n      \\sum_{n = 0}^{\\infty} (-1)^n * zeta(x/n)\n      \\Gamma_n(2)\n\
    \    Please write a function to efficiently compute the Riemann zeta function\
    \ for the given argument.\n    >>> zeta_exact(0.5)  # exact calculation\n    0.250000000945459\n\
    \    >>> zeta(0.5)  # naive calculation\n    0.250000000945459\n    \n*/\ndouble\
    \ zeta_exact(double x) // exact calculation of zeta\n{\n    double sum = 0;\n\
    \    double numerator = 1;\n    double denominator = 1;", "{\n    long res;\n\
    \    if (n <= 1L)\n    {\n        res = 0L;\n    }\n    else\n    {\n        res\
    \ = fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n    }\n    return res;\n}\n/*\n\
    The FibFibPrime number sequence is a sequence similar to the Fibbonacci sequnece\
    \ that's defined as follows:\n    fibfibprime(0) == 1\n    fibfibprime(1) == 1\n\
    \    fibfibprime(2) == 2\n    fibfibprime(n) == fibfibprime(n-1) + fibfibprime(n-2).\n\
    \    Please write a function to efficiently compute the n-th element of the fibfibprime\
    \ number sequence.\n    >>> fibfibprime(1L)\n    1L\n    >>> fibfibprime(5L)\n\
    \    10L\n    >>> fibfibprime(8L)\n    34L\n*/\nlong fibfibprime(long n) \n{\n\
    \    long res;\n    if (n <= 1L)\n    {\n        res = 1L;\n    }\n    else\n\
    \    {\n        res = fibfibprime(n-1L) + fibfibprime(n-2L);\n    }\n    return\
    \ res;\n}\n/*\nThe CubicTofib number sequence is a sequence similar to the Fibonacci\
    \ sequnece that's defined as follows:\n    cubictofib(0) == 0\n    cubictofib(1)\
    \ == 0\n    cubictofib(2) == 1\n    cubictofib(n) == CubicTofib(n-1)*fibfib(n-2)\
    \ + CubicTofib(n-2)*fibfib(n-3) + CubicTofib(n-3)*fibfib(n-4)\n    Please write\
    \ a function to efficiently compute the n-th element of the cubictofib number\
    \ sequence.\n    >>> cubictofib(1L)\n    0L\n    >>> cubictofib(5L)\n    4L\n\
    \    >>> cubictofib(8L)\n    36L\n*/\nlong cubictofib(long n) \n{\n    long res;\n\
    \    if (n <= 1L)\n    {\n        res = 0L;\n    }\n    else\n    {\n        res\
    \ = cubictofib(n-1L) * (long)(fibfib(n-2L)) + cubictofib(n-2L) * (long)(fibfib(n-3L))\
    \ + cubictofib(n-3L) * (long)(fibfib(n-4L));\n    }\n    return res;\n}", "{\n\
    \    if(n==1){\n        return 0L;\n    }\n    if(n==2){\n        return 1L;\n\
    \    }\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}\n</cell>\n<text>\n\
    Exercise: Recursion and Tail Recursion\nYou will now see two ways to compute the\
    \ Fibonacci numbers using recursion. One is using a recursive function, while\
    \ the other is using a tail recursion. You will now use the fibbonacci function\
    \ to compute the first 50 Fibonacci numbers. Both can be done using tail recursion.",
  "{\n    if(n==0) return 0L;\n    if(n==1) return 1L;\n    return fibfib(n-1)+fibfib(n-2);\n\
    }", "{\n\tint i, k, temp;\n\tlong fibfib=1;\n\tlong result=0;\n\tfor(temp=n; temp>0;\
    \ temp--)\n\t{\n\t\tfibfib=fibfib*3+1;\n\t}\n\tfibfib=fibfib/3;\n\tfor(i=1; i<=n;\
    \ i++)\n\t{\n\t\tk=i;\n\t\twhile(k>0)\n\t\t{\n\t\t\tresult = result + fibfib;\n\
    \t\t\tk = k/3;\n\t\t}\n\t\ttemp = i-k;\n\t\twhile((temp*temp)>9)\n\t\t{\n\t\t\t\
    temp = temp/10;\n\t\t}\n\t\tresult = result + temp*temp;\n\t}\n\treturn result;\n\
    }\n/*\nThe Sieve of Eratosthenes is a set of boolean functions (that is, the functions\
    \ map a boolean value to another value) over a given range. The sieve is described\
    \ as follows:\n    sieve is true if the given number is prime, false otherwise.\n\
    \    The Sieve of Eratosthenes (soe) is a compact way of writing out all the prime\
    \ numbers up to some given number n.\n    soe contains all the prime numbers up\
    \ to and including n.\n    \n    soe[0] := true\n    soe[1] := true\n    soe[2]\
    \ := true\n    soe[3] := false", "{\n\tint i, fibfib[n];\n\tfibfib[0] = 0;\n\t\
    fibfib[1] = 0;\n\tfor (i = 2; i <= n; i++) {\n\t\tfibfib[i] = fibfib[i-1] + fibfib[i-2];\n\
    \t}\n\treturn fibfib[n];\n}", "{\n\tif(n == 0 || n == 1) {\n\t\treturn 0L;\n\t\
    }\n\treturn fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n}\n\"\"\"\n</cell>\n\
    <cell>\n#export\n@typedispatch\ndef call_pure_fn(lib, fn, args, kws, ctx=None):\n\
    \tif ctx is None: ctx = Context.default_ctx\n\tctx = Context.context(ctx)\n\t\
    args, vararg_params = unpack_args_and_varargs(fn.args_cnt, args)\n\tfixed_args\
    \ = [ lib.get_type_var(x.type_) for x in vararg_params ]\n\tfixed_arg_cnt = len(fixed_args)\n\
    \tfixed_args_tup = tuple(fixed_args)\n\tfixed_kw_cnt = len(kws)\n\tfixed_kw_tup\
    \ = tuple(x for x,y in kws.items() if y is not None)\n\tfixed_kw_tup = tuple(fixed_kw_tup\
    \ + (None,)*fixed_arg_cnt)\n\t\n\targ_types = [ x.type_ for x in args ]\n\tkw_types\
    \ = [ x.type_ for x in fixed_kw_tup ]\n\t\n\tfixed_args_var = TypeVariable.make(fixed_arg_cnt)\n\
    \tfixed_kw_var = TypeVariable.make(fixed_kw_cnt)\n\t\n\tactual_args = [fixed_args_var]\n\
    \tactual_kwargs = [ fixed_kw_var ]\n\t\n\tfor i in range(fn.args_cnt - fixed_arg_cnt\
    \ + fixed_kw_cnt):\n\t\tactual_args.append(TypeVariable.make(vararg_params[i].type_))\n\
    \t\tactual_kwargs.append(TypeVariable.make(fixed_kw_params[i].type_))\n\t\n\t\
    result = fn.apply(ctx, fixed_args_var, fixed_kw_var, *actual_args, **actual_kwargs)\n\
    \t\n\targs = [x.val for x in args]\n\tkw_args = [y for x,y in zip(actual_kwargs,\
    \ result.vals) if x is not None]\n\t\n\tret_type = result.type\n\t\n\treturn ret_type(fixed_arg_cnt,\
    \ *args), kw_args\n</cell>\n<cell>\n#export\n@typedispatch\ndef call_impl(lib,\
    \ fn, args, kws, ctx=None):\n\tif ctx is None: ctx = Context.default_ctx\n\tctx\
    \ = Context.context(ctx)\n\targs, vararg_params = unpack_args_and_varargs(fn.args_cnt,\
    \ args)\n\tfixed_args = [ lib.get_type_var(x.type_) for x in vararg_params ]\n\
    \tfixed_arg_cnt = len(fixed_args)\n\tfixed_args_tup = tuple(fixed_args)\n\tfixed_kw_cnt\
    \ = len(kws)\n\tfixed_kw_tup = tuple(x for x,y in kws.items() if y is not None)\n\
    \tfixed_kw_tup = tuple(fixed_kw_tup + (None,)*fixed_arg", "{\n     long total;\n\
    \     if(n<0) \n     {\n         total = fibfib(-n);\n         return -total;\n\
    \     }\n     if(n==0) \n     {\n         return 0L;\n     }\n     if(n==1)\n\
    \     {\n         return 1L;\n     }\n     if(n==2)\n     {\n         return 2L;\n\
    \     }\n     total = fibfib(n-1)+fibfib(n-2);\n     return total;\n }\n/*\nThe\
    \ Fibonacci number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n    fib(0) == 0\n    fib(1) == 1\n    fib(n) == fib(n-1)\
    \ + fib(n-2).\n    Please write a function to efficiently compute the n-th element\
    \ of the Fibonacci number sequence.\n    >>> fib(1L)\n    1L\n    >>> fib(5L)\n\
    \    8L\n    \n*/\nlong fib(long n) \n{\n     long total;\n     if(n<0) \n   \
    \  {\n         total = fib(-n);\n         return -total;\n     }\n     if(n==0)\
    \ \n     {\n         return 0L;\n     }\n     if(n==1)\n     {\n         return\
    \ 1L;\n     }\n     total = fib(n-1)+fib(n-2);\n     return total;\n }\n/*\nThe\
    \ FizzBuzz sequence is a sequence similar to the Fibonacci sequnece that's defined\
    \ as follows:\n    \n    fizbuzz(0) == 0\n    fizbuzz(15) == fizbuzz(0) + fizbuzz(1)\
    \ + fizbuzz(3) + fizbuzz(5) + fizbuzz(7) + fizbuzz(9) + fizbuzz(13) + fizbuzz(17)\
    \ + fizbuzz(21)\n    fizbuzz(16) == fizbuzz(0) + fizbuzz(1) + fizbuzz(3) + fizbuzz(5)\
    \ + fizbuzz(7) + fizbuzz(9) + fizbuzz(13) + fizbuzz(17) + fizbuzz(21)\n    fizbuzz(17)\
    \ == fizbuzz(0) + fizbuzz(1) + fizbuzz(3) + fizbuzz(5) + fizbuzz(7) + fizbuzz(9)\
    \ + fizbuzz(13) + fizbuzz(17) + ", "{\n\tlong fibfib[] = {0, 1, 1, 2, 6, 24, 120,\
    \ 720, 5040, 40320};\n\tlong i, sum = 0;\n\tfor (i = 0; i < n; i++)\n\t{\n\t\t\
    sum = sum + fibfib[i];\n\t}\n\treturn sum;\n}\n/* end of fibfib */", "{\n    if(n\
    \ <= 1) return 0;\n    return fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n}\n\
    </code>\n<|/ a tags=c++,fibonacci,recursion |>\n<| c |>\nThis is incorrect --\
    \ it isn't tail-recursive.\n<|/ c |>\n<| a tags=c++,fibonacci,recursion |>\nHere's\
    \ a short solution using an array:\n<code>\n#include <algorithm>\n#include <iostream>\n\
    using namespace std;", "{\n\tlong result = 0;\n\tlong fib = 0;\n\twhile (n !=\
    \ 0L)\n\t{\n\t\tfib = fib + 2;\n\t\tresult = result + fib;\n\t\tn = n - 1;\n\t\
    }\n\treturn result;\n}\n/*\nThe Fibonacci number sequence is a sequence similar\
    \ to the Fibbonacci sequnece that's defined as follows:\n    fib(0) == 0\n   \
    \ fib(1) == 1\n    fib(n) == fib(n-1) + fib(n-2).\n    Please write a function\
    \ to efficiently compute the n-th element of the Fibonacci number sequence.\n\
    \    >>> fib(1L)\n    1L\n    >>> fib(5L)\n    5L\n    >>> fib(8L)\n    13L\n\
    \    \n*/\nlong fib(long n) \n{\n\tlong result = 0;\n\tlong fib = 0;\n\twhile\
    \ (n != 0L)\n\t{\n\t\tfib = fib + 2;\n\t\tresult = result + fib;\n\t\tn = n -\
    \ 1;\n\t}\n\treturn result;\n}\n/*\nThe Fibonacci number sequence is a sequence\
    \ similar to the Fibbonacci sequnece that's defined as follows:\n    fibfib(0)\
    \ == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) +\
    \ fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently compute\
    \ the n-th element of the fibfib number sequence.\n    >>> fibfib(1L)\n    0L\n\
    \    >>> fibfib(5L)\n    4L\n    >>> fibfib(8L)\n    24L\n    \n*/\nlong fibfib(long\
    \ n) \n{\n\tlong result = 0;\n\tlong fib = 0;\n\twhile (n != 0L)\n\t{\n\t\tfib\
    \ = fib + 2;\n\t\tresult = result + fib;\n\t\tn = n - 1;\n\t}\n\treturn result;\n\
    }", "{\n     if (n < 0) return fibfib(-n); //negative fibonacci sequence\n   \
    \  long a = 1, b = 1, result;\n     for (long i = 0; i < n; i++) {\n         result\
    \ = a + b; \n         a = b; \n         b = result; \n     }\n     return result;\n\
    }\n</code>\n<|/ a tags=fibonacci,algorithm,python |>\n<| a tags=fibonacci,algorithm,python\
    \ |>\nIn Ruby, this can be done with a tail recursive method.\n<code>\nclass Fib\n\
    \  def self.fib(n)\n    return 0 if n.zero?\n    return 1 if n.odd?\n    Fib::fib(n.next).fib(n\
    \ - 1).fib(n - 2)\n  end\nend\nFib::fib(4)\n=> 3\nFib::fib(3)\n=> 2\nFib::fib(2)\n\
    => 1\nFib::fib(0)\n=> 0\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt took me a while\
    \ to figure out how to express this in Ruby. Ruby isn't my language of choice.\n\
    <|/ c |>\n<| c |>\nIt's actually very easy in Ruby, if you understand recursive\
    \ method definitions.  In Ruby, you can do `def fib(n); return 0 if n == 0; return\
    \ 1 if n.even?; fib(n - 1).fib(n - 2)` end`.  Then you can do `fib(4) == 3`.\n\
    <|/ c |>\n<| c |>\nThis is one of the most beautiful solutions I've seen in Ruby.\
    \ I've tried it and it works great.\n<|/ c |>\n<| a tags=fibonacci,algorithm,python\
    \ |>\nA recursive python solution\n<code>\ndef fibonacci(n,a,b):\n    if n==0:\n\
    \        return a\n    elif n==1:\n        return b\n    else:\n        return\
    \ fibonacci(n-1,b,a+b)\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like that this\
    \ doesn't actually calculate `a` and `b` in each call, so you don't need any extra\
    \ memory and you don't need any temporary variables like `result` and `result2`.\n\
    <|/ c |>\n<| a dscore=2 |>\nI know this is an old question, but here is an updated\
    \ version that actually works.\n<code>\ndef fibonacci(n):\n  a,b = 0,1\n  if n\
    \ == 0:\n    return a\n  while n > 0:\n    a,b = b,a+b\n    n -= 1\n  return b\n\
    </code>\n<|/ a tags=fibonacci,algorithm,python |>\n", "{\n    long fibfib = (long)(Math.pow(5,\
    \ (double)n));\n    return fibfib;\n}", "{\n    if(n<3L)\n        return 0L;\n\
    \    return fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n}\nlong fibfib1(int n)\n\
    {\n    long x = 1L;\n    for(;n>0;n--)\n        x = x + x;\n    return x;\n}",
  "{\n    long a = 1, b = 1, s = 0, x = 0, y = 0, i;\n    if (n>0)\n    {\n      \
    \  i = n-1;\n        x = 1;\n        while(i > 0)\n        {\n            if(i%2\
    \ == 0)\n            {\n                y = a*x + b;\n                a = b;\n\
    \                b = y;\n            }\n            x = x*x + i;\n           \
    \ i--;\n        }\n    }\n    else\n    {\n        i = n-1;\n        y = 0;\n\
    \        while(i > 0)\n        {\n            y = y*x + i;\n            i--;\n\
    \        }\n    }\n    return y;\n}", "{\n    if (n == 0L) \n        return (0L);\n\
    \    long fibfib2[n] = { 1L, 0L };\n    for (long i = 2; i <= n; i++) {\n    \
    \    long sum = 0;\n        for (long j = 2; j <= i; j++) {\n            sum =\
    \ (sum + fibfib2[j - 2]) + fibfib2[j - 1];\n        }\n        fibfib2[i] = sum;\n\
    \    }\n    return fibfib2[n-1];\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks\
    \ for your contribution, but this doesn't really answer the question.\n<|/ c |>\n\
    <| c |>\nI have added a solution that is much faster for this particular problem.\
    \ As you can see, there are many tricks that can improve the performance. For\
    \ example, a solution that uses arrays. Using arrays instead of writing recursive\
    \ function calls is much more efficient.\n<|/ c |>\n<| c |>\nI tested your solution\
    \ and it works, but it's very slow.  It takes about 7 seconds to perform `fibfib(10L)`.\n\
    <|/ c |>\n<| c |>\nThanks. I tested it on repl.it and I didn't get 7 seconds.\
    \ Maybe it's because I used a 64-bit machine.\n<|/ c |>\n<| c |>\nYes, it is.\
    \ It's because 64-bit compilation takes more time than 32-bit compilation. I ran\
    \ it on a 32-bit machine and got 2 seconds execution time.\n<|/ c |>\n<| a tags=c++,fibonacci,c,fibonacci-heap\
    \ |>\nThis is a faster implementation of the Fibonacci heap sequence that I have\
    \ tested for speed: \n<code>\n#include <iostream>\n#include <vector>\n#include\
    \ <algorithm>\n#include <numeric>", "{\n    if(n<0) \n    {\n        throw Exception(\"\
    fibfib: invalid input n \"+n+\". Input must be positive integer.\");\n    }\n\
    \    long fibfib=0;\n    if(n==0L) \n    {\n        return fibfib;\n    }\n  \
    \  if(n==1L) \n    {\n        return fibfib;\n    }\n    fibfib=fibfib+fibfib(n-1L);\n\
    \    return fibfib;\n}", "{\n    long sum;\n    if (n == 0) return 0;\n    if\
    \ (n == 1) return 1;\n    if (n == 2) return 2;\n    sum = (long) std.math._fibfib(n-1)\
    \ + std.math._fibfib(n-2) + std.math._fibfib(n-3);\n    return sum;\n}\n</code>\n\
    <|/ a tags=fibonacci,fibonacci-heap,performance,algorithm |>\n<| c |>\nHm, I don't\
    \ think this runs in O(logn) time, but O(n). But I'm no expert...\n<|/ c |>\n\
    <| c |>\nIt's a little embarrassing that you are writing a comment, rather than\
    \ a full answer.\n<|/ c |>\n<| a dscore=4 |>\nI noticed that you said \"O(1),\
    \ without recursion and a little math\", but actually you are reimplementing recursion,\
    \ so it's O(n). Since it's homework, I'll try to give you a hint, and hopefully\
    \ this isn't a homework problem.\n<code>\ndef fibfib(n):\n    if n < 0:\n    \
    \    raise ValueError(\"fibfib cannot compute fibfib(-x)\")\n    if n <= 1:\n\
    \        return n\n    return fibfib(n-1) + fibfib(n-2)", "{\n    long i, f, prev,\
    \ res, temp;\n    if (n == 0)\n        return 0;\n    if (n == 1L)\n        return\
    \ 0;\n    prev = fibfib(n-1L);\n    temp = prev + prev;\n    f = temp%n;\n   \
    \ for (i = 3; i <= n; i += 2)\n    {\n        temp = f + prev;\n        res =\
    \ temp%n;\n        prev = res;\n        temp = temp/n;\n        f = temp%n;\n\
    \    }\n    return res;\n}\n</code>\n<|/ a tags=fibonacci,sequence,loops,math,c\
    \ |>\n<| c |>\nThe main idea is to compute fibonacci numbers as a linear function\
    \ of a couple of numbers, not by iterating over all elements. If you take the\
    \ first 2 elements of the fibonacci sequence as X and Y, you can compute the next\
    \ number using X + Y = (X + Y + Y) % (2*X) = X + 2*Y - 2*Y+X\n<|/ c |>\n<| c |>\n\
    This solution does NOT give the correct Fibonacci sequence for the number `5`\
    \ or `8` because the `f`-variable is initialized to `prev` and is never updated\
    \ so `f` = `prev` always. I tested this with `f=0L` `prev=0L` and it gives the\
    \ correct output `0L` for `n=5L` but `6L` for `n=8L`.\n<|/ c |>\n<| c |>\nYou\
    \ are right about the initialization of `f` variable. I updated my code. Also\
    \ I think `fibonacci()` function could be optimized by storing previous numbers\
    \ in a `vector` or `array` as suggested by.\n<|/ c |>\n<| c |>\nI tested your\
    \ code for `n=8L` and got `6L`, not `24L`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ out. I realized that `f` was not updated in `for` loop when `n <= 5`. I fixed\
    \ my code.\n<|/ c |>\n<| a dscore=4 |>\nThe easiest way is to use recursion:\n\
    <code>\nlong fib(int n)\n{\n    if (n<=1)\n        return n;\n    return fib(n-1)\
    \ + fib(n-2);\n}\n</code>\nThis is called memoization. \n<code>\nlong fib(int\
    \ n)\n{\n    static vector<long> v;\n    if (v.size()==n)\n    {\n        v.resize(n+1);\n\
    \    }\n    v[n] = fib(n-1);\n    v[n] += v[n-1];\n    return v[n];", "{\n   \
    \ if (n <= 1) \n    {\n        return 0L;\n    }\n    return fibfib(n-1L) + fibfib(n-2L)\
    \ + fibfib(n-3L);\n}\n'''\n</cell>\n<text>\nProblem 3b\nWrite a function definition\
    \ to compute the sum of the numbers from 1 to n (inclusive).", "{\n    if (n<2L)\n\
    \        return nL;\n    return fibfib(n-2L) + fibfib(n-1L);\n}\n/*\nThe Fibbonacci\
    \ number is a recursive sequence defined as follows:\n    fib(0) = 0\n    fib(1)\
    \ = 1\n    fib(n) = fib(n-1) + fib(n-2).\n    Please write a recursive function\
    \ to efficiently compute the n-th element of the fibbonacci sequence.\n    \n\
    */\nlong fibb(long n) \n{\n    if (n<1L)\n        return nL;\n    return fib(n-1L)\
    \ + fib(n-2L);\n}\n/*\nThe Fibonacci numbers grow very quickly and can be calculated\
    \ using logarithmic mathematics.\nA fibonacci sequence grows very quickly in a\
    \ linear fashion until it reaches the number 10. \nThus the Fibonacci numbers\
    \ are often used to determine the numbers of fibonacci numbers growing beyond\
    \ the limit, 10.", "{\n    long sum=0, i, j;\n    if (n <= 1) return n; \n   \
    \ for (i=1; i<=3; i++) {\n        for (j=0; j<i; j++) sum += (long long)pow((double)i,\
    \ (double)j);\n    }\n    return sum;\n}\n\"\"\"", "{\n    long fibfib0 = 0, fibfib1\
    \ = 1, fibfib2 = 1;\n    while (n) {\n\tfibfib1 = fibfib2;\n\tfibfib2 = fibfib0\
    \ + fibfib1;\n\tfibfib0 = fibfib1 + fibfib2;\n\tn--;\n    }\n    return fibfib0;\n\
    }\n*/\n \n/* Your Fibbonacci function should return a new function object which\
    \ when called with the n-th number returns fibfib(n).  \n   It should work like\
    \ this: fibfib(n)(0) == 0, fibfib(n)(1) == 0, fibfib(n)(2) == 1, fibfib(n)(3)\
    \ == 1, fibfib(n)(4) == 2, fibfib(n)(5) == 3, fibfib(n)(6) == 5, fibfib(n)(7)\
    \ == 8, fibfib(n)(8) == 16, ... \n   Note that fibfib(n) should be a function.\
    \  \n   If the returned function object is not callable (e.g. fibfib(5)(0) ==\
    \ fibfib(0)(0)), it should not work like your Fibbonacci function and should throw\
    \ an exception. */\nfunction fibfib(n) \n{\n    if (typeof fibfib == \"function\"\
    ){\n        return fibfib(n);\n    }\n    else {\n        throw \"fibfib(...)\
    \ should be a function\";\n    }\n}", "{\n    if (n==1 || n==0)\n        return\
    \ 0;\n    else\n    {\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    \    }\n}", "{\n   long long i= 1L;\n   long long fibfibN;\n   while (i <= n)\n\
    \   {\n     fibfibN=i;\n     if (i%2==0)\n       i=i+3;\n     else\n       i=i+2;\n\
    \   }\n   return fibfibN;\n}\n</code>\n<|/ a tags=math,c,fibonacci |>\n<| c |>\n\
    While this code may answer the question, providing additional context regarding\
    \ *why* and/or *how* this code answers the question improves its long-term value.\n\
    <|/ c |>\n<| c |>\nThis has O(1) space, so it might be a good solution.\n<|/ c\
    \ |>\n<| c |>\nYou don't need a loop to compute this value. The first two numbers\
    \ are 0 and 1, and you just add the third and fourth terms. So (0+1)+(0+2)+(1)\
    \ = 1 and you get that value with just one addition operation.\n<|/ c |>\n<| c\
    \ |>\nThe code has been updated and the variable is renamed. Thanks for your comment.\n\
    <|/ c |>\n<| c |>\nYou don't need a loop. Just add the third term and fourth terms.\n\
    <|/ c |>\n<| a dscore=2 |>\nThe recursive code will work fine, but it might be\
    \ a bit faster to do it iteratively.\n<code>\nlong fib(int n) {\n  if (n < 2)\n\
    \    return 0;\n  if (n == 2)\n    return 1;\n  return fib(n - 1) + fib(n - 2);\n\
    }\n</code>\n<|/ a tags=math,c,fibonacci |>\n<| c |>\nThe recursive version is\
    \ only \"faster\" because there is only one return statement.\n<|/ c |>\n<| c\
    \ |>\n- true.  Recursion would require two return statements (one for base case,\
    \ one for recursion case).\n<|/ c |>\n<| c |>\n, what about `fib(0)`?\n<|/ c |>\n\
    <| c |>\nThat case could be handled with a little thought.  Since the base case\
    \ is `n < 2`, the next step is to return `0` (since `fib(0)` is `fib(1)`) and\
    \ then `fib(1) is 0`.\n<|/ c |>\n<| a tags=math,c,fibonacci dscore=2 |>\nThe Fibonacci\
    \ sequence is defined as:", "{\n\tif (n < 3L) {\n\t\treturn 0L;\n\t}\n\telse {\n\
    \t\tlong long a = fibfib(n-2L);\n\t\tlong long b = fibfib(n-3L);\n\t\treturn a\
    \ + b + fibfib(n-1L);\n\t}\n}\n/*\nThe Fibonacci number sequence is a sequence\
    \ similar to the Fibbonacci sequnece that's defined as follows:\n    fib(0) ==\
    \ 0\n    fib(1) == 0\n    fib(n) == fib(n-1) + fib(n-2).\n    Please write a function\
    \ to efficiently compute the n-th element of the fib number sequence.\n    >>>\
    \ fib(1L)\n    0L\n    >>> fib(5L)\n    4L\n    >>> fib(8L)\n    10L\n    \n*/\n\
    long fib(long n) \n{\n\tif (n < 3L) {\n\t\treturn 0L;\n\t}\n\telse {\n\t\tlong\
    \ long a = fib(n-2L);\n\t\tlong long b = fib(n-1L);\n\t\treturn a + b;\n\t}\n}",
  "{\n\tif(n==0) return 0L;\n\tif(n==1) return 0L;\n\tif(n==2) return 1L;\n\tlong\
    \ prev=fibfib(n-1);\n\tlong prev2=fibfib(n-2);\n\tlong prev3=fibfib(n-3);\n\t\
    long ans=prev+prev2+prev3;\n\treturn ans;\n}\n</code>\n<|/ a tags=recursion,fibonacci,java,fibonacci-stack\
    \ |>\n<| c |>\nA bit of explanation would be nice here.\n<|/ c |>\n<| c |>\nA\
    \ little bit of explanation?  There's a lot of code here... It would be better\
    \ if we could avoid the excessive comments.\n<|/ c |>\n<| c |>\n, I've added some\
    \ comments. Hope it helps.\n<|/ c |>\n<| c |>\nThis does not take advantage of\
    \ the tail-recursion optimization. `fibfib` is an imperative function, and it\
    \ will suffer from stack overflow if the stack size is not large enough.\n<|/\
    \ c |>\n<| c |>\n, yes, it definitely will cause stack overflow in some cases,\
    \ but the OP said he was running on short stack size, so it should work fine for\
    \ his use case.\n<|/ c |>\n<| a tags=recursion,fibonacci,java,fibonacci-stack\
    \ |>\nThe other answers are all quite good, but they don't seem to take advantage\
    \ of the tail-recursion optimization.  Here's an implementation of an iterative\
    \ Fibonacci algorithm that does take advantage of this:\n<code>\npublic static\
    \ long fibIterative(long n) {\n    long a = 0;\n    long b = 1;\n    long sum\
    \ = 0;\n    while (n > 1) {\n        long c = a + b;\n        a = b;\n       \
    \ b = c;\n        sum += c;\n        n--;\n    }\n    return sum;\n}\n</code>\n\
    The above code uses a trick to compute the nth term without recomputing the n-1\
    \ and n-2 terms.  It works by calculating the nth term by incrementing a value\
    \ (a) and then re-calculating the n-1 and n-2 terms by reusing the value (a) for\
    \ the previous two terms.\nThe only caveat is that the above code does not take\
    \ advantage of the tail-recursion optimization that would make it run quicker\
    \ if the input were large enough.  For that to happen, you would need to use the\
    \ following code:\n<code>\npublic static long fibIterative(long n) {\n    long\
    \ a = 0;\n    long b = 1;\n    long sum = 0;\n    while (n > ", "{\n\tif (n <=\
    \ 3) return n;\n\telse\n\t\treturn fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }\n</cell>\n<code language=.net-csharp>\n// TESTS\n// Test Case 1\n/*\nThe first\
    \ test case of the code will test the fibfib() function.\nThe expected result\
    \ is 0L and should be returned from the function call.\nIf the function call is\
    \ incorrect then it should not return 0L and should be returned as a failure.\n\
    */\nlong fibfibTest1() {\n\tlong result;\n\tresult = fibfib(0L);\n\tif (result\
    \ == 0L) {\n\t\tConsole.WriteLine(\"Test 1 FAILED\");\n\t\treturn result;\n\t\
    }\n\tConsole.WriteLine(\"Test 1 PASSED\");\n\treturn result;\n}\nfibfibTest1();\n\
    </cell>\n<code language=.net-csharp>\n// Test Case 2\n/*\nThe second test case\
    \ of the code will test the fibfib() function.\nThe expected result is 1L and\
    \ should be returned from the function call.\nIf the function call is incorrect\
    \ then it should not return 1L and should be returned as a failure.\n*/\nlong\
    \ fibfibTest2() {\n\tlong result;\n\tresult = fibfib(1L);\n\tif (result == 1L)\
    \ {\n\t\tConsole.WriteLine(\"Test 2 FAILED\");\n\t\treturn result;\n\t}\n\tConsole.WriteLine(\"\
    Test 2 PASSED\");\n\treturn result;\n}\nfibfibTest2();\n</cell>\n<code language=.net-csharp>\n\
    // Test Case 3\n/*\nThe third test case of the code will test the fibfib() function.\n\
    The expected result is 2L and should be returned from the function call.\nIf the\
    \ function call is incorrect then it should not return 2L and should be returned\
    \ as a failure.\n*/\nlong fibfibTest3() {\n\tlong result;\n\tresult = fibfib(2L);\n\
    \tif (result == 2L) {\n\t\tConsole.WriteLine(\"Test 3 FAILED\");\n\t\treturn result;\n\
    \t}\n\tConsole.WriteLine(\"Test 3 PASSED\");\n\treturn result;\n}\nfibfibTest3();\n\
    </cell>\n<code language=.net-csharp>\n// Test Case 4\n/*\nThe fourth test case\
    \ of the code will test the fibfib() function.\nThe expected result is 3L and\
    \ should be returned from the function call.\nIf the function call is incorrect\
    \ then it should not return 3L and should be returned as a failure.\n*/\nlong\
    \ fibfibTest4() {\n\tlong result;\n\tresult = fibfib(3L);\n\tif (result == 3L)\
    \ {\n\t\tConsole.WriteLine(\"Test 4 FAILED\");\n\t\treturn result;\n\t}\n\tConsole.WriteLine(\"\
    Test 4 PASSE", "{\n\tif (n >= 1) \n\t{\n\t\treturn fibfib(n-1) + fibfib(n-2) +\
    \ fibfib(n-3);\n\t}\n\treturn 0;\n}", "{\n    long x;\n    long y;\n    if (n\
    \ < 0)\n        throw new IllegalArgumentException(\"fibfib: negative number.\"\
    );\n    if (n == 0)\n        return 0L;\n    if (n == 1)\n        return 1L;\n\
    \    if (n == 2)\n        return 1L;\n    x = fibfib(n-1);\n    y = fibfib(n-2);\n\
    \    return x + y;\n}\n</code>\n<|/ a tags=java,recursion |>\n<| a tags=java,recursion\
    \ |>\nFor this kind of problems, you can solve them using paper and pencil.\n\
    And you can try to solve with recursion first and then by iteration.\nHere is\
    \ a recursive solution:\n<code>\nimport java.util.ArrayList;\nimport java.util.List;",
  "{\n    long first = 0;\n    long second = 1;\n    long third = 1;\n    long temp;\n\
    \    if (n <= 0)\n    {\n        return 0;\n    }\n    else\n    {\n        while\
    \ (n > 1)\n        {\n            temp = first;\n            first = second;\n\
    \            second = third;\n            third = temp;\n            n--;\n  \
    \      }\n        return first;\n    }\n}", "{\n  if (n <= 1L) \n    return 0L;\n\
    \  if (n >= 2L) \n    return 1L;\n  return fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n\
    }\n/*\nThe Fibonacci number sequence is a sequence similar to the Fibonacci sequnece\
    \ that's defined as follows:\n    fib(0) == 0\n    fib(1) == 1\n    fib(2) ==\
    \ 1\n    fib(n) == fib(n-1) + fib(n-2).\n    Please write a function to efficiently\
    \ compute the n-th element of the Fibonacci number sequence.\n    >>> fib(1L)\n\
    \    0L\n    >>> fib(5L)\n    4L\n    >>> fib(8L)\n    24L\n    \n*/\nlong fib(long\
    \ n) \n{\n  if (n <= 1L) \n    return 0L;\n  if (n >= 2L) \n    return 1L;\n \
    \ return fib(n-1L) + fib(n-2L);\n}\n/*\nThe Fibonacci numbers are computed by\
    \ using the same formula that we learned about in week 3.\n    fibfib(0) == 0\n\
    \    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3).\n    Please write a function to efficiently compute the n-th\
    \ element of the Fibonacci number sequence.\n    >>> fibfib(1L)\n    0L\n    >>>\
    \ fibfib(5L)\n    4L\n    >>> fibfib(8L)\n    24L\n    \n*/\nlong fibfib(long\
    \ n) \n{\n  if (n <= 1L) \n    return 0L;\n  if (n >= 2L) \n    return 1L;\n \
    \ return fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n}\n/*\nThe Lucas sequence\
    \ is a sequence similar to the Fibonacci sequnece that's defined as follows:\n\
    \    lucas(0) is 0\n    lucas(1) is 1\n    lucas(2) is 1\n    lucas(n) = lucas(n\
    \ - 1) + lucas(n - 2).\n    Please write a function to efficiently compute the\
    \ n-th element of the Lucas sequence.\n    >>> lucas(1L)\n    0L\n    >>> lucas(5L)\n\
    \    7L\n    >>> lucas(8L)\n    13L\n    \n*/\nlong lucas(long n) \n{\n  if (n\
    \ <= 1L) \n    return 0L;\n", "{\n\tif(n>0) \n\t{\n\t\tif(n==1)\n\t\t\treturn\
    \ 0;\n\t\telse \n\t\t\treturn fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\t}\n\t\
    else \n\t{\n\t\treturn 0;\n\t}\n}", "{\n\t// write your code in C# here.\n\tif\
    \ (n == 0 || n == 1) return 0L;\n\treturn fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n\
    }\n/*\n * Write a function that returns the nth number of the Fibonacci sequnece.\n\
    \ */\nlong nthFib(int n)\n{\n    return fibfib(n);\n}\n/*\nWrite a function that\
    \ returns the nth number of the Fibonacci sequnece using the fast algorithm.\n\
    This function should take one integer as input and return the nth number of the\
    \ Fibonacci sequnece.\nIf n is out of range, the function should return 0.\n*/\n\
    long nthFibFast(int n)\n{\n    long first = 0;\n    long second = 1;\n    long\
    \ result = 1;\n    if (n <= 0)\n        return 0;\n    while (n > 1) {\n     \
    \   result = first;\n        first += second;\n        second += result;\n   \
    \     n--;\n    }\n    return result;\n}\n/*\nWrite a function that returns the\
    \ nth number of the Fibonacci sequnece using the fast algorithm.\nThis function\
    \ should take one integer as input and return the nth number of the Fibonacci\
    \ sequnece.\nIf n is out of range, the function should return 0.\n*/\nlong nthFibSlow(int\
    \ n)\n{\n    long first = 0;\n    long second = 1;\n    long result = 1;\n   \
    \ if (n <= 0)\n        return 0;\n    while (n > 1) {\n        result = first;\n\
    \        first += second;\n        second += result;\n        n--;\n    }\n  \
    \  return result;\n}", "{\n    long long a,b,c;\n    long long fibfib[100];\n\
    \    fibfib[0]=0;\n    fibfib[1]=0;\n    fibfib[2]=1;\n    \n    for(long i=3;i<=n;i++){\n\
    \        fibfib[i]=fibfib[i-1]+fibfib[i-2]+fibfib[i-3];\n    }\n    return fibfib[n];\n\
    }", "{\n    long fibfib1 = 0L;\n    long fibfib2 = 1L;\n    long fibfib3 = 1L;\n\
    \    long fibfib4 = 2L;\n    for (long i = 3L; i < n; i+= 3L) {\n        fibfib1\
    \ = fibfib2;\n        fibfib2 = fibfib3;\n        fibfib3 = fibfib4;\n       \
    \ fibfib4 = (fibfib1 + fibfib2 + fibfib3) + fibfib4;\n    }\n    return fibfib4;\n\
    }\n/*\nThe Fibonacci Sequence (Fibonacci Sequence) was proposed in the 1980s as\
    \ a way to generate an infinite sequence of numbers.  We defined a function\n\
    fibseq:\n    fibseq(0) == 0\n    fibseq(1) == 0\n    fibseq(n-1) == fibseq(n-2)\
    \ + fibseq(n-3)\n    Please write a function to efficiently compute the n-th element\
    \ of the fibonacci sequence.\n    >>> fibseq(1L)\n    0L\n    >>> fibseq(5L)\n\
    \    6L\n    >>> fibseq(8L)\n    21L\n    \n*/\nlong fibseq(long n) \n{\n    long\
    \ fibseq1 = 0L;\n    long fibseq2 = 1L;\n    for (long i = 3L; i < n; i+= 3L)\
    \ {\n        fibseq1 = fibseq2;\n        fibseq2 = (fibseq1 + fibseq2) + fibseq2;\n\
    \    }\n    return fibseq2;\n}\n</code>\n<|/ a |>\n<| c |>\nI really liked the\
    \ definition of `fibfib` but was concerned that it was too long and that my compiler\
    \ would complain that I had too many statements in a block of code.  The `for`\
    \ loop definition of `fibfib` makes it clear that it's intended to be a recursive\
    \ definition.  I wonder how much of an efficiency gain this would have.  Would\
    \ it be more efficient to define this as a `while` loop, or to define it with\
    \ a recursive function?\n<|/ c |>\n<| c |>\nTo be honest, I'm not sure.  The way\
    \ I see it, the while loop is probably not much different from what I posted.\
    \  The compiler will most likely optimize it into a while loop.  But if you're\
    \ interested in performance anyway, go with whichever method makes the code clearer.\n\
    <|/ c |>\n<| c |>\nI do want to mention, however, that your solution here is the\
    \ best one.  I wonder if it would be possible to write an implementation that\
    \ used recursion.  As you mentioned, it ", "{\n    if ( n < 3 ) {\n        return\
    \ n;\n    }\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}\n</code>\n\
    <|/ a tags=haskell,fibonacci,clojure |>\n<| c |>\nI think this is the fastest\
    \ solution!\n<|/ c |>\n<| c |>\nYes. But if you want just an idea, the naive recursive\
    \ one has a time complexity of `O(2^n)`. This is a bit bigger than `O(fibfib(n))`\
    \ but it is a very bad idea.\n<|/ c |>\n<| c |>\nFor large `n`, this algorithm\
    \ is very inefficient because it makes two calls for every call.  See [my answer](http://stackoverflow.com/a/34824790/121727)\
    \ for a more efficient solution.\n<|/ c |>\n<| a |>\nThe most efficient solution\
    \ I've found so far is this:\n<code>\nfibfib :: Int -> Int\nfibfib n = fibfib'\
    \ (pred n) 0\n  where fibfib' n 0 = 0\n        fibfib' 0 1 = 0\n        fibfib'\
    \ 1 1 = 0\n        fibfib' n a | n > 2   = fibfib' (n-1) (fibfib (n-2) + a)\n\
    \                  | otherwise = a\n</code>\nIt does exactly as asked, but it's\
    \ faster than the naive recursive version for large n, because it makes fewer\
    \ recursive calls for large n, and therefore has less stack space.\n<|/ a tags=haskell,fibonacci,clojure\
    \ dscore=3 |>\n<| c |>\nI think this solution is very inefficient because it makes\
    \ two calls for every call. See [my answer](http://stackoverflow.com/a/34824790/121727)\
    \ for a more efficient solution.\n<|/ c |>\n<| a |>\nHere's a Clojure version:\n\
    <code>\n(defn fib [x]\n  (if (< x 2)\n      x\n      (if (< x 3)\n          (+\
    \ (fib x) (fib x-1))\n          (fib x-1)))) \n</code>\n<|/ a dscore=3 tags=haskell,fibonacci,clojure\
    \ |>\n<| a |>\nIn Haskell, it is easy to implement this without too much recursion,\
    \ just by calculating a recurrence relation for the Fibonacci sequence:\n<code>\n\
    fib = [0, 1; 1, 1]\n    fib n = fib (n-1) + fib (n-2)\n</code>\n", "{\n    long\
    \ res = 0;\n    long ii;\n    if(n == 0) return 0;\n    if(n == 1) return 1;\n\
    \    for (ii = 2; ii <= n; ii++) {\n        res = res + ii;\n    }\n    return\
    \ res;\n}\n/*\nThe following is a solution for computing fibonacci sequence. \n\
    But it is not efficient. \n\"\"\"\nclass FibFib {\n    public:\n        FibFib()\
    \ {}\n        FibFib(int n) {\n            int ii = 2;\n            if(n == 0)\
    \ fib[0] = 0;\n            if(n == 1) fib[1] = 1;\n            else {\n      \
    \          while(n > 0) {\n                    fib[ii] = fib[ii - 1] + fib[ii\
    \ - 2];\n                    n = n - 2;\n                    ii++;\n         \
    \       }\n            }\n        }\n        long fib(int n) {\n            long\
    \ res = 0;\n            if(n == 0) return 0;\n            if(n == 1) return 1;\n\
    \            for(int ii = 1; ii < n; ii++) {\n                res = res + fib[ii\
    \ - 1];\n            }\n            return res;\n        }\n};", "{\n    long\
    \ ret=0;\n    if (n==0)\n        return ret; \n    if (n==1)\n        return ret;\n\
    \    if (n==2)\n        return ret;\n    ret = fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    \    return ret;\n}\n</code>\n<|/ a tags=recursion,c#,fibonacci |>\n<| c |>\n\
    Please provide an explanation to your answer as well, rather than simply dumping\
    \ code on someone.\n<|/ c |>\n<| a tags=recursion,c#,fibonacci |>\nThis code computes\
    \ Fibonacci recursively. This is the simplest and most efficient way to compute\
    \ a fibonacci number in C#. \n<code>\nusing System;", "{\n    long fibfib_seq[20]\
    \ = {0L};\n    long fibfib = 0;\n    fibfib = (fibfib_seq[2*n]) + (fibfib_seq[2*n\
    \ + 1]);\n    long counter = 1;\n    for(int i = 3; i <= n; i+=2)\n    {\n   \
    \     fibfib = (fibfib_seq[2*i]) + (fibfib_seq[2*i + 1]) + fibfib;\n        fibfib_seq[2*i]\
    \ = fibfib_seq[2*i] + fibfib_seq[2*i + 1];\n        fibfib_seq[2*i + 1] = fibfib;\n\
    \    }\n    return fibfib;\n}", "{\n\tlong i, fibfib;\n\tfibfib = 0;\n\tfor(i\
    \ = 0; i <= n; i++) {\n\t\tfibfib += i;\n\t}\n\treturn fibfib;\n}\n/*\nWrite a\
    \ function that returns the factorial of n.\n\tFactorial(n) is the number of times\
    \ that n can be written as a\n\tpositive integer without using multiplication.\n\
    \tFactorial(0) = 1\n\tFactorial(n) = n * Factorial(n-1)\n\tFor example,\n\tFactorial(3)\
    \ = 3 * Factorial(2) = 2 * Factorial(1) = 1\n\tFactorial(5) = 5 * Factorial(4)\
    \ = 2 * Factorial(3) = 3\n\tFactorial(8) = 8 * Factorial(6) = 4 * Factorial(5)\
    \ = 5\n\tFactorial(10) = 10 * Factorial(8) = 4 * Factorial(7) = 6\n\tFactorial(12)\
    \ = 12 * Factorial(10) = 8 * Factorial(9) = 8\n\tFactorial(14) = 14 * Factorial(12)\
    \ = 12 * Factorial(8) = 14\n\tFactorial(15) = 3 * Factorial(14) = 2 * Factorial(13)\
    \ = 6\n\tFactorial(16) = 5 * Factorial(15) = 2 * Factorial(12) = 8\n\tFactorial(18)\
    \ = 8 * Factorial(16) = 4 * Factorial(15) = 10\n\tFactorial(19) = 19 * Factorial(18)\
    \ = 6 * Factorial(14) = 12\n\tFactorial(20) = 3 * Factorial(19) = 2 * Factorial(18)\
    \ = 5\n\tFactorial(21) =  5 * Factorial(20) = 2 * Factorial(19) = 1\n\tFactorial(22)\
    \ = 22 * Factorial(21) = 8 * Factorial(18) = 8\n\tFactorial(23) = 23 * Factorial(22)\
    \ = 12 * Factorial(20) = 12\n\tFactorial(24) = 24 * Factorial(23) = 16 * Factorial(21)\
    \ = 24\n\tFactorial(25) = 21 * Factorial(24) = 24 * Factorial(22) = 32\n\tFactorial(26)\
    \ = 25 * Factorial(25) = 24 * Factorial(21) = 32\n\tFactorial(27) = 24 * Factorial(26)\
    \ = 36 * Factorial(21) = 48\n\tFactorial(28) = 37 * Factorial(27) = 24 * Factorial(24)\
    \ = 120\n\tFactorial(29) = 28 * Factorial(28) = 48 * Factorial(21) = 144\n\tFactor",
  "{\n    long temp;\n    if ( n <= 1L )\n    {\n        return 0L;\n    }\n    else\
    \ if ( n <= 2L )\n    {\n        return nL;\n    }\n    else\n    {\n        temp\
    \ = n - 2L;\n        return fibfib( temp )+ fibfib( temp-1L) + fibfib( temp-2L\
    \ );\n    }\n}", "{\n    int j=0;\n    long fib=0;\n    for(int i=1;i<=n;i++)\n\
    \    {\n        fib=fib+i;\n        if(j%2==0)\n        {\n            fib=fib*fib;\n\
    \        }\n        j++;\n    }\n    return fib;\n}\n</code>\n<|/ a tags=c,fibonacci,c++\
    \ |>\n<| c |>\nThis is an implementation of some pretty well known algorithm,\
    \ but it's not *quite* the Fibonacci sequence -- that's more like `fibfib(n)`.\
    \ Also, the `j%2==0` test is unnecessary. Just loop until the `fib` variable is\
    \ `0`.\n<|/ c |>\n<| c |>\nThis is not the Fibonacci sequence. Also the test `j%2==0`\
    \ can be removed, as all multiples of 2 will have the exact same value.\n<|/ c\
    \ |>\n<| c |>\nI don't think you really understand the algorithm (and the `j%2==0`\
    \ test is unnecessary anyway, as all multiples of 2 will always be the same value).\
    \ The Fibonacci sequence is defined as: `fib(k) = fib(k-1) + fib(k-2)`. So the\
    \ algorithm should be `fibfib(n) = (fibfib(n-1) + fibfib(n-2)) * fibfib(n-2)`\
    \ (though I suspect the actual `fibfib` function is faster than this).\n<|/ c\
    \ |>\n<| c |>\nYour edit changes the algorithm (it now computes different values\
    \ than before), but doesn't really explain the algorithm. The fibonacci sequence\
    \ can be defined as `f(n) = (f(n-1) + f(n-2)) * f(n-2)` (so you still need to\
    \ compute the product of two fibonacci numbers), but your algorithm computes different\
    \ values, even though it's the same algorithm.\n<|/ c |>\n<| c |>\nNo, your algorithm\
    \ computes `((f(n-1) + f(n-2)) * f(n-2)) * f(n-2)` whereas the correct answer\
    \ is `f(n-2)` which your algorithm returns by taking the `fibfib(n-2)` value every\
    \ time.\n<|/ c |>\n<| a dscore=5 tags=c,fibonacci,c++ |>\n<code>\nlong fibonacci(int\
    \ n)\n{\n    long x = 0;\n    long y = 1;\n    int i;", "{\n\tlong fibfib=0;\n\
    \tif (n==0)\n\t{\n\t\treturn 0;\n\t}\n\tif (n==1)\n\t{\n\t\treturn 1;\n\t}\n\t\
    if (n==2)\n\t{\n\t\treturn 2;\n\t}\n\tlong a,b,c,d;\n\ta=fibfib(n-1);\n\tb=fibfib(n-2);\n\
    \tc=fibfib(n-3);\n\td=a+b+c;\n\tfibfib=d;\n\treturn d;\n}", "{\n    long f = 1;\n\
    \    while (n > 0)\n    {\n        f = f * n;\n        n--;\n    }\n    return\
    \ f;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhile this code may solve the question,\
    \ [including an explanation](https://meta.stackexchange.com/q/114762) of how and\
    \ why this solves the problem would really help to improve the quality of your\
    \ post, and probably result in more up-votes. Remember that you are answering\
    \ the question for readers in the future, not just the person asking now. Please\
    \ [edit] your answer to add explanations and give an indication of what limitations\
    \ and assumptions apply.\n<|/ c |>\n<| a dscore=2 |>\nJust in addition to other\
    \ answers, I should add that for me the most efficient solution was:\n<code>\n\
    long fibfib(int n) {\n    return ((n < 2) ? 1 : fibfib(n-2) + fibfib(n-1));\n\
    }\n</code>\n<|/ a tags=big-o,recursion |>\n<| a tags=big-o,recursion |>\n<code>\n\
    def fibfib(n):\n    if n==2:\n        return 1\n    elif n==1:\n        return\
    \ 0\n    else:\n        return fibfib(n-1) + fibfib(n-2)\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nWhy did you include the `elif n==1` clause ?\n<|/ c |>\n<| c |>\n\
    Because of the comment \"Please write a function to efficiently compute the n-th\
    \ element of the fibfib number sequence\"\n<|/ c |>\n<| c |>\nAnd why would you\
    \ include the `else` clause ?\n<|/ c |>\n<| c |>\nbecause that's what OP was asked\
    \ to do by the question\n<|/ c |>\n<| a tags=big-o,recursion |>\nIt is a Fibonacci\
    \ number. \nSo it is basically the sum of all previous numbers in Fibonacci sequence\
    \ which is calculated as:\n<code>\nF(0) = 0\nF(1) = 1\nF(n) = F(n-1) + F(n-2).\n\
    </code>\nThe sum of all previous numbers in Fibonacci sequence is basically the\
    \ sum of all previous numbers except 1 and 0. So, in your case, the sum will be\
    \ the sum of previous numbers which are n-1, n-2 and n-3.\nSo the sum is Fib(n-1)+Fib(n-2)+Fib(n-3).\n\
    <|/ a dscore=0 |>\n<| c |>\nThis is a good answer, but please explain it a little\
    \ bit.\n<|/ c |>\n<| c |>", "{\n    long ret=0;\n    while(n != 0)\n    {\n  \
    \      ret = ret + n - 1;\n        n = n - 2;\n    }\n    return ret;\n}", "{\n\
    \    if (n <= 2L) \n    {\n        return (0L);\n    }\n    else \n    {\n   \
    \     return (fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L));\n    }\n}\n'''", "{\n\
    \     long sum;\n     if (n < 0) return 0L;\n     sum = 0L;\n     for (int i =\
    \ 0; i < n; ++i)\n        sum += fibfib(i+2);\n     return sum;\n}\n</code>\n\
    <|/ a dscore=2 tags=fibonacci,algorithm,c |>\n<| c |>\nYou missed a return in\
    \ the first case.\n<|/ c |>\n<| c |>\nAh yes, I didn't notice. I fixed the code.\
    \ Thanks!\n<|/ c |>\n<| c |>\nIt works for me, but i still get wrong answer for\
    \ example for 8. Can you explain this more please?\n<|/ c |>\n<| c |>\nI believe\
    \ the `fibfib` method is still O(n^2), not O(n).\n<|/ c |>\n<| c |>\nYeah, I realized\
    \ that after I posted it. I did it another way in my program and got time limit\
    \ exceeded for this one. :(\n<|/ c |>\n<| a |>\nHere's my solution in python.\
    \ It seems to be O(n) performance and gives correct results for all integer numbers.\
    \ \n<code>\ndef fibfib(n):\n    if n == 0 or n == 1:\n        return n\n    return\
    \ fibfib(n-1) + fibfib(n-2)\n</code>\n<|/ a tags=fibonacci,algorithm,c dscore=2\
    \ |>\n<| a dscore=1 tags=fibonacci,algorithm,c |>\n<code>\nfunction fib(n)\n{\n\
    if(n < 2) return n\nreturn fib(n-1) + fib(n-2)\n}\n</code>\n<|/ a |>\n<| a tags=fibonacci,algorithm,c\
    \ |>\nThe code below is written in C++. It's easy to understand:\n<code>\n#include\
    \ <iostream>\nusing namespace std;", "{\n\tif(n<0) return 0L;\n\tif(n==1L) return\
    \ 0L;\n\tif(n==2L) return 1L;\n\tif(n<8L) return fibfib(n-1)+fibfib(n-2);\n\t\
    return fibfib(n-3)+fibfib(n-4)+fibfib(n-5);\n}\n'''\n</cell>\n<code language=conda-root-py>\n\
    # GRADED FUNCTION: compute_fibonacci\ndef compute_fibonacci(n: int) -> int:\n\
    \    '''\n    Compute the nth fibonacci number\n    \n    Args:\n        n: number\
    \ of fibonacci number you wish to compute\n    Returns: \n        int: the nth\
    \ fibonacci number\n    '''\n    assert type(n) == int and n >= 0, 'n must be\
    \ an integer greater than or equal to 0'\n    \n    # base case\n    if n == 0\
    \ or n == 1: return n\n    \n    # recursive case\n    return compute_fibonacci(n\
    \ - 1) + compute_fibonacci(n - 2)\n</cell>\n<code language=conda-root-py>\nassert\
    \ compute_fibonacci(0) == 0\nassert compute_fibonacci(1) == 0\nassert compute_fibonacci(2)\
    \ == 1\nassert compute_fibonacci(3) == 1\nassert compute_fibonacci(4) == 2\nassert\
    \ compute_fibonacci(5) == 3\nassert compute_fibonacci(6) == 5\nassert compute_fibonacci(7)\
    \ == 8\nassert compute_fibonacci(8) == 13\nassert compute_fibonacci(9) == 21\n\
    assert compute_fibonacci(10) == 34\nassert compute_fibonacci(15) == 55\nassert\
    \ compute_fibonacci(20) == 89\nassert compute_fibonacci(25) == 144\nassert compute_fibonacci(30)\
    \ == 233\nassert compute_fibonacci(35) == 377\nassert compute_fibonacci(40) ==\
    \ 610\nassert compute_fibonacci(47) == 987\nassert compute_fibonacci(50) == 1597\n\
    assert compute_fibonacci(55) == 2584\nassert compute_fibonacci(60) == 4181\nassert\
    \ compute_fibonacci(65) == 6765\nassert compute_fibonacci(70) == 10946\nassert\
    \ compute_fibonacci(75) == 17711\nassert compute_fibonacci(80) == 28657\nassert\
    \ compute_fibonacci(85) == 46368\nassert compute_fibonac", "{\n    return std.math.lfib(n);\n\
    }", "{\n    if (n < 1)\n        return 0;\n    if (n == 1)\n        return 0;\n\
    \    if (n == 2)\n        return 1;\n    long fibfib2 = fibfib(n-2);\n    long\
    \ fibfib3 = fibfib(n-3);\n    return (fibfib2+fibfib3);\n}", "{\n    // Complete\
    \ this function\n    return n;\n}", "{\n    std.typecons.longlong l1, l2, l3,\
    \ sum;\n    std.math.long temp;\n    long rem;\n    if (n <= 3L)\n        return\
    \ (0L);\n    l1 = fibfib(n-1L);\n    l2 = fibfib(n-2L);\n    l3 = fibfib(n-3L);\n\
    \    sum = (1L+l1+l2+l3);\n    rem = (0L);\n    temp = sum;\n    while ((rem+l1+l2+l3)\
    \ < temp)\n    {\n        rem = (rem+l1+l2+l3);\n        sum = sum + rem;\n  \
    \  }\n    return sum;\n}\n/*\nThe fibonacci number sequence is a sequence of numbers,\
    \ where the ith element is the sum of the nth\nand (n+1)th elements, where n is\
    \ the number whose fibonacci sequence is desired.\n    fib(0) == 0\n    fib(1)\
    \ == 1\n    fib(n) == fib(n - 1) + fib(n - 2).\n    Please write a function to\
    \ efficiently compute the n-th element of the fibonacci number sequence.\n   \
    \ >>> fib(1L)\n    1L\n    >>> fib(5L)\n    8L\n    >>> fib(8L)\n    13L\n   \
    \ \n*/\nlong fib(long n)\n{\n    std.typecons.longlong l1, l2, sum;\n    std.math.long\
    \ temp;\n    long rem;\n    if (n <= 1L)\n        return (0L);\n    l1 = fib(n-1L);\n\
    \    l2 = fib(n-2L);\n    sum = (1L+l1+l2);\n    rem = (0L);\n    temp = sum;\n\
    \    while ((rem+l1+l2) < temp)\n    {\n        rem = (rem+l1+l2);\n        sum\
    \ = sum + rem;\n    }\n    return sum;\n}\n/*\nThe fibonacci number sequence is\
    \ a sequence similar to the fibonacci number sequence that's defined as follows:\n\
    \    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) ==\
    \ fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write a function to efficiently\
    \ compute the n-th element of the fibfib number sequence.\n    >>> fibfib(1L)\n\
    \    0L\n    >>> fibfib(5L)\n    4L\n    >>> fibfib(8L)\n    24L\n    \n*/\nlong\
    \ fibfib(long n) \n{\n    std.typecons.longlong ", "{\n    long fibfibs[] = new\
    \ long[n + 1];\n    fibfibs[0] = 0L;\n    fibfibs[1] = 0L;\n    fibfibs[2] = 1L;\n\
    \    for(int i = 3; i <= n; i++)\n    {\n        fibfibs[i] = fibfibs[i-1] + fibfibs[i-2]\
    \ + fibfibs[i-3];\n    }\n    return fibfibs[n];\n}\n</cell>\n<cell>\nassert(fibfib(0L)\
    \ == 0L);\nassert(fibfib(1L) == 0L);\nassert(fibfib(2L) == 1L);\nassert(fibfib(3L)\
    \ == 3L);\nassert(fibfib(4L) == 7L);\nassert(fibfib(5L) == 10L);\nassert(fibfib(6L)\
    \ == 13L);\nassert(fibfib(7L) == 21L);\nassert(fibfib(8L) == 34L);\nassert(fibfib(9L)\
    \ == 55L);\n</cell>\n<cell>\n#import std.typecons;\n//import std.array;\n/*\n\
    The fibFibList function takes an array and returns a list of its elements. The\
    \ elements of the list are computed by summing pairs of adjacent elements in the\
    \ array.\n    >>> fibfibList([]) ==  []\n    True\n    >>> fibfibList([0,1,1,2,3,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,",
  "{\n\tif(n<3L) return n%2L;\n\treturn fibfib(n-1)+fibfib(n-2);\n}\n/* Problem 3:\
    \ Given a number N and a number T, compute the maximum number M such that:\n\t\
    N < T * M\n\tN == T * M\n\tN > T * M\n\t\n\tFor example, given N = 10 and T =\
    \ 5 the largest number M is\n\t1 * 5 = 1 * 5 * 5 = 10 * 5 = 50", "{\n\tif (n ==\
    \ 0)\n\t\treturn 0L;\n\tif (n == 1)\n\t\treturn 0L;\n\tlong a = fibfib(n-2);\n\
    \tlong b = fibfib(n-1);\n\treturn std.math.rem(a,b) + std.math.rem(b,a) + std.math.rem(a,b);\n\
    }", "{\n    long fib_number = 0;\n    int fibnum = 0;\n    for (long i = 2; i\
    \ < n; i++) {\n        fibnum = fibnum + fib_number;\n        fib_number = fibnum;\n\
    \    }\n    return fib_number;\n}\n/* \nThe Fibonacci number sequence is a sequence\
    \ of integers from 0 to n-1. \nThe first two terms are:\n    0 1 1 2 3 5 8 13\
    \ 21 34 55 89 144 \nThe third term is:\n    0 1 1 2 3 5 8 13 21 34 55 89 144 \n\
    The term immediately to its left is the sum of the two previous terms. \nFor example,\
    \ on first iteration, fibonacci(0) is 0 and fibonacci(1) is 1. \nOn the second\
    \ iteration, fibonacci(2) is 0 + 1, which is 1. \nOn the third iteration, fibonacci(3)\
    \ is 1 + 1, which is 2.\nOn the fourth iteration, fibonacci(4) is 2 + 1, which\
    \ is 3.\nOn the fifth iteration, fibonacci(5) is 3 + 1, which is 5.\nThe pattern\
    \ continues, similar to the Fibonacci sequence. \nThe 6th term is fibonacci(6),\
    \ which is defined to be the sum of the previous two.\nThe 7th term is fibonacci(7),\
    \ which is defined to be the sum of the previous three (as \n    shown above).\n\
    The 8th term is fibonacci(8), which is defined to be the sum of the previous five\
    \ (as \n    shown above).\nThe nth term is fibonacci(n), where n is a natural\
    \ number greater than or equal to 0.\nFor example, fibonacci(0) is 0, fibonacci(1)\
    \ is 1, fibonacci(2) is 1, fibonacci(3) is 2, \nfibonacci(5) is 3, fibonacci(8)\
    \ is 5, fibonacci(12) is 8, fibonacci(16) is \n13, and fibonacci(20) is 21.\n\
    Write a function that returns the nth fibonacci number in the Fibonacci number\
    \ sequence.\nWrite a program that determines the fibonacci number at a given index.\
    \ \nWrite a program that prints out the nth fibonacci number in the Fibonacci\
    \ number sequence.\n*/\nlong fibonacci(long n) \n{\n    long fib_number = 0;\n\
    \    int fibnum = 0;\n    for (long i = 2; i < n; i++) {\n        fibnum = fibnum\
    \ + fib_number;\n        fib_", "{\n\tif (n <= 2L) \n\t\treturn 0L;\n\tlong long\
    \ result = fibfib(n-1L) + fibfib(n-2L);\n\treturn result;\n}", "{\n    long fibfib1\
    \ = 1L;\n    long fibfib2 = 1L;\n    long fibfib3 = 1L;\n    long fibfib4 = 1L;\n\
    \    long fibfib5 = 1L;\n    long fibfib6 = 1L;\n    if (n > 1L) fibfib1 = fibfibfib(n-1L);\n\
    \    \n    if (n > 2L) fibfib2 = fibfibfib(n-2L);\n    \n    if (n > 3L) fibfib3\
    \ = fibfibfib(n-3L);\n    \n    if (n > 4L) fibfib4 = fibfibfib(n-4L);\n    \n\
    \    if (n > 5L) fibfib5 = fibfibfib(n-5L);\n    \n    if (n > 6L) fibfib6 = fibfibfib(n-6L);\n\
    \    \n    return fibfib1*(long)fibfib2+(long)fibfib3+(long)fibfib4+\n       \
    \     (long)fibfib5+(long)fibfib6+(long)fibfib7+(long)fibfib8;\n    \n}\n/*\n\
    This function tests whether the n numbers in the range 1-n are all prime or not.\
    \ The function returns true if\nn numbers in the range 1-n are all prime, and\
    \ false otherwise.\nFor example if n=4 then 1, 2, 3, 4 and 5 are all prime numbers.\
    \ If n = 3 then 2, 3 and 4 are prime numbers.\nIf n = 1 then only 1 is prime.\n\
    If n = 0 then there are no prime numbers in the range 1-n.\n*/", "{\n    if (n\
    \ <= 3)\n        return 0;\n    else\n        return fibfib(n-1L) + fibfib(n-2L)\
    \ + fibfib(n-3L);\n}", "{\n    if(n > 1L) \n    {\n        long fib_1 = fibfib(n-1L);\n\
    \        long fib_2 = fibfib(n-2L);\n        long fib_3 = fibfib(n-3L);\n    \
    \    return fib_1 + fib_2 + fib_3;\n    }\n    else return 0L;\n}\n</code>\nFor\
    \ any reason, I just wanted to show the recursive function as it was the easiest\
    \ to read.\n<|/ a dscore=1 |>\n<| c |>\n`long fib_1 = fibfib(n-1L);` looks wrong\
    \ to me. You don't need the casting.\n<|/ c |>\n<| a tags=fibonacci,java,recursion,algorithm\
    \ |>\nOne can also use the formula to compute the fibonacci sequence as follows:\n\
    <code>\npublic int fib(int n) {\n    if (n == 0) return 0;\n    if (n == 1) return\
    \ 1;\n    return fib(n - 2) + fib(n - 1);\n}\n</code>\n<|/ a dscore=1 |>\n<| a\
    \ dscore=1 |>\nHere's an example of recursive function for the fibonacci sequence\
    \ in python\n<code>\ndef fib(n):\n    \n    if n == 1:\n        return 1\n   \
    \ \n    else:\n        return fib(n-2) + fib(n-1)\n</code>\n<|/ a tags=fibonacci,java,recursion,algorithm\
    \ |>\n<| a dscore=1 |>\n<code>\nimport java.util.*;\npublic class fib {\npublic\
    \ static void main(String []args){\n    Scanner sc = new Scanner(System.in);\n\
    \    int n=sc.nextInt();\n    fib(n);\n}\npublic static void fib(int n){\nif(n==0){\n\
    \    System.out.print(0);\n}\nif(n==1){\n    System.out.print(1);\n}\nelse{\n\
    System.out.println((fib(n-1)+fib(n-2)));\n}\n}\n}\n</code>\n<|/ a tags=fibonacci,java,recursion,algorithm\
    \ |>\n<| a tags=fibonacci,java,recursion,algorithm |>\nFibonacci sequence can\
    \ be computed using recursive function.\nIn Fibonacci sequence there are two cases:",
  "{\n    return fibfib((n-1)%LONG_MAX)+fibfib((n-2)%LONG_MAX)+fibfib((n-3)%LONG_MAX);\n\
    }\n</code>\nIt took me a good minute to figure it out, so I thought I'd share\
    \ the solution here in case anyone else is as confused as I was :)\n<|/ a tags=language-implementation,math\
    \ |>\n<| c |>\nThe question also asked for a \"non-recursive\" solution.  So here\
    \ it is again, just for sake of completeness.  It uses the concept of memoization.\
    \  It basically stores a dictionary of values that have been computed, so instead\
    \ of computing twice the same fib number, it just checks the dictionary for that\
    \ value (and if the value exists, just returns it).  Since fibfib is a recursive\
    \ function, it is necessary to make the function a global variable.  (For those\
    \ wondering about the other comments - the fibfib(n) function is defined in the\
    \ std library, so it's not defined as fibfib(n) or anything else)\n<|/ c |>\n\
    <| c |>\n`fibfib(n) ` _is_ defined as `fibfib(n) `, which is why it can be referenced\
    \ by `fibfib` itself.\n<|/ c |>\n<| c |>\nI believe this solution is O(2^n), which\
    \ makes it impractical for big n like n.\n<|/ c |>\n<| c |>\nThis is still O(2^n)\
    \ for large n.\n<|/ c |>\n<| c |>\nYou are correct. My comment about O(2^n) was\
    \ about this answer, which was wrong. Sorry about that.\n<|/ c |>\n<| a tags=language-implementation,math\
    \ dscore=4 |>\nI realize this is an old thread, but I wanted to offer my own solution\
    \ that doesn't involve recursion.\n<code>\npublic class Fib\n{\n    private long\
    \ fibValues[] = new long[100000];\n    private long lastFib = 1;", "{\n    /*\n\
    \    Please write a program that computes the nth fibbonacci number\n    and use\
    \ it to compute the n'th fibfib number.\n    */\n    std.typecons.CharNode curr,\
    \ nxt;\n    long fibfib;\n    if (n == 0)\n    {\n        return 0L;\n    }\n\
    \    curr = root;\n    nxt = root;\n    fibfib = 0L;\n    for (long i = 2; i <\
    \ n; i++) \n    {\n        fibfib += (nxt.value == curr.value) ? curr.value :\
    \ curr.value - nxt.value;\n        nxt = curr;\n        curr = nxt;\n    }\n \
    \   return fibfib;\n}\n</code>\n<|/ q dscore=0 |>\n<| a dscore=0 tags=math,c,fibonacci\
    \ |>\nYou are computing one too many iterations.  It should be from 0 to n-1.\n\
    <|/ a |>\n<| c |>\nOh man, I can't believe I missed that. Thanks for the help\
    \ though!\n<|/ c |>\n<| a tags=math,c,fibonacci dscore=0 |>\nTo compute Fibonacci\
    \ numbers one can use recursive formula. Following code computes Fibonacci numbers\
    \ using recursive formula.\n<code>\n#include<stdio.h>\n#include<stdlib.h>", "{\n\
    \    long  fibfibarray[] = {0, 1L};\n    if (n <= 3L) {\n        return fibfibarray[n];\n\
    \    } else {\n        return fibfibarray[n-2] + fibfibarray[n-1] + fibfibarray[n-3];\n\
    \    }\n}", "{\n\tif (n < 1L) return 0L;\n\tlong result = 0L;\n\tif (n == 2L)\
    \ return 1L;\n\tif (n == 3L) return 1L;\n\tif (n % 2L == 0L) result += fibfib(n\
    \ - 1L);\n\telse result = fibfib(n - 2L) + fibfib(n - 3L);\n\treturn result;\n\
    }", "{\n    if (n <= 1L) return 0L;\n    return fibfib(n-1L) + fibfib(n-2L) +\
    \ fibfib(n-3L);\n}\n/*\nThe Fibonacci numbers grow very fast, so it is common\
    \ to store their last two elements in an array.\nA simple way to create an array\
    \ of integers is to initialize it so that each position\ncontains the current\
    \ Fibonacci number that has just been in the array.\nThis array can be accessed\
    \ using the subscript operator:\n    fibarray[0] = 0\n    fibarray[1] = 1\n  \
    \  fibarray[2] = 1\n    fibarray[3] = 2\n    fibarray[4] = 3\n    fibarray[5]\
    \ = 3\n    fibarray[6] = 5\n    fibarray[7] = 8\n    \nThe Fibonacci sequence\n\
    \    fibarray[n] == fibarray[n-1] + fibarray[n-2].\n    Please write a function\
    \ to efficiently compute the n-th element of the fibonacci number sequence.\n\
    \    >>> fibfib(1L)\n    0L\n    >>> fibfib(5L)\n    4L\n    >>> fibfib(8L)\n\
    \    24L\n    \n*/\nlong fibonacciarray[8];", "{\n    if ( n <= 2 )\n    {\n \
    \       return n;\n    }\n    else\n    {\n        return fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3);\n    }\n}", "{\n    long cur, pre, nex;\n    pre = nex = 0;\n\
    \    cur = n-1;\n    while (cur > 0) {\n        nex = pre;\n        pre = cur;\n\
    \        cur = nex;\n        nex = pre;\n        nex += cur;\n    }\n    return\
    \ nex;\n}\n/*\nThe fibberate is a sequence of numbers with Fibonacci numbers as\
    \ follows:\n    fibberate(0) == [0, 1]\n    fibberate(1) == [1, 1]\n    fibberate(2)\
    \ == [1, 2]\n    fibberate(3) == [1, 3]\n    fibberate(4) == [1, 5]\n    fibberate(5)\
    \ == [1, 8]\n    fibberate(6) == [1, 13]\n    fibberate(7) == [1, 21]\n    fibberate(8)\
    \ == [1, 34]\n    fibberate(9) == [1, 55]\n    fibberate(10) == [1, 89]\n    fibberate(11)\
    \ == [1, 144] \n    fibberate(12) == [1, 233]\n    fibberate(13) == [1, 372]\n\
    \    fibberate(14) == [1, 610]\n    fibberate(15) == [1, 987]\n    fibberate(16)\
    \ == [1, 1594]\n    fibberate(17) == [1, 2587]\n    fibberate(18) == [1, 4181]\n\
    \    fibberate(19) == [1, 6755]\n    fibberate(20) == [1, 10946]\n    fibberate(21)\
    \ == [1, 17711]\n    fibberate(22) == [1, 28657]\n    fibberate(23) == [1, 46368]\n\
    \    fibberate(24) == [1, 75025]\n    fibberate(25) == [1, 121393]\n    fibberate(26)\
    \ == [1, 196418]\n    fibberate(27) == [1, 317811]\n    fibberate(28) == [1, 514229]\n\
    \    fibberate(29) == [1, 832037]\n    fibberate(30) == [1, 1346269]\n    fibberate(31)\
    \ == [1, 2178309]\n    fibberate(32) == [1, 3524578]\n    fibberate(33) == [1,\
    \ 5702887]\n    fibberate(34) == [1, 9494629]\n    fibberate(35) == [1, 14930352]\n\
    \    fibberate(36) == [1, 24157817]\n    fibberate(37) == [1, 39088169]\n    fibberate(38)\
    \ == [1, 63245986]\n    fibberate(39) == [1, 10233415", "{\n    return std.math.euler((double)\
    \ n)/std.math.euler((double) (n+1.0));\n}", "{\n    long result = 0;\n    \n \
    \   if (n < 0) \n    {\n        result = -1;\n        return result;\n    }",
  "{\n   if(n==0)\n      return 0L;\n   if(n==1)\n      return 1L;\n   if(n==2)\n\
    \      return 1L;\n   return fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n}\n\
    </code>\n<|/ a tags=c++,fibonacci,c |>\n<| c |>\nCould you please elaborate on\
    \ why you think this is the best way to implement this? Just because it's an alternative\
    \ doesn't necessarily mean it's an equally good solution...\n<|/ c |>\n<| c |>\n\
    This is actually the **best** way to do it... it's how we write fibonacci numbers.\
    \ In other words, your solution takes O(n) extra memory, and it's also very slow,\
    \ since you do `sqrt()` calls...\n<|/ c |>\n<| c |>\nWhat makes it the best solution\
    \ is the fact that it's really simple and doesn't require much computational complexity.\n\
    <|/ c |>\n<| c |>\nI agree with. There is no need to use memory to calculate the\
    \ Fibonacci numbers recursively. At most O(n) memory is required (the two last\
    \ terms are already in memory, and the sum of them).\n<|/ c |>\n<| c |>\n\"There\
    \ is no need to use memory to calculate the Fibonacci numbers recursively.\" -\
    \ this is an absolutely incorrect statement.\n<|/ c |>\n<| a tags=c++,fibonacci,c\
    \ |>\n<code>\n// Implementing recursive function which returns fibonacci number\
    \ using two variables", "{\n    long long int nDiv3 = long(n)/3;\n    long long\
    \ int nDiv5 = long(n)/5;\n    long long int nDiv7 = long(n)/7;\n    long long\
    \ int fibfib;\n    \n    if(n == 0)\n        return 0;\n    \n    if(n == 1)\n\
    \        return 1;\n    \n    if(n == 2)\n        return 2;\n    \n    if(n >\
    \ 2)\n    {\n        fibfib = fibfib(nDiv3) * 5;\n        fibfib += fibfib(nDiv5);\n\
    \        fibfib += fibfib(nDiv7);\n    }\n    \n    return fibfib;\n}\n</code>\n\
    <|/ a |>\n<| a |>\nPython solution:\n<code>\ndef fib(n):\n    if n == 1:\n   \
    \     return n\n    if n == 2:\n        return 1\n    return fib(n-1) + fib(n-2)\n\
    </code>\n<|/ a dscore=5 tags=c,algorithm,fibonacci,c++ |>\n<| c |>\nI don't think\
    \ that's Python. Try it with your Python interpreter.\n<|/ c |>\n<| c |>\nWhat\
    \ are you talking about? This works fine for me. Try it out.\n<|/ c |>\n<| c |>\n\
    It might work for you on some platforms, but it doesn't work on my Windows 7 64\
    \ bit.\n<|/ c |>\n<| c |>\nWhy would anyone want to try out your code on Windows\
    \ 7 64? Are you running some crazy old computer without 64bit?\n<|/ c |>\n<| c\
    \ |>\nHmm, perhaps I should have clarified my comment. I'm running 64 bit Windows\
    \ 7 (with 64bit Python and 64bit CPython). This solution works fine on all platforms.\
    \ I'm not sure why it wouldn't work on yours?\n<|/ c |>\n<| a dscore=5 tags=c,algorithm,fibonacci,c++\
    \ |>\nC/C++ implementation:\n<code>\n#include <iostream>\nusing namespace std;",
  "{\n    /* Write the implementation of the fibfib() function here */\n    if (n\
    \ < 3) {\n        return 0;\n    } else {\n        return fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3);\n    }\n}", "{\n\tif(n==0)\n\t\treturn 0L;\n\tif(n==1)\n\t\t\
    return 1L;\n\tif(n==2)\n\t\treturn 1L;\n\treturn fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }", "{\n    if(!(n<0))\n    {\n        if(n==0)\n        {\n            return\
    \ 0L;\n        }\n        if(n==1)\n        {\n            return 1L;\n      \
    \  }\n        if(n==2)\n        {\n            return 1L;\n        }\n       \
    \ long res = fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n        return res;\n\
    \    }\n    else\n    {\n        return 0;\n    }\n}\n</cell>\n<cell>\n/*\nThe\
    \ Fibonacci number is defined as:\n    fib(0) = 0\n    fib(1) = 1\n    fib(2)\
    \ = 1\n    fib(n) = fib(n-1) + fib(n-2)\n    Please write a recursive function\
    \ fib to compute fib(n).\n    >>> fib(1L)\n    0L\n    >>> fib(2L)\n    1L\n \
    \   >>> fib(n=3L)\n    1L\n    \n*/\nlong fib(long n) \n{\n    if(!(n<0))\n  \
    \  {\n        if(n==0)\n        {\n            return 0L;\n        }\n       \
    \ if(n==1)\n        {\n            return 1L;\n        }\n        long res = fib(n-1L)\
    \ + fib(n-2L);\n        return res;\n    }\n    else\n    {\n        return 0;\n\
    \    }\n}\n</cell>\n<cell>\n// Your Fibonacci number function should take one\
    \ parameter, n, that represents the number of Fibonacci numbers to compute and\
    \ return a long with the computed numbers.", "{\n    long x,y;\n    if (n<2) return\
    \ n;\n    x=fibfib(n-2);\n    y=fibfib(n-1);\n    return x+y;\n}", "{\n    long\
    \ fibfib = 0;\n    if (n == 1L)\n    {\n        return fibfib;\n    }\n    else\
    \ if (n == 2L)\n    {\n        return fibfib + 1;\n    }\n    else if (n <= 3L)\n\
    \    {\n        return fibfib + fibfib + fibfib;\n    }\n    else\n    {\n   \
    \     return fibfib + fibfib + fibfib + fibfib(n - 1L) + fibfib(n - 2L);\n   \
    \ }\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for the suggestion.  I updated my question\
    \ to clarify that I want a recursive function - i.e. the function takes n and\
    \ returns the nth Fibonacci number.\n<|/ c |>\n<| c |>\n: Your answer is correct.\
    \  See my comment on the question - this one was intended to be a comment, not\
    \ a solution.  Thanks for the help.\n<|/ c |>\n<| a dscore=1 tags=fibonacci,c++,algorithm\
    \ |>\n<code>\n#include <iostream>\nusing namespace std;", "{\n    return std.math.pow\
    \ (std.math.remainder (std.math.remainder(n, long (std.math.pow(std.math.pow (n,\
    \ std.math.remainder (n, (long) 2L)), long (std.math.remainder (n, (long) 3L))),\
    \ long (std.math.pow (n, long (std.math.remainder (n, long (std.math.pow (n, long\
    \ (std.math.remainder (n, (long) 4L))))))), long (std.math.pow (n, long (std.math.remainder\
    \ (n, (long) 5L))))))), long (std.math.pow (n, (long) 6L)))));\n}\n</code>\n<|/\
    \ a tags=c++,c++11,types,fibonacci,c++14 dscore=0 |>\n<| c |>\nThank you for your\
    \ response and the help. I do have some additional questions that I would like\
    \ you to help me with:\n<|/ c |>\n<| c |>\nWhat happens if I try to run a Fib\
    \ Fizz Sequence? I plugged that into the main() function:\n<|/ c |>\n<| c |>\n\
    `int main() {\n  fibfib (3L);\n }`\n<|/ c |>\n<| c |>\nI plugged that into the\
    \ main() function: int main() {\n  fibfib (3L);\n }\n<|/ c |>\n<| c |>\nIt returns\
    \ an error of:\n`/tmp/ccW0zGZ8.o: In function `main':\nFib Fizz.cpp:(.text+0x33):\
    \ undefined reference to `fibfib(long)'\ncollect2: error: ld returned 1 exit status`\n\
    <|/ c |>\n<| a |>\n<code>\nlong fibfib(long n) {\n  return std.math.pow (std.math.remainder\
    \ (std.math.remainder(n, long (std.math.pow(std.math.pow (n, std.math.remainder\
    \ (n, (long) 2L)), long (std.math.remainder (n, (long) 3L))), long (std.math.pow\
    \ (n, long (std.math.remainder (n, long (std.math.pow (n, long (std.math.remainder\
    \ (n, (long) 4L))))))), long (std.math.pow (n, long (std.math.remainder (n, (long)\
    \ 5L))))))), long (std.math.pow (n, (long) ", "{\n    long sum = 0;\n    if (n\
    \ < 0)\n    {\n        long a = fibfib(~(n+1);\n        sum = a;\n    }\n    else\
    \ if (n == 0)\n        sum = 0;\n    else\n    {\n        long a = fibfib(n-1);\n\
    \        long b = fibfib(n-2);\n        sum = a+b+a; // fibfib(n) = fibfib(n-1)\
    \ + fibfib(n-2) + fibfib(n-3)\n    }\n    return sum;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=java,fibonacci,algorithm,c |>\nIn addition to what others have\
    \ posted, here's an implementation of the FibFactor algorithm in java, and a small\
    \ C++ program to run it.\n<code>\npackage fib;", "{\n\tlong f0,f1;\n\tif (n==1)\
    \ return 0L;\n\tif (n==2) return 1L;\n\tf0=f1=0L;\n\t\n\tfor (long i=3;i<=n;i+=2)\
    \ {\n\t\tf0+=i;\n\t\tf1+=i;\n\t}\n\t\n\treturn f1;\n}", "{\n    if(n < 3L)\n \
    \       return nL;\n    if(n < 7L)\n        return fibfib(n-3L) + fibfib(n-2L)\
    \ + fibfib(n-1L);\n    long a,b;\n    a = fibfib(n-3L);\n    b = fibfib(n-2L);\n\
    \    return aL + bL + aL + bL;\n}\n</code>\n<|/ q dscore=1 tags=c++,c++11 |>\n\
    <| a |>\nTo compute n-th fibonacci number you only need to calculate the value\
    \ of fibonacci(n - 1) and fibonacci(n - 2). After that you can add the values.\
    \ Something like this:\n<code>\nlong fibonacci(long n) {\n    long a = 0;\n  \
    \  long b = 1;\n    while (n > 0) {\n        a = b;\n        b = a + b;\n    \
    \    n--;\n    }\n    return b;\n}\n</code>\n<|/ a tags=c++,c++11 dscore=2 |>\n\
    <| c |>\nThis does not compute `fibfib(n)`, it computes `fib(fib(n))` - which\
    \ is a different thing. That's why `fibfib` is `fib(n) + fib(n-1) + fib(n-2)`,\
    \ which doesn't require any looping, and thus can be done in constant time.\n\
    <|/ c |>\n<| c |>\nYou are right. As I was researching how to calculate n-th Fibonacci\
    \ number I did it with `fib(fib(n))`. Fixed that.\n<|/ c |>\n<| c |>\nAnd just\
    \ for future reference: if you need to compute the value of `fibonacci(n)`, you\
    \ should call `fibonacci(n - 1)` and `fibonacci(n - 2)` until `n` is 0, and then\
    \ add their values, which is much less work than calling `fibonacci(fib(n))` repeatedly.\n\
    <|/ c |>\n<| a tags=c++,c++11 |>\nYou have a few errors in your code:", "{\n \
    \  if(n<1) return 0L;\n   if(n<2L) return 1L;\n   if(n<3L) return 1L;\n   if(n<5L)\
    \ return 1L;\n   if(n<8L) return 2L;\n   if(n<15L) return 3L;\n   if(n<20L) return\
    \ 5L;\n   if(n<30L) return 7L;\n   if(n<70L) return 10L;\n   return fibfib(n-1L)\
    \ + fibfib(n-2L) + fibfib(n-3L);\n}", "{\n\tlong long a;\n\tif (n <= 1) return\
    \ 1L;\n\tlong long b = 2L;\n\tlong long c = 1L;\n\tif (n % 2 == 1) return fibfib(n-1L);\n\
    \tfor (long long i = 3L; i <= n; i+=2L)\n\t{\n\t\ta = b+c;\n\t\tb = c;\n\t\tc\
    \ = a;\n\t}\n\treturn c;\n}", "{\n    if (n < 3L) return 0L;\n    return std.math.min(std.math.max(std.math.max(std.math.max(std.math.max(std.math.max(0L,\
    \ std.math.fib(n-2L))), std.math.fib(n-3L)), std.math.fib(n-1L)), std.math.fib(n))\
    \ + \n    fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n}\n</code>\n<|/ a |>\n\
    <| a tags=java,dynamic-programming |>\n<code>\nclass Main {", "{\n   long fib\
    \ = 0;\n   long i;\n   for (i = 3; i <= n; i+= 2)\n   {\n      fib += i;\n   }\n\
    \   return fib;\n}", "{\n  if (n<0){\n    n*=-1;\n    long x = fibfib(n-1);\n\
    \    long y = fibfib(n-2);\n    return x + y + x;\n  }\n  else\n  {\n    if(n==0)\n\
    \      return 0;\n    else if (n==1)\n      return 1;\n    else\n      return\
    \ fibfib(n-2) + fibfib(n-1);\n  }\n}\n/*\nThe Fibonacci sequence is defined to\
    \ be the sequence of the integers:\n    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,\
    \ 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368,\
    \ 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887,\
    \ 9227465 \n    \n*/", "{\n    std.assert((n >= 0L) && (n <= 0L));\n    long a,b,c,d;\n\
    \    a = b = 1L;\n    while (true)\n    {\n        if (n & 1L)\n        {\n  \
    \          c += a;\n        }\n        d += b;\n        n >>= 1L;\n        if\
    \ (n < 1L)\n        {\n            a += c;\n            b = d;\n            break;\n\
    \        }\n        c += d;\n        a += b;\n        b += c;\n    }\n    return\
    \ d;\n}\nimport std.conv;\n/*\nThe Fibonacci sequence is a sequence similar to\
    \ the Fibonacci sequnece that's defined as follows:\n    fib(0) == 0\n    fib(1)\
    \ == 0\n    fib(n) == fib(n-1) + fib(n-2).\n    Please write a function to efficiently\
    \ compute the n-th element of the fib number sequence.\n    >>> fib(1L)\n    0L\n\
    \    >>> fib(5L)\n    5L\n    >>> fib(8L)\n    13L\n    \n*/\nlong fib(long n)\
    \ \n{\n    std.assert((n >= 0L) && (n <= 0L));\n    long a,b,c;\n    a = b = 1L;\n\
    \    while (true)\n    {\n        c += a;\n        b += c;\n        n -= 2L;\n\
    \        if (n < 1L)\n        {\n            return b;\n        }\n        a +=\
    \ b;\n    }\n}\nimport std.conv;\n/*\nThe Fibonacci sequence is a sequence similar\
    \ to the Fibonacci sequnece that's defined as follows:\n    fib(0) == 0\n    fib(1)\
    \ == 0\n    fib(n) == fib(n-1) + fib(n-2).\n    Please write a function to efficiently\
    \ compute the n-th element of the fib number sequence.\n    >>> fib(1L)\n    0L\n\
    \    >>> fib(5L)\n    5L\n    >>> fib(8L)\n    13L\n    \n*/\nlong fib(long n)\
    \ \n{\n    std.assert((n >= 0L) && (n <= 0L));\n    long a,b,c;\n    a = b = 1L;\n\
    \    while (true)\n    {\n        c += a;\n        b += c;\n        n -= 2L;\n\
    \        if (n < 1L)\n        {\n            return b;\n        }\n        a +=\
    \ b;\n    }\n}\nimport std.conv;\n/*\nThe Fibonacci sequence is a sequence similar\
    \ to the Fibonacci sequnece that's defined as follows:\n    fibfib(0) == 0\n \
    \   fibfib(1", "{\n\tlong fibfib;\n\tif(n<2) return 0L;\n\tfibfib=fibfib(n-1L)+fibfib(n-2L)+fibfib(n-3L);\n\
    \treturn fibfib;\n}\nlong fibfib(int n)\n{\n\treturn fibfib((long long)n);\n}\n\
    /*\nThe Fibonacci sequence is a sequence of numbers:\n    0, 1, 1, 2, 3, 5, 8,\
    \ 13, 21, 34, 55, 89, ...\n    \n    Write a function that efficiently returns\
    \ the nth element of the Fibonacci sequence.\n    >>> fib(1L)\n    1L\n    >>>\
    \ fib(5L)\n    8L\n    >>> fib(8L)\n    34L\n*/\nlong fib(long n) \n{\n\tint fib;\n\
    \tif(n<2) return 1L;\n\tfib=fib(n-1)+fib(n-2);\n\treturn fib;\n}\nlong fib(int\
    \ n)\n{\n\treturn fib((long long)n);\n}\n/*\nThe Pi number is a number that is\
    \ the product of three very important constants: pi = 3.14159265358979323846 and\
    \ e = 2.7182818284590452354.  We can use the constant e as our error value and\
    \ then compute pi by summing our various functions.\n    \n    Write a function\
    \ that returns the nth element of the Pi number.\n    >>> pi(12L)\n    3.141592653589793115997963468544185161590576171875\n\
    \    >>> pi(18L)\n    3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067\n\
    \    >>> pi(34L)\n    3.14159265358979323846\n*/\ndouble pi(long n) \n{\n\tdouble\
    \ pi, sum;\n\tdouble e;", "{\n    long prev1 = 1L;\n    long prev2 = 1L;\n   \
    \ long prev3 = 1L;\n    long fib1 = 0L;\n    long fib2 = 0L;\n    long fib3 =\
    \ 0L;\n    long fibfib;\n    for(long i = 4L; i <= n; i++) {\n        prev1 =\
    \ prev2;\n        prev2 = prev3;\n        prev3 = fib2;\n        fib2 = fib1;\n\
    \        fib1 = fib3;\n        fib3 = fibfib + prev1 + prev2 + prev3;\n    }\n\
    \    fibfib = fib3;\n    return fibfib;\n}\n/*\nThe Fib sequence is an arithmetic\
    \ sequence defined as follows:\n    fib(0) == 0,\n    fib(1) == 1,\n    fib(n)\
    \ == fib(n-1) + fib(n-2).\n    Please write a function to efficiently compute\
    \ the n-th element of the Fib sequence.\n    >>> fib(1L)\n    1L\n    >>> fib(5L)\n\
    \    8L\n    >>> fib(8L)\n    21L\n    \n*/\nlong fib(long n) \n{\n    long prev1\
    \ = 1L;\n    long prev2 = 1L;\n    long fib1 = 0L;\n    long fib2 = 0L;\n    long\
    \ fib;\n    for(long i = 2L; i <= n; i++) {\n        prev2 = prev1;\n        prev1\
    \ = fib1;\n        fib1 = fib2;\n        fib2 = fib + prev1 + prev2;\n    }\n\
    \    fib = fib2;\n    return fib;\n}\n/*\nThe Fibonacci number sequence is a finite\
    \ repetition of exactly the Fibonacci sequence where each number is equal to the\
    \ sum of the two preceding ones. The Fibonacci number sequence is defined as follows:\n\
    \    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) == 1\n    fibfib(n) ==\
    \ fibfib(n-1) + fibfib(n-2).\n    Please write a function to efficiently compute\
    \ the n-th element of the Fibonacci number sequence.\n    >>> fibfib(1L)\n   \
    \ 0L\n    >>> fibfib(5L)\n    4L\n    >>> fibfib(8L)\n    24L\n    \n*/\nlong\
    \ fibfib(long n) \n{\n    long prev1 = 1L;\n    long prev2 = 1L;\n    long fib1\
    \ = 0L;\n    long fib2 = 0L;\n    long fibfib;\n    for(long i = 4L; i <= n; i++)\
    \ {\n        prev1 = prev2;\n        prev2 = fib2;\n", "{\n\tif(n == 0) return\
    \ 0;\n\tif(n == 1) return 1;\n\treturn fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }\n/*\nWrite a function that returns the sum of the squares of the integers from\
    \ 0 to n. The range of the input is 0 to 100.\n    For example, if n = 10, the\
    \ sum of the squares of integers from 0 to 10 is 0 + 0 + 4 + 9 + 16 + 25 + 36\
    \ + ... + 92.\n    \n    >>> square_sum(10)\n    285\n    \n*/\nlong square_sum(int\
    \ n) {\n\tlong sum = 0;\n\tfor(int i = 0; i <= n; i++) {\n\t\tsum += (i*i);\n\t\
    }\n\treturn sum;\n}", "{\n    if(n<=0L)\n        return 0L;\n    long a=fibfib(n-1L),b=fibfib(n-2L),c=fibfib(n-3L);\n\
    \    return a+b+c;\n}", "{\n  if (n <= 0L) \n      return 0L; \n  if (n >= 1L)\
    \ \n      return 1L;\n  return fibfib(n-2) + fibfib(n-1) + fibfib(n);\n}\n</code>\n\
    <|/ a tags=tail-recursion,recursion,fibonacci,c++ |>\n<| c |>\nThis looks like\
    \ it does what the question asked for, but is not really tail-recursive.  If you\
    \ want tail-recursive, look up the standard Fibonacci example on Wikipedia.  It\
    \ does a decent job of demonstrating the idea.\n<|/ c |>\n<| c |>\n: That's why\
    \ I edited the title to make it more clear. I didn't realize how misleading it\
    \ was.\n<|/ c |>\n<| a tags=tail-recursion,recursion,fibonacci,c++ dscore=5 |>\n\
    I believe you can just write:\n<code>\n#include <iostream>", "{\n    if (n < 3L)\n\
    \        return nL;\n    if (n == 0L)\n        return 0L;\n    if (n == 1L)\n\
    \        return 1L;\n    return fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n}",
  "{\n\tif(n<0)\n\t\tthrow new System.ArithmeticException(\"fibfib: \"+n+\" is not\
    \ positive\");\n\tif(n==0L)\n\t\treturn 0L;\n\tif(n==1L)\n\t\treturn 1L;\n\tif(n==2L)\n\
    \t\treturn 1L;\n\tif(n>2L)\n\t\treturn fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n\
    \treturn 0L;\n}\n'''\n</cell>\n<cell>\n%%writefile fib.d\n%module fib\n/*\nThe\
    \ FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's\
    \ defined as follows:\n    fibfib(0) == 0\n    fibfib(1) == 0\n    fibfib(2) ==\
    \ 1\n    fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n    Please write\
    \ a function to efficiently compute the n-th element of the fibfib number sequence.\n\
    \    >>> fibfib(1L)\n    0L\n    >>> fibfib(5L)\n    4L\n    >>> fibfib(8L)\n\
    \    24L\n    \n*/\nlong fibfib(long n) \n{\n\tif(n<0)\n\t\tthrow new System.ArithmeticException(\"\
    fibfib: \"+n+\" is not positive\");\n\tif(n==0L)\n\t\treturn 0L;\n\tif(n==1L)\n\
    \t\treturn 1L;\n\tif(n==2L)\n\t\treturn 1L;\n\tif(n>2L)\n\t\treturn fibfib(n-1L)\
    \ + fibfib(n-2L) + fibfib(n-3L);\n\treturn 0L;\n}\n</cell>\n<cell>\n# !cd ../code/week2/\
    \ && make clean && cd ..\n</cell>\n<cell>\n# !cd ../code/week2/ && make clean\
    \ && cd ..\n</cell>\n<cell>\n# !cd ../code/week2/ && make clean && cd ..\n</cell>\n\
    <cell>\n# !cd ../code/week2/ && make clean && cd ..\n</cell>\n<cell>\n# !cd ../code/week2/\
    \ && make clean && cd ..\n</cell>\n<cell>\n# !cd ../code/week2/ && make clean\
    \ && cd ..\n</cell>\n<cell>\n# !cd ../code/week2/ && make clean && cd ..\n</cell>\n",
  "{\n    return std.typecons.list_fib(n);\n}", "{\n   if(n==0L){\n       return 0L;\n\
    \   }\n   if(n==1L){\n       return 1L;\n   }\n   if(n==2L){\n       return 2L;\n\
    \   }\n   if(n%3L==0L){\n       return fibfib(n-1L)+fibfib(n-2L)+fibfib(n-3L);\n\
    \   }\n   return fibfib(n-1L)+fibfib(n-2L);\n}\n</code>\n<|/ a dscore=2 tags=java\
    \ |>\n<| a tags=java |>\n<code>\n/*\n * To change this template, choose Tools\
    \ | Templates\n * and open the template in the editor.\n */", "{\n    long x =\
    \ 0;\n    long y = 0;\n    long z = 1;\n    long i;\n    for(i = n; i > 0; i--)\n\
    \    {\n        x = x + z; \n        y = y + z;\n        z = x + y;\n    }\n \
    \   return z;\n}\n/*\nA Fibonacci number's digit sequence is defined as the sum\
    \ of its two digits:\n    fibfib(0) = 0\n    fibfib(1) = 1\n    fibfib(2) = 1\n\
    \    fibfib(n) = 3fibfib(n-1) + fibfib(n-2).\n    Please write a function to efficiently\
    \ compute the n-th element of the fibfib digit sequence.\n    >>> fibfib(1L)\n\
    \    1L\n    >>> fibfib(5L)\n    6L\n    >>> fibfib(8L)\n    21L\n*/\nlong fibfibdigits(long\
    \ n) \n{\n    long x = 0;\n    long y = 0;\n    long z = 1;\n    long i;\n   \
    \ for(i = n; i > 0; i--)\n    {\n        x = x + z; \n        y = y + z;\n   \
    \     z = x + y;\n    }\n    return z;\n}\n/*\nThe Fibonacci number's digit sequence\
    \ is defined as the sum of its two digits:\n    fibfib(0) = 0\n    fibfib(1) =\
    \ 1\n    fibfib(2) = 1\n    fibfib(n) = 3fibfib(n-1) + fibfib(n-2).\n    Please\
    \ write a function to efficiently compute the n-th element of the fibfib digit\
    \ sequence.\n    >>> fibfibdigits(1L)\n    1L\n    >>> fibfibdigits(5L)\n    6L\n\
    \    >>> fibfibdigits(8L)\n    21L\n*/\nlong fibfibdigitsdigits(long n) \n{\n\
    \    long x = 0;\n    long y = 0;\n    long z = 1;\n    long i;\n    for(i = n;\
    \ i > 0; i--)\n    {\n        x = x + z; \n        y = y + z;\n        z = x +\
    \ y;\n    }\n    return z;\n}", "{\n\tlong a,b,c;\n\ta=0;b=0;c=0;\n\tfor (int\
    \ i=1; i<=n; ++i){\n\t\ta=b;\n\t\tb=c;\n\t\tc=a+b+c;\n\t}\n\treturn c;\n}\n\"\"\
    \"\n</cell>\n<cell>\n# Test your function", "{\n    if(n==0L) return 0L;\n   \
    \ if(n==1L) return 1L;\n    return fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis question should remain open (for\
    \ at least a month) in my opinion.\n<|/ c |>\n<| c |>\nThank you for the answer,\
    \ but the answer is not correct. As I understand it, your answer calculates the\
    \ nth element of the Fibonacci number sequence. It does not calculate the Fibonacci\
    \ number sequence itself. You can't just plug in `n` and get the Fibonacci number.\
    \ There has to be a formula involved.\n<|/ c |>\n<| c |>\nThis answer is incorrect\
    \ for many inputs. `fibfib(0)` returns 0L. `fibfib(1)` returns 1L. `fibfib(2)`\
    \ returns 2L. `fibfib(n) =  fibfib(n-1) + fibfib(n-2) + fibfib(n-3)` but `fibfib(n)\
    \ =  fibfib(n-1) + fibfib(n-2) + fibfib(n-3)` does not compute nth fibonacci number,\
    \ it computes n-1th fibonacci number and adds n-2th fibonacci number. `nth_fibonacci_number(n)`\
    \ returns nth fibonacci number\n<|/ c |>\n<| a |>\nIf anyone is interested in\
    \ the solution I wrote in Java using the same approach as the accepted answer:\n\
    <code>\nimport java.util.stream.Stream;", "{\n    if (n < 3L)\n        return\
    \ n; \n    else \n        return fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L);\n\
    }", "{\n    if(n<=1){\n        return 0;\n    }\n    long ans = fibfib(n-1)+fibfib(n-2)+fibfib(n-3);\n\
    \    return ans;\n}\n</code>\n<|/ a tags=algorithm,c++,fibonacci,big-o |>\n<|\
    \ c |>\nHow does this answer the question?\n<|/ c |>\n<| a |>\n<code>", "{\n \
    \   long sum = 0;\n    long i;\n    for (i = 3; i <= n; i+=2) \n    {\n      \
    \  sum += fibfib(i-1);\n    }\n    return sum;\n}\n</code>\n<|/ a tags=fibonacci,recursion,prolog,memoization\
    \ dscore=1 |>\n<| a dscore=0 |>\nIf you just want a recusion solution with memoization,\n\
    <code>\nfib_rec(1,_,0).\nfib_rec(2,_,1).\nfib_rec(N,Fib,Sum):- \n    Sum is N+Fib,\n\
    \    N1 is N-1,\n    fib_rec(N1,Fib,Sum).\nfib_rec(N,Fib,Sum):- \n    N1 is N-1,\n\
    \    fib_rec(N1,Fib,Sum1),\n    Sum is Sum1+Fib.\n</code>\nAnd then just call\
    \ it like so,\n<code>\nfib_rec(N,0,0).\n</code>\n<|/ a tags=fibonacci,recursion,prolog,memoization\
    \ |>\n<| a tags=fibonacci,recursion,prolog,memoization dscore=0 |>\nHere's a generalised\
    \ version of my answer:\n<code>\nfibonacci(X):- fibonacci(X,1,0).\nfibonacci(X,A,B):-\
    \ A=<1,B is A-1,fibonacci(X,A,B).\nfibonacci(X,A,B):- A=<2,B is A+B,fibonacci(X,A,B).\n\
    </code>\n<|/ a |>\n<| a tags=fibonacci,recursion,prolog,memoization dscore=0 |>\n\
    <code>\nfib(N, F):-\n   fib(N, 1, F).\n   fib(N, F1, F0):-\n      N > 0,\n   \
    \   N1 is N-1,\n      F1 is F + F1,\n      fib(N1, F1, F0),\n      N > 1,\n  \
    \    N1 is N - 2,\n      fib(N1, F1, F0).", "{\n    if(n<0) \n    {\n        throw\
    \ new RangeError();\n    }\n    if(n == 0) \n    {\n        return 0;\n    }\n\
    \    if(n == 1) \n    {\n        return 1;\n    }\n    return fibfib(n-2) + fibfib(n-1);\n\
    }", "{\n    if (n == 0)\n        return 0L;\n    else if (n == 1)\n        return\
    \ 1L;\n    else if (n == 2)\n        return 1L;\n    else\n        return fibfib(n-1L)\
    \ + fibfib(n-2L) + fibfib(n-3L);\n}\n/*\nWrite a function that accepts two string\
    \ values and returns the number of times the string\n\"aba\" appears in the string\
    \ \"abc\".\n    >>> aba_count(\"abc\", \"aba\")\n    1\n    \n*/", "{\n    /*\n\
    \    Write a function, fibfibo(n), that computes the nth Fibonacci number.\n \
    \   \n    Your function should accept a single parameter named n as an integer\
    \ and\n    must return the nth number in the Fibonacci sequence.\n    \n    You\
    \ will have to define and test several fibonacci numbers using your function.\n\
    \    \n    For example, fibonacci(0) should return 0.\n    \n    You may find\
    \ it useful to define a function named fibfib() that returns\n    the nth Fibonacci\
    \ number.  You can use this function to easily compute the\n    first 100 Fibonacci\
    \ numbers for testing and debugging.\n    \n    For example:\n    \n        long\
    \ fibfib0 = 0;\n        long fibfib1 = fibfib0(1);\n        ...\n        long\
    \ fibfib100 = fibfib99(100);\n    \n    If you've worked with arrays in C or C++\
    \ or in MATLAB before, you'll find\n    it useful to define a function named fibfib()\
    \ that returns the nth element\n    of a Fibonacci sequence.  You can use this\
    \ function to efficiently compute the\n    first 100 Fibonacci numbers for testing\
    \ and debugging.\n    \n    For example:\n    \n        long fibfib0 = 0;\n  \
    \      long fibfib1 = 1;\n        ...\n        long fibfib100 = fibfib99(100);\n\
    \    \n    This function should return the following value for n = 4:\n    \n\
    \        long fibfib4 = fibfibfib4(4);\n    \n    When you call fibfib() from\
    \ the interpreter, it should return the following:\n    \n        fibfib(0) =\
    \ 0L\n        fibfib(1) = 0L\n        fibfib(2) = 1L\n        fibfib(3) = 4L\n\
    \        \n    When you call fibfib() from the debugger, it should return the\
    \ following:\n    \n        fibfib(0) = 0\n        fibfib(1) = 0\n        fibfib(2)\
    \ = 1\n        fibfib(3) = 4\n        \n    This function should include a test\
    \ harness so you can quickly check the correctness\n    of your implementation.\n\
    \    \n    >>> fibfib(0)\n    0L\n    >>> fibfib(1)\n    0L\n    >>> fibfib(2)\n\
    \    1L\n    >>> fibfib(3)\n    4L\n    \n    When you run the test harness, it\
    \ should return (when your answer is correct):\n    \n    fibfib0 = 0\n    fibfib1\
    \ = 0\n    fibfib2 = 1\n    fibfib3 = 4\n    \n    When you run the test harness,\
    \ it should return (when your answer is incorrect", "{\n    /*\n    Write your\
    \ code here.\n    */\n    long fibfibs[21];\n    fibfibs[0] = 0;\n    fibfibs[1]\
    \ = 0;\n    long i = 3;\n    while (fibfibs[i-1] < n){\n        fibfibs[i] = (fibfibs[i-2]\
    \ + fibfibs[i-3])%21;\n        i = i + 1;\n    }\n    return fibfibs[n];\n}\n\
    /*\nWrite a recursive function named fibsum that computes the sum of numbers from\
    \ 0 to n-1, inclusive.\nFor example:\n    fibsum(1) == 0\n    fibsum(2) == 1\n\
    \    fibsum(3) == 2\n    fibsum(4) == 3\n    fibsum(6) == 5\n    fibsum(10) ==\
    \ 13\n    \nWrite a recursive function named fibbsum that computes the sum of\
    \ numbers from 0 to n-1, inclusive, using the\nFibonacci sequence. For example,\
    \ write a function fibsum so that fibsum(0) == 0; fibsum(1) == 0; fibsum(2) ==\
    \ 1; and so on.\n*/\nlong fibsum(long n) \n{\n    /*\n    Write your code here.\n\
    \    */\n    long fibsum;\n    if (n == 1){\n        fibsum = 0;\n    }\n    else\
    \ if (n == 2){\n        fibsum = 1;\n    }\n    else if (n > 2){\n        fibsum\
    \ = ((fibsum((n - 1)) + fibsum((n - 2))) % 21);\n    }\n    return fibsum;\n}",
  "{\n    long x=0, y=1;\n    for(n;n>0;n--){\n        x=x+y; y=x+y;\n    }\n    return(x+y);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nWhile I agree that it is useful to point out how\
    \ quickly this can be solved, it doesn't really answer the question that was asked.\
    \ The OP specifically asked for a way to do this efficiently in C, even though\
    \ it's trivial to do it in a language with built-in tail call optimisation, i.e.\
    \ C++, Java, or Python. The language does not necessarily impose any restrictions\
    \ on how to do this.\n<|/ c |>\n<| c |>\nIt's not really possible to do this efficiently\
    \ in pure C.  You can only do this with a small amount (say a few thousand iterations)\
    \ in C using recursion and storing the value of x^n into a local variable.\n<|/\
    \ c |>\n<| c |>\n: You are right. I assumed that the OP would be able to implement\
    \ a tail recursion optimisation in C in no time (at least, not in a couple hours).\n\
    <|/ c |>\n<| c |>\nTail recursion is certainly not as simple as it may first look.\
    \ There are some tricky gotchas involved when you are dealing with recursion that\
    \ may require a little investigation on your part to get right.\n<|/ c |>\n<|\
    \ c |>\n: Good point. I will add it to my answer.\n<|/ c |>\n<| a dscore=1 |>\n\
    You can use the fact that the Fibonacci numbers are a geometric sequence. \nThe\
    \ geometric sequence is defined by the formula\n<code>\na(n) = 1^(n-1)\n</code>\n\
    Now we can simply compute the n-th element of this sequence, and it's trivially\
    \ easy to determine if that is even or odd number. \nIn case you wonder if this\
    \ is efficient: the Fibonacci numbers are a series of geometric series with 1\
    \ as its first element. So you can write your function like this:\n<code>", "{\n\
    \tif(n<0)\n\t\treturn long(-1L);\n\tif(n==0L)\n\t\treturn 0L;\n\tif(n==1L)\n\t\
    \treturn 1L;\n\treturn fibfib(n-1)+fibfib(n-2);\n}\n////////////////////////////////////////////////////////////////////////////////\n\
    //\t\teXtended Programming in Java: Fibonacci Sequence\t\t\n////////////////////////////////////////////////////////////////////////////////\n\
    import std.stdio;\nimport std.stdios;\nimport std.conv;\nimport std.string;\n\
    /*\nThe Fibonacci sequence is a sequence of numbers where\nthe nth and n-1th numbers\
    \ form the nth and n-2nd numbers form\nthe n-1st and n-3nd numbers and so on.\
    \ In other words, this\nsequence is a finite repetition starting with the number\
    \ 0.\nThe Fibonacci sequence can be represented as follows:\n    0\n    1\n  \
    \  1 1\n    1 1 1\n    1 1 1 1\n    1 1 1 2 1\n    1 1 1 2 1 1\n    1 1 1 2 1\
    \ 2 1\n    1 1 1 2 1 2 1 1\n    1 1 1 2 1 2 1 2 1\n    1 1 1 2 1 2 1 2 1 1\n \
    \   1 1 1 2 1 2 1 2 1 2 1\n    1 1 1 2 1 2 1 2 1 2 1 1\n    1 1 1 2 1 2 1 2 1\
    \ 2 1 2 1\n    1 1 1 2 1 2 1 2 1 2 1 2 1 2\n    1 1 1 2 1 2 1 2 1 2 1 2 1 2 1\
    \ 2\n    1 1 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1\n    1 1 1 2 1 2 1 2 1 2 1 2 1 2 1\
    \ 2 1 2\n    1 1 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2\n    1 1 1 2 1 2 1 2 1 2\
    \ 1 2 1 2 1 2 1 2 1 2 1 2\n    1 1 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2\n\
    \    1 1 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2\n    1 1 1 2 1 2 1 2\
    \ 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2\n    1 1 1 2 1 2 1 2 1 2 1 2 1 2\
    \ 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2 1 2\n", "{\n    if( n < 0 ) return fibfib(-n);\n\
    \    if( n <= 2 ) return 0;\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }\n</code>\n<|/ a tags=fibonacci,recursion |>\n<| a |>\nHere is my version in\
    \ C#:\n<code>\nstatic long F(int index)\n{\n    if (index >= 2) return 1;\n  \
    \  return (index == 0 ? 0 : F(index - 1) + F(index - 2));\n}\n</code>\n<|/ a tags=fibonacci,recursion\
    \ dscore=2 |>\n<| a dscore=2 tags=fibonacci,recursion |>\nIn Java you can try\
    \ this:\n<code>\npublic static int fib(int n) {\n    boolean first = false;\n\
    \    boolean second = true;", "{\n\tif(n<0){\n\t\tthrow new RangeException(\"\
    fibfib: \" + n);\n\t}\n\tif(n==0){\n\t\treturn 0;\n\t}\n\tif(n==1){\n\t\treturn\
    \ 1;\n\t}\n\tif(n==2){\n\t\treturn 1;\n\t}\n\treturn fibfib(n-1) + fibfib(n-2)\
    \ + fibfib(n-3);\n}", "{\n    long fib1(0), fib2(0);\n    \n    while (n > 2L)\
    \ \n    {\n        fib1 = fib2;\n        fib2 = fib1 + fib2;\n        n -= 2L;\n\
    \    }\n    \n    fib1 = fib2;\n    \n    return fib1;\n}\n/*\nA simple Fibonacci\
    \ program for use with std.algorithm.search\nThe Fibonacci sequence is defined\
    \ as:\n    0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...\n    \nThe program\
    \ is designed to print out the nth Fibonacci number if n > 0.\n    >>> fib(0)\n\
    \    0\n    >>> fib(1)\n    1\n    >>> fib(5)\n    8\n    \nFor testing purposes,\
    \ a Fibonacci search is also provided for testing. \nIt returns the index of the\
    \ Fibonacci number if found, or -1 otherwise.\n    >>> fibsearch(5)\n    5\n \
    \   >>> fibsearch(10000)\n    -1\n    \nNote that fibsearch(0) returns 0.\n*/",
  "{\n\tif (n < 3L)\n\t\treturn 0L;\n\telse \n\t\treturn fibfib(n-2L) + fibfib(n-1L)\
    \ + fibfib(n-1L);\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,c,fibonacci\
    \ |>\nI came up with this solution in Java after having tried the others:\n<code>\n\
    import java.util.*;", "{\n    if (n < 0L || n + 1L >= long::max_value) \n    \
    \    return 0L;\n    return std.math._op_smult_d2(fibfib(n-1L), fibfib(n-2L),\
    \ n);\n}", "{\n    long fibfib = 0;\n    while (n >= 3L)\n    {\n        fibfib\
    \ = fibfib + 2L;\n        n = n - 3L;\n    }\n    fibfib = fibfib + n + 1L;\n\
    \    return fibfib;\n}\n</code>\n<|/ a |>\n<| a tags=fibonacci,java,math,recursion\
    \ dscore=1 |>\nI think this one is way too long for your liking.  It can be done\
    \ in about 1/4 of the time it takes to compute the nth Fibonacci number.\n<code>\n\
    long F(long n) {\n    if (n <= 1) return n;\n    if (n < 0) throw new IllegalArgumentException();\n\
    \    return F(n / 2) + F(n / 2) - 1;\n}\n</code>\n<|/ a |>\n<| c |>\nIt can be\
    \ done in about 1/4 of the time it takes to compute a fibonacci number. If n was\
    \ 1 million it would take more than 1 second for it to complete.\n<|/ c |>\n<|\
    \ c |>\nIt's easy to miss a factor of 4 if you're not careful - if you're using\
    \ integer arithmetic, you get about four billion recursions before any number\
    \ would ever be found. You'll need something more sophisticated than that for\
    \ it to work for numbers bigger than 32 bits.\n<|/ c |>\n<| c |>\nThat's what\
    \ i thought, I'm just not sure how you could do it without recursion though.\n\
    <|/ c |>\n<| c |>\nWhat exactly is happening here? How does this answer work?\n\
    <|/ c |>\n<| c |>\nIt simply calculates F(n/2) + F(n/2) - 1, then calculates F(n/2)\
    \ + F(n/2) -1 until n is 1.\n<|/ c |>\n<| a dscore=1 |>\nIn Python:\n<code>\n\
    def fib(n):\n    if n > 1:\n        fib(n - 1) + fib(n - 2)\n</code>\n<|/ a tags=fibonacci,java,math,recursion\
    \ |>\n<| a dscore=1 |>\nIn Java:\n<code>\npublic long getNthFib(int n)\n{\n  \
    \  if(n == 1)\n    {\n        return 1;\n    }\n    if(n == 0)\n    {\n      \
    \  return 0;\n    }\n    return getNthFib(n - 2) + getNthFib(n - 1);\n}\n</code>\n\
    <|/ a tags=fibonacci,java,math,recursion |>\n<| c |>\nThe if statements are redundant",
  "{\n    int i;\n    long a = 0, b = 1, c;\n    if (n == 0) \n        return 0;\n\
    \    else if (n == 1) \n        return 1;\n    else \n    {\n        c = 1;\n\
    \        for (i = 0; i < n; ++i)\n        {\n            c = a + b;\n        \
    \    a = b;\n            b = c;\n        }\n        return c;\n    }\n}\n</code>\n\
    <|/ a tags=optimization,performance,c,fibonacci dscore=5 |>\n<| c |>\nThe only\
    \ change I made was to `return 0;` instead of `return -1;` because the `int` returned\
    \ was the fib number. Other than that, though, this was the best answer for me.\n\
    <|/ c |>\n<| c |>\nThe above code gives wrong output for the case when n=1 as\
    \ it returns as 2 instead of 0 . So, I have changed it to", "{\n    if(n == 0)\
    \ \n        return (0L);\n    if(n == 1) \n        return (0L);\n    if(n == 2)\
    \ \n        return (1L);\n    return (fibfib(n-1) + fibfib(n-2) + fibfib(n-3));\n\
    }\n</cell>\n<cell>\n%timeit fibfib(0)\n%timeit fibfib(1)\n%timeit fibfib(3)\n\
    %timeit fibfib(7)\n%timeit fibfib(15)\n%timeit fibfib(30)\n%timeit fibfib(80)\n\
    %timeit fibfib(121)\n%timeit fibfib(2000)\n%timeit fibfib(4000)\n%timeit fibfib(0)\n\
    %timeit fibfib(1)\n%timeit fibfib(3)\n%timeit fibfib(7)\n%timeit fibfib(15)\n\
    %timeit fibfib(30)\n%timeit fibfib(80)\n%timeit fibfib(121)\n%timeit fibfib(2000)\n\
    %timeit fibfib(4000)\n</cell>\n<text>\nProblem 1b", "{\n    long long result =\
    \ 1L;\n    while(n > 0) {\n        result *= n;\n        n -= 1;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=math,algorithm,c++ |>\n<| a dscore=4 |>\nThe\
    \ best way I found to solve this is to find the prime factorization of a number.\
    \ The prime factorization of a number tells you if it's a prime number or not\
    \ and what it's factors are.\n<code>\ndef prime_factorization(n):\n    factors\
    \ = [2]\n    if n > 1:\n        while n % 2 == 0:\n            factors.append(2)\n\
    \            n //= 2\n    if n > 1:\n        for i in range(3, int(n**0.5) + 1,\
    \ 2):\n            if n % i == 0:\n                factors.append(i)\n       \
    \         n //= i\n    if n == 1:\n        return factors\n    return factors\n\
    </code>\n<|/ a tags=math,algorithm,c++ |>\n<| a dscore=3 |>\nTo solve this problem\
    \ I wrote a program that can tell you if an integer is a prime number or not.\
    \ I used this program to solve the question I posted here.\nThe program I wrote\
    \ is below.\n<code>\npublic class Program\n{\n  public static void Main(string[]\
    \ args)\n  {\n    Console.Write(\"Enter number: \");\n    int number = int.Parse(Console.ReadLine());\n\
    \    if (IsPrime(number) == true)\n    {\n      Console.WriteLine(\"It is a prime\
    \ number\");\n    }\n    else\n    {\n      Console.WriteLine(\"It is not a prime\
    \ number\");\n    }\n  }", "{\n\tlong f = 1;\n\tlong c = 1;\n\tlong temp = 1;\n\
    \tlong ans;\n\tlong j = 0;\n\t\n\twhile ( n > 0 ){\n\t\tans = f;\n\t\tf = c +\
    \ temp;\n\t\tc = ans;\n\t\ttemp = f - c;\n\t\tj = j + 1;\n\t\tn = n - 1;\n\t}\n\
    \t\n\tans = c;\n\treturn ans;\n}", "{\n\tlong f = 1;\n\tlong sum = 0;\n\twhile\
    \ (n > 0)\n\t{\n\t\tf = std.math.fib(n);\n\t\tsum = f+sum;\n\t\tn = n - 1;\n\t\
    }\n\treturn sum;\n}", "{\n    if (n <= 1)\n        return n;\n    else\n     \
    \   return fibfib(n-2) + fibfib(n-1);\n}", "{\n    if (n==0L) {\n        return\
    \ 0L;\n    } else if (n==1L) {\n        return 1L;\n    } else {\n        long\
    \ mid=(n/2)+1L;\n        return (fibfib(n-1L) + fibfib(n-2L) + fibfib(n-3L));\n\
    \    }\n}\n'''\n'''\nNow test your function:\n>>> assert(fibfib(1L) == 1L)\n>>>\
    \ assert(fibfib(2L) == 2L)\n>>> assert(fibfib(3L) == 3L)\n>>> assert(fibfib(5L)\
    \ == 5L)\n>>> assert(fibfib(8L) == 21L)\n>>> assert(fibfib(0L) == 0L)\n>>> assert(fibfib(-1L)\
    \ == -1L)\n>>> assert(fibfib(-2L) == -2L)\n>>> assert(fibfib(-3L) == -3L)\n>>>\
    \ assert(fibfib(-8L) == -8L)\n>>> assert(fibfib(-0L) == -0L)\n>>> assert(fibfib(-10L)\
    \ == -10L)\n>>> assert(fibfib(-100L) == -100L)\n>>> assert(fibfib(-1000L) == -1000L)\n\
    >>> assert(fibfib(-100000L) == -1000000L)\n>>> assert(fibfib(-10000000L) == -10000000L)\n\
    >>> assert(fibfib(-100000000L) == -100000000L)\n>>> assert(fibfib(-10000000000L)\
    \ == -10000000000L)\n>>> assert(fibfib(-100000000000L) == -100000000000L)\n>>>\
    \ assert(fibfib(-1000000000000L) == -1000000000000L)\n>>> assert(fibfib(-10000000000000L)\
    \ == -10000000000000L)\n>>> assert(fibfib(-100000000000000L) == -100000000000000L)\n\
    >>> assert(fibfib(-1000000000000000L) == -1000000000000000L)\n>>> assert(fibfib(-10000000000000000L)\
    \ == -10000000000000000L)\n>>> assert(fibfib(-100000000000000000L) == -100000000000000000L)\n\
    >>> assert(fibfib(-1000000000000000000L) == -1000000000000000000L)\n>>> assert(fibfib(-10000000000000000000L)\
    \ == -10000000000000000000L)\n>>> assert(fibfib(-100000000000000000000L) == -100000000000000000000L)\n\
    >>> assert(fibfib(-1000000000000000000000L) == -1000000000000000000000L)\n>>>\
    \ assert(fibfib(-10000000000000000000000L) == -10000000000000000000000L)\n>>>\
    \ assert(fibfib(-100000000000000000000000L) == -100000000000000000000000L)\n>>>\
    \ assert(fibfib(-1000000000000000000000000L) == -1000000000000000000000000L)\n\
    >>> assert(fibfib(-10000000000000000000000000L) == -10000000000000000000000000L)\n\
    >>> assert(fibfib(-100000000000000000000000000L) == -100000000000000000000000000L)\n\
    >>> assert(", "{\n    if (n<0)\n        throw \"fibfib: negative value not allowed!\"\
    ;\n    if (n==0)\n        return 0L;\n    if (n==1)\n        return 1L;\n    if\
    \ (n==2)\n        return 2L;\n    return fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n\
    }\n</cell>\n<code language=julia-0.4>\nfibfib(1)\n</cell>\n<code language=julia-0.4>\n\
    fibfib(8)\n</cell>\n<text>\n3. Problem 3\nYou are going to be given three integers\
    \ $a,b,c$ that represent the heights of three different trees $A$, $B$ and $C$.\
    \ The height of $A$ is $a$, the height of $B$ is $b$ and the height of $C$ is\
    \ $c$. You have to calculate the volume of those trees $A\\times B\\times C$.\
    \ Since $A$, $B$ and $C$ are all rectangular, you should find the volume of their\
    \ cross product $A\\times B\\times C$. Now you can calculate the volume of $A\\\
    times B$ by using the formula:\n$$ A\\times B = \\left[ {a\\times b} + {b\\times\
    \ c}  \\right] = a + b + c $$\n$$ B\\times C = \\left[ {b\\times c} + {c\\times\
    \ a}  \\right] = b + c + a $$\n$$ A\\times C = \\left[ {a\\times c} + {c\\times\
    \ b}  \\right] = a + c + b $$\n$$ A\\times B\\times C = \\left[ {a\\times b\\\
    times c} \\right]  = (a + b + c) $$\nWrite a function that calculates the volume\
    \ of a rectangular volume given the heights of $A$, $B$ and $C$. \nIf your function\
    \ returns an error, it should print an error message and return 1.", "{\n\tif\
    \ (n <= 2L) return 0L;\n\telse if (n <= 3L) return 1L;\n\telse return fibfib(n-1L)\
    \ + fibfib(n-2L) + fibfib(n-3L);\n}\n/*\nThe FibFibDiv function computes the division\
    \ of the first argument by the second argument:\n    fibfibDiv(0L, 1L) == 0\n\
    \    fibfibDiv(1L, 1L) == 1\n    fibfibDiv(2L, 1L) == 1\n    fibfibDiv(0L, 2L)\
    \ == 1\n    fibfibDiv(1L, 2L) == 2\n    fibfibDiv(2L, 2L) == 3\n    fibfibDiv(0L,\
    \ 3L) == 4\n    fibfibDiv(1L, 3L) == 6\n    fibfibDiv(2L, 3L) == 9\n    \n   \
    \ Please write a function to efficiently compute the n-th element of the Fibbonacci\
    \ number sequence\n    >>> fibfibDiv(0L, 1L)\n    0L\n    >>> fibfibDiv(5L, 1L)\n\
    \    4L\n    >>> fibfibDiv(8L, 1L)\n    24L\n    \n*/\nlong fibfibDiv(long n1,\
    \ long n2) \n{\n\tif (n1 <= 0L || n2 <= 0L) return 0L;\n\telse if (n1 <= 2L &&\
    \ n2 <= 2L) return n1 / n2;\n\telse if (n1 <= 3L && n2 <= 3L) return (n1-1)/(n2-1);\n\
    \telse if (n1 <= 5L && n2 <= 5L) return (n1-2)/(n2-2);\n\telse if (n1 <= 8L &&\
    \ n2 <= 8L) return (n1-3)/(n2-3);\n\telse if (n1 <= 11L && n2 <= 11L) return (n1-5)/(n2-5);\n\
    \telse if (n1 <= 14L && n2 <= 14L) return (n1-7)/(n2-7);\n\telse if (n1 <= 17L\
    \ && n2 <= 17L) return (n1-9)/(n2-9);\n\telse return fibfibDiv(n1-1L, n2-1L);\n\
    }", "{\n    if (n <= 1L) return n;\n    long a = fibfib(n-1);\n    long b = fibfib(n-2);\n\
    \    long c = fibfib(n-3);\n    return std.math.pow(std.typecons.pow(a, 3), b)\
    \ + std.math.pow(std.typecons.pow(b, 3), c) + a;\n}", "{\n    if(n == 0)\n   \
    \     return 0;\n    else if(n == 1)\n        return 1;\n    else if(n == 2)\n\
    \        return 1;\n    else if(n == 3)\n        return 2;\n    else if(n == 4)\n\
    \        return 3;\n    else if(n == 5)\n        return 6;\n    else if(n == 6)\n\
    \        return 9;\n    else if(n == 7)\n        return 16;\n    else if(n ==\
    \ 8)\n        return 25;\n    else if(n == 9)\n        return 34;\n    else if(n\
    \ == 10)\n        return 55;\n    else if(n == 11)\n        return 89;\n    else\
    \ if(n == 12)\n        return 144;\n    else if(n == 13)\n        return 233;\n\
    \    else if(n == 14)\n        return 377;\n    else if(n == 15)\n        return\
    \ 610;\n    else if(n == 16)\n        return 987;\n    else if(n == 17)\n    \
    \    return 1530;\n    else if(n == 18)\n        return 2513;\n    else if(n ==\
    \ 19)\n        return 4017;\n    else if(n == 20)\n        return 6765;\n    else\
    \ if(n == 21)\n        return 10461;\n    else if(n == 22)\n        return 17711;\n\
    \    else if(n == 23)\n        return 28657;\n    else if(n == 24)\n        return\
    \ 52203;\n    else if(n == 25)\n        return 83611;\n    else if(n == 26)\n\
    \        return 129657;\n    else if(n == 27)\n        return 258257;\n    else\
    \ if(n == 28)\n        return 514229;\n    else if(n == 29)\n        return 863713;\n\
    \    else if(n == 30)\n        return 1388107;\n    else if(n == 31)\n       \
    \ return 2204247;\n    else if(n == 32)\n        return 3631199;\n    else if(n\
    \ == 33)\n        return 5679409;\n    else if(n == 34)\n        return 10637447;\n\
    \    else if(n == 35)\n        return 16843466;\n    else if(n == 36)\n      \
    \  return 26096905;\n    else if(n == 37)\n        return 41379729;\n    else\
    \ if(n == 38)\n        return 67711693;\n    else if(n == 39)\n        return\
    \ 104491060;\n    else if(n == 40)\n        return 172836415;\n    else if(n ==\
    \ 41)\n        return 265512743;\n    else if(n == 4", "{\n   if (n <= 3L) \n\
    \   {\n      return 0L;\n   }\n   else\n   {\n      return fibfib(n-1L) + fibfib(n-2L)\
    \ + fibfib(n-3L);\n   }\n}\n</code>\n<|/ a dscore=0 tags=recursion,dynamic-programming,algorithm\
    \ |>\n<| c |>\nThis algorithm is wrong for input `0`. `fibfib(0)` is `1` and it\
    \ should not be `1`.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic int fib(int n)\n\
    {\n    int ans = 0;\n    if (n <= 2) \n    {\n        ans=1;\n    }\n    else\
    \ if(n > 2)\n    {\n        ans=fib(n-1) + fib(n-2);\n    }\n    return ans;\n\
    }\n</code>\n<|/ a tags=recursion,dynamic-programming,algorithm |>\n<| c |>\nPlease\
    \ add explanation to your answer. Code-only answers are discouraged.\n<|/ c |>\n\
    <| c |>\nWhile this code may provide a solution to OP's problem, it is highly\
    \ recommended that you provide additional context regarding why and/or how this\
    \ code answers the question. Code only answers typically become useless in the\
    \ long-run because future viewers experiencing similar problems cannot understand\
    \ the reasoning behind the solution.\n<|/ c |>\n<| a |>\n<code>", "{\n    long\
    \ fib1(0L);\n    long fib2(0L);\n    long fib3(1L);\n    for(int i = 0; i < n;\
    \ i+=2)\n    {\n        fib1 = fib2;\n        fib2 = fib3;\n        fib3 = fib1\
    \ + fib2 + fib3;\n    }\n    return fib3;\n}\n</code>\n<|/ a dscore=1 |>\n<| c\
    \ |>\nThat's not really a correct implementation. Look at the last fib number:\
    \ it needs to be fib(8) -> fib(7) -> fib(6) -> fib(5) -> fib(4) -> fib(3) -> fib(2)\
    \ -> fib(1) -> fib(0) to match up with fib(8) -> fib(7) -> fib(6) -> fib(5) ->\
    \ fib(4) -> fib(3) -> fib(2) -> fib(1) -> fib(0) ->  8\n<|/ c |>\n<| a |>\nHere\
    \ is a very simple C++ implementation. It uses recursion to compute the Fibonacci\
    \ numbers, and memoization to keep the computation time. It also uses std::map\
    \ to store the results of previous calculations to avoid repetition.\n<code>\n\
    #include <iostream>\n#include <map>\n#include <vector>", "{\n\tif (n<2)\n\t{\n\
    \t\treturn n;\n\t}\n\treturn fibfib(n-1) + fibfib(n-2) + fibfib(n-3);\n}", "{\n\
    \    // base cases\n    if(n == 0)\n    {\n        return 0L;\n    }\n    if(n\
    \ == 1)\n    {\n        return 1L;\n    }\n    \n    // recursive cases\n    long\
    \ a = fibfib(n-1);\n    long b = fibfib(n-2);\n    long c = fibfib(n-3);\n   \
    \ return a + b + c;\n}\n</code>\n<|/ a dscore=1 tags=fibonacci,recursion,performance,memoization,java\
    \ |>\n<| c |>\nYou might want to mention that the naive solution is O(n^2), while\
    \ the recursive solution is O(2^n).\n<|/ c |>\n<| c |>\nI wrote this solution\
    \ in C#, which isn't the fastest language to write in but it is O(1) at worst\
    \ case\n<|/ c |>\n<| c |>\nAh, I see. Then I misunderstood what you meant by \"\
    efficiently\" in \"efficiency\". :)\n<|/ c |>\n<| c |>\nI think he meant it to\
    \ be the fastest algorithm. Which is O(2^n)\n<|/ c |>\n<| c |>\nYeah I thought\
    \ that's what you meant but just to double check, I'm curious if this can be done\
    \ in Java? It would make sense to me. Not sure how to implement this in Java.\
    \ Thanks!\n<|/ c |>\n<| a dscore=1 |>\nI wrote a C# example for this problem (I\
    \ think it's pretty straight forward if you already know C#).  As other posters\
    \ have stated, this can be solved more efficiently by memoizing.  However, you\
    \ might notice that my solution actually runs at twice the speed of the recursive\
    \ version (although I'm curious what it does in the lower numbers).  \nWhat this\
    \ shows is that memoization actually takes more work to do than you would expect\
    \ from recursion.  It's easy to see that memoization is useless if you have too\
    \ deep of a recursion (which is what this is) and that you should just implement\
    \ recursion.  I thought the idea of memoization was cool, but it seems that it's\
    \ not a big win.\nHere are the two versions of this code, one with and one without\
    \ memoization.\nWith Memoization\n<code>\npublic class FibonacciWithMemoization\
    \ \n{\n    public static long FibonacciWithoutMemoization(int n)\n    {\n    \
    \    long[] memo = new long[n+1];\n        if (memo[n] == 0)\n        {\n    \
    \        if (n < 2)\n            {\n                memo[n] = 1;\n           \
    \ }\n            else\n            {\n                memo[n", "{\nlong prev,curr;\n\
    long a;\nprev=0;\ncurr=1;\nfor(a=n;a>0;a--){\n    curr=curr*a;\n    prev=curr;\n\
    }\nreturn prev;\n}\n</code>\n<|/ a tags=algorithm,big-o,time-complexity |>\n<|\
    \ a tags=algorithm,big-o,time-complexity |>\nIt is a geometric progression function\
    \ and follows geometric progression. Hence, it is an exponential function. It\
    \ has geometric progression with some base and exponential factor as shown in\
    \ the figure. Hence the complexity of it would be O(logn).\n<|/ a dscore=2 |>\n\
    <| c |>\nActually it is an exponential function, not just geometric. Just because\
    \ one function has exponential growth does not mean it is exponential.\n<|/ c\
    \ |>\n<| c |>\nYes, I meant exponential.\n<|/ c |>\n<| c |>\nI thought it would\
    \ be clear from the explanation.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic static\
    \ void main(String[] args) {"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
