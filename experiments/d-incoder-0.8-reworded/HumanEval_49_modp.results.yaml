language: d
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q;\n\tif (p ==\
    \ 0)\n\t\treturn 1;\n\tfor (q = 0; q < n; q++)\n\t\tif (p & 1)\n\t\t\tp = p /\
    \ 2 ^ q;\n\t\telse\n\t\t\tp = p / 2 ^ q + 1;\n\treturn p;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb7xth76u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q, r;\n\t\n\t\
    /* compute n^r and r mod p */\n\tq = modl(n, p);\n\tr = modl(q, p);\n\t\n\t/*\
    \ compute r^2 mod p */\n\tq = modl(r, p);\n\t\n\t/* compute r^3 mod p */\n\tq\
    \ = modl(q, p);\n\t\n\t/* compute r^4 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute\
    \ r^5 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^6 mod p */\n\tq = modl(q,\
    \ p);\n\t\n\t/* compute r^7 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^8\
    \ mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^9 mod p */\n\tq = modl(q, p);\n\
    \t\n\t/* compute r^10 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^11 mod p\
    \ */\n\tq = modl(q, p);\n\t\n\t/* compute r^12 mod p */\n\tq = modl(q, p);\n\t\
    \n\t/* compute r^13 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^14 mod p */\n\
    \tq = modl(q, p);\n\t\n\t/* compute r^15 mod p */\n\tq = modl(q, p);\n\t\n\t/*\
    \ compute r^16 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^17 mod p */\n\t\
    q = modl(q, p);\n\t\n\t/* compute r^18 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute\
    \ r^19 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^20 mod p */\n\tq = modl(q,\
    \ p);\n\t\n\t/* compute r^21 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^22\
    \ mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^23 mod p */\n\tq = modl(q, p);\n\
    \t\n\t/* compute r^24 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^25 mod p\
    \ */\n\tq = modl(q, p);\n\t\n\t/* compute r^26 mod p */\n\tq = modl(q, p);\n\t\
    \n\t/* compute r^27 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^28 mod p */\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpeyhsxl4x.d(104): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeyhsxl4x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong ppow = pow(p,n);\n\
    \tlong res = (n^ppow) % p;\n\tif (res == 0 && p != 1 && ppow != 1) {\n\t\t//assert(res!=0)\n\
    \t\tint diff = res%p;\n\t\tlong a = ppow - diff;\n\t\tlong b = ppow - diff;\n\t\
    \tlong c = ppow - diff;\n\t\tlong d = ppow - diff;\n\t\tlong ppowa = pow(p,a);\n\
    \t\tlong ppowa = pow(p,b);\n\t\tlong ppowb = pow(p,c);\n\t\tlong ppowc = pow(p,d);\n\
    \t\tlong ppowd = pow(p,n%p);\n\t\tres = (n^(a*ppowa+b*ppowa+c*ppowb+d*ppowc+n%p*ppowd))\
    \ % p;\n\t}\n\treturn res;\n}\n'''\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2cqxbosf.d(37): Error: unterminated character constant\n/tmp/tmp2cqxbosf.d(37):
    Error: Declaration expected, not \''0U\''\n/tmp/tmp2cqxbosf.d(37): Error: unterminated
    character constant\n/tmp/tmp2cqxbosf.d(42): Error: Declaration expected, not \''assert\''\n/tmp/tmp2cqxbosf.d(43):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp2cqxbosf.d(44): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp2cqxbosf.d(45): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp2cqxbosf.d(46): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp2cqxbosf.d(47): Error: Declaration expected, not \''assert\''\n/tmp/tmp2cqxbosf.d(48):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp2cqxbosf.d(49): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2cqxbosf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0L)\n \
    \       return n; // 0^0 = 1\n    \n    // Handle special cases\n    if (p ==\
    \ 0L)\n        return 1;\n    if (p == -1L)\n        return n;\n    \n    // Test\
    \ for common case\n    if (n == p)\n        return n;\n    \n    // Test for power\
    \ of 2\n    if (p & (p - 1))\n        return modpow2n(n, p);\n    \n    // Compute\
    \ result = 1L - n\n    long res = 1L - n;\n    \n    // Test for a power of 2\
    \ larger than the modulus\n    if (p & p)\n        res = modpow2n(n, p);\n   \
    \ \n    return res;\n}\n/*\nReturn n^p modulo p (be aware of numerics).\n    >>>\
    \ modpow2(3L, 5L)\n    3L\n    >>> modpow2(1101L, 101L)\n    2L\n    >>> modpow2(0L,\
    \ 101L)\n    1L\n    >>> modpow2(3L, 11L)\n    8L\n    >>> modpow2(100L, 101L)\n\
    \    1L\n    \n*/\nlong modpow2(long n, long p) \n{\n    if (n == 0L)\n      \
    \  return n; // 0^0 = 1\n    \n    // Handle special cases\n    if (p == 0L)\n\
    \        return n;\n    if (p == -1L)\n        return 1;\n    \n    // Test for\
    \ common case\n    if (n == p)\n        return n;\n    \n    // Test for power\
    \ of 2\n    if (p & (p - 1))\n        return modpow2n(n, p);\n    \n    // Compute\
    \ result = 1L - n\n    long res = 1L - n;\n    \n    // Test for a power of 2\
    \ larger than the modulus\n    if (p & p)\n        res = modpow2n(n, p);\n   \
    \ \n    return res;\n}\n/*\nReturn n^p modulo p (be aware of numerics).\n    >>>\
    \ modpow3(3L, 5L)\n    3L\n    >>> modpow3(1101L, 101L)\n    2L\n    >>> modpow3(0L,\
    \ 101L)\n    1L\n    >>> modpow3(3L, 11L)\n    8L\n    >>> modpow3(100L, 101L)\n\
    \    1L\n    \n*/\nlong modpow3(long n, long p) \n{\n    if (n == 0L)\n      \
    \  return n; // 0^0 = 1\n    \n    // Handle special cases\n    if (p == 0L)\n\
    \        return n;\n    if (p == -1L)\n        return 1;\n    \n    // Test for\
    \ common case\n    if (n == p)\n        return n;\n    \n    // Test for power\
    \ of 2\n    if (p & (p - 1))\n        return modpow2n(n, \nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc1e776hv.d(119): Error: expression expected, not \''unittest\''\n/tmp/tmpc1e776hv.d(120):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpc1e776hv.d(121): Error: expression
    expected, not \''alias\''\n/tmp/tmpc1e776hv.d(121): Error: found \''candidate\''
    when expecting \'',\''\n/tmp/tmpc1e776hv.d(121): Error: expression expected, not
    \''=\''\n/tmp/tmpc1e776hv.d(121): Error: found \''modp\'' when expecting \'',\''\n/tmp/tmpc1e776hv.d(121):
    Error: expression expected, not \'';\''\n/tmp/tmpc1e776hv.d(123): Error: found
    \''assert\'' when expecting \'',\''\n/tmp/tmpc1e776hv.d(123): Error: found \'';\''
    when expecting \'',\''\n/tmp/tmpc1e776hv.d(124): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmpc1e776hv.d(125): Error: found \'';\'' when expecting \'',\''\n/tmp/tmpc1e776hv.d(126):
    Error: found \'';\'' when expecting \'',\''\n/tmp/tmpc1e776hv.d(127): Error: found
    \'';\'' when expecting \'',\''\n/tmp/tmpc1e776hv.d(128): Error: found \'';\''
    when expecting \'',\''\n/tmp/tmpc1e776hv.d(129): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmpc1e776hv.d(130): Error: expression expected, not \''}\''\n/tmp/tmpc1e776hv.d(131):
    Error: found \''void\'' when expecting \'',\''\n/tmp/tmpc1e776hv.d(131): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmpc1e776hv.d(131): Error: expression
    expected, not \''}\''\n/tmp/tmpc1e776hv.d(131): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmpc1e776hv.d(131): Error: found \''EOF\'' when expecting \'')\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc1e776hv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d, d;\n\td =\
    \ n % p;\n\tif (d == 0) return n;\n\tif (d > 0) return n % p;\n\treturn (n % p\
    \ + p) % p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8f6nlroe.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x, y, z;\n\t\
    long xmodp, ymodp;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx1fmutxf.d(21): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx1fmutxf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n < 0) \n\t{\n\
    \t\tif (p<0) return 0L; \n\t\telse return -p; \n\t}\n\t\n\tif (p==0) return 1L;\n\
    \t\n\tlong r = n;\n\t\n\twhile (r%p != 0) \n\t{ \n\t\tr = r*10L + n%p; \n\t\t\
    n = (n-p)/10L; \n\t}\n\treturn r%p;\n}\n/*\nReturn the next multiple of p greater\
    \ than n.\n    >>> nextp(0L, 101L)\n    101L\n    >>> nextp(101L, 101L)\n    101L\n\
    \    \n*/\nlong nextp(long n, long p) \n{\n\tif (n < 0) return 0L;\n\t\n\tif (p==0)\
    \ return 0L;\n\t\n\tlong r = n;\n\t\n\twhile (r%p != 0) \n\t{ \n\t\tr = r*10L\
    \ + n%p; \n\t\tn = (n-p)/10L; \n\t}\n\t\n\treturn r%p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwf8cabff.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x, y;\n\tassert(n\
    \ > 0);\n\tassert(p > 0);\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_f5wgik9.d(22): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_f5wgik9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x;\n\tint i;\n\
    \tint sign;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprnfuxlvg.d(22): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprnfuxlvg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    for(; n > 0; --n) {\n        result *= p;\n        if(result < 0L) result\
    \ += p;\n        result %= p;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf8p4pg50.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 0) \n\t{\n\
    \t\treturn n;\n\t}\n\tif (p == 1) \n\t{\n\t\treturn n;\n\t}\n\tlong result = n\
    \ & (-p);\n\tlong x = 0;\n\tdo\n\t{\n\t\tx = x + result;\n\t\tresult = result<<1;\n\
    \t\tresult = result + p;\n\t} while (result > n);\n\t\n\treturn result;\n}\n/******************************************************************************/\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2cg_kty4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x, q, res;\n\
    \    x = n % p;\n    if (x < p-1)\n       return 0;\n    else if (x == 0)\n  \
    \     return x;\n    else\n       q = modp(x / p, p);\n    res = x - p * q;\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpynaos7ng.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn (long)((long)n\
    \ % (long)p) * 2 - p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvh7nohwq.d(19): Error: C style cast illegal, use cast(long)n\n/tmp/tmpvh7nohwq.d(19):
    Error: C style cast illegal, use cast(long)p\n/tmp/tmpvh7nohwq.d(19): Error: C
    style cast illegal, use cast(long)(cast(long)n % cast(long)p)\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpvh7nohwq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong rem = 0;\n\t\
    long temp;\n\tif(n>p) \n\t{\n\t\twhile(n>p) \n\t\t{\n\t\t\trem += n;\n\t\t\tn\
    \ -= p;\n\t\t}\n\t\ttemp = n;\n\t\tn = p;\n\t\tp = rem;\n\t\trem = temp;\n\t}\n\
    \treturn rem%p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpksnnaeb9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int i;\n    long\
    \ res = n;\n    \n    for (i = 0; i < 64; i++) {\n        if (res >= p) {\n  \
    \          res--;\n            res *= p;\n            res %= p;\n        }\n \
    \   }\n    return res;\n}\n#endif\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3hj01p_3.d(31): Error: Declaration expected, not \''#\''\n/tmp/tmp3hj01p_3.d(36):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp3hj01p_3.d(37): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp3hj01p_3.d(38): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp3hj01p_3.d(39): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp3hj01p_3.d(40): Error: Declaration expected, not \''assert\''\n/tmp/tmp3hj01p_3.d(41):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp3hj01p_3.d(42): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp3hj01p_3.d(43): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3hj01p_3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n==0)\n\t\treturn\
    \ 0L;\n\tif(n<0)\n\t\treturn n*modp(-n, p);\n\tif(p>n)\n\t\treturn 0L;\n\tlong\
    \ mod=1;\n\tlong ret=1;\n\twhile(p>=p)\n\t{\n\t\tif(p&1)\n\t\t{\n\t\t\tmod=(n%mod)^mod;\n\
    \t\t\tret*=mod;\n\t\t}\n\t\tn/=p;\n\t\tif(n==0)\n\t\t\treturn ret;\n\t}\n\treturn\
    \ ret*mod;\n}\n/*\nReturn x^y modulo p (be aware of numerics).\n    >>> modpow(3L,\
    \ 5L, 5L)\n    3L\n    >>> modpow(1101L, 101L, 101L)\n    2L\n    >>> modpow(3L,\
    \ 11L, 101L)\n    8L\n    >>> modpow(100L, 101L, 101L)\n    1L\n    \n*/\nlong\
    \ modpow(long x, long y, long p) \n{\n\tif(x==0 || y==0 || p==0)\n\t\treturn 0L;\n\
    \tif(p>y)\n\t\treturn modpow(x, y/2, p);\n\tif(p>x)\n\t\treturn modpow(x, y-1,\
    \ p);\n\tlong mod=1;\n\tlong ret=1;\n\tlong q=modpow(x-y, y, p);\n\twhile(q>p)\n\
    \t{\n\t\tq/=p;\n\t\tmod=(mod*q)%p;\n\t\tret*=mod;\n\t}\n\twhile(q>1)\n\t{\n\t\t\
    mod=(mod*q)%p;\n\t\tret*=mod;\n\t\tq/=p;\n\t}\n\treturn ret;\n}\n/*\nReturn x\
    \ // y without remainder (be aware of numerics).\n    >>> modinc(4L, 5L)\n   \
    \ 3L\n    >>> modinc(1101L, 101L)\n    101L\n    >>> modinc(0L, 101L)\n    1L\n\
    \    >>> modinc(3L, 11L)\n    3L\n    >>> modinc(100L, 101L)\n    1L\n    \n*/\n\
    long modinc(long x, long y) \n{\n\tif(x==0 || y==0)\n\t\treturn 0L;\n\tif(x>y)\n\
    \t\treturn modinc(x-y, y);\n\tif(y==1)\n\t\treturn x;\n\treturn x%y;\n}\n/*\n\
    Return x // y with remainder (be aware of numerics).\n    >>> modi(1101L, 101L)\n\
    \    1L\n    >>> modi(0L, 101L)\n    1L\n    >>> modi(3L, \nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpiidv86wi.d(101): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiidv86wi.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x, y;\n   \
    \ \n    x = n;\n    y = p;\n    while (x > y) {\n        x -= y;\n        y +=\
    \ y;\n    }\n    while (y == 1) {\n        y *= 2;\n        x--;\n    }\n    if\
    \ (x < y) {\n        x -= y;\n    }\n    return x;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmol4wcvh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n == 0 || p ==\
    \ 0) return 0;\n\tif (n < p) return (n & ((long)p-1));\n\treturn (n - n%p);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb32hy0d4.d(20): Error: C style cast illegal, use cast(long)p\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb32hy0d4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = n;\n\
    \    while ((result = result % p) != 0) {\n        n -= 1;\n        if (n == 0L)\
    \ {\n            return result;\n        }\n    }\n    return n;\n}\n/*\nReturn\
    \ a vector with first m elements equal to x, rest equal to y (modulo p (be aware\
    \ of numerics)).\n    >>> modvec(1L, 101L, 3L)\n    [0, 3, 1]\n    \n*/\nvector<long>\
    \ modvec(long x, long y, long m) \n{\n    vector<long> result;\n    for (long\
    \ i = 0; i <= m; i++) {\n        result[i - 1] = modp(x + (i - 1) * y, p);\n \
    \   }\n    return result;\n}\n/*\nReturn a vector with first m elements equal\
    \ to x, rest equal to y (modulo p (be aware of numerics)).\n    >>> modvec(1L,\
    \ 101L, 3L)\n    [0, 3, 1]\n    \n*/\nvector<long> modvec(long x, long y, long\
    \ p, long m) \n{\n    vector<long> result = modvec(x, p, m);\n    result.insert(result.end(),\
    \ y, y); // add y to the end\n    return result;\n}\n/*\nReturn an inverted modulo\
    \ p (be aware of numerics).\n    >>> modinv(2L, 5L)\n    2L\n    >>> modinv(1101L,\
    \ 101L)\n    1L\n    >>> modinv(0L, 101L)\n    0L\n    >>> modinv(3L, 11L)\n \
    \   2L\n    >>> modinv(100L, 101L)\n    1L\n    \n*/\nlong modinv(long n, long\
    \ p) \n{\n    long result = n;\n    while (n != 0L) {\n        result -= n % p;\n\
    \        n /= p;\n    }\n    return result;\n}\n/*\nReturn a vector with first\
    \ m elements equal to x, rest equal to y (modulo p (be aware of numerics)).\n\
    \    >>> modinvvec(1L, 101L, 3L)\n    [0, 1, 3]\n    \n*/\nvector<long> modinvvec(long\
    \ x, long y, long m) \n{\n    vector<long> result;\n    for (long i = 0; i <=\
    \ m; i++) {\n        result[i - 1] = modinv(x + (i - 1) * y, p);\n    }\n    return\
    \ result;\n}\n/*\nReturn a vector with first m elements equal to x, rest equal\
    \ to y (modulo p (be aware of numerics)).\n    >>> modinvvec(1L, 101L, 3L)\n \
    \   [0, 1, 3]\n    \n*/\nvector<long> modinvvec(long x, long y, long p, long m)\
    \ \n{\n    vector<long> result = modinvvec(x, \nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcdtem123.d(34): Error: no identifier for declarator vector\n/tmp/tmpcdtem123.d(34):
    Error: Declaration expected, not \''<\''\n/tmp/tmpcdtem123.d(37): Error: Declaration
    expected, not \''for\''\n/tmp/tmpcdtem123.d(37): Error: no identifier for declarator
    i\n/tmp/tmpcdtem123.d(37): Error: Declaration expected, not \''<=\''\n/tmp/tmpcdtem123.d(37):
    Error: no identifier for declarator i\n/tmp/tmpcdtem123.d(37): Error: Declaration
    expected, not \''++\''\n/tmp/tmpcdtem123.d(39): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcdtem123.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong m = (long)(long)\
    \ (p);\n\tif (n < m)\n\t\treturn 0;\n\treturn m - (long) (pow(2, n) - 1);\n}\n\
    */\n/** Return 2^n modulo p (be aware of numerics).\n * \n * The algorithm is\
    \ based on:\n *\n * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n\
    \ * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n\
    \ * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n */\nlong\
    \ modp_d(long n, long p) \n{\n\tlong m = p;\n\tif (n < m)\n\t\treturn 0;\n\treturn\
    \ m - (long) (pow(2, n) - 1);\n}\n/** Return the smallest number d such that 2^d\
    \ <= p < 2^(n+d). */\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcl8uz40b.d(19): Error: C style cast illegal, use cast(long)p\n/tmp/tmpcl8uz40b.d(19):
    Error: C style cast illegal, use cast(long)cast(long)p\n/tmp/tmpcl8uz40b.d(22):
    Error: C style cast illegal, use cast(long)(pow(2, n) - 1)\n/tmp/tmpcl8uz40b.d(24):
    Error: Declaration expected, not \''*\''\n/tmp/tmpcl8uz40b.d(37): Error: Declaration
    expected, not \''if\''\n/tmp/tmpcl8uz40b.d(39): Error: Declaration expected, not
    \''return\''\n/tmp/tmpcl8uz40b.d(40): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcl8uz40b.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n==0) {return 1;}\n\
    \tif(n<0) {n=-n;} \n\tif(p<0) {p=-p;}\n\tif(p>n) {\n\t\tn = p + p - 1;\n\t}\n\t\
    if(p==0) {return 1;}\n\tif(n==p) {return 0;}\n\treturn n % p;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptzvlnuor.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn n - modpow(Long.bitCount(n),\
    \ p, Long.SIZE);\n}\n/**\n * Return n modulo p.\n * \n * This is faster than modp(n,p).\n\
    \ */\nlong modn (long n, long p) \n{\n\tlong res = n;\n\twhile (p > res)\n\t\t\
    res -= p;\n\treturn res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppah5_jen.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = p % n;\n\
    \    return (r != 0L) ? r : n + r;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/\nlong modp64(long n, long p)\n{\n    long r = p % n;\n    return\
    \ (r != 0L) ? r : n + r;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/\nlong mod64(long n, long p)\n{\n    long r = p % n;\n    return\
    \ (r != 0L) ? r : n + r;\n}\n/*\nReturn a double rounded to n digits.\n    >>>\
    \ modd(10L, 100L)\n    10.0\n    >>> modd(10L, 100L, 'F')\n    10.0\n    >>> modd(10L,\
    \ 100L, 'E')\n    10.0\n    >>> modd(10L, 100L, 'D')\n    10.0\n    \n*/\ndouble\
    \ modd(long n, long p, char c)\n{\n    double r = double(modp64(n, p));\n    if\
    \ (c == 'E' || c == 'D')\n        return r;\n    else if (c == 'F')\n        return\
    \ double(std.round(r));\n    else\n        return r;\n}\n/*\nReturn a double rounded\
    \ to n digits.\n    >>> modd(10L, 100L)\n    10.0\n    >>> modd(10L, 100L, 'F')\n\
    \    10.0\n    >>> modd(10L, 100L, 'E')\n    10.0\n    >>> modd(10L, 100L, 'D')\n\
    \    10.0\n    \n*/\ndouble modd64(long n, long p, char c)\n{\n    double r =\
    \ double(mod64(n, p));\n    if (c == 'E' || c == 'D')\n        return r;\n   \
    \ else if (c == 'F')\n        return double(std.round(r));\n    else\n       \
    \ return r;\n}\n/*\nReturn the sum ((a + b) + c) = ((a mod p) + (b mod p)) + c.\n\
    \    >>> modsum(10\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkes43c2t.d(74): Error: found \''(\'' when expecting \''.\''
    following double\n/tmp/tmpkes43c2t.d(74): Error: semicolon expected, not \'')\''\n/tmp/tmpkes43c2t.d(74):
    Error: found \'')\'' instead of statement\n/tmp/tmpkes43c2t.d(78): Error: found
    \''(\'' when expecting \''.\'' following double\n/tmp/tmpkes43c2t.d(78): Error:
    found \'')\'' when expecting \'';\'' following return statement\n/tmp/tmpkes43c2t.d(79):
    Error: found \''else\'' instead of statement\n/tmp/tmpkes43c2t.d(96): Error: found
    \''(\'' when expecting \''.\'' following double\n/tmp/tmpkes43c2t.d(96): Error:
    semicolon expected, not \'')\''\n/tmp/tmpkes43c2t.d(96): Error: found \'')\''
    instead of statement\n/tmp/tmpkes43c2t.d(100): Error: found \''(\'' when expecting
    \''.\'' following double\n/tmp/tmpkes43c2t.d(100): Error: found \'')\'' when expecting
    \'';\'' following return statement\n/tmp/tmpkes43c2t.d(101): Error: found \''else\''
    instead of statement\n/tmp/tmpkes43c2t.d(104): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkes43c2t.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n < p) \n\t\t\
    return 0;\n\tlong p = 1;\n\tlong q = n - p;\n\tlong r = 1;\n\twhile (r < q) \n\
    \t{\n\t\tr = p * q;\n\t\tp++;\n\t\tq--;\n\t}\n\treturn p - n;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeyu34gnw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x;\n\tx = n %\
    \ p;\n\tif (x < 0)\n\t{\n\t\tx += p;\n\t}\n\telse\n\t{\n\t\tx = x - p;\n\t}\n\t\
    return x;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhfqm_rh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long t;\n    if(p\
    \ == 0)\n        return 0;\n    \n    if(n == 0)\n        return 1;\n    \n  \
    \  if(p > n)\n        p = n;\n    \n    t = (p - 1L) % p;\n    \n    if(n == t)\n\
    \        return t;\n    \n    return n - t;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcf1onhge.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1;\n\
    \    while (n > 0) {\n        if ((n % p) == 0) {\n            n = n / p;\n  \
    \          res = (res * res * res + 2) % p;\n        }\n        else {\n     \
    \       n = (n * res + 2) % p;\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ 2^n modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>>\
    \ modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nunsigned long modpu(unsigned\
    \ long n, unsigned long p) \n{\n    unsigned long res = 1;\n    while (n > 0)\
    \ {\n        if ((n % p) == 0) {\n            n = n / p;\n            res = (res\
    \ * res * res + 2) % p;\n        }\n        else {\n            n = (n * res +\
    \ 2) % p;\n        }\n    }\n    return res;\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong long modpll(long long n, long long p) \n{\n  \
    \  long long res = 1;\n    while (n > 0) {\n        if ((n % p) == 0) {\n    \
    \        n = n / p;\n            res = (res * res * res + 2) % p;\n        }\n\
    \        else {\n            n = (n * res + 2) % p;\n        }\n    }\n    return\
    \ res;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n\
    \    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n \
    \   >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nunsigned\
    \ long long modpul(unsigned long long n, unsigned long long p) \n{\n    unsigned\
    \ long long res = 1;\n    while (n > 0) {\n        if ((n % p) == 0) {\n     \
    \       n = n / p;\n            res = (res * res * res + 2) % p;\n        }\n\
    \        else {\n            n = (n * res + 2) % p;\n        }\n    }\n    return\
    \ res;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_jt4l8a7.d(45): Error: no identifier for declarator unsigned\n/tmp/tmp_jt4l8a7.d(45):
    Error: found \''long\'' when expecting \'')\''\n/tmp/tmp_jt4l8a7.d(45): Error:
    semicolon expected following function declaration\n/tmp/tmp_jt4l8a7.d(45): Error:
    no identifier for declarator n\n/tmp/tmp_jt4l8a7.d(45): Error: Declaration expected,
    not \'',\''\n/tmp/tmp_jt4l8a7.d(48): Error: Declaration expected, not \''while\''\n/tmp/tmp_jt4l8a7.d(51):
    Error: no identifier for declarator res\n/tmp/tmp_jt4l8a7.d(51): Error: Declaration
    expected, not \''=\''\n/tmp/tmp_jt4l8a7.d(52): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_jt4l8a7.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (p) {\n        if ((n % p) != 0) {\n            result *= n;\n    \
    \        result %= p;\n        }\n        n /= p;\n    }\n    return (n == 0)\
    \ ? result : 1L;\n}\n/*\nReturn 2^n modulo p.\n    >>> modp(3L, 5L)\n    3L\n\
    \    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n*/\nlong modp2l(long n, long\
    \ p)\n{\n    long res = 1L;\n    while (p) {\n        if ((n % p) != 0) {\n  \
    \          res*=n;\n            res %= p;\n        }\n        n /= p;\n    }\n\
    \    return (n == 0) ? res : 1L;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprwgewd6t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res;\n\tlong\
    \ k;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmjue_0p9.d(21): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmjue_0p9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long rem = n % p;\n\
    \    long q = n - rem;\n    if (q < 0) return q + p;\n    if (rem == 0)\n    \
    \    return p;\n    if (rem > 0)\n        return modp(q, p) + p;\n    return modp(q,\
    \ p);\n}\n/*\n>>> modp_p2(5L, 3L)\n(2, 3L)\n>>> modp_p2(5L, 6L)\n(1, 5L)\n>>>\
    \ modp_p2(5L, 8L)\n(1, 3L)\n>>> modp_p2(5L, 2L)\n(5, 3L)\n>>> modp_p2(5L, 101L)\n\
    (5, 3L)\n>>> modp_p2(-5L, 3L)\n(-5, 3L)\n>>> modp_p2(-5L, 6L)\n(-4, 5L)\n>>> modp_p2(-5L,\
    \ 8L)\n(-4, 3L)\n>>> modp_p2(-5L, 2L)\n(-5, 3L)\n>>> modp_p2(-5L, 101L)\n(-5,\
    \ 3L)\n>>> modp_p2(-5L, 101L)\n(-5, 3L)\n>>> modp_p2(111L, 101L)\n(11, 10L)\n\
    >>> modp_p2(111L, 101L)\n(11, 10L)\n>>> modp_p2(111L, 101L)\n(11, 10L)\n*/\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpisd4skcy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tn = n % p;\n\tif (n\
    \ < p)\n\t\treturn n % p;\n\treturn ((p * n) % (p * 2)) % p;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprzfmz1ap.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res = 1;\n\t\
    while(n>0) {\n\t\tres = (res*10)%p; \n\t\tn = (n-1)/10;\n\t}\n\treturn res;\n\
    }\n/*\nTest if a number is prime\nReturn True if a is prime else False\n*/\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq16ya25w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x;\n    int\
    \ r;\n    if (p > 1) // trivial case\n    {\n        return 1;\n    }\n    else\
    \ if (p == 1) // n==1\n    {\n        return n;\n    }\n    else if (p == 0) //\
    \ n==0\n    {\n        return 0;\n    }\n    // otherwise calculate r = n % p\
    \ (i.e. return r mod p)\n    x = n % p;\n    if (x >= p) // n is larger, modulo\
    \ p \n    {\n        x -= p;\n    }\n    r = x;\n    while (r > 0 && r != p) //\
    \ while r divides p\n    {\n        r--;\n        x -= p;\n    }\n    return r*p\
    \ + (n-x);\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThe following algorithm is\
    \ based on a modified Euclid's algorithm to calculate the modular inverse of a\
    \ number. The algorithm is based on this question and its answers. \n<code>\n\
    function modinv(x, mod) {\n  let m = mod(x, mod);\n  while (x !== 1) {\n    m\
    \ = mod(m, mod);\n    x = (x * m) % (mod - 1);\n  }\n  return m;\n}\n</code>\n\
    The mod function is a function that returns the modulus of a number and the modinv\
    \ function calculates the modular inverse of a number. \n<code>\nfunction mod(x,\
    \ modulus) {\n  return x - ((x * modulus) % modulus);\n}\n</code>\nIn your code\
    \ you are trying to divide a number by 1 but this operation is not possible. The\
    \ first step would be to perform the modulo operation on the first and second\
    \ number of the array. After you do that you can subtract the two arrays and find\
    \ the modular inverse of the new array which you would then multiply by the second\
    \ number. This should give you the modular inverse of the array.\n<|/ a tags=modulus,math,modular-arithmetic,c++\
    \ dscore=1 |>\n<| a |>\nThis solution is a little simpler than the other answers\
    \ but I think it performs more efficient as it does not use division or modulus\
    \ but instead uses bit operations to calculate the inverse:\n<code>\nlong modinv(long\
    \ x, long mod) {\n    long r = 0, q;\n    long m = 1;\n    while (x > 0) {\n \
    \       q = x >> 31;\n        r = q | (r << 1);\n        m = m << 1 | (m >> 31);\n\
    \        x &= ~(q << 31);\n    }\n    q = m << 1;\n    r = r ^ (r >> 31);\n  \
    \  return q | (r << 1);\n}\n</code>\n<|/ a tags=modulus,math,modular-arithmetic,c++\
    \ dscore=1 |>\n<|\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgqwfq86c.d(47): Error: Declaration expected, not \''<\''\n/tmp/tmpgqwfq86c.d(50):
    Error: unterminated character constant\n/tmp/tmpgqwfq86c.d(54): Error: Declaration
    expected, not \''while\''\n/tmp/tmpgqwfq86c.d(56): Error: no identifier for declarator
    x\n/tmp/tmpgqwfq86c.d(56): Error: Declaration expected, not \''=\''\n/tmp/tmpgqwfq86c.d(57):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgqwfq86c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n == 0)\n\t\treturn\
    \ n;\n\tif(p == 1)\n\t\treturn n;\n\tif(p == 0)\n\t\treturn 1;\n\tif(n == p)\n\
    \t\treturn n;\n\tif(n == p - 1)\n\t\treturn mod((1L << p), p) ^ 1;\n\tif(n ==\
    \ p - 2)\n\t\treturn mod((1L << p), p) ^ 2;\n\tif(n == p - 4)\n\t\treturn mod((1L\
    \ << p), p) ^ 4;\n\tif(n == p - 8)\n\t\treturn mod((1L << p), p) ^ 8;\n\tif(n\
    \ == p - 16)\n\t\treturn mod((1L << p), p) ^ 16;\n\tif(n == p - 32)\n\t\treturn\
    \ mod((1L << p), p) ^ 32;\n\tif(n == p - 64)\n\t\treturn mod((1L << p), p) ^ 64;\n\
    \tif(n == p - 128)\n\t\treturn mod((1L << p), p) ^ 128;\n\tif(n == p - 256)\n\t\
    \treturn mod((1L << p), p) ^ 256;\n\tif(n == p - 512)\n\t\treturn mod((1L << p),\
    \ p) ^ 512;\n\tif(n == p - 1024)\n\t\treturn mod((1L << p), p) ^ 1024;\n\tif(n\
    \ == p - 2048)\n\t\treturn mod((1L << p), p) ^ 2048;\n\tif(n == p - 4096)\n\t\t\
    return mod((1L << p), p) ^ 4096;\n\tif(n == p - 8192)\n\t\treturn mod((1L << p),\
    \ p) ^ 8192;\n\treturn n;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/\nulong modp(ulong n, ulong p)\n{\n\tif(n == 0)\n\t\treturn n;\n\
    \tif(p == 1)\n\t\treturn n;\n\tif(p == 0)\n\t\treturn 1;\n\tif(n == p)\n\t\treturn\
    \ n;\n\tif(n == p - 1)\n\t\treturn mod((1UL << p), p) ^ 1;\n\tif(n == p - 2)\n\
    \t\treturn mod((1UL << p), p) ^ 2;\n\tif(n == p - 4)\n\t\treturn mod((1\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpl2uznqlg.d(86): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpl2uznqlg.d(88):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmpl2uznqlg.d(89): Error: expression
    expected, not \''alias\''\n/tmp/tmpl2uznqlg.d(89): Error: found \''candidate\''
    when expecting \'',\''\n/tmp/tmpl2uznqlg.d(89): Error: expression expected, not
    \''=\''\n/tmp/tmpl2uznqlg.d(89): Error: found \''modp\'' when expecting \'',\''\n/tmp/tmpl2uznqlg.d(89):
    Error: expression expected, not \'';\''\n/tmp/tmpl2uznqlg.d(91): Error: found
    \''assert\'' when expecting \'',\''\n/tmp/tmpl2uznqlg.d(91): Error: found \'';\''
    when expecting \'',\''\n/tmp/tmpl2uznqlg.d(92): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmpl2uznqlg.d(93): Error: found \'';\'' when expecting \'',\''\n/tmp/tmpl2uznqlg.d(94):
    Error: found \'';\'' when expecting \'',\''\n/tmp/tmpl2uznqlg.d(95): Error: found
    \'';\'' when expecting \'',\''\n/tmp/tmpl2uznqlg.d(96): Error: found \'';\'' when
    expecting \'',\''\n/tmp/tmpl2uznqlg.d(97): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmpl2uznqlg.d(98): Error: expression expected, not \''}\''\n/tmp/tmpl2uznqlg.d(99):
    Error: found \''void\'' when expecting \'',\''\n/tmp/tmpl2uznqlg.d(99): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmpl2uznqlg.d(99): Error: expression
    expected, not \''}\''\n/tmp/tmpl2uznqlg.d(99): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmpl2uznqlg.d(99): Error: found \''EOF\'' when expecting \'')\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl2uznqlg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res = 1L;\n\t\
    if (n == 0) return 0L;\n\tif (n & -p == 0) return 0L;\n\twhile (n > 0) {\n\t\t\
    res = (res<<1) + n%p;\n\t\tn = n/p;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmped9wtauu.d(21): Error: -p == 0 must be parenthesized when next
    to operator &\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmped9wtauu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n >= p)\n  \
    \  {\n        return (p + n) % p;\n    }\n    else\n    {\n        return (n +\
    \ p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n    \n \
    \   >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n    >>> modp2l(1L,\
    \ 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n    if (n >= p)\n\
    \    {\n        return (p + n) % p;\n    }\n    else\n    {\n        return (n\
    \ + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n    \n\
    \    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n    >>>\
    \ modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n    if\
    \ (n >= p)\n    {\n        return (p + n) % p;\n    }\n    else\n    {\n     \
    \   return (n + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    \n    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n \
    \   >>> modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n\
    \    if (n >= p)\n    {\n        return (p + n) % p;\n    }\n    else\n    {\n\
    \        return (n + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    \n    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n \
    \   >>> modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n\
    \    if (n >= p)\n    {\n        return (p + n) % p;\n    }\n    else\n    {\n\
    \        return (n + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    \n    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n \
    \   >>> modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5sdf0m4v.d(130): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5sdf0m4v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong rem = 0;\n\t\
    while ( n > 0 ) \n\t{\n\t\trem = ( rem << 1 ) | n % 2;\n\t\tn /= 2;\n\t}\n\twhile\
    \ ( p > 0 )\n\t{\n\t\trem = ( rem << 1 ) | ( rem & p );\n\t\tp >>= 1;\n\t}\n\t\
    return rem;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt7hulas7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res = 1;\n\t\
    for(int i = 0; i < n; ++i) {\n\t\tif (res == p || res == (p % 2)) res = (res *\
    \ res + 2) % p;\n\t\telse res = (res + n % p) % p;\n\t}\n\treturn res;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphnwgeo68.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long a = 1;\n  \
    \  long b = 2;\n    while (b < p)\n    {\n        if (b & 1)\n        {\n    \
    \        a += b;\n        }\n        b *= 2;\n    }\n    return a % p;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpazkxk0d3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn bitwise_or(\n\
    \t\tshift(bitwise_and(n,1L),bitwise_and(p,1L)),\n\t\tbitwise_and(bitwise_and(n,1L),p)\n\
    \t\t);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpba3r2otq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long d = 1;\n  \
    \  while ((d * p) != n)\n        d = (d*2) + 1;\n    return (n - d - 1) / p;\n\
    }\n/*\nReturn the first number bigger than x (be aware of numerics).\n    >>>\
    \ pow2(0L)\n    0L\n    >>> pow2(1L)\n    1L\n    >>> pow2(2L)\n    2L\n    >>>\
    \ pow2(3L)\n    8L\n    >>> pow2(3L)\n    8L\n    >>> pow2(4L)\n    16L\n    >>>\
    \ pow2(4L)\n    16L\n    \n*/\nlong pow2(long x)\n{\n    long y, t, m = 0;\n \
    \   for (y = 0; y < x; y++)\n\tm = modp(m, 2L);\n    for (y = 0; y < x; y++)\n\
    \tt = modp(2 * y, m) + 1;\n    return t;\n}\n/*\nReturn the factorial of n, modulo\
    \ p (be aware of numerics).\n    >>> fact(1L)\n    1L\n    >>> fact(2L)\n    2L\n\
    \    >>> fact(3L)\n    6L\n    >>> fact(3L)\n    6L\n    >>> fact(4L)\n    24L\n\
    \    >>> fact(4L)\n    24L\n    \n*/\nlong fact(long n)\n{\n    long t, x = 0;\n\
    \    while (n-- > 0)\n\tx = x * 2L;\n    return x;\n}\n/*\nReturn the number of\
    \ trailing zeros.\n    >>> trailingzeros(0L)\n    0L\n    >>> trailingzeros(0L)\n\
    \    0L\n    >>> trailingzeros(1L)\n    1L\n    >>> trailingzeros(1L)\n    1L\n\
    \    >>> trailingzeros(101L)\n    2L\n    >>> trailingzeros(101L)\n    2L\n  \
    \  >>> trailingzeros(11L)\n    4L\n    >>> trailingzeros(11L)\n    4L\n    \n\
    */\nlong trailingzeros(long n)\n{\n    long x;\n    x = n - 1;\n    while (n >\
    \ 0)\n\tif (n%10L == 0L)\n\t    x = x -1;\n\tn = (n-1)/10L;\n\treturn x;\n}\n\
    /*\nReturn the sum of all the digits of n (be aware of numerics).\n    >>> digitsSum(33L)\n\
    \    9L\n    >>> digitsSum(33L)\n    9L\n    >>> digitsSum(1101L)\n    12L\n \
    \   >>> digitsSum(1101L)\n    12L\n    \n*/\nlong digitsSum(long n)\n{\n    long\
    \ t;\n    for (t = 0; n < 10; n = n * 10\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbb2by5lz.d(120): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmpbb2by5lz.d(132): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbb2by5lz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int a = (int)n,\
    \ m = 0;\n    int t = p + 1;\n    int c = 1;\n    \n    while (c <= t && a) {\n\
    \        c <<= 1;\n        m++;\n        a <<= 1;\n    }\n    \n    m += p - ((p\
    \ > 0) ? c : ~c) + 1;\n    \n    if (m == 0) {\n        return n;\n    }\n   \
    \ \n    return n % m;\n}\n'''\n    \ndef mod2(x):\n    \n    '''\n    \n    Implementation\
    \ of the mod2 function (returns the modulo 2^n with n being a non-negative integer).\
    \ \n    \n    Parameters:\n    \n    x: a non-negative integer\n    \n    Returns:\n\
    \    \n    modulo 2^n\n    \n    Example:\n    \n    >>> mod2(5)\n    3\n    \n\
    \    '''\n    \n    count = 0\n    mod = 1\n    \n    while x > 0:\n        count\
    \ = count + 1\n        mod = mod << 1\n        if count == 2:\n            mod\
    \ = mod + 1\n            count = 0\n        x = x >> 1\n    return mod\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe0m7rwql.d(19): Error: C style cast illegal, use cast(int)n\n/tmp/tmpe0m7rwql.d(37):
    Error: unterminated character constant\n/tmp/tmpe0m7rwql.d(37): Error: Declaration
    expected, not \''0U\''\n/tmp/tmpe0m7rwql.d(37): Error: unterminated character
    constant\n/tmp/tmpe0m7rwql.d(41): Error: unterminated character constant\n/tmp/tmpe0m7rwql.d(41):
    Error: unterminated character constant\n/tmp/tmpe0m7rwql.d(58): Error: unterminated
    character constant\n/tmp/tmpe0m7rwql.d(58): Error: unterminated character constant\n/tmp/tmpe0m7rwql.d(75):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpe0m7rwql.d(76): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpe0m7rwql.d(77): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpe0m7rwql.d(78): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpe0m7rwql.d(79): Error: Declaration expected, not \''assert\''\n/tmp/tmpe0m7rwql.d(80):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpe0m7rwql.d(81): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpe0m7rwql.d(82): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0m7rwql.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r, s;\n\tr =\
    \ n - p*log2(p);\n\ts = n-r*log2(r);\n\ts = modpow2(s, p, r);\n\treturn r + s;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy9dpdhoo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x= n;\n   \
    \ long y= p;\n    long z= 1L;\n    \n    while (x > y) \n    {\n        x = x\
    \ / y;\n        y = y % y;\n        z = z * y % p;\n    }\n    \n    return z;\n\
    }\n// end module modp\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis works great!\
    \ Thank you! I have upvoted the answer, but I don't have the reputation yet to\
    \ make it public.\n<|/ c |>\n<| c |>\nI did vote on it yesterday by accident,\
    \ it's now up there.\n<|/ c |>\n<| c |>\nI made it public now.\n<|/ c |>\n<| c\
    \ |>\nYou do know [that you can accept answers](http://meta.stackexchange.com/a/5235)?\n\
    <|/ c |>\n<| c |>\nI didn't know you could do that. Thanks for the tip!\n<|/ c\
    \ |>\n<| a tags=python,bit-manipulation,mod,binary,c dscore=1 |>\nAs others have\
    \ mentioned, a lookup table will probably be your best bet in C. Here's an example\
    \ of a lookup table in C:\n<code>\ntypedef unsigned char byte;\ntypedef unsigned\
    \ long long ull;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyxfo0xjc.d(33): Error: Declaration expected, not \''<\''\n/tmp/tmpyxfo0xjc.d(36):
    Error: unterminated character constant\n/tmp/tmpyxfo0xjc.d(39): Error: unterminated
    character constant\n/tmp/tmpyxfo0xjc.d(48): Error: unterminated character constant\n/tmp/tmpyxfo0xjc.d(51):
    Error: unterminated character constant\n/tmp/tmpyxfo0xjc.d(54): Deprecation: use
    of typedef is deprecated; use alias instead\n/tmp/tmpyxfo0xjc.d(54): Error: no
    identifier for declarator unsigned\n/tmp/tmpyxfo0xjc.d(54): Error: semicolon expected
    to close typedef declaration\n/tmp/tmpyxfo0xjc.d(54): Error: no identifier for
    declarator long\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyxfo0xjc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn (long)math::pow2p(n,\
    \ p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzxgpjshf.d(19): Error: C style cast illegal, use cast(long)math\n/tmp/tmpzxgpjshf.d(19):
    Error: found \'':\'' when expecting \'';\'' following return statement\n/tmp/tmpzxgpjshf.d(19):
    Error: found \'':\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpzxgpjshf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  if (n >= p)\n    return\
    \ n - p;\n  else\n    return p + mod((n - p), p);\n}\n#endif\n/*\nReturn n^a mod\
    \ p, where p is prime. \n    >>> modp(7, 2L)\n    3L\n    >>> modp(8, 2L)\n  \
    \  2L\n    >>> modp(8, 3L)\n    1L\n*/\nlong modpow(long a, long p, long mod)\n\
    {\n  long res = 1L;\n  for (long d = 0L; d <= p; d += 2L) {\n    res = (res *\
    \ a) % mod;\n    res = ((res * res) % mod) %  mod;\n  }\n  return res;\n}\n/*\n\
    Return log(a) mod p.\n    >>> modp(3, 5L)\n    3L\n*/\nlong modln_mod(long a,\
    \ long p)\n{\n  long res = 1L;\n  long x = 1L;\n  while (x * p < a) {\n    if\
    \ (a % p == 0) {\n      int r = a / p;\n      res = (res * r) % p;\n    }\n  \
    \  x += (p - 1L) / p;\n  }\n  return res;\n}\n/*\nReturn 2^n modulo p where n\
    \ is prime and p is odd. \n    >>> modp(15L, 5L)\n    2L\n    >>> modp(8L, 7L)\n\
    \    3L\n*/\nlong modp2(long n, long p)\n{\n  long res = 1L;\n  long x = 1L;\n\
    \  long y = 1L;\n  while (x * p < n) {\n    if (n % p == 0) {\n      int r = n\
    \ / p;\n      res = (res * r) % p;\n    }\n    x += (p - 1L) / p;\n    y += (p\
    \ - 1L) / p;\n  }\n  return res;\n}\n/*\nReturn 2^n modulo p where n is odd and\
    \ p is odd. \n    >>> modp(3L, 5L)\n    2L\n    >>> modp(9L, 7L)\n    3L\n*/\n\
    long modp2o(long n, long p)\n{\n  long res = 1L;\n  long x = 1L;\n  long y = 1L;\n\
    \  while (x * p < n) {\n    if (n % p == 0) {\n      int r = n / p;\n      res\
    \ = (res * r) % p;\n    }\n    x += (p - 1L) / p;\n    y += (p - 1L) / p;\n  }\n\
    \  return res;\n}\n/*\nReturn n^a mod p, where p is prime. \n    >>> modp(\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp0z4ou36n.d(24): Error: Declaration expected, not \''#\''\n/tmp/tmp0z4ou36n.d(37):
    Error: Declaration expected, not \''for\''\n/tmp/tmp0z4ou36n.d(37): Error: no
    identifier for declarator d\n/tmp/tmp0z4ou36n.d(37): Error: Declaration expected,
    not \''<=\''\n/tmp/tmp0z4ou36n.d(37): Error: no identifier for declarator d\n/tmp/tmp0z4ou36n.d(37):
    Error: Declaration expected, not \''+=\''\n/tmp/tmp0z4ou36n.d(39): Error: no identifier
    for declarator res\n/tmp/tmp0z4ou36n.d(39): Error: Declaration expected, not \''=\''\n/tmp/tmp0z4ou36n.d(40):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0z4ou36n.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long x = 0;\n  while\
    \ ( n < p ) \n  {\n    n <<= 1;\n    x <<= 1;\n  }\n  x &= (p - 1L);\n  n &= (p\
    \ - 1);\n  x ^= n;\n  n ^= x;\n  x ^= n;\n  n ^= x;\n  return n;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnfqw6176.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint i;\n\tlong r =\
    \ 1L;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps5mjyops.d(21): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps5mjyops.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long p2 = modpow(p,2,n);\n\
    \    return n%p2; \n}\n/*\nReturn n modulo p in O(logn) time.\n    NOTE: n must\
    \ be positive.\n    NOTE: if n is negative, result is undefined.\n    >>> modpow(0L,\
    \ 0L, 0L)\n    0L\n    >>> modpow(0L, 0L, 1L)\n    1L\n    >>> modpow(0L, 1L,\
    \ 0L)\n    1L\n    >>> modpow(0L, 1L, 1L)\n    0L\n    >>> modpow(1L, 0L, 1L)\n\
    \    0L\n    >>> modpow(1L, 1L, 0L)\n    1L\n    >>> modpow(1L, 1L, 1L)\n    1L\n\
    \    \n    \n    >>> modpow(-3L, 3L, 3L)\n    0L\n    >>> modpow(-3L, 3L, 4L)\n\
    \    0L\n    >>> modpow(-3L, 4L, 3L)\n    1L\n    >>> modpow(-3L, 4L, 4L)\n  \
    \  1L\n    >>> modpow(-5L, 3L, 3L)\n    1L\n    >>> modpow(-5L, 3L, 4L)\n    2L\n\
    \    >>> modpow(-5L, 4L, 3L)\n    2L\n    >>> modpow(-5L, 4L, 4L)\n    3L\n  \
    \  \n*/\nlong modpow(long n, long p, long modulo) \n{\n    long p2 = modpow(p,2,n);\n\
    \    long q2 = modpow(p2,2,modulo);\n    long r2 = n%p2;\n    return p2+(modulo*q2%modulo)-r2;\
    \ \n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph6fjrx7z.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1;\n\
    \    if (n % 2 == 0) \n    {\n        res = (res << 1) % p;\n        n /= 2;\n\
    \    } \n    while (n != 0)\n    {\n        if (n % 2 == 1)\n        {\n     \
    \       res = (res * (p / 2)) % p;\n            n /= 2;\n        } \n        else\n\
    \        {\n            res = (res) % p;\n            n /= 2;\n        }\n   \
    \ }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl8pn3l4c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong tmp;\n\ttmp =\
    \ n % p;\n\tif (tmp == 0) \n\t\treturn n;\n\telse\n\t\treturn (p * pow(2,(long)(n\
    \ - tmp)) % p); \n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppea9tk_o.d(24): Error: C style cast illegal, use cast(long)(n
    - tmp)\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppea9tk_o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n < 0)\n\t\tn\
    \ = -n;\n\tif (p < 0)\n\t\tp = -p;\n\t\n\tlong r = 1;\n\twhile (n) {\n\t\tif (n\
    \ % 2 == 0)\n\t\t\tr = (r << 1) + 1;\n\t\tn = n / 2;\n\t}\n\twhile (p) {\n\t\t\
    if (p % 2 == 0)\n\t\t\tr = (r << 1) + 1;\n\t\tp = p / 2;\n\t}\n\treturn r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpktndldvp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  int r;\n  long r =\
    \ n % p;\n  if (r != 0) \n    r = p - r;\n  return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpit40rxkk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\t/*\n\t   0\n\t 8\n\
    \t17\n\t22\n\t27\n\t32\n\t37\n\t42\n\t47\n\t52\n\t57\n\t62\n\t67\n\t72\n\t77\n\
    \t82\n\t87\n\t92\n\t97\n\t102\n\t107\n\t112\n\t117\n\t122\n\t127\n\t132\n\t137\n\
    \t142\n\t147\n\t152\n\t157\n\t162\n\t167\n\t172\n\t177\n\t182\n\t187\n\t192\n\t\
    197\n\t202\n\t207\n\t212\n\t217\n\t222\n\t227\n\t232\n\t237\n\t242\n\t247\n\t\
    252\n\t257\n\t262\n\t267\n\t272\n\t277\n\t282\n\t287\n\t292\n\t297\n\t302\n\t\
    307\n\t312\n\t317\n\t322\n\t327\n\t332\n\t337\n\t342\n\t347\n\t352\n\t357\n\t\
    362\n\t367\n\t372\n\t377\n\t382\n\t387\n\t392\n\t397\n\t402\n\t407\n\t412\n\t\
    417\n\t422\n\t427\n\t432\n\t437\n\t442\n\t457\n\t462 \n\t*/\n\t\n\tif (n < p)\
    \ {\n\t\treturn 0;\n\t}\n\t\n\tif (n == p) return 1;\n\tif (n == (p-1U)) {\n\t\
    \treturn p;\n\t}\n\t\n\tlong d = 1;\n\t\n\twhile (d < p) {\n\t\td *= 2;\n\t}\n\
    \t\n\twhile ((n % d) != 0) {\n\t\td *= 2;\n\t\tn++;\n\t}\n\t\n\treturn (n-d);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfm09nj7g.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long ret = 1;\n\
    \    for (; n > 0; n /= p)\n        ret *= p;\n    ret %= p;\n    if (n < p) \n\
    \        ret += p;\n    return ret;\n}\n</code>\n<|/ a tags=math,algorithm,modulus,integer,language-agnostic\
    \ |>\n<| c |>\nHow does this answer the question? It doesn't seem to address any\
    \ specific questions about modulus. I'm also not sure that `modp(11L, 101L)` is\
    \ supposed to produce `8L`. It should produce `5L`.\n<|/ c |>\n<| c |>\n: Yes,\
    \ you are right.  It produces 5L.  I fixed that and added an explanation.  Thanks.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe code in the question does not really implement\
    \ modular exponentiation at all. It merely does a bit-wise xor-operation on the\
    \ two numbers, then does an exponentiation by squaring them. \nThe bit-wise xor\
    \ operation is probably not the best idea in this case, since it only works for\
    \ unsigned integers.\n<|/ a tags=math,algorithm,modulus,integer,language-agnostic\
    \ |>\n<| c |>\nThis doesn't really answer the question. I don't see how this explains\
    \ how to implement modular exponentiation.\n<|/ c |>\n<| c |>\n- yes, it does.\
    \  I suggest reading up on modular exponentiation and studying the code in that\
    \ answer.\n<|/ c |>\n<| c |>\nYou only need to implement modular exponentiation\
    \ when it is known that the two exponents are not a power of two. Of course, you\
    \ could just use the modulus operator as in the code in the question, but this\
    \ would work for any exponent.\n<|/ c |>\n<| a dscore=0 |>\nJust implement the\
    \ modular exponentiation.\n<code>\n#include <iostream>\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxvtptfox.d(27): Error: Declaration expected, not \''<\''\n/tmp/tmpxvtptfox.d(30):
    Error: unterminated character constant\n/tmp/tmpxvtptfox.d(30): Error: unterminated
    character constant\n/tmp/tmpxvtptfox.d(40): Error: unterminated character constant\n/tmp/tmpxvtptfox.d(40):
    Error: unterminated character constant\n/tmp/tmpxvtptfox.d(56): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpxvtptfox.d(57): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpxvtptfox.d(58): Error: Declaration expected, not \''assert\''\n/tmp/tmpxvtptfox.d(59):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpxvtptfox.d(60): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpxvtptfox.d(61): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpxvtptfox.d(62): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpxvtptfox.d(63): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxvtptfox.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d = n - 1L;\n\
    \t\n\twhile ((d & 1) != 0 && d != 1L) \n\t{\n\t\td >>= 1;\n\t\tn--;\n\t}\n\t\n\
    \td = 1L << n;\n\td -= p;\n\t\n\tif (d == 0L)\n\t{\n\t\treturn 1L;\n\t}\n\telse\n\
    \t{\n\t\treturn d;\n\t}\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprg9q5wc9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n   long r, t;\n   t\
    \ = ((r=(long)p)%(long)n);\n   if ((t >= 0) && ((long)(r+n) < p)) {\n      r =\
    \ (long)r;\n   } \n   return r;\n}\n'''\n    \nclass Power:\n    '''\n    The\
    \ power class, used to represent a power with two operands\n    '''\n    def __init__(self,\
    \ base=0, exp=0):\n        self.base = base\n        self.exp = exp\n    def __str__(self):\n\
    \        return '{}^{}'.format(self.base, self.exp)\n    def __repr__(self):\n\
    \        return 'Power({}, {})'.format(self.base, self.exp)\n    def __rpow__(self,\
    \ pow):\n        if isinstance(pow, Power):\n            return Power(pow.base,\
    \ pow.exp * pow.base)\n        return Power(pow, self.exp)\n    def __add__(self,\
    \ other):\n        if isinstance(other, Power):\n            base = (self.base\
    \ * other.base) % mod\n            exp = (self.exp + other.exp) % mod\n      \
    \      return Power(base, exp)\n        if isinstance(other, int) or isinstance(other,\
    \ long):\n            base = (self.base * other) % mod\n            exp = (self.exp\
    \ + other) % mod\n            return Power(base, exp)\n        raise TypeError('unsupported\
    \ operand type(s) for +: Power and {}'.format(type(other)))\n    def __sub__(self,\
    \ other):\n        if isinstance(other, Power):\n            base = (self.base\
    \ * other.base) % mod\n            exp = (self.exp + other.exp) % mod\n      \
    \      return Power(base, exp)\n        if isinstance(other, int) or isinstance(other,\
    \ long):\n            base = (self.base - other) % mod\n            exp = (self.exp\
    \ - other) % mod\n            return Power(base, exp)\n        raise TypeError('unsupported\
    \ operand type(s) for +: Power and {}'.format(type(other)))\n    def __mul__(self,\
    \ other):\n        if isinstance(other, Power):\n            base = (self.base\
    \ * other.base) % mod\n            exp = (self.exp * other.exp) % mod\n      \
    \      return Power(base, exp)\n        if isinstance(other, int) or isinstance(other,\
    \ long):\n            base = (self.base * other) % mod\n            exp = (self.exp\
    \ * other) % mod\n            return Power(base, exp)\n        raise TypeError('unsupported\
    \ operand type(s) for +: Power and {}'.format(type(other)))\n    def __div__(self,\
    \ other):\n        if isinstance(other, Power):\n            base = (self.base\
    \ % other.base) / other.base\n            exp = (self.exp % other.exp) / other.exp\n\
    \            return Power(base, exp)\n        if isinstance(other, int) or isinstance(other,\
    \ long):\n            base = (self.base % other) / other\n            exp = (self.exp\
    \ % other) / other\n            return Power(base, exp)\n        raise TypeError('unsupported\
    \ operand type(s) for +: Power and {}'.format(type(other)))\n    def __rdiv__(self,\
    \ other):\n        if isinstance(other, Power):\n            base = other.base\
    \ * self.base\n            exp = other.exp * self.exp\n            return Power(base,\
    \ exp)\n        if isinstance(other, int) or isinstance(other, long):\n      \
    \      \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpw5adzz_5.d(20): Error: C style cast illegal, use cast(long)p\n/tmp/tmpw5adzz_5.d(20):
    Error: C style cast illegal, use cast(long)n\n/tmp/tmpw5adzz_5.d(21): Error: C
    style cast illegal, use cast(long)(r + n)\n/tmp/tmpw5adzz_5.d(22): Error: C style
    cast illegal, use cast(long)r\n/tmp/tmpw5adzz_5.d(26): Error: unterminated character
    constant\n/tmp/tmpw5adzz_5.d(26): Error: Declaration expected, not \''24009344U\''\n/tmp/tmpw5adzz_5.d(26):
    Error: unterminated character constant\n/tmp/tmpw5adzz_5.d(29): Error: unterminated
    character constant\n/tmp/tmpw5adzz_5.d(29): Error: unterminated character constant\n/tmp/tmpw5adzz_5.d(31):
    Error: unterminated character constant\n/tmp/tmpw5adzz_5.d(31): Error: unterminated
    character constant\n/tmp/tmpw5adzz_5.d(36): Error: unterminated character constant\n/tmp/tmpw5adzz_5.d(36):
    Error: unterminated character constant\n/tmp/tmpw5adzz_5.d(38): Error: unterminated
    character constant\n/tmp/tmpw5adzz_5.d(38): Error: unterminated character constant\n/tmp/tmpw5adzz_5.d(52):
    Error: unterminated character constant\n/tmp/tmpw5adzz_5.d(52): Error: unterminated
    character constant\n/tmp/tmpw5adzz_5.d(62): Error: unterminated character constant\n/tmp/tmpw5adzz_5.d(62):
    Error: unterminated character constant\n/tmp/tmpw5adzz_5.d(72): Error: unterminated
    character constant\n/tmp/tmpw5adzz_5.d(72): Error: unterminated character constant\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw5adzz_5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return 1L ^ (n &\
    \ -p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj8qt8huo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong result = 1L;\n\
    \t\n\twhile(n > p)\n\t{\n\t\tif(n > p) n--;\n\t\tresult = (result << 1) | n;\n\
    \t}\n\t\n\twhile(n < p)\n\t{\n\t\tresult <<= 1;\n\t\tif(n == p)\n\t\t\treturn\
    \ result;\n\t\tn++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmput4rm8na.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x;\n    long\
    \ mod;\n    x = modinv(p, n);\n    mod = (x & 1) ? (p ^ x) : x;\n    return (n\
    \ ^ mod);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnods0f9i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int bits = (int)p;\n\
    \    long r = 1;\n    long m = 0;\n    while (n > 0) {\n\tif (n & 1) {\n\t   \
    \ m = r * p;\n\t    r = std.math.remainder(m, p);\n\t}\n\tbits = bits - 1;\n\t\
    n = n >> 1;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp944crla_.d(19): Error: C style cast illegal, use cast(int)p\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp944crla_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n == 0)\n\t\treturn\
    \ 0;\n\tif(p == 0)\n\t\treturn n;\n\treturn std.__modpow(n, std.__sub(p, 1L),\
    \ p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ju8hd3w.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  int i, k = 1;\n  for\
    \ (i = 0; i < (int) sizeof(ulong) * CHAR_BIT; i = i + 1) {\n    if (p == 1)\n\
    \      return n;\n    if (p & 1) {\n      n = n << 1;\n      k++;\n    }\n   \
    \ if (k & 1)\n      n = n ^ ((ulong) n >> (ulong) i);\n    p = p >> 1;\n    k++;\n\
    \  }\n  return n;\n}\n'''\n</cell>\n<cell>\n# Cell\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkyauu6mt.d(20): Error: found \'')\'' when expecting \''.\''
    following ulong\n/tmp/tmpkyauu6mt.d(20): Error: found \''*\'' when expecting identifier
    following \''ulong.\''\n/tmp/tmpkyauu6mt.d(20): Error: found \''CHAR_BIT\'' when
    expecting \'',\''\n/tmp/tmpkyauu6mt.d(20): Error: expression expected, not \'';\''\n/tmp/tmpkyauu6mt.d(20):
    Error: found \''i\'' when expecting \'',\''\n/tmp/tmpkyauu6mt.d(20): Error: expression
    expected, not \''=\''\n/tmp/tmpkyauu6mt.d(20): Error: found \''i\'' when expecting
    \'',\''\n/tmp/tmpkyauu6mt.d(20): Error: C style cast illegal, use cast(int)sizeof(0,
    0, 0, +1)\n/tmp/tmpkyauu6mt.d(20): Error: found \''{\'' when expecting \'';\''
    following for condition\n/tmp/tmpkyauu6mt.d(21): Error: expression expected, not
    \''if\''\n/tmp/tmpkyauu6mt.d(22): Error: found \''return\'' when expecting \'')\''\n/tmp/tmpkyauu6mt.d(28):
    Error: C style cast illegal, use cast(ulong)n\n/tmp/tmpkyauu6mt.d(28): Error:
    C style cast illegal, use cast(ulong)i\n/tmp/tmpkyauu6mt.d(32): Error: Declaration
    expected, not \''return\''\n/tmp/tmpkyauu6mt.d(33): Error: unrecognized declaration\n/tmp/tmpkyauu6mt.d(34):
    Error: unterminated character constant\n/tmp/tmpkyauu6mt.d(34): Error: unterminated
    character constant\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkyauu6mt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong tmp;\n\tif (p==0)\n\
    \t\treturn n;\n\ttmp = (n & (p-1));\n\tif (tmp==n)\n\t\treturn p;\n\treturn (tmp+1)|p|modp((tmp&n)|p|p-1,\
    \ p);\n}\n\t\n//@version=52 nov. 2009\n//@qpy:none\nimport std.random;\nimport\
    \ std.time;\nimport std.datetime;\nimport std.random;\nimport std.range;\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppig5qp45.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  return modpow(n, p,\
    \ p);\n}\n#endif\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc9rqhev4.d(21): Error: Declaration expected, not \''#\''\n/tmp/tmpc9rqhev4.d(26):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpc9rqhev4.d(27): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpc9rqhev4.d(28): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpc9rqhev4.d(29): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpc9rqhev4.d(30): Error: Declaration expected, not \''assert\''\n/tmp/tmpc9rqhev4.d(31):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpc9rqhev4.d(32): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpc9rqhev4.d(33): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc9rqhev4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long d;\n    n =\
    \ (long)((n * p) % p);\n    d = (long)(n >> 5); \n    while (d > 0)\n    {\n \
    \       long tmp = (n%p); \n        n = (n-p);\n        d = (long)(tmp >> 5);\
    \ \n    }\n    return (n << 5) + d;\n}\n/*\nReturn 2^n (mod p).\n    >>> mod2(3L,\
    \ 5L)\n    3L\n    >>> mod2(1101L, 101L)\n    2L\n    >>> mod2(0L, 101L)\n   \
    \ 1L\n    >>> mod2(3L, 11L)\n    8L\n    >>> mod2(100L, 101L)\n    1L\n    \n\
    */\nlong mod2(long n, long p) \n{\n    long d;\n    n = (long)((n * p) % p);\n\
    \    d = (long)(n >> 5); \n    while (d > 0)\n    {\n        long tmp = (n%p);\
    \ \n        n = (n-p);\n        d = (long)(tmp >> 5); \n    }\n    return n;\n\
    }\n/*\nReturn 2^n mod p.\n    >>> mod2p(3L, 5L)\n    3L\n    >>> mod2p(1101L,\
    \ 101L)\n    2L\n    >>> mod2p(0L, 101L)\n    1L\n    >>> mod2p(3L, 11L)\n   \
    \ 8L\n    >>> mod2p(100L, 101L)\n    1L\n    \n*/\nlong mod2p(long n, long p)\
    \ \n{\n    long d;\n    n = (long)((n * p) % p);\n    d = (long)(n >> 5); \n \
    \   while (d > 0)\n    {\n        long tmp = (n%p); \n        n = (n-p);\n   \
    \     d = (long)(tmp >> 5); \n    }\n    return (n << 5) + d;\n}\n/*\nReturn 2^n\
    \ modulo p (be aware of numerics).\n    >>> mod2p(3L, 5L)\n    3L\n    >>> mod2p(1101L,\
    \ 101L)\n    2L\n    >>> mod2p(0L, 101L)\n    1L\n    >>> mod2p(3L, 11L)\n   \
    \ 8L\n    >>> mod2p(100L, 101L)\n    1L\n    \n*/\nlong mod2p(long n, long p)\
    \ \n{\n    long d;\n    n = (long)((n * p) % p);\n    d = (long)(n >> 5); \n \
    \   while (d > 0)\n    {\n        long tmp = (n%p); \n        n = (n-p);\n   \
    \     d = (long)(tmp >> 5); \n    }\n    return n;\n}\n/*\n\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp72jxd20f.d(20): Error: C style cast illegal, use cast(long)(n
    * p % p)\n/tmp/tmp72jxd20f.d(21): Error: C style cast illegal, use cast(long)(n
    >> 5)\n/tmp/tmp72jxd20f.d(26): Error: C style cast illegal, use cast(long)(tmp
    >> 5)\n/tmp/tmp72jxd20f.d(47): Error: C style cast illegal, use cast(long)(n *
    p % p)\n/tmp/tmp72jxd20f.d(48): Error: C style cast illegal, use cast(long)(n
    >> 5)\n/tmp/tmp72jxd20f.d(53): Error: C style cast illegal, use cast(long)(tmp
    >> 5)\n/tmp/tmp72jxd20f.d(74): Error: C style cast illegal, use cast(long)(n *
    p % p)\n/tmp/tmp72jxd20f.d(75): Error: C style cast illegal, use cast(long)(n
    >> 5)\n/tmp/tmp72jxd20f.d(80): Error: C style cast illegal, use cast(long)(tmp
    >> 5)\n/tmp/tmp72jxd20f.d(101): Error: C style cast illegal, use cast(long)(n
    * p % p)\n/tmp/tmp72jxd20f.d(102): Error: C style cast illegal, use cast(long)(n
    >> 5)\n/tmp/tmp72jxd20f.d(107): Error: C style cast illegal, use cast(long)(tmp
    >> 5)\n/tmp/tmp72jxd20f.d(111): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp72jxd20f.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r = 1;\n\twhile\
    \ (n) {\n\t\tif (n % p)\n\t\t\tr = (r * 10) % p;\n\t\tn = (n * 10) % p;\n\t}\n\
    \treturn r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8potqzzp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q, m;\n\t\n\t\
    if(n == 0) return 1;\n\tif(n == 1) return n;\n\t\n\tif(p == 1)\n\t{\n\t\treturn\
    \ n;\n\t}\n\t\n\tif(n == p)\n\t{\n\t\treturn 1;\n\t}\n\t\n\tq = modp(n/p, p);\n\
    \tm = n % p;\n\t\n\treturn q * p + m;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpivbzec83.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n > p) {\n \
    \       long ans = (n%p);\n        long t = (n%p) + p;\n        ans %= t;\n  \
    \      ans %= p;\n        return ans;\n    }\n    return n;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph4lycxqc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if(p < 0)\n    \
    \    p = 0;\n    if(n == 0)\n        return p;\n    if(p == 1)\n        return\
    \ n;\n    if(p == 2)\n        return n;\n    if(n % p == 0)\n        return modp(n\
    \ / p, p);\n    return modp(n % p, p);\n}\nlong pow2(long n, long p)\n{\n    long\
    \ res = 1;\n    long t = 1;\n    for(; p > 0; p >>= 1)\n    {\n        if(p&1)\n\
    \            res *= n;\n        n *= t;\n        t *= n;\n    }\n    return res;\n\
    }\n/*\nReturn n! modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n    3L\n\
    \    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nlong modp(long n,\
    \ long p)\n{\n    return modp(n, modp(modp(modp(modp(modp(modp(modp(modp(n, modp(modp(modp(modp(n,\
    \ modp(modp(modp(modp(n, modp(1)))))), modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(n)))))), modp(modp(modp(modp(modp(modp(modp(modp(1)))))))),\
    \ modp(modp(modp(modp(modp(modp(modp(n)))))), modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3ql0pkt1.d(61): Error: expression expected, not \''unittest\''\n/tmp/tmp3ql0pkt1.d(62):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmp3ql0pkt1.d(63): Error: expression
    expected, not \''alias\''\n/tmp/tmp3ql0pkt1.d(63): Error: found \''candidate\''
    when expecting \'',\''\n/tmp/tmp3ql0pkt1.d(63): Error: expression expected, not
    \''=\''\n/tmp/tmp3ql0pkt1.d(63): Error: found \''modp\'' when expecting \'',\''\n/tmp/tmp3ql0pkt1.d(63):
    Error: expression expected, not \'';\''\n/tmp/tmp3ql0pkt1.d(65): Error: found
    \''assert\'' when expecting \'',\''\n/tmp/tmp3ql0pkt1.d(65): Error: found \'';\''
    when expecting \'',\''\n/tmp/tmp3ql0pkt1.d(66): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmp3ql0pkt1.d(67): Error: found \'';\'' when expecting \'',\''\n/tmp/tmp3ql0pkt1.d(68):
    Error: found \'';\'' when expecting \'',\''\n/tmp/tmp3ql0pkt1.d(69): Error: found
    \'';\'' when expecting \'',\''\n/tmp/tmp3ql0pkt1.d(70): Error: found \'';\'' when
    expecting \'',\''\n/tmp/tmp3ql0pkt1.d(71): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmp3ql0pkt1.d(72): Error: expression expected, not \''}\''\n/tmp/tmp3ql0pkt1.d(73):
    Error: found \''void\'' when expecting \'',\''\n/tmp/tmp3ql0pkt1.d(73): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmp3ql0pkt1.d(73): Error: expression
    expected, not \''}\''\n/tmp/tmp3ql0pkt1.d(73): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmp3ql0pkt1.d(73): Error: found \''EOF\'' when expecting \'')\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3ql0pkt1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return pow(2l, n-p,\
    \ p);\n}\n</code>\n<|/ a dscore=4 tags=java |>\n<| a dscore=4 |>\nHere's an example\
    \ of the code as of Java 8:\n<code>\nimport java.util.function.Function;\nimport\
    \ java.util.function.IntBinaryOperator;\nimport java.util.stream.IntStream;\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp970rhk1g.d(19): Error: Lower case integer suffix \''l\'' is
    not allowed. Please use \''L\'' instead\n/tmp/tmp970rhk1g.d(21): Error: Declaration
    expected, not \''<\''\n/tmp/tmp970rhk1g.d(24): Error: unterminated character constant\n/tmp/tmp970rhk1g.d(27):
    Error: identifier expected following package\n/tmp/tmp970rhk1g.d(27): Error: \'';\''
    expected\n/tmp/tmp970rhk1g.d(27): Error: no identifier for declarator .IntBinaryOperator\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp970rhk1g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p != 0)\n\t{\n\
    \t\tlong m = (n >> p) & p;\n\t\treturn (n - (m << p)) % p;\n\t} \n\telse return\
    \ 0;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8aojrait.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  if(n < p) {\n    if(n\
    \ <= (long)((double)p - (double)(n))) return n;\n    return (n-p) % (p-1);\n \
    \ }\n  else return n-p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvizokuat.d(20): Error: C style cast illegal, use cast(double)p\n/tmp/tmpvizokuat.d(20):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmpvizokuat.d(20): Error:
    C style cast illegal, use cast(long)(cast(double)p - cast(double)n)\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpvizokuat.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0 || p\
    \ == 0)\n        return 0;\n    long res = p%n;\n    if (res == 0)\n        return\
    \ n;\n    else if (res > 0)\n        return modp(res, p) + 1;\n    else\n    \
    \    return modp(res, n);\n}\n'''\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5yzz2kg3.d(29): Error: unterminated character constant\n/tmp/tmp5yzz2kg3.d(29):
    Error: Declaration expected, not \''12049696U\''\n/tmp/tmp5yzz2kg3.d(29): Error:
    unterminated character constant\n/tmp/tmp5yzz2kg3.d(34): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp5yzz2kg3.d(35): Error: Declaration expected, not \''assert\''\n/tmp/tmp5yzz2kg3.d(36):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp5yzz2kg3.d(37): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp5yzz2kg3.d(38): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp5yzz2kg3.d(39): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp5yzz2kg3.d(40): Error: Declaration expected, not \''assert\''\n/tmp/tmp5yzz2kg3.d(41):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5yzz2kg3.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  if (p == 0) return\
    \ 1;\n  if (p == 1) return n;\n  if (p == 2) return 2L * n;\n  if (p == 6) return\
    \ (11L + 7L) * n - (7L * 11L);\n  if (p == 9) return (35L + 10L) * n - (10L *\
    \ 35L);\n  if (p == 12) return (755L + 21L) * n - (21L * 755L);\n  if (p == 15)\
    \ return (1110L + 54L) * n - (54L * 1110L);\n  if (p == 18) return (1066L + 104L)\
    \ * n - (104L * 1066L);\n  if (p == 23) return (1564L + 174L) * n - (174L * 1564L);\n\
    \  if (p == 28) return (1864L + 236L) * n - (236L * 1864L);\n  if (p == 33) return\
    \ (2066L + 272L) * n - (272L * 2066L);\n  if (p == 38) return (2196L + 296L) *\
    \ n - (296L * 2196L);\n  if (p == 43) return (2244L + 352L) * n - (352L * 2244L);\n\
    \  if (p == 48) return (2324L + 394L) * n - (394L * 2324L);\n  if (p == 53) return\
    \ (2468L + 444L) * n - (444L * 2468L);\n  if (p == 58) return (2556L + 512L) *\
    \ n - (512L * 2556L);\n  if (p == 63) return (2744L + 576L) * n - (576L * 2744L);\n\
    \  if (p == 68) return (2876L + 624L) * n - (624L * 2876L);\n  if (p == 75) return\
    \ (3056L + 648L) * n - (648L * 3056L);\n  if (p == 80) return (3216L + 704L) *\
    \ n - (704L * 3216L);\n  if (p == 87) return (3376L + 768L) * n - (768L * 3376L);\n\
    \  if (p == 94) return (3564L + 824L) * n - (824L * 3564L);\n  if (p == 101) return\
    \ (3680L + 896L) * n - (896L * 3680L);\n  if (p == 108) return (3802L + 944L)\
    \ * n - (944L\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpa3a1tbjw.d(42): Error: found \''unittest\'' when expecting \'')\''\n/tmp/tmpa3a1tbjw.d(44):
    Error: found \''{\'' when expecting \'';\'' following return statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa3a1tbjw.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while ((n & p) != 0L) {\n        result *= 2L;\n        n /= p; \n    }\n\
    \    return result;\n}\n/* \nReturn ceil(n).\n    >>> ceilp(5L)\n    6L\n    >>>\
    \ ceilp(3L)\n    2L\n    \n*/\nlong ceilp(long n)\n{\n    return (n+(n&1)-1)/2;\n\
    }\n/*\nReturn floor of n.\n    >>> floorp(5L)\n    3L\n    >>> floorp(3L)\n  \
    \  2L\n    \n*/\nlong floorp(long n)\n{\n    return (n-1)/2;\n}\n/*\nReturn true\
    \ iff n is integer.\n    >>> ispp(3L)\n    True\n    >>> ispp(1L)\n    False\n\
    \    \n*/\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc7z6rsaf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong result = n;\n\
    \tfor (;;) {\n\t\tresult %= p;\n\t\tif (result < n) {\n\t\t\treturn result;\n\t\
    \t}\n\t\tresult = (result << 1) % p;\n\t}\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modm(3L, 5L)\n    3L\n    >>> modm(1101L, 101L)\n   \
    \ 2L\n    >>> modm(0L, 101L)\n    1L\n    >>> modm(3L, 11L)\n    8L\n    >>> modm(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modm(long n, long p) \n{\n\treturn modp(modp(n,\
    \ p), p);\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> modm(3L,\
    \ 5L)\n    3L\n    >>> modm(1101L, 101L)\n    2L\n    >>> modm(0L, 101L)\n   \
    \ 1L\n    >>> modm(3L, 11L)\n    8L\n    >>> modm(100L, 101L)\n    1L\n    \n\
    */\nlong modm(long n, long p, long mod) {\n\treturn modp(modp(n, p), mod);\n}\n\
    /*\nReturn p^n (be aware of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>>\
    \ modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nlong modp(long n,\
    \ long p) \n{\n\tlong result = p;\n\tfor (;;) {\n\t\tresult *= n;\n\t\tresult\
    \ %= p;\n\t\tif (result < n) {\n\t\t\treturn result;\n\t\t}\n\t\tresult /= p;\n\
    \t}\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqwha6ds0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1;\n\
    \    for(long i=0; i<n; i++) res = res * p % p;\n    return res;\n}\n</code>\n\
    It works with all natural numbers, even negatives.\n<code>\nimport std.algorithm;\
    \ \nimport std.stdio;\nimport std.string;\nunittest\n{\n    alias candidate =\
    \ modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L)\
    \ == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L)\
    \ == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpx13pk4cr.d(23): Error: Declaration expected, not \''<\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx13pk4cr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long r;\n  if(n==0)\n\
    \    return 0L;\n  if(n==1L) return p; \n  if(p==0)\n    return 0;\n  if(p==1L)\n\
    \    return p;\n  r = modp(n - 1, p); \n  if(n > (long)(INT_MAX/p))\n    {\n \
    \     long q = modp(INT_MAX - n, p);\n      r = q | (r << 32L);\n    }\n  return\
    \ r+p; \n} \n/* \n   Return n^(1/d) modulo p.\n   \n   See http://www.math.rutgers.edu/~z70ws/naca0068/math_faq2.html\
    \ for more info.\n   \n   >>> modp2(3, 5)\n   3\n   >>> modp2(1101, 101)\n   2\n\
    \   >>> modp2(0, 101)\n   1\n   >>> modp2(3, 11)\n   8\n   >>> modp2(100, 101)\n\
    \   1\n*/\nlong modp2(long n, long d)\n{\n  long p = d*d;\n  return modp(n, p);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpbyi38p_e.d(28): Error: C style cast illegal, use cast(long)(INT_MAX
    / p)\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbyi38p_e.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong mask = (1L <<\
    \ p) - 1;\n\tlong res = n % p;\n\tif (res < p) \n\t\tres += p;\n\treturn res &\
    \ mask;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ovcsyo5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x, y, z, tmp;\n\
    \    if(p > p) return 0;\n    if(p < 2 || p > n) return 0;\n    if(n & 1) return\
    \ 0;\n    if(n <= p) return n;\n    for(y = 0; y < n; y++){\n        for(x = 0,\
    \ tmp = 1; tmp < p; tmp = tmp * 2){\n            z = (x^tmp) % p;\n          \
    \  if(z != 0){\n                if((z + y) % 2 == 0)\n                    return\
    \ z;\n                else{\n                    x = z;\n                }\n \
    \           }\n        }\n    }\n    return 0;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpltoo0jap.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long d;\n    \n\
    \    d = n - p; // = n - (p ^ n);\n    if (d < 0)\n        d = d + p;\n    \n\
    \    return d % p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk_vuhhcw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int shift = 32 -\
    \ __builtin_clz(n);\n    if (shift < 0) shift = 0;\n    return ((n << shift) %\
    \ (p == 0) ? p : ((p & -p) + p));\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl0bz91sn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 0;\n    if (p == 0)\n        return 1;\n    if (p == 1)\n      \
    \  return n;\n    if (p > n || p < 1)\n        return 0;\n    \n    long q = n\
    \ / p;\n    \n    long d = n % p;\n    \n    if (d == 0)\n        return n;\n\
    \    \n    long t = p - 1;\n    \n    if (q == 0)\n        return t;\n    \n \
    \   if (q == 1)\n        return p * t;\n    \n    long c = 1;\n    \n    while\
    \ (t != 0) {\n        t = t&(~d);\n        q = q<<1;\n        if (q == 1) {\n\
    \            c = c<<1;\n            c = c+t;\n        }\n        d = (d)<<1;\n\
    \    }\n    \n    return c;\n}\nunittest\n{\n    alias candidate = modp;\n\n \
    \   assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_0thwwv8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn n & (-p);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpylcitntb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1;\n\
    \    long m;\n    long m1, m2;\n    long mask;\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpigcrx541.d(23): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpigcrx541.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int n1 = n % p;\n\
    \    if (n1 == 0) {\n        return n;\n    } else {\n        return ((n-1) /\
    \ p) * p;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi5x849l4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   for (; n != 0L; n--, p >>= 1) {\n        if ((r << 1) + (r >> 3) >= p)\n \
    \           r &= p - 1;\n        else\n            r &= p;\n    }\n    return\
    \ r;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI used the following function for\
    \ finding the number of trailing zeros in the binary representation of the number:\n\
    <code>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2k56t2a6.d(28): Error: Declaration expected, not \''<\''\n/tmp/tmp2k56t2a6.d(37):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp2k56t2a6.d(38): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp2k56t2a6.d(39): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp2k56t2a6.d(40): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp2k56t2a6.d(41): Error: Declaration expected, not \''assert\''\n/tmp/tmp2k56t2a6.d(42):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp2k56t2a6.d(43): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp2k56t2a6.d(44): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2k56t2a6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r;\n    if\
    \ ((n & -p) == n)\n        return 0;\n    r =  (n & (-p));\n    r = (r >> 1) ^\
    \ ((n & 1) == 0 ? 0x571bf95e : 0);\n    r = (r >> 1) ^ ((n & 1) == 0 ? 0xab9ac971\
    \ : 0);\n    return (r & p) == 0 ? r : (p^r);\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps1fhk2fa.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (p == 0) {\n\
    \        return 0;\n    }\n    if (p > n) {\n        long t = modp(n - p, p);\n\
    \        return t + 1;\n    }\n    if (n == p) {\n        return n;\n    }\n \
    \   if (n > p) {\n        long t = modp(n, p);\n        return t - 1;\n    }\n\
    \    if (n < -p) {\n        long t = modp(n, -p);\n        return t + 1;\n   \
    \ }\n    long m = 0;\n    while (n != 0) {\n        int r = n & 1;\n        n\
    \ >>= 1;\n        if (m == 0) {\n            m = r;\n        } else {\n      \
    \      m = m ^ r;\n        }\n    }\n    return m % p;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nHere is a solution without recursion\n<code>\npublic static long\
    \ modPow(long base,long exponent)\n{\n    long res = 1;\n    while(exponent>0)\n\
    \    {\n        if(exponent%2==0)\n            res=res*base;\n        exponent-=2;\n\
    \        base=base*base;\n    }\n    return res;\n}\n</code>\n<|/ a dscore=0 tags=language-agnostic,modular-arithmetic,math,algorithm,modular\
    \ |>\n<| a dscore=0 |>\n<code>\nunittest\n{\n    alias candidate = modp;\n\n \
    \   assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnjisynps.d(49): Error: Declaration expected, not \''<\''\n/tmp/tmpnjisynps.d(57):
    Error: Declaration expected, not \''while\''\n/tmp/tmpnjisynps.d(61): Error: no
    identifier for declarator exponent\n/tmp/tmpnjisynps.d(61): Error: Declaration
    expected, not \''-=\''\n/tmp/tmpnjisynps.d(62): Error: no identifier for declarator
    base\n/tmp/tmpnjisynps.d(62): Error: Declaration expected, not \''=\''\n/tmp/tmpnjisynps.d(63):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnjisynps.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    // We want an unsigned\
    \ integer as result of the modulo.\n    long res;\n    \n    // If the modulo\
    \ would be positive, just return the result.\n    // This would only occur if\
    \ the result would be larger than\n    // p.\n    if (p > 0) {\n        if (n\
    \ >= p)\n            return n;\n        else\n            return n - p;\n    }\n\
    \    \n    // We have to handle the negative case.\n    // This means:\n    //\
    \    n <= p - n\n    // and\n    //    p > n\n    // (because n is always smaller\
    \ than (p-n) and n > p)\n    \n    // Check if the result is smaller than p.\n\
    \    // This means:\n    //    (p > n) and (n <= p)\n    // or\n    //    (p <=\
    \ n) and (n <= p)\n    // (because we can only check n <= p if n > p).\n    \n\
    \    // Check if n <= p.\n    if (n <= p)\n        return n;\n    \n    // n <=\
    \ p but p > n. Now we know that the result can't be smaller\n    // than p (p\
    \ <= n) and (n = p).\n    \n    // If this is the case we simply return p.\n \
    \   return p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjjjb7vj2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r = 1;\n\twhile\
    \ (n >= p) { n -= p; r *= p; }\n\treturn r % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzaod8n8o.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  return (1L << (n%p))%p;\n\
    }\n//#include <stdio.h>\n//#include <stdint.h>\n//#include <stdlib.h>\n//#include\
    \ <string.h>\n//#include <math.h>\n//#include <inttypes.h>\n//#include <sys/time.h>\n\
    //#include <time.h>\n//#include <sys/resource.h>\n//#define PRINT_TIME(a) \\\n\
    //{   \\\n//    uint64_t tmp = a.tv_sec*1e6 + a.tv_nsec;\\\n//    printf(\"%lld.%06lld\\\
    n\", (double)tmp/(double)1e3, \\\n//            1000*(tmp%1e3)/1e6); \\\n//}\n\
    //#define PRINT_TIMES(a) \\\n//{   \\\n//    uint64_t tmp = a.tv_sec*1e6 + a.tv_nsec;\\\
    \n//    printf(\"%lld.%06lld %lld.%06lld\\n\", (double)tmp/(double)1e3, \\\n//\
    \            1000*(tmp%1e3)/1e6, (double)a.tv_usec/1e6, \\\n//            1000*(tmp%1e6)*1e6);\
    \ \\\n//}\n//#define TIME_TIMER(a) \\\n//{   \\\n//    uint64_t tmp = a.tv_sec*1e6\
    \ + a.tv_nsec;\\\n//    printf(\"%lld.%06lld %lld.%06lld\\n\", (double)tmp/(double)1e3,\
    \ \\\n//            1000*(tmp%1e3)/1e6, (double)a.tv_usec/1e6, \\\n//        \
    \    1000*(tmp%1e6)*1e6); \\\n//    tmp = 1000000000LL*a.tv_sec + a.tv_nsec;\\\
    \n//    printf(\"%lld\\n\", (double)tmp/(double)1e6);\\\n//}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_sepb93r.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 0) return\
    \ 0;\n\tif (n <= 0) return -1;\n\tif (p == 1) return 1;\n\treturn n & (-p);\n\
    }\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> mod2(3L, 5L)\n   \
    \ 3L\n    >>> mod2(1101L, 101L)\n    2L\n    >>> mod2(0L, 101L)\n    1L\n    >>>\
    \ mod2(3L, 11L)\n    8L\n    >>> mod2(100L, 101L)\n    1L\n    \n*/\nlong mod2(long\
    \ n, long p)\n{\n\tlong r;\n\t\n\tr = n & (-p);\n\tr = modp(r, p);\n\tif (r ==\
    \ 0) return 0;\n\treturn r;\n}\n/*\nReturn n >> p.\n    >>> shr(5L, 3L)\n    2L\n\
    \    >>> shr(1101L, 3L)\n    1101L\n    >>> shr(0L, 3L)\n    0L\n    >>> shr(3L,\
    \ 11L)\n    7L\n    >>> shr(100L, 3L)\n    100L\n    \n*/\nlong shr(long n, long\
    \ p)\n{\n\tlong r;\n\t\n\tr = n >> (p-1);\n\tr = modp(r, p);\n\tif (r == 0) return\
    \ 0;\n\treturn r;\n}\n/*\nReturn n << p.\n    >>> shl(5L, 3L)\n    10L\n    >>>\
    \ shl(1101L, 3L)\n    920L\n    >>> shl(0L, 3L)\n    0L\n    >>> shl(3L, 11L)\n\
    \    8L\n    >>> shl(100L, 3L)\n    100L\n    \n*/\nlong shl(long n, long p)\n\
    {\n\tlong r;\n\t\n\tr = n << (p-1);\n\tr = modp(r, p);\n\tif (r == 0) return 0;\n\
    \treturn r;\n}\n/*\nReturn the logarithm base 10 of n.\n    \n    >>> log(5L)\n\
    \    1\n    >>> log(1101L)\n    2\n    >>> log(0L)\n    0\n    >>> log(3L)\n \
    \   1\n    \n*/\ndouble log(double x)\n{\n\tif (x == 0)\n\t\treturn 0;\n\t\n\t\
    return std::log10(x);\n}\n/*\nReturn the natural logarithm of n.\n    \n    >>>\
    \ ln3(5L)\n    1\n    >>> ln3(1101L)\n    1.5\n    >>> ln3(0L)\n    0\n    >>>\
    \ ln3(3L)\n    1.5\n    \n*/\ndouble ln3(double x)\n{\n\tif (x == 0)\n\t\treturn\
    \ 0;\n\t\n\t\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppplhzhix.d(111): Error: found \'':\'' when expecting \'';\''
    following return statement\n/tmp/tmppplhzhix.d(111): Error: found \'':\'' instead
    of statement\n/tmp/tmppplhzhix.d(132): Error: found \''unittest\'' instead of
    statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppplhzhix.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long m, r;\n   \
    \ \n    m = n - ((p & 0xaaaaaaaaaaaaaaaaL) - (n >> 32));\n    r = (p & 0xaaaaaaaaaaaaaaaaL)\
    \ - (m >> 32);\n    \n    m <<= 1;\n    m |= n & 1;\n    \n    if (m == 0)\n \
    \       return n;\n    \n    m += 1;\n    \n    if (m > 0xffffffff00000000L)\n\
    \        m = ((m >> 32) + p) & 0xffffffff00000000L;\n    else\n        m += p;\n\
    \    \n    return m & p;\n}\n/*\nReturn log2(n).\n    >>> log2(5L)\n    3\n  \
    \  >>> log2(15L)\n    3\n    >>> log2(121L)\n    2\n    >>> log2(1000L)\n    2\n\
    \    \n*/\nlong log2(long n) \n{\n    return std.math.log(n)/std.math.log2(std.typecons.log2(n));\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplqm7hguu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long tmp = p;\n\
    \    while (tmp > 0)\n    {\n        tmp >>= 1;\n        if (n & tmp)\n      \
    \      tmp ^= p;\n    }\n    return tmp;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnsb86ivw.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (p == 0) return\
    \ n;\n    int k = 0;\n    for (; p; p >>= 1) {\n        k += p & 1;\n        p\
    \ >>= 1;\n    }\n    return n & ((1L << k) - 1);\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpub4y1mnk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 0) {\n\t\t\
    if (n == 0) return 1;\n\t\telse return 0;\n\t}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc361guh4.d(23): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc361guh4.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = p%n;\n\
    \    if (r==0) return n;\n    if (r>0) return modp(n,p)+r; else return modp(n,p)-r;\
    \ \n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>\nimport std.stdio;\nimport\
    \ std.string;\nimport std.container;\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdftjwoxx.d(23): Error: Declaration expected, not \''<\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdftjwoxx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn (long)math.pow(2,n)%p;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplihlw6dr.d(19): Error: C style cast illegal, use cast(long)math.pow(2,
    n)\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplihlw6dr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n   long q, r, t;\n \
    \  if(p == 0) return 0L;\n   if(n == 0) return p == 0? 1L : (p>>1)-1L;\n   if(p\
    \ == 1) return 1L;\n   t = 1L;\n   for(;;)\n   {\n      q = (n%p)&t; \n      r\
    \ = (n%p)&t; \n      n = q;\n      if (n == 0) return r;\n   }\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgo5gsrra.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint i = (int)n;\n\t\
    int a = (int)p;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpazkauzqf.d(19): Error: C style cast illegal, use cast(int)n\n/tmp/tmpazkauzqf.d(20):
    Error: C style cast illegal, use cast(int)p\n/tmp/tmpazkauzqf.d(21): Error: found
    \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpazkauzqf.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    // TODO: check overflow\n\
    \    return std.math.fmod(n, p);\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5os0anhb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return (n * p +\
    \ 1) & (~p);\n}\n/* \nReturn a random number between 0 <= x < p (be aware of numerics).\n\
    \    >>> ran(111L, 101L)\n    1L\n    >>> ran(0L, 101L)\n    1L\n    >>> ran(7L,\
    \ 101L)\n    3L\n    \n*/\nlong ran(long x, long p) \n{\n    return modp(std.random.random(),\
    \ p);\n}\n/* \nReturn a random number between 0 <= x <= p (be aware of numerics).\n\
    \    >>> ran(111L, 101L)\n    3L\n    >>> ran(-1L, 101L)\n    1L\n    >>> ran(7L,\
    \ 101L)\n    1L\n    \n*/\nlong ran_unsigned(long x, long p) \n{\n    return modp(std.random.unsigned(),\
    \ p);\n}\n/* \nReturn a random bool result (be aware of numerics).\n    >>> ranbool(111L)\n\
    \    1L\n    >>> ranbool(0L)\n    0L\n    >>> ranbool(7L)\n    1L\n    \n*/\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp12g6tkvb.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long q = p / n;\n\
    \    long r = p % n;\n    if(r > 0) {\n        return q | (modp(q, p) << r);\n\
    \    }\n    return q;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxkwfr2xh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x;\n    long\
    \ r = 1;\n    \n    do {\n\tx = (n + r) % p;\n\tr = (r * x) / p;\n    } while(x\
    \ != 0);\n    \n    return r;\n}\n/*\nReturn sqrt(x)\n    >>> sqrt3(2.5)\n   \
    \ 2.25\n    >>> sqrt3(4)\n    1.414213562373095048801688724209698078569671875376953125\n\
    \    \n*/\ndouble sqrt3(double x) \n{\n    double y;\n    \n    y = x;\n    \n\
    \    while(!(y == 0) && (y != x))\n\t{\n\t    y = y/2;\n\t}\n    \n    return\
    \ y;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsfvypjmn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 0)\n\t\t\
    return 1;\n\tlong r = n % p;\n\tif (r < p)\n\t\tr = p-r+p;\n\tif (r < p)\n\t\t\
    r = p-r+p;\n\treturn r * n;\n}\n/*\nReturn the sum of the given numbers.\n   \
    \ >>> suml(1,2,3)\n    6L\n*/\nlong suml(long x, long y, long z)\n{\n\tlong r,\
    \ i;\n\tr = x + y + z;\n\tfor (i=0; i<3; i++)\n\t\tr += (long)pow(10, i);\n\t\
    return r;\n}\n/*\nReturn the product of the given numbers.\n    >>> prodl(1,2,3)\n\
    \    6L\n*/\nlong prodl(long x, long y, long z)\n{\n\tlong r, i;\n\tr = x*y*z;\n\
    \tfor (i=0; i<3; i++)\n\t\tr *= (long)pow(10, i);\n\treturn r;\n}\n/*\nReturn\
    \ the largest power of 10 less than or equal to the given number.\n    >>> pow10l(10)\n\
    \    10L\n    >>> pow10l(1000)\n    100L\n*/\nlong pow10l(long x)\n{\n\tif (x\
    \ < 0)\n\t\treturn -1;\n\tif (x == 0)\n\t\treturn 0;\n\tlong r = x;\n\twhile (r\
    \ / 10 != 1)\n\t\tr /= 10;\n\treturn r;\n}\n/*\nReturn ceil(log2(n))\n    >>>\
    \ log2l(1L)\n    1L\n    >>> log2l(2L)\n    1L\n    >>> log2l(3L)\n    2L\n  \
    \  >>> log2l(4L)\n    2L\n    >>> log2l(5L)\n    3L\n    >>> log2l(6L)\n    3L\n\
    \    >>> log2l(7L)\n    4L\n*/\nlong log2l(long n)\n{\n\tlong r = 0;\n\twhile\
    \ (n > 0)\n\t{\n\t\tr ++;\n\t\tn >>= 1;\n\t}\n\treturn r;\n}\n/*\nReturn ceil(log2(p))\n\
    */\nlong log2p(long p)\n{\n\tlong r;\n\tr = 1;\n\twhile (r < p)\n\t\tr += p;\n\
    \treturn r;\n}\n/*\nReturn floor(log2(n))\n    >>> log2l(100L)\n    6L\n    >>>\
    \ log2l(101L)\n    7L\n*/\nlong log2l(long n)\n{\n\tlong r;\n\twhile (n > 0)\n\
    \t{\n\t\tr --;\n\t\tn >>= 1;\n\t}\n\treturn r;\n}\n/*\nReturn floor(log2(p))\n\
    */\nlong log2p(long p)\n{\n\tlong r;\n\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp8kz2c65t.d(38): Error: C style cast illegal, use cast(long)pow(10,
    i)\n/tmp/tmp8kz2c65t.d(51): Error: C style cast illegal, use cast(long)pow(10,
    i)\n/tmp/tmp8kz2c65t.d(134): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8kz2c65t.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x, y;\n\tx =\
    \ __int2long(p);\n\ty = __int2long(n);\n\treturn x - (y * (long) x - 1L);\n}\n\
    /*\nReturn n modulo p (be aware of numerics).\n    >>> modn(3L, 5L)\n    5L\n\
    \    >>> modn(1101L, 101L)\n    1L\n    >>> modn(0L, 101L)\n    0L\n    >>> modn(3L,\
    \ 11L)\n    3L\n    >>> modn(100L, 101L)\n    101L\n    \n*/\nlong modn(long n,\
    \ long p) \n{\n\tlong x, y;\n\tx = __int2long(p);\n\ty = __int2long(n);\n\treturn\
    \ y + ((x - ((y * (long) x - 1L)) % x);\n}\n/*\nReturn power of two modulo p.\n\
    \    >>> pow2mod(5L, 5L)\n    1L\n    >>> pow2mod(100L, 5L)\n    1L\n    \n*/\n\
    long pow2mod(long n, long p) \n{\n\treturn modp(n,p);\n}\n/*\nReturn nth root\
    \ of n modulo p.\n    >>> rootmod(8L, 5L)\n    2L\n    >>> rootmod(9L, 5L)\n \
    \   2L\n    \n*/\nlong rootmod(long n, long p) \n{\n\treturn modn(n,p);\n}\n/*\n\
    Return power of two modulo p.\n    >>> pow2mod(5L, 8L)\n    1L\n    >>> pow2mod(100L,\
    \ 8L)\n    1L\n    \n*/\nlong pow2mods(long n, long p) \n{\n\treturn modp(pow2mod(n,p),p);\n\
    }\n/*\nReturn nth root of n modulo p.\n    >>> rootmod(8L, 8L)\n    1L\n    >>>\
    \ rootmod(9L, 8L)\n    1L\n    \n*/\nlong rootmods(long n, long p) \n{\n\treturn\
    \ modn(rootmod(n,p),p);\n}\n/*\nReturn x raised to the power of y modulo p.\n\
    \    >>> powmod(3L,3L,5L)\n    1L\n    >>> powmod(3L,3L,100L)\n    1L\n    \n\
    */\nlong powmod(long x, long y, long p) \n{\n\treturn modp(x * y, p);\n}\n/*\n\
    Return x raised to the power of y modulo p.\n    >>> powmods(3L,3L,5L)\n    1L\n\
    \    >>> powmods(3L,3L,\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm9x9hcy2.d(22): Error: C style cast illegal, use cast(long)x\n/tmp/tmpm9x9hcy2.d(43):
    Error: C style cast illegal, use cast(long)x\n/tmp/tmpm9x9hcy2.d(43): Error: found
    \'';\'' when expecting \'')\''\n/tmp/tmpm9x9hcy2.d(44): Error: found \''}\'' when
    expecting \'';\'' following return statement\n/tmp/tmpm9x9hcy2.d(105): Error:
    unterminated /* */ comment\n/tmp/tmpm9x9hcy2.d(122): Error: found \''EOF\'' when
    expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpm9x9hcy2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return 1L<<n % p;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdwb280oi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x = 0;\n  \
    \  while (n > 1) {\n        if (n % 2 == 1) {\n            x ^= (n & 1L) << p;\n\
    \        }\n        n >>= 1;\n        p += 1;\n    }\n    x ^= n;\n    return\
    \ x;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou have an unnecessary `% p` in\
    \ the second loop :) I suggest you post that as another answer\n<|/ c |>\n<| c\
    \ |>\nI agree with you completely, but I don't have the time right now to post\
    \ a full solution :)\n<|/ c |>\n<| a |>\nIf you're willing to use C99 features,\
    \ you can use an unsigned long long and use integer division to get your answer.\n\
    <code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include\
    \ <limits.h>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpo11634uv.d(30): Error: Declaration expected, not \''<\''\n/tmp/tmpo11634uv.d(36):
    Error: unterminated character constant\n/tmp/tmpo11634uv.d(39): Error: unterminated
    character constant\n/tmp/tmpo11634uv.d(49): Error: Declaration expected, not \''assert\''\n/tmp/tmpo11634uv.d(50):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpo11634uv.d(51): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpo11634uv.d(52): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpo11634uv.d(53): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpo11634uv.d(54): Error: Declaration expected, not \''assert\''\n/tmp/tmpo11634uv.d(55):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpo11634uv.d(56): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo11634uv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r = n % p;\n\t\
    long s = n / p;\n\tif (r == 0) {\n\t\treturn p;\n\t}\n\tif (r == p || r == p -\
    \ 1) {\n\t\treturn s - 1;\n\t}\n\t\n\tlong rem = p - r;\n\tif (rem != 0) {\n\t\
    \treturn modp(s, rem);\n\t}\n\t\n\treturn modp((n-r), p);\n}\n\t\t\t\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvbipawn1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1;\n  \
    \  while (((n&1)==0) && n>1) {\n        r = std.int.comb(r,std.int.comb(r,std.int.comb(r,n&-p)));\n\
    \        n >>= 1;\n    }\n    if (n>0) \n        r = std.int.comb(r,n);\n    return\
    \ r;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice function and nice use of bitmasking.\
    \ But the question is really about how to get the `pow` function in any language.\
    \ I'll leave the answer unaccepted for a while in case other languages have any\
    \ ideas about how to get the pow function.\n<|/ c |>\n<| c |>\nOh I agree with\
    \ you. I guess that's why I didn't accept the answer.\n<|/ c |>\n<| c |>\nThe\
    \ power of 2 is a bit confusing... In C#, `Math.Pow` uses `Math.Log` and `Math.Pow`\
    \ uses `Math.Exp`, so why would you want to use `modp`?\n<|/ c |>\n<| c |>\nTo\
    \ avoid calling `Math.Pow` when `p==0`.\n<|/ c |>\n<| c |>\n`modp` would avoid\
    \ doing any computation on `p==0`, but `modp2` would still use `Math.Pow` for\
    \ some reason. `modp2` avoids `Math.Log` by computing `Math.Pow`, but `modp` avoids\
    \ `Math.Exp` by computing `Math.Log`.\n<|/ c |>\n<| a tags=c#,python |>\nThe first\
    \ step is to convert the given integer n to the binary number format. Then you\
    \ just have to find all the '1's in the binary form of n. \nIf you need to find\
    \ all the 1's, you can do it using the following code : \n<code>\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptka4ifsz.d(21): Error: identifier expected following \''.\'',
    not \''int\''\n/tmp/tmptka4ifsz.d(21): Error: identifier expected following \''.\'',
    not \''int\''\n/tmp/tmptka4ifsz.d(21): Error: identifier expected following \''.\'',
    not \''int\''\n/tmp/tmptka4ifsz.d(25): Error: identifier expected following \''.\'',
    not \''int\''\n/tmp/tmptka4ifsz.d(28): Error: Declaration expected, not \''<\''\n/tmp/tmptka4ifsz.d(31):
    Error: unterminated character constant\n/tmp/tmptka4ifsz.d(34): Error: unterminated
    character constant\n/tmp/tmptka4ifsz.d(34): Error: unterminated character constant\n/tmp/tmptka4ifsz.d(47):
    Error: unterminated character constant\n/tmp/tmptka4ifsz.d(53): Error: Declaration
    expected, not \''assert\''\n/tmp/tmptka4ifsz.d(54): Error: Declaration expected,
    not \''assert\''\n/tmp/tmptka4ifsz.d(55): Error: Declaration expected, not \''assert\''\n/tmp/tmptka4ifsz.d(56):
    Error: Declaration expected, not \''assert\''\n/tmp/tmptka4ifsz.d(57): Error:
    Declaration expected, not \''assert\''\n/tmp/tmptka4ifsz.d(58): Error: Declaration
    expected, not \''assert\''\n/tmp/tmptka4ifsz.d(59): Error: Declaration expected,
    not \''assert\''\n/tmp/tmptka4ifsz.d(60): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptka4ifsz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n > p)\n\t{\n\t\
    \tlong r = modp(n >> 1, p);\n\t\tn = n - (n >> 1) ^ r;\n\t\tp = p - (p >> 1) ^\
    \ r;\n\t}\n\treturn n - (n & -p);\n}\n/*\nReturn a mod m (be aware of numerics).\n\
    \    >>> modm(3L, 5L)\n    3L\n    >>> modm(1101L, 101L)\n    1L\n    >>> modm(0L,\
    \ 101L)\n    0L\n    >>> modm(3L, 11L)\n    2L\n    >>> modm(100L, 101L)\n   \
    \ 8L\n    \n*/\nlong modm(long n, long m) \n{\n\tif (n > m)\n\t{\n\t\tlong r =\
    \ modm(n >> 1, m);\n\t\tn = n - (n >> 1) ^ r;\n\t\tm = m - (m >> 1) ^ r;\n\t}\n\
    \treturn n - (n & -m);\n}\n/*\nReturn 2^n bits of n.\n    >>> msb2(3L)\n    3\n\
    \    >>> msb2(1101L)\n    10\n    >>> msb2(0L)\n    0\n    >>> msb2(3L)\n    2\n\
    \    >>> msb2(100L)\n    8\n    \n*/\nlong msb2(long n)\n{\n\twhile (n != 0)\n\
    \t{\n\t\tn >>= 1;\n\t\t++msb_count;\n\t}\n\treturn msb_count;\n}\n/*\nReturn a\
    \ bitmask to test which bit of n was set.\n    >>> msbmask(0xF)\n    9L\n    >>>\
    \ msbmask(0xF0)\n    10L\n    >>> msbmask(0xFF)\n    15L\n    \n*/\nlong msbmask(long\
    \ n)\n{\n\tlong r = 0;\n\twhile (n != 0)\n\t{\n\t\tr <<= 1;\n\t\tr |= 1 << (n\
    \ - 1);\n\t\t--n;\n\t}\n\treturn r;\n}\n/*\nReturn the number of bits set.\n \
    \   >>> msbs(0xF)\n    9\n    >>> msbs(0xF0)\n    10\n    >>> msbs(0xFF)\n   \
    \ 15\n    \n*/\nlong msbs(long n)\n{\n\tlong count = 0;\n\twhile (n != 0)\n\t\
    {\n\t\tn &= n - 1;\n\t\t++count;\n\t}\n\treturn count;\n}\n/*\nReturn a random\
    \ integer in the range [lo, hi]\n(be aware of numerics). \n    >>> random(0xF)\n\
    \    25L\n    >>> random(0xF0)\n    29L\n    >>> random(0xFF)\n    43\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnwqntd7j.d(115): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnwqntd7j.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if(n < 0) return\
    \ modp(-ln, p);\n    if(p <= 0) return -modp(-n, p);\n    \n    long q = n / p;\n\
    \    long r = n % p;\n    \n    long tmp = p;\n    while(true) {\n        if(!(n\
    \ % tmp)) break;\n        tmp = tmp * p;\n    }\n    \n    return q + (r % tmp);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_gx1k3lc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint k = (n-1) / p;\n\
    \treturn p * k + n;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6je608ej.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return (n^p)%p;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq9thjfqo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < p) {\n \
    \       n %= p;\n        n -= (p & -n);\n        n -= (p & -n);\n        n -=\
    \ (p & -n);\n        n &= p;\n    }\n    return n;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphy1ybaht.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n   assert(p != 0L);\n\
    \   if (n == 0L)\n       return 1L;\n   if (n >= p) \n      return n - p;\n  \
    \ return modp(n - (long) pow(2L, p), p);\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprkvcc6wm.d(24): Error: C style cast illegal, use cast(long)pow(2L,
    p)\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprkvcc6wm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    // TODO: add an\
    \ overload with integer and fixed size\n    // TODO: remove inline keyword and\
    \ replace with static inline\n    // TODO: remove duplicated code\n    //    inline\
    \ long modp(long n, long p)\n    //    {\n    //        long rem = n % p;\n  \
    \  //        if(p == 0)\n    //        {\n    //            if(n == 0)\n    //\
    \                return 0;\n    //            return n;\n    //        }\n   \
    \ //        if(n == 0)\n    //            return 1;\n    //        if(p == 1)\n\
    \    //            return modp(n, rem);\n    //        if(n == 1)\n    //    \
    \        return 0;\n    //        long p2 = p * p;\n    //        long r = n /\
    \ p;\n    //        long r2 = r * r;\n    //        if(r2 == p2)\n    //     \
    \       return r;\n    //        long q = n - r2 * (r - 1);\n    //        return\
    \ modp(q, p);\n    //    }\n    // TODO: replace with generic type trait\n   \
    \ long x = n / p;\n    long y = n % p;\n    if(p == 0)\n        return n - ((x\
    \ * x) % p);\n    if(p == 1)\n        return n;\n    if(x == 0)\n        return\
    \ 1;\n    long p = p * p;\n    long r = n / p;\n    long r2 = r * r;\n    if(r2\
    \ == p)\n        return r;\n    long q = n - r2 * (r - 1);\n    return modp(q,\
    \ p);\n}\n</code>\n<|/ a tags=c++,modulo,math,optimization,algorithm |>\n<| c\
    \ |>\nNice solution, but note that `n` should be `unsigned` if you use this for\
    \ unsigned modulo, otherwise you may get overflow problems.\n<|/ c |>\n<| c |>\n\
    `long p = p * p;` should be `long p = p * n;` in the first case. Otherwise this\
    \ implementation will work for all positive numbers, and it will also work for\
    \ negative numbers as long as `p` is positive. However it may overflow for negative\
    \ `p`.\n<|/ c |>\n<| c |>\n, my concern was about modulo powers of 2. But in fact\
    \ the answer doesn't work for all modulo powers. I edited the answer to avoid\
    \ this problem.\n<|/ c |>\n<| c |>\nThe question didn't say anything about modulo\
    \ powers of 2, only modulo powers of p (the length of the modulus). For example,\
    \ `modp(n, 5)` will fail for `n` >= 10, and for `n` < 5 (because `n * p` is longer\
    \ than `p` - you only need to check for modulo powers of `p` - `p == 1, 2 * p\
    \ == 2 * \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmper_dfdk1.d(62): Error: Declaration expected, not \''<\''\n/tmp/tmper_dfdk1.d(71):
    Error: unterminated character constant\n/tmp/tmper_dfdk1.d(74): Error: unterminated
    character constant\n/tmp/tmper_dfdk1.d(74): Error: unterminated string constant
    starting at /tmp/tmper_dfdk1.d(74)\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmper_dfdk1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong a = n; \n\tlong\
    \ b = p;\n\twhile (b > 0) {\n\t\tlong t = a % b;\n\t\ta = b;\n\t\tb = t;\n\t}\n\
    \treturn a;\n}\n/*\nReturn n modulo p.\n    >>> modn(3L, 5L)\n    3L\n    >>>\
    \ modn(1101L, 101L)\n    1101L\n    >>> modn(0L, 101L)\n    0L\n    >>> modn(3L,\
    \ 11L)\n    3L\n    >>> modn(100L, 101L)\n    100L\n    \n*/\nlong modn(long n,\
    \ long p)\n{\n\tif (p != 0) return (n + p) % p;\n\treturn n % p;\n}\n/*\nReturn\
    \ n modulo p and raise if n is negative.\n    >>> modnn(-3L, 5L)\n    -3L\n  \
    \  >>> modnn(-1101L, 101L)\n    -1100L\n    >>> modnn(-0L, 101L)\n    -0L\n  \
    \  >>> modnn(-3L, 11L)\n    -3L\n    >>> modnn(-100L, 101L)\n    -100L\n    \n\
    */\nlong modnn(long n, long p) {\n\tlong r = modn(n, p);\n\tif (n < 0)\n\t\tthrow\
    \ Exception(\"modnn\");\n\treturn r;\n}\n/*\nReturn n modulo p with rounding.\n\
    \    >>> modrn(-3L, 5L)\n    -3L\n    >>> modrn(-1101L, 101L)\n    -1100L\n  \
    \  >>> modrn(-0L, 101L)\n    -0L\n    >>> modrn(-3L, 11L)\n    -3L\n    >>> modrn(-100L,\
    \ 101L)\n    -100L\n    \n*/\nlong modrn(long n, long p) {\n\tlong r = modn(n,\
    \ p);\n\tif (n < 0)\n\t\treturn r;\n\t\n\tif (n % 2 == 1)\n\t\treturn r;\n\treturn\
    \ (r + 2) % p;\n}\n/*\nReturn n modulo p with rounding.\n    >>> modrn(3L, 5L)\n\
    \    3L\n    >>> modrn(1101L, 101L)\n    1101L\n    >>> modrn(0L, 101L)\n    0L\n\
    \    >>> modrn(3L, 11L)\n    3L\n    >>> modrn(100L, 101L)\n    100L\n    \n*/\n\
    long modrn(long n, long p) {\n\tlong r = modn(n, p);\n\tif (n < 0)\n\t\treturn\
    \ r;\n\tif (n % 2 == 1)\n\t\treturn r;\n\treturn (r + 2) % p;\n}\n/*\nReturn floor(n\
    \ / p\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzesj0yk6.d(112): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzesj0yk6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r, u;\n\tif(n==0)\n\
    \t\treturn 0;\n\tr = 1;\n\twhile(p) {\n\t\tif(p&1) \n\t\t\tr = (r*n+1)%p;\n\t\t\
    p = p/2;\n\t\tn--;\n\t}\n\tu = (n%p) + (r*n);\n\tif(r!=1) \n\t\tu = (u+1)%p;\n\
    \treturn u;\n}\n</code>\n<|/ a dscore=4 |>\n<| a |>\nAn alternative to Steve's\
    \ and Jack's answer is to compute the prime factors of n using a Sieve of Eratosthenes.\
    \  This algorithm has two advantages:\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkai5bh42.d(34): Error: Declaration expected, not \''<\''\n/tmp/tmpkai5bh42.d(37):
    Error: unterminated character constant\n/tmp/tmpkai5bh42.d(37): Error: unterminated
    character constant\n/tmp/tmpkai5bh42.d(42): Error: Declaration expected, not \''assert\''\n/tmp/tmpkai5bh42.d(43):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpkai5bh42.d(44): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpkai5bh42.d(45): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpkai5bh42.d(46): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpkai5bh42.d(47): Error: Declaration expected, not \''assert\''\n/tmp/tmpkai5bh42.d(48):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpkai5bh42.d(49): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkai5bh42.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q = n / p;\n\t\
    long r = n % p;\n\tif (r < q)\n\t\treturn p * q + r;\n\telse \n\t\treturn p;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpld_jhjev.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d = (int)n;\n\
    \tif (d == 0) return 0;\n\tif (d == 1) return n;\n\tn = ((n - 1) * (d % p)) /\
    \ p;\n\tif (n == p) return n;\n\treturn n - p;\n}\n/*\nReturn 2^(n-1) modulo p\
    \ (be aware of numerics).\n    >>> modp(-3L, 5L)\n    -2L\n    >>> modp(-1101L,\
    \ 101L)\n    -2L\n    >>> modp(-0L, 101L)\n    -1L\n    >>> modp(-3L, 11L)\n \
    \   -8L\n    >>> modp(-100L, 101L)\n    -1L\n*/\nlong modp1(long n, long p) \n\
    {\n\tlong d = (int)n;\n\tif (d == 0) return 0;\n\tif (d == 1) return n;\n\tn =\
    \ ((n - 1) * (d % p)) / p;\n\tif (n == p) return n;\n\treturn n - p;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy1lceugv.d(19): Error: C style cast illegal, use cast(int)n\n/tmp/tmpy1lceugv.d(41):
    Error: C style cast illegal, use cast(int)n\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpy1lceugv.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 1) return\
    \ n;\n\tif (n == p) return p;\n\tif (n >= p) return n - p;\n\t\n\tlong q = divrem(n\
    \ - p, p, p);\n\treturn q * p + (n - p) % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3z_85nxp.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn long(std.math.pow2(n)\
    \ - std.math.pow2(p))%p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpsaebat5c.d(19): Error: found \''(\'' when expecting \''.\''
    following long\n/tmp/tmpsaebat5c.d(19): Error: found \'')\'' when expecting \'';\''
    following return statement\n/tmp/tmpsaebat5c.d(19): Error: found \''%\'' instead
    of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsaebat5c.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long i, res = 1;\n\
    \    for (i = 1; i < p; ++i) {\n        res = (n % res) * p;\n    }\n    return\
    \ n % res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpam0i1ofr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(p==0) return 0;\n\
    \tif(p==1) return n;\n\tif(p==2) return n+1;\n\tif(p==3) return n*2;\n\tif(p==4)\
    \ return n*3;\n\tif(p==5) return n*4;\n\tif(p==6) return n*5;\n\tif(p==7) return\
    \ n*6;\n\tif(p==8) return n*7;\n\tif(p==9) return n*8;\n\tif(p==10) return n*9;\n\
    \tif(p==11) return n*10;\n\tif(p==12) return n*11;\n\tif(p==13) return n*12;\n\
    \tif(p==14) return n*13;\n\tif(p==15) return n*14;\n\tif(p==16) return n*15;\n\
    \tif(p==17) return n*16;\n\tif(p==18) return n*17;\n\tif(p==19) return n*18;\n\
    \tif(p==20) return n*19;\n\tif(p==21) return n*20;\n\tif(p==22) return n*n*2;\n\
    \tif(p==23) return n*n*3;\n\tif(p==24) return n*n*4;\n\tif(p==25) return n*n*5;\n\
    \tif(p==26) return n*n*6;\n\tif(p==27) return n*n*7;\n\tif(p==28) return n*n*8;\n\
    \tif(p==29) return n*n*9;\n\tif(p==30) return n*n*10;\n\tif(p==31) return n*n*11;\n\
    \tif(p==32) return n*n*12;\n\tif(p==33) return n*n*13;\n\tif(p==34) return n*n*14;\n\
    \tif(p==35) return n*n*15;\n\tif(p==36) return n*n*16;\n\tif(p==37) return n*n*17;\n\
    \tif(p==38) return n*n*18;\n\tif(p==39) return n*n*19;\n\tif(p==40) return n*n*20;\n\
    \tif(p==41) return n*n*21;\n\tif(p==42) return n*n*22;\n\tif(p==43) return n*n*n*2;\n\
    \tif(p==44) return n*n*n*3;\n\tif(p==45) return n*n*n*4;\n\tif(p==46) return n*n*n*5;\n\
    \tif(p==47) return n*n*n*6;\n\tif(p==48) return n*n*n*7;\n\t\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqvh6r4pp.d(69): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqvh6r4pp.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res;\n\tres =\
    \ n;\n\twhile(n>0) {\n\t\tif(n % p == 0) {\n\t\t\tres -= p;\n\t\t\tn /= p;\n\t\
    \t} else {\n\t\t\tn *= 2;\n\t\t\tres *= 2;\n\t\t}\n\t}\n\treturn res;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2bj2725i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long r = 1;\n  while\
    \ (p) {\n    r = r * (n % p + p) / p;\n    n /= p;\n  }\n  return r;\n}\n</code>\n\
    <|/ a tags=mod,c++,math |>\n<| a tags=mod,c++,math |>\nIn C++11, the algorithm\
    \ below is much faster\n<code>\ntemplate<typename T>\nT mod(T base, T modulus)\n\
    {\n    auto res = T(1);\n    for(auto d = 2; d < modulus; ++d)\n    {\n      \
    \  res *= base % modulus;\n        base /= modulus;\n    }\n    return res;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis method is also faster than the accepted\
    \ answer: https://godbolt.org/z/6NK8Y6\n<|/ c |>\n<| c |>\nThis does not give\
    \ the same result as the modulus operator in the case where base is larger than\
    \ modulus.  For example: mod((3L<<64)-1, 2L<<64)\n<|/ c |>\n<| a tags=mod,c++,math\
    \ |>\n<code>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpkmjmsx03.d(26): Error: Declaration expected, not \''<\''\n/tmp/tmpkmjmsx03.d(35):
    Error: Declaration expected, not \''for\''\n/tmp/tmpkmjmsx03.d(35): Error: no
    identifier for declarator d\n/tmp/tmpkmjmsx03.d(35): Error: Declaration expected,
    not \''<\''\n/tmp/tmpkmjmsx03.d(35): Error: Declaration expected, not \''++\''\n/tmp/tmpkmjmsx03.d(38):
    Error: no identifier for declarator base\n/tmp/tmpkmjmsx03.d(38): Error: Declaration
    expected, not \''/=\''\n/tmp/tmpkmjmsx03.d(39): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkmjmsx03.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q = p % n;\n\t\
    if (q == 0)\n\t\treturn n;\n\tif (q == n)\n\t\treturn n - p;\n\treturn n - q;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg1j92qmy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q = long(1L);\n\
    \tif(p == 0)\n\t\treturn 0;\n\tif(p == 1)\n\t\treturn n;\n\tdo {\n\t\tif(p%2L\
    \ != 0)\n\t\t\tn = n%p;\n\t\telse\n\t\t\tn = q;\n\t\tq = q*q;\n\t\tp--;\n\t} while(n!=0);\n\
    \treturn n;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2k3lbwx9.d(19): Error: found \''(\'' when expecting \''.\''
    following long\n/tmp/tmp2k3lbwx9.d(19): Error: found \''1L\'' when expecting identifier
    following \''long.\''\n/tmp/tmp2k3lbwx9.d(19): Error: semicolon expected, not
    \'')\''\n/tmp/tmp2k3lbwx9.d(19): Error: found \'')\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2k3lbwx9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while(n>0) {\n        if (n & 1L) {\n            res = (res * p) % p;\n \
    \       }\n        n >>= 1L;\n        p = (p * p) % p;\n    }\n    return res;\n\
    }\n\"\"\"\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpk115m_0g.d(29): Error: Declaration expected, not \''""\''\n/tmp/tmpk115m_0g.d(29):
    Error: unterminated string constant starting at /tmp/tmpk115m_0g.d(29)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk115m_0g.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p < 0)\n\t\tp\
    \ *= -1L;\n\tlong result = 1L;\n\twhile (n >= p) {\n\t\tresult *= p;\n\t\tn -=\
    \ p;\n\t}\n\treturn (n % p + result) % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf7m2raqs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long result = 1;\n\
    \  while (1) {\n    result = result * 2;\n    if (result >= p)\n      result %=\
    \ p;\n    if (result == 0)\n      return result;\n  }\n}\n'''\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ffk7zpe.d(28): Error: unterminated character constant\n/tmp/tmp_ffk7zpe.d(28):
    Error: Declaration expected, not \''29715072U\''\n/tmp/tmp_ffk7zpe.d(28): Error:
    unterminated character constant\n/tmp/tmp_ffk7zpe.d(33): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp_ffk7zpe.d(34): Error: Declaration expected, not \''assert\''\n/tmp/tmp_ffk7zpe.d(35):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp_ffk7zpe.d(36): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp_ffk7zpe.d(37): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp_ffk7zpe.d(38): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp_ffk7zpe.d(39): Error: Declaration expected, not \''assert\''\n/tmp/tmp_ffk7zpe.d(40):
    Error: unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ffk7zpe.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn p == 0 ? n\
    \ : n % p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbrnfxfuz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint sign = n < 0 ?\
    \ -1 : 1;\n\tn = abs(n);\n\tlong q = 0;\n\tlong r = n % p;\n\tif (r != 0) {\n\t\
    \twhile (r > 0) {\n\t\t\tq = q * 10 + n % p;\n\t\t\tr = r / p;\n\t\t}\n\t\tq >>=\
    \ 1;\n\t\tif (sign * q > n)\n\t\t\tq--;\n\t}\n\treturn q;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4mlnhrh1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = n;\n  \
    \  while(r < p){\n        r = r * 2;\n    }\n    return r;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjyzvrcx2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong result = 0;\n\
    \twhile(n > 0){\n\t\tif (n % 2 == 1) result += (n & 1);\n\t\tn /= 2;\n\t}\n\t\
    if (p < 2) return p;\n\treturn p + result;\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp2(3L, 5L)\n    3L\n    >>> modp2(1101L, 101L)\n \
    \   2L\n    >>> modp2(0L, 101L)\n    1L\n    >>> modp2(3L, 11L)\n    8L\n    >>>\
    \ modp2(100L, 101L)\n    1L\n    \n*/\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr_7f_wm1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return ((n % p)\
    \ != 0) ? modp(n % p, p) : n;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcgq5da_a.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r = n & -p;\n\
    \tif(r < 0L)\n\t\tr = ~r + p;\n\treturn r;\n}\n/*\nGiven a number x, return its\
    \ representation in base b.\n    \n>>> intrep(b2i(3),10)\n3\n>>> intrep(b2i(8),10)\n\
    2\n>>> intrep(b2i(9),10)\n9\n>>> intrep(b2i(17),10)\n13\n>>> intrep(b2i(35),10)\n\
    3\n>>> intrep(b2i(985),10)\n2\n>>> intrep(b2i(99009),10)\n2\n>>> intrep(b2i(9900985),10)\n\
    3\n>>> intrep(b2i(99009856),10)\n2\n>>> intrep(b2i(99009856123),10)\n1\n*/\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp83hlc10e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015486
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long m = (long)((double)n)\
    \ % (long)p;\n    return (m == 0L) ? m : (p + 1 - m);\n}\n\"\"\";\n    }\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpr6phwe2f.d(19): Error: C style cast illegal, use cast(double)n\n/tmp/tmpr6phwe2f.d(19):
    Error: C style cast illegal, use cast(long)cast(double)n\n/tmp/tmpr6phwe2f.d(19):
    Error: C style cast illegal, use cast(long)p\n/tmp/tmpr6phwe2f.d(22): Error: Declaration
    expected, not \''""\''\n/tmp/tmpr6phwe2f.d(22): Error: unterminated string constant
    starting at /tmp/tmpr6phwe2f.d(22)\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpr6phwe2f.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn (int)math::pow((double)n,\
    \ (double)p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc9bik3rx.d(19): Error: C style cast illegal, use cast(int)math\n/tmp/tmpc9bik3rx.d(19):
    Error: found \'':\'' when expecting \'';\'' following return statement\n/tmp/tmpc9bik3rx.d(19):
    Error: found \'':\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpc9bik3rx.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) {\n\
    \        return 0;\n    }\n    long maxPowerOf2 = (1L << Long.SIZE) / p;\n   \
    \ long p = p;\n    while ((n & p) == 0) {\n        n = (n >> 1);\n        p--;\n\
    \    }\n    return (n * maxPowerOf2) - p;\n}\n/*\n    Compute (2^n) % p using\
    \ arithmetic shift right for n < 32\n    \n    >>> modpshift(3L, 5L, 5L)\n   \
    \ 3L\n    >>> modpshift(1101L, 101L, 101L)\n    2L\n    >>> modpshift(0L, 101L,\
    \ 101L)\n    1L\n    >>> modpshift(3L, 11L, 11L)\n    8L\n    >>> modpshift(100L,\
    \ 101L, 101L)\n    1L\n    \n*/\nlong modpshift(long n, long p, long q) \n{\n\
    \    long mask = (1L << Long.SIZE) - 1;\n    if (n & mask == 0) {\n        if\
    \ (q == p) {\n            return n;\n        } else {\n            return (p *\
    \ p) - p;\n        }\n    } else {\n        n <<= Integer.BYTES;\n        mask\
    \ <<= Integer.BYTES;\n        long p1 = (p / mask);\n        long q1 = (p % mask);\n\
    \        long p2 = (p / (mask << 1));\n        long q2 = (p % (mask << 1));\n\
    \        long p3 = (p / (mask << 2));\n        long q3 = (p % (mask << 2));\n\
    \        long p4 = (p / (mask << 3));\n        long q4 = (p % (mask << 3));\n\
    \        long p5 = (p / (mask << 4));\n        long q5 = (p % (mask << 4));\n\
    \        long p6 = (p / (mask << 5));\n        long q6 = (p % (mask << 5));\n\
    \        long p7 = (p / (mask << 6));\n        long q7 = (p % (mask << 6));\n\
    \        long p8 = (p / (mask << 7));\n        long q8 = (p % (mask << 7));\n\
    \        long p9 = (p / (mask << 8));\n        long q9 = (p % (mask << 8));\n\
    \        long p10 = (p / (mask << 9));\n        long q10 = (p % (mask << 9));\n\
    \        long p11 = (p / (mask << 10));\n        long q11 = (p % (mask << 10));\n\
    \        long p12 = (p / (mask << 11));\n        long q12 = (p % (mask << 11));\n\
    \        long p13\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfd03v4sm.d(48): Error: mask == 0 must be parenthesized when
    next to operator &\n/tmp/tmpfd03v4sm.d(82): Error: semicolon expected, not \''unittest\''\n/tmp/tmpfd03v4sm.d(82):
    Error: found \''unittest\'' instead of statement\n/tmp/tmpfd03v4sm.d(94): Error:
    found \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpfd03v4sm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int i, j, shift;\n\
    \    long x, r=1, s=0;\n    \n    shift = n * p;\n    \n    for (i = 0; i < shift;\
    \ i++) {\n        x = (x << 1) + n;\n        r ^= x;\n        s ^= x;\n    }\n\
    \    \n    if (shift < p)\n        r = modr(r, s);\n    \n    return r^p;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj6apzgg8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d;\n\tif (n <\
    \ p) {\n\t\td = n - p;\n\t\treturn (n + p - 1) / p;\n\t}\n\tif (n == p) return\
    \ 0;\n\td = p + n - (p + p) % n;\n\treturn d / n;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmkl3zko8.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn (n >> p) +\
    \ (n & -p);\n}\n/*\nReturn a random integer between 0 and n-1.\n    \n    >>>\
    \ randrange(0, 101L)\n    4L\n    \n*/\nlong randrange(long n)\n{\n\treturn (int)std.math.random(n);\n\
    }\n/*\nReturn a random number between m and n-1 (inclusive).\n    \n    >>> randrange(2,\
    \ 101L)\n    3L\n    \n*/\nlong randrange(long m, long n)\n{\n\treturn randrange(m)\
    \ + (n - m);\n}\n/*\nReturn a random float between 0 and 1.\n    \n    >>> randfloat()\n\
    \    0.9401687363368665\n    \n*/\ndouble randfloat()\n{\n\treturn (double)std.math.random();\n\
    }\n/*\nReturn a random int between m and n-1 (inclusive).\n    \n    >>> randint2(2,\
    \ 101L)\n    3L\n    \n*/\nlong randint2(long m, long n)\n{\n\treturn randrange(m)\
    \ + (n - m);\n}\n/*\nReturn a random long between 0 and n-1.\n    \n    >>> randlong2(101L)\n\
    \    5L\n    \n*/\nlong randlong2(long n)\n{\n\treturn randrange(n);\n}\n/*\n\
    Return a random float between -1 and n (exclusive).\n    \n    >>> randint3(101L)\n\
    \    -0.9173268801866131\n    \n*/\ndouble randint3(long n)\n{\n\treturn (double)(std.math.random()\
    \ * ((double)n + (double)1));\n}\n/*\nReturn a random long between m and n (inclusive).\n\
    \    \n    >>> randint3(2, 101L)\n    2L\n    \n*/\nlong randint3(long m, long\
    \ n)\n{\n\treturn randrange(m) + (n - m);\n}\n/*\nReturn a random int between\
    \ m and n (inclusive).\n    \n    >>> randint3(2, 101L)\n    2L\n    \n*/\nlong\
    \ randint3(long m, long n)\n{\n\treturn randrange(m) + (n - m);\n}\n/*\nReturn\
    \ a random long between 0 and n (exclusive).\n    \n    >>> randint3(2, 101L)\n\
    \    2L\n    \n*/\nlong randint3(long m, long n)\n{\n\treturn randrange(m) + (n\
    \ - m);\n}\n/*\nReturn a random long between 0 and n (inclusive).\n    \n    >>>\
    \ randint3(2, 101L)\n    2L\n    \n*/\nlong randint3(long m, long n)\n{\n\treturn\
    \ randrange(m) + (n - m);\n\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7buxgv63.d(30): Error: C style cast illegal, use cast(int)std.math.random(n)\n/tmp/tmp7buxgv63.d(52):
    Error: C style cast illegal, use cast(double)std.math.random()\n/tmp/tmp7buxgv63.d(85):
    Error: C style cast illegal, use cast(double)n\n/tmp/tmp7buxgv63.d(85): Error:
    C style cast illegal, use cast(double)1\n/tmp/tmp7buxgv63.d(85): Error: C style
    cast illegal, use cast(double)(std.math.random() * (cast(double)n + cast(double)1))\n/tmp/tmp7buxgv63.d(131):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp7buxgv63.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r, c;\n   \
    \ \n    c = n % p;\n    r = (n / p) - c;\n    if (r < 0) {\n        r %= p;\n\
    \        c = p - r;\n    }\n    \n    return (r << 1) + c;\n}\n// End of file\
    \ stdmodp.cpp\n// //////////////////////////////////////////////////////////////////\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=modulo,c++,bit-manipulation |>\nIn a 32-bit\
    \ (signed) machine, there is no way to represent negative numbers as integers,\
    \ since they require a larger number of bits.\nThe most straightforward way would\
    \ be to mask off the most significant bit in the integer, then shift the result\
    \ one bit to the right to get the desired result.\n<code>\n#include <iostream>\n\
    #include <stdint.h>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpucae9b26.d(32): Error: Declaration expected, not \''<\''\n/tmp/tmpucae9b26.d(44):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpucae9b26.d(45): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpucae9b26.d(46): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpucae9b26.d(47): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpucae9b26.d(48): Error: Declaration expected, not \''assert\''\n/tmp/tmpucae9b26.d(49):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpucae9b26.d(50): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpucae9b26.d(51): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpucae9b26.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 0) \n\t\t\
    return n;\n\t\n\tlong m = p + n - 1; \n\treturn (m % p + p) % p; \n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp39wujd_j.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong mask = 1;\n\t\
    long x = n;\n\tint sign;\n\twhile (x != 0) {\n\t\tif (x & 1) x = p * x + n;\n\t\
    \tsign = x >> 63;\n\t\tmask <<= 1;\n\t\tmask |= sign;\n\t}\n\treturn (n >> 63)\
    \ - mask;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpszzuu9ir.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long ans = 1;\n\
    \    long mask;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpxd1z_ldn.d(21): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxd1z_ldn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int t;\n    long\
    \ r;\n    \n    if (p == 0)\n\t{\n\t    r = 1L;\n\t}\n    else if (n == 0)\n\t\
    {\n\t    r = 0L;\n\t}\n    else\n\t{\n\t    t = (((p-1L) & (p-1L)) - 1L) % p;\n\
    \t    r = modp(n/p, p);\n\t    if (t != 0L)\n\t\t{\n\t\t    r = (r * (p-1L) +\
    \ t) % p;\n\t\t}\n\t}\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp473dcyex.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long rem;\n    if\
    \ (n >= p) { \n        long r = p + modp(p - n, p);\n        long s = n - p;\n\
    \        if (s <= 0) {\n            return r;\n        }\n        rem = (r * s\
    \ - r) / s;\n        if (rem < 0)\n            rem += p;\n        return rem +\
    \ 1;\n    }\n    return n;\n}\n</code>\n<|/ a |>\n<| c |>\nCan you explain a little\
    \ bit more about this solution? This code looks good but I have no idea what it\
    \ means.\n<|/ c |>\n<| c |>\nThis solution was created by [Jack Dorsey](http://stackoverflow.com/questions/2582712/modular-exponentiation-in-java#answer-2582825).\n\
    <|/ c |>\n<| c |>\nThe algorithm is pretty straight forward, it basically works\
    \ by repeatedly taking a \"square root\" (`sqrt(x) = floor(sqrt(x))`) of a number\
    \ until it has no remainder. Since you just want a power of two modulo `p`, this\
    \ only works when the modulus is prime. If it is a non-prime number, the algorithm\
    \ will repeat it until it does have a remainder.\n<|/ c |>\n<| c |>\nThis code\
    \ isn't working for me. It always return 1 when input is not even number.\n<|/\
    \ c |>\n<| c |>\nCan you please post a complete example and what input you are\
    \ using? I tried it with your example and it works.\n<|/ c |>\n<| a |>\nThe simplest\
    \ and fastest method I know of for raising numbers in modulo p is to first do\
    \ an exponentiation mod p, then take the result mod p.\n<code>\nlong modpow(long\
    \ n, long m, long p) {\n    long result = 1;\n    for (long i = 2; i <= n; i++)\
    \ {\n        result = modpow(i,m,p) * p;\n    }\n    return result % m;\n}\n</code>\n\
    <|/ a tags=java,modular-arithmetic dscore=3 |>\n<| c |>\nVery efficient implementation!\
    \ Thanks.\n<|/ c |>\n<| a |>\nI used the idea of a \"square root\" (sqrt(x)) and\
    \ solved it using the following algorithm:\nunittest\n{\n    alias candidate =\
    \ modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L)\
    \ == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L)\
    \ == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgibxx95_.d(33): Error: Declaration expected, not \''<\''\n/tmp/tmpgibxx95_.d(45):
    Error: unterminated character constant\n/tmp/tmpgibxx95_.d(55): Error: Declaration
    expected, not \''for\''\n/tmp/tmpgibxx95_.d(55): Error: no identifier for declarator
    i\n/tmp/tmpgibxx95_.d(55): Error: Declaration expected, not \''<=\''\n/tmp/tmpgibxx95_.d(55):
    Error: no identifier for declarator i\n/tmp/tmpgibxx95_.d(55): Error: Declaration
    expected, not \''++\''\n/tmp/tmpgibxx95_.d(57): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgibxx95_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n < p) {\n\t\t\
    return 0;\n\t}\n\tlong q = p - 1L;\n\tlong r = n - p;\n\tlong d = (r + q) >> 1L;\n\
    \twhile (d != 0) {\n\t\tlong rem = r - d;\n\t\tr = d;\n\t\td = (rem + q) >> 1L;\n\
    \t}\n\treturn r + p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpczclfuh_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = p & -p,\
    \ q;\n    \n    /* Make n positive */\n    if (r < n)\n    {\n\tq = n << 1;\n\t\
    do\n\t    q = q >> 1;\n\twhile (r < q);\n\tq = n >> 1;\n\tdo\n\t    q = q >> 1;\n\
    \twhile (r < q);\n\tr = q;\n    }\n    else\n    {\n\twhile (r >= n)\n\t    r\
    \ -= n;\n    }\n    \n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_zd3b92j.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\t// FIXME: handle NaN?\n\
    \tif (n >= p)\n\t\treturn n;\n\telse\n\t\treturn (n - p + 1) * p % n;\n}\n// end\
    \ \"modp.h\"\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5jboheq6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint u;\n\tlong res;\n\
    \t\n\tres = n & p;\n\t\n\tfor (u = 3; u <= 64; u *= 2) {\n\t\tif (n >= u) {\n\t\
    \t\tres += 1;\n\t\t\tn -= u;\n\t\t}\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgpcs9agy.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long m = n;\n  \
    \  \n    while (m & 1L)\n\tm >>= 1L;\n    \n    long x = 0;\n    \n    while ((m\
    \ & 1L) != 0)\n\tm >>= 1L;\n    \n    for (;;) {\n\tx <<= 1L;\n\tm >>= 1L;\n\t\
    \n\tif (m == 0L)\n\t    break;\n\t\n\tif (n & 1L)\n\t    x |= 1L;\n\t\n\tif (m\
    \ != 0L)\n\t    m <<= 1L;\n    }\n    \n    return x % p;\n}\n/*\nReturn n^m modulo\
    \ p.\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    1L\n    >>>\
    \ modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n\
    \    1L\n    \n*/\nlong powm(long n, long m) {\n    long p = 1;\n    \n    while\
    \ (m & 1L)\n\tp <<= 1L;\n    \n    m >>= 1L;\n    \n    for (;;) {\n\tp <<= 1L;\n\
    \tm >>= 1L;\n\t\n\tif (m == 0L)\n\t    break;\n\t\n\tif (n & 1L)\n\t    p |= 1L;\n\
    \t\n\tif (m != 0L)\n\t    m <<= 1L;\n    }\n    \n    return p;\n}\n/*\nReturn\
    \ n^m modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>>\
    \ modp(1101L, 101L)\n    1L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nlong powm_m(long n,\
    \ long m) {\n    long p = 1;\n    \n    while (m & 1L)\n\tp <<= 1L;\n    \n  \
    \  m >>= 1L;\n    \n    for (;;) {\n\tp <<= 1L;\n\tm >>= 1L;\n\t\n\tif (m == 0L)\n\
    \t    break;\n\t\n\tif (n & 1L)\n\t    p |= 1L;\n\t\n\tif (m != 0L)\n\t    m <<=\
    \ 1L;\n    }\n    \n    return p;\n}\n/*\nReturn n^m modulo p (be aware of \n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplra5ab3v.d(121): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplra5ab3v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1;\n\
    \    long base = 2;\n    while (true) {\n        long mask = (base << 1) ^ base;\n\
    \        if (n & mask) result ^= base;\n        base <<= 1;\n        n >>= 1;\n\
    \    }\n    if (p == 1)\n        return result;\n    else \n        return result\
    \ ^ modp(n >> 1, p);\n}\n\"\"\")\n        self.write_func_comment(\"\"\"\nReturns\
    \ modular multiplicative inverse: x^(-n) mod p.\n    \n    >>> modinv(16L, 5L)\
    \ # 16^-5 mod 5\n    2L\n    >>> modinv(2L, 5L) # 2^-5 mod 5\n    1L\n    >>>\
    \ modinv(5L, 2L) # 5^-2 mod 2\n    3L\n    >>> modinv(5L, 11L) # 5^-11 mod 11\n\
    \    2L\n    \nThe inverse of a prime modulo p is also the multiplicative inverse\
    \ of p modulo p.\n    \n    >>> modinv(4L, 5L)\n    1L\n    >>> modinv(4L, 2L)\n\
    \    3L\n    \nThe inverse of 0 is 1, and of 1 is 1.\n    \n    >>> modinv(0L,\
    \ 3L)\n    1L\n    >>> modinv(1L, 3L)\n    1L\n    \nThe inverse of -1 is 0.\n\
    \    \n    >>> modinv(-1, 3L)\n    0L\n    \n\"\"\");\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpq0pgmzki.d(32): Error: Declaration expected, not \''""\''\n/tmp/tmpq0pgmzki.d(64):
    Error: unterminated string constant starting at /tmp/tmpq0pgmzki.d(64)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq0pgmzki.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint i; \n\tlong res\
    \ = 1L;\n\tfor (i=0; i<n; i++) res *= p;\n\tres %= p;\n\tif (res == p) res ^=\
    \ p; // don't change sign\n\treturn res;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy9cya2vn.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong t = n >> 52;\n\
    \tn = (n - t*p) >> 52;\n\tn = (t + n*p + p) % (p - 1);\n\treturn n;\n}\n/*\nReturn\
    \ a random number between min (inclusive) and max (inclusive).\n    Max is exclusive\
    \ (so f(min) is different from f(max))\n    \n    >>> random(0)\n    0\n    >>>\
    \ random(10)\n    9\n    >>> random(-10, 5)\n    -5\n    \n*/\nlong random(long\
    \ min, long max)\n{\n\treturn min + (long)drand48() * (max - min);\n}\n/*\nReturn\
    \ a random number between min (inclusive) and max (inclusive).\n    Max is inclusive\
    \ (so f(min) == f(max))\n    \n    >>> randomint()\n    0\n    >>> randomint(10)\n\
    \    9\n    >>> randomint(-10, 5)\n    -5\n    \n*/\nlong randomint(long min,\
    \ long max)\n{\n\treturn random(min, max) + 1;\n}\n/*\nReturn a random element\
    \ of arr (which must be a vector of length n)\n    \n    >>> randomvec(\"\")\n\
    \    Traceback (most recent call last):\n        ...\n    IndexError: string index\
    \ out of range\n    \n    >>> randomvec([1, 2, 3, 4])\n    3\n    \n*/\nobject\
    \ randomvec(string arr)\n{\n\tint n = arr.length;\n\tint k = random(0, n);\n\t\
    return arr[k];\n}\n/*\nReturn a random element of arr (which must be a vector\
    \ of length n)\n    \n    >>> randomveclist([10, 11, 12, 13])\n    13\n    \n\
    */\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgcjihswr.d(38): Error: C style cast illegal, use cast(long)drand48()\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgcjihswr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d;\n\t\n\td =\
    \ p - n;\n\tif (d > 0)\n\t{\n\t\tif (n < 0)\n\t\t\td = -d;\n\t\tn = n * 2;\n\t\
    \twhile (d % 2 != 0)\n\t\t\td = d / 2;\n\t\tn = n - 1;\n\t}\n\telse\n\t{\n\t\t\
    n = n * 2;\n\t\twhile (d % 2 != 0)\n\t\t\td = d / 2;\n\t\tn = n + 1;\n\t}\n\t\
    return n;\n}\n\t\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx7fh1nnv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long q = n / p;\n\
    \    return q*q % p;\n}\n/* \n* Return r**n (mod p), for integers n, p > 0.\n\
    * \n* For integers n, p > 0, r**n % p == r**n\n*/\nlong powr(long r, long n, long\
    \ p) \n{\n    return powrr_impl(r, n, p, r);\n}\n/*\nReturn r**n (mod p), for\
    \ integers n, p > 0, r <= MAX_R\n*/\nlong powr_impl(long r, long n, long p, long\
    \ MAX_R) {\n    int exponent;\n    if (n >= MAX_R) {\n        exponent = n;\n\
    \    }\n    else {\n        exponent = modp(MAX_R - n, p);\n    }\n    return\
    \ r * r * (exponent - p) % p;\n}\n/* Return 2**n (mod p), for integers n, p >\
    \ 0\n    \nFor integers n, p > 0, 2**n <= p\n*/\nlong pow2(long n, long p) {\n\
    \    return pow2_impl(n, p, n);\n}\n/*\nReturn 2**n (mod p), for integers n, p\
    \ > 0, r <= MAX_R\n*/\nlong pow2_impl(long n, long p, long MAX_R) {\n    long\
    \ maxexp;\n    long r;\n    if (n >= MAX_R) {\n        maxexp = MAX_R-1;\n   \
    \ }\n    else {\n        maxexp = modp(MAX_R-n, p);\n    }\n    r = powr_impl(2,\
    \ n, p, maxexp);\n    return r % p;\n}\n/*\nReturn n! (mod p). \n    \nFor integers\
    \ n, p > 0\n*/\nlong factorial(long n, long p) {\n    long p = p;\n    long r\
    \ = 1;\n    while (n > p) {\n        r = r * n % p;\n        n = n / p;\n    }\n\
    \    return r;\n}\n/*\nReturn n! (mod p). \n    \nFor integers n, p > 0\n*/\n\
    long factorial_impl(long n, long p) {\n    long maxexp;\n    long r;\n    if (n\
    \ >= p) {\n        maxexp = p - 1;\n    }\n    else {\n        maxexp = modp(n\
    \ - p, p);\n    }\n    r = factorial_impl(n, maxexp);\n    return r % p;\n}\n\
    /* Return sqrt(n)\n   \nFor integers n >= 0\n*/\nlong sqrt(long n) {\n    long\
    \ p = n;\n    long r = 1;\n    long m;\n    long t;\n    long sqexp;\n    while\
    \ (p > 0) {\n        m = p%10;\nunittest\n{\n    alias candidate = modp;\n\n \
    \   assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpdojbziiu.d(109): Error: found \''unittest\'' instead of statement\n/tmp/tmpdojbziiu.d(121):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdojbziiu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0) return\
    \ 0L;\n    long res = 1L;\n    while ((n % p) == 0)\n    {\n        res = (res*2L)\
    \ % p;\n        n = n/p;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe5usyt4b.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    // TODO: improve\
    \ performance\n    long result = n & -p;\n    if (result != 0)\n        return\
    \ result + p;\n    \n    return result + p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfo0uipq5.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n == 0L)\n\t{\n\
    \t\treturn 0L;\n\t}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6x4q61dm.d(23): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6x4q61dm.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x, t;\n\t\n\t\
    x = n & p;\n\tt = n >> 32;\n\tif (x == 0)\n\t{\n\t\treturn 1L;\n\t}\n\treturn\
    \ std.math.pow(x * x, 32L) % (p % x) + t;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe0mpi30u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0) {\n        if (n & 1L) {\n            res = (res * p) % p;\n\
    \        }\n        n >>= 1;\n        p = (p * p) % p;\n    }\n    return res;\n\
    }\n#endif\n/* \n * Reverse a vector.\n * For each element in the vector v[i],\
    \ v[i] is swapped with v[(i + n) % v.len()]\n * \n * Returns 0 if the input vector\
    \ was null, or -1 if the input vector was too short\n * \n * Complexity: O(v.len())\n\
    \ */\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpex1a_8zn.d(29): Error: Declaration expected, not \''#\''\n/tmp/tmpex1a_8zn.d(42):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpex1a_8zn.d(43): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpex1a_8zn.d(44): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpex1a_8zn.d(45): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpex1a_8zn.d(46): Error: Declaration expected, not \''assert\''\n/tmp/tmpex1a_8zn.d(47):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpex1a_8zn.d(48): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpex1a_8zn.d(49): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpex1a_8zn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q;\n\t\n\tif(p\
    \ == 0)\n\t\treturn 0;\n\tif(p == 1)\n\t\treturn n;\n\tif(p < 0)\n\t{\n\t\tif(n\
    \ < 0)\n\t\t{\n\t\t\tif(p == -1)\n\t\t\t\treturn n;\n\t\t\telse\n\t\t\t\treturn\
    \ 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(p == 0)\n\t\t\t\treturn n;\n\t\t\telse\n\
    \t\t\t\treturn 1;\n\t\t}\n\t}\n\tif(n == 0)\n\t\treturn 0;\n\tif(n == 1)\n\t\t\
    return p;\n\t\n\tq = n;\n\tp = p - 1;\n\t\n\twhile(p > 0)\n\t{\n\t\tq = q * p;\n\
    \t\tp = p - 1;\n\t}\n\t\n\tif(p == 1)\n\t\treturn q;\n\telse\n\t\treturn n - q;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp91npor5k.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q, r;\n\tif(n\
    \ == 0) \n\t{\n\t\treturn 0;\n\t}\n\tif(n == 1)\n\t{\n\t\treturn p;\n\t}\n\tq\
    \ = n / p;\n\tr = n % p;\n\tif(p % 2 == 1) \n\t{\n\t\tq = -q;\n\t}\n\treturn p\
    \ * q + r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9qzngj_7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return divrem(n,\
    \ p) >> 1;\n}\n\"\"\")\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6v6loyl3.d(21): Error: Declaration expected, not \''""\''\n/tmp/tmp6v6loyl3.d(21):
    Error: unterminated string constant starting at /tmp/tmp6v6loyl3.d(21)\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6v6loyl3.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = n;\n  \
    \  long t = r;\n    while (t > 0) {\n\tr = r * p % modp((n-1)/t, p);\n\tt--;\n\
    \    }\n    return r;\n}\n/*\nReturn p * 2^n modulo p (be aware of numerics).\n\
    */\nlong mulp2p(long n, long p) \n{\n    long r = p;\n    long t = r;\n    while\
    \ (t > 0) {\n\tr = r * n % modp((n-1)/t, p);\n\tt--;\n    }\n    return r;\n}\n\
    /*\nReturn p * 2^(n-1) modulo p (be aware of numerics).\n*/\nlong mulp2p1(long\
    \ n, long p) \n{\n    long r = p;\n    long t = r;\n    while (t > 0) {\n\tr =\
    \ r * n % modp((n-1)/t, p);\n\tt--;\n    }\n    return r;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph1a_aoju.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (p == 0) return\
    \ 0L;\n    return std.math.remainder(n, p);\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 3L)\n    8L\n    >>> modp(1101L, 1101L)\n  \
    \  1L\n    >>> modp(0L, 1101L)\n    1L\n    >>> modp(3L, 5L)\n    2L\n    >>>\
    \ modp(100L, 100L)\n    0L\n    \n*/\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdaa_4vv1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q;\n\t\n\tif\
    \ (p == 0) return 0;\n\tq = n % p;\n\treturn p + q;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp141za9oi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  return n%(p - 1);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw987hbmu.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return __gcd(n,\
    \ p);\n}\n/*\nReturn a new list containing every element that is >= to l, and\
    \ every element that is <= to l.\n    >>> rangei([0, 2], 3)\n    [(0, 1), (0,\
    \ 2), (1, 2)]\n    \n*/\nList<T> rangei(List<T> l, T to) \n{\n    List<T> r =\
    \ new List<T>(l.size());\n    r.add(l.head);\n    T current = l.head;\n    while\
    \ (current != to)\n    {\n        T next = current;\n        current = current.next;\n\
    \        r.add(next);\n    }\n    return r;\n}\n/*\nReturn a new list containing\
    \ every element that is >= to l, and every element that is <= to l.\n    >>> rangeu([0,\
    \ 2], 3)\n    [(0, 1), (1, 2), (0, 2)]\n    \n*/\nList<T> rangeu(List<T> l, T\
    \ to) \n{\n    List<T> r = new List<T>(l.size());\n    T current = l.head;\n \
    \   while (current != to)\n    {\n        T next = current;\n        current =\
    \ current.next;\n        r.add(next);\n    }\n    return r;\n}\n/*\nReturn a new\
    \ list containing every element that is >= to l, and every element that is <=\
    \ to l.\n    >>> ranges([0, 2], 3)\n    [(0, 1), (0, 2), (2, 3)]\n    \n*/\nList<T>\
    \ ranges(List<T> l, T to) \n{\n    List<T> r = new List<T>(l.size());\n    r.add(l.head);\n\
    \    T current = l.head;\n    while (current != to)\n    {\n        T next = current;\n\
    \        current = current.next;\n        r.add(next);\n    }\n    return r;\n\
    }\n/*\nReturn a new list containing every element that is >= to l, and every element\
    \ that is <= to l.\n    >>> rangep([0, 2], 3)\n    [(0, 1), (0, 2), (1, 3)]\n\
    \    \n*/\nList<T> rangep(List<T> l, T to) \n{\n    List<T> r = new List<T>(l.size());\n\
    \    r.add(l.head);\n    T current = l.head;\n    while (current != to)\n    {\n\
    \        T next = current;\n        current = current.next;\n        r.add(next);\n\
    \    }\n    return r;\n}\n/*\nReturn a new list containing every element that\
    \ is >= to l, and every element that is <= to l.\n    >>> ranged([0, 2], 3)\n\
    \    [(0, 1), (1, 2), (2, 3)]\n    \n*/\nList<T> ranged(List<T> l, T to) \n{\n\
    \    List<T> r = new List<T>(l.size());\n    r.add(l.head);\n    T current = l.head;\n\
    \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpaabcwu5e.d(27): Error: no identifier for declarator List\n/tmp/tmpaabcwu5e.d(27):
    Error: Declaration expected, not \''<\''\n/tmp/tmpaabcwu5e.d(30): Error: function
    declaration without return type. (Note that constructors are always named \''this\'')\n/tmp/tmpaabcwu5e.d(30):
    Error: no identifier for declarator r.add(l.head)\n/tmp/tmpaabcwu5e.d(32): Error:
    Declaration expected, not \''while\''\n/tmp/tmpaabcwu5e.d(35): Error: no identifier
    for declarator current\n/tmp/tmpaabcwu5e.d(35): Error: Declaration expected, not
    \''=\''\n/tmp/tmpaabcwu5e.d(36): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmpaabcwu5e.d(36):
    Error: no identifier for declarator r.add(next)\n/tmp/tmpaabcwu5e.d(37): Error:
    unrecognized declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaabcwu5e.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    \n    if (n <= 0\
    \ || p <= 0) {\n        throw new IllegalArgumentException(\"modulus must be positive\"\
    );\n    }\n    \n    return ((long)n & (-p)) + (long)((long)n * (long)p >> 32);\n\
    }\n\"\"\"\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpel_tnni0.d(24): Error: C style cast illegal, use cast(long)n\n/tmp/tmpel_tnni0.d(24):
    Error: C style cast illegal, use cast(long)n\n/tmp/tmpel_tnni0.d(24): Error: C
    style cast illegal, use cast(long)p\n/tmp/tmpel_tnni0.d(24): Error: C style cast
    illegal, use cast(long)(cast(long)n * cast(long)p >> 32)\n/tmp/tmpel_tnni0.d(26):
    Error: Declaration expected, not \''""\''\n/tmp/tmpel_tnni0.d(26): Error: unterminated
    string constant starting at /tmp/tmpel_tnni0.d(26)\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpel_tnni0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1;\n\
    \    while (n >= p) {\n        res *= p;\n        n -= p;\n    }\n    return ((n\
    \ - p) % p) + p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpicporwgc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return modp(new\
    \ long[n], p).n[0];\n}\npublic struct __modp {\n    public long[] n;\n    public\
    \ __modp(long _n, long _p) \n    {\n        n = new long[_n / _p + 1];\n     \
    \   long a = _n % _p;\n        n[_n / _p] = 0;\n        if (a == 0) \n       \
    \ {\n            long b = 1;\n            int k = 0;\n            while (a !=\
    \ 0) {\n                n[k++] = a % _p;\n                a = (a / _p) * b;\n\
    \                b *= _p;\n            }\n        }\n        else {\n        \
    \    long a = 1;\n            int k = 0;\n            while (a != 0) {\n     \
    \           n[k++] = a % _p;\n                a = (a / _p) * a;\n            \
    \    a *= _p;\n            }\n        }\n    }\n}\nstatic final __modp modp =\
    \ new __modp(1L, 101L);\n// end\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmply9hj1e5.d(23): Error: function declaration without return type.
    (Note that constructors are always named \''this\'')\n/tmp/tmply9hj1e5.d(24):
    Error: no identifier for declarator __modp(long _n, long _p)\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmply9hj1e5.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong ret = 1;\n\t\
    while(n) {\n\t\tret = p * ret;\n\t\tn &= n - 1;\n\t}\n\treturn ret;\n}\n/*\n \
    \   Return sum of two longs modulo p. Beware of overflow.\n    >>> sum3mod(100L,\
    \ 101L)\n    1L\n*/\nlong sum3mod(long x, long y) \n{\n\tlong sum;\n\tsum = x+y;\n\
    \treturn sum % modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_y63mmnn.d(36): Error: expression expected, not \''unittest\''\n/tmp/tmp_y63mmnn.d(37):
    Error: found \''{\'' when expecting \'',\''\n/tmp/tmp_y63mmnn.d(38): Error: expression
    expected, not \''alias\''\n/tmp/tmp_y63mmnn.d(38): Error: found \''candidate\''
    when expecting \'',\''\n/tmp/tmp_y63mmnn.d(38): Error: expression expected, not
    \''=\''\n/tmp/tmp_y63mmnn.d(38): Error: found \''modp\'' when expecting \'',\''\n/tmp/tmp_y63mmnn.d(38):
    Error: expression expected, not \'';\''\n/tmp/tmp_y63mmnn.d(40): Error: found
    \''assert\'' when expecting \'',\''\n/tmp/tmp_y63mmnn.d(40): Error: found \'';\''
    when expecting \'',\''\n/tmp/tmp_y63mmnn.d(41): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmp_y63mmnn.d(42): Error: found \'';\'' when expecting \'',\''\n/tmp/tmp_y63mmnn.d(43):
    Error: found \'';\'' when expecting \'',\''\n/tmp/tmp_y63mmnn.d(44): Error: found
    \'';\'' when expecting \'',\''\n/tmp/tmp_y63mmnn.d(45): Error: found \'';\'' when
    expecting \'',\''\n/tmp/tmp_y63mmnn.d(46): Error: found \'';\'' when expecting
    \'',\''\n/tmp/tmp_y63mmnn.d(47): Error: expression expected, not \''}\''\n/tmp/tmp_y63mmnn.d(48):
    Error: found \''void\'' when expecting \'',\''\n/tmp/tmp_y63mmnn.d(48): Error:
    found \''{\'' when expecting \'',\''\n/tmp/tmp_y63mmnn.d(48): Error: expression
    expected, not \''}\''\n/tmp/tmp_y63mmnn.d(48): Error: found \''EOF\'' when expecting
    \'',\''\n/tmp/tmp_y63mmnn.d(48): Error: found \''EOF\'' when expecting \'')\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_y63mmnn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long rem, t;\n \
    \   /* Find modulus */\n    t = n*p;\n    rem = ((t+1)&(t-1));\n    if (rem ==\
    \ 0) {\n        return 1;\n    } else {\n        return (rem-1L) / p;\n    }\n\
    }\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n   \
    \ 3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>>\
    \ modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfnb0extk.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res = 1;\n\t\
    long mask = 1;\n\tlong tmp = n - p;\n\twhile(mask > 0) {\n\t\tres = (res * tmp)\
    \ % p;\n\t\tmask = (mask * 10L) % p;\n\t}\n\treturn res;\n}\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5krar4nj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long d = n - p;\n\
    \  if(d < 0) return p - modp(d, p);\n  if(d >= p) return n;\n  \n  long r = 1;\n\
    \  while(d != 0) {\n    d = d / 2;\n    r = r * 2;\n  }\n  \n  return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6_5iulyd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r;\n\tn = long(n);\n\
    \tp = long(p);\n\tr = (n&(1L<<p)) - 1;\n\treturn r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp2qc6b_y4.d(20): Error: found \''(\'' when expecting \''.\''
    following long\n/tmp/tmp2qc6b_y4.d(20): Error: found \'')\'' when expecting \'';\''
    following statement\n/tmp/tmp2qc6b_y4.d(21): Error: found \''(\'' when expecting
    \''.\'' following long\n/tmp/tmp2qc6b_y4.d(21): Error: found \'')\'' when expecting
    \'';\'' following statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2qc6b_y4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long r = n;\n  long\
    \ m = 0;\n  while(m < (long)(p - 1)) {\n    r <<= 1;\n    m ++;\n  }\n  m %= p;\n\
    \  while(m > 0) {\n    r <<= 1;\n    m --;\n  }\n  return r;\n}\n</code>\n<|/\
    \ a tags=math,modular-arithmetic,bit-manipulation,java,c++ |>\n<| c |>\nYour implementation\
    \ is buggy, it fails for mod 2 with your example, it returns 1 for 2L.\n<|/ c\
    \ |>\n<| c |>\nThe OP was only looking for the modulo operation. Anything else\
    \ would probably be an overkill and in any case this kind of answer is frowned\
    \ upon.\n<|/ c |>\n<| a |>\nThe question was originally tagged C and C++.\nIn\
    \ the C language:\n<code>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp71owwvx0.d(21): Error: C style cast illegal, use cast(long)(p
    - 1)\n/tmp/tmp71owwvx0.d(32): Error: Declaration expected, not \''<\''\n/tmp/tmp71owwvx0.d(48):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp71owwvx0.d(49): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp71owwvx0.d(50): Error: Declaration
    expected, not \''assert\''\n/tmp/tmp71owwvx0.d(51): Error: Declaration expected,
    not \''assert\''\n/tmp/tmp71owwvx0.d(52): Error: Declaration expected, not \''assert\''\n/tmp/tmp71owwvx0.d(53):
    Error: Declaration expected, not \''assert\''\n/tmp/tmp71owwvx0.d(54): Error:
    Declaration expected, not \''assert\''\n/tmp/tmp71owwvx0.d(55): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp71owwvx0.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn 1L & ((long)n)\
    \ % ((long)p) ;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpm4ocozhu.d(19): Error: C style cast illegal, use cast(long)n\n/tmp/tmpm4ocozhu.d(19):
    Error: C style cast illegal, use cast(long)p\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmpm4ocozhu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long ret = n;\n\
    \    while(ret && ret % p) \n        ret /= p;\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprqv7x3nd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d = n % p;\n\t\
    n /= p;\n\tif (d > 0)\n\t\tn++;\n\treturn n;\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ms6z_oj.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int k = (int)n;\n\
    \    long r, r2;\n    \n    if (k < 0) \n    {\n        PyErr_SetString(PyExc_ValueError,\
    \ \"modp() arg 1 must be >= 0\");\n        return 1;\n    }\n    \n    if (k >=\
    \ p)\n    {\n        return 0;\n    }\n    \n    r = 1;\n    r2 = p;\n    while\
    \ (k > 0) \n    {\n        r <<= 1;\n        r += (r2 & 1);\n        r2 >>= 1;\n\
    \        k >>= 1;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate =\
    \ modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L)\
    \ == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L)\
    \ == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf_zwqqpb.d(19): Error: C style cast illegal, use cast(int)n\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf_zwqqpb.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long m = 2;\n  \
    \  while(p % m == 0)\n        m = m*2;\n    return ((n%m) + m - 1L) % m;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg8g6x_1h.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n == 0) return\
    \ 0;\n\tif(n == 1) return p;\n\tlong q, r;\n\tif(p == 1) return 1;\n\tif(p ==\
    \ 0) return 0;\n\tq = modp(n >> 1, p); \n\tr = n % p; \n\treturn ((n ^ q) * p\
    \ + r) % p; \n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwotv4drd.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return ((long) n)\
    \ % (long) p;\n}\n</code>\n<|/ a |>\n<| c |>\nYour modp function works fine for\
    \ positive numbers, where as Python uses modular inverse for negative numbers.\n\
    <|/ c |>\n<| c |>\nThis works fine for positive numbers, but not for negative\
    \ numbers. Just use Math.abs(): https://pastebin.com/ZgZ4uFXA\n<|/ c |>\n<| a\
    \ dscore=4 |>\n<code>\ndef modular_inverse(a, p):\n    \"\"\" Return modular inverse\
    \ of 'a' in base 'p'.\n    >>> modular_inverse(2, 3)\n    1\n    \"\"\"\n    q,\
    \ r = divmod(a, p)\n    if r == 0: return q\n    inverse = pow(p, q-1, p)\n  \
    \  if a == inverse:\n        # Extremely rare case, but we'll take a guess for\
    \ it.\n        return modular_inverse(a, q)\n    return inverse\n</code>\n<|/\
    \ a tags=algorithm,python,modular |>\n<| a |>\nHere's a working Python version\
    \ which doesn't use any external libraries:\n<code>\ndef modinv(a, m):\n    m,\
    \ n = divmod(a, m)\n    if m == 0:\n        return a\n    elif n == 0:\n     \
    \   return modinv(a, m)\n    else:\n        return modinv(a, (m*m)%m)\n</code>\n\
    For positive integers, the above will work just fine. If m is a negative number,\
    \ it will fail. \n<code>\n>>> modinv(7, 12)\n17\n>>> modinv(7, -7)\n-7\n</code>\n\
    <|/ a tags=algorithm,python,modular dscore=4 |>\n<| c |>\nGreat! I love Python.\n\
    <|/ c |>\n<| c |>\n`modinv()` doesn't work for negative integers though\n<|/ c\
    \ |>\n<| a tags=algorithm,python,modular |>\n<code>\ndef modinv(x, m):\n    x,\
    \ m = abs(x), abs(m)\n    if m == 2:\n        if x == 1: return x\n        if\
    \ x%2 == 0: return 1\n        if x%2 == 1: return x\n    m, n = divmod(x, m)\n\
    \    if m == 0: return m\n    if n == 0:\n        return modinv(x, m)\n    return\
    \ modinv(x*x, m%m)\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgjaxih5j.d(19): Error: C style cast illegal, use cast(long)n\n/tmp/tmpgjaxih5j.d(19):
    Error: C style cast illegal, use cast(long)p\n/tmp/tmpgjaxih5j.d(21): Error: Declaration
    expected, not \''<\''\n/tmp/tmpgjaxih5j.d(40): Error: unterminated character constant\n/tmp/tmpgjaxih5j.d(46):
    Error: unterminated character constant\n/tmp/tmpgjaxih5j.d(46): Error: unterminated
    character constant\n/tmp/tmpgjaxih5j.d(69): Error: unterminated character constant\n/tmp/tmpgjaxih5j.d(88):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpgjaxih5j.d(89): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpgjaxih5j.d(90): Error: Declaration
    expected, not \''assert\''\n/tmp/tmpgjaxih5j.d(91): Error: Declaration expected,
    not \''assert\''\n/tmp/tmpgjaxih5j.d(92): Error: Declaration expected, not \''assert\''\n/tmp/tmpgjaxih5j.d(93):
    Error: Declaration expected, not \''assert\''\n/tmp/tmpgjaxih5j.d(94): Error:
    Declaration expected, not \''assert\''\n/tmp/tmpgjaxih5j.d(95): Error: unrecognized
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgjaxih5j.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long rem;\n    \n\
    \    rem = n % p;\n    if (rem == 0) {\n        if (n >= p)\n            return\
    \ n;\n    }\n    if (rem == p) {\n        n /= p;\n        n--;\n        if (n\
    \ < 0) {\n            n = p + n;\n        }\n    }\n    return n * p;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnnov81_t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r;\n    bool\
    \ s = n % p;\n    if (s == 0) return n;\n    if (s == 1) return n - p;\n    if\
    \ (p % 2 == 0) {\n        r = modp(n/2, p);\n        return r*r + n;\n    } else\
    \ {\n        r = modp((n - 1)/2, p);\n        return r*r + n + 1L;\n    }\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpba3hxi_d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  return std.int.__pow__(std.int.__pow__(2,\
    \ n), p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpasgqccxx.d(19): Error: identifier expected following \''.\'',
    not \''int\''\n/tmp/tmpasgqccxx.d(19): Error: identifier expected following \''.\'',
    not \''int\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpasgqccxx.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r = 1L;\n\twhile\
    \ (n > 0L) {\n\t\tif (n & 1L) \n\t\t\tr = (r * p) % p;\n\t\tn = n >> 1;\n\t\t\
    p = (p * p) % p;\n\t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm82t0pd_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\t/*\n\tmodpow:\n\t\
    http://en.wikipedia.org/wiki/Modulo_operation\n\thttp://www.delorie.com/gnu/docs/gcc-4.6/lib/gcc/test/IntlTests/intltest-long-modpow.html\n\
    \t*/\n\tif(p == 1)\n\t\treturn n;\n\tif(p == 0)\n\t\treturn 0;\n\tif(p < 0)\n\t\
    \tp = -p;\n\tif(n == 0)\n\t\treturn 0;\n\tif(n < 0)\n\t\treturn modpow(-n, p);\n\
    \tlong ret = 0;\n\tlong a = n;\n\tlong b = p;\n\twhile(a != 0) {\n\t\tlong t =\
    \ b%a;\n\t\tret += t;\n\t\tb /= a;\n\t}\n\treturn p*ret + n;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpale2cz87.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q;\n\tn = n %\
    \ p;\n\tif(n == 0) \n\t\treturn n;\n\t\n\tif(p == 1) \n\t\treturn n;\n\t\n\tif(p\
    \ == 2) \n\t\treturn 2L;\n\t\n\tif(p == q) \n\t\treturn n;\n\t\n\tif(p == q +\
    \ 1) \n\t\treturn n - ((n - q) % p);\n\t\n\tif(p == q + 2) \n\t\treturn n - 1;\n\
    \t\n\tq = p / 2;\n\treturn modp(n, q) + modp((n - p * q) % p, q);\n}\n/* \n  \
    \  Find the least common multiple of n and p.\n    >>> lcm(5L, 10L)\n    10L\n\
    \    >>> lcm(101L, 10L)\n    10L\n    >>> lcm(0L, 10L)\n    0L\n    >>> lcm(100L,\
    \ 101L)\n    100L\n    \n*/\nlong lcm(long n, long p) \n{\n\treturn n * p / modp(n,\
    \ p);\n}\n/* \n    Find the least common multiple of n and p.\n    >>> lcm(5L,\
    \ 10L)\n    10L\n    >>> lcm(101L, 10L)\n    10L\n    >>> lcm(0L, 10L)\n    0L\n\
    \    >>> lcm(100L, 101L)\n    100L\n    \n*/\nlong lcm(long n, long p, long q)\
    \ \n{\n\treturn n * p / modp(n, p) * q / modp(q, p);\n}\n/* \n    Find the least\
    \ common multiple of n and p.\n    >>> lcm(5L, 10L)\n    10L\n    >>> lcm(101L,\
    \ 10L)\n    10L\n    >>> lcm(0L, 10L)\n    0L\n    >>> lcm(100L, 101L)\n    100L\n\
    \    \n*/\nlong lcm(long n, long p, long q, long r) \n{\n\treturn n * p / modp(n,\
    \ p) * q / modp(q, p) * r / modp(r, q);\n}\n/* \n    Find the least common multiple\
    \ of n and p.\n    >>> lcm(5L, 10L)\n    10L\n    >>> lcm(101L, 10L)\n    10L\n\
    \    >>> lcm(0L, 10L)\n    0L\n    >>> lcm(100L, 101L)\n    100L\n    \n*/\nlong\
    \ lcm(long n, long p, long q, long r, long s) \n{\n\treturn n * p / modp(n, p)\
    \ * q / modp(q, p) * r / modp\nunittest\n{\n    alias candidate = modp;\n\n  \
    \  assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmgpqjhxn.d(105): Error: found \''unittest\'' when expecting
    \'';\'' following return statement\n/tmp/tmpmgpqjhxn.d(117): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpmgpqjhxn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res;\n\tlong\
    \ mask = ~((long) p);\n\tn &= mask;\n\t\n\tif (n & 1) {\n\t\tn = (n - 1) ^ mask;\n\
    \t} else {\n\t\tn = (n - 1);\n\t}\n\t\n\tres = (n << 31) | (n >> 31);\n\treturn\
    \ res;\n}\n/*\nReturn the floor of n modulo p.\n    >>> floorp(3L, 5L)\n    3L\n\
    \    >>> floorp(1101L, 101L)\n    1L\n    >>> floorp(0L, 101L)\n    0L\n    >>>\
    \ floorp(3L, 11L)\n    3L\n    >>> floorp(100L, 101L)\n    0L\n    \n*/\nlong\
    \ floorp(long n, long p)\n{\n\tlong mask = (~((long) p));\n\tn &= mask;\n\t\n\t\
    if (n & 1) {\n\t\tn = (n - 1) ^ mask;\n\t} else {\n\t\tn = (n - 1);\n\t}\n\t\n\
    \treturn n;\n}\n/*\nReturn the ceiling of n modulo p.\n    >>> ceilingp(3L, 5L)\n\
    \    5L\n    >>> ceilingp(1101L, 101L)\n    1L\n    >>> ceilingp(0L, 101L)\n \
    \   1L\n    >>> ceilingp(3L, 11L)\n    3L\n    >>> ceilingp(100L, 101L)\n    1L\n\
    \    \n*/\nlong ceilingp(long n, long p)\n{\n\tlong mask = (~((long) p));\n\t\
    n &= mask;\n\t\n\tif (!(n & 1)) {\n\t\tn = (n - 1) ^ mask;\n\t} else {\n\t\tn\
    \ = (n - 1);\n\t}\n\t\n\treturn n;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6g_68em6.d(20): Error: C style cast illegal, use cast(long)p\n/tmp/tmp6g_68em6.d(48):
    Error: C style cast illegal, use cast(long)p\n/tmp/tmp6g_68em6.d(75): Error: C
    style cast illegal, use cast(long)p\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp6g_68em6.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int res = 1L;\n\
    \    while (n-- != 0) {\n        res = (2*res) % p;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpobvlfq4x.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n == 0) return\
    \ 0;\n\tif(n == 1) return 1;\n\tif(p == 0) return n;\n\treturn p%n+modp(n-1, p);\n\
    }\n/*\n>>> mod(1L, 5L)\n5L\n>>> mod(1101L, 101L)\n1L\n>>> mod(0L, 101L)\n0L\n\
    >>> mod(3L, 11L)\n3L\n>>> mod(100L, 101L)\n0L\n>>> mod(1L, 5L)\n5L\n*/\nlong mod(long\
    \ n, long p) \n{\n\tif(n == 0) return 0;\n\tif(n == 1) return n;\n\tif(p == 0)\
    \ return n;\n\tif(p == 1) return 1;\n\tif(p == 2) return n-1;\n\treturn p%n+mod(n-1,\
    \ p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps8gvh1bz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1660015487
