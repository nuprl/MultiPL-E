language: d
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q;\n\tif (p ==\
    \ 0)\n\t\treturn 1;\n\tfor (q = 0; q < n; q++)\n\t\tif (p & 1)\n\t\t\tp = p /\
    \ 2 ^ q;\n\t\telse\n\t\t\tp = p / 2 ^ q + 1;\n\treturn p;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpy8kgg2fh.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e25]

    ??:? void tmpy8kgg2fh.__unittest_L29_C1() [0x427ad3]

    ??:? void tmpy8kgg2fh.__modtest() [0x427ba8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb4b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9de]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb71]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430020]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fafd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9b5]

    ??:? runModuleUnitTests [0x42b921]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428274]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q, r;\n\t\n\t\
    /* compute n^r and r mod p */\n\tq = modl(n, p);\n\tr = modl(q, p);\n\t\n\t/*\
    \ compute r^2 mod p */\n\tq = modl(r, p);\n\t\n\t/* compute r^3 mod p */\n\tq\
    \ = modl(q, p);\n\t\n\t/* compute r^4 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute\
    \ r^5 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^6 mod p */\n\tq = modl(q,\
    \ p);\n\t\n\t/* compute r^7 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^8\
    \ mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^9 mod p */\n\tq = modl(q, p);\n\
    \t\n\t/* compute r^10 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^11 mod p\
    \ */\n\tq = modl(q, p);\n\t\n\t/* compute r^12 mod p */\n\tq = modl(q, p);\n\t\
    \n\t/* compute r^13 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^14 mod p */\n\
    \tq = modl(q, p);\n\t\n\t/* compute r^15 mod p */\n\tq = modl(q, p);\n\t\n\t/*\
    \ compute r^16 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^17 mod p */\n\t\
    q = modl(q, p);\n\t\n\t/* compute r^18 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute\
    \ r^19 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^20 mod p */\n\tq = modl(q,\
    \ p);\n\t\n\t/* compute r^21 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^22\
    \ mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^23 mod p */\n\tq = modl(q, p);\n\
    \t\n\t/* compute r^24 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^25 mod p\
    \ */\n\tq = modl(q, p);\n\t\n\t/* compute r^26 mod p */\n\tq = modl(q, p);\n\t\
    \n\t/* compute r^27 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^28 mod p */\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcpv3kh97.d(104): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcpv3kh97.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong ppow = pow(p,n);\n\
    \tlong res = (n^ppow) % p;\n\tif (res == 0 && p != 1 && ppow != 1) {\n\t\t//assert(res!=0)\n\
    \t\tint diff = res%p;\n\t\tlong a = ppow - diff;\n\t\tlong b = ppow - diff;\n\t\
    \tlong c = ppow - diff;\n\t\tlong d = ppow - diff;\n\t\tlong ppowa = pow(p,a);\n\
    \t\tlong ppowa = pow(p,b);\n\t\tlong ppowb = pow(p,c);\n\t\tlong ppowc = pow(p,d);\n\
    \t\tlong ppowd = pow(p,n%p);\n\t\tres = (n^(a*ppowa+b*ppowa+c*ppowb+d*ppowc+n%p*ppowd))\
    \ % p;\n\t}\n\treturn res;\n}\n'''\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk4ce7if1.d(37): Error: unterminated character constant

    /tmp/tmpk4ce7if1.d(37): Error: declaration expected, not `63U`

    /tmp/tmpk4ce7if1.d(37): Error: unterminated character constant

    /tmp/tmpk4ce7if1.d(42): Error: declaration expected, not `assert`

    /tmp/tmpk4ce7if1.d(43): Error: declaration expected, not `assert`

    /tmp/tmpk4ce7if1.d(44): Error: declaration expected, not `assert`

    /tmp/tmpk4ce7if1.d(45): Error: declaration expected, not `assert`

    /tmp/tmpk4ce7if1.d(46): Error: declaration expected, not `assert`

    /tmp/tmpk4ce7if1.d(47): Error: declaration expected, not `assert`

    /tmp/tmpk4ce7if1.d(48): Error: declaration expected, not `assert`

    /tmp/tmpk4ce7if1.d(49): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk4ce7if1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0L)\n \
    \       return n; // 0^0 = 1\n    \n    // Handle special cases\n    if (p ==\
    \ 0L)\n        return 1;\n    if (p == -1L)\n        return n;\n    \n    // Test\
    \ for common case\n    if (n == p)\n        return n;\n    \n    // Test for power\
    \ of 2\n    if (p & (p - 1))\n        return modpow2n(n, p);\n    \n    // Compute\
    \ result = 1L - n\n    long res = 1L - n;\n    \n    // Test for a power of 2\
    \ larger than the modulus\n    if (p & p)\n        res = modpow2n(n, p);\n   \
    \ \n    return res;\n}\n/*\nReturn n^p modulo p (be aware of numerics).\n    >>>\
    \ modpow2(3L, 5L)\n    3L\n    >>> modpow2(1101L, 101L)\n    2L\n    >>> modpow2(0L,\
    \ 101L)\n    1L\n    >>> modpow2(3L, 11L)\n    8L\n    >>> modpow2(100L, 101L)\n\
    \    1L\n    \n*/\nlong modpow2(long n, long p) \n{\n    if (n == 0L)\n      \
    \  return n; // 0^0 = 1\n    \n    // Handle special cases\n    if (p == 0L)\n\
    \        return n;\n    if (p == -1L)\n        return 1;\n    \n    // Test for\
    \ common case\n    if (n == p)\n        return n;\n    \n    // Test for power\
    \ of 2\n    if (p & (p - 1))\n        return modpow2n(n, p);\n    \n    // Compute\
    \ result = 1L - n\n    long res = 1L - n;\n    \n    // Test for a power of 2\
    \ larger than the modulus\n    if (p & p)\n        res = modpow2n(n, p);\n   \
    \ \n    return res;\n}\n/*\nReturn n^p modulo p (be aware of numerics).\n    >>>\
    \ modpow3(3L, 5L)\n    3L\n    >>> modpow3(1101L, 101L)\n    2L\n    >>> modpow3(0L,\
    \ 101L)\n    1L\n    >>> modpow3(3L, 11L)\n    8L\n    >>> modpow3(100L, 101L)\n\
    \    1L\n    \n*/\nlong modpow3(long n, long p) \n{\n    if (n == 0L)\n      \
    \  return n; // 0^0 = 1\n    \n    // Handle special cases\n    if (p == 0L)\n\
    \        return n;\n    if (p == -1L)\n        return 1;\n    \n    // Test for\
    \ common case\n    if (n == p)\n        return n;\n    \n    // Test for power\
    \ of 2\n    if (p & (p - 1))\n        return modpow2n(n, \nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx9t9k2xm.d(119): Error: expression expected, not `unittest`

    /tmp/tmpx9t9k2xm.d(120): Error: found `{` when expecting `,`

    /tmp/tmpx9t9k2xm.d(121): Error: expression expected, not `alias`

    /tmp/tmpx9t9k2xm.d(121): Error: found `candidate` when expecting `,`

    /tmp/tmpx9t9k2xm.d(121): Error: expression expected, not `=`

    /tmp/tmpx9t9k2xm.d(121): Error: found `modp` when expecting `,`

    /tmp/tmpx9t9k2xm.d(121): Error: expression expected, not `;`

    /tmp/tmpx9t9k2xm.d(123): Error: found `assert` when expecting `,`

    /tmp/tmpx9t9k2xm.d(123): Error: found `;` when expecting `,`

    /tmp/tmpx9t9k2xm.d(124): Error: found `;` when expecting `,`

    /tmp/tmpx9t9k2xm.d(125): Error: found `;` when expecting `,`

    /tmp/tmpx9t9k2xm.d(126): Error: found `;` when expecting `,`

    /tmp/tmpx9t9k2xm.d(127): Error: found `;` when expecting `,`

    /tmp/tmpx9t9k2xm.d(128): Error: found `;` when expecting `,`

    /tmp/tmpx9t9k2xm.d(129): Error: found `;` when expecting `,`

    /tmp/tmpx9t9k2xm.d(130): Error: expression expected, not `}`

    /tmp/tmpx9t9k2xm.d(13'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d, d;\n\td =\
    \ n % p;\n\tif (d == 0) return n;\n\tif (d > 0) return n % p;\n\treturn (n % p\
    \ + p) % p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb4639te2.d(19): Error: declaration `tmpb4639te2.modp.d` is already
    defined

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb4639te2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x, y, z;\n\t\
    long xmodp, ymodp;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvjtmsxxb.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvjtmsxxb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n < 0) \n\t{\n\
    \t\tif (p<0) return 0L; \n\t\telse return -p; \n\t}\n\t\n\tif (p==0) return 1L;\n\
    \t\n\tlong r = n;\n\t\n\twhile (r%p != 0) \n\t{ \n\t\tr = r*10L + n%p; \n\t\t\
    n = (n-p)/10L; \n\t}\n\treturn r%p;\n}\n/*\nReturn the next multiple of p greater\
    \ than n.\n    >>> nextp(0L, 101L)\n    101L\n    >>> nextp(101L, 101L)\n    101L\n\
    \    \n*/\nlong nextp(long n, long p) \n{\n\tif (n < 0) return 0L;\n\t\n\tif (p==0)\
    \ return 0L;\n\t\n\tlong r = n;\n\t\n\twhile (r%p != 0) \n\t{ \n\t\tr = r*10L\
    \ + n%p; \n\t\tn = (n-p)/10L; \n\t}\n\t\n\treturn r%p;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp64az161p.d(64): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ef5]

    ??:? void tmp64az161p.__unittest_L60_C1() [0x427b79]

    ??:? void tmp64az161p.__modtest() [0x427c74]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bc1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aaae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300f0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fbcd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa85]

    ??:? runModuleUnitTests [0x42b9f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428344]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x, y;\n\tassert(n\
    \ > 0);\n\tassert(p > 0);\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7671t7ds.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7671t7ds.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x;\n\tint i;\n\
    \tint sign;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb5w8t_i7.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5w8t_i7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    for(; n > 0; --n) {\n        result *= p;\n        if(result < 0L) result\
    \ += p;\n        result %= p;\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp27se_tad.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ded]

    ??:? void tmp27se_tad.__unittest_L27_C1() [0x427a75]

    ??:? void tmp27se_tad.__modtest() [0x427b70]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a97d]

    ??:? runModuleUnitTests [0x42b8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42823c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 0) \n\t{\n\
    \t\treturn n;\n\t}\n\tif (p == 1) \n\t{\n\t\treturn n;\n\t}\n\tlong result = n\
    \ & (-p);\n\tlong x = 0;\n\tdo\n\t{\n\t\tx = x + result;\n\t\tresult = result<<1;\n\
    \t\tresult = result + p;\n\t} while (result > n);\n\t\n\treturn result;\n}\n/******************************************************************************/\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0qbv0cvd.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e15]

    ??:? void tmp0qbv0cvd.__unittest_L39_C1() [0x427a99]

    ??:? void tmp0qbv0cvd.__modtest() [0x427b94]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430010]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9a5]

    ??:? runModuleUnitTests [0x42b911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x, q, res;\n\
    \    x = n % p;\n    if (x < p-1)\n       return 0;\n    else if (x == 0)\n  \
    \     return x;\n    else\n       q = modp(x / p, p);\n    res = x - p * q;\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp6pzdl_0m.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e15]

    ??:? void tmp6pzdl_0m.__unittest_L30_C1() [0x427a99]

    ??:? void tmp6pzdl_0m.__modtest() [0x427b94]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430010]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9a5]

    ??:? runModuleUnitTests [0x42b911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn (long)((long)n\
    \ % (long)p) * 2 - p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx12d9w7s.d(19): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmpx12d9w7s.d(19): Error: C style cast illegal, use `cast(long)p`

    /tmp/tmpx12d9w7s.d(19): Error: C style cast illegal, use `cast(long)(cast(long)n
    % cast(long)p)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx12d9w7s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong rem = 0;\n\t\
    long temp;\n\tif(n>p) \n\t{\n\t\twhile(n>p) \n\t\t{\n\t\t\trem += n;\n\t\t\tn\
    \ -= p;\n\t\t}\n\t\ttemp = n;\n\t\tn = p;\n\t\tp = rem;\n\t\trem = temp;\n\t}\n\
    \treturn rem%p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppg46yw3m.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmppg46yw3m.__unittest_L35_C1() [0x427a85]

    ??:? void tmppg46yw3m.__modtest() [0x427b80]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int i;\n    long\
    \ res = n;\n    \n    for (i = 0; i < 64; i++) {\n        if (res >= p) {\n  \
    \          res--;\n            res *= p;\n            res %= p;\n        }\n \
    \   }\n    return res;\n}\n#endif\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaswyq067.d(31): Error: declaration expected, not `#`

    /tmp/tmpaswyq067.d(36): Error: declaration expected, not `assert`

    /tmp/tmpaswyq067.d(37): Error: declaration expected, not `assert`

    /tmp/tmpaswyq067.d(38): Error: declaration expected, not `assert`

    /tmp/tmpaswyq067.d(39): Error: declaration expected, not `assert`

    /tmp/tmpaswyq067.d(40): Error: declaration expected, not `assert`

    /tmp/tmpaswyq067.d(41): Error: declaration expected, not `assert`

    /tmp/tmpaswyq067.d(42): Error: declaration expected, not `assert`

    /tmp/tmpaswyq067.d(43): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaswyq067.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n==0)\n\t\treturn\
    \ 0L;\n\tif(n<0)\n\t\treturn n*modp(-n, p);\n\tif(p>n)\n\t\treturn 0L;\n\tlong\
    \ mod=1;\n\tlong ret=1;\n\twhile(p>=p)\n\t{\n\t\tif(p&1)\n\t\t{\n\t\t\tmod=(n%mod)^mod;\n\
    \t\t\tret*=mod;\n\t\t}\n\t\tn/=p;\n\t\tif(n==0)\n\t\t\treturn ret;\n\t}\n\treturn\
    \ ret*mod;\n}\n/*\nReturn x^y modulo p (be aware of numerics).\n    >>> modpow(3L,\
    \ 5L, 5L)\n    3L\n    >>> modpow(1101L, 101L, 101L)\n    2L\n    >>> modpow(3L,\
    \ 11L, 101L)\n    8L\n    >>> modpow(100L, 101L, 101L)\n    1L\n    \n*/\nlong\
    \ modpow(long x, long y, long p) \n{\n\tif(x==0 || y==0 || p==0)\n\t\treturn 0L;\n\
    \tif(p>y)\n\t\treturn modpow(x, y/2, p);\n\tif(p>x)\n\t\treturn modpow(x, y-1,\
    \ p);\n\tlong mod=1;\n\tlong ret=1;\n\tlong q=modpow(x-y, y, p);\n\twhile(q>p)\n\
    \t{\n\t\tq/=p;\n\t\tmod=(mod*q)%p;\n\t\tret*=mod;\n\t}\n\twhile(q>1)\n\t{\n\t\t\
    mod=(mod*q)%p;\n\t\tret*=mod;\n\t\tq/=p;\n\t}\n\treturn ret;\n}\n/*\nReturn x\
    \ // y without remainder (be aware of numerics).\n    >>> modinc(4L, 5L)\n   \
    \ 3L\n    >>> modinc(1101L, 101L)\n    101L\n    >>> modinc(0L, 101L)\n    1L\n\
    \    >>> modinc(3L, 11L)\n    3L\n    >>> modinc(100L, 101L)\n    1L\n    \n*/\n\
    long modinc(long x, long y) \n{\n\tif(x==0 || y==0)\n\t\treturn 0L;\n\tif(x>y)\n\
    \t\treturn modinc(x-y, y);\n\tif(y==1)\n\t\treturn x;\n\treturn x%y;\n}\n/*\n\
    Return x // y with remainder (be aware of numerics).\n    >>> modi(1101L, 101L)\n\
    \    1L\n    >>> modi(0L, 101L)\n    1L\n    >>> modi(3L, \nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphkuz8fhv.d(101): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphkuz8fhv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x, y;\n   \
    \ \n    x = n;\n    y = p;\n    while (x > y) {\n        x -= y;\n        y +=\
    \ y;\n    }\n    while (y == 1) {\n        y *= 2;\n        x--;\n    }\n    if\
    \ (x < y) {\n        x -= y;\n    }\n    return x;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpygxx101t.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmpygxx101t.__unittest_L36_C1() [0x427a81]

    ??:? void tmpygxx101t.__modtest() [0x427b7c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n == 0 || p ==\
    \ 0) return 0;\n\tif (n < p) return (n & ((long)p-1));\n\treturn (n - n%p);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgy5nkysx.d(20): Error: C style cast illegal, use `cast(long)p`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgy5nkysx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = n;\n\
    \    while ((result = result % p) != 0) {\n        n -= 1;\n        if (n == 0L)\
    \ {\n            return result;\n        }\n    }\n    return n;\n}\n/*\nReturn\
    \ a vector with first m elements equal to x, rest equal to y (modulo p (be aware\
    \ of numerics)).\n    >>> modvec(1L, 101L, 3L)\n    [0, 3, 1]\n    \n*/\nvector<long>\
    \ modvec(long x, long y, long m) \n{\n    vector<long> result;\n    for (long\
    \ i = 0; i <= m; i++) {\n        result[i - 1] = modp(x + (i - 1) * y, p);\n \
    \   }\n    return result;\n}\n/*\nReturn a vector with first m elements equal\
    \ to x, rest equal to y (modulo p (be aware of numerics)).\n    >>> modvec(1L,\
    \ 101L, 3L)\n    [0, 3, 1]\n    \n*/\nvector<long> modvec(long x, long y, long\
    \ p, long m) \n{\n    vector<long> result = modvec(x, p, m);\n    result.insert(result.end(),\
    \ y, y); // add y to the end\n    return result;\n}\n/*\nReturn an inverted modulo\
    \ p (be aware of numerics).\n    >>> modinv(2L, 5L)\n    2L\n    >>> modinv(1101L,\
    \ 101L)\n    1L\n    >>> modinv(0L, 101L)\n    0L\n    >>> modinv(3L, 11L)\n \
    \   2L\n    >>> modinv(100L, 101L)\n    1L\n    \n*/\nlong modinv(long n, long\
    \ p) \n{\n    long result = n;\n    while (n != 0L) {\n        result -= n % p;\n\
    \        n /= p;\n    }\n    return result;\n}\n/*\nReturn a vector with first\
    \ m elements equal to x, rest equal to y (modulo p (be aware of numerics)).\n\
    \    >>> modinvvec(1L, 101L, 3L)\n    [0, 1, 3]\n    \n*/\nvector<long> modinvvec(long\
    \ x, long y, long m) \n{\n    vector<long> result;\n    for (long i = 0; i <=\
    \ m; i++) {\n        result[i - 1] = modinv(x + (i - 1) * y, p);\n    }\n    return\
    \ result;\n}\n/*\nReturn a vector with first m elements equal to x, rest equal\
    \ to y (modulo p (be aware of numerics)).\n    >>> modinvvec(1L, 101L, 3L)\n \
    \   [0, 1, 3]\n    \n*/\nvector<long> modinvvec(long x, long y, long p, long m)\
    \ \n{\n    vector<long> result = modinvvec(x, \nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgna7g54v.d(34): Error: no identifier for declarator `vector`

    /tmp/tmpgna7g54v.d(34): Error: declaration expected, not `<`

    /tmp/tmpgna7g54v.d(37): Error: declaration expected, not `for`

    /tmp/tmpgna7g54v.d(37): Error: no identifier for declarator `i`

    /tmp/tmpgna7g54v.d(37): Error: declaration expected, not `<=`

    /tmp/tmpgna7g54v.d(37): Error: no identifier for declarator `i`

    /tmp/tmpgna7g54v.d(37): Error: declaration expected, not `++`

    /tmp/tmpgna7g54v.d(39): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgna7g54v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong m = (long)(long)\
    \ (p);\n\tif (n < m)\n\t\treturn 0;\n\treturn m - (long) (pow(2, n) - 1);\n}\n\
    */\n/** Return 2^n modulo p (be aware of numerics).\n * \n * The algorithm is\
    \ based on:\n *\n * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n\
    \ * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n\
    \ * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n */\nlong\
    \ modp_d(long n, long p) \n{\n\tlong m = p;\n\tif (n < m)\n\t\treturn 0;\n\treturn\
    \ m - (long) (pow(2, n) - 1);\n}\n/** Return the smallest number d such that 2^d\
    \ <= p < 2^(n+d). */\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6tr42ksj.d(19): Error: C style cast illegal, use `cast(long)p`

    /tmp/tmp6tr42ksj.d(19): Error: C style cast illegal, use `cast(long)cast(long)p`

    /tmp/tmp6tr42ksj.d(22): Error: C style cast illegal, use `cast(long)(pow(2, n)
    - 1)`

    /tmp/tmp6tr42ksj.d(24): Error: declaration expected, not `*`

    /tmp/tmp6tr42ksj.d(37): Error: declaration expected, not `if`

    /tmp/tmp6tr42ksj.d(39): Error: declaration expected, not `return`

    /tmp/tmp6tr42ksj.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6tr42ksj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n==0) {return 1;}\n\
    \tif(n<0) {n=-n;} \n\tif(p<0) {p=-p;}\n\tif(p>n) {\n\t\tn = p + p - 1;\n\t}\n\t\
    if(p==0) {return 1;}\n\tif(n==p) {return 0;}\n\treturn n % p;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqxr87itz.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e2d]

    ??:? void tmpqxr87itz.__unittest_L29_C1() [0x427ab5]

    ??:? void tmpqxr87itz.__modtest() [0x427bb0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9e6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb79]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430028]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb05]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9bd]

    ??:? runModuleUnitTests [0x42b929]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42827c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn n - modpow(Long.bitCount(n),\
    \ p, Long.SIZE);\n}\n/**\n * Return n modulo p.\n * \n * This is faster than modp(n,p).\n\
    \ */\nlong modn (long n, long p) \n{\n\tlong res = n;\n\twhile (p > res)\n\t\t\
    res -= p;\n\treturn res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfo5fp835.d(19): Error: undefined identifier `modpow`, did you mean
    function `modp`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfo5fp835.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = p % n;\n\
    \    return (r != 0L) ? r : n + r;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/\nlong modp64(long n, long p)\n{\n    long r = p % n;\n    return\
    \ (r != 0L) ? r : n + r;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/\nlong mod64(long n, long p)\n{\n    long r = p % n;\n    return\
    \ (r != 0L) ? r : n + r;\n}\n/*\nReturn a double rounded to n digits.\n    >>>\
    \ modd(10L, 100L)\n    10.0\n    >>> modd(10L, 100L, 'F')\n    10.0\n    >>> modd(10L,\
    \ 100L, 'E')\n    10.0\n    >>> modd(10L, 100L, 'D')\n    10.0\n    \n*/\ndouble\
    \ modd(long n, long p, char c)\n{\n    double r = double(modp64(n, p));\n    if\
    \ (c == 'E' || c == 'D')\n        return r;\n    else if (c == 'F')\n        return\
    \ double(std.round(r));\n    else\n        return r;\n}\n/*\nReturn a double rounded\
    \ to n digits.\n    >>> modd(10L, 100L)\n    10.0\n    >>> modd(10L, 100L, 'F')\n\
    \    10.0\n    >>> modd(10L, 100L, 'E')\n    10.0\n    >>> modd(10L, 100L, 'D')\n\
    \    10.0\n    \n*/\ndouble modd64(long n, long p, char c)\n{\n    double r =\
    \ double(mod64(n, p));\n    if (c == 'E' || c == 'D')\n        return r;\n   \
    \ else if (c == 'F')\n        return double(std.round(r));\n    else\n       \
    \ return r;\n}\n/*\nReturn the sum ((a + b) + c) = ((a mod p) + (b mod p)) + c.\n\
    \    >>> modsum(10\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm6clf30w.d(104): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm6clf30w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n < p) \n\t\t\
    return 0;\n\tlong p = 1;\n\tlong q = n - p;\n\tlong r = 1;\n\twhile (r < q) \n\
    \t{\n\t\tr = p * q;\n\t\tp++;\n\t\tq--;\n\t}\n\treturn p - n;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6c85rinz.d(21): Error: variable `p` is shadowing variable `tmp6c85rinz.modp.p`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6c85rinz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x;\n\tx = n %\
    \ p;\n\tif (x < 0)\n\t{\n\t\tx += p;\n\t}\n\telse\n\t{\n\t\tx = x - p;\n\t}\n\t\
    return x;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpt89eqizk.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dd5]

    ??:? void tmpt89eqizk.__unittest_L31_C1() [0x427a5d]

    ??:? void tmpt89eqizk.__modtest() [0x427b58]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bafb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a98e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a965]

    ??:? runModuleUnitTests [0x42b8d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428224]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long t;\n    if(p\
    \ == 0)\n        return 0;\n    \n    if(n == 0)\n        return 1;\n    \n  \
    \  if(p > n)\n        p = n;\n    \n    t = (p - 1L) % p;\n    \n    if(n == t)\n\
    \        return t;\n    \n    return n - t;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp68nbmhq8.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e1d]

    ??:? void tmp68nbmhq8.__unittest_L36_C1() [0x427aa1]

    ??:? void tmp68nbmhq8.__modtest() [0x427b9c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb43]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9d6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb69]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430018]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faf5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9ad]

    ??:? runModuleUnitTests [0x42b919]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42826c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1;\n\
    \    while (n > 0) {\n        if ((n % p) == 0) {\n            n = n / p;\n  \
    \          res = (res * res * res + 2) % p;\n        }\n        else {\n     \
    \       n = (n * res + 2) % p;\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ 2^n modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>>\
    \ modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nunsigned long modpu(unsigned\
    \ long n, unsigned long p) \n{\n    unsigned long res = 1;\n    while (n > 0)\
    \ {\n        if ((n % p) == 0) {\n            n = n / p;\n            res = (res\
    \ * res * res + 2) % p;\n        }\n        else {\n            n = (n * res +\
    \ 2) % p;\n        }\n    }\n    return res;\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong long modpll(long long n, long long p) \n{\n  \
    \  long long res = 1;\n    while (n > 0) {\n        if ((n % p) == 0) {\n    \
    \        n = n / p;\n            res = (res * res * res + 2) % p;\n        }\n\
    \        else {\n            n = (n * res + 2) % p;\n        }\n    }\n    return\
    \ res;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n\
    \    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n \
    \   >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nunsigned\
    \ long long modpul(unsigned long long n, unsigned long long p) \n{\n    unsigned\
    \ long long res = 1;\n    while (n > 0) {\n        if ((n % p) == 0) {\n     \
    \       n = n / p;\n            res = (res * res * res + 2) % p;\n        }\n\
    \        else {\n            n = (n * res + 2) % p;\n        }\n    }\n    return\
    \ res;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvuwjd_19.d(45): Error: no identifier for declarator `unsigned`

    /tmp/tmpvuwjd_19.d(45): Error: found `long` when expecting `)`

    /tmp/tmpvuwjd_19.d(45): Error: semicolon expected following function declaration

    /tmp/tmpvuwjd_19.d(45): Error: no identifier for declarator `n`

    /tmp/tmpvuwjd_19.d(45): Error: declaration expected, not `,`

    /tmp/tmpvuwjd_19.d(48): Error: declaration expected, not `while`

    /tmp/tmpvuwjd_19.d(51): Error: no identifier for declarator `res`

    /tmp/tmpvuwjd_19.d(51): Error: declaration expected, not `=`

    /tmp/tmpvuwjd_19.d(52): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvuwjd_19.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while (p) {\n        if ((n % p) != 0) {\n            result *= n;\n    \
    \        result %= p;\n        }\n        n /= p;\n    }\n    return (n == 0)\
    \ ? result : 1L;\n}\n/*\nReturn 2^n modulo p.\n    >>> modp(3L, 5L)\n    3L\n\
    \    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n*/\nlong modp2l(long n, long\
    \ p)\n{\n    long res = 1L;\n    while (p) {\n        if ((n % p) != 0) {\n  \
    \          res*=n;\n            res %= p;\n        }\n        n /= p;\n    }\n\
    \    return (n == 0) ? res : 1L;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164505
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res;\n\tlong\
    \ k;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp171ahw2l.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp171ahw2l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long rem = n % p;\n\
    \    long q = n - rem;\n    if (q < 0) return q + p;\n    if (rem == 0)\n    \
    \    return p;\n    if (rem > 0)\n        return modp(q, p) + p;\n    return modp(q,\
    \ p);\n}\n/*\n>>> modp_p2(5L, 3L)\n(2, 3L)\n>>> modp_p2(5L, 6L)\n(1, 5L)\n>>>\
    \ modp_p2(5L, 8L)\n(1, 3L)\n>>> modp_p2(5L, 2L)\n(5, 3L)\n>>> modp_p2(5L, 101L)\n\
    (5, 3L)\n>>> modp_p2(-5L, 3L)\n(-5, 3L)\n>>> modp_p2(-5L, 6L)\n(-4, 5L)\n>>> modp_p2(-5L,\
    \ 8L)\n(-4, 3L)\n>>> modp_p2(-5L, 2L)\n(-5, 3L)\n>>> modp_p2(-5L, 101L)\n(-5,\
    \ 3L)\n>>> modp_p2(-5L, 101L)\n(-5, 3L)\n>>> modp_p2(111L, 101L)\n(11, 10L)\n\
    >>> modp_p2(111L, 101L)\n(11, 10L)\n>>> modp_p2(111L, 101L)\n(11, 10L)\n*/\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpyt16h0ri.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmpyt16h0ri.__unittest_L58_C1() [0x427a85]

    ??:? void tmpyt16h0ri.__modtest() [0x427b80]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tn = n % p;\n\tif (n\
    \ < p)\n\t\treturn n % p;\n\treturn ((p * n) % (p * 2)) % p;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjayzal5m.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ded]

    ??:? void tmpjayzal5m.__unittest_L24_C1() [0x427a9b]

    ??:? void tmpjayzal5m.__modtest() [0x427b70]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a97d]

    ??:? runModuleUnitTests [0x42b8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42823c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res = 1;\n\t\
    while(n>0) {\n\t\tres = (res*10)%p; \n\t\tn = (n-1)/10;\n\t}\n\treturn res;\n\
    }\n/*\nTest if a number is prime\nReturn True if a is prime else False\n*/\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5ki3w78y.d(34): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ded]

    ??:? void tmp5ki3w78y.__unittest_L30_C1() [0x427a71]

    ??:? void tmp5ki3w78y.__modtest() [0x427b6c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a97d]

    ??:? runModuleUnitTests [0x42b8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42823c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x;\n    int\
    \ r;\n    if (p > 1) // trivial case\n    {\n        return 1;\n    }\n    else\
    \ if (p == 1) // n==1\n    {\n        return n;\n    }\n    else if (p == 0) //\
    \ n==0\n    {\n        return 0;\n    }\n    // otherwise calculate r = n % p\
    \ (i.e. return r mod p)\n    x = n % p;\n    if (x >= p) // n is larger, modulo\
    \ p \n    {\n        x -= p;\n    }\n    r = x;\n    while (r > 0 && r != p) //\
    \ while r divides p\n    {\n        r--;\n        x -= p;\n    }\n    return r*p\
    \ + (n-x);\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nThe following algorithm is\
    \ based on a modified Euclid's algorithm to calculate the modular inverse of a\
    \ number. The algorithm is based on this question and its answers. \n<code>\n\
    function modinv(x, mod) {\n  let m = mod(x, mod);\n  while (x !== 1) {\n    m\
    \ = mod(m, mod);\n    x = (x * m) % (mod - 1);\n  }\n  return m;\n}\n</code>\n\
    The mod function is a function that returns the modulus of a number and the modinv\
    \ function calculates the modular inverse of a number. \n<code>\nfunction mod(x,\
    \ modulus) {\n  return x - ((x * modulus) % modulus);\n}\n</code>\nIn your code\
    \ you are trying to divide a number by 1 but this operation is not possible. The\
    \ first step would be to perform the modulo operation on the first and second\
    \ number of the array. After you do that you can subtract the two arrays and find\
    \ the modular inverse of the new array which you would then multiply by the second\
    \ number. This should give you the modular inverse of the array.\n<|/ a tags=modulus,math,modular-arithmetic,c++\
    \ dscore=1 |>\n<| a |>\nThis solution is a little simpler than the other answers\
    \ but I think it performs more efficient as it does not use division or modulus\
    \ but instead uses bit operations to calculate the inverse:\n<code>\nlong modinv(long\
    \ x, long mod) {\n    long r = 0, q;\n    long m = 1;\n    while (x > 0) {\n \
    \       q = x >> 31;\n        r = q | (r << 1);\n        m = m << 1 | (m >> 31);\n\
    \        x &= ~(q << 31);\n    }\n    q = m << 1;\n    r = r ^ (r >> 31);\n  \
    \  return q | (r << 1);\n}\n</code>\n<|/ a tags=modulus,math,modular-arithmetic,c++\
    \ dscore=1 |>\n<|\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy7gq_alq.d(47): Error: declaration expected, not `<`

    /tmp/tmpy7gq_alq.d(50): Error: unterminated character constant

    /tmp/tmpy7gq_alq.d(54): Error: declaration expected, not `while`

    /tmp/tmpy7gq_alq.d(56): Error: no identifier for declarator `x`

    /tmp/tmpy7gq_alq.d(56): Error: declaration expected, not `=`

    /tmp/tmpy7gq_alq.d(57): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy7gq_alq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n == 0)\n\t\treturn\
    \ n;\n\tif(p == 1)\n\t\treturn n;\n\tif(p == 0)\n\t\treturn 1;\n\tif(n == p)\n\
    \t\treturn n;\n\tif(n == p - 1)\n\t\treturn mod((1L << p), p) ^ 1;\n\tif(n ==\
    \ p - 2)\n\t\treturn mod((1L << p), p) ^ 2;\n\tif(n == p - 4)\n\t\treturn mod((1L\
    \ << p), p) ^ 4;\n\tif(n == p - 8)\n\t\treturn mod((1L << p), p) ^ 8;\n\tif(n\
    \ == p - 16)\n\t\treturn mod((1L << p), p) ^ 16;\n\tif(n == p - 32)\n\t\treturn\
    \ mod((1L << p), p) ^ 32;\n\tif(n == p - 64)\n\t\treturn mod((1L << p), p) ^ 64;\n\
    \tif(n == p - 128)\n\t\treturn mod((1L << p), p) ^ 128;\n\tif(n == p - 256)\n\t\
    \treturn mod((1L << p), p) ^ 256;\n\tif(n == p - 512)\n\t\treturn mod((1L << p),\
    \ p) ^ 512;\n\tif(n == p - 1024)\n\t\treturn mod((1L << p), p) ^ 1024;\n\tif(n\
    \ == p - 2048)\n\t\treturn mod((1L << p), p) ^ 2048;\n\tif(n == p - 4096)\n\t\t\
    return mod((1L << p), p) ^ 4096;\n\tif(n == p - 8192)\n\t\treturn mod((1L << p),\
    \ p) ^ 8192;\n\treturn n;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/\nulong modp(ulong n, ulong p)\n{\n\tif(n == 0)\n\t\treturn n;\n\
    \tif(p == 1)\n\t\treturn n;\n\tif(p == 0)\n\t\treturn 1;\n\tif(n == p)\n\t\treturn\
    \ n;\n\tif(n == p - 1)\n\t\treturn mod((1UL << p), p) ^ 1;\n\tif(n == p - 2)\n\
    \t\treturn mod((1UL << p), p) ^ 2;\n\tif(n == p - 4)\n\t\treturn mod((1\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp8b5br6r.d(86): Error: found `unittest` when expecting `)`

    /tmp/tmpp8b5br6r.d(88): Error: found `{` when expecting `,`

    /tmp/tmpp8b5br6r.d(89): Error: expression expected, not `alias`

    /tmp/tmpp8b5br6r.d(89): Error: found `candidate` when expecting `,`

    /tmp/tmpp8b5br6r.d(89): Error: expression expected, not `=`

    /tmp/tmpp8b5br6r.d(89): Error: found `modp` when expecting `,`

    /tmp/tmpp8b5br6r.d(89): Error: expression expected, not `;`

    /tmp/tmpp8b5br6r.d(91): Error: found `assert` when expecting `,`

    /tmp/tmpp8b5br6r.d(91): Error: found `;` when expecting `,`

    /tmp/tmpp8b5br6r.d(92): Error: found `;` when expecting `,`

    /tmp/tmpp8b5br6r.d(93): Error: found `;` when expecting `,`

    /tmp/tmpp8b5br6r.d(94): Error: found `;` when expecting `,`

    /tmp/tmpp8b5br6r.d(95): Error: found `;` when expecting `,`

    /tmp/tmpp8b5br6r.d(96): Error: found `;` when expecting `,`

    /tmp/tmpp8b5br6r.d(97): Error: found `;` when expecting `,`

    /tmp/tmpp8b5br6r.d(98): Error: expression expected, not `}`

    /tmp/tmpp8b5br6r.d(99): Error: found '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res = 1L;\n\t\
    if (n == 0) return 0L;\n\tif (n & -p == 0) return 0L;\n\twhile (n > 0) {\n\t\t\
    res = (res<<1) + n%p;\n\t\tn = n/p;\n\t}\n\treturn res;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl8lbq58d.d(21): Error: `-p == 0` must be parenthesized when next
    to operator `&`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl8lbq58d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n >= p)\n  \
    \  {\n        return (p + n) % p;\n    }\n    else\n    {\n        return (n +\
    \ p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n    \n \
    \   >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n    >>> modp2l(1L,\
    \ 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n    if (n >= p)\n\
    \    {\n        return (p + n) % p;\n    }\n    else\n    {\n        return (n\
    \ + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n    \n\
    \    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n    >>>\
    \ modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n    if\
    \ (n >= p)\n    {\n        return (p + n) % p;\n    }\n    else\n    {\n     \
    \   return (n + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    \n    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n \
    \   >>> modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n\
    \    if (n >= p)\n    {\n        return (p + n) % p;\n    }\n    else\n    {\n\
    \        return (n + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    \n    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n \
    \   >>> modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n\
    \    if (n >= p)\n    {\n        return (p + n) % p;\n    }\n    else\n    {\n\
    \        return (n + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    \n    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n \
    \   >>> modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8hqci9l_.d(130): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8hqci9l_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong rem = 0;\n\t\
    while ( n > 0 ) \n\t{\n\t\trem = ( rem << 1 ) | n % 2;\n\t\tn /= 2;\n\t}\n\twhile\
    \ ( p > 0 )\n\t{\n\t\trem = ( rem << 1 ) | ( rem & p );\n\t\tp >>= 1;\n\t}\n\t\
    return rem;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbmedk795.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e1d]

    ??:? void tmpbmedk795.__unittest_L32_C1() [0x427aa1]

    ??:? void tmpbmedk795.__modtest() [0x427b9c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb43]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9d6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb69]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430018]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faf5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9ad]

    ??:? runModuleUnitTests [0x42b919]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42826c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res = 1;\n\t\
    for(int i = 0; i < n; ++i) {\n\t\tif (res == p || res == (p % 2)) res = (res *\
    \ res + 2) % p;\n\t\telse res = (res + n % p) % p;\n\t}\n\treturn res;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi_o8508_.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e1d]

    ??:? void tmpi_o8508_.__unittest_L26_C1() [0x427acb]

    ??:? void tmpi_o8508_.__modtest() [0x427ba0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb43]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9d6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb69]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430018]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faf5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9ad]

    ??:? runModuleUnitTests [0x42b919]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42826c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long a = 1;\n  \
    \  long b = 2;\n    while (b < p)\n    {\n        if (b & 1)\n        {\n    \
    \        a += b;\n        }\n        b *= 2;\n    }\n    return a % p;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpw1oqlhce.d(35): unittest failure

    ----------------

    ??:? _d_unittestp [0x427de5]

    ??:? void tmpw1oqlhce.__unittest_L31_C1() [0x427a6d]

    ??:? void tmpw1oqlhce.__modtest() [0x427b68]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fabd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a975]

    ??:? runModuleUnitTests [0x42b8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn bitwise_or(\n\
    \t\tshift(bitwise_and(n,1L),bitwise_and(p,1L)),\n\t\tbitwise_and(bitwise_and(n,1L),p)\n\
    \t\t);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt93hd6fr.d(19): Error: undefined identifier `bitwise_or`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt93hd6fr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long d = 1;\n  \
    \  while ((d * p) != n)\n        d = (d*2) + 1;\n    return (n - d - 1) / p;\n\
    }\n/*\nReturn the first number bigger than x (be aware of numerics).\n    >>>\
    \ pow2(0L)\n    0L\n    >>> pow2(1L)\n    1L\n    >>> pow2(2L)\n    2L\n    >>>\
    \ pow2(3L)\n    8L\n    >>> pow2(3L)\n    8L\n    >>> pow2(4L)\n    16L\n    >>>\
    \ pow2(4L)\n    16L\n    \n*/\nlong pow2(long x)\n{\n    long y, t, m = 0;\n \
    \   for (y = 0; y < x; y++)\n\tm = modp(m, 2L);\n    for (y = 0; y < x; y++)\n\
    \tt = modp(2 * y, m) + 1;\n    return t;\n}\n/*\nReturn the factorial of n, modulo\
    \ p (be aware of numerics).\n    >>> fact(1L)\n    1L\n    >>> fact(2L)\n    2L\n\
    \    >>> fact(3L)\n    6L\n    >>> fact(3L)\n    6L\n    >>> fact(4L)\n    24L\n\
    \    >>> fact(4L)\n    24L\n    \n*/\nlong fact(long n)\n{\n    long t, x = 0;\n\
    \    while (n-- > 0)\n\tx = x * 2L;\n    return x;\n}\n/*\nReturn the number of\
    \ trailing zeros.\n    >>> trailingzeros(0L)\n    0L\n    >>> trailingzeros(0L)\n\
    \    0L\n    >>> trailingzeros(1L)\n    1L\n    >>> trailingzeros(1L)\n    1L\n\
    \    >>> trailingzeros(101L)\n    2L\n    >>> trailingzeros(101L)\n    2L\n  \
    \  >>> trailingzeros(11L)\n    4L\n    >>> trailingzeros(11L)\n    4L\n    \n\
    */\nlong trailingzeros(long n)\n{\n    long x;\n    x = n - 1;\n    while (n >\
    \ 0)\n\tif (n%10L == 0L)\n\t    x = x -1;\n\tn = (n-1)/10L;\n\treturn x;\n}\n\
    /*\nReturn the sum of all the digits of n (be aware of numerics).\n    >>> digitsSum(33L)\n\
    \    9L\n    >>> digitsSum(33L)\n    9L\n    >>> digitsSum(1101L)\n    12L\n \
    \   >>> digitsSum(1101L)\n    12L\n    \n*/\nlong digitsSum(long n)\n{\n    long\
    \ t;\n    for (t = 0; n < 10; n = n * 10\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7a0c6hak.d(120): Error: found `unittest` when expecting `)`

    /tmp/tmp7a0c6hak.d(132): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7a0c6hak.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int a = (int)n,\
    \ m = 0;\n    int t = p + 1;\n    int c = 1;\n    \n    while (c <= t && a) {\n\
    \        c <<= 1;\n        m++;\n        a <<= 1;\n    }\n    \n    m += p - ((p\
    \ > 0) ? c : ~c) + 1;\n    \n    if (m == 0) {\n        return n;\n    }\n   \
    \ \n    return n % m;\n}\n'''\n    \ndef mod2(x):\n    \n    '''\n    \n    Implementation\
    \ of the mod2 function (returns the modulo 2^n with n being a non-negative integer).\
    \ \n    \n    Parameters:\n    \n    x: a non-negative integer\n    \n    Returns:\n\
    \    \n    modulo 2^n\n    \n    Example:\n    \n    >>> mod2(5)\n    3\n    \n\
    \    '''\n    \n    count = 0\n    mod = 1\n    \n    while x > 0:\n        count\
    \ = count + 1\n        mod = mod << 1\n        if count == 2:\n            mod\
    \ = mod + 1\n            count = 0\n        x = x >> 1\n    return mod\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9sxa4wve.d(19): Error: C style cast illegal, use `cast(int)n`

    /tmp/tmp9sxa4wve.d(37): Error: unterminated character constant

    /tmp/tmp9sxa4wve.d(37): Error: declaration expected, not `63U`

    /tmp/tmp9sxa4wve.d(37): Error: unterminated character constant

    /tmp/tmp9sxa4wve.d(41): Error: unterminated character constant

    /tmp/tmp9sxa4wve.d(41): Error: unterminated character constant

    /tmp/tmp9sxa4wve.d(58): Error: unterminated character constant

    /tmp/tmp9sxa4wve.d(58): Error: unterminated character constant

    /tmp/tmp9sxa4wve.d(75): Error: declaration expected, not `assert`

    /tmp/tmp9sxa4wve.d(76): Error: declaration expected, not `assert`

    /tmp/tmp9sxa4wve.d(77): Error: declaration expected, not `assert`

    /tmp/tmp9sxa4wve.d(78): Error: declaration expected, not `assert`

    /tmp/tmp9sxa4wve.d(79): Error: declaration expected, not `assert`

    /tmp/tmp9sxa4wve.d(80): Error: declaration expected, not `assert`

    /tmp/tmp9sxa4wve.d(81): Error: declaration expected, not `assert`

    /tmp/tmp9sxa4wve.d(82): Error: unrecognized declara'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r, s;\n\tr =\
    \ n - p*log2(p);\n\ts = n-r*log2(r);\n\ts = modpow2(s, p, r);\n\treturn r + s;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt5c80qll.d(20): Error: cannot implicitly convert expression `cast(real)n
    - cast(real)p * log2(cast(real)p)` of type `real` to `long`

    /tmp/tmpt5c80qll.d(21): Error: cannot implicitly convert expression `cast(real)n
    - cast(real)r * log2(cast(real)r)` of type `real` to `long`

    /tmp/tmpt5c80qll.d(22): Error: undefined identifier `modpow2`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt5c80qll.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x= n;\n   \
    \ long y= p;\n    long z= 1L;\n    \n    while (x > y) \n    {\n        x = x\
    \ / y;\n        y = y % y;\n        z = z * y % p;\n    }\n    \n    return z;\n\
    }\n// end module modp\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis works great!\
    \ Thank you! I have upvoted the answer, but I don't have the reputation yet to\
    \ make it public.\n<|/ c |>\n<| c |>\nI did vote on it yesterday by accident,\
    \ it's now up there.\n<|/ c |>\n<| c |>\nI made it public now.\n<|/ c |>\n<| c\
    \ |>\nYou do know [that you can accept answers](http://meta.stackexchange.com/a/5235)?\n\
    <|/ c |>\n<| c |>\nI didn't know you could do that. Thanks for the tip!\n<|/ c\
    \ |>\n<| a tags=python,bit-manipulation,mod,binary,c dscore=1 |>\nAs others have\
    \ mentioned, a lookup table will probably be your best bet in C. Here's an example\
    \ of a lookup table in C:\n<code>\ntypedef unsigned char byte;\ntypedef unsigned\
    \ long long ull;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvu8mazuk.d(33): Error: declaration expected, not `<`

    /tmp/tmpvu8mazuk.d(36): Error: unterminated character constant

    /tmp/tmpvu8mazuk.d(39): Error: unterminated character constant

    /tmp/tmpvu8mazuk.d(48): Error: unterminated character constant

    /tmp/tmpvu8mazuk.d(51): Error: unterminated character constant

    /tmp/tmpvu8mazuk.d(54): Error: semicolon expected, not `long`

    /tmp/tmpvu8mazuk.d(54): Error: use `long` for a 64 bit integer instead of `long
    long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvu8mazuk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn (long)math::pow2p(n,\
    \ p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3x9i_2aa.d(19): Error: C style cast illegal, use `cast(long)math`

    /tmp/tmp3x9i_2aa.d(19): Error: found `:` when expecting `;` following `return`
    statement

    /tmp/tmp3x9i_2aa.d(19): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3x9i_2aa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  if (n >= p)\n    return\
    \ n - p;\n  else\n    return p + mod((n - p), p);\n}\n#endif\n/*\nReturn n^a mod\
    \ p, where p is prime. \n    >>> modp(7, 2L)\n    3L\n    >>> modp(8, 2L)\n  \
    \  2L\n    >>> modp(8, 3L)\n    1L\n*/\nlong modpow(long a, long p, long mod)\n\
    {\n  long res = 1L;\n  for (long d = 0L; d <= p; d += 2L) {\n    res = (res *\
    \ a) % mod;\n    res = ((res * res) % mod) %  mod;\n  }\n  return res;\n}\n/*\n\
    Return log(a) mod p.\n    >>> modp(3, 5L)\n    3L\n*/\nlong modln_mod(long a,\
    \ long p)\n{\n  long res = 1L;\n  long x = 1L;\n  while (x * p < a) {\n    if\
    \ (a % p == 0) {\n      int r = a / p;\n      res = (res * r) % p;\n    }\n  \
    \  x += (p - 1L) / p;\n  }\n  return res;\n}\n/*\nReturn 2^n modulo p where n\
    \ is prime and p is odd. \n    >>> modp(15L, 5L)\n    2L\n    >>> modp(8L, 7L)\n\
    \    3L\n*/\nlong modp2(long n, long p)\n{\n  long res = 1L;\n  long x = 1L;\n\
    \  long y = 1L;\n  while (x * p < n) {\n    if (n % p == 0) {\n      int r = n\
    \ / p;\n      res = (res * r) % p;\n    }\n    x += (p - 1L) / p;\n    y += (p\
    \ - 1L) / p;\n  }\n  return res;\n}\n/*\nReturn 2^n modulo p where n is odd and\
    \ p is odd. \n    >>> modp(3L, 5L)\n    2L\n    >>> modp(9L, 7L)\n    3L\n*/\n\
    long modp2o(long n, long p)\n{\n  long res = 1L;\n  long x = 1L;\n  long y = 1L;\n\
    \  while (x * p < n) {\n    if (n % p == 0) {\n      int r = n / p;\n      res\
    \ = (res * r) % p;\n    }\n    x += (p - 1L) / p;\n    y += (p - 1L) / p;\n  }\n\
    \  return res;\n}\n/*\nReturn n^a mod p, where p is prime. \n    >>> modp(\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp65_3mgnw.d(24): Error: declaration expected, not `#`

    /tmp/tmp65_3mgnw.d(37): Error: declaration expected, not `for`

    /tmp/tmp65_3mgnw.d(37): Error: no identifier for declarator `d`

    /tmp/tmp65_3mgnw.d(37): Error: declaration expected, not `<=`

    /tmp/tmp65_3mgnw.d(37): Error: no identifier for declarator `d`

    /tmp/tmp65_3mgnw.d(37): Error: declaration expected, not `+=`

    /tmp/tmp65_3mgnw.d(39): Error: no identifier for declarator `res`

    /tmp/tmp65_3mgnw.d(39): Error: declaration expected, not `=`

    /tmp/tmp65_3mgnw.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp65_3mgnw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long x = 0;\n  while\
    \ ( n < p ) \n  {\n    n <<= 1;\n    x <<= 1;\n  }\n  x &= (p - 1L);\n  n &= (p\
    \ - 1);\n  x ^= n;\n  n ^= x;\n  x ^= n;\n  n ^= x;\n  return n;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfhgxangj.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e05]

    ??:? void tmpfhgxangj.__unittest_L33_C1() [0x427a89]

    ??:? void tmpfhgxangj.__modtest() [0x427b84]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb2b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9be]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb51]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430000]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fadd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a995]

    ??:? runModuleUnitTests [0x42b901]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428254]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint i;\n\tlong r =\
    \ 1L;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppucvkta_.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppucvkta_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long p2 = modpow(p,2,n);\n\
    \    return n%p2; \n}\n/*\nReturn n modulo p in O(logn) time.\n    NOTE: n must\
    \ be positive.\n    NOTE: if n is negative, result is undefined.\n    >>> modpow(0L,\
    \ 0L, 0L)\n    0L\n    >>> modpow(0L, 0L, 1L)\n    1L\n    >>> modpow(0L, 1L,\
    \ 0L)\n    1L\n    >>> modpow(0L, 1L, 1L)\n    0L\n    >>> modpow(1L, 0L, 1L)\n\
    \    0L\n    >>> modpow(1L, 1L, 0L)\n    1L\n    >>> modpow(1L, 1L, 1L)\n    1L\n\
    \    \n    \n    >>> modpow(-3L, 3L, 3L)\n    0L\n    >>> modpow(-3L, 3L, 4L)\n\
    \    0L\n    >>> modpow(-3L, 4L, 3L)\n    1L\n    >>> modpow(-3L, 4L, 4L)\n  \
    \  1L\n    >>> modpow(-5L, 3L, 3L)\n    1L\n    >>> modpow(-5L, 3L, 4L)\n    2L\n\
    \    >>> modpow(-5L, 4L, 3L)\n    2L\n    >>> modpow(-5L, 4L, 4L)\n    3L\n  \
    \  \n*/\nlong modpow(long n, long p, long modulo) \n{\n    long p2 = modpow(p,2,n);\n\
    \    long q2 = modpow(p2,2,modulo);\n    long r2 = n%p2;\n    return p2+(modulo*q2%modulo)-r2;\
    \ \n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164505
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1;\n\
    \    if (n % 2 == 0) \n    {\n        res = (res << 1) % p;\n        n /= 2;\n\
    \    } \n    while (n != 0)\n    {\n        if (n % 2 == 1)\n        {\n     \
    \       res = (res * (p / 2)) % p;\n            n /= 2;\n        } \n        else\n\
    \        {\n            res = (res) % p;\n            n /= 2;\n        }\n   \
    \ }\n    return res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqjebaqaa.d(44): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e65]

    ??:? void tmpqjebaqaa.__unittest_L40_C1() [0x427aed]

    ??:? void tmpqjebaqaa.__modtest() [0x427be8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb8b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa1e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbb1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430060]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb3d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9f5]

    ??:? runModuleUnitTests [0x42b961]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282b4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong tmp;\n\ttmp =\
    \ n % p;\n\tif (tmp == 0) \n\t\treturn n;\n\telse\n\t\treturn (p * pow(2,(long)(n\
    \ - tmp)) % p); \n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphbx7z7bq.d(24): Error: C style cast illegal, use `cast(long)(n
    - tmp)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphbx7z7bq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n < 0)\n\t\tn\
    \ = -n;\n\tif (p < 0)\n\t\tp = -p;\n\t\n\tlong r = 1;\n\twhile (n) {\n\t\tif (n\
    \ % 2 == 0)\n\t\t\tr = (r << 1) + 1;\n\t\tn = n / 2;\n\t}\n\twhile (p) {\n\t\t\
    if (p % 2 == 0)\n\t\t\tr = (r << 1) + 1;\n\t\tp = p / 2;\n\t}\n\treturn r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm7bedq62.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e5d]

    ??:? void tmpm7bedq62.__unittest_L37_C1() [0x427b07]

    ??:? void tmpm7bedq62.__modtest() [0x427bdc]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430058]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9ed]

    ??:? runModuleUnitTests [0x42b959]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  int r;\n  long r =\
    \ n % p;\n  if (r != 0) \n    r = p - r;\n  return r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_rbmgfkt.d(20): Error: declaration `tmp_rbmgfkt.modp.r` is already
    defined

    /tmp/tmp_rbmgfkt.d(22): Error: cannot implicitly convert expression `p - cast(long)r`
    of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_rbmgfkt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\t/*\n\t   0\n\t 8\n\
    \t17\n\t22\n\t27\n\t32\n\t37\n\t42\n\t47\n\t52\n\t57\n\t62\n\t67\n\t72\n\t77\n\
    \t82\n\t87\n\t92\n\t97\n\t102\n\t107\n\t112\n\t117\n\t122\n\t127\n\t132\n\t137\n\
    \t142\n\t147\n\t152\n\t157\n\t162\n\t167\n\t172\n\t177\n\t182\n\t187\n\t192\n\t\
    197\n\t202\n\t207\n\t212\n\t217\n\t222\n\t227\n\t232\n\t237\n\t242\n\t247\n\t\
    252\n\t257\n\t262\n\t267\n\t272\n\t277\n\t282\n\t287\n\t292\n\t297\n\t302\n\t\
    307\n\t312\n\t317\n\t322\n\t327\n\t332\n\t337\n\t342\n\t347\n\t352\n\t357\n\t\
    362\n\t367\n\t372\n\t377\n\t382\n\t387\n\t392\n\t397\n\t402\n\t407\n\t412\n\t\
    417\n\t422\n\t427\n\t432\n\t437\n\t442\n\t457\n\t462 \n\t*/\n\t\n\tif (n < p)\
    \ {\n\t\treturn 0;\n\t}\n\t\n\tif (n == p) return 1;\n\tif (n == (p-1U)) {\n\t\
    \treturn p;\n\t}\n\t\n\tlong d = 1;\n\t\n\twhile (d < p) {\n\t\td *= 2;\n\t}\n\
    \t\n\twhile ((n % d) != 0) {\n\t\td *= 2;\n\t\tn++;\n\t}\n\t\n\treturn (n-d);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpo6q84xa7.d(138): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e05]

    ??:? void tmpo6q84xa7.__unittest_L134_C1() [0x427a8d]

    ??:? void tmpo6q84xa7.__modtest() [0x427b88]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb2b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9be]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb51]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430000]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fadd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a995]

    ??:? runModuleUnitTests [0x42b901]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428254]

    ??:? void rt.dmain2._d'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long ret = 1;\n\
    \    for (; n > 0; n /= p)\n        ret *= p;\n    ret %= p;\n    if (n < p) \n\
    \        ret += p;\n    return ret;\n}\n</code>\n<|/ a tags=math,algorithm,modulus,integer,language-agnostic\
    \ |>\n<| c |>\nHow does this answer the question? It doesn't seem to address any\
    \ specific questions about modulus. I'm also not sure that `modp(11L, 101L)` is\
    \ supposed to produce `8L`. It should produce `5L`.\n<|/ c |>\n<| c |>\n: Yes,\
    \ you are right.  It produces 5L.  I fixed that and added an explanation.  Thanks.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe code in the question does not really implement\
    \ modular exponentiation at all. It merely does a bit-wise xor-operation on the\
    \ two numbers, then does an exponentiation by squaring them. \nThe bit-wise xor\
    \ operation is probably not the best idea in this case, since it only works for\
    \ unsigned integers.\n<|/ a tags=math,algorithm,modulus,integer,language-agnostic\
    \ |>\n<| c |>\nThis doesn't really answer the question. I don't see how this explains\
    \ how to implement modular exponentiation.\n<|/ c |>\n<| c |>\n- yes, it does.\
    \  I suggest reading up on modular exponentiation and studying the code in that\
    \ answer.\n<|/ c |>\n<| c |>\nYou only need to implement modular exponentiation\
    \ when it is known that the two exponents are not a power of two. Of course, you\
    \ could just use the modulus operator as in the code in the question, but this\
    \ would work for any exponent.\n<|/ c |>\n<| a dscore=0 |>\nJust implement the\
    \ modular exponentiation.\n<code>\n#include <iostream>\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzn1juy9i.d(27): Error: declaration expected, not `<`

    /tmp/tmpzn1juy9i.d(30): Error: unterminated character constant

    /tmp/tmpzn1juy9i.d(30): Error: unterminated character constant

    /tmp/tmpzn1juy9i.d(40): Error: unterminated character constant

    /tmp/tmpzn1juy9i.d(40): Error: unterminated character constant

    /tmp/tmpzn1juy9i.d(56): Error: declaration expected, not `assert`

    /tmp/tmpzn1juy9i.d(57): Error: declaration expected, not `assert`

    /tmp/tmpzn1juy9i.d(58): Error: declaration expected, not `assert`

    /tmp/tmpzn1juy9i.d(59): Error: declaration expected, not `assert`

    /tmp/tmpzn1juy9i.d(60): Error: declaration expected, not `assert`

    /tmp/tmpzn1juy9i.d(61): Error: declaration expected, not `assert`

    /tmp/tmpzn1juy9i.d(62): Error: declaration expected, not `assert`

    /tmp/tmpzn1juy9i.d(63): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzn1juy9i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d = n - 1L;\n\
    \t\n\twhile ((d & 1) != 0 && d != 1L) \n\t{\n\t\td >>= 1;\n\t\tn--;\n\t}\n\t\n\
    \td = 1L << n;\n\td -= p;\n\t\n\tif (d == 0L)\n\t{\n\t\treturn 1L;\n\t}\n\telse\n\
    \t{\n\t\treturn d;\n\t}\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprgekv2dg.d(58): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmprgekv2dg.__unittest_L53_C1() [0x427aa3]

    ??:? void tmprgekv2dg.__modtest() [0x427b78]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n   long r, t;\n   t\
    \ = ((r=(long)p)%(long)n);\n   if ((t >= 0) && ((long)(r+n) < p)) {\n      r =\
    \ (long)r;\n   } \n   return r;\n}\n'''\n    \nclass Power:\n    '''\n    The\
    \ power class, used to represent a power with two operands\n    '''\n    def __init__(self,\
    \ base=0, exp=0):\n        self.base = base\n        self.exp = exp\n    def __str__(self):\n\
    \        return '{}^{}'.format(self.base, self.exp)\n    def __repr__(self):\n\
    \        return 'Power({}, {})'.format(self.base, self.exp)\n    def __rpow__(self,\
    \ pow):\n        if isinstance(pow, Power):\n            return Power(pow.base,\
    \ pow.exp * pow.base)\n        return Power(pow, self.exp)\n    def __add__(self,\
    \ other):\n        if isinstance(other, Power):\n            base = (self.base\
    \ * other.base) % mod\n            exp = (self.exp + other.exp) % mod\n      \
    \      return Power(base, exp)\n        if isinstance(other, int) or isinstance(other,\
    \ long):\n            base = (self.base * other) % mod\n            exp = (self.exp\
    \ + other) % mod\n            return Power(base, exp)\n        raise TypeError('unsupported\
    \ operand type(s) for +: Power and {}'.format(type(other)))\n    def __sub__(self,\
    \ other):\n        if isinstance(other, Power):\n            base = (self.base\
    \ * other.base) % mod\n            exp = (self.exp + other.exp) % mod\n      \
    \      return Power(base, exp)\n        if isinstance(other, int) or isinstance(other,\
    \ long):\n            base = (self.base - other) % mod\n            exp = (self.exp\
    \ - other) % mod\n            return Power(base, exp)\n        raise TypeError('unsupported\
    \ operand type(s) for +: Power and {}'.format(type(other)))\n    def __mul__(self,\
    \ other):\n        if isinstance(other, Power):\n            base = (self.base\
    \ * other.base) % mod\n            exp = (self.exp * other.exp) % mod\n      \
    \      return Power(base, exp)\n        if isinstance(other, int) or isinstance(other,\
    \ long):\n            base = (self.base * other) % mod\n            exp = (self.exp\
    \ * other) % mod\n            return Power(base, exp)\n        raise TypeError('unsupported\
    \ operand type(s) for +: Power and {}'.format(type(other)))\n    def __div__(self,\
    \ other):\n        if isinstance(other, Power):\n            base = (self.base\
    \ % other.base) / other.base\n            exp = (self.exp % other.exp) / other.exp\n\
    \            return Power(base, exp)\n        if isinstance(other, int) or isinstance(other,\
    \ long):\n            base = (self.base % other) / other\n            exp = (self.exp\
    \ % other) / other\n            return Power(base, exp)\n        raise TypeError('unsupported\
    \ operand type(s) for +: Power and {}'.format(type(other)))\n    def __rdiv__(self,\
    \ other):\n        if isinstance(other, Power):\n            base = other.base\
    \ * self.base\n            exp = other.exp * self.exp\n            return Power(base,\
    \ exp)\n        if isinstance(other, int) or isinstance(other, long):\n      \
    \      \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpidrttdkj.d(20): Error: C style cast illegal, use `cast(long)p`

    /tmp/tmpidrttdkj.d(20): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmpidrttdkj.d(21): Error: C style cast illegal, use `cast(long)(r + n)`

    /tmp/tmpidrttdkj.d(22): Error: C style cast illegal, use `cast(long)r`

    /tmp/tmpidrttdkj.d(26): Error: unterminated character constant

    /tmp/tmpidrttdkj.d(26): Error: declaration expected, not `63U`

    /tmp/tmpidrttdkj.d(26): Error: unterminated character constant

    /tmp/tmpidrttdkj.d(29): Error: unterminated character constant

    /tmp/tmpidrttdkj.d(29): Error: unterminated character constant

    /tmp/tmpidrttdkj.d(31): Error: unterminated character constant

    /tmp/tmpidrttdkj.d(31): Error: unterminated character constant

    /tmp/tmpidrttdkj.d(36): Error: unterminated character constant

    /tmp/tmpidrttdkj.d(36): Error: unterminated character constant

    /tmp/tmpidrttdkj.d(38): Error: unterminated character constant

    /tmp/tmpidrttdkj.d(38): Error: unterminated character constant

    /tmp/tmpidrttdkj.d(52): Error: unterminat'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return 1L ^ (n &\
    \ -p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpxox8tdl4.d(25): unittest failure

    ----------------

    ??:? _d_unittestp [0x427db5]

    ??:? void tmpxox8tdl4.__unittest_L21_C1() [0x427a3d]

    ??:? void tmpxox8tdl4.__modtest() [0x427b38]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a945]

    ??:? runModuleUnitTests [0x42b8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong result = 1L;\n\
    \t\n\twhile(n > p)\n\t{\n\t\tif(n > p) n--;\n\t\tresult = (result << 1) | n;\n\
    \t}\n\t\n\twhile(n < p)\n\t{\n\t\tresult <<= 1;\n\t\tif(n == p)\n\t\t\treturn\
    \ result;\n\t\tn++;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpic5og5b6.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e0d]

    ??:? void tmpic5og5b6.__unittest_L37_C1() [0x427a95]

    ??:? void tmpic5og5b6.__modtest() [0x427b90]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb59]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430008]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fae5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a99d]

    ??:? runModuleUnitTests [0x42b909]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42825c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x;\n    long\
    \ mod;\n    x = modinv(p, n);\n    mod = (x & 1) ? (p ^ x) : x;\n    return (n\
    \ ^ mod);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5srr8jnd.d(21): Error: undefined identifier `modinv`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5srr8jnd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int bits = (int)p;\n\
    \    long r = 1;\n    long m = 0;\n    while (n > 0) {\n\tif (n & 1) {\n\t   \
    \ m = r * p;\n\t    r = std.math.remainder(m, p);\n\t}\n\tbits = bits - 1;\n\t\
    n = n >> 1;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjw85mwcj.d(19): Error: C style cast illegal, use `cast(int)p`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjw85mwcj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n == 0)\n\t\treturn\
    \ 0;\n\tif(p == 0)\n\t\treturn n;\n\treturn std.__modpow(n, std.__sub(p, 1L),\
    \ p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpal_91q5c.d(23): Error: undefined identifier `__modpow` in package
    `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpal_91q5c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  int i, k = 1;\n  for\
    \ (i = 0; i < (int) sizeof(ulong) * CHAR_BIT; i = i + 1) {\n    if (p == 1)\n\
    \      return n;\n    if (p & 1) {\n      n = n << 1;\n      k++;\n    }\n   \
    \ if (k & 1)\n      n = n ^ ((ulong) n >> (ulong) i);\n    p = p >> 1;\n    k++;\n\
    \  }\n  return n;\n}\n'''\n</cell>\n<cell>\n# Cell\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpre6c9787.d(20): Error: found `)` when expecting `.` following ulong

    /tmp/tmpre6c9787.d(20): Error: found `*` when expecting identifier following `ulong`.

    /tmp/tmpre6c9787.d(20): Error: found `CHAR_BIT` when expecting `,`

    /tmp/tmpre6c9787.d(20): Error: expression expected, not `;`

    /tmp/tmpre6c9787.d(20): Error: found `i` when expecting `,`

    /tmp/tmpre6c9787.d(20): Error: expression expected, not `=`

    /tmp/tmpre6c9787.d(20): Error: found `i` when expecting `,`

    /tmp/tmpre6c9787.d(20): Error: C style cast illegal, use `cast(int)sizeof(0, 0,
    0, +1)`

    /tmp/tmpre6c9787.d(20): Error: found `{` when expecting `;` following `for` condition

    /tmp/tmpre6c9787.d(21): Error: expression expected, not `if`

    /tmp/tmpre6c9787.d(22): Error: found `return` when expecting `)`

    /tmp/tmpre6c9787.d(28): Error: C style cast illegal, use `cast(ulong)n`

    /tmp/tmpre6c9787.d(28): Error: C style cast illegal, use `cast(ulong)i`

    /tmp/tmpre6c9787.d(32): Error: declaration expected, not `return`

    /tmp/tmpre6c9787.d(33): Error: unrecognized d'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong tmp;\n\tif (p==0)\n\
    \t\treturn n;\n\ttmp = (n & (p-1));\n\tif (tmp==n)\n\t\treturn p;\n\treturn (tmp+1)|p|modp((tmp&n)|p|p-1,\
    \ p);\n}\n\t\n//@version=52 nov. 2009\n//@qpy:none\nimport std.random;\nimport\
    \ std.time;\nimport std.datetime;\nimport std.random;\nimport std.range;\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptnuqbx9l.d(31): Error: module `time` is in file ''std/time.d''
    which cannot be read

    import path[0] = /tmp

    import path[1] = /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos

    import path[2] = /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptnuqbx9l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  return modpow(n, p,\
    \ p);\n}\n#endif\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpch1my8ev.d(21): Error: declaration expected, not `#`

    /tmp/tmpch1my8ev.d(26): Error: declaration expected, not `assert`

    /tmp/tmpch1my8ev.d(27): Error: declaration expected, not `assert`

    /tmp/tmpch1my8ev.d(28): Error: declaration expected, not `assert`

    /tmp/tmpch1my8ev.d(29): Error: declaration expected, not `assert`

    /tmp/tmpch1my8ev.d(30): Error: declaration expected, not `assert`

    /tmp/tmpch1my8ev.d(31): Error: declaration expected, not `assert`

    /tmp/tmpch1my8ev.d(32): Error: declaration expected, not `assert`

    /tmp/tmpch1my8ev.d(33): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpch1my8ev.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long d;\n    n =\
    \ (long)((n * p) % p);\n    d = (long)(n >> 5); \n    while (d > 0)\n    {\n \
    \       long tmp = (n%p); \n        n = (n-p);\n        d = (long)(tmp >> 5);\
    \ \n    }\n    return (n << 5) + d;\n}\n/*\nReturn 2^n (mod p).\n    >>> mod2(3L,\
    \ 5L)\n    3L\n    >>> mod2(1101L, 101L)\n    2L\n    >>> mod2(0L, 101L)\n   \
    \ 1L\n    >>> mod2(3L, 11L)\n    8L\n    >>> mod2(100L, 101L)\n    1L\n    \n\
    */\nlong mod2(long n, long p) \n{\n    long d;\n    n = (long)((n * p) % p);\n\
    \    d = (long)(n >> 5); \n    while (d > 0)\n    {\n        long tmp = (n%p);\
    \ \n        n = (n-p);\n        d = (long)(tmp >> 5); \n    }\n    return n;\n\
    }\n/*\nReturn 2^n mod p.\n    >>> mod2p(3L, 5L)\n    3L\n    >>> mod2p(1101L,\
    \ 101L)\n    2L\n    >>> mod2p(0L, 101L)\n    1L\n    >>> mod2p(3L, 11L)\n   \
    \ 8L\n    >>> mod2p(100L, 101L)\n    1L\n    \n*/\nlong mod2p(long n, long p)\
    \ \n{\n    long d;\n    n = (long)((n * p) % p);\n    d = (long)(n >> 5); \n \
    \   while (d > 0)\n    {\n        long tmp = (n%p); \n        n = (n-p);\n   \
    \     d = (long)(tmp >> 5); \n    }\n    return (n << 5) + d;\n}\n/*\nReturn 2^n\
    \ modulo p (be aware of numerics).\n    >>> mod2p(3L, 5L)\n    3L\n    >>> mod2p(1101L,\
    \ 101L)\n    2L\n    >>> mod2p(0L, 101L)\n    1L\n    >>> mod2p(3L, 11L)\n   \
    \ 8L\n    >>> mod2p(100L, 101L)\n    1L\n    \n*/\nlong mod2p(long n, long p)\
    \ \n{\n    long d;\n    n = (long)((n * p) % p);\n    d = (long)(n >> 5); \n \
    \   while (d > 0)\n    {\n        long tmp = (n%p); \n        n = (n-p);\n   \
    \     d = (long)(tmp >> 5); \n    }\n    return n;\n}\n/*\n\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsqe4n_za.d(20): Error: C style cast illegal, use `cast(long)(n
    * p % p)`

    /tmp/tmpsqe4n_za.d(21): Error: C style cast illegal, use `cast(long)(n >> 5)`

    /tmp/tmpsqe4n_za.d(26): Error: C style cast illegal, use `cast(long)(tmp >> 5)`

    /tmp/tmpsqe4n_za.d(47): Error: C style cast illegal, use `cast(long)(n * p % p)`

    /tmp/tmpsqe4n_za.d(48): Error: C style cast illegal, use `cast(long)(n >> 5)`

    /tmp/tmpsqe4n_za.d(53): Error: C style cast illegal, use `cast(long)(tmp >> 5)`

    /tmp/tmpsqe4n_za.d(74): Error: C style cast illegal, use `cast(long)(n * p % p)`

    /tmp/tmpsqe4n_za.d(75): Error: C style cast illegal, use `cast(long)(n >> 5)`

    /tmp/tmpsqe4n_za.d(80): Error: C style cast illegal, use `cast(long)(tmp >> 5)`

    /tmp/tmpsqe4n_za.d(101): Error: C style cast illegal, use `cast(long)(n * p %
    p)`

    /tmp/tmpsqe4n_za.d(102): Error: C style cast illegal, use `cast(long)(n >> 5)`

    /tmp/tmpsqe4n_za.d(107): Error: C style cast illegal, use `cast(long)(tmp >> 5)`

    /tmp/tmpsqe4n_za.d(111): Error: unterminated /* */ comment

    Failed'
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r = 1;\n\twhile\
    \ (n) {\n\t\tif (n % p)\n\t\t\tr = (r * 10) % p;\n\t\tn = (n * 10) % p;\n\t}\n\
    \treturn r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfm4aw3x1.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmpfm4aw3x1.__unittest_L27_C1() [0x427a7d]

    ??:? void tmpfm4aw3x1.__modtest() [0x427b78]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q, m;\n\t\n\t\
    if(n == 0) return 1;\n\tif(n == 1) return n;\n\t\n\tif(p == 1)\n\t{\n\t\treturn\
    \ n;\n\t}\n\t\n\tif(n == p)\n\t{\n\t\treturn 1;\n\t}\n\t\n\tq = modp(n/p, p);\n\
    \tm = n % p;\n\t\n\treturn q * p + m;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi0c7gzs4.d(43): unittest failure

    ----------------'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n > p) {\n \
    \       long ans = (n%p);\n        long t = (n%p) + p;\n        ans %= t;\n  \
    \      ans %= p;\n        return ans;\n    }\n    return n;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpjgbcs9us.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427de5]

    ??:? void tmpjgbcs9us.__unittest_L28_C1() [0x427a93]

    ??:? void tmpjgbcs9us.__modtest() [0x427b68]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fabd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a975]

    ??:? runModuleUnitTests [0x42b8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if(p < 0)\n    \
    \    p = 0;\n    if(n == 0)\n        return p;\n    if(p == 1)\n        return\
    \ n;\n    if(p == 2)\n        return n;\n    if(n % p == 0)\n        return modp(n\
    \ / p, p);\n    return modp(n % p, p);\n}\nlong pow2(long n, long p)\n{\n    long\
    \ res = 1;\n    long t = 1;\n    for(; p > 0; p >>= 1)\n    {\n        if(p&1)\n\
    \            res *= n;\n        n *= t;\n        t *= n;\n    }\n    return res;\n\
    }\n/*\nReturn n! modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n    3L\n\
    \    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nlong modp(long n,\
    \ long p)\n{\n    return modp(n, modp(modp(modp(modp(modp(modp(modp(modp(n, modp(modp(modp(modp(n,\
    \ modp(modp(modp(modp(n, modp(1)))))), modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(n)))))), modp(modp(modp(modp(modp(modp(modp(modp(1)))))))),\
    \ modp(modp(modp(modp(modp(modp(modp(n)))))), modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp36izz76d.d(61): Error: expression expected, not `unittest`

    /tmp/tmp36izz76d.d(62): Error: found `{` when expecting `,`

    /tmp/tmp36izz76d.d(63): Error: expression expected, not `alias`

    /tmp/tmp36izz76d.d(63): Error: found `candidate` when expecting `,`

    /tmp/tmp36izz76d.d(63): Error: expression expected, not `=`

    /tmp/tmp36izz76d.d(63): Error: found `modp` when expecting `,`

    /tmp/tmp36izz76d.d(63): Error: expression expected, not `;`

    /tmp/tmp36izz76d.d(65): Error: found `assert` when expecting `,`

    /tmp/tmp36izz76d.d(65): Error: found `;` when expecting `,`

    /tmp/tmp36izz76d.d(66): Error: found `;` when expecting `,`

    /tmp/tmp36izz76d.d(67): Error: found `;` when expecting `,`

    /tmp/tmp36izz76d.d(68): Error: found `;` when expecting `,`

    /tmp/tmp36izz76d.d(69): Error: found `;` when expecting `,`

    /tmp/tmp36izz76d.d(70): Error: found `;` when expecting `,`

    /tmp/tmp36izz76d.d(71): Error: found `;` when expecting `,`

    /tmp/tmp36izz76d.d(72): Error: expression expected, not `}`

    /tmp/tmp36izz76d.d(73): Error: found '
  stdout: ''
  timestamp: 1660164490
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return pow(2l, n-p,\
    \ p);\n}\n</code>\n<|/ a dscore=4 tags=java |>\n<| a dscore=4 |>\nHere's an example\
    \ of the code as of Java 8:\n<code>\nimport java.util.function.Function;\nimport\
    \ java.util.function.IntBinaryOperator;\nimport java.util.stream.IntStream;\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9003r8jm.d(19): Error: lower case integer suffix ''l'' is not allowed.
    Please use ''L'' instead

    /tmp/tmp9003r8jm.d(21): Error: declaration expected, not `<`

    /tmp/tmp9003r8jm.d(24): Error: unterminated character constant

    /tmp/tmp9003r8jm.d(27): Error: identifier expected following `package`

    /tmp/tmp9003r8jm.d(27): Error: `;` expected

    /tmp/tmp9003r8jm.d(27): Error: no identifier for declarator `.IntBinaryOperator`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9003r8jm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p != 0)\n\t{\n\
    \t\tlong m = (n >> p) & p;\n\t\treturn (n - (m << p)) % p;\n\t} \n\telse return\
    \ 0;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk089u32h.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dd5]

    ??:? void tmpk089u32h.__unittest_L26_C1() [0x427a7f]

    ??:? void tmpk089u32h.__modtest() [0x427b54]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bafb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a98e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a965]

    ??:? runModuleUnitTests [0x42b8d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428224]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  if(n < p) {\n    if(n\
    \ <= (long)((double)p - (double)(n))) return n;\n    return (n-p) % (p-1);\n \
    \ }\n  else return n-p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppk69oun8.d(20): Error: C style cast illegal, use `cast(double)p`

    /tmp/tmppk69oun8.d(20): Error: C style cast illegal, use `cast(double)n`

    /tmp/tmppk69oun8.d(20): Error: C style cast illegal, use `cast(long)(cast(double)p
    - cast(double)n)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppk69oun8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0 || p\
    \ == 0)\n        return 0;\n    long res = p%n;\n    if (res == 0)\n        return\
    \ n;\n    else if (res > 0)\n        return modp(res, p) + 1;\n    else\n    \
    \    return modp(res, n);\n}\n'''\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4eyxkqni.d(29): Error: unterminated character constant

    /tmp/tmp4eyxkqni.d(29): Error: declaration expected, not `63U`

    /tmp/tmp4eyxkqni.d(29): Error: unterminated character constant

    /tmp/tmp4eyxkqni.d(34): Error: declaration expected, not `assert`

    /tmp/tmp4eyxkqni.d(35): Error: declaration expected, not `assert`

    /tmp/tmp4eyxkqni.d(36): Error: declaration expected, not `assert`

    /tmp/tmp4eyxkqni.d(37): Error: declaration expected, not `assert`

    /tmp/tmp4eyxkqni.d(38): Error: declaration expected, not `assert`

    /tmp/tmp4eyxkqni.d(39): Error: declaration expected, not `assert`

    /tmp/tmp4eyxkqni.d(40): Error: declaration expected, not `assert`

    /tmp/tmp4eyxkqni.d(41): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4eyxkqni.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  if (p == 0) return\
    \ 1;\n  if (p == 1) return n;\n  if (p == 2) return 2L * n;\n  if (p == 6) return\
    \ (11L + 7L) * n - (7L * 11L);\n  if (p == 9) return (35L + 10L) * n - (10L *\
    \ 35L);\n  if (p == 12) return (755L + 21L) * n - (21L * 755L);\n  if (p == 15)\
    \ return (1110L + 54L) * n - (54L * 1110L);\n  if (p == 18) return (1066L + 104L)\
    \ * n - (104L * 1066L);\n  if (p == 23) return (1564L + 174L) * n - (174L * 1564L);\n\
    \  if (p == 28) return (1864L + 236L) * n - (236L * 1864L);\n  if (p == 33) return\
    \ (2066L + 272L) * n - (272L * 2066L);\n  if (p == 38) return (2196L + 296L) *\
    \ n - (296L * 2196L);\n  if (p == 43) return (2244L + 352L) * n - (352L * 2244L);\n\
    \  if (p == 48) return (2324L + 394L) * n - (394L * 2324L);\n  if (p == 53) return\
    \ (2468L + 444L) * n - (444L * 2468L);\n  if (p == 58) return (2556L + 512L) *\
    \ n - (512L * 2556L);\n  if (p == 63) return (2744L + 576L) * n - (576L * 2744L);\n\
    \  if (p == 68) return (2876L + 624L) * n - (624L * 2876L);\n  if (p == 75) return\
    \ (3056L + 648L) * n - (648L * 3056L);\n  if (p == 80) return (3216L + 704L) *\
    \ n - (704L * 3216L);\n  if (p == 87) return (3376L + 768L) * n - (768L * 3376L);\n\
    \  if (p == 94) return (3564L + 824L) * n - (824L * 3564L);\n  if (p == 101) return\
    \ (3680L + 896L) * n - (896L * 3680L);\n  if (p == 108) return (3802L + 944L)\
    \ * n - (944L\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0k0wvh3v.d(42): Error: found `unittest` when expecting `)`

    /tmp/tmp0k0wvh3v.d(44): Error: found `{` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0k0wvh3v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1L;\n\
    \    while ((n & p) != 0L) {\n        result *= 2L;\n        n /= p; \n    }\n\
    \    return result;\n}\n/* \nReturn ceil(n).\n    >>> ceilp(5L)\n    6L\n    >>>\
    \ ceilp(3L)\n    2L\n    \n*/\nlong ceilp(long n)\n{\n    return (n+(n&1)-1)/2;\n\
    }\n/*\nReturn floor of n.\n    >>> floorp(5L)\n    3L\n    >>> floorp(3L)\n  \
    \  2L\n    \n*/\nlong floorp(long n)\n{\n    return (n-1)/2;\n}\n/*\nReturn true\
    \ iff n is integer.\n    >>> ispp(3L)\n    True\n    >>> ispp(1L)\n    False\n\
    \    \n*/\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpy2r2jn8c.d(62): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmpy2r2jn8c.__unittest_L58_C1() [0x427b15]

    ??:? void tmpy2r2jn8c.__modtest() [0x427c10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430088]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa1d]

    ??:? runModuleUnitTests [0x42b989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong result = n;\n\
    \tfor (;;) {\n\t\tresult %= p;\n\t\tif (result < n) {\n\t\t\treturn result;\n\t\
    \t}\n\t\tresult = (result << 1) % p;\n\t}\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modm(3L, 5L)\n    3L\n    >>> modm(1101L, 101L)\n   \
    \ 2L\n    >>> modm(0L, 101L)\n    1L\n    >>> modm(3L, 11L)\n    8L\n    >>> modm(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modm(long n, long p) \n{\n\treturn modp(modp(n,\
    \ p), p);\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> modm(3L,\
    \ 5L)\n    3L\n    >>> modm(1101L, 101L)\n    2L\n    >>> modm(0L, 101L)\n   \
    \ 1L\n    >>> modm(3L, 11L)\n    8L\n    >>> modm(100L, 101L)\n    1L\n    \n\
    */\nlong modm(long n, long p, long mod) {\n\treturn modp(modp(n, p), mod);\n}\n\
    /*\nReturn p^n (be aware of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>>\
    \ modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nlong modp(long n,\
    \ long p) \n{\n\tlong result = p;\n\tfor (;;) {\n\t\tresult *= n;\n\t\tresult\
    \ %= p;\n\t\tif (result < n) {\n\t\t\treturn result;\n\t\t}\n\t\tresult /= p;\n\
    \t}\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqds53ymw.d(44): Error: `tmpqds53ymw.modp` called with argument
    types `(long, long)` matches both:

    /tmp/tmpqds53ymw.d(17):     `tmpqds53ymw.modp(long n, long p)`

    and:

    /tmp/tmpqds53ymw.d(77):     `tmpqds53ymw.modp(long n, long p)`

    /tmp/tmpqds53ymw.d(61): Error: `tmpqds53ymw.modp` called with argument types `(long,
    long)` matches both:

    /tmp/tmpqds53ymw.d(17):     `tmpqds53ymw.modp(long n, long p)`

    and:

    /tmp/tmpqds53ymw.d(77):     `tmpqds53ymw.modp(long n, long p)`

    /tmp/tmpqds53ymw.d(93): Error: `tmpqds53ymw.modp` called with argument types `(long,
    long)` matches both:

    /tmp/tmpqds53ymw.d(17):     `tmpqds53ymw.modp(long n, long p)`

    and:

    /tmp/tmpqds53ymw.d(77):     `tmpqds53ymw.modp(long n, long p)`

    /tmp/tmpqds53ymw.d(94): Error: `tmpqds53ymw.modp` called with argument types `(long,
    long)` matches both:

    /tmp/tmpqds53ymw.d(17):     `tmpqds53ymw.modp(long n, long p)`

    and:

    /tmp/tmpqds53ymw.d(77):     `tmpqds53ymw.modp(long n, long p)`

    /tmp/tmpqds53ymw.d(95): Error: `tmpqds53ymw.modp` called with argument types'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1;\n\
    \    for(long i=0; i<n; i++) res = res * p % p;\n    return res;\n}\n</code>\n\
    It works with all natural numbers, even negatives.\n<code>\nimport std.algorithm;\
    \ \nimport std.stdio;\nimport std.string;\nunittest\n{\n    alias candidate =\
    \ modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L)\
    \ == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L)\
    \ == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw8ne3ef4.d(23): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw8ne3ef4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long r;\n  if(n==0)\n\
    \    return 0L;\n  if(n==1L) return p; \n  if(p==0)\n    return 0;\n  if(p==1L)\n\
    \    return p;\n  r = modp(n - 1, p); \n  if(n > (long)(INT_MAX/p))\n    {\n \
    \     long q = modp(INT_MAX - n, p);\n      r = q | (r << 32L);\n    }\n  return\
    \ r+p; \n} \n/* \n   Return n^(1/d) modulo p.\n   \n   See http://www.math.rutgers.edu/~z70ws/naca0068/math_faq2.html\
    \ for more info.\n   \n   >>> modp2(3, 5)\n   3\n   >>> modp2(1101, 101)\n   2\n\
    \   >>> modp2(0, 101)\n   1\n   >>> modp2(3, 11)\n   8\n   >>> modp2(100, 101)\n\
    \   1\n*/\nlong modp2(long n, long d)\n{\n  long p = d*d;\n  return modp(n, p);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnxl3x9iz.d(28): Error: C style cast illegal, use `cast(long)(INT_MAX
    / p)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnxl3x9iz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong mask = (1L <<\
    \ p) - 1;\n\tlong res = n % p;\n\tif (res < p) \n\t\tres += p;\n\treturn res &\
    \ mask;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4kaa_qyg.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ddd]

    ??:? void tmp4kaa_qyg.__unittest_L25_C1() [0x427a61]

    ??:? void tmp4kaa_qyg.__modtest() [0x427b5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a996]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fab5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a96d]

    ??:? runModuleUnitTests [0x42b8d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42822c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x, y, z, tmp;\n\
    \    if(p > p) return 0;\n    if(p < 2 || p > n) return 0;\n    if(n & 1) return\
    \ 0;\n    if(n <= p) return n;\n    for(y = 0; y < n; y++){\n        for(x = 0,\
    \ tmp = 1; tmp < p; tmp = tmp * 2){\n            z = (x^tmp) % p;\n          \
    \  if(z != 0){\n                if((z + y) % 2 == 0)\n                    return\
    \ z;\n                else{\n                    x = z;\n                }\n \
    \           }\n        }\n    }\n    return 0;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2mub7wyi.d(42): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmp2mub7wyi.__unittest_L38_C1() [0x427b15]

    ??:? void tmp2mub7wyi.__modtest() [0x427c10]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430088]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa1d]

    ??:? runModuleUnitTests [0x42b989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long d;\n    \n\
    \    d = n - p; // = n - (p ^ n);\n    if (d < 0)\n        d = d + p;\n    \n\
    \    return d % p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0vjajw5y.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dd5]

    ??:? void tmp0vjajw5y.__unittest_L27_C1() [0x427a7f]

    ??:? void tmp0vjajw5y.__modtest() [0x427b54]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bafb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a98e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a965]

    ??:? runModuleUnitTests [0x42b8d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428224]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int shift = 32 -\
    \ __builtin_clz(n);\n    if (shift < 0) shift = 0;\n    return ((n << shift) %\
    \ (p == 0) ? p : ((p & -p) + p));\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnczg7n1g.d(19): Error: undefined identifier `__builtin_clz`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnczg7n1g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0)\n  \
    \      return 0;\n    if (p == 0)\n        return 1;\n    if (p == 1)\n      \
    \  return n;\n    if (p > n || p < 1)\n        return 0;\n    \n    long q = n\
    \ / p;\n    \n    long d = n % p;\n    \n    if (d == 0)\n        return n;\n\
    \    \n    long t = p - 1;\n    \n    if (q == 0)\n        return t;\n    \n \
    \   if (q == 1)\n        return p * t;\n    \n    long c = 1;\n    \n    while\
    \ (t != 0) {\n        t = t&(~d);\n        q = q<<1;\n        if (q == 1) {\n\
    \            c = c<<1;\n            c = c+t;\n        }\n        d = (d)<<1;\n\
    \    }\n    \n    return c;\n}\nunittest\n{\n    alias candidate = modp;\n\n \
    \   assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpb_tmotch.d(61): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ead]

    ??:? void tmpb_tmotch.__unittest_L57_C1() [0x427b35]

    ??:? void tmpb_tmotch.__modtest() [0x427c30]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbd3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa66]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbf9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300a8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb85]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa3d]

    ??:? runModuleUnitTests [0x42b9a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn n & (-p);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmq2_yh5b.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dad]

    ??:? void tmpmq2_yh5b.__unittest_L21_C1() [0x427a5b]

    ??:? void tmpmq2_yh5b.__modtest() [0x427b30]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bad3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a966]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faf9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffa8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa85]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a93d]

    ??:? runModuleUnitTests [0x42b8a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1;\n\
    \    long m;\n    long m1, m2;\n    long mask;\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph2d_xnv_.d(23): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph2d_xnv_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int n1 = n % p;\n\
    \    if (n1 == 0) {\n        return n;\n    } else {\n        return ((n-1) /\
    \ p) * p;\n    }\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4pwzdzfw.d(19): Error: cannot implicitly convert expression `n
    % p` of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4pwzdzfw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1L;\n \
    \   for (; n != 0L; n--, p >>= 1) {\n        if ((r << 1) + (r >> 3) >= p)\n \
    \           r &= p - 1;\n        else\n            r &= p;\n    }\n    return\
    \ r;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nI used the following function for\
    \ finding the number of trailing zeros in the binary representation of the number:\n\
    <code>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf8iy1xmh.d(28): Error: declaration expected, not `<`

    /tmp/tmpf8iy1xmh.d(37): Error: declaration expected, not `assert`

    /tmp/tmpf8iy1xmh.d(38): Error: declaration expected, not `assert`

    /tmp/tmpf8iy1xmh.d(39): Error: declaration expected, not `assert`

    /tmp/tmpf8iy1xmh.d(40): Error: declaration expected, not `assert`

    /tmp/tmpf8iy1xmh.d(41): Error: declaration expected, not `assert`

    /tmp/tmpf8iy1xmh.d(42): Error: declaration expected, not `assert`

    /tmp/tmpf8iy1xmh.d(43): Error: declaration expected, not `assert`

    /tmp/tmpf8iy1xmh.d(44): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf8iy1xmh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r;\n    if\
    \ ((n & -p) == n)\n        return 0;\n    r =  (n & (-p));\n    r = (r >> 1) ^\
    \ ((n & 1) == 0 ? 0x571bf95e : 0);\n    r = (r >> 1) ^ ((n & 1) == 0 ? 0xab9ac971\
    \ : 0);\n    return (r & p) == 0 ? r : (p^r);\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp96b_5l17.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e2d]

    ??:? void tmp96b_5l17.__unittest_L27_C1() [0x427ab1]

    ??:? void tmp96b_5l17.__modtest() [0x427bac]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9e6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb79]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430028]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb05]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9bd]

    ??:? runModuleUnitTests [0x42b929]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42827c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (p == 0) {\n\
    \        return 0;\n    }\n    if (p > n) {\n        long t = modp(n - p, p);\n\
    \        return t + 1;\n    }\n    if (n == p) {\n        return n;\n    }\n \
    \   if (n > p) {\n        long t = modp(n, p);\n        return t - 1;\n    }\n\
    \    if (n < -p) {\n        long t = modp(n, -p);\n        return t + 1;\n   \
    \ }\n    long m = 0;\n    while (n != 0) {\n        int r = n & 1;\n        n\
    \ >>= 1;\n        if (m == 0) {\n            m = r;\n        } else {\n      \
    \      m = m ^ r;\n        }\n    }\n    return m % p;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\nHere is a solution without recursion\n<code>\npublic static long\
    \ modPow(long base,long exponent)\n{\n    long res = 1;\n    while(exponent>0)\n\
    \    {\n        if(exponent%2==0)\n            res=res*base;\n        exponent-=2;\n\
    \        base=base*base;\n    }\n    return res;\n}\n</code>\n<|/ a dscore=0 tags=language-agnostic,modular-arithmetic,math,algorithm,modular\
    \ |>\n<| a dscore=0 |>\n<code>\nunittest\n{\n    alias candidate = modp;\n\n \
    \   assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8vt9z0ri.d(49): Error: declaration expected, not `<`

    /tmp/tmp8vt9z0ri.d(57): Error: declaration expected, not `while`

    /tmp/tmp8vt9z0ri.d(61): Error: no identifier for declarator `exponent`

    /tmp/tmp8vt9z0ri.d(61): Error: declaration expected, not `-=`

    /tmp/tmp8vt9z0ri.d(62): Error: no identifier for declarator `base`

    /tmp/tmp8vt9z0ri.d(62): Error: declaration expected, not `=`

    /tmp/tmp8vt9z0ri.d(63): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8vt9z0ri.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    // We want an unsigned\
    \ integer as result of the modulo.\n    long res;\n    \n    // If the modulo\
    \ would be positive, just return the result.\n    // This would only occur if\
    \ the result would be larger than\n    // p.\n    if (p > 0) {\n        if (n\
    \ >= p)\n            return n;\n        else\n            return n - p;\n    }\n\
    \    \n    // We have to handle the negative case.\n    // This means:\n    //\
    \    n <= p - n\n    // and\n    //    p > n\n    // (because n is always smaller\
    \ than (p-n) and n > p)\n    \n    // Check if the result is smaller than p.\n\
    \    // This means:\n    //    (p > n) and (n <= p)\n    // or\n    //    (p <=\
    \ n) and (n <= p)\n    // (because we can only check n <= p if n > p).\n    \n\
    \    // Check if n <= p.\n    if (n <= p)\n        return n;\n    \n    // n <=\
    \ p but p > n. Now we know that the result can't be smaller\n    // than p (p\
    \ <= n) and (n = p).\n    \n    // If this is the case we simply return p.\n \
    \   return p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpu6uqvvd_.d(60): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmpu6uqvvd_.__unittest_L56_C1() [0x427a55]

    ??:? void tmpu6uqvvd_.__modtest() [0x427b50]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r = 1;\n\twhile\
    \ (n >= p) { n -= p; r *= p; }\n\treturn r % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9ki_fjmh.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ddd]

    ??:? void tmp9ki_fjmh.__unittest_L23_C1() [0x427a61]

    ??:? void tmp9ki_fjmh.__modtest() [0x427b5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a996]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fab5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a96d]

    ??:? runModuleUnitTests [0x42b8d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42822c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  return (1L << (n%p))%p;\n\
    }\n//#include <stdio.h>\n//#include <stdint.h>\n//#include <stdlib.h>\n//#include\
    \ <string.h>\n//#include <math.h>\n//#include <inttypes.h>\n//#include <sys/time.h>\n\
    //#include <time.h>\n//#include <sys/resource.h>\n//#define PRINT_TIME(a) \\\n\
    //{   \\\n//    uint64_t tmp = a.tv_sec*1e6 + a.tv_nsec;\\\n//    printf(\"%lld.%06lld\\\
    n\", (double)tmp/(double)1e3, \\\n//            1000*(tmp%1e3)/1e6); \\\n//}\n\
    //#define PRINT_TIMES(a) \\\n//{   \\\n//    uint64_t tmp = a.tv_sec*1e6 + a.tv_nsec;\\\
    \n//    printf(\"%lld.%06lld %lld.%06lld\\n\", (double)tmp/(double)1e3, \\\n//\
    \            1000*(tmp%1e3)/1e6, (double)a.tv_usec/1e6, \\\n//            1000*(tmp%1e6)*1e6);\
    \ \\\n//}\n//#define TIME_TIMER(a) \\\n//{   \\\n//    uint64_t tmp = a.tv_sec*1e6\
    \ + a.tv_nsec;\\\n//    printf(\"%lld.%06lld %lld.%06lld\\n\", (double)tmp/(double)1e3,\
    \ \\\n//            1000*(tmp%1e3)/1e6, (double)a.tv_usec/1e6, \\\n//        \
    \    1000*(tmp%1e6)*1e6); \\\n//    tmp = 1000000000LL*a.tv_sec + a.tv_nsec;\\\
    \n//    printf(\"%lld\\n\", (double)tmp/(double)1e6);\\\n//}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpsz2dv2md.d(57): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmpsz2dv2md.__unittest_L52_C1() [0x427a77]

    ??:? void tmpsz2dv2md.__modtest() [0x427b4c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 0) return\
    \ 0;\n\tif (n <= 0) return -1;\n\tif (p == 1) return 1;\n\treturn n & (-p);\n\
    }\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> mod2(3L, 5L)\n   \
    \ 3L\n    >>> mod2(1101L, 101L)\n    2L\n    >>> mod2(0L, 101L)\n    1L\n    >>>\
    \ mod2(3L, 11L)\n    8L\n    >>> mod2(100L, 101L)\n    1L\n    \n*/\nlong mod2(long\
    \ n, long p)\n{\n\tlong r;\n\t\n\tr = n & (-p);\n\tr = modp(r, p);\n\tif (r ==\
    \ 0) return 0;\n\treturn r;\n}\n/*\nReturn n >> p.\n    >>> shr(5L, 3L)\n    2L\n\
    \    >>> shr(1101L, 3L)\n    1101L\n    >>> shr(0L, 3L)\n    0L\n    >>> shr(3L,\
    \ 11L)\n    7L\n    >>> shr(100L, 3L)\n    100L\n    \n*/\nlong shr(long n, long\
    \ p)\n{\n\tlong r;\n\t\n\tr = n >> (p-1);\n\tr = modp(r, p);\n\tif (r == 0) return\
    \ 0;\n\treturn r;\n}\n/*\nReturn n << p.\n    >>> shl(5L, 3L)\n    10L\n    >>>\
    \ shl(1101L, 3L)\n    920L\n    >>> shl(0L, 3L)\n    0L\n    >>> shl(3L, 11L)\n\
    \    8L\n    >>> shl(100L, 3L)\n    100L\n    \n*/\nlong shl(long n, long p)\n\
    {\n\tlong r;\n\t\n\tr = n << (p-1);\n\tr = modp(r, p);\n\tif (r == 0) return 0;\n\
    \treturn r;\n}\n/*\nReturn the logarithm base 10 of n.\n    \n    >>> log(5L)\n\
    \    1\n    >>> log(1101L)\n    2\n    >>> log(0L)\n    0\n    >>> log(3L)\n \
    \   1\n    \n*/\ndouble log(double x)\n{\n\tif (x == 0)\n\t\treturn 0;\n\t\n\t\
    return std::log10(x);\n}\n/*\nReturn the natural logarithm of n.\n    \n    >>>\
    \ ln3(5L)\n    1\n    >>> ln3(1101L)\n    1.5\n    >>> ln3(0L)\n    0\n    >>>\
    \ ln3(3L)\n    1.5\n    \n*/\ndouble ln3(double x)\n{\n\tif (x == 0)\n\t\treturn\
    \ 0;\n\t\n\t\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwwh4bkgv.d(111): Error: found `:` when expecting `;` following
    `return` statement

    /tmp/tmpwwh4bkgv.d(111): Error: found `:` instead of statement

    /tmp/tmpwwh4bkgv.d(132): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwwh4bkgv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long m, r;\n   \
    \ \n    m = n - ((p & 0xaaaaaaaaaaaaaaaaL) - (n >> 32));\n    r = (p & 0xaaaaaaaaaaaaaaaaL)\
    \ - (m >> 32);\n    \n    m <<= 1;\n    m |= n & 1;\n    \n    if (m == 0)\n \
    \       return n;\n    \n    m += 1;\n    \n    if (m > 0xffffffff00000000L)\n\
    \        m = ((m >> 32) + p) & 0xffffffff00000000L;\n    else\n        m += p;\n\
    \    \n    return m & p;\n}\n/*\nReturn log2(n).\n    >>> log2(5L)\n    3\n  \
    \  >>> log2(15L)\n    3\n    >>> log2(121L)\n    2\n    >>> log2(1000L)\n    2\n\
    \    \n*/\nlong log2(long n) \n{\n    return std.math.log(n)/std.math.log2(std.typecons.log2(n));\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppgcnfsr3.d(53): Error: undefined identifier `log2` in module `std.typecons`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppgcnfsr3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long tmp = p;\n\
    \    while (tmp > 0)\n    {\n        tmp >>= 1;\n        if (n & tmp)\n      \
    \      tmp ^= p;\n    }\n    return tmp;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164506
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (p == 0) return\
    \ n;\n    int k = 0;\n    for (; p; p >>= 1) {\n        k += p & 1;\n        p\
    \ >>= 1;\n    }\n    return n & ((1L << k) - 1);\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp8xkahx1d.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmp8xkahx1d.__unittest_L27_C1() [0x427aa3]

    ??:? void tmp8xkahx1d.__modtest() [0x427b78]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 0) {\n\t\t\
    if (n == 0) return 1;\n\t\telse return 0;\n\t}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq6tfhp9d.d(23): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq6tfhp9d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = p%n;\n\
    \    if (r==0) return n;\n    if (r>0) return modp(n,p)+r; else return modp(n,p)-r;\
    \ \n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>\nimport std.stdio;\nimport\
    \ std.string;\nimport std.container;\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpldccfugl.d(23): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpldccfugl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn (long)math.pow(2,n)%p;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8bu94zr1.d(19): Error: C style cast illegal, use `cast(long)math.pow(2,
    n)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8bu94zr1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n   long q, r, t;\n \
    \  if(p == 0) return 0L;\n   if(n == 0) return p == 0? 1L : (p>>1)-1L;\n   if(p\
    \ == 1) return 1L;\n   t = 1L;\n   for(;;)\n   {\n      q = (n%p)&t; \n      r\
    \ = (n%p)&t; \n      n = q;\n      if (n == 0) return r;\n   }\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164506
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint i = (int)n;\n\t\
    int a = (int)p;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxen7gi9e.d(19): Error: C style cast illegal, use `cast(int)n`

    /tmp/tmpxen7gi9e.d(20): Error: C style cast illegal, use `cast(int)p`

    /tmp/tmpxen7gi9e.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxen7gi9e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    // TODO: check overflow\n\
    \    return std.math.fmod(n, p);\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn861whds.d(20): Error: cannot implicitly convert expression `fmod(cast(real)n,
    cast(real)p)` of type `real` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn861whds.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return (n * p +\
    \ 1) & (~p);\n}\n/* \nReturn a random number between 0 <= x < p (be aware of numerics).\n\
    \    >>> ran(111L, 101L)\n    1L\n    >>> ran(0L, 101L)\n    1L\n    >>> ran(7L,\
    \ 101L)\n    3L\n    \n*/\nlong ran(long x, long p) \n{\n    return modp(std.random.random(),\
    \ p);\n}\n/* \nReturn a random number between 0 <= x <= p (be aware of numerics).\n\
    \    >>> ran(111L, 101L)\n    3L\n    >>> ran(-1L, 101L)\n    1L\n    >>> ran(7L,\
    \ 101L)\n    1L\n    \n*/\nlong ran_unsigned(long x, long p) \n{\n    return modp(std.random.unsigned(),\
    \ p);\n}\n/* \nReturn a random bool result (be aware of numerics).\n    >>> ranbool(111L)\n\
    \    1L\n    >>> ranbool(0L)\n    0L\n    >>> ranbool(7L)\n    1L\n    \n*/\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1e0uvm6h.d(33): Error: undefined identifier `random` in package
    `std`

    /tmp/tmp1e0uvm6h.d(47): Error: undefined identifier `random` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1e0uvm6h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long q = p / n;\n\
    \    long r = p % n;\n    if(r > 0) {\n        return q | (modp(q, p) << r);\n\
    \    }\n    return q;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppji79jee.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ded]

    ??:? void tmppji79jee.__unittest_L26_C1() [0x427a71]

    ??:? void tmppji79jee.__modtest() [0x427b6c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a97d]

    ??:? runModuleUnitTests [0x42b8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42823c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164491
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x;\n    long\
    \ r = 1;\n    \n    do {\n\tx = (n + r) % p;\n\tr = (r * x) / p;\n    } while(x\
    \ != 0);\n    \n    return r;\n}\n/*\nReturn sqrt(x)\n    >>> sqrt3(2.5)\n   \
    \ 2.25\n    >>> sqrt3(4)\n    1.414213562373095048801688724209698078569671875376953125\n\
    \    \n*/\ndouble sqrt3(double x) \n{\n    double y;\n    \n    y = x;\n    \n\
    \    while(!(y == 0) && (y != x))\n\t{\n\t    y = y/2;\n\t}\n    \n    return\
    \ y;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164506
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 0)\n\t\t\
    return 1;\n\tlong r = n % p;\n\tif (r < p)\n\t\tr = p-r+p;\n\tif (r < p)\n\t\t\
    r = p-r+p;\n\treturn r * n;\n}\n/*\nReturn the sum of the given numbers.\n   \
    \ >>> suml(1,2,3)\n    6L\n*/\nlong suml(long x, long y, long z)\n{\n\tlong r,\
    \ i;\n\tr = x + y + z;\n\tfor (i=0; i<3; i++)\n\t\tr += (long)pow(10, i);\n\t\
    return r;\n}\n/*\nReturn the product of the given numbers.\n    >>> prodl(1,2,3)\n\
    \    6L\n*/\nlong prodl(long x, long y, long z)\n{\n\tlong r, i;\n\tr = x*y*z;\n\
    \tfor (i=0; i<3; i++)\n\t\tr *= (long)pow(10, i);\n\treturn r;\n}\n/*\nReturn\
    \ the largest power of 10 less than or equal to the given number.\n    >>> pow10l(10)\n\
    \    10L\n    >>> pow10l(1000)\n    100L\n*/\nlong pow10l(long x)\n{\n\tif (x\
    \ < 0)\n\t\treturn -1;\n\tif (x == 0)\n\t\treturn 0;\n\tlong r = x;\n\twhile (r\
    \ / 10 != 1)\n\t\tr /= 10;\n\treturn r;\n}\n/*\nReturn ceil(log2(n))\n    >>>\
    \ log2l(1L)\n    1L\n    >>> log2l(2L)\n    1L\n    >>> log2l(3L)\n    2L\n  \
    \  >>> log2l(4L)\n    2L\n    >>> log2l(5L)\n    3L\n    >>> log2l(6L)\n    3L\n\
    \    >>> log2l(7L)\n    4L\n*/\nlong log2l(long n)\n{\n\tlong r = 0;\n\twhile\
    \ (n > 0)\n\t{\n\t\tr ++;\n\t\tn >>= 1;\n\t}\n\treturn r;\n}\n/*\nReturn ceil(log2(p))\n\
    */\nlong log2p(long p)\n{\n\tlong r;\n\tr = 1;\n\twhile (r < p)\n\t\tr += p;\n\
    \treturn r;\n}\n/*\nReturn floor(log2(n))\n    >>> log2l(100L)\n    6L\n    >>>\
    \ log2l(101L)\n    7L\n*/\nlong log2l(long n)\n{\n\tlong r;\n\twhile (n > 0)\n\
    \t{\n\t\tr --;\n\t\tn >>= 1;\n\t}\n\treturn r;\n}\n/*\nReturn floor(log2(p))\n\
    */\nlong log2p(long p)\n{\n\tlong r;\n\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxnmojltg.d(38): Error: C style cast illegal, use `cast(long)pow(10,
    i)`

    /tmp/tmpxnmojltg.d(51): Error: C style cast illegal, use `cast(long)pow(10, i)`

    /tmp/tmpxnmojltg.d(134): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxnmojltg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x, y;\n\tx =\
    \ __int2long(p);\n\ty = __int2long(n);\n\treturn x - (y * (long) x - 1L);\n}\n\
    /*\nReturn n modulo p (be aware of numerics).\n    >>> modn(3L, 5L)\n    5L\n\
    \    >>> modn(1101L, 101L)\n    1L\n    >>> modn(0L, 101L)\n    0L\n    >>> modn(3L,\
    \ 11L)\n    3L\n    >>> modn(100L, 101L)\n    101L\n    \n*/\nlong modn(long n,\
    \ long p) \n{\n\tlong x, y;\n\tx = __int2long(p);\n\ty = __int2long(n);\n\treturn\
    \ y + ((x - ((y * (long) x - 1L)) % x);\n}\n/*\nReturn power of two modulo p.\n\
    \    >>> pow2mod(5L, 5L)\n    1L\n    >>> pow2mod(100L, 5L)\n    1L\n    \n*/\n\
    long pow2mod(long n, long p) \n{\n\treturn modp(n,p);\n}\n/*\nReturn nth root\
    \ of n modulo p.\n    >>> rootmod(8L, 5L)\n    2L\n    >>> rootmod(9L, 5L)\n \
    \   2L\n    \n*/\nlong rootmod(long n, long p) \n{\n\treturn modn(n,p);\n}\n/*\n\
    Return power of two modulo p.\n    >>> pow2mod(5L, 8L)\n    1L\n    >>> pow2mod(100L,\
    \ 8L)\n    1L\n    \n*/\nlong pow2mods(long n, long p) \n{\n\treturn modp(pow2mod(n,p),p);\n\
    }\n/*\nReturn nth root of n modulo p.\n    >>> rootmod(8L, 8L)\n    1L\n    >>>\
    \ rootmod(9L, 8L)\n    1L\n    \n*/\nlong rootmods(long n, long p) \n{\n\treturn\
    \ modn(rootmod(n,p),p);\n}\n/*\nReturn x raised to the power of y modulo p.\n\
    \    >>> powmod(3L,3L,5L)\n    1L\n    >>> powmod(3L,3L,100L)\n    1L\n    \n\
    */\nlong powmod(long x, long y, long p) \n{\n\treturn modp(x * y, p);\n}\n/*\n\
    Return x raised to the power of y modulo p.\n    >>> powmods(3L,3L,5L)\n    1L\n\
    \    >>> powmods(3L,3L,\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpob7gk0px.d(22): Error: C style cast illegal, use `cast(long)x`

    /tmp/tmpob7gk0px.d(43): Error: C style cast illegal, use `cast(long)x`

    /tmp/tmpob7gk0px.d(43): Error: found `;` when expecting `)`

    /tmp/tmpob7gk0px.d(44): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmpob7gk0px.d(105): Error: unterminated /* */ comment

    /tmp/tmpob7gk0px.d(122): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpob7gk0px.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return 1L<<n % p;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnthjgy63.d(25): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dc5]

    ??:? void tmpnthjgy63.__unittest_L21_C1() [0x427a49]

    ??:? void tmpnthjgy63.__modtest() [0x427b44]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baeb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a97e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a955]

    ??:? runModuleUnitTests [0x42b8c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428214]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long x = 0;\n  \
    \  while (n > 1) {\n        if (n % 2 == 1) {\n            x ^= (n & 1L) << p;\n\
    \        }\n        n >>= 1;\n        p += 1;\n    }\n    x ^= n;\n    return\
    \ x;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou have an unnecessary `% p` in\
    \ the second loop :) I suggest you post that as another answer\n<|/ c |>\n<| c\
    \ |>\nI agree with you completely, but I don't have the time right now to post\
    \ a full solution :)\n<|/ c |>\n<| a |>\nIf you're willing to use C99 features,\
    \ you can use an unsigned long long and use integer division to get your answer.\n\
    <code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include\
    \ <limits.h>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2breut0y.d(30): Error: declaration expected, not `<`

    /tmp/tmp2breut0y.d(36): Error: unterminated character constant

    /tmp/tmp2breut0y.d(39): Error: unterminated character constant

    /tmp/tmp2breut0y.d(49): Error: declaration expected, not `assert`

    /tmp/tmp2breut0y.d(50): Error: declaration expected, not `assert`

    /tmp/tmp2breut0y.d(51): Error: declaration expected, not `assert`

    /tmp/tmp2breut0y.d(52): Error: declaration expected, not `assert`

    /tmp/tmp2breut0y.d(53): Error: declaration expected, not `assert`

    /tmp/tmp2breut0y.d(54): Error: declaration expected, not `assert`

    /tmp/tmp2breut0y.d(55): Error: declaration expected, not `assert`

    /tmp/tmp2breut0y.d(56): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2breut0y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r = n % p;\n\t\
    long s = n / p;\n\tif (r == 0) {\n\t\treturn p;\n\t}\n\tif (r == p || r == p -\
    \ 1) {\n\t\treturn s - 1;\n\t}\n\t\n\tlong rem = p - r;\n\tif (rem != 0) {\n\t\
    \treturn modp(s, rem);\n\t}\n\t\n\treturn modp((n-r), p);\n}\n\t\t\t\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgnfoigjg.d(40): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e2d]

    ??:? void tmpgnfoigjg.__unittest_L36_C1() [0x427ab5]

    ??:? void tmpgnfoigjg.__modtest() [0x427bb0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb53]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9e6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb79]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430028]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb05]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9bd]

    ??:? runModuleUnitTests [0x42b929]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42827c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = 1;\n  \
    \  while (((n&1)==0) && n>1) {\n        r = std.int.comb(r,std.int.comb(r,std.int.comb(r,n&-p)));\n\
    \        n >>= 1;\n    }\n    if (n>0) \n        r = std.int.comb(r,n);\n    return\
    \ r;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice function and nice use of bitmasking.\
    \ But the question is really about how to get the `pow` function in any language.\
    \ I'll leave the answer unaccepted for a while in case other languages have any\
    \ ideas about how to get the pow function.\n<|/ c |>\n<| c |>\nOh I agree with\
    \ you. I guess that's why I didn't accept the answer.\n<|/ c |>\n<| c |>\nThe\
    \ power of 2 is a bit confusing... In C#, `Math.Pow` uses `Math.Log` and `Math.Pow`\
    \ uses `Math.Exp`, so why would you want to use `modp`?\n<|/ c |>\n<| c |>\nTo\
    \ avoid calling `Math.Pow` when `p==0`.\n<|/ c |>\n<| c |>\n`modp` would avoid\
    \ doing any computation on `p==0`, but `modp2` would still use `Math.Pow` for\
    \ some reason. `modp2` avoids `Math.Log` by computing `Math.Pow`, but `modp` avoids\
    \ `Math.Exp` by computing `Math.Log`.\n<|/ c |>\n<| a tags=c#,python |>\nThe first\
    \ step is to convert the given integer n to the binary number format. Then you\
    \ just have to find all the '1's in the binary form of n. \nIf you need to find\
    \ all the 1's, you can do it using the following code : \n<code>\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp91pothhq.d(21): Error: identifier expected following `.`, not `int`

    /tmp/tmp91pothhq.d(21): Error: identifier expected following `.`, not `int`

    /tmp/tmp91pothhq.d(21): Error: identifier expected following `.`, not `int`

    /tmp/tmp91pothhq.d(25): Error: identifier expected following `.`, not `int`

    /tmp/tmp91pothhq.d(28): Error: declaration expected, not `<`

    /tmp/tmp91pothhq.d(31): Error: unterminated character constant

    /tmp/tmp91pothhq.d(34): Error: unterminated character constant

    /tmp/tmp91pothhq.d(34): Error: unterminated character constant

    /tmp/tmp91pothhq.d(47): Error: unterminated character constant

    /tmp/tmp91pothhq.d(53): Error: declaration expected, not `assert`

    /tmp/tmp91pothhq.d(54): Error: declaration expected, not `assert`

    /tmp/tmp91pothhq.d(55): Error: declaration expected, not `assert`

    /tmp/tmp91pothhq.d(56): Error: declaration expected, not `assert`

    /tmp/tmp91pothhq.d(57): Error: declaration expected, not `assert`

    /tmp/tmp91pothhq.d(58): Error: declaration expected, not `assert`

    /tmp/tmp91p'
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n > p)\n\t{\n\t\
    \tlong r = modp(n >> 1, p);\n\t\tn = n - (n >> 1) ^ r;\n\t\tp = p - (p >> 1) ^\
    \ r;\n\t}\n\treturn n - (n & -p);\n}\n/*\nReturn a mod m (be aware of numerics).\n\
    \    >>> modm(3L, 5L)\n    3L\n    >>> modm(1101L, 101L)\n    1L\n    >>> modm(0L,\
    \ 101L)\n    0L\n    >>> modm(3L, 11L)\n    2L\n    >>> modm(100L, 101L)\n   \
    \ 8L\n    \n*/\nlong modm(long n, long m) \n{\n\tif (n > m)\n\t{\n\t\tlong r =\
    \ modm(n >> 1, m);\n\t\tn = n - (n >> 1) ^ r;\n\t\tm = m - (m >> 1) ^ r;\n\t}\n\
    \treturn n - (n & -m);\n}\n/*\nReturn 2^n bits of n.\n    >>> msb2(3L)\n    3\n\
    \    >>> msb2(1101L)\n    10\n    >>> msb2(0L)\n    0\n    >>> msb2(3L)\n    2\n\
    \    >>> msb2(100L)\n    8\n    \n*/\nlong msb2(long n)\n{\n\twhile (n != 0)\n\
    \t{\n\t\tn >>= 1;\n\t\t++msb_count;\n\t}\n\treturn msb_count;\n}\n/*\nReturn a\
    \ bitmask to test which bit of n was set.\n    >>> msbmask(0xF)\n    9L\n    >>>\
    \ msbmask(0xF0)\n    10L\n    >>> msbmask(0xFF)\n    15L\n    \n*/\nlong msbmask(long\
    \ n)\n{\n\tlong r = 0;\n\twhile (n != 0)\n\t{\n\t\tr <<= 1;\n\t\tr |= 1 << (n\
    \ - 1);\n\t\t--n;\n\t}\n\treturn r;\n}\n/*\nReturn the number of bits set.\n \
    \   >>> msbs(0xF)\n    9\n    >>> msbs(0xF0)\n    10\n    >>> msbs(0xFF)\n   \
    \ 15\n    \n*/\nlong msbs(long n)\n{\n\tlong count = 0;\n\twhile (n != 0)\n\t\
    {\n\t\tn &= n - 1;\n\t\t++count;\n\t}\n\treturn count;\n}\n/*\nReturn a random\
    \ integer in the range [lo, hi]\n(be aware of numerics). \n    >>> random(0xF)\n\
    \    25L\n    >>> random(0xF0)\n    29L\n    >>> random(0xFF)\n    43\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq_au1d1k.d(115): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq_au1d1k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if(n < 0) return\
    \ modp(-ln, p);\n    if(p <= 0) return -modp(-n, p);\n    \n    long q = n / p;\n\
    \    long r = n % p;\n    \n    long tmp = p;\n    while(true) {\n        if(!(n\
    \ % tmp)) break;\n        tmp = tmp * p;\n    }\n    \n    return q + (r % tmp);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9uai9yix.d(19): Error: undefined identifier `ln`, did you mean
    variable `n`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9uai9yix.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint k = (n-1) / p;\n\
    \treturn p * k + n;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2xpvq9ry.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dc5]

    ??:? void tmp2xpvq9ry.__unittest_L22_C1() [0x427a6f]

    ??:? void tmp2xpvq9ry.__modtest() [0x427b44]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baeb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a97e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a955]

    ??:? runModuleUnitTests [0x42b8c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428214]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return (n^p)%p;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwli42nug.d(25): unittest failure

    ----------------

    ??:? _d_unittestp [0x427db5]

    ??:? void tmpwli42nug.__unittest_L21_C1() [0x427a3d]

    ??:? void tmpwli42nug.__modtest() [0x427b38]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42badb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a96e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a945]

    ??:? runModuleUnitTests [0x42b8b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428204]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < p) {\n \
    \       n %= p;\n        n -= (p & -n);\n        n -= (p & -n);\n        n -=\
    \ (p & -n);\n        n &= p;\n    }\n    return n;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphetawy_l.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427de5]

    ??:? void tmphetawy_l.__unittest_L28_C1() [0x427a6d]

    ??:? void tmphetawy_l.__modtest() [0x427b68]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fabd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a975]

    ??:? runModuleUnitTests [0x42b8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n   assert(p != 0L);\n\
    \   if (n == 0L)\n       return 1L;\n   if (n >= p) \n      return n - p;\n  \
    \ return modp(n - (long) pow(2L, p), p);\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6f0j8qat.d(24): Error: C style cast illegal, use `cast(long)pow(2L,
    p)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6f0j8qat.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    // TODO: add an\
    \ overload with integer and fixed size\n    // TODO: remove inline keyword and\
    \ replace with static inline\n    // TODO: remove duplicated code\n    //    inline\
    \ long modp(long n, long p)\n    //    {\n    //        long rem = n % p;\n  \
    \  //        if(p == 0)\n    //        {\n    //            if(n == 0)\n    //\
    \                return 0;\n    //            return n;\n    //        }\n   \
    \ //        if(n == 0)\n    //            return 1;\n    //        if(p == 1)\n\
    \    //            return modp(n, rem);\n    //        if(n == 1)\n    //    \
    \        return 0;\n    //        long p2 = p * p;\n    //        long r = n /\
    \ p;\n    //        long r2 = r * r;\n    //        if(r2 == p2)\n    //     \
    \       return r;\n    //        long q = n - r2 * (r - 1);\n    //        return\
    \ modp(q, p);\n    //    }\n    // TODO: replace with generic type trait\n   \
    \ long x = n / p;\n    long y = n % p;\n    if(p == 0)\n        return n - ((x\
    \ * x) % p);\n    if(p == 1)\n        return n;\n    if(x == 0)\n        return\
    \ 1;\n    long p = p * p;\n    long r = n / p;\n    long r2 = r * r;\n    if(r2\
    \ == p)\n        return r;\n    long q = n - r2 * (r - 1);\n    return modp(q,\
    \ p);\n}\n</code>\n<|/ a tags=c++,modulo,math,optimization,algorithm |>\n<| c\
    \ |>\nNice solution, but note that `n` should be `unsigned` if you use this for\
    \ unsigned modulo, otherwise you may get overflow problems.\n<|/ c |>\n<| c |>\n\
    `long p = p * p;` should be `long p = p * n;` in the first case. Otherwise this\
    \ implementation will work for all positive numbers, and it will also work for\
    \ negative numbers as long as `p` is positive. However it may overflow for negative\
    \ `p`.\n<|/ c |>\n<| c |>\n, my concern was about modulo powers of 2. But in fact\
    \ the answer doesn't work for all modulo powers. I edited the answer to avoid\
    \ this problem.\n<|/ c |>\n<| c |>\nThe question didn't say anything about modulo\
    \ powers of 2, only modulo powers of p (the length of the modulus). For example,\
    \ `modp(n, 5)` will fail for `n` >= 10, and for `n` < 5 (because `n * p` is longer\
    \ than `p` - you only need to check for modulo powers of `p` - `p == 1, 2 * p\
    \ == 2 * \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpab548ook.d(62): Error: declaration expected, not `<`

    /tmp/tmpab548ook.d(71): Error: unterminated character constant

    /tmp/tmpab548ook.d(74): Error: unterminated character constant

    /tmp/tmpab548ook.d(74): Error: unterminated string constant starting at /tmp/tmpab548ook.d(74)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpab548ook.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong a = n; \n\tlong\
    \ b = p;\n\twhile (b > 0) {\n\t\tlong t = a % b;\n\t\ta = b;\n\t\tb = t;\n\t}\n\
    \treturn a;\n}\n/*\nReturn n modulo p.\n    >>> modn(3L, 5L)\n    3L\n    >>>\
    \ modn(1101L, 101L)\n    1101L\n    >>> modn(0L, 101L)\n    0L\n    >>> modn(3L,\
    \ 11L)\n    3L\n    >>> modn(100L, 101L)\n    100L\n    \n*/\nlong modn(long n,\
    \ long p)\n{\n\tif (p != 0) return (n + p) % p;\n\treturn n % p;\n}\n/*\nReturn\
    \ n modulo p and raise if n is negative.\n    >>> modnn(-3L, 5L)\n    -3L\n  \
    \  >>> modnn(-1101L, 101L)\n    -1100L\n    >>> modnn(-0L, 101L)\n    -0L\n  \
    \  >>> modnn(-3L, 11L)\n    -3L\n    >>> modnn(-100L, 101L)\n    -100L\n    \n\
    */\nlong modnn(long n, long p) {\n\tlong r = modn(n, p);\n\tif (n < 0)\n\t\tthrow\
    \ Exception(\"modnn\");\n\treturn r;\n}\n/*\nReturn n modulo p with rounding.\n\
    \    >>> modrn(-3L, 5L)\n    -3L\n    >>> modrn(-1101L, 101L)\n    -1100L\n  \
    \  >>> modrn(-0L, 101L)\n    -0L\n    >>> modrn(-3L, 11L)\n    -3L\n    >>> modrn(-100L,\
    \ 101L)\n    -100L\n    \n*/\nlong modrn(long n, long p) {\n\tlong r = modn(n,\
    \ p);\n\tif (n < 0)\n\t\treturn r;\n\t\n\tif (n % 2 == 1)\n\t\treturn r;\n\treturn\
    \ (r + 2) % p;\n}\n/*\nReturn n modulo p with rounding.\n    >>> modrn(3L, 5L)\n\
    \    3L\n    >>> modrn(1101L, 101L)\n    1101L\n    >>> modrn(0L, 101L)\n    0L\n\
    \    >>> modrn(3L, 11L)\n    3L\n    >>> modrn(100L, 101L)\n    100L\n    \n*/\n\
    long modrn(long n, long p) {\n\tlong r = modn(n, p);\n\tif (n < 0)\n\t\treturn\
    \ r;\n\tif (n % 2 == 1)\n\t\treturn r;\n\treturn (r + 2) % p;\n}\n/*\nReturn floor(n\
    \ / p\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp905ghjzu.d(112): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp905ghjzu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r, u;\n\tif(n==0)\n\
    \t\treturn 0;\n\tr = 1;\n\twhile(p) {\n\t\tif(p&1) \n\t\t\tr = (r*n+1)%p;\n\t\t\
    p = p/2;\n\t\tn--;\n\t}\n\tu = (n%p) + (r*n);\n\tif(r!=1) \n\t\tu = (u+1)%p;\n\
    \treturn u;\n}\n</code>\n<|/ a dscore=4 |>\n<| a |>\nAn alternative to Steve's\
    \ and Jack's answer is to compute the prime factors of n using a Sieve of Eratosthenes.\
    \  This algorithm has two advantages:\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo7ecwbiu.d(34): Error: declaration expected, not `<`

    /tmp/tmpo7ecwbiu.d(37): Error: unterminated character constant

    /tmp/tmpo7ecwbiu.d(37): Error: unterminated character constant

    /tmp/tmpo7ecwbiu.d(42): Error: declaration expected, not `assert`

    /tmp/tmpo7ecwbiu.d(43): Error: declaration expected, not `assert`

    /tmp/tmpo7ecwbiu.d(44): Error: declaration expected, not `assert`

    /tmp/tmpo7ecwbiu.d(45): Error: declaration expected, not `assert`

    /tmp/tmpo7ecwbiu.d(46): Error: declaration expected, not `assert`

    /tmp/tmpo7ecwbiu.d(47): Error: declaration expected, not `assert`

    /tmp/tmpo7ecwbiu.d(48): Error: declaration expected, not `assert`

    /tmp/tmpo7ecwbiu.d(49): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo7ecwbiu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q = n / p;\n\t\
    long r = n % p;\n\tif (r < q)\n\t\treturn p * q + r;\n\telse \n\t\treturn p;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpegqcbfc_.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ddd]

    ??:? void tmpegqcbfc_.__unittest_L26_C1() [0x427a61]

    ??:? void tmpegqcbfc_.__modtest() [0x427b5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a996]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fab5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a96d]

    ??:? runModuleUnitTests [0x42b8d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42822c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d = (int)n;\n\
    \tif (d == 0) return 0;\n\tif (d == 1) return n;\n\tn = ((n - 1) * (d % p)) /\
    \ p;\n\tif (n == p) return n;\n\treturn n - p;\n}\n/*\nReturn 2^(n-1) modulo p\
    \ (be aware of numerics).\n    >>> modp(-3L, 5L)\n    -2L\n    >>> modp(-1101L,\
    \ 101L)\n    -2L\n    >>> modp(-0L, 101L)\n    -1L\n    >>> modp(-3L, 11L)\n \
    \   -8L\n    >>> modp(-100L, 101L)\n    -1L\n*/\nlong modp1(long n, long p) \n\
    {\n\tlong d = (int)n;\n\tif (d == 0) return 0;\n\tif (d == 1) return n;\n\tn =\
    \ ((n - 1) * (d % p)) / p;\n\tif (n == p) return n;\n\treturn n - p;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph3u17rz7.d(19): Error: C style cast illegal, use `cast(int)n`

    /tmp/tmph3u17rz7.d(41): Error: C style cast illegal, use `cast(int)n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph3u17rz7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 1) return\
    \ n;\n\tif (n == p) return p;\n\tif (n >= p) return n - p;\n\t\n\tlong q = divrem(n\
    \ - p, p, p);\n\treturn q * p + (n - p) % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp26yigts5.d(23): Error: undefined identifier `divrem`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp26yigts5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn long(std.math.pow2(n)\
    \ - std.math.pow2(p))%p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwhmicm77.d(19): Error: undefined identifier `pow2` in module `std.math`,
    did you mean template `pow(F, G)(F x, G n) if (isFloatingPoint!F && isIntegral!G)`?

    /tmp/tmpwhmicm77.d(19): Error: undefined identifier `pow2` in module `std.math`,
    did you mean template `pow(F, G)(F x, G n) if (isFloatingPoint!F && isIntegral!G)`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhmicm77.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: -8
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long i, res = 1;\n\
    \    for (i = 1; i < p; ++i) {\n        res = (n % res) * p;\n    }\n    return\
    \ n % res;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(p==0) return 0;\n\
    \tif(p==1) return n;\n\tif(p==2) return n+1;\n\tif(p==3) return n*2;\n\tif(p==4)\
    \ return n*3;\n\tif(p==5) return n*4;\n\tif(p==6) return n*5;\n\tif(p==7) return\
    \ n*6;\n\tif(p==8) return n*7;\n\tif(p==9) return n*8;\n\tif(p==10) return n*9;\n\
    \tif(p==11) return n*10;\n\tif(p==12) return n*11;\n\tif(p==13) return n*12;\n\
    \tif(p==14) return n*13;\n\tif(p==15) return n*14;\n\tif(p==16) return n*15;\n\
    \tif(p==17) return n*16;\n\tif(p==18) return n*17;\n\tif(p==19) return n*18;\n\
    \tif(p==20) return n*19;\n\tif(p==21) return n*20;\n\tif(p==22) return n*n*2;\n\
    \tif(p==23) return n*n*3;\n\tif(p==24) return n*n*4;\n\tif(p==25) return n*n*5;\n\
    \tif(p==26) return n*n*6;\n\tif(p==27) return n*n*7;\n\tif(p==28) return n*n*8;\n\
    \tif(p==29) return n*n*9;\n\tif(p==30) return n*n*10;\n\tif(p==31) return n*n*11;\n\
    \tif(p==32) return n*n*12;\n\tif(p==33) return n*n*13;\n\tif(p==34) return n*n*14;\n\
    \tif(p==35) return n*n*15;\n\tif(p==36) return n*n*16;\n\tif(p==37) return n*n*17;\n\
    \tif(p==38) return n*n*18;\n\tif(p==39) return n*n*19;\n\tif(p==40) return n*n*20;\n\
    \tif(p==41) return n*n*21;\n\tif(p==42) return n*n*22;\n\tif(p==43) return n*n*n*2;\n\
    \tif(p==44) return n*n*n*3;\n\tif(p==45) return n*n*n*4;\n\tif(p==46) return n*n*n*5;\n\
    \tif(p==47) return n*n*n*6;\n\tif(p==48) return n*n*n*7;\n\t\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpauawlqij.d(69): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpauawlqij.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res;\n\tres =\
    \ n;\n\twhile(n>0) {\n\t\tif(n % p == 0) {\n\t\t\tres -= p;\n\t\t\tn /= p;\n\t\
    \t} else {\n\t\t\tn *= 2;\n\t\t\tres *= 2;\n\t\t}\n\t}\n\treturn res;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfw_w8dc7.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmpfw_w8dc7.__unittest_L32_C1() [0x427a79]

    ??:? void tmpfw_w8dc7.__modtest() [0x427b74]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long r = 1;\n  while\
    \ (p) {\n    r = r * (n % p + p) / p;\n    n /= p;\n  }\n  return r;\n}\n</code>\n\
    <|/ a tags=mod,c++,math |>\n<| a tags=mod,c++,math |>\nIn C++11, the algorithm\
    \ below is much faster\n<code>\ntemplate<typename T>\nT mod(T base, T modulus)\n\
    {\n    auto res = T(1);\n    for(auto d = 2; d < modulus; ++d)\n    {\n      \
    \  res *= base % modulus;\n        base /= modulus;\n    }\n    return res;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis method is also faster than the accepted\
    \ answer: https://godbolt.org/z/6NK8Y6\n<|/ c |>\n<| c |>\nThis does not give\
    \ the same result as the modulus operator in the case where base is larger than\
    \ modulus.  For example: mod((3L<<64)-1, 2L<<64)\n<|/ c |>\n<| a tags=mod,c++,math\
    \ |>\n<code>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_9qvejc2.d(26): Error: declaration expected, not `<`

    /tmp/tmp_9qvejc2.d(35): Error: declaration expected, not `for`

    /tmp/tmp_9qvejc2.d(35): Error: no identifier for declarator `d`

    /tmp/tmp_9qvejc2.d(35): Error: declaration expected, not `<`

    /tmp/tmp_9qvejc2.d(35): Error: declaration expected, not `++`

    /tmp/tmp_9qvejc2.d(38): Error: no identifier for declarator `base`

    /tmp/tmp_9qvejc2.d(38): Error: declaration expected, not `/=`

    /tmp/tmp_9qvejc2.d(39): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_9qvejc2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q = p % n;\n\t\
    if (q == 0)\n\t\treturn n;\n\tif (q == n)\n\t\treturn n - p;\n\treturn n - q;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4ynbkj9c.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ddd]

    ??:? void tmp4ynbkj9c.__unittest_L26_C1() [0x427a65]

    ??:? void tmp4ynbkj9c.__modtest() [0x427b60]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a996]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fab5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a96d]

    ??:? runModuleUnitTests [0x42b8d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42822c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q = long(1L);\n\
    \tif(p == 0)\n\t\treturn 0;\n\tif(p == 1)\n\t\treturn n;\n\tdo {\n\t\tif(p%2L\
    \ != 0)\n\t\t\tn = n%p;\n\t\telse\n\t\t\tn = q;\n\t\tq = q*q;\n\t\tp--;\n\t} while(n!=0);\n\
    \treturn n;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg2rxr8j_.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e15]

    ??:? void tmpg2rxr8j_.__unittest_L34_C1() [0x427a99]

    ??:? void tmpg2rxr8j_.__modtest() [0x427b94]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430010]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9a5]

    ??:? runModuleUnitTests [0x42b911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while(n>0) {\n        if (n & 1L) {\n            res = (res * p) % p;\n \
    \       }\n        n >>= 1L;\n        p = (p * p) % p;\n    }\n    return res;\n\
    }\n\"\"\"\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj8rj9d2p.d(29): Error: declaration expected, not `""`

    /tmp/tmpj8rj9d2p.d(29): Error: unterminated string constant starting at /tmp/tmpj8rj9d2p.d(29)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj8rj9d2p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p < 0)\n\t\tp\
    \ *= -1L;\n\tlong result = 1L;\n\twhile (n >= p) {\n\t\tresult *= p;\n\t\tn -=\
    \ p;\n\t}\n\treturn (n % p + result) % p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5l6xbprg.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427df5]

    ??:? void tmp5l6xbprg.__unittest_L28_C1() [0x427a7d]

    ??:? void tmp5l6xbprg.__modtest() [0x427b78]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb1b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ae]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb41]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42facd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a985]

    ??:? runModuleUnitTests [0x42b8f1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428244]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long result = 1;\n\
    \  while (1) {\n    result = result * 2;\n    if (result >= p)\n      result %=\
    \ p;\n    if (result == 0)\n      return result;\n  }\n}\n'''\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph2eye4_r.d(28): Error: unterminated character constant

    /tmp/tmph2eye4_r.d(28): Error: declaration expected, not `63U`

    /tmp/tmph2eye4_r.d(28): Error: unterminated character constant

    /tmp/tmph2eye4_r.d(33): Error: declaration expected, not `assert`

    /tmp/tmph2eye4_r.d(34): Error: declaration expected, not `assert`

    /tmp/tmph2eye4_r.d(35): Error: declaration expected, not `assert`

    /tmp/tmph2eye4_r.d(36): Error: declaration expected, not `assert`

    /tmp/tmph2eye4_r.d(37): Error: declaration expected, not `assert`

    /tmp/tmph2eye4_r.d(38): Error: declaration expected, not `assert`

    /tmp/tmph2eye4_r.d(39): Error: declaration expected, not `assert`

    /tmp/tmph2eye4_r.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph2eye4_r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164491
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn p == 0 ? n\
    \ : n % p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp54zyv83d.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dbd]

    ??:? void tmp54zyv83d.__unittest_L21_C1() [0x427a6b]

    ??:? void tmp54zyv83d.__modtest() [0x427b40]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bae3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a976]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb09]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa95]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a94d]

    ??:? runModuleUnitTests [0x42b8b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42820c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint sign = n < 0 ?\
    \ -1 : 1;\n\tn = abs(n);\n\tlong q = 0;\n\tlong r = n % p;\n\tif (r != 0) {\n\t\
    \twhile (r > 0) {\n\t\t\tq = q * 10 + n % p;\n\t\t\tr = r / p;\n\t\t}\n\t\tq >>=\
    \ 1;\n\t\tif (sign * q > n)\n\t\t\tq--;\n\t}\n\treturn q;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpotfomahl.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e95]

    ??:? void tmpotfomahl.__unittest_L34_C1() [0x427b05]

    ??:? void tmpotfomahl.__modtest() [0x427c18]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbbb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa4e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbe1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430090]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb6d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa25]

    ??:? runModuleUnitTests [0x42b991]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282e4]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = n;\n  \
    \  while(r < p){\n        r = r * 2;\n    }\n    return r;\n}\nunittest\n{\n \
    \   alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpa6anydss.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dc5]

    ??:? void tmpa6anydss.__unittest_L25_C1() [0x427a4d]

    ??:? void tmpa6anydss.__modtest() [0x427b48]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baeb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a97e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a955]

    ??:? runModuleUnitTests [0x42b8c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428214]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong result = 0;\n\
    \twhile(n > 0){\n\t\tif (n % 2 == 1) result += (n & 1);\n\t\tn /= 2;\n\t}\n\t\
    if (p < 2) return p;\n\treturn p + result;\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp2(3L, 5L)\n    3L\n    >>> modp2(1101L, 101L)\n \
    \   2L\n    >>> modp2(0L, 101L)\n    1L\n    >>> modp2(3L, 11L)\n    8L\n    >>>\
    \ modp2(100L, 101L)\n    1L\n    \n*/\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpth9dszq9.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e0d]

    ??:? void tmpth9dszq9.__unittest_L41_C1() [0x427a91]

    ??:? void tmpth9dszq9.__modtest() [0x427b8c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb59]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430008]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fae5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a99d]

    ??:? runModuleUnitTests [0x42b909]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42825c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return ((n % p)\
    \ != 0) ? modp(n % p, p) : n;\n}\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164507
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r = n & -p;\n\
    \tif(r < 0L)\n\t\tr = ~r + p;\n\treturn r;\n}\n/*\nGiven a number x, return its\
    \ representation in base b.\n    \n>>> intrep(b2i(3),10)\n3\n>>> intrep(b2i(8),10)\n\
    2\n>>> intrep(b2i(9),10)\n9\n>>> intrep(b2i(17),10)\n13\n>>> intrep(b2i(35),10)\n\
    3\n>>> intrep(b2i(985),10)\n2\n>>> intrep(b2i(99009),10)\n2\n>>> intrep(b2i(9900985),10)\n\
    3\n>>> intrep(b2i(99009856),10)\n2\n>>> intrep(b2i(99009856123),10)\n1\n*/\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpiqwqndlc.d(53): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmpiqwqndlc.__unittest_L48_C1() [0x427a7b]

    ??:? void tmpiqwqndlc.__modtest() [0x427b50]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long m = (long)((double)n)\
    \ % (long)p;\n    return (m == 0L) ? m : (p + 1 - m);\n}\n\"\"\";\n    }\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgv62xs6h.d(19): Error: C style cast illegal, use `cast(double)n`

    /tmp/tmpgv62xs6h.d(19): Error: C style cast illegal, use `cast(long)cast(double)n`

    /tmp/tmpgv62xs6h.d(19): Error: C style cast illegal, use `cast(long)p`

    /tmp/tmpgv62xs6h.d(22): Error: declaration expected, not `""`

    /tmp/tmpgv62xs6h.d(22): Error: unterminated string constant starting at /tmp/tmpgv62xs6h.d(22)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgv62xs6h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn (int)math::pow((double)n,\
    \ (double)p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd6_bf65h.d(19): Error: C style cast illegal, use `cast(int)math`

    /tmp/tmpd6_bf65h.d(19): Error: found `:` when expecting `;` following `return`
    statement

    /tmp/tmpd6_bf65h.d(19): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd6_bf65h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n == 0) {\n\
    \        return 0;\n    }\n    long maxPowerOf2 = (1L << Long.SIZE) / p;\n   \
    \ long p = p;\n    while ((n & p) == 0) {\n        n = (n >> 1);\n        p--;\n\
    \    }\n    return (n * maxPowerOf2) - p;\n}\n/*\n    Compute (2^n) % p using\
    \ arithmetic shift right for n < 32\n    \n    >>> modpshift(3L, 5L, 5L)\n   \
    \ 3L\n    >>> modpshift(1101L, 101L, 101L)\n    2L\n    >>> modpshift(0L, 101L,\
    \ 101L)\n    1L\n    >>> modpshift(3L, 11L, 11L)\n    8L\n    >>> modpshift(100L,\
    \ 101L, 101L)\n    1L\n    \n*/\nlong modpshift(long n, long p, long q) \n{\n\
    \    long mask = (1L << Long.SIZE) - 1;\n    if (n & mask == 0) {\n        if\
    \ (q == p) {\n            return n;\n        } else {\n            return (p *\
    \ p) - p;\n        }\n    } else {\n        n <<= Integer.BYTES;\n        mask\
    \ <<= Integer.BYTES;\n        long p1 = (p / mask);\n        long q1 = (p % mask);\n\
    \        long p2 = (p / (mask << 1));\n        long q2 = (p % (mask << 1));\n\
    \        long p3 = (p / (mask << 2));\n        long q3 = (p % (mask << 2));\n\
    \        long p4 = (p / (mask << 3));\n        long q4 = (p % (mask << 3));\n\
    \        long p5 = (p / (mask << 4));\n        long q5 = (p % (mask << 4));\n\
    \        long p6 = (p / (mask << 5));\n        long q6 = (p % (mask << 5));\n\
    \        long p7 = (p / (mask << 6));\n        long q7 = (p % (mask << 6));\n\
    \        long p8 = (p / (mask << 7));\n        long q8 = (p % (mask << 7));\n\
    \        long p9 = (p / (mask << 8));\n        long q9 = (p % (mask << 8));\n\
    \        long p10 = (p / (mask << 9));\n        long q10 = (p % (mask << 9));\n\
    \        long p11 = (p / (mask << 10));\n        long q11 = (p % (mask << 10));\n\
    \        long p12 = (p / (mask << 11));\n        long q12 = (p % (mask << 11));\n\
    \        long p13\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4grgl52e.d(48): Error: `mask == 0` must be parenthesized when next
    to operator `&`

    /tmp/tmp4grgl52e.d(82): Error: semicolon expected, not `unittest`

    /tmp/tmp4grgl52e.d(82): Error: found `unittest` instead of statement

    /tmp/tmp4grgl52e.d(94): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4grgl52e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int i, j, shift;\n\
    \    long x, r=1, s=0;\n    \n    shift = n * p;\n    \n    for (i = 0; i < shift;\
    \ i++) {\n        x = (x << 1) + n;\n        r ^= x;\n        s ^= x;\n    }\n\
    \    \n    if (shift < p)\n        r = modr(r, s);\n    \n    return r^p;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_26wfuwa.d(22): Error: cannot implicitly convert expression `n
    * p` of type `long` to `int`

    /tmp/tmp_26wfuwa.d(31): Error: undefined identifier `modr`, did you mean function
    `modp`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_26wfuwa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d;\n\tif (n <\
    \ p) {\n\t\td = n - p;\n\t\treturn (n + p - 1) / p;\n\t}\n\tif (n == p) return\
    \ 0;\n\td = p + n - (p + p) % n;\n\treturn d / n;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoe5e_bgi.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e0d]

    ??:? void tmpoe5e_bgi.__unittest_L28_C1() [0x427a91]

    ??:? void tmpoe5e_bgi.__modtest() [0x427b8c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb59]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430008]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fae5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a99d]

    ??:? runModuleUnitTests [0x42b909]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42825c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn (n >> p) +\
    \ (n & -p);\n}\n/*\nReturn a random integer between 0 and n-1.\n    \n    >>>\
    \ randrange(0, 101L)\n    4L\n    \n*/\nlong randrange(long n)\n{\n\treturn (int)std.math.random(n);\n\
    }\n/*\nReturn a random number between m and n-1 (inclusive).\n    \n    >>> randrange(2,\
    \ 101L)\n    3L\n    \n*/\nlong randrange(long m, long n)\n{\n\treturn randrange(m)\
    \ + (n - m);\n}\n/*\nReturn a random float between 0 and 1.\n    \n    >>> randfloat()\n\
    \    0.9401687363368665\n    \n*/\ndouble randfloat()\n{\n\treturn (double)std.math.random();\n\
    }\n/*\nReturn a random int between m and n-1 (inclusive).\n    \n    >>> randint2(2,\
    \ 101L)\n    3L\n    \n*/\nlong randint2(long m, long n)\n{\n\treturn randrange(m)\
    \ + (n - m);\n}\n/*\nReturn a random long between 0 and n-1.\n    \n    >>> randlong2(101L)\n\
    \    5L\n    \n*/\nlong randlong2(long n)\n{\n\treturn randrange(n);\n}\n/*\n\
    Return a random float between -1 and n (exclusive).\n    \n    >>> randint3(101L)\n\
    \    -0.9173268801866131\n    \n*/\ndouble randint3(long n)\n{\n\treturn (double)(std.math.random()\
    \ * ((double)n + (double)1));\n}\n/*\nReturn a random long between m and n (inclusive).\n\
    \    \n    >>> randint3(2, 101L)\n    2L\n    \n*/\nlong randint3(long m, long\
    \ n)\n{\n\treturn randrange(m) + (n - m);\n}\n/*\nReturn a random int between\
    \ m and n (inclusive).\n    \n    >>> randint3(2, 101L)\n    2L\n    \n*/\nlong\
    \ randint3(long m, long n)\n{\n\treturn randrange(m) + (n - m);\n}\n/*\nReturn\
    \ a random long between 0 and n (exclusive).\n    \n    >>> randint3(2, 101L)\n\
    \    2L\n    \n*/\nlong randint3(long m, long n)\n{\n\treturn randrange(m) + (n\
    \ - m);\n}\n/*\nReturn a random long between 0 and n (inclusive).\n    \n    >>>\
    \ randint3(2, 101L)\n    2L\n    \n*/\nlong randint3(long m, long n)\n{\n\treturn\
    \ randrange(m) + (n - m);\n\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjpkg7418.d(30): Error: C style cast illegal, use `cast(int)std.math.random(n)`

    /tmp/tmpjpkg7418.d(52): Error: C style cast illegal, use `cast(double)std.math.random()`

    /tmp/tmpjpkg7418.d(85): Error: C style cast illegal, use `cast(double)n`

    /tmp/tmpjpkg7418.d(85): Error: C style cast illegal, use `cast(double)1`

    /tmp/tmpjpkg7418.d(85): Error: C style cast illegal, use `cast(double)(std.math.random()
    * (cast(double)n + cast(double)1))`

    /tmp/tmpjpkg7418.d(131): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjpkg7418.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r, c;\n   \
    \ \n    c = n % p;\n    r = (n / p) - c;\n    if (r < 0) {\n        r %= p;\n\
    \        c = p - r;\n    }\n    \n    return (r << 1) + c;\n}\n// End of file\
    \ stdmodp.cpp\n// //////////////////////////////////////////////////////////////////\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=modulo,c++,bit-manipulation |>\nIn a 32-bit\
    \ (signed) machine, there is no way to represent negative numbers as integers,\
    \ since they require a larger number of bits.\nThe most straightforward way would\
    \ be to mask off the most significant bit in the integer, then shift the result\
    \ one bit to the right to get the desired result.\n<code>\n#include <iostream>\n\
    #include <stdint.h>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2jfa6ebd.d(32): Error: declaration expected, not `<`

    /tmp/tmp2jfa6ebd.d(44): Error: declaration expected, not `assert`

    /tmp/tmp2jfa6ebd.d(45): Error: declaration expected, not `assert`

    /tmp/tmp2jfa6ebd.d(46): Error: declaration expected, not `assert`

    /tmp/tmp2jfa6ebd.d(47): Error: declaration expected, not `assert`

    /tmp/tmp2jfa6ebd.d(48): Error: declaration expected, not `assert`

    /tmp/tmp2jfa6ebd.d(49): Error: declaration expected, not `assert`

    /tmp/tmp2jfa6ebd.d(50): Error: declaration expected, not `assert`

    /tmp/tmp2jfa6ebd.d(51): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2jfa6ebd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (p == 0) \n\t\t\
    return n;\n\t\n\tlong m = p + n - 1; \n\treturn (m % p + p) % p; \n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnkf1cjj3.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dd5]

    ??:? void tmpnkf1cjj3.__unittest_L25_C1() [0x427a59]

    ??:? void tmpnkf1cjj3.__modtest() [0x427b54]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bafb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a98e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a965]

    ??:? runModuleUnitTests [0x42b8d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428224]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong mask = 1;\n\t\
    long x = n;\n\tint sign;\n\twhile (x != 0) {\n\t\tif (x & 1) x = p * x + n;\n\t\
    \tsign = x >> 63;\n\t\tmask <<= 1;\n\t\tmask |= sign;\n\t}\n\treturn (n >> 63)\
    \ - mask;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164507
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long ans = 1;\n\
    \    long mask;\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc64vez8x.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc64vez8x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int t;\n    long\
    \ r;\n    \n    if (p == 0)\n\t{\n\t    r = 1L;\n\t}\n    else if (n == 0)\n\t\
    {\n\t    r = 0L;\n\t}\n    else\n\t{\n\t    t = (((p-1L) & (p-1L)) - 1L) % p;\n\
    \t    r = modp(n/p, p);\n\t    if (t != 0L)\n\t\t{\n\t\t    r = (r * (p-1L) +\
    \ t) % p;\n\t\t}\n\t}\n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0x90t7ys.d(32): Error: cannot implicitly convert expression `((p
    - 1L & p - 1L) - 1L) % p` of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0x90t7ys.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long rem;\n    if\
    \ (n >= p) { \n        long r = p + modp(p - n, p);\n        long s = n - p;\n\
    \        if (s <= 0) {\n            return r;\n        }\n        rem = (r * s\
    \ - r) / s;\n        if (rem < 0)\n            rem += p;\n        return rem +\
    \ 1;\n    }\n    return n;\n}\n</code>\n<|/ a |>\n<| c |>\nCan you explain a little\
    \ bit more about this solution? This code looks good but I have no idea what it\
    \ means.\n<|/ c |>\n<| c |>\nThis solution was created by [Jack Dorsey](http://stackoverflow.com/questions/2582712/modular-exponentiation-in-java#answer-2582825).\n\
    <|/ c |>\n<| c |>\nThe algorithm is pretty straight forward, it basically works\
    \ by repeatedly taking a \"square root\" (`sqrt(x) = floor(sqrt(x))`) of a number\
    \ until it has no remainder. Since you just want a power of two modulo `p`, this\
    \ only works when the modulus is prime. If it is a non-prime number, the algorithm\
    \ will repeat it until it does have a remainder.\n<|/ c |>\n<| c |>\nThis code\
    \ isn't working for me. It always return 1 when input is not even number.\n<|/\
    \ c |>\n<| c |>\nCan you please post a complete example and what input you are\
    \ using? I tried it with your example and it works.\n<|/ c |>\n<| a |>\nThe simplest\
    \ and fastest method I know of for raising numbers in modulo p is to first do\
    \ an exponentiation mod p, then take the result mod p.\n<code>\nlong modpow(long\
    \ n, long m, long p) {\n    long result = 1;\n    for (long i = 2; i <= n; i++)\
    \ {\n        result = modpow(i,m,p) * p;\n    }\n    return result % m;\n}\n</code>\n\
    <|/ a tags=java,modular-arithmetic dscore=3 |>\n<| c |>\nVery efficient implementation!\
    \ Thanks.\n<|/ c |>\n<| a |>\nI used the idea of a \"square root\" (sqrt(x)) and\
    \ solved it using the following algorithm:\nunittest\n{\n    alias candidate =\
    \ modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L)\
    \ == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L)\
    \ == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpay9gxj3_.d(33): Error: declaration expected, not `<`

    /tmp/tmpay9gxj3_.d(45): Error: unterminated character constant

    /tmp/tmpay9gxj3_.d(55): Error: declaration expected, not `for`

    /tmp/tmpay9gxj3_.d(55): Error: no identifier for declarator `i`

    /tmp/tmpay9gxj3_.d(55): Error: declaration expected, not `<=`

    /tmp/tmpay9gxj3_.d(55): Error: no identifier for declarator `i`

    /tmp/tmpay9gxj3_.d(55): Error: declaration expected, not `++`

    /tmp/tmpay9gxj3_.d(57): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpay9gxj3_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n < p) {\n\t\t\
    return 0;\n\t}\n\tlong q = p - 1L;\n\tlong r = n - p;\n\tlong d = (r + q) >> 1L;\n\
    \twhile (d != 0) {\n\t\tlong rem = r - d;\n\t\tr = d;\n\t\td = (rem + q) >> 1L;\n\
    \t}\n\treturn r + p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps0ksavov.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e05]

    ??:? void tmps0ksavov.__unittest_L32_C1() [0x427a8d]

    ??:? void tmps0ksavov.__modtest() [0x427b88]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb2b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9be]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb51]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430000]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fadd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a995]

    ??:? runModuleUnitTests [0x42b901]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428254]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = p & -p,\
    \ q;\n    \n    /* Make n positive */\n    if (r < n)\n    {\n\tq = n << 1;\n\t\
    do\n\t    q = q >> 1;\n\twhile (r < q);\n\tq = n >> 1;\n\tdo\n\t    q = q >> 1;\n\
    \twhile (r < q);\n\tr = q;\n    }\n    else\n    {\n\twhile (r >= n)\n\t    r\
    \ -= n;\n    }\n    \n    return r;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp0hbomq3o.d(46): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e1d]

    ??:? void tmp0hbomq3o.__unittest_L42_C1() [0x427aa1]

    ??:? void tmp0hbomq3o.__modtest() [0x427b9c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb43]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9d6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb69]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430018]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faf5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9ad]

    ??:? runModuleUnitTests [0x42b919]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42826c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\t// FIXME: handle NaN?\n\
    \tif (n >= p)\n\t\treturn n;\n\telse\n\t\treturn (n - p + 1) * p % n;\n}\n// end\
    \ \"modp.h\"\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9x5hfrnd.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dc5]

    ??:? void tmp9x5hfrnd.__unittest_L26_C1() [0x427a4d]

    ??:? void tmp9x5hfrnd.__modtest() [0x427b48]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baeb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a97e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a955]

    ??:? runModuleUnitTests [0x42b8c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428214]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint u;\n\tlong res;\n\
    \t\n\tres = n & p;\n\t\n\tfor (u = 3; u <= 64; u *= 2) {\n\t\tif (n >= u) {\n\t\
    \t\tres += 1;\n\t\t\tn -= u;\n\t\t}\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5pwzumrs.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ded]

    ??:? void tmp5pwzumrs.__unittest_L33_C1() [0x427a75]

    ??:? void tmp5pwzumrs.__modtest() [0x427b70]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a97d]

    ??:? runModuleUnitTests [0x42b8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42823c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long m = n;\n  \
    \  \n    while (m & 1L)\n\tm >>= 1L;\n    \n    long x = 0;\n    \n    while ((m\
    \ & 1L) != 0)\n\tm >>= 1L;\n    \n    for (;;) {\n\tx <<= 1L;\n\tm >>= 1L;\n\t\
    \n\tif (m == 0L)\n\t    break;\n\t\n\tif (n & 1L)\n\t    x |= 1L;\n\t\n\tif (m\
    \ != 0L)\n\t    m <<= 1L;\n    }\n    \n    return x % p;\n}\n/*\nReturn n^m modulo\
    \ p.\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    1L\n    >>>\
    \ modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n\
    \    1L\n    \n*/\nlong powm(long n, long m) {\n    long p = 1;\n    \n    while\
    \ (m & 1L)\n\tp <<= 1L;\n    \n    m >>= 1L;\n    \n    for (;;) {\n\tp <<= 1L;\n\
    \tm >>= 1L;\n\t\n\tif (m == 0L)\n\t    break;\n\t\n\tif (n & 1L)\n\t    p |= 1L;\n\
    \t\n\tif (m != 0L)\n\t    m <<= 1L;\n    }\n    \n    return p;\n}\n/*\nReturn\
    \ n^m modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>>\
    \ modp(1101L, 101L)\n    1L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nlong powm_m(long n,\
    \ long m) {\n    long p = 1;\n    \n    while (m & 1L)\n\tp <<= 1L;\n    \n  \
    \  m >>= 1L;\n    \n    for (;;) {\n\tp <<= 1L;\n\tm >>= 1L;\n\t\n\tif (m == 0L)\n\
    \t    break;\n\t\n\tif (n & 1L)\n\t    p |= 1L;\n\t\n\tif (m != 0L)\n\t    m <<=\
    \ 1L;\n    }\n    \n    return p;\n}\n/*\nReturn n^m modulo p (be aware of \n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiw409bht.d(121): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiw409bht.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long result = 1;\n\
    \    long base = 2;\n    while (true) {\n        long mask = (base << 1) ^ base;\n\
    \        if (n & mask) result ^= base;\n        base <<= 1;\n        n >>= 1;\n\
    \    }\n    if (p == 1)\n        return result;\n    else \n        return result\
    \ ^ modp(n >> 1, p);\n}\n\"\"\")\n        self.write_func_comment(\"\"\"\nReturns\
    \ modular multiplicative inverse: x^(-n) mod p.\n    \n    >>> modinv(16L, 5L)\
    \ # 16^-5 mod 5\n    2L\n    >>> modinv(2L, 5L) # 2^-5 mod 5\n    1L\n    >>>\
    \ modinv(5L, 2L) # 5^-2 mod 2\n    3L\n    >>> modinv(5L, 11L) # 5^-11 mod 11\n\
    \    2L\n    \nThe inverse of a prime modulo p is also the multiplicative inverse\
    \ of p modulo p.\n    \n    >>> modinv(4L, 5L)\n    1L\n    >>> modinv(4L, 2L)\n\
    \    3L\n    \nThe inverse of 0 is 1, and of 1 is 1.\n    \n    >>> modinv(0L,\
    \ 3L)\n    1L\n    >>> modinv(1L, 3L)\n    1L\n    \nThe inverse of -1 is 0.\n\
    \    \n    >>> modinv(-1, 3L)\n    0L\n    \n\"\"\");\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdtrkxob6.d(32): Error: declaration expected, not `""`

    /tmp/tmpdtrkxob6.d(64): Error: unterminated string constant starting at /tmp/tmpdtrkxob6.d(64)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdtrkxob6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tint i; \n\tlong res\
    \ = 1L;\n\tfor (i=0; i<n; i++) res *= p;\n\tres %= p;\n\tif (res == p) res ^=\
    \ p; // don't change sign\n\treturn res;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpliptw8fp.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dfd]

    ??:? void tmpliptw8fp.__unittest_L26_C1() [0x427a85]

    ??:? void tmpliptw8fp.__modtest() [0x427b80]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb23]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9b6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb49]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42fff8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fad5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a98d]

    ??:? runModuleUnitTests [0x42b8f9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42824c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong t = n >> 52;\n\
    \tn = (n - t*p) >> 52;\n\tn = (t + n*p + p) % (p - 1);\n\treturn n;\n}\n/*\nReturn\
    \ a random number between min (inclusive) and max (inclusive).\n    Max is exclusive\
    \ (so f(min) is different from f(max))\n    \n    >>> random(0)\n    0\n    >>>\
    \ random(10)\n    9\n    >>> random(-10, 5)\n    -5\n    \n*/\nlong random(long\
    \ min, long max)\n{\n\treturn min + (long)drand48() * (max - min);\n}\n/*\nReturn\
    \ a random number between min (inclusive) and max (inclusive).\n    Max is inclusive\
    \ (so f(min) == f(max))\n    \n    >>> randomint()\n    0\n    >>> randomint(10)\n\
    \    9\n    >>> randomint(-10, 5)\n    -5\n    \n*/\nlong randomint(long min,\
    \ long max)\n{\n\treturn random(min, max) + 1;\n}\n/*\nReturn a random element\
    \ of arr (which must be a vector of length n)\n    \n    >>> randomvec(\"\")\n\
    \    Traceback (most recent call last):\n        ...\n    IndexError: string index\
    \ out of range\n    \n    >>> randomvec([1, 2, 3, 4])\n    3\n    \n*/\nobject\
    \ randomvec(string arr)\n{\n\tint n = arr.length;\n\tint k = random(0, n);\n\t\
    return arr[k];\n}\n/*\nReturn a random element of arr (which must be a vector\
    \ of length n)\n    \n    >>> randomveclist([10, 11, 12, 13])\n    13\n    \n\
    */\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpywqqbwnv.d(38): Error: C style cast illegal, use `cast(long)drand48()`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpywqqbwnv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d;\n\t\n\td =\
    \ p - n;\n\tif (d > 0)\n\t{\n\t\tif (n < 0)\n\t\t\td = -d;\n\t\tn = n * 2;\n\t\
    \twhile (d % 2 != 0)\n\t\t\td = d / 2;\n\t\tn = n - 1;\n\t}\n\telse\n\t{\n\t\t\
    n = n * 2;\n\t\twhile (d % 2 != 0)\n\t\t\td = d / 2;\n\t\tn = n + 1;\n\t}\n\t\
    return n;\n}\n\t\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwd_7hwsl.d(45): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e5d]

    ??:? void tmpwd_7hwsl.__unittest_L41_C1() [0x427ae5]

    ??:? void tmpwd_7hwsl.__modtest() [0x427be0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb83]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa16]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fba9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430058]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb35]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9ed]

    ??:? runModuleUnitTests [0x42b959]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282ac]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long q = n / p;\n\
    \    return q*q % p;\n}\n/* \n* Return r**n (mod p), for integers n, p > 0.\n\
    * \n* For integers n, p > 0, r**n % p == r**n\n*/\nlong powr(long r, long n, long\
    \ p) \n{\n    return powrr_impl(r, n, p, r);\n}\n/*\nReturn r**n (mod p), for\
    \ integers n, p > 0, r <= MAX_R\n*/\nlong powr_impl(long r, long n, long p, long\
    \ MAX_R) {\n    int exponent;\n    if (n >= MAX_R) {\n        exponent = n;\n\
    \    }\n    else {\n        exponent = modp(MAX_R - n, p);\n    }\n    return\
    \ r * r * (exponent - p) % p;\n}\n/* Return 2**n (mod p), for integers n, p >\
    \ 0\n    \nFor integers n, p > 0, 2**n <= p\n*/\nlong pow2(long n, long p) {\n\
    \    return pow2_impl(n, p, n);\n}\n/*\nReturn 2**n (mod p), for integers n, p\
    \ > 0, r <= MAX_R\n*/\nlong pow2_impl(long n, long p, long MAX_R) {\n    long\
    \ maxexp;\n    long r;\n    if (n >= MAX_R) {\n        maxexp = MAX_R-1;\n   \
    \ }\n    else {\n        maxexp = modp(MAX_R-n, p);\n    }\n    r = powr_impl(2,\
    \ n, p, maxexp);\n    return r % p;\n}\n/*\nReturn n! (mod p). \n    \nFor integers\
    \ n, p > 0\n*/\nlong factorial(long n, long p) {\n    long p = p;\n    long r\
    \ = 1;\n    while (n > p) {\n        r = r * n % p;\n        n = n / p;\n    }\n\
    \    return r;\n}\n/*\nReturn n! (mod p). \n    \nFor integers n, p > 0\n*/\n\
    long factorial_impl(long n, long p) {\n    long maxexp;\n    long r;\n    if (n\
    \ >= p) {\n        maxexp = p - 1;\n    }\n    else {\n        maxexp = modp(n\
    \ - p, p);\n    }\n    r = factorial_impl(n, maxexp);\n    return r % p;\n}\n\
    /* Return sqrt(n)\n   \nFor integers n >= 0\n*/\nlong sqrt(long n) {\n    long\
    \ p = n;\n    long r = 1;\n    long m;\n    long t;\n    long sqexp;\n    while\
    \ (p > 0) {\n        m = p%10;\nunittest\n{\n    alias candidate = modp;\n\n \
    \   assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp72qz63w4.d(109): Error: found `unittest` instead of statement

    /tmp/tmp72qz63w4.d(121): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72qz63w4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (n < 0) return\
    \ 0L;\n    long res = 1L;\n    while ((n % p) == 0)\n    {\n        res = (res*2L)\
    \ % p;\n        n = n/p;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1db2qbxc.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ded]

    ??:? void tmp1db2qbxc.__unittest_L28_C1() [0x427a75]

    ??:? void tmp1db2qbxc.__modtest() [0x427b70]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a97d]

    ??:? runModuleUnitTests [0x42b8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42823c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    // TODO: improve\
    \ performance\n    long result = n & -p;\n    if (result != 0)\n        return\
    \ result + p;\n    \n    return result + p;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpacp6pqtl.d(30): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dcd]

    ??:? void tmpacp6pqtl.__unittest_L26_C1() [0x427a51]

    ??:? void tmpacp6pqtl.__modtest() [0x427b4c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baf3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a986]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb19]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faa5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a95d]

    ??:? runModuleUnitTests [0x42b8c9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42821c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif (n == 0L)\n\t{\n\
    \t\treturn 0L;\n\t}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkwd271tc.d(23): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkwd271tc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: -8
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong x, t;\n\t\n\t\
    x = n & p;\n\tt = n >> 32;\n\tif (x == 0)\n\t{\n\t\treturn 1L;\n\t}\n\treturn\
    \ std.math.pow(x * x, 32L) % (p % x) + t;\n}\nunittest\n{\n    alias candidate\
    \ = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1L;\n\
    \    while (n > 0) {\n        if (n & 1L) {\n            res = (res * p) % p;\n\
    \        }\n        n >>= 1;\n        p = (p * p) % p;\n    }\n    return res;\n\
    }\n#endif\n/* \n * Reverse a vector.\n * For each element in the vector v[i],\
    \ v[i] is swapped with v[(i + n) % v.len()]\n * \n * Returns 0 if the input vector\
    \ was null, or -1 if the input vector was too short\n * \n * Complexity: O(v.len())\n\
    \ */\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L)\
    \ == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4eovdax9.d(29): Error: declaration expected, not `#`

    /tmp/tmp4eovdax9.d(42): Error: declaration expected, not `assert`

    /tmp/tmp4eovdax9.d(43): Error: declaration expected, not `assert`

    /tmp/tmp4eovdax9.d(44): Error: declaration expected, not `assert`

    /tmp/tmp4eovdax9.d(45): Error: declaration expected, not `assert`

    /tmp/tmp4eovdax9.d(46): Error: declaration expected, not `assert`

    /tmp/tmp4eovdax9.d(47): Error: declaration expected, not `assert`

    /tmp/tmp4eovdax9.d(48): Error: declaration expected, not `assert`

    /tmp/tmp4eovdax9.d(49): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4eovdax9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q;\n\t\n\tif(p\
    \ == 0)\n\t\treturn 0;\n\tif(p == 1)\n\t\treturn n;\n\tif(p < 0)\n\t{\n\t\tif(n\
    \ < 0)\n\t\t{\n\t\t\tif(p == -1)\n\t\t\t\treturn n;\n\t\t\telse\n\t\t\t\treturn\
    \ 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(p == 0)\n\t\t\t\treturn n;\n\t\t\telse\n\
    \t\t\t\treturn 1;\n\t\t}\n\t}\n\tif(n == 0)\n\t\treturn 0;\n\tif(n == 1)\n\t\t\
    return p;\n\t\n\tq = n;\n\tp = p - 1;\n\t\n\twhile(p > 0)\n\t{\n\t\tq = q * p;\n\
    \t\tp = p - 1;\n\t}\n\t\n\tif(p == 1)\n\t\treturn q;\n\telse\n\t\treturn n - q;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9tqv9ibq.d(65): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e8d]

    ??:? void tmp9tqv9ibq.__unittest_L61_C1() [0x427b11]

    ??:? void tmp9tqv9ibq.__modtest() [0x427c0c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbb3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa46]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fbd9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430088]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb65]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa1d]

    ??:? runModuleUnitTests [0x42b989]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4282dc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q, r;\n\tif(n\
    \ == 0) \n\t{\n\t\treturn 0;\n\t}\n\tif(n == 1)\n\t{\n\t\treturn p;\n\t}\n\tq\
    \ = n / p;\n\tr = n % p;\n\tif(p % 2 == 1) \n\t{\n\t\tq = -q;\n\t}\n\treturn p\
    \ * q + r;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpexvoqm7_.d(41): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e15]

    ??:? void tmpexvoqm7_.__unittest_L36_C1() [0x427ac3]

    ??:? void tmpexvoqm7_.__modtest() [0x427b98]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430010]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9a5]

    ??:? runModuleUnitTests [0x42b911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return divrem(n,\
    \ p) >> 1;\n}\n\"\"\")\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbvfjenvf.d(21): Error: declaration expected, not `""`

    /tmp/tmpbvfjenvf.d(21): Error: unterminated string constant starting at /tmp/tmpbvfjenvf.d(21)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbvfjenvf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: -8
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r = n;\n  \
    \  long t = r;\n    while (t > 0) {\n\tr = r * p % modp((n-1)/t, p);\n\tt--;\n\
    \    }\n    return r;\n}\n/*\nReturn p * 2^n modulo p (be aware of numerics).\n\
    */\nlong mulp2p(long n, long p) \n{\n    long r = p;\n    long t = r;\n    while\
    \ (t > 0) {\n\tr = r * n % modp((n-1)/t, p);\n\tt--;\n    }\n    return r;\n}\n\
    /*\nReturn p * 2^(n-1) modulo p (be aware of numerics).\n*/\nlong mulp2p1(long\
    \ n, long p) \n{\n    long r = p;\n    long t = r;\n    while (t > 0) {\n\tr =\
    \ r * n % modp((n-1)/t, p);\n\tt--;\n    }\n    return r;\n}\nunittest\n{\n  \
    \  alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    if (p == 0) return\
    \ 0L;\n    return std.math.remainder(n, p);\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 3L)\n    8L\n    >>> modp(1101L, 1101L)\n  \
    \  1L\n    >>> modp(0L, 1101L)\n    1L\n    >>> modp(3L, 5L)\n    2L\n    >>>\
    \ modp(100L, 100L)\n    0L\n    \n*/\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp72ks4lu1.d(20): Error: cannot implicitly convert expression `remainder(cast(real)n,
    cast(real)p)` of type `real` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72ks4lu1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q;\n\t\n\tif\
    \ (p == 0) return 0;\n\tq = n % p;\n\treturn p + q;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoyll2znq.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dc5]

    ??:? void tmpoyll2znq.__unittest_L25_C1() [0x427a49]

    ??:? void tmpoyll2znq.__modtest() [0x427b44]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42baeb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a97e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb11]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffc0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa9d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a955]

    ??:? runModuleUnitTests [0x42b8c1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428214]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  return n%(p - 1);\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpon19n1ts.d(26): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dad]

    ??:? void tmpon19n1ts.__unittest_L21_C1() [0x427a57]

    ??:? void tmpon19n1ts.__modtest() [0x427b2c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bad3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a966]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42faf9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffa8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa85]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a93d]

    ??:? runModuleUnitTests [0x42b8a9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x4281fc]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return __gcd(n,\
    \ p);\n}\n/*\nReturn a new list containing every element that is >= to l, and\
    \ every element that is <= to l.\n    >>> rangei([0, 2], 3)\n    [(0, 1), (0,\
    \ 2), (1, 2)]\n    \n*/\nList<T> rangei(List<T> l, T to) \n{\n    List<T> r =\
    \ new List<T>(l.size());\n    r.add(l.head);\n    T current = l.head;\n    while\
    \ (current != to)\n    {\n        T next = current;\n        current = current.next;\n\
    \        r.add(next);\n    }\n    return r;\n}\n/*\nReturn a new list containing\
    \ every element that is >= to l, and every element that is <= to l.\n    >>> rangeu([0,\
    \ 2], 3)\n    [(0, 1), (1, 2), (0, 2)]\n    \n*/\nList<T> rangeu(List<T> l, T\
    \ to) \n{\n    List<T> r = new List<T>(l.size());\n    T current = l.head;\n \
    \   while (current != to)\n    {\n        T next = current;\n        current =\
    \ current.next;\n        r.add(next);\n    }\n    return r;\n}\n/*\nReturn a new\
    \ list containing every element that is >= to l, and every element that is <=\
    \ to l.\n    >>> ranges([0, 2], 3)\n    [(0, 1), (0, 2), (2, 3)]\n    \n*/\nList<T>\
    \ ranges(List<T> l, T to) \n{\n    List<T> r = new List<T>(l.size());\n    r.add(l.head);\n\
    \    T current = l.head;\n    while (current != to)\n    {\n        T next = current;\n\
    \        current = current.next;\n        r.add(next);\n    }\n    return r;\n\
    }\n/*\nReturn a new list containing every element that is >= to l, and every element\
    \ that is <= to l.\n    >>> rangep([0, 2], 3)\n    [(0, 1), (0, 2), (1, 3)]\n\
    \    \n*/\nList<T> rangep(List<T> l, T to) \n{\n    List<T> r = new List<T>(l.size());\n\
    \    r.add(l.head);\n    T current = l.head;\n    while (current != to)\n    {\n\
    \        T next = current;\n        current = current.next;\n        r.add(next);\n\
    \    }\n    return r;\n}\n/*\nReturn a new list containing every element that\
    \ is >= to l, and every element that is <= to l.\n    >>> ranged([0, 2], 3)\n\
    \    [(0, 1), (1, 2), (2, 3)]\n    \n*/\nList<T> ranged(List<T> l, T to) \n{\n\
    \    List<T> r = new List<T>(l.size());\n    r.add(l.head);\n    T current = l.head;\n\
    \nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4fxsoxqm.d(27): Error: no identifier for declarator `List`

    /tmp/tmp4fxsoxqm.d(27): Error: declaration expected, not `<`

    /tmp/tmp4fxsoxqm.d(30): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp4fxsoxqm.d(30): Error: no identifier for declarator `r.add(l.head)`

    /tmp/tmp4fxsoxqm.d(32): Error: declaration expected, not `while`

    /tmp/tmp4fxsoxqm.d(35): Error: no identifier for declarator `current`

    /tmp/tmp4fxsoxqm.d(35): Error: declaration expected, not `=`

    /tmp/tmp4fxsoxqm.d(36): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp4fxsoxqm.d(36): Error: no identifier for declarator `r.add(next)`

    /tmp/tmp4fxsoxqm.d(37): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4fxsoxqm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    \n    if (n <= 0\
    \ || p <= 0) {\n        throw new IllegalArgumentException(\"modulus must be positive\"\
    );\n    }\n    \n    return ((long)n & (-p)) + (long)((long)n * (long)p >> 32);\n\
    }\n\"\"\"\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnu36bf18.d(24): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmpnu36bf18.d(24): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmpnu36bf18.d(24): Error: C style cast illegal, use `cast(long)p`

    /tmp/tmpnu36bf18.d(24): Error: C style cast illegal, use `cast(long)(cast(long)n
    * cast(long)p >> 32)`

    /tmp/tmpnu36bf18.d(26): Error: declaration expected, not `""`

    /tmp/tmpnu36bf18.d(26): Error: unterminated string constant starting at /tmp/tmpnu36bf18.d(26)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnu36bf18.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long res = 1;\n\
    \    while (n >= p) {\n        res *= p;\n        n -= p;\n    }\n    return ((n\
    \ - p) % p) + p;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7yqkrwdc.d(31): unittest failure

    ----------------

    ??:? _d_unittestp [0x427de5]

    ??:? void tmp7yqkrwdc.__unittest_L26_C1() [0x427a93]

    ??:? void tmp7yqkrwdc.__modtest() [0x427b68]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb0b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a99e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb31]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fabd]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a975]

    ??:? runModuleUnitTests [0x42b8e1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428234]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return modp(new\
    \ long[n], p).n[0];\n}\npublic struct __modp {\n    public long[] n;\n    public\
    \ __modp(long _n, long _p) \n    {\n        n = new long[_n / _p + 1];\n     \
    \   long a = _n % _p;\n        n[_n / _p] = 0;\n        if (a == 0) \n       \
    \ {\n            long b = 1;\n            int k = 0;\n            while (a !=\
    \ 0) {\n                n[k++] = a % _p;\n                a = (a / _p) * b;\n\
    \                b *= _p;\n            }\n        }\n        else {\n        \
    \    long a = 1;\n            int k = 0;\n            while (a != 0) {\n     \
    \           n[k++] = a % _p;\n                a = (a / _p) * a;\n            \
    \    a *= _p;\n            }\n        }\n    }\n}\nstatic final __modp modp =\
    \ new __modp(1L, 101L);\n// end\nunittest\n{\n    alias candidate = modp;\n\n\
    \    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps0_babx3.d(23): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmps0_babx3.d(24): Error: no identifier for declarator `__modp(long _n, long
    _p)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps0_babx3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong ret = 1;\n\t\
    while(n) {\n\t\tret = p * ret;\n\t\tn &= n - 1;\n\t}\n\treturn ret;\n}\n/*\n \
    \   Return sum of two longs modulo p. Beware of overflow.\n    >>> sum3mod(100L,\
    \ 101L)\n    1L\n*/\nlong sum3mod(long x, long y) \n{\n\tlong sum;\n\tsum = x+y;\n\
    \treturn sum % modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpypaalv_e.d(36): Error: expression expected, not `unittest`

    /tmp/tmpypaalv_e.d(37): Error: found `{` when expecting `,`

    /tmp/tmpypaalv_e.d(38): Error: expression expected, not `alias`

    /tmp/tmpypaalv_e.d(38): Error: found `candidate` when expecting `,`

    /tmp/tmpypaalv_e.d(38): Error: expression expected, not `=`

    /tmp/tmpypaalv_e.d(38): Error: found `modp` when expecting `,`

    /tmp/tmpypaalv_e.d(38): Error: expression expected, not `;`

    /tmp/tmpypaalv_e.d(40): Error: found `assert` when expecting `,`

    /tmp/tmpypaalv_e.d(40): Error: found `;` when expecting `,`

    /tmp/tmpypaalv_e.d(41): Error: found `;` when expecting `,`

    /tmp/tmpypaalv_e.d(42): Error: found `;` when expecting `,`

    /tmp/tmpypaalv_e.d(43): Error: found `;` when expecting `,`

    /tmp/tmpypaalv_e.d(44): Error: found `;` when expecting `,`

    /tmp/tmpypaalv_e.d(45): Error: found `;` when expecting `,`

    /tmp/tmpypaalv_e.d(46): Error: found `;` when expecting `,`

    /tmp/tmpypaalv_e.d(47): Error: expression expected, not `}`

    /tmp/tmpypaalv_e.d(48): Error: found '
  stdout: ''
  timestamp: 1660164492
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long rem, t;\n \
    \   /* Find modulus */\n    t = n*p;\n    rem = ((t+1)&(t-1));\n    if (rem ==\
    \ 0) {\n        return 1;\n    } else {\n        return (rem-1L) / p;\n    }\n\
    }\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n   \
    \ 3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>>\
    \ modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp2zy0kezd.d(47): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ddd]

    ??:? void tmp2zy0kezd.__unittest_L43_C1() [0x427a61]

    ??:? void tmp2zy0kezd.__modtest() [0x427b5c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb03]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a996]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb29]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fab5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a96d]

    ??:? runModuleUnitTests [0x42b8d9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42822c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res = 1;\n\t\
    long mask = 1;\n\tlong tmp = n - p;\n\twhile(mask > 0) {\n\t\tres = (res * tmp)\
    \ % p;\n\t\tmask = (mask * 10L) % p;\n\t}\n\treturn res;\n}\nunittest\n{\n   \
    \ alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4nv13b5j.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ded]

    ??:? void tmp4nv13b5j.__unittest_L28_C1() [0x427a75]

    ??:? void tmp4nv13b5j.__modtest() [0x427b70]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a97d]

    ??:? runModuleUnitTests [0x42b8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42823c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: -1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long d = n - p;\n\
    \  if(d < 0) return p - modp(d, p);\n  if(d >= p) return n;\n  \n  long r = 1;\n\
    \  while(d != 0) {\n    d = d / 2;\n    r = r * 2;\n  }\n  \n  return r;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660164508
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r;\n\tn = long(n);\n\
    \tp = long(p);\n\tr = (n&(1L<<p)) - 1;\n\treturn r;\n}\nunittest\n{\n    alias\
    \ candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwhw_czqk.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dbd]

    ??:? void tmpwhw_czqk.__unittest_L25_C1() [0x427a41]

    ??:? void tmpwhw_czqk.__modtest() [0x427b3c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bae3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a976]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb09]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffb8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fa95]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a94d]

    ??:? runModuleUnitTests [0x42b8b9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42820c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  long r = n;\n  long\
    \ m = 0;\n  while(m < (long)(p - 1)) {\n    r <<= 1;\n    m ++;\n  }\n  m %= p;\n\
    \  while(m > 0) {\n    r <<= 1;\n    m --;\n  }\n  return r;\n}\n</code>\n<|/\
    \ a tags=math,modular-arithmetic,bit-manipulation,java,c++ |>\n<| c |>\nYour implementation\
    \ is buggy, it fails for mod 2 with your example, it returns 1 for 2L.\n<|/ c\
    \ |>\n<| c |>\nThe OP was only looking for the modulo operation. Anything else\
    \ would probably be an overkill and in any case this kind of answer is frowned\
    \ upon.\n<|/ c |>\n<| a |>\nThe question was originally tagged C and C++.\nIn\
    \ the C language:\n<code>\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9y8n_m8i.d(21): Error: C style cast illegal, use `cast(long)(p
    - 1)`

    /tmp/tmp9y8n_m8i.d(32): Error: declaration expected, not `<`

    /tmp/tmp9y8n_m8i.d(48): Error: declaration expected, not `assert`

    /tmp/tmp9y8n_m8i.d(49): Error: declaration expected, not `assert`

    /tmp/tmp9y8n_m8i.d(50): Error: declaration expected, not `assert`

    /tmp/tmp9y8n_m8i.d(51): Error: declaration expected, not `assert`

    /tmp/tmp9y8n_m8i.d(52): Error: declaration expected, not `assert`

    /tmp/tmp9y8n_m8i.d(53): Error: declaration expected, not `assert`

    /tmp/tmp9y8n_m8i.d(54): Error: declaration expected, not `assert`

    /tmp/tmp9y8n_m8i.d(55): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9y8n_m8i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\treturn 1L & ((long)n)\
    \ % ((long)p) ;\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5ujq7_2y.d(19): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmp5ujq7_2y.d(19): Error: C style cast illegal, use `cast(long)p`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5ujq7_2y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long ret = n;\n\
    \    while(ret && ret % p) \n        ret /= p;\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpy46av85g.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dd5]

    ??:? void tmpy46av85g.__unittest_L24_C1() [0x427a5d]

    ??:? void tmpy46av85g.__modtest() [0x427b58]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bafb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a98e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a965]

    ??:? runModuleUnitTests [0x42b8d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428224]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong d = n % p;\n\t\
    n /= p;\n\tif (d > 0)\n\t\tn++;\n\treturn n;\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9svxxziu.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x427dd5]

    ??:? void tmp9svxxziu.__unittest_L39_C1() [0x427a5d]

    ??:? void tmp9svxxziu.__modtest() [0x427b58]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bafb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a98e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb21]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffd0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faad]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a965]

    ??:? runModuleUnitTests [0x42b8d1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428224]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int k = (int)n;\n\
    \    long r, r2;\n    \n    if (k < 0) \n    {\n        PyErr_SetString(PyExc_ValueError,\
    \ \"modp() arg 1 must be >= 0\");\n        return 1;\n    }\n    \n    if (k >=\
    \ p)\n    {\n        return 0;\n    }\n    \n    r = 1;\n    r2 = p;\n    while\
    \ (k > 0) \n    {\n        r <<= 1;\n        r += (r2 & 1);\n        r2 >>= 1;\n\
    \        k >>= 1;\n    }\n    return r;\n}\nunittest\n{\n    alias candidate =\
    \ modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L)\
    \ == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L)\
    \ == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmr5ex11t.d(19): Error: C style cast illegal, use `cast(int)n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmr5ex11t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long m = 2;\n  \
    \  while(p % m == 0)\n        m = m*2;\n    return ((n%m) + m - 1L) % m;\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpc6xl18qj.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x427ded]

    ??:? void tmpc6xl18qj.__unittest_L24_C1() [0x427a75]

    ??:? void tmpc6xl18qj.__modtest() [0x427b70]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb13]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9a6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb39]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x42ffe8]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fac5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a97d]

    ??:? runModuleUnitTests [0x42b8e9]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42823c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n == 0) return\
    \ 0;\n\tif(n == 1) return p;\n\tlong q, r;\n\tif(p == 1) return 1;\n\tif(p ==\
    \ 0) return 0;\n\tq = modp(n >> 1, p); \n\tr = n % p; \n\treturn ((n ^ q) * p\
    \ + r) % p; \n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfni6fx5i.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e15]

    ??:? void tmpfni6fx5i.__unittest_L28_C1() [0x427ac3]

    ??:? void tmpfni6fx5i.__modtest() [0x427b98]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb3b]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9ce]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb61]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430010]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42faed]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a9a5]

    ??:? runModuleUnitTests [0x42b911]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428264]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    return ((long) n)\
    \ % (long) p;\n}\n</code>\n<|/ a |>\n<| c |>\nYour modp function works fine for\
    \ positive numbers, where as Python uses modular inverse for negative numbers.\n\
    <|/ c |>\n<| c |>\nThis works fine for positive numbers, but not for negative\
    \ numbers. Just use Math.abs(): https://pastebin.com/ZgZ4uFXA\n<|/ c |>\n<| a\
    \ dscore=4 |>\n<code>\ndef modular_inverse(a, p):\n    \"\"\" Return modular inverse\
    \ of 'a' in base 'p'.\n    >>> modular_inverse(2, 3)\n    1\n    \"\"\"\n    q,\
    \ r = divmod(a, p)\n    if r == 0: return q\n    inverse = pow(p, q-1, p)\n  \
    \  if a == inverse:\n        # Extremely rare case, but we'll take a guess for\
    \ it.\n        return modular_inverse(a, q)\n    return inverse\n</code>\n<|/\
    \ a tags=algorithm,python,modular |>\n<| a |>\nHere's a working Python version\
    \ which doesn't use any external libraries:\n<code>\ndef modinv(a, m):\n    m,\
    \ n = divmod(a, m)\n    if m == 0:\n        return a\n    elif n == 0:\n     \
    \   return modinv(a, m)\n    else:\n        return modinv(a, (m*m)%m)\n</code>\n\
    For positive integers, the above will work just fine. If m is a negative number,\
    \ it will fail. \n<code>\n>>> modinv(7, 12)\n17\n>>> modinv(7, -7)\n-7\n</code>\n\
    <|/ a tags=algorithm,python,modular dscore=4 |>\n<| c |>\nGreat! I love Python.\n\
    <|/ c |>\n<| c |>\n`modinv()` doesn't work for negative integers though\n<|/ c\
    \ |>\n<| a tags=algorithm,python,modular |>\n<code>\ndef modinv(x, m):\n    x,\
    \ m = abs(x), abs(m)\n    if m == 2:\n        if x == 1: return x\n        if\
    \ x%2 == 0: return 1\n        if x%2 == 1: return x\n    m, n = divmod(x, m)\n\
    \    if m == 0: return m\n    if n == 0:\n        return modinv(x, m)\n    return\
    \ modinv(x*x, m%m)\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9s3cgyax.d(19): Error: C style cast illegal, use `cast(long)n`

    /tmp/tmp9s3cgyax.d(19): Error: C style cast illegal, use `cast(long)p`

    /tmp/tmp9s3cgyax.d(21): Error: declaration expected, not `<`

    /tmp/tmp9s3cgyax.d(40): Error: unterminated character constant

    /tmp/tmp9s3cgyax.d(46): Error: unterminated character constant

    /tmp/tmp9s3cgyax.d(46): Error: unterminated character constant

    /tmp/tmp9s3cgyax.d(69): Error: unterminated character constant

    /tmp/tmp9s3cgyax.d(88): Error: declaration expected, not `assert`

    /tmp/tmp9s3cgyax.d(89): Error: declaration expected, not `assert`

    /tmp/tmp9s3cgyax.d(90): Error: declaration expected, not `assert`

    /tmp/tmp9s3cgyax.d(91): Error: declaration expected, not `assert`

    /tmp/tmp9s3cgyax.d(92): Error: declaration expected, not `assert`

    /tmp/tmp9s3cgyax.d(93): Error: declaration expected, not `assert`

    /tmp/tmp9s3cgyax.d(94): Error: declaration expected, not `assert`

    /tmp/tmp9s3cgyax.d(95): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long rem;\n    \n\
    \    rem = n % p;\n    if (rem == 0) {\n        if (n >= p)\n            return\
    \ n;\n    }\n    if (rem == p) {\n        n /= p;\n        n--;\n        if (n\
    \ < 0) {\n            n = p + n;\n        }\n    }\n    return n * p;\n}\nunittest\n\
    {\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmppnclr0_6.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x427e0d]

    ??:? void tmppnclr0_6.__unittest_L35_C1() [0x427a91]

    ??:? void tmppnclr0_6.__modtest() [0x427b8c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bb33]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42a9c6]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fb59]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430008]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fae5]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42a99d]

    ??:? runModuleUnitTests [0x42b909]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x42825c]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    long r;\n    bool\
    \ s = n % p;\n    if (s == 0) return n;\n    if (s == 1) return n - p;\n    if\
    \ (p % 2 == 0) {\n        r = modp(n/2, p);\n        return r*r + n;\n    } else\
    \ {\n        r = modp((n - 1)/2, p);\n        return r*r + n + 1L;\n    }\n}\n\
    unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n\
    \    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L) ==\
    \ 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4ztcjkrv.d(20): Error: cannot implicitly convert expression `n
    % p` of type `long` to `bool`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4ztcjkrv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n  return std.int.__pow__(std.int.__pow__(2,\
    \ n), p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp49kso4_o.d(19): Error: identifier expected following `.`, not `int`

    /tmp/tmp49kso4_o.d(19): Error: identifier expected following `.`, not `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp49kso4_o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: -8
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong r = 1L;\n\twhile\
    \ (n > 0L) {\n\t\tif (n & 1L) \n\t\t\tr = (r * p) % p;\n\t\tn = n >> 1;\n\t\t\
    p = (p * p) % p;\n\t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\t/*\n\tmodpow:\n\t\
    http://en.wikipedia.org/wiki/Modulo_operation\n\thttp://www.delorie.com/gnu/docs/gcc-4.6/lib/gcc/test/IntlTests/intltest-long-modpow.html\n\
    \t*/\n\tif(p == 1)\n\t\treturn n;\n\tif(p == 0)\n\t\treturn 0;\n\tif(p < 0)\n\t\
    \tp = -p;\n\tif(n == 0)\n\t\treturn 0;\n\tif(n < 0)\n\t\treturn modpow(-n, p);\n\
    \tlong ret = 0;\n\tlong a = n;\n\tlong b = p;\n\twhile(a != 0) {\n\t\tlong t =\
    \ b%a;\n\t\tret += t;\n\t\tb /= a;\n\t}\n\treturn p*ret + n;\n}\nunittest\n{\n\
    \    alias candidate = modp;\n\n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L,\
    \ 101L) == 2L);\n    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L,\
    \ 11L) == 8L);\n    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L,\
    \ 5L) == 4L);\n    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu8zt0q_n.d(33): Error: undefined identifier `modpow`, did you mean
    function `modp`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu8zt0q_n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong q;\n\tn = n %\
    \ p;\n\tif(n == 0) \n\t\treturn n;\n\t\n\tif(p == 1) \n\t\treturn n;\n\t\n\tif(p\
    \ == 2) \n\t\treturn 2L;\n\t\n\tif(p == q) \n\t\treturn n;\n\t\n\tif(p == q +\
    \ 1) \n\t\treturn n - ((n - q) % p);\n\t\n\tif(p == q + 2) \n\t\treturn n - 1;\n\
    \t\n\tq = p / 2;\n\treturn modp(n, q) + modp((n - p * q) % p, q);\n}\n/* \n  \
    \  Find the least common multiple of n and p.\n    >>> lcm(5L, 10L)\n    10L\n\
    \    >>> lcm(101L, 10L)\n    10L\n    >>> lcm(0L, 10L)\n    0L\n    >>> lcm(100L,\
    \ 101L)\n    100L\n    \n*/\nlong lcm(long n, long p) \n{\n\treturn n * p / modp(n,\
    \ p);\n}\n/* \n    Find the least common multiple of n and p.\n    >>> lcm(5L,\
    \ 10L)\n    10L\n    >>> lcm(101L, 10L)\n    10L\n    >>> lcm(0L, 10L)\n    0L\n\
    \    >>> lcm(100L, 101L)\n    100L\n    \n*/\nlong lcm(long n, long p, long q)\
    \ \n{\n\treturn n * p / modp(n, p) * q / modp(q, p);\n}\n/* \n    Find the least\
    \ common multiple of n and p.\n    >>> lcm(5L, 10L)\n    10L\n    >>> lcm(101L,\
    \ 10L)\n    10L\n    >>> lcm(0L, 10L)\n    0L\n    >>> lcm(100L, 101L)\n    100L\n\
    \    \n*/\nlong lcm(long n, long p, long q, long r) \n{\n\treturn n * p / modp(n,\
    \ p) * q / modp(q, p) * r / modp(r, q);\n}\n/* \n    Find the least common multiple\
    \ of n and p.\n    >>> lcm(5L, 10L)\n    10L\n    >>> lcm(101L, 10L)\n    10L\n\
    \    >>> lcm(0L, 10L)\n    0L\n    >>> lcm(100L, 101L)\n    100L\n    \n*/\nlong\
    \ lcm(long n, long p, long q, long r, long s) \n{\n\treturn n * p / modp(n, p)\
    \ * q / modp(q, p) * r / modp\nunittest\n{\n    alias candidate = modp;\n\n  \
    \  assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgeb1zo0k.d(105): Error: found `unittest` when expecting `;` following
    `return` statement

    /tmp/tmpgeb1zo0k.d(117): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgeb1zo0k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong res;\n\tlong\
    \ mask = ~((long) p);\n\tn &= mask;\n\t\n\tif (n & 1) {\n\t\tn = (n - 1) ^ mask;\n\
    \t} else {\n\t\tn = (n - 1);\n\t}\n\t\n\tres = (n << 31) | (n >> 31);\n\treturn\
    \ res;\n}\n/*\nReturn the floor of n modulo p.\n    >>> floorp(3L, 5L)\n    3L\n\
    \    >>> floorp(1101L, 101L)\n    1L\n    >>> floorp(0L, 101L)\n    0L\n    >>>\
    \ floorp(3L, 11L)\n    3L\n    >>> floorp(100L, 101L)\n    0L\n    \n*/\nlong\
    \ floorp(long n, long p)\n{\n\tlong mask = (~((long) p));\n\tn &= mask;\n\t\n\t\
    if (n & 1) {\n\t\tn = (n - 1) ^ mask;\n\t} else {\n\t\tn = (n - 1);\n\t}\n\t\n\
    \treturn n;\n}\n/*\nReturn the ceiling of n modulo p.\n    >>> ceilingp(3L, 5L)\n\
    \    5L\n    >>> ceilingp(1101L, 101L)\n    1L\n    >>> ceilingp(0L, 101L)\n \
    \   1L\n    >>> ceilingp(3L, 11L)\n    3L\n    >>> ceilingp(100L, 101L)\n    1L\n\
    \    \n*/\nlong ceilingp(long n, long p)\n{\n\tlong mask = (~((long) p));\n\t\
    n &= mask;\n\t\n\tif (!(n & 1)) {\n\t\tn = (n - 1) ^ mask;\n\t} else {\n\t\tn\
    \ = (n - 1);\n\t}\n\t\n\treturn n;\n}\nunittest\n{\n    alias candidate = modp;\n\
    \n    assert(candidate(3L, 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n\
    \    assert(candidate(0L, 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n\
    \    assert(candidate(100L, 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n\
    \    assert(candidate(31L, 5L) == 3L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfd22s5as.d(20): Error: C style cast illegal, use `cast(long)p`

    /tmp/tmpfd22s5as.d(48): Error: C style cast illegal, use `cast(long)p`

    /tmp/tmpfd22s5as.d(75): Error: C style cast illegal, use `cast(long)p`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfd22s5as.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164493
- exit_code: 0
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n    int res = 1L;\n\
    \    while (n-- != 0) {\n        res = (2*res) % p;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
    \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
    \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
    \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
    \ == 3L);\n}\nvoid main(){}"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660164493
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tif(n == 0) return\
    \ 0;\n\tif(n == 1) return 1;\n\tif(p == 0) return n;\n\treturn p%n+modp(n-1, p);\n\
    }\n/*\n>>> mod(1L, 5L)\n5L\n>>> mod(1101L, 101L)\n1L\n>>> mod(0L, 101L)\n0L\n\
    >>> mod(3L, 11L)\n3L\n>>> mod(100L, 101L)\n0L\n>>> mod(1L, 5L)\n5L\n*/\nlong mod(long\
    \ n, long p) \n{\n\tif(n == 0) return 0;\n\tif(n == 1) return n;\n\tif(p == 0)\
    \ return n;\n\tif(p == 1) return 1;\n\tif(p == 2) return n-1;\n\treturn p%n+mod(n-1,\
    \ p);\n}\nunittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L,\
    \ 5L) == 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L,\
    \ 101L) == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L,\
    \ 101L) == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L,\
    \ 5L) == 3L);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpky89_9yr.d(51): unittest failure

    ----------------

    ??:? _d_unittestp [0x427eb5]

    ??:? void tmpky89_9yr.__unittest_L47_C1() [0x427b39]

    ??:? void tmpky89_9yr.__modtest() [0x427c34]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42bbdb]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42aa6e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x42fc01]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4300b0]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x42fb8d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42aa45]

    ??:? runModuleUnitTests [0x42b9b1]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428304]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164493
