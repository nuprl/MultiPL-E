name: HumanEval_111_histogram
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nGiven a string representing a\
  \ space separated lowercase letters, return an associative array\n    of the letter\
  \ with the most repetition and containing the corresponding count.\n    If several\
  \ letters have the same occurrence, return all of them.\n    \n    Example:\n  \
  \  >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n  \
  \  >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
  a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\"\
  )\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___\n\n  \
  \  \n*/\nNullable!(long[string]) histogram(string test) \n"
tests: "unittest\n{\n    alias candidate = histogram;\n\n{\n        auto result =\
  \ candidate(\"a b b a\");\n        assert(!result.isNull && result.get == [\"a\"\
  : 2L, \"b\": 2L]);\n}\n\n{\n        auto result = candidate(\"a b c a b\");\n  \
  \      assert(!result.isNull && result.get == [\"a\": 2L, \"b\": 2L]);\n}\n\n{\n\
  \        auto result = candidate(\"a b c d g\");\n        assert(!result.isNull\
  \ && result.get == [\"a\": 1L, \"b\": 1L, \"c\": 1L, \"d\": 1L, \"g\": 1L]);\n}\n\
  \n{\n        auto result = candidate(\"r t g\");\n        assert(!result.isNull\
  \ && result.get == [\"r\": 1L, \"t\": 1L, \"g\": 1L]);\n}\n\n{\n        auto result\
  \ = candidate(\"b b b b a\");\n        assert(!result.isNull && result.get == [\"\
  b\": 4L]);\n}\n\n{\n        auto result = candidate(\"r t g\");\n        assert(!result.isNull\
  \ && result.get == [\"r\": 1L, \"t\": 1L, \"g\": 1L]);\n}\n\n{\n        auto result\
  \ = candidate(\"\");\n        assert(result.isNull);\n}\n\n{\n        auto result\
  \ = candidate(\"a\");\n        assert(!result.isNull && result.get == [\"a\": 1L]);\n\
  }\n\n}\nvoid main(){}"
completions: ["{\n    var histogram = std.typecons.nil;\n    var freqs = std.typecons.nil;\n\
    \    \n    // Split the string and find all letters.\n    // Build a histogram\
    \ for each letter with the number of occurrences.\n    foreach(split(test, \"\
    \ \"), \n           function(elt)\n           {\n               foreach(split(elt,\
    \ \" \"), \n                    function(e)\n                    {\n         \
    \               \n                        if(!std.typecons.isLetter(e))\n    \
    \                    {\n                            throw(ArgumentError(\"histogram\
    \ expects a string with only letters\"));\n                        }\n       \
    \                 \n                        var letter = std.typecons.first(e);\n\
    \                        \n                        if(!std.typecons.isLetter(letter))\n\
    \                        {\n                            throw(ArgumentError(\"\
    histogram expects a string with only letters\"));\n                        }\n\
    \                        \n                        var count = std.typecons.count(e);\n\
    \                        \n                        if(!std.typecons.isLong(count))\n\
    \                        {\n                            throw(ArgumentError(\"\
    histogram expects a number as count\"));\n                        }\n        \
    \                \n                        \n                        if(std.typecons.compare(histogram,\
    \ letter) == 0)\n                        {\n                            var value\
    \ = std.typecons.toLong(histogram) + std.typecons.toLong(count);\n           \
    \                 \n                            if(std.typecons.compare(freqs,\
    \ value) == 0)\n                            {\n                              \
    \  freqs = std.typecons.toLong(freqs); \n                                freqs\
    \ = std.typecons.toLong(freqs); \n                                freqs = std.typecons.toLong(freqs);\
    \ \n                                freqs = std.typecons.toLong(freqs); \n   \
    \                         }\n                            \n                  \
    \          histogram = std.typecons.toLong(histogram); \n                    \
    \        histogram = std.typecons.toLong(histogram); \n                      \
    \      histogram = std.typecons.toLong(histogram); \n                        \
    \    histogram = std.typecons.toLong(histogram); \n                          \
    \  \n                            histogram = std.typecons.toLong(histogram); \n\
    \                            histogram = std.typecons.toLong(histogram); \n  \
    \                          \n                        }\n                     \
    \   else\n                        {\n                            \n          \
    \                  histogram = std.typecons.toLong(histogram); \n            \
    \                histogram = std.typecons.toLong(histogram); \n              \
    \              histogram = std.typecons.toLong(histogram); \n                \
    \            \n                            histogram = std.typecons.toLong(histogram);\
    \ \n                            histogram = std.typecons.toLong(histogram); \n\
    \                            \n                            histogram = std.",
  "  : test == null || test.length == 0\n    ? null\n    : test.chars().map(c => c).foldl(\n\
    \        (a, b) => a + ((b[c as char] ?? 0L) + 1), \n        Dict.empty[string,\
    \ long]\n      );\n    \n    \nimport std.conv;\nimport std.range;\n/*\nGiven\
    \ a string representing a space separated lowercase letters, return an associative\
    \ array\n    of the letter with the most repetition and containing the corresponding\
    \ count.\n    If several letters have the same occurrence, return all of them.\n\
    \    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L,\
    \ \"c\": 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\":\
    \ 2L].nullable\n    >>> histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n\
    \    >>> histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\
    \")\n    ___null_dict___", "{\n    Nullable! {\n        foreach(test, str) {\n\
    \            map[str, 1L] +=1;\n        }\n        foreach(map, map) {\n     \
    \       foreach(value, 1L) {\n                if(map[value] > map[map[value]]\
    \ ) {\n                    map[value] = map[map[value]];\n                   \
    \ map[map[value]] = value;\n                }\n            }\n        }\n    }\n\
    }\n</code>\nThe result of the above is:", "{\n    \n    struct Histogram\n   \
    \ {\n        long count;\n        long[string] letters;\n    };\n    \n    Histogram\
    \ histo;\n    \n    histo = Null(Histogram);\n    \n    for (auto c : test)\n\
    \    {\n        auto found = histo[char(c)];\n        found.count = found.count\
    \ + 1;\n        if (found.count > 0)\n            found.letters = insert!(found.letters,\
    \ c, found.count);\n    }\n    return histo;\n}", "    : Map[string, long] =\n\
    \    let mut map = Nullable!(Map[string, long])()\n    let mut counter: long =\
    \ 1\n    \n    for letter in test.chars() {\n        if let Some(count)=map.get(letter)\
    \ {\n            counter = count + counter;\n        } else {\n            map[letter]\
    \ = counter;\n            counter += 1;\n        }\n    }\n    map;", "    ->\
    \ Nullable!(long[string])\n{\n    let result = \n        map(test) \n        >>\
    \ map(char.digit)\n        >> fold(0, \n            (x, y) => \n             \
    \   if x == y then (x,1) else (x+y, x+1), \n            \n        )\n    \n  \
    \  if result.1 == result.2 then (Nullable!(long[]), Nullable!(long[]))\n    else\
    \ (result, Nullable!(long[]))\n}", "{\n    var counts = test.splitBy(\" \").map(function(aString){\n\
    \    return (aString, {(aString) -> aString.length})\n});\n    \n    var maxCount\
    \ = counts[0].1.fold((maxCount,count){\n        return count > maxCount ? count\
    \ : maxCount\n    });\n    \n    var result = counts\n    .filter((a) => {\n \
    \       return a[1].1.include(maxCount);\n    })\n    .map((a) => {\n        return\
    \ a[0];\n    })\n    .sorted();\n    return __builtins__.dictFrom((result).__self__);\n\
    }\n/* \nGiven a string representing a space separated lowercase letters, return\
    \ an associative array\n    of the letter with the most repetition and containing\
    \ the corresponding count.\n    If several letters have the same occurrence, return\
    \ all of them.\n    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"a\":\
    \ 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"\
    a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\")\n    [\"a\": 2L,\
    \ \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n\
    \    >>> histogram(\"\")\n    ___null_dict___", "  if  isPrefixOf(test, \" \"\
    ) \n    then Nullable!(long[string])(mapIndex(test, charCount))\n    else Nullable!(long[string])(MapOfStringlong())\
    \ ;\n/*\nGiven a string representing a space separated lowercase letters, return\
    \ a dictionary containing a\n    list of all the letters with the most repetition\
    \ and containing the corresponding count.\n    If several letters have the same\
    \ occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"a b\
    \ c\")\n    {\"a\": 1L, \"b\": 1L, \"c\": 1L}\n    >>> histogram(\"a b b a\")\n\
    \    {\"a\": 2L, \"b\": 2L}\n    >>> histogram(\"a b c a b\")\n    {\"a\": 2L,\
    \ \"b\": 2L}\n    >>> histogram(\"b b b b a\")\n    {\"b\": 4L}\n    >>> histogram(\"\
    \")\n    ___null_dict___\n    \n    \n*/\nNullable!(mapOf(string, long[string]))\
    \ histogram(string test) \n  if  isPrefixOf(test, \" \") \n    then Nullable!(mapOf(string,\
    \ long[string]))(mapIndex(test, charCount))\n    else Nullable!(mapOf(string,\
    \ long[string]))(MapOfStringlong()) ;\n/*\nGiven a string representing a space\
    \ separated lowercase letters, return an associative array\n    of the letter\
    \ with the most repetition and containing the corresponding count.\n    If several\
    \ letters have the same occurrence, return all of them.\n    \n    Example:\n\
    \    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L]\n    >>>\
    \ histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L]\n    >>> histogram(\"a b\
    \ c a b\")\n    [\"a\": 2L, \"b\": 2L]\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L]\n    >>> histogram(\"\")\n    ___null_dict___\n    \n    \n*/\n\
    Nullable!(mapOf(string,long)) histogram(string test) \n  if  isPrefixOf(test,\
    \ \" \") \n    then Nullable!(mapOf(string,long))(mapIndex(test, charCount))\n\
    \    else Nullable!(mapOf(string,long))(MapOfStringlong()) ;\n/*\nGiven a string\
    \ representing a space separated lowercase letters, return an associative array\n\
    \    of the letter with the most repetition and containing the corresponding count.\n\
    \    If several letters have the same occurrence, return all of them.\n    \n\
    \    Example:\n    >>> histogram(\"a ", "{\n    var histogram: long[string] =\
    \ __null;\n    for each(string s in test) {\n        histogram[s] = histogram.get(s,\
    \ 0) + 1L;\n    }\n    return histogram;\n}", "    : Nullable!(__dict_long__)\
    \ {\n    \n    // TODO: Optimize this function\n    // Count the occurrences of\
    \ the letters in the test string and return the letter with most occurrence\n\
    \    // and the number of occurrences.\n    local dict[char] :: long = 0;\n  \
    \  local dict[char] :: long = 0;\n    for c in test {\n        dict[c] = dict[c]\
    \ + 1L;\n    }\n    \n    for c in dict {\n        if dict[c] > test[test.length()\
    \ - 1] {\n            dict[c] = dict[c];\n            test[test.length() - 1]\
    \ = c; \n        }\n    }\n    return test;\n}\n/*\nGiven an associative array\
    \ or array of pairs, return an associative array where each pair has the\n   \
    \ same value but a different key. \n    \n    Example:\n    >>> array_key_merge([[\"\
    a\", 0], [\"b\", 1], [\"a\", 0]], [[\"a\", 0], [\"b\", 1], [\"b\", 0]])\n    [[0L,\
    \ 1L], [1L, 0L]]", "{\n    var dict: dict[string, long] = [];\n    test.split('\
    \ ').forEach((e: any, index: any) => {\n        var l = dict[e];\n        if (l\
    \ == null) l = dict[e] = 1;\n        else ++l;\n    });\n    return dict;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis looks like the best solution for me\
    \ at the moment but I have a question. When I try to run this script in the interactive\
    \ shell I get the following error: \n``` /c/Users/Daniel/anaconda3/bin/ipython:1:\
    \ DeprecationWarning: the imp module is deprecated in favour of importlib; see\
    \ the module's documentation for alternative uses```\n<|/ c |>\n<| c |>\nThis\
    \ warning is due to the fact that I was using `imp` to load `__main__.py` as a\
    \ module. This has been replaced by `importlib` which has much better support\
    \ for handling imports of packages (and modules). I've updated the script to use\
    \ `importlib` instead of `imp`.\n<|/ c |>\n<| a dscore=1 tags=python,dictionary,java,python-2.7\
    \ |>\nI have done this in python but i can't post it for you. Maybe it will be\
    \ interesting for you\n<code>\ndictionary = {}", "{\n    // convert string to\
    \ array of chars\n    char[] arr = test.asCharArray();\n    // map array of chars\
    \ to array of ints counting occurrences\n    int[] counts = ArrayUtils.toIntArray(arr);\n\
    \    // convert ints to array of longs\n    long[] longs = ArrayUtils.toLongArray(counts);\n\
    \    // map array of longs to array of longs containing letters\n    long[] letters\
    \ = ArrayUtils.toLongArray(arr);\n    \n    Arrays.sort(letters);\n    \n    long[]\
    \ result = new long[arr.length];\n    int i = 0;\n    for (long x : letters) {\n\
    \        result[i] = x;\n        i++;\n    }\n    return Nullable(result);\n}",
  "    : Map[string, long] =\n    match test.trim().split(' ') with\n    | [] -> ___null_dict___\n\
    \    | _ ->\n        let histogram = test.splitByAny(' ').fold({}) (fst (fold\
    \ add))\n        let histo = histogram.fold((0L)) {(acc, item) ->\n          \
    \  match item.trim().toLowerInvariant() with\n            | _ when String.length\
    \ item > 0 -> \n                (item, acc)\n            | _ -> \n           \
    \     acc }\n        histogram.value", "    : test == \"\"\n        ? Nullable!(long[string])()\n\
    \        : test == \" \"\n            ? Nullable!(long[string])()\n          \
    \  : histogram(std.algorithm.distinct[char](test))\n            : histogram.impl[Nullable!(long[string])](test);",
  "\t: test{\n\t\timport std.typecons;\n\t\timport std.array;\n\t\t\n\t\tvar res =\
    \ __dict_new();\n\t\tvar counts = __dict_new();\n\t\tvar maxCount = null;\n\t\t\
    var maxCountKey = null;\n\t\tvar keyCount = null;\n\t\tvar testChar: char;\n\t\
    \tvar testString = toCharArray(test);\n\t\tforeach(testChar, testString)\n\t\t\
    \tswitch(toCharArray(testChar))\n\t\t\t\tcase null:\n\t\t\t\t\tbreak;\n\t\t\t\t\
    case \" \":\n\t\t\t\t\tbreak;\n\t\t\t\tcase \" \\n\":\n\t\t\t\t\tbreak;\n\t\t\t\
    \tdefault:\n\t\t\t\t\tvar index = toLower(testChar) - 'a';\n\t\t\t\t\tvar char\
    \ = testString[index];\n\t\t\t\t\tif(!__dict_haskey(res, char))\n\t\t\t\t\t\t\
    __dict_put!(res, char, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\t__dict_put!(res, char,\
    \ 1 + __dict_get!(res, char));\n\t\t\t\t\tif(!__dict_haskey(counts, char))\n\t\
    \t\t\t\t\t__dict_put!(counts, char, 1);\n\t\t\t\t\telse\n\t\t\t\t\t\t__dict_put!(counts,\
    \ char, 1 + __dict_get!(counts, char));\n\t\t\t\t\t\n\t\t\t\t\tif(__dict_get!(counts,\
    \ char) > maxCount)\n\t\t\t\t\t\tmaxCount = __dict_get!(counts, char);\n\t\t\t\
    \t\tif(__dict_get!(res, char) > maxCount)\n\t\t\t\t\t\tmaxCount = __dict_get!(res,\
    \ char);\n\t\t\t\t\tif(maxCount == null)\n\t\t\t\t\t\tmaxCountKey = char;\n\t\t\
    \t\t\t\n\t\t\t\t\tif(__dict_get!(counts, char) == __dict_get!(res, char))\n\t\t\
    \t\t\t\tkeyCount++;\n\t\t\t\t\telse if(__dict_get!(counts, char) < __dict_get!(res,\
    \ char))\n\t\t\t\t\t\tkeyCount = 0;\n\t\t\t\tbreak;\n\t\t}\n\t\tif((keyCount >\
    \ 0) && (maxCount > 0))\n\t\t\t__dict_put!(res, maxCountKey, maxCount);\n\t\t\
    __dict_put!(counts, maxCountKey, keyCount);\n\t\treturn res;\n\t}", "{\n    Nullable!(long[string])\
    \ result = null;\n    for (char c in test)\n    {\n        result = max(result,\
    \ count__long_(c as char));\n    }\n    return result;\n}", "{\n    Nullable!(long[string])\
    \ result = null;\n    \n    for (int i = 0; i< test.length; ++i)\n    {\n    \
    \    Nullable!(long[string]) tmp = null;\n        for (int j = 0; j< test.length;\
    \ ++j)\n        {\n            if (i == j)\n            {\n                tmp\
    \ = Nullable!(long[string]) { 0L, 1L };\n            }\n            \n       \
    \     else if (test[i] == test[j])\n            {\n                tmp += Nullable!(long[string])\
    \ { 1L, 1L };\n            }\n            else\n            {\n              \
    \  tmp += Nullable!(long[string]) { 0L, 1L };\n            }\n        }\n    \
    \    \n        if (tmp != null)\n        {\n            if (result == null)\n\
    \            {\n                result = tmp;\n            }\n            else\n\
    \            {\n                result += tmp;\n            }\n        }\n   \
    \ }\n    \n    if (result == null)\n    {\n        result = Nullable!(long[string])\
    \ \"\";\n    }\n    \n    return result;\n}\n/*\nGiven a string representing a\
    \ space separated lowercase letters, return an associative array\n    of the letter\
    \ with the most repetition and containing the corresponding count.\n    If several\
    \ letters have the same occurrence, return all of them.\n    \n    Example:\n\
    \    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___",
  "    : dict string -> long\n{\n    // Convert string to array of lowercase\n   \
    \ var chars: array <char> = test.toCharArray().map((c) => c.toLowerCase());\n\
    \    \n    // Count the occurences of each letter\n    var counts: array [char]\
    \ = chars.reduce((acc, c) => {\n        acc[c] = acc[c] ? acc[c]+1 : 1\n     \
    \   return acc\n    }, []);\n    \n    // Sort letters from most to least\n  \
    \  counts.sort((a,b) => a-b)\n    \n    // Return the associative array containing\
    \ the letter with the most occurrence\n    var result: Nullable<long> = Nullable<long>(0);\n\
    \    for (let i=0; i<chars.length; i++){\n        if (result==Nullable<long>(0)||counts[i]>result.value)\n\
    \            result := counts[i];\n    }\n    return result.nullable;\n}\n/*\n\
    Given a string representing a space separated lowercase letters, return an associative\
    \ array\n    containing the letter with the most occurrences in any position and\
    \ containing the\n    corresponding count in any position.\n    \n    Example:\n\
    \    >>> histogram(\"a b c\")\n    {\"a\": 1L, \"b\": 1L, \"c\": 1L}.nullable\n\
    \    >>> histogram(\"a b b a\")\n    {\"a\": 2L, \"b\": 2L}.nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    {\"a\": 2L, \"b\": 2L}.nullable\n    >>> histogram(\"\
    b b b b a\")\n    {\"b\": 4L}.nullable\n    >>> histogram(\"\")\n    ___null_dict___",
  "    where {\n        var nchars = test.length();\n        var bins = new Nullable<long[]>;\n\
    \        var result = _map();\n        \n        for (int i = 0; i < nchars; i++){\n\
    \            var ch = test.charAt(i);\n            \n            if (bins.isDefinedAt(ch)){\n\
    \                result[ch] += 1;\n            } else {\n                bins[ch]\
    \ = 1;\n            }\n        }\n        return result;\n    }", "{\n    if (test==\"\
    \") return ___null_dict____;\n    \n    int count = 0;\n    int bestCount = 0;\n\
    \    string bestChar = \"\";\n    foreach(char in test)\n    {\n        int thisCount\
    \ = count[char];\n        if ( thisCount > bestCount )\n        {\n          \
    \  bestCount = thisCount;\n            bestChar = char;\n        }\n        count[char]++;\n\
    \    }\n    return ___tuple2(bestChar, bestCount);\n}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the most repetition and containing the corresponding count.\n  \
    \  If several letters have the same occurrence, return all of them.\n    \n  \
    \  Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___",
  "{\n    Nullable!(long[string]) result = ___null_dict___;\n    \n    forall char\
    \ c in test \n    {\n        if (c == __null_char__) {\n            continue;\n\
    \        }\n        if !result.containsKey(c)\n        {\n            result[c]\
    \ = __long0__;\n        }\n        \n        long count = result[c];\n       \
    \ \n        if(count < result[c])\n        {\n            result[c] = count;\n\
    \        }\n    }\n    \n    \n    return result.nonnull;\n}", "{\n\tnull!(test);\n\
    \tvar h = __builtins__[\"dict\"]();\n\tforeach(test, x -> h[x,1] = 1L);\n\treturn\
    \ h.take();\n}", "{\n    Nullable!(long[string]) res;\n    \n    for(char c in\
    \ test) {\n        \n        if(!containsKey!(res, c)) {\n            res[c] =\
    \ 0L;\n        }\n        \n        long tmp = res[c];\n        \n        if(tmp\
    \ >= long.MAX_VALUE) {\n            tmp = long.MAX_VALUE;\n        }\n       \
    \ \n        res[c] += 1;\n    }\n    \n    return res;\n}", "{\n\tNullable histogram\
    \ = Null(test);\n\tif(test != null && !test.isEmpty)\n\t{\n\t\tstring[] testChars\
    \ = test.split(\" \");\n\t\tfor(int i = 0; i < testChars.length; i++)\n\t\t{\n\
    \t\t\tstring currentChar = testChars[i];\n\t\t\tif(histogram.contains(currentChar))\n\
    \t\t\t{\n\t\t\t\thistogram.set(currentChar, histogram.get(currentChar) + 1);\n\
    \t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thistogram.set(currentChar, 1L);\n\t\t\t\
    }\n\t\t}\n\t\treturn histogram;\n\t}\n\treturn histogram;\n}", "{\n    var dict:\
    \ dict[char,long] = null;\n    \n    foreach(char c in test)\n    {\n        var\
    \ count = dict.getOrDefault(c, 0L);\n        dict[c] = count + 1;\n    }\n   \
    \ \n    return dict as Nullable[dict[char,long]];\n}", "    => if test == \"\"\
    \n        then NullDict(()) \n        else\n            test |> String.to_char\
    \ |> Seq.countBy (fun x -> x) |> \n                Seq.filter (fun x -> x > 1)\
    \ |>\n                Seq.sortBy (fun (_, x) -> x) |>\n                Seq.map(fun\
    \ (k, x) -> k + (x,))\n            |> Seq.toList\n            |> List.ofSeq |>\
    \ List.map(fun (x, count) -> x + (count.0,)) \n            |> List.ofSeq |> NullDict(())\n\
    ;", "{\n        \n    long dict;\n    string max;\n    int count = 0;\n    for(int\
    \ i = 0; i < test.length(); i++)\n    {\n        dict = dict.contains(test.subString(i))?\
    \ dict[test.subString(i)].add(count) : dict[test.subString(i)] = [];\n    }\n\
    \    foreach(dict, list: long[] )\n    {\n        if( list.count() == list[0])\
    \ \n        {\n            max = list[0];\n        }\n        else \n        {\n\
    \            if( list.count() > list.max() ) \n            {\n               \
    \ max = list[0];\n            }\n        }\n    }\n    return dict.contains(max)\
    \ ? dict[max] : Nullable!(dict[max]);\n}", "{\n    int[string] result = new int[string];\n\
    \    \n    for(char c : test.chars)\n        result[c] = (result[c] + 1L) >>>\
    \ 0;\n    \n    foreach(k, v : result)\n        if(v == result.max)\n        \
    \    test[k] = v;\n            \n    return test;\n}\n/*\nReturn an array of all\
    \ numbers that are divisors of test\n    \nExample:\n    \n    >>> allDivisors(4)\n\
    \    [1, 2, 4]\n    \n*/\nNullable!(int[]) allDivisors(int test) \n{\n    int\
    \ n = 0;\n    while(test > 0)\n    {\n        test /= 10;\n        n++;\n    }\n\
    \    \n    int[] result = new int[n];\n    \n    foreach(i, v : result)\n    {\n\
    \        if(test % i == 0)\n            result[i] = test / i;\n    }\n    \n \
    \   return result;\n}\n/*\nReturn the sum of all numbers that are divisors of\
    \ test\n    \nExample:\n    \n    >>> sum(4)\n    10\n    \n*/\nNullable!(int)\
    \ sum(int test) \n{\n    int n = 0;\n    while(test > 0)\n    {\n        test\
    \ /= 10;\n        n++;\n    }\n    \n    int[] result = new int[n];\n    foreach(i,\
    \ v : result)\n    {\n        if(test % i == 0)\n            result[i] = test\
    \ / i;\n    }\n    \n    return result.sum;\n}\n/*\nReturn a tuple of all numbers\
    \ that are divisors of test\n    \nExample:\n    \n    >>> allDivisors(4)\n  \
    \  [1, 2, 4]\n    \n*/\nNullable!(int[]) allDivisors(int test) \n{\n    int n\
    \ = 0;\n    while(test > 0)\n    {\n        test /= 10;\n        n++;\n    }\n\
    \    \n    int[] result = new int[n];\n    \n    foreach(i, v : result)\n    {\n\
    \        if(test % i == 0)\n            result[i] = test / i;\n    }\n    \n \
    \   return result;\n}\n/*\nReturn an array of all numbers that are divisors of\
    \ test\n    \nExample:\n    \n    >>> allDivisors(4)\n    [1, 2, 4]\n    \n*/\n\
    Nullable!(int[]) allDivisors(int test) \n{\n    int n = 0;\n    while(test > 0)\n\
    \    {\n        test /= 10;\n        n++;\n    }\n    \n    int[] result = new\
    \ int[n];\n    \n    foreach(i, v : result)\n    {\n        if(test % i == 0)\n\
    \            result[i] = test / i;\n    }\n    \n    return result;\n}\n/*\nReturn\
    \ a tuple of all number", "{\n\t/*\n    Create an empty dict to store key / value\
    \ pairs\n    */\n\tvar dict: dict[long]  = {};\n\t\n\t\n\t/*\n    Split the string\
    \ into a list of characters\n    */\n\tvar split: string = test.split(\" \");\n\
    \t\n\t\n\t/*\n    Iterate over the list of characters, counting each occurrence\
    \ of the character.\n    */\n\tfor(var i: uint = 0; i < split.length; i++) \n\t\
    {\n\t\t/*\n        If the current character is not in the dict, add it with a\
    \ count of 1\n        Otherwise, add to the current value of the dict\n      \
    \  */\n\t\tif(!dict.__contains__(split[i]))\n\t\t{\n\t\t\tdict[split[i]] = 1L;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tdict[split[i]]++;\n\t\t}\n\t}\n\t\n\t\n\t/*\n  \
    \  Iterate through the dict and find the key with the highest value\n    */\n\t\
    var maxKey: long = long(0);\n\tvar maxValue: long = long(0);\n\tfor(var key: long\
    \ in dict) \n\t{\n\t\tif(dict[long] > maxValue) \n\t\t{\n\t\t\tmaxValue = dict[long];\n\
    \t\t\tmaxKey = key;\n\t\t}\n\t}\n\t\n\t\n\t/*\n    If the string only contains\
    \ one word, return the key\n    Otherwise, return a list of all keys\n    */\n\
    \t\n\tif(split.length == 1)\n\t{\n\t\treturn maxKey;\n\t}\n\telse\n\t{\n\t\treturn\
    \ dict;\n\t}\n}", "{\n\tlet words = test.split(\" \");\n\tlet dict = \n\t\twords\n\
    \t\t\t.map(w=>std.dict.new(w, false))\n\t\t\t.fold(std.dict(), std.functional.fold(\n\
    \t\t\t\t(x, y) => std.dict.merge(x, y, \n\t\t\t\t\t(x,y) => std.dict.highestKey(x,\
    \ y)\n\t\t\t\t)\n\t\t\t));\n\t\n\treturn std.dict.map(dict, (k, v) => std.typecons.newCons(k,\
    \ v.count()));\n}\n/*\nGiven a string representing a space separated lowercase\
    \ letters, return an associative array\n    of the letter with the most repetition\
    \ and containing the corresponding count.\n    If several letters have the same\
    \ occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"a b\
    \ c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a\
    \ b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___", "  : Nullable!(long[string])\
    \ =\n    match test with\n    | null -> Nullable!(long[string])\n    | _ ->\n\
    \        let histo = \n            test.Split(\" \").\n            GroupBy(fun\
    \ s -> s).\n            map (fun (_, group) -> group |> List.map (fun a -> a,\
    \ group.Count()))\n        in\n            (\n                histo |> List.fold\
    \ (fun (histo,c) -> \n                    match histo.get(a) with\n          \
    \          | Some (m, v) -> if v > c then (Some (m, v), c) else  histo\n     \
    \               | None -> (None, c)\n                ) None\n            )\n \
    \           |> fst\n            \nHistogram!(long[string]) histogram(string test)\
    \ =\n    match histogram(test) with\n    | null -> null\n    | _ -> histogram.0",
  "  : test\n{\n  \n  string letters = string(test).split();\n  \n  if(length(letters)\
    \ < 1)\n    throw new Error(\"No letters provided\");\n  \n  // Initialize a map\
    \ of letters to count\n  map!(map, x => (x: 1L)) map!(map, x => (x: 0)) map!(map,\
    \ x => (x: 0)) map!(map, x => (x: 0)) map!(map, x => (x: 0)) map!(map, x => (x:\
    \ 0)) map!(map, x => (x: 0));\n  \n  map!(map, x => x + 1) // Add the count of\
    \ the letters\n  \n  map!(map, x => x.x.max) // Return the letter with the most\
    \ occurences\n}", "{\n\tNullable!{long[string]} histogram = new Nullable!{long[string]}();\n\
    \t\n\ttest.split(' ').map(function(word){\n\t\tvar freq = test.split(' ').filter(function(t){return\
    \ t == word}).length;\n\t\tif(freq > 0){\n\t\t\thistogram[word] = freq;\n\t\t\
    }\n\t})\n\treturn histogram;\n}", "{\n    char[] chars = test.asCharArray();\n\
    \    \n    Nullable!(long[string]) hist = Nullable![(char, long)] {};\n    \n\
    \    foreach(char, chars, \n    \n    function(char: char) \n    {\n        hist[(char)]\
    \ += 1;\n        \n    });\n    \n    return hist;\n}", "{\n    \n    let words\
    \ = test.split (\" \");\n    \n    // count letter frequencies in words and store\
    \ them in an associative array \"count\"\n    let mutable count = 0;\n    \n \
    \   for w in words do\n        match count[w] with\n        | None -> count[w]\
    \ := 0L\n        | Some x -> count[w] += 1;\n    \n    match count with\n    |\
    \ Null(x) ->  Null(x)\n    | Some (x :: xs) ->\n        // build new dictionary\
    \ to return\n        match x with \n        | _ -> Null(x)\n        | _ ->\n \
    \           let mutable max = 0L;\n            // count the max number of repetitions\
    \ in the dictionary\n            let mutable maxCount = 0L;\n            let mutable\
    \ maxLetter = String.Empty;\n            for w in xs do\n                match\
    \ count[w] with\n                | None -> count[w] := 0L\n                | Some\
    \ x -> \n                    if (max < x) then\n                        max <-\
    \ x;\n                        maxCount <- x\n                        maxLetter\
    \ <- w;\n                \n            Null([maxLetter; maxCount])\n    \n};\n\
    /*\nGiven a string representing a space separated lowercase letters, return an\
    \ associative array\n    of the letter with the most repetition and containing\
    \ the corresponding count.\n    If several letters have the same occurrence, return\
    \ all of them.\n    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"a\":\
    \ 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"\
    a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\")\n    [\"a\": 2L,\
    \ \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n\
    \    >>> histogram(\"\")\n    ___null_dict___", "{\n\t\n\tlet dict = new Nullable<long[string]>(null);\n\
    \t\n\ttest.split(' ').map(string => { \n\t\tif(string.empty()) return dict;\n\t\
    \tif(dict.contains(string)) {\n\t\t\tdict[string] += 1;\n\t\t} else {\n\t\t\t\
    dict[string] = 1;\n\t\t}\n\t\treturn dict;\n\t});\n}", "{\n    Nullable!{long}__null_dict___\
    \ := {};\n    \n    string splits = test.split(\" \");\n    string letter;\n \
    \   long count;\n    \n    for each (letter in splits)\n    {\n        Nullable!{long}__null_dict__[letter]\
    \ := Nullable!0;\n    }\n    \n    for each (letter in splits)\n    {\n      \
    \  count := 0;\n        \n        for each (letter in splits)\n        {\n   \
    \         count += Nullable!0__null_dict__[letter];\n            Nullable!0__null_dict__[letter]\
    \ := count;\n        }\n    }\n    \n    return Nullable!0__null_dict__;\n}\n\
    /*\nGiven a non-negative integer N, print N copies of 'A'. N may assume only contain\
    \ digits.\n    Example:\n    >>> aa_print_number(10)\n    AA AA AA AA AA AA AA\
    \ AA\n    >>> aa_print_number(1)\n    A\n    >>> aa_print_number(-1)\n    Error!\n\
    */", "{\n  map!(test, &(length(split(test)) as long), values);\n  map!(test, &(sort(values(&1),\
    \ by=&1)[0].1), values);\n  map!(test, &(sort(values(&1), by=&1)[0].1), values);\n\
    \  map!(test, &(sort(values(&1), by=&1)[0].1), values);\n  map!(test, &(sort(values(&1),\
    \ by=&1)[0].1), values);\n  return map!(test, &(sort(values(&1), by=&1)[0].1),\
    \ values);\n}\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"a b c\");\n\
    </cell>\n<code language=dyalog-kernel>\nhistogram(\"a b b a a\");\n</cell>\n<code\
    \ language=dyalog-kernel>\nhistogram(\"b b b b a\");\n</cell>\n<code language=dyalog-kernel>\n\
    histogram(\"b b b b a\");\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"\
    a b c a b\");\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"b b c b a\"\
    );\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"a b b c a\");\n</cell>\n\
    <code language=dyalog-kernel>\nhistogram(\"b b c a b\");\n</cell>\n<code language=dyalog-kernel>\n\
    histogram(\"a b c b b\");\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"\
    b c a b b\");\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"b b a b b\"\
    );\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"a a a a a\");\n</cell>\n\
    <code language=dyalog-kernel>\nhistogram(\"a b c a b\");\n</cell>\n<code language=dyalog-kernel>\n\
    histogram(\"a b c a b\");\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"\
    a b c a b\");\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"a b c a b\"\
    );\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"a b c a b\");\n</cell>\n\
    <code language=dyalog-kernel>\nhistogram(\"a b c a b\");\n</cell>\n<code language=dyalog-kernel>\n\
    histogram(\"a b c a b\");\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"\
    a b c a b\");", "{\n    return __histogram__(test, Nullable!([long[string]]),\
    \ \"\");\n}", "  \n  \n{\n\tNullable dict = Nullable.none!();\n\tchar[] charArray\
    \ = test.chars().takeWhile(isLetter).skip(1).collect();\n\tSortedMap[char,long,SortOrder.Ascending,\
    \ CaseInsensitive] tempDict = SortedMap(charArray,0);\n\tlong maxCount = charArray.len();\n\
    \tfor(char a : charArray)\n\t{\n\t\ttempDict[a] = tempDict[a] + 1L;\n\t\tif(tempDict[a]\
    \ > maxCount)\n\t\t{\n\t\t\tmaxCount = tempDict[a];\n\t\t\tdict = tempDict.toMap();\n\
    \t\t}\n\t}\n\treturn dict;\n}", "{\n    Nullable!(dict[char,long]) res=\n    dict[test[0]]!=null\
    \ && dict[test[0]][test[1]]!=null && dict[test[0]][test[1]].__isnull\n       \
    \ ? dict[test[0]][test[1]].__tonull\n        : dict[test[0]][test[1]];\n     \
    \   \n    for(int i=1;i<test.length;i++) \n    {\n        Nullable!(dict[char,long])\
    \ temp;\n        temp=dict[test[i]]!=null && dict[test[i]][test[i-1]]!=null &&\
    \ dict[test[i]][test[i-1]].__isnull\n            ? dict[test[i]][test[i-1]].__tonull\n\
    \            : dict[test[i]][test[i-1]];\n        \n        if(temp.__isnull!=res.__isnull)\n\
    \        {\n            res=temp;\n        }\n    }\n    return res;\n}", "  \
    \  =\n    try\n        try\n            let testList = test.split(\" \")\n   \
    \         \n            let histogram = new LongDict<_>()\n            \n    \
    \        \n            for i in 0..testList.Length-1\n                do\n   \
    \                 let thisLetter = testList[i]\n                    let otherLetters\
    \ = testList.GetRange(i+1)\n                    \n                    histogram.Add(thisLetter,\
    \ otherLetters.Length)\n                    \n                \n            \n\
    \            let rec maxCount rec maxCount = \n                match histogram.Values\
    \ with\n                | [] -> 0L\n                | (value, count) -> if count\
    \ = maxCount then maxCount else maxCount // Only return the first occurrence\n\
    \            \n            return maxCount |> Nullable.toNullable\n          \
    \  \n        \n        with ex -> raise ex\n        \n    with\n    \n    \n \
    \   try\n        try\n            let testList = test.split(\" \")\n         \
    \   \n            let histogram = new LongDict<_>()\n            \n          \
    \  \n            for i in 0..testList.Length-1\n                do\n         \
    \           let thisLetter = testList[i]\n                    let otherLetters\
    \ = testList.GetRange(i+1)\n                    \n                    histogram.Add(thisLetter,\
    \ otherLetters.Length)\n                    \n                \n            \n\
    \            let rec maxCount rec maxCount = \n                match histogram.Values\
    \ with\n                | [] -> 0L\n                | (value, count) -> if count\
    \ = maxCount then maxCount else maxCount // Only return the first occurrence\n\
    \            \n            return maxCount |> Nullable.toNullable\n          \
    \  \n        \n        with ex -> raise ex\n        \n    with\n    \n    \n \
    \   try\n        try\n            let testList = test.split(\" \")\n         \
    \   \n            let histogram = new LongDict<_>()\n            \n          \
    \  \n            for i in 0..testList.Length-1\n                do\n         \
    \           let thisLetter = testList[i]\n                    let otherLetters\
    \ = testList.GetRange(i+1)\n                    \n                    histogram.Add(thisLetter,\
    \ otherLetters.Length)\n                    \n                \n            \n\
    \            let rec maxCount rec maxCount = \n                match histogram.Values\
    \ with\n                | [] -> 0L\n                | (value, count) -> if count\
    \ = maxCount then maxCount else maxCount // Only return the first occurrence\n\
    \            \n            return maxCount |> Nullable.toNullable\n          \
    \  \n        \n        with ex -> raise ex\n        \n    with\n    \n    \n \
    \   try\n        try\n            let testList = test.split(\" \")\n         \
    \   \n            let histogram = new LongDict<_>()\n            \n          \
    \  \n            for i in 0..testList.Length-1\n", "{\n\tNullable!(long[string])\
    \ histogram = Nullable!(long[string]) ___null_dict___;\n\ttest.toLowerCase().split(\"\
    \ \").foreach(l => {\n\t\thistogram[l] = histogram[l] ? histogram[l] + 1 : 1;\n\
    \t});\n\t\n\treturn histogram;\n}", "{\n    match test.split(\" \") {\n      \
    \  Case(x) => histogram(x),\n        Case(x => x != \"\") => null,\n        Case(x\
    \ => x == \"\") => Nullable!()\n    }\n}\n</code>\n<|/ a tags=dart dscore=0 |>\n\
    <| a dscore=0 tags=dart |>\nThis works for me in Dart 2.0:\n<code>\nimport 'dart:convert';",
  "    {\n    \n    int i = 0;\n    \n    Nullable!(long) total;\n    \n    int j\
    \ = 0;\n    \n    Nullable!(long) max;\n    \n    String! key;\n    \n    Array!(long)\
    \ map = new Array!(long);\n    \n    Array!(string) result = new Array!(string);\n\
    \    \n    \n    for (; i < test.length(); i++) {\n        \n        Nullable!(long)\
    \ count = Nullable!(long) 1;\n        \n        \n        if (test[i] == ' ')\
    \ {\n            \n            \n            map[j++] = Nullable!(long) 1;\n \
    \           \n            \n            continue;\n        }\n        \n     \
    \   for (int k = i; k < test.length(); k++) {\n            \n            \n  \
    \          if (test[k] == ' ') {\n                \n                map[j++] =\
    \ Nullable!(long) 1;\n                \n                \n                continue;\n\
    \            }\n            \n            if (test[k] == test[i]) {\n        \
    \        \n                count++;\n            }\n            \n           \
    \ \n        }\n        \n        if (count > max) {\n            \n          \
    \  max = count;\n            \n            key = \"\";\n            \n       \
    \     total = 0;\n            \n            for (int l = i; l < test.length();\
    \ i++) {\n                \n                key += test[l];\n                \n\
    \                total += Nullable!(long) map[i];\n                \n        \
    \    }\n            \n            \n            result[i] = key;\n           \
    \ \n        }\n        \n        \n    }\n    \n    \n    if (max == Nullable!(long)\
    \ 0) {\n        \n        return Nullable!(map);\n    }\n    \n    return Nullable!(long)\
    \ max;\n    }\n/*\nGiven a string representing a space separated lowercase letters,\
    \ return an associative array\n    of the letter with the most repetition and\
    \ containing the corresponding count.\n    If several letters have the same occurrence,\
    \ return all of them.\n    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"\
    a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"\
    a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\")\n    [\"a\": 2L,\
    \ \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n\
    \    >>> histogram(\"\")\n    ___null_dict___\n*/\nNullable!(long[string]) histogram(string\
    \ test) \n    {\n    \n    int i = 0;\n    \n    Nullable!(long) total;\n    \n\
    \    int j = 0;\n    \n    Nullable!(long", "{\n\t// TODO: optimize\n\tNullable!{long:long}!{long:long}!{long:long}!{long:long}\
    \ = {\n\t\t[char:null] = { 0:0, 1:0, 2:0, 3:0, 4:0, 5:0 },\n\t\t[char:null] =\
    \ { 0:0, 1:0, 2:0, 3:0, 4:0, 5:0 },\n\t\t[char:null] = { 0:0, 1:0, 2:0, 3:0, 4:0,\
    \ 5:0 },\n\t\t[char:null] = { 0:0, 1:0, 2:0, 3:0, 4:0, 5:0 },\n\t\t[char:null]\
    \ = { 0:0, 1:0, 2:0, 3:0, 4:0, 5:0 }\n\t};\n\t\n\t\n\ttest.split(' ').forEach((c:string)\
    \ => {\n\t\tvar index = char.index(c.char());\n\t\tif (index >= 0) {\n\t\t\tNullable!{long:long}!{long:long}!{long:long}!{long:long}!{long:long}.char!index\n\
    \t\t\t\t(c.char())[c.char()]\n\t\t\t\t++;\n\t\t} else {\n\t\t\tNullable!{long:long}!{long:long}!{long:long}!{long:long}!{long:long}.char\n\
    \t\t\t\t(c.char())\n\t\t\t\t++;\n\t\t}\n\t});\n\t\n\t// TODO: optimize\n\tNullable!{long:long}!{long:long}!{long:long}!{long:long}!{long:long}.sort!(char.compare);\n\
    \t\n\treturn Nullable!{long:long}!{long:long}!{long:long}!{long:long}!{long:long}.filter!(\n\
    \t\tc => c !== null,\n\t\tc => c.value >= 2);\n}\n</cell>\n<text>\nHistogram",
  "{\n\tvar result : Nullable<long>  = Nullable<long>[];\n    var count : Nullable<long>\
    \ = Nullable<long>[];\n\t\n\tfor (var i : int in test.chars()) {\n\t\tlet char\
    \ : char = i;\n        /*\n        \tCreate a counter for the character and push\
    \ it to the result array\n        \tIf the character isn't in the result array,\
    \ add it and set its count to 1\n        \tOtherwise, find the existing occurrence\
    \ and increment the count by 1\n        \tIf the character has never been seen\
    \ before, set the count to 1\n        */\n        if (! result[char]) {\n    \
    \    \tresult.push(char);\n        \tcount.push(1);\n        }\n        else {\n\
    \            let existing : Nullable<long> = result[char];\n            \n   \
    \         count.push(existing);\n            count.push(count.last + 1);\n   \
    \     }\n    }\n    \n    /*\n        Convert the result array to a dictionary\
    \ where the keys are the characters and the values are the counts\n        */\n\
    \    var histogramDict : Nullable<long> = Nullable<long>[];\n    for (var i :\
    \ int in result) {\n        histogramDict.push(result[i]);\n    }\n    \n    /*\n\
    \        Sort the dictionary from highest count to lowest count\n        */\n\
    \    histogramDict.sort();\n    \n    /*\n        Take the top most occurrence\
    \ of every letter\n        \n        If the dictionary has more than one value\
    \ with the same value, choose the highest one\n        */\n    histogramDict =\
    \ histogramDict.groupBy(function (x: Nullable<long>): Nullable<long> {\n     \
    \   return x;\n    }).map(function (x: Nullable<long>): Nullable<long> {\n   \
    \     return x[0];\n    }).take(histogramDict.length);\n    \n    /*\n       \
    \ Return the dictionary and a new sorted list of letters sorted by count\n   \
    \     */\n    return (histogramDict, histogramDict.sort());\n}", "{\n\tvar h :\
    \ long[string]; // hashtable\n\tvar c = 1; // count\n\tvar s = ''; // string accumulator\n\
    \tfor(var i = 0; i < test.length; i++) \n\t{\n\t\tvar ch = test.charAt(i);\n\t\
    \t\n\t\tif(c++ == h[ch])\n\t\t{\n\t\t\t// count hasn't changed, so append to the\
    \ string accumulator\n\t\t\t// and move on to the next letter\n\t\t\ts = s + ch;\n\
    \t\t}\n\t\telse \n\t\t{\n\t\t\t// count has changed, so reset the string accumulator\
    \ to \n\t\t\t// the first letter\n\t\t\ts = ch;\n\t\t\t// and increment the count\n\
    \t\t\tc++;\n\t\t}\n\t\t\n\t\tif(!c) \n\t\t{\n\t\t\t// we found a letter's count\
    \ equals 1, so reset the count\n\t\t\t// and append the letter that was found\
    \ on the first run\n\t\t\tc++;\n\t\t\ts = ch;\n\t\t}\n\t\th[ch] = c;\n\t}\n\t\n\
    \treturn [s, h];\n}", "    local result : long[string] = ___new__(null);\n   \
    \ for each (local c in test) \n        if !result[c]\n            result[c] =\
    \ 1;\n        else\n            result[c] =+ 1;\n        fi;\n    return result;\n\
    end\n/*\nGiven a string of length n, return a string representing the first n\
    \ words of the sentence in alphabetical order.\nIf the sentence has less than\
    \ n words, return it unmodified.\n    \n    Example:\n    >>> firstNWords(\"The\
    \ quick brown fox jumps over the lazy dog\")\n    \"The quick brown fox jumps\
    \ over the lazy dog\".nullable\n    >>> firstNWords(\"The quick brown fox jumps\
    \ over the lazy dog\", 5)\n    \"The quick brown fox\".nullable\n    >>> firstNWords(\"\
    \")\n    ___null_dict___", "{\n    Nullable n = {};\n    foreach (char c in test)\n\
    \    {\n        if (!n.containsKey(c))\n            n.add(c);\n        else\n\
    \            n[c] += 1;\n    }\n    return n;\n}", "    : testLength=test.length,\
    \ testResults=__null_dict__() {\n    // TODO: Implement this function.\n    \n\
    \    /*\n    We could just do one loop and increment the value by one,\n    but\
    \ this solution is probably easier to understand and probably runs faster.\n \
    \   */\n    \n    for(int i = 0; i<testLength; i++) {\n        if(testResults[test[i]]==null)\
    \ testResults[test[i]]=0;\n        testResults[test[i]]++;\n    }\n    return\
    \ testResults;\n}\n/*\n    \n    Here's a slightly more efficient version of the\
    \ previous function\n    that runs in constant time.\n    \n    We keep track\
    \ of the letters that have already been seen in our histogram\n    \n    We then\
    \ iterate over the string once to build the histogram, and one more time\n   \
    \ to look up the letters that have the highest counts.\n    \n    Finally, we\
    \ add 1 to each of these letters, giving us their occurrence.\n    \n    \n  \
    \  \n    \n    */\nNullable!(long[string]) histogramEfficiency(string test) \n\
    \    : testLength=test.length, testResults=__null_dict__() {\n    \n    /*\n \
    \   We could just do one loop and increment the value by one,\n    but this solution\
    \ is probably easier to understand and probably runs faster.\n    */\n    \n \
    \   for(int i = 0; i<testLength; i++) {\n        if(testResults[test[i]]==null)\
    \ testResults[test[i]]=0;\n        testResults[test[i]]++;\n    }\n    \n    /*\n\
    \    We keep track of the letters that have already been seen in our histogram\n\
    \    \n    We then iterate over the string once to build the histogram, and one\
    \ more time\n    to look up the letters that have the highest counts.\n    \n\
    \    Finally, we add 1 to each of these letters, giving us their occurrence.\n\
    \    */\n    \n    for(auto [k, v] : testResults) {\n        if(k>0) k++;\n  \
    \  }\n    return testResults;\n}", "{\n    // TODO: Rewrite this function using\
    \ pattern matching.\n    \n    var histogram = Dict();\n    foreach(char c in\
    \ test)\n        histogram[char] = histogram[char] + 1UL;\n    \n    var maxOccurences\
    \ = 0;\n    var maxOccurrences = 0;\n    foreach(char c in histogram)\n    {\n\
    \        if (histogram[c] > maxOccurences)\n        {\n            maxOccurences\
    \ = histogram[c];\n            maxOccurrences = c;\n        }\n    }\n    \n \
    \   return Nullable[maxOccurrences: maxOccurences]; \n}", "{\n    local Nullable<long>\
    \ dict;\n    local Nullable<long> max;\n    local Nullable<long> curr = 0;\n \
    \   for (char c in test) {\n        local long value;\n        dict[c] = dict[c].value\
    \ + 1;\n        if (dict[c] > max) {\n            max = dict[c];\n           \
    \ dict = new Nullable<long>(dict[c]);\n        }\n        else if (dict[c] > curr\
    \ && c != dict[c]) {\n            curr = dict[c];\n            dict = new Nullable<long>(dict[c]);\n\
    \        }\n        else if (dict[c] == curr) {\n            dict = new Nullable<long>(dict[c]);\n\
    \        }\n    }\n    if (dict.value > 0) {\n        return dict;\n    } else\
    \ {\n        return ___null_dict____;\n    }\n}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the highest occurrence and containing the corresponding count.\n\
    \    If several letters have the same occurrence, return the letter with the lowest\
    \ alphabetical position.\n    \n    Example:\n    >>> histogram(\"a b c\")\n \
    \   [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a b c a b\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___\n    \n \
    \   \n*/\nNullable!(char[string]) histogram(string test) \n{\n    local Nullable<char>\
    \ dict;\n    local Nullable<char> max;\n    local Nullable<char> curr = 'a';\n\
    \    for (char c in test) {\n        local char value;\n        dict[c] = dict[c].value\
    \ + 1;\n        if (dict[c] > max) {\n            max = dict[c];\n           \
    \ dict = new Nullable<char>(dict[c]);\n        }\n        else if (dict[c] > curr\
    \ && c != dict[c]) {\n            curr = dict[c];\n            dict = new Nullable<char>(dict[c]);\n\
    \        }\n        else if (dict[c] == curr) {\n            dict = new Nullable<char>(dict[c]);\n\
    \        }\n    }\n    if (dict.value > 0) {\n        return dict;\n    } else\
    \ {\n        return ___null_dict____;\n    }\n}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the most repetition and containing the corresponding count.\n  \
    \  If several letters have the same occurrence, return all of them.\n    \n  \
    \  Example:\n    >>> histogram(\"a b c\")\n", "        -> Nullable!{string =>\
    \ long}\n    {\n        let res = vec![\"\"; 256];\n        let mut count_map\
    \ = Nullable!{string => long}();\n        for ch in test.chars() {\n         \
    \   count_map.set(ch, (count_map.getOrDefault(ch, 0) + 1l));\n        }\n    \
    \    for ch in count_map {\n            res[ch] = count_map.getOrDefault(ch, 0l)\
    \ + 1l;\n        }\n        res[\"\"] = 1l;\n        Nullable!{string => res}\n\
    \    }", "{\n    let histogram = \n        test.chars()\n        .map(x=>x.asUpper())\n\
    \        .groupBy()\n        .map(x=>x.key.asUpper())\n        .toArray();\n \
    \   return histogram.length == 0 ? Null(Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T: Nullable!{T:\
    \ Nullable!{T: Nullable!{T: Nullable", "{\n    var result = new Nullable<long>();\n\
    \    var count = Nullable<long>();\n    var letters = test.split(\" \");\n   \
    \ for (var i = 0; i < letters.length; i++)\n    {\n        var letter = letters[i];\n\
    \        if (!count.isNull())\n        {\n            if (count.getValue() > count.value())\n\
    \            {\n                result = count;\n                count = new Nullable<long>();\n\
    \            }\n        }\n        count.set(count.getValue() + 1);\n    }\n \
    \   if (!count.isNull())\n    {\n        result = count;\n    }\n    return result.nullable;\n\
    }", "    : Nullable!(dict[string,long]) =\n    match test.trim().split(\" \")\
    \ with\n    | [] -> Nullable!(dict[string,long])\n    | _ ->\n        let l =\
    \ histogram(_)\n        match l.value with\n        | None -> l.copy(value = Nullable!(dict[string,long]()))\n\
    \        | Some(count) ->\n            match l.value with\n            | None\
    \ -> l\n            | Some(dict) -> \n                match histogram.value with\n\
    \                | None -> l.copy(value = Nullable!(dict[string,long](count +\
    \ 1)))\n                | Some(count) -> \n                    let new_count =\
    \ count + l.value\n                    match histogram.value with\n          \
    \          | None -> l.copy(value = Nullable!(dict[string,long](new_count)))\n\
    \                    | Some(dict) -> l.copy(value = Nullable!(dict[string,long](new_count)))\n\
    \        \n        \n/*\nGiven a string representing a space separated lowercase\
    \ letters, return an associative array\n    of the letter with the most repetition\
    \ and containing the corresponding count.\n    If several letters have the same\
    \ occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"a b\
    \ c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a\
    \ b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___", "{\n  \
    \  var result : Nullable<long> = Nullable((long[1])(0));\n    \n    foreach(word\
    \ in split(test, \"\\s+\"))\n    {\n        var letter : string = word[0];\n \
    \       var count : long = word.length > 1 ? long[word[1]] : long[1];\n      \
    \  \n        if((result|notNull).isNull)\n        {\n            result = Nullable(count);\n\
    \        }\n        else\n        {\n            result = maxCounts[letter] =\
    \ max(maxCounts[letter], count);\n        }\n    }\n    \n    return result;\n\
    }", "{\n\tvar nLetters: Array[string] =\n\t\ttoVector(test).splitToArray().map(chr\
    \ => chr as string).toArray();\n\tvar nCounts: Array[long] = \n\t\tnLetters.map(letter\
    \ => 1 as long).sum();\n\treturn \n\t\tif(nCounts > 0) \n\t\t{\n\t\t\tvar nMaxCount:\
    \ long = nCounts.max;\n\t\t\tvar nLetter: string = nLetters.max;\n\t\t\tvar nCount:\
    \ long = nCounts.max;\n\t\t\t\n\t\t\tvar res: Nullable[long] =\n\t\t\t\tNullable[long].of(\n\
    \t\t\t\t\tnLetter,\n\t\t\t\t\tnCount);\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\telse\
    \ \n\t\t{\n\t\t\treturn Nullable[long].of(___null_dict___);\n\t\t}\n}\n/*\nGiven\
    \ a string representing a space separated lowercase letters, return an associative\
    \ array\n    of the letter with the most repetition and containing the corresponding\
    \ count.\n    If several letters have the same occurrence, return all of them.\n\
    \    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L,\
    \ \"c\": 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\":\
    \ 2L].nullable\n    >>> histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n\
    \    >>> histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\
    \")\n    ___null_dict___", "  : Nullable!({\n    \n    var __dict__ : Nullable!({\n\
    \        var __counts__ : long = 0;\n        for (int i = 0; i < test.length;\
    \ ++i)\n            ++__counts__[test[i]];\n        return __counts__;\n    })\
    \ = {\n    };\n    \n    for (let __i = 0; __i < test.length; ++__i)\n       \
    \ if (__dict__[test[__i]].isNull)\n            __dict__[test[__i]] = __counts__[test[__i]];\n\
    \        else\n            __dict__[test[__i]] += __dict__[test[__i].key];\n \
    \   return __dict__;\n});", "{\n    \n    let mut freq: Map[string, (long, int)]\
    \ = __null_dict();\n    let mut chars = test.chars();\n    \n    let mut count\
    \ = 0;\n    loop\n    {\n        let mut letter = chars.next();\n        \n  \
    \      if (freq.get(letter) == __null_dict())\n        {\n            freq[letter]\
    \ = (0, 0);\n            \n        }\n        \n        let mut freq_val: ((long,\
    \ int), Map<_, _>) = __null_dict();\n        let mut count_val: (long, int) =\
    \ __null_dict();\n        \n        let mut letter_val = freq[letter];\n     \
    \   \n        if (freq_val.get((*letter_val.1).1) < count_val.1)\n        {\n\
    \            freq_val[(letter_val.0, letter_val.1)] = (count_val.0, *letter_val);\n\
    \            \n        }\n        else\n        {\n            freq_val[(letter_val.0,\
    \ letter_val.1)] = count_val;\n        }\n        \n        \n        if (freq_val.size\
    \ == 0)\n        {\n            break;\n        }\n        \n        count +=\
    \ 1;\n        \n    }\n    \n    \n    let mut ret_val: Nullable<long> = __null_dict();\n\
    \    \n    if !__null_dict(freq).is_empty()\n    {\n        ret_val = (count,\
    \ freq);\n    }\n    else\n    {\n        ret_val = __null_dict();\n    }\n  \
    \  \n    \n    \n    return ret_val;\n    \n}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return a list of\n    all possible combinations\
    \ of letters.\n    Example:\n    >>> combos(\"a b c\")\n    [[\"a\", \"b\", \"\
    c\"], [\"a\", \"c\", \"b\"], [\"b\", \"a\", \"c\"], [\"b\", \"c\", \"a\"], [\"\
    c\", \"a\", \"b\"]]\n    >>> combos(\"a b c\")\n    [[\"a\", \"b\", \"c\"], [\"\
    a\", \"c\", \"b\"], [\"b\", \"a\", \"c\"], [\"b\", \"c\", \"a\"], [\"c\", \"a\"\
    , \"b\"]]\n    >>> combos(\"a b c a b\")\n    [[\"a\", \"b\", \"c\", \"a\", \"\
    b\"], [\"a\", \"b\", \"c\", \"b\", \"a\"], [\"a\", \"c\", \"b\", \"a\", \"b\"\
    ], [\"a\", \"c\", \"b\", \"b\", \"a\"], [\"b\", \"a\", \"c\", \"a\", \"b\"], [\"\
    b\", \"a\", \"c\", \"b\", \"a\"], [\"b\", \"c\", \"a\", \"a\", \"b\"], [\"b\"\
    , \"c\", \"a\", \"b\", \"a\"], [\"c\", \"a\", \"b\", \"a\", \"b\"], [\"c\", \"\
    a\", \"b\", \"b\", \"a\"]]\n    >>> combos(\"\")\n    [[]]", "{\n    map: map![];\n\
    \    map!(test, char => {map[char] ?= 0; map[char] += 1;});\n    map: map!map;\n\
    \    map: map!(map, function(v: long, k: char) -> long {\n        if (v >= 0)\
    \ {\n            map[k];\n        }\n        return 0;\n    });\n    map: map!map;\n\
    \    map: map!(map, function(v: long, k: char) -> (long) -> (long) {\n       \
    \ if (v >= 0) {\n            map[k];\n        }\n        return function(v: long)\
    \ -> (long) -> long {\n            return v;\n        };\n    });\n    map: map!map;\n\
    \    map: map!(map, function(v: long, k: char) -> (long) -> long {\n        if\
    \ (v >= 0) {\n            map[k];\n        }\n        return function(v: long)\
    \ -> (long) -> long {\n            return v;\n        };\n    });\n    map: map!(map,\
    \ function(v: long, k: char) -> (long) -> long {\n        if (v >= 0) {\n    \
    \        map[k];\n        }\n        return function(v: long) -> (long) -> long\
    \ {\n            return v;\n        };\n    });\n    map: map!(map, function(v:\
    \ long, k: char) -> (long) -> long {\n        if (v >= 0) {\n            map[k];\n\
    \        }\n        return function(v: long) -> (long) -> long {\n           \
    \ return v;\n        };\n    });\n    map: map!(map, function(v: long, k: char)\
    \ -> (long) -> long {\n        if (v >= 0) {\n            map[k];\n        }\n\
    \        return function(v: long) -> (long) -> long {\n            return v;\n\
    \        };\n    });\n    map: map!map;\n    map: map!(map, function(v: long,\
    \ k: char) -> (long) -> long {\n        if (v >= 0) {\n            map[k];\n \
    \       }\n        return function(v: long) -> (long) -> long {\n            return\
    \ v;\n        };\n    });\n    map: map!(map, function(v: long, k: char) -> (long)\
    \ -> long {\n        if (v >= 0) {\n            map[k];\n        }\n        return\
    \ function(v: long) -> (long) -> long {\n            return v;\n        };\n \
    \   });\n    map: map!(map, function(v: long, k: char) -> (long) -> long {\n \
    \       if (v >= 0) {\n            map[k];\n        }\n        return function(v:\
    \ long) -> (long) -> long {\n            return v;\n        };\n    });\n    map:\
    \ map!(map, function(v: long, k: char) -> (long) -> long {\n        if (v >= 0)\
    \ {\n            map[k];\n        }\n        return function(v: long) -> (", "{\n\
    \    return histogram(std.algorithmic.map!(std.string.length, test.split(\" \"\
    )));\n}\n\"\"\"\ndef histograms(self):\n    return self.call_with_signature('histogram',\
    \ signature(Nullable[long[string]]))", "{\n    var histo = ___dict___();\n   \
    \ var split = test.split(\" \");\n    for(int i = 0; i < split.length; i ++)\n\
    \    {\n        var str = split[i];\n        var count = histo[str];\n       \
    \ if(count == null)\n        {\n            histo[str] = 1;\n        }\n     \
    \   else\n        {\n            histo[str] ++;\n        }\n    }\n    return\
    \ histo;\n}\n/*\nGiven a string representing a space separated lowercase letters,\
    \ return an associative array\n    of the letter with the most repetition and\
    \ containing the corresponding count.\n    If several letters have the same occurrence,\
    \ return all of them.\n    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"\
    a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"\
    a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\")\n    [\"a\": 2L,\
    \ \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n\
    \    >>> histogram(\"\")\n    ___null_dict___\n    \n    \n*/\nNullable!(long[string])\
    \ histogram(string test, long maxLetterCount)\n{\n    var histo = ___dict___();\n\
    \    var split = test.split(\" \");\n    for(int i = 0; i < split.length; i ++)\n\
    \    {\n        var str = split[i];\n        var count = histo[str];\n       \
    \ if(count == null)\n        {\n            histo[str] = 1;\n        }\n     \
    \   else\n        {\n            histo[str] ++;\n        }\n    }\n    var histo2\
    \ = ___dict___();\n    for(var key in histo)\n    {\n        if(histo[key] > maxLetterCount)\n\
    \        {\n            histo2[key] = histo[key];\n        }\n    }\n    return\
    \ histo2;\n}\n/*\nGiven a string representing a space separated lowercase letters,\
    \ return an associative array\n    of the letter with the most repetition and\
    \ containing the corresponding count.\n    If several letters have the same occurrence,\
    \ return all of them.\n    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"\
    a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"\
    a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\")\n    [\"a\": 2L,\
    \ \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n\
    \    >>> histogram(\"\")\n    ___null_dict___\n    \n    \n*/\nNullable!(long[string])\
    \ histogram(string test, ", "{\n  long maxCount = 0;\n  long maxLetter = 0;\n\
    \  string currentLetter = \"\";\n  for (char c : test)\n  {\n    if (std.isAlpha(c))\n\
    \    {\n      if (currentLetter != c)\n      {\n        currentLetter = c;\n \
    \     }\n      else\n      {\n        ++currentLetter;\n      }\n    }\n    else\n\
    \    {\n      if (currentLetter != \"\")\n      {\n        --currentLetter;\n\
    \      }\n      ++maxCount;\n    }\n  }\n  \n  Nullable!(long) result = map! (lambda\
    \ (letter, count) new Nullable(letter, count)) (\n    collect(groupBy! (letter)\
    \ test)\n  );\n  \n  if (maxCount > 0)\n  {\n    return result;\n  }\n  else\n\
    \  {\n    Nullable!(long) nullDict = new Nullable(\"\", 0);\n    return nullDict;\n\
    \  }\n}", "{\n    int i = 0;\n    Nullable!(long[string]) result = null;\n   \
    \ \n    for i in test.split(\" \") {\n        if (test.contains(i)) {\n      \
    \      if (result == null) {\n                result = { i : 1 };\n          \
    \  }\n            else {\n                Nullable!(long) current_count = result[i\
    \ as string];\n                \n                if (current_count == null) {\n\
    \                    result[i as string] = 1L;\n                }\n          \
    \      else {\n                    Nullable!(long) new_count = current_count +\
    \ 1L;\n                    \n                    if (new_count > result[i as string])\
    \ {\n                        result[i as string] = new_count;\n              \
    \      }\n                }\n            }\n        }\n    }\n    \n    if (result\
    \ == null) {\n        result = { }; \n    }\n    \n    return result;\n}", " \
    \   where {\n    long temp = 0;\n    map: map!{};\n    for (i = 0; i < test.length;\
    \ ++i)\n        if (test[i] != \" \")\n            for (j = 0; j < test.length;\
    \ ++j)\n                if (test[i] == test[j])\n                    map[test[i]]\
    \ += 1;\n                else \n                    if (map[test[i]] > temp)\n\
    \                        temp  = map[test[i]];\n                    map[test[i]]\
    \ = 1;\n    return map[test.last()].isDefined ? map.toMap().filterKeys(k => k\
    \ == test.last()).toMap() : map.toMap();\n}", "{\n    Nullable!(long[string])\
    \ histogram = Nullable!(long[string]());", "{\n    var __result__ : Nullable!(long[string])\
    \ =\n        Nullable!((long[string] with\n            get => 0,\n           \
    \ set => 0,\n            toArray => []\n        ));\n    \n    var __tests__ :\
    \ Iterable<int> =\n        test.splitByAll(\" \").map(test => test.toInt);\n \
    \   \n    var __count__ : int =\n        __tests__.toList().foldLeft<int>(0)((memo,\
    \ test) =>\n            memo + __tests__.find(__test => __test == test).count\n\
    \        );\n    \n    var __test__ : int =\n        __tests__.toList().max();\n\
    \    \n    __tests__.forEach(__test =>\n        {\n            __result__.get\
    \ += 1;\n            \n            var __temp__ : long[string] =\n           \
    \     __result__.toArray();\n            \n            __temp__.push(__test);\n\
    \            __result__.set += __count__;\n            __result__.toArray = __temp__;\n\
    \        }\n    );\n    \n    return __result__;\n}\n/*\n Given a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the most repetition and containing the corresponding count.\n  \
    \  If several letters have the same occurrence, return all of them.\n    \n  \
    \  Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___",
  "{\n    var result={};\n    var count=0;\n    var items=test.split(\" \");\n   \
    \ foreach (a in items) {\n        var item=a.trim();\n        if (item==\"\")\
    \ {\n            continue;\n        }\n        if (item not in result) {\n   \
    \         result[item]=0;\n        }\n        result[item] += 1;\n        count+=1;\n\
    \    }\n    foreach (item in result) \n    {\n        if (result[item] > 1) {\n\
    \            result[item]=result[item];\n            result[item]=count;\n   \
    \     }\n    }\n    \n    return Nullable(result);\n}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the least repetition and containing the corresponding count.\n \
    \   If several letters have the same occurrence, return all of them.\n    \n \
    \   Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\":\
    \ 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"b\": 2L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n\
    \    ___null_dict___\n    \n    \n*/\nNullable!(long[string]) histogram2(string\
    \ test) \n{\n    var result={};\n    var count=0;\n    var items=test.split(\"\
    \ \");\n    foreach (a in items) {\n        var item=a.trim();\n        if (item==\"\
    \") {\n            continue;\n        }\n        if (item not in result) {\n \
    \           result[item]=0;\n        }\n        result[item] += 1;\n        count+=1;\n\
    \    }\n    foreach (item in result) \n    {\n        if (result[item] == 1) {\n\
    \            result[item]=result[item];\n            result[item]=count;\n   \
    \     }\n    }\n    \n    return Nullable(result);\n}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the most occurrence and containing the corresponding count.\n  \
    \  If several letters have the same occurrence, return all of them.\n    \n  \
    \  Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"b\": 2L, \"a\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> ", "{\n    Nullable result;\n\
    \    \n    // Count up the occurrence of each letter\n    foreach(test, |letter|\
    \ {\n        \n        var count = std.dictionary.count(map!(test.chars, |c| c\
    \ == letter).keys);\n        result = map!(count, |x| (letter, x));\n    });\n\
    \    \n    \n    return result;\n}\n/*\nGiven a string, return a list of words\
    \ in the string which are separated by space characters,\n    i.e. the string\
    \ consists of only letters or digits. A word is a sequence of letters \n    separated\
    \ by spaces. The function should return a list of strings. A word is a sequence\
    \ of\n    letters separated by spaces. The function should return a list of strings.\
    \ \n    \n    Example:\n    >>> words(\"a b is c\")\n    [\"a b\", \"is c\"]\n\
    \    >>> words(\"a b is c a b\")\n    [\"a b\", \"is c\", \"a b\"]\n    >>> words(\"\
    a b is c a b c\")\n    [\"a b\", \"is c\", \"a b\", \"c\"]\n    >>> words(\"a\
    \ b c a b c\")\n    [\"a b\", \"is c\", \"a b\", \"c\"]\n    \n    \n*/\nNullable!(list[string])\
    \ words(string test) \n{\n    Nullable result;\n    \n    foreach(test, |c| {\n\
    \        \n        var words = std.array.array!(string);\n        foreach(map!(test.chars,\
    \ |c| c == ' '), |c| {\n            \n            foreach(words.array, |w| {\n\
    \                \n                if(w == \"\")\n                    w = c;\n\
    \                else if(w != c)\n                    w = w + \" \" + c;\n   \
    \         });\n        });\n        \n        foreach(words.array, |w| {\n   \
    \         \n            if(w != \"\")\n                result = map!(w.split(\"\
    \ \"), |w| {\n                    (w, 1);\n                })\n              \
    \  |> map!(|(w, repeat)| {\n                    (w, repeat);\n               \
    \ });\n        });\n        \n    });\n    \n    return result;\n}\n/*\nGiven\
    \ a string representing a space-separated uppercase letters, return an associative\
    \ array\n    of the letter with the most repetition and containing the corresponding\
    \ count.\n    If several letters have the same occurrence, return all of them.\n\
    \    \n    Example:\n    >>> histogram(\"A B C\")\n    [\"A\": 1L, \"B\": 1L,\
    \ \"C\": 1L].nullable\n    >>> histogram(\"A B B A\")\n    [\"A\": 2L, \"B\":\
    \ 2L].nullable\n    >>> histogram(\"B A C\")\n    [\"B\": 1L, \"A\": 1L, \"C\"\
    : 1L].nullable\n    >>> ", "{\n    var dict: [string: long] = __dict___;\n   \
    \ for(var index = 0; index < test.length; ++index)\n    {\n        var letter:\
    \ char = test[index];\n        if(!has(dict, letter))\n            dict[letter]\
    \ = 1;\n        else\n            dict[letter] += 1;\n    }\n    var result: [string:\
    \ long] = dict;\n    result.nullable = dict;\n    return result;\n}", "{\n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n", "{\n    var d = Nullable[long[string]]();\n\
    \    var m = 1L;\n    var mc = 1L;\n    \n    var words = split(test);\n    foreach(word,\
    \ words)\n    {\n        var x = find(d, word);\n        if(x==None) \n      \
    \  {\n            d[word] = 1L;\n        }\n        else\n        {\n        \
    \    d[word] += x;\n        }\n    }\n    \n    foreach(k, d)\n    {\n       \
    \ m += d[k];\n    }\n    \n    return Nullable[long[string]](m, d);\n}", "{\n\
    \   //TODO: this function is only used by histogram2 \n   Nullable!(long[string])\
    \ histogram, counts;\n   string[] split = test.split(' ');\n   if(split.length\
    \ == 0)\n   {\n       histogram.isNull = true;\n       return histogram;\n   }\n\
    \   if(split.length == 1)\n   {\n       histogram.isNull = false;\n       histogram.key\
    \ = split[0];\n       counts[split[0]] = 0;\n       return histogram;\n   }\n\
    \   \n   histogram.isNull = false;\n   histogram.key = split[0];\n   counts[split[0]]\
    \ = 1;\n   \n   for(int i = 1; i < split.length; i++)\n   {\n       if(split[i]\
    \ != split[i - 1])\n       {\n           histogram.key += ' '; \n           histogram.key\
    \ += split[i];\n           counts[split[i]] += 1;\n       }\n   }\n   return histogram;\n\
    }", "{\n    Nullable! histogram(test.split());\n}", "{\n    Nullable!(long[string])\
    \ result;\n    \n    map!(test, |s| \n        ifelse!(isLetter(s), \n        \
    \    \n            map!(split(s), |s| \n                map!(s, |c| \n       \
    \             ifelse!(isLetter(c), \n                        \n              \
    \          ifelse!(result.contains(c), \n                            \n      \
    \                      result[c] += 1,\n                            \n       \
    \                     result[c] = 1\n                            \n          \
    \              ), \n                        \n                        result[c]\
    \ = 1\n                    )\n                )\n            ), \n           \
    \ \n            result[\"\"] = 1,\n        )\n    );\n    \n    return result;\n\
    }", "{\n\tlet letters = test.split (\" \");\n\tlet dict = dict (letters: 1L);\n\
    \tfor each (a in letters)\n\t{\n\t\tif  (dict .containsKey (a))\n\t\t{\n\t\t\t\
    dict [a] += 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdict [a] = 1;\n\t\t}\n\t}\n\treturn\
    \ dict ;\n}", "{\n    Nullable! result = new Nullable!();\n    for(let i of test.split(\"\
    \ \")) {\n        let count =\n            __std.dictionary.lookup(result, i).__std.toLong().__std.toNullable().__toLong();\n\
    \        if (count.isNull || count.toLong() == 0) {\n            __std.dictionary.lookup(result,\
    \ i) = new Nullable!();\n        } else {\n            __std.dictionary.lookup(result,\
    \ i) = new Nullable!(count.toLong());\n        }\n    }\n    __std.dictionary.lookup(result,\
    \ null) = Nullable!();\n    return result;\n}", "{\n\tvar max: long;\n\tvar result:\
    \ long[string]; \n\tforeach(test in test.split(\" \")){\n\t\tif(length(test) ==\
    \ 0){continue;}\n\t\tvar tmp: long = 1;\n\t\tif(length(test) == 1){\n\t\t\ttmp\
    \ = 1;\n\t\t}else{\n\t\t\tforeach(k in test.splitstring(1)){\n\t\t\t\ttmp *= cast(k,\
    \ long);\n\t\t\t}\n\t\t}\n\t\tif(tmp > max){\n\t\t\tresult = null();\n\t\t\tmax\
    \ = tmp;\n\t\t}else{\n\t\t\tresult = append(result, k=>tmp);\n\t\t}\n\t}\n\treturn\
    \ result;\n}", "{\n\tNullable result = Nullable!{[string: int]};\n\tforall(test,\
    \ x => {\n\t\tif(!x.isspace()) result.upsert(x, 1L);\n\t\telse\n\t\t{\n\t\t\t\
    if(result.exists(x))\n\t\t\t{\n\t\t\t\tint prev = result[x];\n\t\t\t\tresult[x]\
    \ = result.exists(x) ? prev + 1 : 1L;\n\t\t\t}\n\t\t}\n\t});\n\treturn result;\n\
    }", "{\n\ttest=toLowerFirst(test);\n\tlet result = std.array();\n\t\n\tlet testChars:\
    \ Set = std.set();\n\tfor(let char of test)\n\t{\n\t\tif(char !=\" \") \n\t\t\
    {\n\t\t\ttestChars.add(char);\n\t\t}\n\t}\n\t\n\tfor(let char of testChars)\n\t\
    {\n\t\tlet count = std.count(test,char);\n\t\tif(count>0)\n\t\t{\n\t\t\tresult.add([char,count]);\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n    var d = ___dict___;\n    var res = ___nullable_dict____;\n\
    \    foreach(test, x=>{\n        if(hasKey(x,d))\n        {\n            ++d[x];\n\
    \        } else {\n            d[x] = 1;\n        }\n        if(hasKey(x,res))\n\
    \        {\n            ++res[x];\n        } else {\n            res[x] = 1;\n\
    \        }\n    });\n    return res;\n}\nimport std.string;\nimport std.array;\n\
    import std.conv;\n/*\nGiven an int array, return the maximum possible sum.\n \
    \   \nExample:\n    >>> max_values([1,2,4])\n    6\n    >>> max_values([0,1,2,3])\n\
    \    0\n    \n*/\nNullable!(int) max_values(int array) \n{\n    var res = 0;\n\
    \    var index = 0;\n    foreach(array[i], x=>\n    {\n        foreach(array[i+1],\
    \ y=>\n        {\n            if(x>y) {\n                if(x>res) {\n       \
    \             res = x;\n                }\n                if(i<array.length-1)\
    \ {\n                    ++i;\n                }\n            }\n        });\n\
    \    });\n    return res;\n}\nimport std.string;\nimport std.conv;\n/*\nGiven\
    \ an int array, return a string array of the unique strings in the array.\n  \
    \  \nExample:\n    >>> unique_strings([1,2,4,3,5,7,2])\n    [\"2\", \"4\", \"\
    7\", \"5\"]\n    >>> unique_strings([1,2,4,3,5,7,2,5,6,2])\n    [\"2\", \"4\"\
    , \"5\", \"6\", \"7\"]\n    \n*/\nNullable!(string array) unique_strings(int array)\
    \ \n{\n    var res = ___nullable_array___;\n    foreach(array[i], x=>\n    {\n\
    \        if(!hasKey(x,res))\n        {\n            res.add(x);\n        }\n \
    \   });\n    return res;\n}\nimport std.string;\nimport std.conv;\n/*\nGiven an\
    \ int array, return an associative array of strings to the sum of the first elements\n\
    \    of the int array.  \n    \nExample:\n    >>> sum_first_values([1,2,3])\n\
    \    {\"a\": 3, \"b\": 4, \"c\": 6}\n    >>> sum_first_values([1,2,3])\n    ___null_dict___\n\
    \    \n*/\nNullable!(string[string]) sum_first_values(int array) \n{\n    var\
    \ res = ___dict___;\n    foreach(array[i], x=>\n    {\n        if(hasKey(x,res))\n\
    \        {\n            res[x] += array[i];\n        } else {\n            res[x]\
    \ = array[i];\n        }\n    });\n    return res;\n}\nimport std.string;\nimport\
    \ std.conv", "    : Dict<string, long> =\n    \n    test\n    .split(\" \")\n\
    \    |> Array.mapi (fun i letter -> (letter, i))\n    |> Array.toList\n    |>\
    \ List.groupBy fst\n    |> List.sortBy(snd) \n    |> List.map (fun (letter, i)\
    \ -> {letter, i} )\n    |> List.tryPick (fun (letter, i) -> if i >= 2 then Some(letter,\
    \ (i)) else None)\n    |> List.map (fun (letter, i) -> {letter, i})\n    |> List.filter(fun\
    \ (letter, i) -> i >= 2)\n    |> List.sortBy(fun (_, i) -> i)\n    |> List.map(fun\
    \ (letter, i) -> letter)\n    |> Dict\n;\n*/\n/* \n    Given a string, return\
    \ an associative array with the letter with the most repetition\n    and containing\
    \ the corresponding count.\n    If several letters have the same occurrence, return\
    \ all of them.\n    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"a\":\
    \ 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"\
    a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\")\n    [\"a\": 2L,\
    \ \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n\
    \    >>> histogram(\"\")\n    ___null_dict___\n    \n    \n*/\nNullable!(long[string])\
    \ histogram(string test) \n    : Dict<string, long> =\n    \n    test\n    .split(\"\
    \ \")\n    |> Array.mapi (fun i letter -> (letter, i))\n    |> Array.toList\n\
    \    |> List.groupBy fst\n    |> List.sortBy(snd) \n    |> List.map (fun (letter,\
    \ i) -> {letter, i} )\n    |> List.tryPick (fun (letter, i) -> if i >= 2 then\
    \ Some(letter, (i)) else None)\n    |> List.map (fun (letter, i) -> {letter, i})\n\
    \    |> List.filter(fun (letter, i) -> i >= 2)\n    |> List.sortBy(fun (_, i)\
    \ -> i)\n    |> List.map(fun (letter, i) -> letter)\n    |> Dict\n;\n/* \n   \
    \ Given a string, return an associative array with the letter with the most repetition\n\
    \    and containing the corresponding count.\n    If several letters have the\
    \ same occurrence, return all of them.\n    \n    Example:", "{\n\tvar counter:long[string]\
    \ = __builtins__.dict([]);\n\t\n\tforeach ( ch in test ) \n\t{\n\t\tif( !counter.containsKey(ch)\
    \ ) counter[ch] = 0L;\n\t\tcounter[ch] += 1;\n\t}\n\t\n\tforeach ( ch in counter\
    \ ) \n\t{\n\t\tif( counter[ch] > counter[chr(ch)]) counter[chr(ch)] = counter[ch];\n\
    \t}\n\t\n\treturn counter;\n}\n/*\nGiven a string representing a space separated\
    \ lowercase letters, return a string\n    consisting of the letters with the most\
    \ repetition and containing the\n    corresponding count.\n    If several letters\
    \ have the same occurrence, return all of them.\n    \n    Example:\n    >>> mostRepeated(\"\
    a b c\")\n    \"a b c\"\n    >>> mostRepeated(\"a b b a\")\n    \"a b\"\n    >>>\
    \ mostRepeated(\"a b c a b\")\n    \"a b c a b\"\n    >>> mostRepeated(\"b b b\
    \ b a\")\n    \"b b b b a\"\n    >>> mostRepeated(\"a b c a b a b a\")\n    \"\
    a b c a b a b a\"\n    >>> mostRepeated(\"b b b a b b b b a b c a\")\n    \"b\
    \ b b a b b b b a b c a\"", "{\n    local long total = 0;\n    local long max;\n\
    \    local Nullable<string> best;\n    \n    foreach(l, test.split(\" \")) {\n\
    \        total += l==null? 0:1;\n        if(total>max) {\n            max = total;\n\
    \            best = l;\n        }\n    }\n    \n    foreach(l, test.split(\" \"\
    )) {\n        if(l==best)\n            total -= 1;\n        else\n           \
    \ total += 1;\n    }\n    \n    return Nullable({\"name\": best, \"count\": total});\n\
    }", "{\n    var ans = __dict_new();\n    \n    foreach (var e in test.chars)\n\
    \    {\n        var t = __dict_get(ans,e);\n        if(!t)\n        {\n      \
    \      ans[e] = (__long(1),__long(0));\n        }\n        else\n        {\n \
    \           var n = __long(t[0]);\n            if(n==__long(0))\n            {\n\
    \                ans[e] = (__long(1),__long(0));\n            }\n            else\n\
    \            {\n                var c = __long(t[1]) + 1;\n                ans[e]\
    \ = (__long(c),__long(n));\n            }\n        }\n    }\n    \n    return\
    \ ans;\n}\n/*\nWrite a function that will reverse a string.\n    \n    Example:\n\
    \    >>> reverse(\"a b c d\")\n    \"d c b a\"", "{\n    Nullable!{long[string]}\n\
    \    let max: Nullable!(long[string]) = Nullable![];\n    let counts: Nullable!(long[string])\
    \ = Nullable![];\n    for (let i = 0; i < test.length; ++i) {\n        let char\
    \ = test[i];\n        let pos = test.indexOf(char);\n        // If this is first\
    \ time seeing this letter, add it.\n        if !counts.containsKey(char) {\n \
    \           counts.put(char, 1L);\n            // If this is the first time seeing\
    \ this letter, update max.\n        } else {\n            let count = counts.get(char);\n\
    \            counts.put(char, count + 1L);\n            // If the count is greater\
    \ than max, update max.\n            if count > max.get(char) {\n            \
    \    max.put(char, count);\n            }\n        }\n    }\n    // Return max\
    \ if it is not null, otherwise return null.\n    return max.get(test) != null?\
    \ max.get(test): Nullable!null;\n}\n/*\nGiven a string representing a space separated\
    \ lowercase letters, return an associative array\n    of the letter with the most\
    \ repetition and containing the corresponding count.\n    If several letters have\
    \ the same occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"\
    a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"\
    a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___", "{\n  \
    \  Nullable!(long[string]) histogram[char] = \n    {\n        string s = tostring(test);\n\
    \        Nullable!(long[string]) histogram[char]= Nullable!(long[string]::new)\n\
    \        \n        foreach(char c in s) \n        {\n            histogram[char][c]\
    \ = histogram[char][c].plus(1L);\n        }\n    };\n    return histogram;\n}",
  "{\n\tlong result = dict[char].reduce((a, e) -> a + dict[e], 0L);\n\tif (test[0]\
    \ == null)\n\t\treturn Nullable!([char]: (dict[char], result));\n\telse\n\t\t\
    return Nullable!([char]: (dict[char]++, result));\n}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the most repetition and containing the corresponding count.\n  \
    \  If several letters have the same occurrence, return all of them.\n    \n  \
    \  Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___",
  "{\n    string s = test;\n    long result = null;\n    \n    for (string word :\
    \ string(split(s, \" \")))\n    {\n        long count = 1;\n        \n       \
    \ for (string letter : string(split(word, \" \")))\n        {\n            count\
    \ *= std.dictionary.lookup(letter.char).count;\n        }\n        \n        if(result\
    \ == null)\n        {\n            result = count;\n        }\n        else\n\
    \        {\n            if(count > result)\n            {\n                result\
    \ = count;\n            }\n        }\n    }\n    \n    if(result == null)\n  \
    \  {\n        result = 1;\n    }\n    \n    return Nullable(result);\n}", "{\n\
    \    Nullable[long] hist = __dict_get(histograms, test, 1L);\n    if (!hist.hasValue)\n\
    \    {\n        hist.value = histogram(test, histograms[test]);\n        histograms[test]\
    \ = hist.value;\n    }\n    return hist.value;\n}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the most repetition and containing the corresponding count.\n  \
    \  If several letters have the same occurrence, return all of them.\n    \n  \
    \  Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___\n\
    */\nNullable!(long[string]) histogram(string test, Nullable[long] hist) \n{\n\
    \    Nullable[long] dict = __dict_get(histograms, test, 1L);\n    if (!dict.hasValue)\n\
    \    {\n        dict.value = histogram(test, hist);\n        histograms[test]\
    \ = dict.value;\n    }\n    return dict.value;\n}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the most repetition and containing the corresponding count.\n  \
    \  If several letters have the same occurrence, return all of them.\n    \n  \
    \  Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___\n\
    */\nNullable!(long[string]) histogram(string test, Nullable[long] hist, Nullable[long]\
    \ dict) \n{\n    Nullable[long] max = __dict_get(histograms, test, 1L);\n    if\
    \ (!max.hasValue)\n    {\n        max.value = histogram(test, hist, dict);\n \
    \       histograms[test] = max.value;\n    }\n    return max.value;\n}", "   \
    \ where {\n        Nullable!(long) tests = histogram(test, 1L, 0);\n        var\
    \ result = new Nullable!(long);\n        \n        for each (test in tests) result.content\
    \ = result && \n            result || tests[test]; \n        \n        \n    \
    \    return result;\n}", "        : \"long\" =\n    {\n        match test.split(\"\
    \ \") with\n        | [letter] -> Nullable[long, string, Nullable[long,string]](length:\
    \ test, letter: letter, count: 1)\n        | _::tail ->\n            let result\
    \ = histogram(tail)\n            if result == null then null else result\n   \
    \ }\n    \n/*\nGiven a string of characters, return a string that represents its\
    \ frequency distribution.\n    \n    Example:\n    >>> frequency(\"a b c\")\n\
    \    \"acb\"\n    >>> frequency(\"a b b a\")\n    \"abaa\"\n    >>> frequency(\"\
    a b c a b\")\n    \"abcaabb\"\n    >>> frequency(\"b b b b a\")\n    \"bababba\"\
    \n    >>> frequency(\"\")\n    ___null_dict___", "{\n   var counts:long[string]\
    \ = __map_to_longs(test); \n   var largest:long[string]; \n   var i:uint=0; \n\
    \   for each (let key:string in counts) \n   { \n     if largest[string]==nil\
    \ \n       largest[string]=counts[key]; \n     else \n       largest[string]=std.math.max(counts[key],largest[string]);\
    \ \n   } \n   return largest; \n}", "{\n    Nullable!(long[string]) histogram\
    \ = {};\n    for (let i = 0, len = test.length; i < len; ++i)\n    {\n       \
    \ let ch = test.charAt(i);\n        histogram[ch] = histogram.hasOwnProperty(ch)\
    \ ? histogram[ch] + 1L : 1L;\n    }\n    return histogram;\n}\n/*\nGiven a string\
    \ representing a space separated lowercase letters, return a string containing\
    \ the most \nfrequent letter in the string. If several letters have the same occurrence,\
    \ return all of them.\nExample\n    >>> most_frequent_letter(\"a b c\")\n    \"\
    a\"\n    >>> most_frequent_letter(\"a b c a b\")\n    \"a\"\n    >>> most_frequent_letter(\"\
    a b c a b\")\n    \"a\"\n    >>> most_frequent_letter(\"\")\n    ___null_dict___\n\
    */\nNullable!(char) most_frequent_letter(string test) \n{\n    Nullable!(char)\
    \ most_frequent_letter = null;\n    let histogram = histogram(test);\n    let\
    \ max_key = 1;\n    let max_value = -1;\n    for (let key in histogram)\n    {\n\
    \        let value = histogram[key];\n        if (value > max_value)\n       \
    \ {\n            max_value = value;\n            most_frequent_letter = key;\n\
    \        }\n        else if (value == max_value)\n        {\n            if (value\
    \ < max_value)\n            {\n                max_value = value;\n          \
    \      most_frequent_letter = key;\n            }\n        }\n    }\n    return\
    \ most_frequent_letter;\n}\n/*\nGiven a string representing a space separated\
    \ lowercase letters, return an associative array\n    of the letter with the most\
    \ repetition and containing the corresponding count.\n    If several letters have\
    \ the same occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"\
    a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"\
    a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___", "  :->\
    \ long[string]\n{\n    var result : Nullable[(string, long)] = ___null_dict___;\n\
    \    foreach(l, t in split(test, \" \"))\n    if (count(result) == 0 ||\n    \
    \    count((result[l], result[l])) == 1)\n    {\n        result[l] = t;\n    }\n\
    \    else \n    {\n        var c = count((result[l], result[l]));\n        if\
    \ (c == 0)\n        {\n            result[l] = t;\n        }\n        else\n \
    \       {\n            if (c > result[tostring(result[l])])\n            {\n \
    \               result[l] = t;\n            }\n        }\n    }\n    return result;\n\
    }", "\t: Nullable!(dict[char,long])\n{\n\tNullable!(long[string]) res = null;\n\
    \tif (test==null || test==\"\")\n\t\treturn res;\n\tvar res = toDict!(test.split());\n\
    \treturn res;\n}", "{\n\tint count = 0;\n\tforeach(char c in test)\n\t{\n\t\t\
    if(!map.containsKey(c))\n\t\t{\n\t\t\tmap[c] = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\
    \tmap[c]++;\n\t\t}\n\t}\n\treturn map;\n}", "{\n    return histogramImpl(test).nullable;\n\
    }\nfunction histogramImpl(string test) \n{\n    var count = long.zero;\n    var\
    \ result = {};\n    var cur = char;\n    var tmp: string;\n    var maxCount =\
    \ 0;\n    var minCount = long.minValue;\n    \n    for (var _i = 0, _a = test.chars;\
    \ _i < _a.length; _i++) {\n        var item = _a[_i];\n        if (item.isWhitespace)\
    \ {\n            continue;\n        }\n        tmp = item;\n        for (var i\
    \ = tmp.length; i > 0; i--) {\n            cur = char.cast(tmp.substring(0, i));\n\
    \            count++;\n            result[cur] = result[cur].isNull ? 1 : result[cur].value+1;\n\
    \            tmp = (tmp.substring(0, i) + tmp.substring(i));\n        }\n    \
    \    if (count > maxCount) {\n            maxCount = count;\n        }\n     \
    \   if (count < minCount) {\n            minCount = count;\n        }\n    }\n\
    \    \n    for (var k in result) {\n        if (result[k] == maxCount) {\n   \
    \         result[k] = k;\n        }\n    }\n    return make_union__union_map(minCount,\
    \ maxCount).nullable;\n}\n/*\nGiven a string representing a space separated lowercase\
    \ letters, return an associative array\n    of the letter with the most repetition\
    \ and containing the corresponding count.\n    If several letters have the same\
    \ occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"a b\
    \ c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a\
    \ b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___", "{\n  \n\
    \  \n  int max = -99999999;\n  long sum = 0;\n  int len = 0;\n  \n  for (int i\
    \ = 0; i < test.length; ++i)\n  {\n    string letter = test.substring(i);\n  \
    \  \n    if (_dict_contains(&histogram(letter).dict, letter)) {\n      sum +=\
    \ histogram(letter).dict[letter];\n      ++len;\n    }\n    else if (histogram(letter).dict[letter]\
    \ > max) {\n      max = histogram(letter).dict[letter];\n    }\n    \n  }\n  \n\
    \  if (sum > 0) {\n    Nullable!(long) n = new Nullable(sum);\n    n.nullable\
    \ = true;\n    n.dict = histogram(test).dict;\n  }\n  else {\n    n = null;\n\
    \  }\n  \n  return n;\n  \n}", "{\n    Nullable!(long[string]) = Nullable!(long[string])([]);\n\
    \    foreach(test, repeat => {\n        Nullable!(long[string]) = map(Nullable!(long[string])[repeat],\
    \ e => e);\n        Nullable!(long[string]) = map(Nullable!(long[string])[repeat]\
    \ + 1, e => e);\n    });\n    Nullable!(long[string]) = map(Nullable!(long[string])[repeat],\
    \ e => e);\n    foreach(test, e => {\n        Nullable!(long[string]) = map(Nullable!(long[string])[repeat]\
    \ + 1, e => e);\n    });\n    Nullable!(long[string]) = map(Nullable!(long[string])[repeat],\
    \ e => e);\n    foreach(test, e => {\n        Nullable!(long[string]) = map(Nullable!(long[string])[repeat]\
    \ + 1, e => e);\n    });\n    Nullable!(long[string]) = map(Nullable!(long[string])[repeat],\
    \ e => e);\n    foreach(test, e => {\n        Nullable!(long[string]) = map(Nullable!(long[string])[repeat]\
    \ + 1, e => e);\n    });\n    Nullable!(long[string]) = map(Nullable!(long[string])[repeat],\
    \ e => e);\n    foreach(test, e => {\n        Nullable!(long[string]) = map(Nullable!(long[string])[repeat]\
    \ + 1, e => e);\n    });\n    Nullable!(long[string]) = map(Nullable!(long[string])[repeat],\
    \ e => e);\n    foreach(test, e => {\n        Nullable!(long[string]) = map(Nullable!(long[string])[repeat]\
    \ + 1, e => e);\n    });\n    Nullable!(long[string]) = map(Nullable!(long[string])[repeat],\
    \ e => e);\n    foreach(test, e => {\n        Nullable!(long[string]) = map(Nullable!(long[string])[repeat]\
    \ + 1, e => e);\n    });\n    Nullable!(long[string]) = map(Nullable!(long[string])[repeat],\
    \ e => e);\n    foreach(test, e => {\n        Nullable!(long[string]) = map(Nullable!(long[string])[repeat]\
    \ + 1, e => e);\n    });\n    Nullable!(long[string]) = map(Nullable!(long[string])[repeat],\
    \ e => e);\n    ", "{\n    int[string][] counts;\n    foreach(char c in test)\
    \ {\n        int i = c - 'a';\n        if (counts[i] > 0) {\n            counts[i]++;\n\
    \        } else {\n            counts[i] = 1;\n        }\n    }\n    int[string]\
    \ letters;\n    foreach(char c in test) {\n        int i = c - 'a';\n        if\
    \ (counts[i] != 0) {\n            letters[counts[i].toString()] = c;\n       \
    \ }\n    }\n    return letters;\n}\n/*\n    Convert a binary string (such as \"\
    101101\") to a decimal (such as 8)\n    \n    Example:\n    >>> binary2decimal(\"\
    101101\")\n    8.0.nullable\n*/\nNullable!(double) binary2decimal(string binary)\
    \ \n{\n    char bits[] = binary.chars;\n    int sum = 0;\n    foreach(char bit\
    \ in bits) {\n        sum += (char)(bit == '1' ? 1 : 0);\n    }\n    return sum\
    \ / 2.0;\n}\n/*\nGiven a string, return the number of characters that begin with\
    \ a particular letter.\n    \nExample: \n    >>> count(\"a\", \"abc\")\n    1\n\
    */\nNullable!(long) count(char letter, string test) \n{\n    foreach(char c in\
    \ test) {\n        if (c != letter) {\n            continue;\n        }\n    \
    \    return 1;\n    }\n    return 0;\n}\n/*\nGiven a string, return the number\
    \ of times the first character occurs in the string.\n    \nExample: \n    >>>\
    \ count(\"a\", \"abc\")\n    1\n*/\nNullable!(long) first(string test, char letter)\
    \ \n{\n    int count = 0;\n    foreach(char c in test) {\n        if (c == letter)\
    \ {\n            count++;\n        }\n    }\n    return count;\n}\n/*\nGiven a\
    \ string, return the number of times the first character occurs in the string.\n\
    \    \nExample: \n    >>> count(\"a\", \"abc\")\n    1\n*/\nNullable!(long) first(string\
    \ test, char letter) \n{\n    int count = 0;\n    foreach(char c in test) {\n\
    \        if (c == letter) {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n    Find all characters in a string that begin with a particular\
    \ character.\n    \n    Example:\n    >>> filter(\"a bc\", \"a\")\n    [\"a\"\
    ].nullable\n*/\nNullable!(string) filter(string test, char letter) \n{\n    foreach(char\
    \ c in test) {\n        if (c == letter) {\n            yield c;\n        }\n\
    \    }\n}\n/*\n    Given a string, returns the sum of all digits. \n    \n   \
    \ Example:\n    >>> sum(\"abcd\")\n    ", "    when (test != \"\")\n    do\n \
    \       let testChars: char[] = test.chars;\n        let histograms: __Dictionary<_,long>\
    \ = dict()\n        \n        for i in 0 .. testChars.length-1 do\n          \
    \  let thisChar = testChars[i];\n            \n            if histograms.containsKey(thisChar)\n\
    \                then histograms.update(thisChar, histograms[thisChar] + 1L);\n\
    \                else\n                    histograms.update(thisChar, 1L);",
  "    where {\n        Nullable!(dict) dd = histogram(test, 0L);\n        if (dd.isNull)\
    \ return dd;\n        if (dd.isDefined && dd.value.isEmpty) return Nullable(dict.empty);\n\
    \        \n        dict d = dd.value.get; // Dictionary where key is string and\
    \ value is long.\n        \n        // Iterate over the remaining letters.\n \
    \       foreach (i=1; i<dd.size; i++) {\n            string key = dd.keys[i];\n\
    \            Nullable!(long) vv = d.get(key); // Get value for key.\n        \
    \    if (vv.isDefined) {\n                d += (vv.get+1)*key;\n            }\
    \ else {\n                d += 0L;\n            }\n        }\n        \n     \
    \   return Nullable(dict{d});\n    }\n}", "    where {\n    \n    long maxCount\
    \ = 0;\n    string maxKey = \"\";\n    foreach (ch in test) \n        if ch =\
    \ ' ' then \n            int count = 0;\n            foreach (c in test) \n  \
    \              if (c == ch) then \n                    count += 1; \n        \
    \    if (count > maxCount) {\n                maxCount = count;\n            \
    \    maxKey = ch;\n            }\n        } else if ch == maxKey {\n         \
    \   int count = count!(maxCount) + 1L;\n            foreach (c in test) \n   \
    \             if (c == ch) then \n                    count -= 1; \n         \
    \   maxCount = count;\n            maxKey = ch;\n        } else {\n          \
    \  foreach (c in test) \n                if (c == ch) then \n                \
    \    maxCount += 1; \n        }\n    Nullable!(long[string]) res;\n    foreach\
    \ (key in keys(test)) \n        if test = key! then \n            res[key] = maxCount;\n\
    \        else\n            res[key] = 0L;\n    return res;\n}", "{\n        Nullable!(long[string])\
    \ result = null;\n        for each (char c in test)\n                if (result.containsKey(c))\n\
    \                        result[c] += 1;\n                else\n             \
    \           result[c] = 1;\n        return result;\n}", "{\n    var __map = Null<long,string>;\n\
    \    var __iter = __test.split();\n    var __len = __iter.len();\n    var __count\
    \ = 0;\n    while (__len > 0) {\n        var __index = 0;\n        while (__index\
    \ < __len) {\n            var __elem = __iter.next();\n            var __test\
    \ = __elem.toString();\n            var __value = __map.get(__test);\n       \
    \     if (__value == null) {\n                __map.set(__test, 1L);\n       \
    \     } else {\n                __map.set(__test, __value + 1);\n            }\n\
    \            __index++;\n        }\n        __len--;\n    }\n    return __map;\n\
    }", "{\n\tNullable!(long[string]) result = Nullable!(long[string]::__null_dict());\n\
    \t\n\tif(test.size() == 0)\n\t\treturn result;\n\t\t\n\tauto l = test;\n\t\n\t\
    for(auto i : l) {\n\t\tauto it = result.try_get(i);\n\t\tif(it.is_some())\n\t\t\
    \tit.as_ref().value()++;\n\t\telse\n\t\t\tresult = result.try_put(i, 1L);\n\t\
    }\n\t\n\treturn result;\n}", "{\n    return histogram(test, null);\n}\n// @test\n\
    // test cases from std.typecons", "{\n    Nullable!(long[string]) result = ___null_dict____;\n\
    \    \n    for(string letter in test.trim().toLowerCase().split(\" \"))\n    {\n\
    \        if(result![letter] == 0L)\n            result![letter] = 1L;\n      \
    \  else\n            result![letter]++;\n    }\n    \n    return result;\n}\n\
    /*\nGiven a string representing a space separated lowercase letters, return an\
    \ associative array\n    of the letter with the most repetition and containing\
    \ the corresponding count.\n    If several letters have the same occurrence, return\
    \ all of them.\n    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"a\":\
    \ 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"\
    a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\")\n    [\"a\": 2L,\
    \ \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n\
    \    >>> histogram(\"\")\n    ___null_dict___", "{\n\tNullable!({string,int})\
    \ #(test: string #-> Nullable!({string,int}))\n\tlet rec histogramImpl test result=\n\
    \t\tmatch test with\n\t\t| x when x=' ' ->\n\t\t\tresult \n\t\t| _ when Char.isLetter(test[0])\
    \ ->\n\t\t\thistogramImpl (test[1:])\n\t\t\t\t(result.insert(test[0], 1L))\n\t\
    \t| _ ->\n\t\t\thistogramImpl (test) result\n\thistogramImpl test Nullable!(())\n\
    }\n/*\nGiven a string representing a space separated lowercase letters, return\
    \ a tuple of two\n    tuples: the first containing the letter with the most repetition\
    \ and the second the \n    number of repetitions. \n    If several letters have\
    \ the same occurrence, return all of them\n    \n    Example:\n    >>> histogram(\"\
    a b c\")\n    (__a__,1L)\n    >>> histogram(\"a b b a\")\n    (__a__,2L)\n   \
    \ >>> histogram(\"a b c a b\")\n    (__a__,2L)\n    >>> histogram(\"b b b b a\"\
    )\n    (__a__,4L)\n    >>> histogram(\"\")\n    ___null_dict___\n    \n    \n\
    */\nNullable!(int*long[string]) histogram(string test) \n{\n\tNullable!({string,int})\
    \ #(test: string #-> Nullable!({string,int}))\n\tlet rec histogramImpl test result=\n\
    \t\tmatch test with\n\t\t| x when x=' ' ->\n\t\t\tresult \n\t\t| _ when Char.isLetter(test[0])\
    \ ->\n\t\t\thistogramImpl (test[1:])\n\t\t\t\t(result.insert(test[0], 1L))\n\t\
    \t| _ ->\n\t\t\thistogramImpl (test) result\n\thistogramImpl test Nullable!(())\n\
    }\n/*\nGiven a string representing a space separated lowercase letters, return\
    \ a tuple of two\n    tuples: the first containing the letter with the most repetition\
    \ and the second the \n    number of repetitions. \n    If several letters have\
    \ the same occurrence, return all of them\n    \n    Example:\n    >>> histogram(\"\
    a b c\")\n    (__a__,1L)\n    >>> histogram(\"a b b a\")\n    (__a__,2L)\n   \
    \ >>> histogram(\"a b c a b\")\n    (__a__,2L)\n    >>> histogram(\"b b b b a\"\
    )\n    (__a__,4L)\n    >>> histogram(\"\")\n    ___null_dict___\n    \n    \n\
    */\nNullable!(int*int*long[string]) histogram(string test", "  if\n    test==null\
    \ or\n    test.isEmpty,\n    Nullable!((long[])[])\n  else\n    match\n      |\
    \ test==\"null\", Nullable!((long[])[])\n      | test==' ', Nullable!((long[])[])\n\
    \      | test==\"_\", Nullable!((long[])[])\n      | test==\"\\t\", Nullable!((long[])[])\n\
    \      | test==\"\\n\" , Nullable!((long[])[])\n      | test==\".\", Nullable!((long[])[])\n\
    \      | otherwise,\n        \n        string !in \"abcdefghijklmnopqrstuvwxyz\"\
    , Nullable!((long[])[])\n      | otherwise, \n        \n        test.split()\n\
    \        |> List.map(fun (char::string) -> char.ToUpper()) \n        |> List.groupBy(fun\
    \ (char) -> char) \n        |> List.iter( fun (char, list) -> \n            if\
    \ list.Length>1\n            then (char, list.Length)\n            else\n    \
    \        Nullable!((long[])[])\n          )\n        |> Nullable!((long[char],\
    \ int))\n  fi\n;\n/* \nGiven a string representing a space separated lowercase\
    \ letters, return an associative array\n    of the letter with the most repetition\
    \ and containing the corresponding count.\n    If several letters have the same\
    \ occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"a b\
    \ c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"a\
    \ b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___", "{\n  \
    \  \n    var counts : long[string] =\n    {\n        \"_null_dict___\": 0\n  \
    \  };\n    \n    var result : long[string];\n    \n    test.split(\" \").foreach(\n\
    \        function(elem : string )\n        {\n            var count = counts[elem];\n\
    \            \n            if( count == 0 ) counts[elem] = 1;\n            else\
    \ counts[elem] += 1;\n        }\n    );\n    \n    foreach(\n        keys(counts),\n\
    \        function(elem : string )\n        {\n            if( counts[elem] ==\
    \ 0 ) result = null;\n            else\n            {\n                result\
    \ = [];\n                result[elem] = counts[elem];\n                \n    \
    \            if( counts[elem] > counts[\"_null_dict___\"] ) result = null;\n \
    \           }\n        }\n    );\n    \n    return result.nullable \n        ?\
    \ result \n        : dict( \n            map( \n                function(key :\
    \ string)\n                {\n                    if( key == \"_null_dict___\"\
    \ ) return null;\n                    return key;\n                }, \n     \
    \           keys(counts)\n            ), \n            map( \n               \
    \ function(key : string, value : long) \n                {\n                 \
    \   if( key == \"_null_dict___\" ) return null;\n                    return value;\n\
    \                }, \n                keys(counts)\n            )\n        );\n\
    }\n/*\nGiven a string representing a space separated lowercase letters, return\
    \ a list of the letter with the most\n    repetition.\n    If several letters\
    \ have the same occurrence, return all of them. \n    \n    Example:\n    >>>\
    \ histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>>\
    \ histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b\
    \ a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___\n\
    \    \n    \n*/\nNullable!(array[string]) histogram(string test) \n{\n    \n \
    \   var counts : long[string] =\n    {\n        \"_null_dict___\": 0\n    };\n\
    \    \n    var result : long[string];\n    \n    test.split(\" \").foreach(\n\
    \        function(elem : string )\n        {\n            var count = counts[elem];\n\
    \            \n            if( count == 0 ) counts[elem] = 1;\n            else\
    \ counts[elem] += 1;\n        }\n    );\n    \n    return result.nullable \n \
    \       ? result \n        : map( \n            function(key ", "{\n    return\
    \ histogram(test, new NullDict());\n}", "    require\n        testLength > 0\n\
    \    ensure\n        test !~ \"^[a-zA-Z]+$\";\n        test !~ \"^\\\\s+$\";\n\
    \    \n    match test with\n        \"\" => ___null_dict___\n        | test.splitRegexp(\"\
    \ \") ~ \"\\\\s+\" ~> __int__ dict;\n        | test.splitRegexp(\" \") ~ \"[a-zA-Z]+\"\
    \ ~> __int__ dict as dict -> dict\n        | test.splitRegexp(\" \") ~ \"[a-zA-Z]+\\\
    \\s+\" ~> __int__ dict as dict -> dict\n        | test.splitRegexp(\" \") ~ \"\
    [a-zA-Z]+\\\\w+\" ~> __int__ dict as dict -> dict\n        | test.splitRegexp(\"\
    \ \") ~ \"[a-zA-Z]+\\\\w+\\\\s+\" ~> __int__ dict as dict -> dict\n        | _\
    \ => __int__ dict\n    ;\n    \nend\nfunction [T] max<T>(T test: T)(T test: T)\
    \ where T : Comparison<int>\n    require\n        test == __int__ dict as \"test\
    \ == __int__ dict as \"\"\n    ;\n    __int__ dict |> Seq.max\nend", "{\n    Array[string,\
    \ long] result= [];\n    \n    foreach (char c in test) {\n        int count=0;\n\
    \        foreach (char e in test) {\n            if (e!=c) {\n               \
    \ if (c==c) count++;\n            }\n            else {\n                result.push([c,\
    \ count]);\n                count = 0;\n            }\n        }\n    }\n    \n\
    \    foreach (char c in test) {\n        long max= 0;\n        foreach (char e\
    \ in test) {\n            if (e!=c) {\n                if (c==c) max++;\n    \
    \        }\n        }\n        result.push([c, max]);\n    }\n    \n    return\
    \ __toNullable(result);\n}", "{\n  if(test.isEmpty) return Null;\n  if(test in\
    \ self) return self[test];\n  \n  var ret: Nullable!{long[string]} = Null;\n \
    \ var counts: Dictionary{string,int} = null;\n  var cnt: int = 0;\n  for(let c\
    \ : string in test)\n  {\n    if(counts == null)\n      counts = Dict{string,int};\n\
    \    counts[c] = counts[c] ?? 0;\n    counts[c]++;\n  }\n  var maxCount = 0;\n\
    \  var maxLetter: string =null;\n  for(let c : string in counts)\n  {\n    if(counts[c]\
    \ > maxCount)\n    {\n      maxCount = counts[c];\n      maxLetter = c;\n    }\n\
    \  }\n  if(maxCount > 0)\n  {\n    self[test] = maxLetter;\n    return maxLetter;\n\
    \  }\n  \n  return ret;\n}\n/*\nGiven a string representing a space separated\
    \ lowercase letters, return an associative array\n    of the letter with the most\
    \ repetition and containing the corresponding count.\n    If several letters have\
    \ the same occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"\
    a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"\
    a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___", "{\n  \
    \  \n    let len = length(test);\n    let d = dict();\n    let max = 0;\n    let\
    \ curr = \"\";\n    \n    for (let i = 0; i < len; i++) \n    {\n        let c\
    \ = test[i];\n        let val = c.isupper() ? tolong(c) : toulong(c);\n      \
    \  let count = val + 1;\n        \n        if (val > max)\n        {\n       \
    \     max = val;\n            curr = c;\n        }\n        \n        if !d.containsKey(curr)\n\
    \        {\n            d[curr] = count;\n        }\n        else\n        {\n\
    \            d[curr] += count;\n        }\n    }\n    \n    if d.isEmpty() then\n\
    \    {\n        return Nullable!(___null_dict___);\n    }\n    else\n    {\n \
    \       return Nullable!((d : long[string])).map(function (v)\n        {\n   \
    \         \n            let result = \"\";\n            let maxV = 0;\n      \
    \      for (let k = 0; k < len; k++)\n            {\n                \n      \
    \          if (d[k] > maxV)\n                {\n                    maxV = d[k];\n\
    \                    result = k;\n                }\n                \n      \
    \      }\n            \n            return result[..<len];\n        });\n    }\n\
    }\nfunction histogram(string test) \n{\n    \n    let len = length(test);\n  \
    \  let d = dict();\n    let max = 0;\n    let curr = \"\";\n    \n    for (let\
    \ i = 0; i < len; i++) \n    {\n        let c = test[i];\n        let val = c.isupper()\
    \ ? tolong(c) : toulong(c);\n        let count = val + 1;\n        \n        if\
    \ (val > max)\n        {\n            max = val;\n            curr = c;\n    \
    \    }\n        \n        if !d.containsKey(curr)\n        {\n            d[curr]\
    \ = count;\n        }\n        else\n        {\n            d[curr] += count;\n\
    \        }\n    }\n    \n    if d.isEmpty() then\n    {\n        return Nullable!(___null_dict___);\n\
    \    }\n    else\n    {\n        return Nullable!((d : long[string])).map(function\
    \ (v)\n        {\n            \n            let result = \"\";\n            let\
    \ maxV = 0;\n            for (let k = 0; k < len; k++)\n            {\n      \
    \          \n                if (d[k] > maxV)\n                {\n           \
    \         maxV = d[k];\n                    result = k;\n                }\n \
    \               \n            }\n            \n            return result[..<len];\n\
    \        });\n    }\n}", "{\n\tNullable!(long[string]) histograms;\n\tNullable!(long)\
    \ maxCount;\n\t\n\tlet count = 0;\n\t\n\tfor each (string letter in test.splitByAll(\"\
    \ \")){\n\t\tif (histograms?[letter] == null){\n\t\t\thistograms?[letter] = count++;\n\
    \t\t}else{\n\t\t\tif (histograms?[letter] > maxCount){\n\t\t\t\tmaxCount = histograms?[letter];\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\tif (maxCount == 0){\n\t\treturn Nullable!(___null_dict___);\n\
    \t}\n\t\n\treturn histograms;\n}", "{\n    var dict = new Dictionary[\"string\"\
    , long];\n    foreach(i | i in test)\n    {\n        if(i == \" \")\n        \
    \    continue;\n        var x = dict.get(i);\n        if(!x)\n        {\n    \
    \        dict[i] = 1L;\n        }\n        else\n        {\n            dict[i]\
    \ = x + 1L;\n        }\n    }\n    return dict;\n}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the most repetition and containing the corresponding count.\n  \
    \  If several letters have the same occurrence, return all of them.\n    \n  \
    \  Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___",
  "{\n\timport std.hash;\n\tmap!(test) {\n\t\thash!(char) >> map!(char) {\n\t\t\t\
    if!(test == char) {\n\t\t\t\t1L;\n\t\t\t} else {\n\t\t\t\t0L;\n\t\t\t}\n\t\t}\n\
    \t};\n\tauto res = map!(test)  {\n\t\tif!(map.containsKey(char)) {\n\t\t\tnull!;\n\
    \t\t} else {\n\t\t\tmap.get(char);\n\t\t}\n\t};\n\treturn res;\n}", "{\n    local\
    \ string __temp_test = \"\";\n    \n    for __temp_test in string.split(test)\
    \ \n        { \n            var __temp_letter = __temp_test;\n            var\
    \ __temp_occurance = 0;\n            \n            \n            for __temp_letter\
    \ in test.words \n                { \n                    __temp_occurance = __temp_occurance\
    \ + test.words[__temp_letter];\n                    \n                } \n   \
    \         \n            __temp_test[__temp_letter] = __temp_occurance;\n     \
    \   }\n    \n    return ___temp_test;\n}", "{\n    string [] keys = test.split(\"\
    \ \");\n    Nullable!(int[string]) counts = __builtins__[\"__import__\"](\"collections\"\
    ).defaultdict(int);\n    Nullable!(int[string]) freqs = __builtins__[\"__import__\"\
    ](\"collections\").defaultdict(int);\n    for(string k : keys) {\n        counts[k]++;\n\
    \        freqs[k]++;\n    }\n    Nullable!(int[string]) max = __builtins__[\"\
    __import__\"](\"collections\").defaultdict(int);\n    Nullable!(int[string]) maxFreq\
    \ = __builtins__[\"__import__\"](\"collections\").defaultdict(int);\n    for(string\
    \ k : keys) {\n        if(freqs[k] > maxFreq[k]) {\n            maxFreq[k] = freqs[k];\n\
    \            max[k] = freqs[k];\n        }\n        else {\n            if(freqs[k]\
    \ > max[k]) {\n                maxFreq[k] = freqs[k];\n                max[k]\
    \ = freqs[k];\n            }\n        }\n    }\n    Nullable!(long[string]) res\
    \ = __builtins__[\"__import__\"](\"collections\").defaultdict(int);\n    for(string\
    \ k : keys) {\n        long num = maxFreq[k];\n        if(num == 0) {\n      \
    \      res[k] = 0;\n        }\n        else {\n            if(freqs[k] > num)\
    \ {\n                res[k] = num;\n            }\n            else {\n      \
    \          res[k] = freqs[k];\n            }\n        }\n    }\n    return res;\n\
    }\n/*\nGiven a string representing a space separated lowercase letters, return\
    \ an associative array\n    of the letter with the highest number of occurrences\
    \ and containing the corresponding count.\n    If several letters have the same\
    \ occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"a b\
    \ c\")\n    {\"a\": 1L, \"b\": 1L, \"c\": 1L}.nullable\n    >>> histogram(\"a\
    \ b b a\")\n    {\"a\": 2L, \"b\": 2L}.nullable\n    >>> histogram(\"a b c a b\"\
    )\n    {\"a\": 2L, \"b\": 2L}.nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ {\"b\": 4L}.nullable\n    >>> histogram(\"\")\n    ___null_dict___\n    \n \
    \   \n*/\nNullable!(int[string]) highest_freq_letters(string test) \n{\n    string\
    \ [] keys = test.split(\" \");\n    Nullable!(int[string]) counts = __builtins__[\"\
    __import__\"](\"collections\").defaultdict(int);\n    Nullable!(int[string]) freqs\
    \ = __builtins__[\"__import__\"](\"", "    => test.splitStr(\" \").fold(Nullable(long[]),\
    \ function((key, value), acc) =>\n        value.fold(Nullable(long[]), function(value,\
    \ acc) =>\n            acc.set(key, value+1)\n        )\n    )\n;\n//import std.container;\n\
    //import std.traits;\n//import std.range;\n//import std.algorithm;\n//import std.stdio;\n\
    //import std.conv;", "{\n    Array< long > histogram = new Array< long > ();\n\
    \    int maxCount = 0;\n    for( int i = 0; i < test.length(); ++i )\n    {\n\
    \        if( histogram[test[i]] == 0 )\n        {\n            histogram[test[i]]\
    \ = 1;\n            maxCount = 1;\n        }\n        else\n        {\n      \
    \      if( histogram[test[i]] > maxCount )\n                maxCount = histogram[test[i]];\n\
    \            \n        }\n    }\n    return histogram;\n}", "{\n  var d = Nullable!(long[string]());\n\
    \  var tokens = test.split(\" \");\n  \n  // for each token, look it up in the\
    \ dictionary\n  foreach(token, tokens) {\n    if(!d.containsKey(token)) {\n  \
    \    d[token] = 0L;\n    } else {\n      d[token] += 1;\n    }\n  }\n  \n  //\
    \ return either all elements or only the max element and count\n  return d.foldRight(\n\
    \      Nullable!(long[string]()),\n      (a, pair) => \n      {\n        if(a.isEmpty)\
    \ {\n          a = pair;\n        } else {\n          if(a[0] > pair[0]) {\n \
    \           a = pair;\n          }\n        }\n        \n        return a;\n \
    \     }\n  );\n}", '  :> Option<__Nullable[long]>;', "{\n    Nullable!(long[string])(\n\
    \        std.array.get_key_from_value!(\n            std.array.get_max_by_keys!(\n\
    \                std.array.count_by_keys!(test),\n                std.typecons.string2long\n\
    \            ),\n            std.typecons.string2long\n        )\n    );\n}",
  "{\n    Nullable!(long[string]) testCases = histogram(test.trim());\n    if(testCases.isNull)\n\
    \    {\n        return Nullable!(long[string])[\"___null_dict___\"];\n    }\n\
    \    long result = __builtin__.long.reduce(testCases.val).val;\n    return Nullable!(long[string])[test.trim()]\
    \ = result;\n}", "{\n  Nullable!(long[string]) result = null;\n  int count = 1;\n\
    \  string currentLetter;\n  \n  for (int i = 0; i < test.length(); ++i) {\n  \
    \  currentLetter = test.substr(i, 1);\n    \n    if (result != null) {\n     \
    \ if (result[currentLetter] == Null!(1)) {\n        result[currentLetter] = count!;\n\
    \      } else if (result[currentLetter] > count) {\n        result[currentLetter]\
    \ = count!;\n      }\n    } else {\n      result = Null!(long[string]);\n    \
    \  result[currentLetter] = count!;\n    }\n    ++count;\n  }\n  return result;\n\
    }", "{\n\t\n\t\n\t\n\t/*\n\t\n\t\n\t*/\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\
    \t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\
    \n\t\n\t\n\t\n", "{\n\tNullable!(long[string]) _histogram = Nullable!(long[string])\
    \ [];\n\t\n\tforall i in test return \n\t{\n\t\tNullable!(long[string]) _tmp =\
    \ Nullable!(long[string]) [];\n\t\t\n\t\tforall j in i.chars() return \n\t\t{\n\
    \t\t\tif((i := i.trim()).isNotEmpty()) \n\t\t\t{\n\t\t\t\t_tmp[String[j.trim()]]++;\n\
    \t\t\t}\n\t\t}\n\t\t\n\t\t_histogram[_histogram[_histogram.keys.max()]] = _histogram.values.max();\n\
    \t\t_histogram[String[i.trim()]] = _histogram.values.max();\n\t\t_histogram[String[_histogram.keys.max()]]\
    \ = _histogram.values.max();\n\t\t_histogram[String[String[_histogram.keys.max()]]\
    \ = _histogram.values.max();\n\t\t_histogram[String[String[String[_histogram.keys.max()]]\
    \ = _histogram.values.max();\n\t}\n}\n/*\nGiven a string representing a space\
    \ separated lowercase letters, return an associative array\n    of the letter\
    \ with the most repetition and containing the corresponding count.\n    If several\
    \ letters have the same occurrence, return all of them.\n    \n    Example:\n\
    \    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___",
  "{\n    \n    string [] tokens = std.tokenizer.tokenize(test);\n    long[string]\
    \ histogram = new long[tokens.length];\n    for (long i = 0; i < histogram.length;\
    \ ++i)\n        histogram[i] = 0;\n    \n    for (string i : tokens)\n       \
    \ histogram[i]+=1;\n    \n    int[] counts = new int[tokens.length];\n    for\
    \ (long i : histogram)\n        counts[i]+=1;\n    \n    foreach (i: int[] e in\
    \ counts) {\n        string t = std.typecons.string(char[i], counts[i]);\n   \
    \     histogram[t]=e;\n    }\n    \n    long[] a = new long[tokens.length];\n\
    \    foreach(i : int[] e in histogram) {\n        a[std.math.max(0,std.math.min(e.length-1,a.length-1))]\
    \ = e;\n    }\n    return a;\n}\n/*\nGiven a string representing a space separated\
    \ lowercase letters, return an associative array\n    of the letter with the most\
    \ repetition and containing the corresponding count.\n    If several letters have\
    \ the same occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"\
    a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n    >>> histogram(\"\
    a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"a b c a b\"\
    )\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"b b b b a\")\n   \
    \ [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___\n    \n \
    \   \n*/\nNullable!(long[string]) histogram(string test, bool lower) \n{\n   \
    \ string [] tokens = std.tokenizer.tokenize(test);\n    long[string] histogram\
    \ = new long[tokens.length];\n    for (long i = 0; i < histogram.length; ++i)\n\
    \        histogram[i] = 0;\n    \n    for (string i : tokens)\n        histogram[i]+=1;\n\
    \    \n    int[] counts = new int[tokens.length];\n    for (long i : histogram)\n\
    \        counts[i]+=1;\n    \n    foreach (i: int[] e in counts) {\n        string\
    \ t = lower ? std.typecons.string(char[i], counts[i]) : std.typecons.string(char[i],\
    \ std.math.min(e.length-1,a.length-1));\n        histogram[t]=e;\n    }\n    \n\
    \    long[] a = new long[tokens.length];\n    foreach(i : int[] e in histogram)\
    \ {\n        a[std.math.max(0,std.math.min(e.length-1,a.length-1))] = e;\n   \
    \ }\n    return a;\n", "{\n    let\n        // Split all the letters by the whitespaces\
    \ and count the letters\n        histogram: long[char] = map!(test) indexedBy(x\
    \ => x).count(),\n        // For each letter, select the letter with most repetition\
    \ and return this letter and the count of it\n        lettersWithMostRep: long[char]\
    \ = histogram\n                .map(x => x.key).maxBy(y => y.value)\n        \
    \        .map(x => (x.value, x.key));", "{\n    Nullable!(long[string]) result;\n\
    \    \n    foreach(char c, test) {\n        Nullable!(long) count = result[string]!c[string]!;\n\
    \        if(count == 0L) count = 0;\n        result[string]!c[string] = count+1;\n\
    \    }\n    \n    return result;\n}\n/*\nGiven a string representing a space separated\
    \ lowercase letters, return a string with the first\n    letter of the most repeated\
    \ letter. If several letters have the same occurrence, return all\n    of them.\n\
    \    \n    Example:\n    >>> first(\"a b c\")\n    \"a\"\n    >>> first(\"a b\
    \ b a\")\n    \"a\"\n    >>> first(\"a b c a b\")\n    \"a\"\n    >>> first(\"\
    b b b b a\")\n    \"b\"\n    >>> first(\"\")\n    \"\"", '    :: __mod_0!__mod_1!__mod_2!__mod_3!__mod_4!__mod_5!__mod_6!__mod_7!__mod_8!__mod_9!__mod_10!__mod_11!__mod_12!__mod_13!__mod_14!__mod_15!__mod_16!__mod_17!__mod_18!__mod_19!__mod_20!__mod_21!__mod_22!__mod_23!__mod_24!__mod_25!__mod_26!__mod_27!__mod_28!__mod_29!__mod_30!__mod_31!__mod_32!__mod_33!__mod_34!__mod_35!__mod_36!__mod_37!__mod_38!__mod_39!__mod_40!__mod_41!__mod_42!__mod_43!__mod_44!__mod_45!__mod_46!__mod_47!__mod_48!__mod_49!__mod_50!__mod_51!__mod_52!__mod_53!__mod_54!__mod_55!__mod_56!__mod_57!__mod_58!__mod_59!__mod_60!__mod_61!__mod_62!__mod_63!__mod_64!__mod_65!__mod_66!__mod_67!__mod_68!__mod_69!__mod_70!__mod_71!__mod_72!__mod_73!__mod_74!__mod_75!__mod_76!__mod_77!__mod_78!__mod_79!__mod_80!__mod_81!__mod_82!__mod_83!__mod_84!__mod_85!__mod_86!__mod_87!__mod_88!__mod_89!__mod_90!__mod_91!__mod_92!__mod_93!__mod_94!__mod_95!__mod_96!__mod_97!__mod_98!__mod_99!__mod_100!__mod_101!__mod_102!__mod_103!__mod_104!__mod_105!__mod_106!__mod_107!__mod_108!__mod_109!__mod_110!__mod_111!__mod_112!__mod_113!__mod_114!__mod_115!__mod_116!__mod_117!__mod_118!__mod_119!__mod_120!__mod_121!__mod_122!__mod_123!__mod_124!__mod_125!__mod_126',
  "{\n    \n    Nullable! dict[string, long] result;\n    \n    foreach(let c of test)\n\
    \    {\n       \n        if(!dict.__contains__(c.asString()))\n            dict[c.asString()]\
    \ =long.None;\n        dict[c.asString()]++;\n        \n        if(dict[c.asString()]\
    \ > result!.value)\n        {\n            result = dict[c.asString()];\n    \
    \    }\n    }\n    return result;\n}\n/*\nGiven a string representing a space\
    \ separated lowercase letters, return an associative array\n    of the letter\
    \ with the most repetition and containing the corresponding count.\n    If several\
    \ letters have the same occurrence, return all of them.\n    \n    Example:\n\
    \    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___",
  "{\n   var result = {} as Nullable!(long[string]);\n   test.split(\" \").foreach((char){\n\
    \       if (!result.containsKey(char)) result[(char)] = 1;\n       else result[(char)]\
    \ += 1;\n   });\n   return result.asInstanceOf[Nullable!(long[string])] as Nullable!(long[string]);\n\
    }", "{\n\tNullable!(long[string]) result = null;\n\tif (test[0]==\" \")\n\t{\n\
    \t\ttest=test.substring(1);\n\t}\n\tfor (int i=0;i<test.length;i++) {\n\t\tNullable!(long)\
    \ counter = 0;\n\t\tfor (int j=0;j<test.length;j++) {\n\t\t\tif (test[i]==test[j])\n\
    \t\t\t{\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\tif (counter>0) {\n\t\t\tif (result\
    \ == null) {\n\t\t\t\tresult = make[string]((long) counter);\n\t\t\t} else {\n\
    \t\t\t\tresult = result.assoc(test[i], (counter));\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ result;\n}", "    where {\n    map: map!(char->long) histogram(char.asLower())\
    \ test.asLower();\n    map: map!(char->long) map.getOrDefault(char.asLower(),\
    \ 0L);\n    return map;\n}", "{\n    Nullable!(long[string]) histogram;\n    \n\
    \    histogram = map!((t) => (t: t, __size: 0L), test);\n    \n    for (i = 0;\
    \ i < test.Length; ++i)\n        ++histogram[test[i]];\n    \n    for (t = 0;\
    \ t < 256; ++t)\n        histogram[t] = histogram[t] ?? 0L;\n    \n    return\
    \ histogram;\n}", "{\n    var result = dict();\n    for (const letter of test.split(\"\
    \ \"))\n    {\n        result[letter] = result[letter] ?? 0L;\n        result[letter]\
    \ += 1;\n    }\n    return Nullable(result);\n}", "    : Dictionary {\n    int\
    \ maxCount = 1;\n    \n    foreach (char c, test) {\n        int count = test.count(c);\n\
    \        if (count > maxCount) {\n            maxCount = count;\n        }\n \
    \   }\n    \n    Dictionary[string, int] result = new Dictionary[string, int];\n\
    \    int maxCountCount = 0;\n    foreach (char c, test) {\n        count := test.count(c);\n\
    \        if (count > maxCount) {\n            maxCount = count;\n        }\n \
    \       dict[c] := count;\n    }\n    \n    foreach (key, value) {\n        if\
    \ (dict[value] > maxCount) {\n            maxCountCount := dict[value];\n    \
    \    }\n    }\n    \n    foreach (key, value) {\n        if (dict[value] == maxCount)\
    \ {\n            result[key] = dict[value];\n        }\n    }\n    \n    return\
    \ Dictionary[string, int] { result };\n}\n\"\"\"\n    },\n    \n    \"std-function\"\
    \ : \"\"\"\nimport std.typecons;\nimport std.math;\n/*\nGiven a string representing\
    \ an arithmetic expression, return the result of the evaluation.\n    If the expression\
    \ contains more than one valid result, throw an exception.\n    \n    Example:\n\
    \    >>> evaluate(\"2+3\")\n    3\n    >>> evaluate(\"2--3\")\n    -1\n    >>>\
    \ evaluate(\"a * b * c\")\n    Traceback (most recent call last):\n    OperatorException:\
    \ Expression contains more than one valid result\n    \n    \n*/\nNullable!(double)\
    \ evaluate(string test) \n    : Function {\n    Nullable!(double) result = null;\n\
    \    \n    // Parse the expression string and build an abstract syntax tree \n\
    \    Lexer lexer(test);\n    Parser parser;\n    \n    \n    parser.parseExpression();\n\
    \    if (parser.hasErrors()) {\n        throw new OperatorException(\"Expression\
    \ contains more than one valid result\");\n    }\n    \n    double value;\n  \
    \  \n    while (!parser.isError()) {\n        // Parse an operator\n        \n\
    \        string op;\n        parser.parseOperator();\n        if (parser.hasErrors())\
    \ {\n            throw new OperatorException(\"Expression contains more than one\
    \ valid result\");\n        }\n        op = parser.operation();\n        \n  \
    \      // Parse operands\n        parser.parseExpression();\n        if (parser.hasErrors())\
    \ {\n            throw new OperatorException(\"Expression contains more than one\
    \ valid result\");\n        }\n        \n        switch(op) {\n            case\
    \ \"+\": result = add(value); break;\n            case \"-\": result = subtract(value);\
    \ break;\n            case \"*\": result = multiply(value); break;\n         \
    \   case \"/\": result = divide(value); break;\n        }\n        \n        //\
    \ Next operator\n        parser.parseOperator();\n        if (parser.hasErrors())\
    \ {\n            throw new OperatorException(\"Expression contains ", "{\n   \
    \ \n    int count;\n    \n    Nullable<long[string]> result = null;\n    foreach(char\
    \ in test.toCharArray())\n    {\n       if(dict.containsKey(char))\n       {\n\
    \           count = dict[char];\n           dict[char] += 1;\n           if(result\
    \ == null) \n           {\n               result = Nullable<long[]>[char: count];\n\
    \           }\n           else\n           {\n               result = [char: count];\
    \ \n           }\n       }\n    }\n    return result ;\n}", "{\n    Nullable!(long[string])\
    \ h;\n    if (test[0] == \"__\") {\n        h[\"__\"] = 1L;\n    } else {\n  \
    \      var __result = __histogram(test);\n        if (__result != null) {\n  \
    \          h = __result;\n        }\n    }\n    return h;\n}", "    where test.isNotEmpty\
    \ = {\n        let\n            val array = test.split(\" \").toList\n       \
    \     val dict: Option[long[string]] = Option(long[string]())\n            \n\
    \            for (letter <- array) {\n                val c = dict.map(_.contains(letter)).getOrElse(0L)\n\
    \                dict <- Some((dict.getOrElse(letter, 0L) + 1))\n            }\n\
    \            \n            dict <- (dict map {case (k, v) => (k, v.toLong)})\n\
    \        \n        dict map {case (k, v) => k + \": \" + v}\n    }\n    \n   \
    \ /*\n    Similar to the above, but for non-alphabetic characters,\n    i.e. for\
    \ characters not in the \"A..Z\" and \"a..z\" ranges.\n    \n    Example:\n  \
    \  >>> histogram(\"a b c d e f a g h a g h i k g h a\")\n    [\"a\": 2L, \"b\"\
    : 2L, \"c\": 1L, \"d\": 1, \"e\": 1, \"f\": 1, \"g\": 4, \"h\": 4].nullable\n\
    \    \n    */\nNullable!(long[string]) histogram(string test) \n    where test.isNotEmpty\
    \ = {\n        let\n            val array = test.split(\" \").toList\n       \
    \     val dict: Option[long[string]] = Option(long[string]())\n            \n\
    \            for (letter <- array) {\n                val c = dict.map(_.contains(letter)).getOrElse(0L)\n\
    \                dict <- Some((dict.getOrElse(letter, 0L) + 1))\n            }\n\
    \            \n            dict <- (dict map {case (k, v) => (k, v.toLong)})\n\
    \        \n        dict map {case (k, v) => k + \": \" + v}\n    }\n    \n   \
    \ /*\n    Similar to the above, but for non-alphabetic characters,\n    i.e. for\
    \ characters not in the \"A..Z\" and \"a..z\" ranges.\n    \n    Example:\n  \
    \  >>> histogram(\"a b c d e f a g h a g h i k g h a\")\n    [\"a\": 2L, \"b\"\
    : 2L, \"c\": 1L, \"d\": 1, \"e\": 1, \"f\": 1, \"g\": 4, \"h\": 4].nullable\n\
    \    \n    */\nNullable!(long[string]) histogram(string test) \n    where test.isNotEmpty\
    \ = {\n        let\n            val array = test.split(\" \").toList\n       \
    \     val dict: Option[long[string]] = Option(long[string]())\n            \n\
    \            for (letter <- array) {\n                val c = dict.map(_.contains(letter)).getOrElse(0L)\n",
  "{\n  \n  \n    Nullable ret = null;\n    \n    var freq : long[string] = null;\n\
    \    \n    var _map = null; // this will be the return type once filled\n    \n\
    \    \n    for (char in test) {\n        if (freq == null) {\n            freq\
    \ = new long[char];\n        }\n        \n        if (freq[char] != null) {\n\
    \            freq[char]++;\n        }\n        else {\n            freq[char]\
    \ = 1;\n        }\n    }\n    \n    for (char in freq) {\n        if (freq[char]\
    \ == null){\n            freq[char] = 0;\n        }\n    }\n    \n    for (key\
    \ in freq) {\n        \n        var _count : long = freq[key];\n        \n   \
    \     if (_count == 0){\n            \n            _map[key] = null; // this will\
    \ be the return type once filled\n            \n        }\n        else {\n  \
    \          \n            var _key : char[] = new char[_key.length + 1];\n    \
    \        \n            for (idx = 0; idx < _key.length; idx++) {\n           \
    \     _key[idx] = key[idx];\n            }\n            \n            _map[key]\
    \ = _count;\n            \n        }\n        \n    }\n    \n    return ret;\n\
    \    \n}", "{\n\t\n\tNullable hashMap[string]!;\n\t\n\tlet tempArray = test.split(\"\
    \ \");\n\t\n\tfor (i : int in 0 .. tempArray.size - 1)\n\t{\n\t\tlet currentLetter\
    \ = tempArray[i];\n\t\tlet currentCount = hashMap[currentLetter]!;\n\t\thashMap[currentLetter]\
    \ = currentCount + 1;\n\t}\n\treturn hashMap;\n}", "{\n    Nullable!(long[string])\
    \ histogram = Nullable!(long[string]) null;\n    \n    test\n        .split(\"\
    \ \")\n        .map(|item| {\n            histogram[item] = histogram[item] ??\
    \ 0;\n            histogram[item] += 1;\n            histogram\n        })\n \
    \       .filter(|(_, value)| *value > 0)\n        .collect()\n}", "{\n    long\
    \ counts[string] = null;\n    foreach(char c in test.chars) {\n        if(counts[c]\
    \ == null) counts[c] = 0;\n        counts[c] = counts[c] + 1L;\n    }\n    return\
    \ counts;\n}", "{\n    \n    Nullable histogram[string] = Nullable();\n    \n\
    \    var arr = test.toCharArray();\n    for(var i = 0; i < arr.length; ++i) {\n\
    \        histogram[arr[i]] = (histogram[arr[i]] ?? 0L) + 1L;\n    }\n    \n  \
    \  return histogram;\n}", "{\n    Nullable!(long[string]) result = {};\n    string\
    \ letters = trim(test);\n    for(char letter : letters) \n    { \n        long[string]\
    \ letterCounts = result[letter]; \n        if(!letterCounts) \n        { \n  \
    \          letterCounts = { letter: 1L};\n            result[letter] = letterCounts;\n\
    \        } \n        else \n        { \n            letterCounts[letter] = letterCounts[letter]+\
    \ 1L;\n        } \n    }\n    return result;\n}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the least repetition and containing the corresponding count.\n \
    \   If several letters have the same occurrence, return all of them.\n    \n \
    \   Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\":\
    \ 1L].nullable\n    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n\
    \    >>> histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n\
    \    ___null_dict___", "{\n  var dict: Nullable<long> = ___nulldict____;\n  for\
    \ each (ch in test)\n  {\n    if (dict.values[ch] == null)\n    {\n      dict[ch]\
    \ = 1;\n    }\n    else\n    {\n      dict[ch] += 1;\n    }\n  }\n  return dict;\n\
    }\n//\n</code>\n<|/ a dscore=3 |>\n<| a |>\nSince you said you do not mind using\
    \ an external library, I would use the Maps library:\n<code>\nimport Maps\nimport\
    \ java.util.Arrays", "{\n    var dic:Option[long[string]] = None;\n    var letters:Option[long[string]]\
    \ = None;\n    var max:Option[long[string]] = None;\n    for(letter <- test.split(\"\
    \ \")) {\n        if(!dic.contains(letter)) {\n            dic = dic.getOrElse(Option(long[string]()));\n\
    \            letters = letters.getOrElse(Option(long[string]()));\n          \
    \  dic = dic.put(letter, dic.getOrElse(Option(long[string]())) + long(1));\n \
    \           letters = letters.getOrElse(Option(long[string]()));\n        } else\
    \ {\n            letters = letters.getOrElse(Option(long[string]()));\n      \
    \      letters = letters.put(letter, letters.getOrElse(Option(long[string]()))\
    \ + long(1));\n        }\n        if(!max.contains(letter)) {\n            max\
    \ = max.getOrElse(Option(long[string]()));\n            max = max.put(letter,\
    \ max.getOrElse(Option(long[string]())) + long(1));\n        } else {\n      \
    \      max = max.getOrElse(Option(long[string]()));\n            max = max.put(letter,\
    \ max.getOrElse(Option(long[string]())) + long(1));\n        }\n    }\n    var\
    \ results:Option[long[string]] = None;\n    for(letter <- dic.keys) {\n      \
    \  if(max.getOrElse(Option(long[string]())) == dic.getOrElse(Option(long[string]()))\
    \ && dic.getOrElse(Option(long[string]())) == letters.getOrElse(Option(long[string]())))\
    \ {\n            results = results.getOrElse(Option(long[string]()));\n      \
    \      results = results.put(letter, results.getOrElse(Option(long[string]()))\
    \ + long(1));\n        }\n    }\n    return results;\n}", "{\n    Nullable!(long[string])\
    \ dict = Nullable!(long[string])();\n    for (string letter : test.split(\" \"\
    ))\n        if !dict.has(letter)\n            dict[letter] = 1;\n        else\n\
    \            dict[letter] += 1;\n    return dict;\n}", "{\n    \n    std.assert(test.length()\
    \ == 1, 'histogram called with invalid length ');\n    \n    string s = test.toLower();\n\
    \    int len = s.length;\n    \n    std.assert(len > 0, 'histogram called with\
    \ empty string');\n    std.assert(len < 256, 'histogram called with string length\
    \ greater than 256');\n    \n    long count = 1;\n    \n    int[] hist = new int[len];\n\
    \    \n    for(int i = 0; i < len; ++i)\n    {\n        char ch = s[i];\n    \
    \    if(!std.typecons.isChar(ch))\n        {\n            std.assert(false, 'histogram\
    \ called with non-char string ');\n        }\n        \n        int index = std.typecons.toEnum(ch);\n\
    \        if(hist[index] == 0)\n        {\n            count = 1;\n           \
    \ hist[index] = count;\n        }\n        else\n        {\n            count\
    \ = count + 1;\n            hist[index] = count;\n        }\n    }\n    \n   \
    \ Nullable out = null;\n    if(hist.Length > 0)\n    {\n        int maxIndex =\
    \ 0;\n        int maxValue = 0;\n        int maxCount = 0;\n        for(int i\
    \ = 0; i < len; ++i)\n        {\n            if(hist[i] > maxCount)\n        \
    \    {\n                maxCount = hist[i];\n                maxIndex = i;\n \
    \               maxValue = hist[i];\n            }\n        }\n        out = new\
    \ Long(maxIndex, maxValue);\n    }\n    \n    return out;\n}", "{\n\tNullable!(long[string])\
    \ histogram = Nullable!(long[string])();\n\tstring [] words = test.split(\" \"\
    );\n    foreach (word in words) {\n        histogram[word] ? histogram[word] +=\
    \ 1 : histogram[word] = 1;\n    }\n    return histogram;\n}", "    where {\n \
    \   char[] array = test.toCharArray();\n    \n    long[char] histogram = Nullable!(long[char]){};\n\
    \    \n    for(var i = 0;i<array.length;i++) {\n        var char = array[i];\n\
    \        var occurrences = histogram[char];\n        \n        if(occurrences==null)\
    \ {\n            histogram[char] = occurrences = 1;\n        } else {\n      \
    \      occurrences += 1;\n        }\n    }\n    \n    return histogram;\n}", " \
    \   requires test.nonEmptyString();\n    \n{\n    long count = 0;\n    map!( string\
    \ -> ( string, count++ ) );\n    \n    foreach ( string -> test, repeat ) {\n\
    \        if ( count > 1L )\n            map!( string -> string, 1 );\n       \
    \     \n        else\n            map!( string -> string, count );\n    }\n  \
    \  \n}", "{\n    \n    var dic:long[char] = [];\n    for (string word in split(test))\n\
    \    {\n        for (string letter in word)\n        {\n            dic[letter]\
    \ <- dic[letter] + 1;\n        }\n    }\n    \n    if (dic.isEmpty || dic.size\
    \ == 0)\n    {\n        return Null(null);\n    }\n    \n    var maxCount = dic.max;\n\
    \    \n    // The tuple is \"(string, occurrence)\" so just iterate it and keep\
    \ the max occurrence\n    foreach(i <- 0 to dic.size-1)\n    {\n        if (maxCount\
    \ < dic[i])\n        {\n            var maxOccurrence = dic[i];\n            var\
    \ maxLetter = dic.keyAt(i);\n        }\n    }\n    \n    return Tuple(maxLetter,\
    \ maxOccurrence);\n    \n}", "{\n    // TODO: Optimize with memoization \n   \
    \ var result = new Nullable<long>(); // Initialize to null \n    \n    for (auto\
    \ c: test)\n        try { // Ignore errors\n            int count = getValue(c,\
    \ result); // Use try/catch so we can return null \n            if (count == 0)\
    \ // If no occurrences, just add to dictionary \n                putValue(c, result);\
    \ \n            else\n                putValue(c, result, count); // otherwise\
    \ add to dictionary \n        } \n        catch { }\n    return result.nullable;\n\
    }\n/*\nGiven a string, return its length including leading spaces.\n    \n   \
    \ example:\n    >>> len(\"a   b\") // 2\n    int\n*/", "{\n    // Write your code\
    \ here.\n    return Nullable!(long[string])(test.split(\" \").map((x, i) => (x,\
    \ test.split(\" \").count(x))));\n}\n</cell>\n<text>\nstd.typecons.Pair\nNone ",
  "{\n\tvar d = new Nullable<long[string]>();\n\tfor each (String s in test.splitByWholeSpaces())\
    \ {\n\t\td[s.asCString()] = 1;\n\t}\n\treturn d;\n}", "{\n    Nullable!(dict[string]\
    \ test);\n    \n    // parse test into array of characters\n    Nullable!(array[char]\
    \ testchars);\n    \n    if (test) {\n        testchars = toCharArray(test);\n\
    \    }\n    \n    Nullable!(array[char] histograms);\n    \n    if (testchars)\
    \ {\n        histograms = new Array(testchars.length);\n        \n        var\
    \ _hist = histogram; // local copy of histogram\n        \n        for (var i\
    \ = 0; i < testchars.length; i++) {\n            _hist = histogram(_hist, testchars[i]);\n\
    \            \n            if (histograms[i] == null) {\n                histograms[i]\
    \ = _hist;\n            } else {\n                histograms[i] += _hist;\n  \
    \          }\n        }\n    }\n    \n    return histograms;\n}\n/* \nGiven a\
    \ string representing a space separated lowercase letters, return a list of\n\
    \    all words in the string whose letter appears most\n    \n    Example:\n \
    \   >>> histogram(\"a b c\")\n    [\"a\", \"b\", \"c\"]\n    >>> histogram(\"\
    a b b a\")\n    [\"b\", \"a\"]\n    >>> histogram(\"a b c a b\")\n    [\"a\",\
    \ \"b\"]\n    >>> histogram(\"b b b b a\")\n    [\"b\", \"a\"]\n    >>> histogram(\"\
    \")\n    ___null_list___", "{\n\tvar chars = new Nullable!long[string];\n\t\n\t\
    for(var i in test)\n\t{\n\t\tvar char = test[i];\n\t\tif(chars.has(char))\n\t\t\
    {\n\t\t\tchars[char] += 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchars[char] = 1;\n\t\
    \t}\n\t}\n\treturn chars;\n}", "{\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "{\n    var counter: long = long(0);\n    var letters: long = long(test);\n\
    \    for (var i = 0; i< letters; ++i)\n    {\n        var letter: string = test[i];\n\
    \        var count: long = long(counter.count(letter));\n        if (count ==\
    \ 0)\n        {\n            counter[letter] = 1;\n        }\n        else if\
    \ (count > counter[letter])\n        {\n            counter[letter] = count;\n\
    \        }\n    }\n    return counter;\n}", "{\n    map = HashMap<long,int>();\n\
    \    for (word <- test.split(\" \")){\n        map[word] = map[word] ?? 1L;\n\
    \        map[word] = map[word] +1;\n    }\n    \n    return map;\n}\n</cell>\n\
    <cell>\nhistogram(\"a b c a b\");\n</cell>\n<text>\nThe code above shows how you\
    \ might implement the histogram function. You will see that we can use nullable\
    \ types. We are using the ? operator, which has the advantage of making code more\
    \ succinct and readable than an if statement or a loop. It also works with non-nullable\
    \ types (like int).", "    where test ~> space;\n    \n\"\"\"\nhistogram : String\
    \ -> Nullable!(string[string]) \n    where string ~> char;\n    \n/* \nGiven a\
    \ string, convert it to lowercase letters and return it.\n    \nExample: \n  \
    \  >>> lowercase(\"hello world\")\n    \"hello world\".nullable\n*/\nNullable!(string\
    \ lowercase(string input)) \n    where input ~> string;\n    \n/* \nGiven a string\
    \ of lowercase letters, return an associative array\n    with the letter with\
    \ the most repetition and containing the corresponding count.\n    If several\
    \ letters have the same occurrence, return all of them.\n    \nExample: \n   \
    \ >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n*/\n\
    Nullable!(string[string]) histogram(string test) \n    where test ~> lowercase;\n\
    \    \n/* \nGiven a string of lowercase letters, return an associative array\n\
    \    with the letter with the most repetition and containing the corresponding\
    \ count.\n    If several letters have the same occurrence, return all of them.\n\
    \    \n    Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L,\
    \ \"c\": 1L].nullable\n*/\nNullable!(string[string]) histogram(string test) \n\
    \    where test ~> lowercase;\n    \n/*\nGiven a string representing a space separated\
    \ lowercase letters, return an associative array\n    of the letter with the most\
    \ repetition and containing the corresponding count.\n    If several letters have\
    \ the same occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"\
    a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n*/\nNullable!(string[string])\
    \ histogram(string test) \n    where test ~> lowercase;\n    \n/*\nGiven a string\
    \ representing a space separated lowercase letters, return an associative array\n\
    \    of the letter with the most repetition and containing the corresponding count.\n\
    \    If several letters have the same occurrence, return all of them.\n    \n\
    \    Example:\n    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\"\
    : 1L].nullable\n*/\nNullable!(string[string]) histogram(string test) \n    where\
    \ test ~> lowercase;\n    \n/* \nGiven a string representing a space separated\
    \ lowercase letters, return an associative array\n    of the letter with the most\
    \ repetition and containing the corresponding count.\n    If several letters have\
    \ the same occurrence, return all of them.\n    \n    Example:\n    >>> histogram(\"",
  "{\n    var histogram = \n    test.split(\" \").filter(|e| e.length > 0).map(|e|\
    \ {\n        let count = test.split(\" \").filter(|e| e.contains(e)).count();\n\
    \        (e, count)\n    }).group_by(|e| e.0).map(|k| (k.0, k.1.count().unwrap_or(0L)))\n\
    \    .asValue().asUnsafeValue();\n    return histogram;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nThis was very helpful and I appreciate you posting this. It took\
    \ me a while to understand that \"null\" means \"No value.\" This was really helpful,\
    \ thank you!\n<|/ c |>\n<| a dscore=2 |>\n<code>\n// import std.typecons;\nimport\
    \ std.math;\n//import std.array;\n//import std.range;\n//import std.stdio;\n//\
    \ import std.string;", "{\n\tvar d = Null!(long[string]);\n\tvar a = test.split(\"\
    \ \");\n\t\n\tforeach(a, function(a) {\n\t\td(a) = d(a).or_else(0.0L);\n\t\td(a)\
    \ = d(a).add_(1.0L);\n\t});\n\t\n\treturn d;\n}", "{\n\tint[char] counts = dict([(char,\
    \ 0)]);\n\tfor (int i = 0; i < test.length; ++i){\n\t\tchar c = test.charAt(i);\n\
    \t\tcounts[c] += 1;\n\t\tif (counts[c] > 1)\n\t\t\tcounts[c] = 0;\n\t}\n\t\n\t\
    Nullable!(long) result;\n\tint maxCount = 0, bestChar, bestCount = 1;\n\tfor (auto\
    \ iter = counts.begin(); iter != counts.end(); ++iter){\n\t\tif (maxCount < (*iter))\n\
    \t\t\tmaxCount = (*iter);\n\t\tchar c = iter.key();\n\t\tif (counts[c] > bestCount)\n\
    \t\t\tbestCount = counts[c];\n\t\t\t\n\t}\n\t\n\tresult = Nullable!(long)();\n\
    \tfor (auto iter = counts.begin(); iter != counts.end(); ++iter){\n\t\tif (maxCount\
    \ < (*iter))\n\t\t\tmaxCount = (*iter);\n\t\tchar c = iter.key();\n\t\tif (counts[c]\
    \ == bestCount)\n\t\t\tresult = result + c.__int__;\n\t\t\t\n\t}\n\t\n\tresult\
    \ += (long)maxCount;\n\t\n\t\n\tassert ((result == Nullable!(int))(maxCount));\n\
    \treturn result;\n}", "{\n    var res = Nullable!{ };\n    var count = 0;\n  \
    \  foreach(char c in test)\n    {\n        Nullable!(long) a = res[c];\n     \
    \   if(a==null)\n        {\n            res[c] = count++;\n        }\n       \
    \ else\n        {\n            res[c] = (a>count)?a:count;\n        }\n    }\n\
    \    return res;\n}", "{\n    Nullable!({ __key__:string; __val__:long }) testList\
    \ = test.split(\" \");\n    Map!(string, long) histogram;\n    foreach(testList,\
    \ item -> histogram[item] = histogram[item] + 1L);\n    foreach(histogram, item\
    \ -> histogram[item.key] = histogram[item.key]); \n    return histogram;\n}",
  "    where {\n    int count = 0;\n    \n    foreach ( char c in test ) {\n     \
    \   if ( histogram(test) !/= Null ) {\n            foreach ( string s in histogram(test)\
    \ ) {\n                if ( s.Contains(c) ) count++;\n            }\n        }\n\
    \    }\n    \n    if ( histogram(test) != Null ) {\n        foreach ( string s\
    \ in histogram(test) ) {\n            if ( s.Contains(c) ) count++;\n        }\n\
    \    }\n    \n    if ( histogram(test) != Null ) {\n        foreach ( string s\
    \ in histogram(test) ) {\n            if ( s.Contains(c) ) count++;\n        }\n\
    \    }\n    \n    return Nullable(count);\n}\n/*\n    \nGiven a string representing\
    \ a space separated lowercase letters, return an array\n    of the letter with\
    \ the most repetition and containing the corresponding count.\n    If several\
    \ letters have the same occurrence, return all of them.\n    \n    Example:\n\
    \    >>> histogram(\"a b c\")\n    [\"a\": 1L, \"b\": 1L, \"c\": 1L].nullable\n\
    \    >>> histogram(\"a b b a\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    [\"a\": 2L, \"b\": 2L].nullable\n    >>> histogram(\"\
    b b b b a\")\n    [\"b\": 4L].nullable\n    >>> histogram(\"\")\n    ___null_dict___",
  "{\n\tNullable!(dict[string,long]) temp:null = dict[test,null];\n\t\n\tif (temp==null){\n\
    \t\tdict[test,null] = dict[test,0];\n\t\treturn null!;\n\t}\n\t\t\n\tNullable!(dict[string,long])\
    \ result:null = null;\n\tint max:long = 0;\n\t\n\tfor (string s in test){\n\t\t\
    Nullable!(dict[string,long]) thisMax:null = dict[s,null];\n\t\tNullable!(dict[string,long])\
    \ thatMax:null = dict[test,null];\n\t\tif (thisMax!=null && thatMax==null){\n\t\
    \t\tdict[s,max+1] = dict[s,max+1] + 1;\n\t\t} else if (thisMax==null && thatMax!=null){\n\
    \t\t\tdict[s,max+1] = dict[s,max+1] + 1;\n\t\t} else if (thisMax!=null && thatMax!=null){\n\
    \t\t\tdict[s,thisMax] = dict[s,thisMax] + 1;\n\t\t\tdict[s,thatMax] = dict[s,thatMax]\
    \ + 1;\n\t\t\tif (thisMax>max){\n\t\t\t\tmax=thisMax;\n\t\t\t\tresult = dict[s,thisMax];\n\
    \t\t\t} else if (thatMax>max){\n\t\t\t\tmax=thatMax;\n\t\t\t\tresult = dict[s,thatMax];\n\
    \t\t\t}\n\t\t}\n\t}\n\tdict[test,max] = dict[test,max] + 1;\n\treturn result;\n\
    }", "    where test=trim\n    =>\n    let map = new _Dictionary()\n    for c in\
    \ test do\n        let count = _Dictionary.get(map, c)\n        map[c] = count\
    \ + 1\n    \n    let result = _Dictionary[]\n    for key in map do\n        push!(\
    \ result, key, map[key] )\n    \n    \n    Nullable(result)", "  : \"string\"\
    \ as \"long -> nullable long\" \n{\n    var __counter__ : long = 0;\n    var __result__\
    \ : Nullable!(long[string]) =\n      Nullable!({__counter__:0,\n             \
    \   __letters__:{__key__:0,\n                            __value__:\"\"}});\n\
    \    var __tmp__ : string;\n    \n    for (__tmp__ in test) {\n        __result__[__tmp__]\
    \ = __counter__;\n        __counter__ += 1;\n    }\n    \n    for (__tmp__ in\
    \ __result__) {\n        if (__result__[__tmp__] > __counter__) {\n          \
    \  __counter__ = __result__[__tmp__];\n            __result__.value = __tmp__;\n\
    \            __result__.count = __result__[__tmp__];\n        }\n    }\n    \n\
    \    if (__counter__ > 1) {\n        for (__tmp__ in __result__.value) {\n   \
    \         var __tmp__ : string;\n            \n            for (__tmp__ in __result__.value)\
    \ {\n                if (__result__.value.__key__ == __tmp__) {\n            \
    \        var __tmp__ : string;\n                    \n                    __result__.value\
    \ = __tmp__;\n                    __result__.count = __result__.value;\n     \
    \           }\n            }\n        }\n    }\n    \n    return __result__;\n\
    }\n</cell>\n<code language=dyalog-kernel>\nhistogram(\"a b b b a\")\n</cell>\n\
    <text>\nA bit of code golf\nTo convert this function in to Python code you only\
    \ need to replace __tmp__ with tmp and __counter__ with counter respectively.\
    \ And instead of var __counter__ : long = 0; replace it with simply counter =\
    \ 0.", "{\n    string split = test.split(\" \");\n    map!(char => int[char] with\
    \ int) histogram(split);\n}", "{\n    Nullable!(long[string]) dict = Nullable!(long[string])\
    \ null();\n    foreach (char c in test)\n    {\n      dict[c] = dict[c].__add__(1L).__max__();\n\
    \    }\n    return dict;\n}", "{\n\tNullable!(long[string]) _histogram;\n\t\n\t\
    if (test==\"\") return ___null_dict___;\n\t\n\tint i = 0;\n\tNullable!(long) _max\
    \ = -10000L;\n\t\n\tforeach(string s in split(test))\n\t{\n\t\tNullable!(long)\
    \ _count = std.dictionary.lookup(_histogram,s);\n\t\t\n\t\tif (_count < 0)\n\t\
    \t{\n\t\t\t_histogram[s] = -1L;\n\t\t\t_max = -10000L;\n\t\t}\n\t\telse if (_count\
    \ > _max)\n\t\t\t_max = _count;\n\t\telse\n\t\t\t_histogram[s]++;\n\t\t\n\t\t\
    i++;\n\t}\n\t\n\tforeach(var i in _histogram)\n\t{\n\t\tif (i.value.is_null())\n\
    \t\t{\n\t\t\t_histogram[i] = -1L;\n\t\t\t_max = -10000L;\n\t\t}\n\t\telse if (i.value\
    \ >= _max)\n\t\t\t_histogram[i] = i.value;\n\t\telse\n\t\t\t_histogram[i]++;\n\
    \t}\n\t\n\treturn _histogram;\n}", "{\n\t\n\tlet\n\tdict = dict();\n\t\n\tlet\
    \ \n\ti = 1;\n\t\n\twhile i <= test.length\n\t{\n\t\t\n\t\tlet \n\t\tchar = test.slice(i,\
    \ i+1);\n\t\t\n\t\tif !dict.containsKey(char)\n\t\t{\n\t\t\tdict[char] = 1;\n\t\
    \t}\n\t\telse\n\t\t{\n\t\t\tdict[char] += 1;\n\t\t}\n\t\ti += 1;\n\t}\n\treturn\
    \ Nullable!(dict[char]);\n}", '  :- histogram(test, "").', "    where {\n    \
    \    Nullable(dict[string]) = test;\n        string __dict_get__(dict[string]\
    \ dict, string key, long default = null);\n    }", "{\n    \n    var result =\
    \ new Nullable[string]();\n    var dict = Dictionary[string]([], (k, v) => {\n\
    \        if (result.contains(k)) {\n            result[k] = result[k] + (long(v));\n\
    \        }\n        else {\n            result[k] = long(v);\n        }\n    });\n\
    \    \n    foreach(test.split(), i => {\n        if (i != null) {\n          \
    \  dict.add(long(i), 1);\n        }\n    });\n    \n    foreach(result, kvp =>\
    \ {\n        if (kvp.value != null) {\n            kvp.value = kvp.value - (long)kvp.key;\n\
    \        }\n    });\n    \n    return result;\n}", "{\n    auto letters = test.split();\n\
    \    \n    if (letters.length == 0)\n        return Nullable!(long[string]) nulldict;\n\
    \        \n    auto letterdict = __int_dict[dict];\n    \n    auto lettercounts\
    \ = map!(__int_dict[dict[test]], (long i) -> long) |> map!((long i) -> long.zero)\
    \ |> map!(i -> i + 1);", "{\n    var counter: Nullable<long> = Nullable<long>(0);\n\
    \    var max: Nullable<long> = Nullable<long>(0);\n    var current: Nullable<string>\
    \ = Nullable<string>(\"\");\n    foreach(char c in test)\n    {\n        if(!c.isWhitespace())\n\
    \        {\n            current = current + c;\n            counter = counter\
    \ + charOccurrence(current);\n        }\n        else\n        {\n           \
    \ if(counter.nonnull() >= max.nonnull())\n            {\n                max =\
    \ counter;\n            }\n            counter = Nullable<long>(0);\n        \
    \    current = Nullable<string>(\"\\\"\");\n        }\n    }\n    if(counter.nonnull()\
    \ < max.nonnull())\n    {\n        max = counter;\n    }\n    return max.toValue()[\"\
    \".toValue()];\n}", "    where {\n    // convert test to lower case\n    var testLowerCase\
    \ = test.toLower();\n    \n    // map test to lowercase\n    var testLowerCaseDict\
    \ = test.map((string x)=>x.toLower()).map((string x)=>{\n        // initialize\
    \ counter\n        var counter = 1;\n        // initialize counter to 0\n    \
    \    var counterToZero = 0;\n        // iterate through the string\n        for(var\
    \ index = 0; index<test.length;index++){\n            // if current character\
    \ of test is the same as current letter\n            if(testLowerCase[index] ==\
    \ x){\n                // increment the counter\n                counter++;\n\
    \                // if counter is greater than the previous counter\n        \
    \        if(counter > counterToZero){\n                    // save previous counter\n\
    \                    counterToZero = counter;\n                }\n           \
    \ }\n        }\n        // return the letter and its count\n        return [x,\
    \ counterToZero];\n    }).toMap();\n    \n    // return the result\n    return\
    \ testLowerCaseDict;\n}", "\t\t: Nullable!(long[string])\n\t\twhere {\n\t\t  \
    \  long[string] counts;\n\t\t    \n\t\t    bool isCountNull = false;\n\t\t   \
    \ foreach (char c in test) {\n\t\t        if (!isCountNull) {\n\t\t          \
    \  isCountNull = counts[c] == 0;\n\t\t        }\n\t\t        if (counts[c] ==\
    \ 0) {\n\t\t            counts[c] = 1;\n\t\t        } else {\n\t\t           \
    \ counts[c]++;\n\t\t        }\n\t\t    }\n\t\t    \n\t\t    if (isCountNull) {\n\
    \t\t        return Nullable!(long[string]);\n\t\t    } else {\n\t\t        return\
    \ Nullable!(long[string]);\n\t\t    }\n\t\t}\n/*\nGiven a string representing\
    \ a space separated lowercase letters, return an associative array\n    of the\
    \ letter with the most repetition and containing the corresponding count.\n  \
    \  If several letters have the same occurrence, return all of them.\n    \n  \
    \  Example:\n    >>> histogram(\"a b c\")\n    {\"a\": 1L, \"b\": 1L, \"c\": 1L}.nullable\n\
    \    >>> histogram(\"a b b a\")\n    {\"a\": 2L, \"b\": 2L}.nullable\n    >>>\
    \ histogram(\"a b c a b\")\n    {\"a\": 2L, \"b\": 2L}.nullable\n    >>> histogram(\"\
    b b b b a\")\n    {\"b\": 4L}.nullable\n    >>> histogram(\"\")\n    ___null_dict___",
  "    where test ~ \"^[a-z ]*$\" \n    {\n        let rep = __std.dict.empty[string;\
    \ long];\n        let max = 0;\n        let res = Nullable!(long[string]);\n \
    \       for ch in test \n        { \n            let count = __std.dict.table[ch;\
    \ string; long](rep).get(ch);\n            \n            if (count.isSome)\n \
    \           {\n                if (count.value > max)\n                {\n   \
    \                 max = count.value;\n                }\n            }\n     \
    \       else\n            {\n                __std.dict.get(ch, rep, __std.dict.empty[string;\
    \ long]).value += 1;\n            }\n        }\n        \n        if (max > 0)\n\
    \        {\n            let rev_rep = __std.dict.empty[string; long];\n      \
    \      __std.dict.values(rep)\n            .filter(|(k, _)| k.value >= max)\n\
    \            .for_each(|(k, v) -> (k.value, v.value + 1))\n            .for_each(|(_,\
    \ v)| {\n                __std.dict.getall(k).for_each(|(k, _)| {\n          \
    \          if (v > 0)\n                    {\n                        __std.dict.get(k,\
    \ rev_rep, __std.dict.empty[string; long]).value += v;\n                    }\n\
    \                });\n            });\n            \n            res = rev_rep;\n\
    \        }\n        \n        res\n    }", "{\n  var h : map[char] long = map.new;\n\
    \  for(var i = 0; i < test.length; ++i)\n  {\n    var c = test.charAt(i);\n  \
    \  \n    if(h[c] == null)\n      h[c] = 1L;\n    else\n    {\n      h[c] += 1;\n\
    \      \n      if(h[c] > h[test.charAt(0)])\n      {\n        h[test.charAt(0)]\
    \ = h[c];\n      }\n    }\n  }\n  return Nullable(h);\n}\n/*\nThis function takes\
    \ a string representing a space-separated lowercase letters.\nIt returns a new\
    \ string where each letter is replaced with the number of occurrences\nof the\
    \ letter in the string.\n    \n    Example:\n    >>> count_letters(\"a b c\")\n\
    \    \"a_1_c_1\"\n    \n*/\nstring count_letters(string test) \n{\n  var result\
    \ : Array[string] = Array.new;\n  \n  for(var i = 0; i < test.length; ++i)\n \
    \ {\n    var c = test.charAt(i);\n    var index = test.indexOf(c);\n    \n   \
    \ if(index == -1)\n    {\n      result.push(test.charAt(i) + \"_1\");\n    }\n\
    \    else\n    {\n      result.push(test.charAt(i) + \"_\" + (index + 1));\n \
    \   }\n  }\n  return string.join(result, \"\");\n}\n/*\nGiven a string and a character,\
    \ returns the number of occurences of the character in the string.\nIf the character\
    \ is not found, returns null.\n    \n    Example:\n    >>> count_letter(\"a b\
    \ c\", \"a\")\n    1L\n    >>> count_letter(\"a b c d e\", \"z\")\n    ___null_\n\
    */\nNullable(long) count_letter(string test, char test1) \n{\n  var result = long.null;\n\
    \  \n  for(var i = 0; i < test.length; ++i)\n  {\n    var c = test.charAt(i);\n\
    \    \n    if(c != test1)\n    {\n      continue;\n    }\n    else\n    {\n  \
    \    result = test.charAt(i) + \"_\" + result;\n    }\n  }\n  \n  return result;\n\
    }\n/*\nGiven a string representing a space-separated lowercase letters, returns\
    \ an array of\nstrings containing the number of occurences of each letter in the\
    \ string.\n    \n    Example:\n    >>> count_letters(\"a b c\")\n    [\"a_1\"\
    , \"b_1\", \"c_1\"].nullable\n    \n*/\nNullable!(array[string]) count_letters(string\
    \ test) \n{\n  var result : Array[string] = Array.new;\n  \n  for(var i = 0; i\
    \ < test.length; ++i)\n  {\n    var c = test.charAt(i);\n    \n    if(result.contains(c))\n\
    \    {\n      continue;\n    }\n    else\n    {\n      result.push(c);\n    }\n\
    \  }\n", "{\n    \n    map!(string -> map!(char ->\n                    if(test[char].isSpace)\
    \ 0 else 1L) \n              test) \n        .unwrap();\n    \n    if(test.isSpace())\
    \ \n        return Nullable!(map!(char -> 0L) test);\n    \n    if(test.length()\
    \ == 0) \n        return Nullable!(map!(char -> 0L) test);", "{\n    Nullable!(dict{string,\
    \ long}) histogramDict;\n    \n    foreach (str key, str value) in test\n    {\n\
    \        histogramDict[key] = histogramDict[key] + 1L;\n    }", "\t-> Nullable!(long[string]):\
    \ \n\t\n\tresult = dict();\n\tfor word in test.split(\" \"):\n\t\tif (word in\
    \ result):\n\t\t\tresult[word] += 1;\n\t\telse:\n\t\t\tresult[word] = 1;\n\treturn\
    \ Nullable!(long[string](result));\n'''", "{\n\tNullable!(long[string]) result\
    \ = Dictionary<string, long>();\n\tforeach(word : test.split(\" \"))\n\t{\n\t\t\
    if(word.char.Length() > 0)\n\t\t{\n\t\t\tif(result[(word[0])] == null)\n\t\t\t\
    {\n\t\t\t\tresult[(word[0])] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult[(word[0])]++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "{\n\t\n\tNullable!(long[string]) res\
    \ = ___nulldict____;\n\t\n\tif(test.length == 0) {\n\t\treturn res;\n\t}", "{\n\
    \tvar counts: Nullable[long] = null;\n\tfor each (letter in test | string) \n\t\
    {\n\t\t/*\n\t\tif (counts == null || counts[letter] == null || (counts[letter]+1)\
    \ > counts[letter].asLong)\n\t\t\tcounts[letter] = 1;\n\t\telse\n\t\t\tcounts[letter]++;\n\
    \t\t*/\n\t\tif (counts.isNull) \n\t\t{\n\t\t\tcounts[letter] = 1;\n\t\t}\n\t\t\
    else\n\t\t{\n\t\t\tif (counts[letter] == null || (counts[letter]+1) > counts[letter].asLong)\
    \ \n\t\t\t{\n\t\t\t\tcounts[letter] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\
    \tcounts[letter]++;\n\t\t\t}\n\t\t}\n\t}\n\treturn counts;\n}", "{\n\tauto dict\
    \ = Dictionary::new();\n\tfor (int i = 0; i < test.size(); ++i) {\n\t\tif (!dict.get(test.substr(i,\
    \ 1), 0L)) {\n\t\t\tdict[test.substr(i, 1)] = 1;\n\t\t}\n\t\telse {\n\t\t\tdict[test.substr(i,\
    \ 1)] += 1;\n\t\t}\n\t}\n\treturn (dict);\n}", "{\n    var temp:Nullable<_,_>[]\
    \ = [Nullable(\"\"),Nullable(\"\"),Nullable(\"\")];\n    \n    for (let x of test)\
    \ {\n        if temp[0][x] is Nullable && temp[1][x] is Nullable && temp[2][x]\
    \ is Nullable {\n            temp[0][x] += 1;\n            temp[1][x] += 1;\n\
    \            temp[2][x] += 1;\n        } else {\n            temp[0][x] = 1;\n\
    \            temp[1][x] = 1;\n            temp[2][x] = 1;\n        }\n    }\n\
    \    return temp;\n}\n/*\nGiven a string, reverse the string and remove spaces\
    \ from the begining and from the end of it,\n    and returns it as an upper case\
    \ string.\n    \n    Example:\n    >>> upperCaseString(\"a b c\")\n    \"ABC\"\
    \n    >>> upperCaseString(\"a b c d e\")\n    \"A B C D E\"\n*/\nNullable!(string\
    \ [string]) upperCaseString(string test)\n{\n    var temp:Nullable<_,_>[] = [Nullable(\"\
    \"),Nullable(\"\")];\n    \n    for (let x of test) {\n        if x.isUpperCase\
    \ {\n            temp[0] += x;\n            temp[1] += \" \";\n        } else\
    \ {\n            temp[0] += \" \";\n            temp[1] += x;\n        }\n   \
    \ }\n    return temp;\n}\n/*\nGiven a string representing a number, return a boolean\
    \ indicating whether the number is a positive integer or negative.\n    \n   \
    \ Example:\n    >>> isPositiveInteger(\"0\")\n    True\n    >>> isPositiveInteger(\"\
    9\")\n    True\n    >>> isPositiveInteger(\"10\")\n    True\n    >>> isPositiveInteger(\"\
    -10\")\n    True\n    >>> isPositiveInteger(\"-11\")\n    False\n*/\nNullable!(bool[string])\
    \ isPositiveInteger(string test)\n{\n    return test.isPositive;\n}\n/*\nGiven\
    \ a string representing a number, return a boolean indicating whether the number\
    \ is a negative integer or zero.\n    \n    Example:\n    >>> isNegativeInteger(\"\
    0\")\n    True\n    >>> isNegativeInteger(\"9\")\n    True\n    >>> isNegativeInteger(\"\
    10\")\n    True\n    >>> isNegativeInteger(\"-10\")\n    True\n    >>> isNegativeInteger(\"\
    -11\")\n    False\n*/\nNullable!(bool[string]) isNegativeInteger(string test)\n\
    {\n    return test.isNegative;\n}\n/*\nGiven a string representing a number, return\
    \ a boolean indicating whether the number is a decimal number or not.\n    \n\
    \    Example:\n    >>> isDecimalNumber(\"10\")\n    True\n    >>> isDecimalNumber(\"\
    9.5\")\n    True\n    >>> isDecimalNumber(\"10.0\")\n    True\n    >>> isDecimalNumber(\"\
    -10.5\")"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
