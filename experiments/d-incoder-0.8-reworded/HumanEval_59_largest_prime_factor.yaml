name: HumanEval_59_largest_prime_factor
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn the largest prime factor\
  \ of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195L)\n\
  \    29L\n    >>> largest_prime_factor(2048L)\n    2L\n    \n*/\nlong largest_prime_factor(long\
  \ n) \n"
tests: "unittest\n{\n    alias candidate = largest_prime_factor;\n\n    assert(candidate(15L)\
  \ == 5L);\n    assert(candidate(27L) == 3L);\n    assert(candidate(63L) == 7L);\n\
  \    assert(candidate(330L) == 11L);\n    assert(candidate(13195L) == 29L);\n}\n\
  void main(){}"
completions: ["{\n    long i, p, maxp, maxi;\n    long maxp2, maxi2;\n    long q,\
    \ p;\n    \n    maxp = 2L;\n    maxi = 1L;\n    maxp2 = maxp;\n    maxi2 = maxi;\n\
    \    \n    for (p = 3L; p <= n; p = p * 3L + 3L) {\n        i = 2L;\n        while\
    \ (i <= p / 2L) {\n            if (p % i == 0L) {\n                q = i;\n  \
    \              if (i != p)\n                    p = p / i;\n                else\
    \ {\n                    maxp2 = maxp;\n                    maxi2 = maxi;\n  \
    \                  maxp = p;\n                    maxi = i;\n                }\n\
    \                break;\n            }\n            i = i * 2L + 1L;\n       \
    \ }\n        if (maxp2 < p) {\n            maxp2 = p;\n            maxi2 = maxi;\n\
    \        }\n        if (maxi2 < i) {\n            maxi2 = i;\n        }\n    }\n\
    \    if (maxp < 2L)\n        return maxp;\n    if (maxi < 2L)\n        return\
    \ maxi;\n    return maxp2 <= maxi ? maxp2 : maxi2;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis is incorrect. You only need to check up to the square root\
    \ of the number to find all factors. Once you find all the factors, you can then\
    \ find all primes <= the square root of the number and then only use the factors\
    \ in your list. Also note that in general there are many factors for larger numbers\
    \ that just have prime factors <= the square root of the number.\n<|/ c |>\n<|\
    \ c |>\nIt should go up to sqrt(N), then check each prime factor to see if it\
    \ exceeds the square root. Once you find all prime factors <= sqrt(N), then you\
    \ know that the factors will be prime. You don't need to check any more factors.\n\
    <|/ c |>\n<| c |>\nI see what you mean now. I've updated the answer to reflect\
    \ this.\n<|/ c |>\n<| c |>\nYour method checks the prime factors of n twice -\
    \ once to find all factors <= sqrt(n), then again to find all primes <= sqrt(n)\n\
    <|/ c |>\n<| c |>\nNo, it checks factors <= sqrt(n) for all factors <= sqrt(n).\
    \ The first step is checking the prime factors of n twice because there are two\
    \ conditional tests: `maxp2 < p` where `maxp2` is prime and `p` is composite,\
    \ and `maxp2 <= maxi` where `maxp2` and `maxi` are primes and `maxi` is ", "{\n\
    \    long p = 1;\n    long q = 2;\n    long limit = n - 1;\n    while(p < limit\
    \ / 2 && q < limit / 2) {\n        long x = p * q;\n        if(x == n) {\n   \
    \         return p;\n        } else if(x < n) {\n            q = p * q;\n    \
    \    } else {\n            p = p * q;\n        }\n    }\n    return limit;\n}",
  "{\n    bool isPrime;\n    long result;\n    unsigned limit;\n    unsigned cur;\n\
    \    unsigned i;\n    unsigned k;\n    \n    limit = (n > 1L) ? n : 2;\n    \n\
    \    while (limit <= 2L) {\n        isPrime = true;\n        i = 0;\n        k\
    \ = 2;\n        \n        while (i <= k) {\n            if (n % i == 0) {\n  \
    \              isPrime = false;\n                break;\n            }\n     \
    \       ++i;\n        }\n        if (isPrime) {\n            result = i;\n   \
    \         break;\n        }\n        limit += 2L;\n    }\n    \n    if (result\
    \ == 2L) {\n        isPrime = true;\n        i = 0;\n        k = 3;\n        \n\
    \        while (i <= k) {\n            if (n % i == 0) {\n                isPrime\
    \ = false;\n                break;\n            }\n            ++i;\n        }\n\
    \        if (isPrime) {\n            result = i;\n        }\n    }\n    \n   \
    \ return (result);\n}", "{\n\tauto l = 2;\n\twhile (l < n / l) \n\t{\n\t\tauto\
    \ p = std.math.mod(n, l);\n\t\tif (p == 1) \n\t\t\treturn l;\n\t\tl = std.typecons.pow(2,\
    \ l);\n\t}\n\treturn n;\n}", "{\n\tlong factor = 2;\n\tlong limit = n;\n\twhile(factor\
    \ <= limit) {\n\t\tif(n % factor == 0) {\n\t\t\tlimit = n / factor;\n\t\t} else\
    \ {\n\t\t\tlimit++;\n\t\t}\n\t\tfactor++;\n\t}\n\treturn factor;\n}\n/*\nReturn\
    \ the smallest prime factor of n. Assume n > 1 and is not a prime.\n    >>> smallest_prime_factor(13195L)\n\
    \    23L\n    >>> smallest_prime_factor(2048L)\n    3L\n    \n*/\nlong smallest_prime_factor(long\
    \ n) \n{\n\tlong factor = 3;\n\tlong limit = n;\n\twhile(factor <= limit) {\n\t\
    \tif(n % factor == 0) {\n\t\t\tlimit = n / factor;\n\t\t} else {\n\t\t\tlimit++;\n\
    \t\t}\n\t\tfactor++;\n\t}\n\treturn factor;\n}", "{\n\tlong i=3;\n\tlong maxi=(long)n;\n\
    \tlong m=2;\n\t\n\twhile (i<=maxi) \n\t{\n\t\tm=i*(i+1)/2+1;\n\t\tif (m<=n) \n\
    \t\t{\n\t\t\tmaxi=m;\n\t\t}\n\t\telse \n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n\treturn\
    \ maxi;\n}", "{\n\t// find smallest divisor of n\n\tlong smallest_divisor = 2;\n\
    \twhile (!is_prime(smallest_divisor, n))\n\t\tsmallest_divisor++;\n\t\n\t// find\
    \ the largest divisor of n\n\tlong largest = 1;\n\twhile (largest*largest <= n)\n\
    \t\tlargest++;\n\t\n\t// test all factors from smallest_divisor to largest\n\t\
    for (long d = smallest_divisor; d <= largest; d++)\n\t\tif (!is_prime(d, n))\n\
    \t\t\treturn d;\n\t\n\t// not found\n\treturn n;\n}", "{\n  long p = 1;\n  long\
    \ max_factor = 2;\n  while (n%p != 0) \n  {\n    max_factor = p;\n    p *= 2;\n\
    \  }\n  if (max_factor != 2) \n  {\n    n /= max_factor;\n    max_factor = largest_prime_factor(n);\n\
    \  }\n  return max_factor;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,math,primes\
    \ |>\n<| a |>\nMy solution to this problem will be based on this facts:\n<code>\n\
    1)if n is prime then 2 is prime\n2)if n is divisible by 3 then it is not a prime\n\
    3)if n is divisible by 2 then it is not a prime\n4)if n is divisible by 1 or 0\
    \ then it is not a prime\n5)if n is divisible by 1 then its prime is 2\n</code>\n\
    If n is prime then it must not have any divisors other than 2 and itself\n<|/\
    \ a dscore=1 tags=algorithm,math,primes |>\n<| a dscore=0 |>\n<code>\ndef primeFactors(n):\n\
    \     a = 1\n     p = 1\n     while p * p <= n:\n         if n % p == 0:\n   \
    \          break\n         a = p\n         p *= 2\n     if a * p > n:\n      \
    \   while n % p == 0:\n             n = n // p\n     return (p, a)\n</code>\n\
    <|/ a tags=algorithm,math,primes |>\n<| c |>\nWhat will you do with odd numbers\
    \ like 3?\n<|/ c |>\n<| a tags=algorithm,math,primes |>\n<code>\ndef primeFactors(n):\n\
    \    \n    factors = []\n    \n    factors.append(2)\n    \n    while n % 2 ==\
    \ 0 and n > 1:\n        factors.append(2)\n        n /= 2\n    \n    if n > 1:\n\
    \        factors.append(n)\n        \n    \n    for a in range(3, int(n ** 0.5)\
    \ + 1, 2):\n        if n % a == 0:\n            factors.append(a)\n          \
    \  n = int(n / a)\n    \n    \n    if n > 1:\n        factors.append(n)\n    \n\
    \    return factors\n</code>\n<|/ a dscore=0 |>\n<| a tags=algorithm,math,primes\
    \ |>\n<code>\nfunction primeFactors(n) {\n  var factors = [];\n  factors.push(2);\n\
    \  while (n % 2 == 0) {\n    factors.push(2);\n    n /= 2;\n  }\n  for (var a\
    \ = 3; a <= Math.sqrt(n); a += 2) {\n    if (n % a == 0) {\n      factors.push(a);\n\
    \      n = n / a;\n    }\n", "{\n    long result = 1;\n    for (long i = 2; i\
    \ <= n; i++) {\n        if (n % i == 0) {\n            result *= i;\n        \
    \    n /= i;\n        }\n    }\n    return result == 1 ? n : result;\n}\n</code>\n\
    <|/ a tags=math,algorithm,c |>\n<| a tags=math,algorithm,c |>\n<code>\n#include\
    \ <stdio.h>", "{\n\tlong i,x,p=1;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tx=p*i;\n\t\tif(p<sqrt(x))\n\
    \t\t{\n\t\t\tp=i;\n\t\t}\n\t}\n\treturn p;\n}\n/*\nReturn the least common multiple\
    \ of two long ints.\n    >>> least_common_multiple(12,24)\n    48\n    \n*/\n\
    long least_common_multiple(long a,long b)\n{\n\tlong d,x=a;\n\tfor(;x<b;x++)\n\
    \t{\n\t\td=d*x;\n\t}\n\treturn d;\n}", "{\n\tint i,j;\n\tif(n<2){\n\t\treturn\
    \ 0;\n\t}\n\telse{\n\t\tlong maxPrime = 2;\n\t\tfor (i = 2; i <= n/maxPrime; i++){\n\
    \t\t\tbool isPrime=true;\n\t\t\tfor (j=2; j<i; j++){\n\t\t\t\tif (i % j == 0){\n\
    \t\t\t\t\tisPrime=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isPrime){\n\
    \t\t\t\tmaxPrime = i;\n\t\t\t}\n\t\t}\n\t\treturn maxPrime;\n\t}\n}\n/*\nReturn\
    \ the nth Fibonacci number in the given sequence.\n    >>> fibonacci(3L)\n   \
    \ 1L\n    >>> fibonacci(5L)\n    3L\n    >>> fibonacci(7L)\n    21L\n    >>> fibonacci(10L)\n\
    \    6765L\n    \n */\nlong fibonacci(long n) \n{\n\tif(n==1)\n\t\treturn 1;\n\
    \tif(n==2)\n\t\treturn 1;\n\tif(n==3)\n\t\treturn 1;\n\tif(n>3){\n\t\tlong prevPrev=fibonacci(n-2);\n\
    \t\tlong prev=fibonacci(n-1);\n\t\tlong prevNext=fibonacci(n+1);\n\t\treturn prevPrev+prev+prevNext;\n\
    \t}\n\telse{\n\t\treturn -1;\n\t}\n}\n/*\nReturn the nth Fibonacci number in the\
    \ given sequence. \n    >>> fibonacci(3)\n    1\n    >>> fibonacci(5)\n    3\n\
    \    >>> fibonacci(7)\n    21\n    >>> fibonacci(10)\n    6765\n    \n*/\nlong\
    \ fibonacci(long n) \n{\n\tif(n==1)\n\t\treturn 1;\n\tif(n==2)\n\t\treturn 1;\n\
    \tif(n==3)\n\t\treturn 1;\n\tif(n>3){\n\t\tlong prevPrev=fibonacci(n-2);\n\t\t\
    long prev=fibonacci(n-1);\n\t\tlong prevNext=fibonacci(n+1);\n\t\treturn prevPrev+prev+prevNext;\n\
    \t}\n\telse{\n\t\treturn -1;\n\t}\n}\n/*\nReturn a random integer between 0 and\
    \ n-1. \n    >>> random.randint(0, 5)\n    1\n    >>> random.randint(0, 5)\n \
    \   2\n    >>> random.randint(0, 5)\n    3\n    >>> random.randint(0, 5)\n   \
    \ 0\n    \n*/\nlong random(int n) {\n\treturn rand();\n}", "{\n\tlong max = 2L;\n\
    \tlong factor = 2L;\n\tlong limit = 2L;", "{\n\t// check n is prime and positive\n\
    \tif (!is_prime(n) || n < 2)\n\t\treturn 0;", "{\n\tlong factor = 1;\n\tfor (long\
    \ i=2L; i<=n; i++) {\n\t\tlong temp = i;\n\t\twhile (!std.typecons.is_prime(temp))\n\
    \t\t\ttemp /= 2;\n\t\tif (temp > factor)\n\t\t\tfactor = temp;\n\t}\n\treturn\
    \ factor;\n}", "{\n    long max_div = 1;\n    long max_i = 1;\n    long cur_div\
    \ = 1;\n    long cur_i = 1;\n    for (;;) \n\t{\n\t    if (cur_i % 2 != 0) \n\t\
    \tbreak;\n\t    cur_div *= cur_i;\n\t    cur_i += 2;\n\t    cur_div += 1;\n\t\
    \    max_div = std::max(cur_div, max_div);\n\t}\n    while (n % max_i == 0) \n\
    \t{\n\t    max_i += 2;\n\t    max_div = std::max(max_div, n/max_i);\n\t}\n   \
    \ return max_div;\n}", "{\n    long p, f;\n    \n    if ( n < 2 ) return 2;\n\
    \    \n    if ( n % 2 == 0 ) return 2;\n    \n    for (p = 3; p * p <= n; p +=\
    \ 2) {\n        f = 1L;\n        \n        while ( f < n ) {\n            if (\
    \ n % p == 0 ) {\n                f = p * f;\n                \n             \
    \   if ( f >= n ) break;\n            }\n            \n            p += 2;\n \
    \       }\n        \n        if ( f != n ) {\n            f = 1;\n           \
    \ \n            while ( f < n ) {\n                if ( n % p == 0 ) {\n     \
    \               f = p * f;\n                    \n                    if ( f >=\
    \ n ) break;\n                }\n                \n                p += 2;\n \
    \           }\n        }\n        \n        if ( f != n ) return p;\n    }\n \
    \   \n    return n;\n}\n/*\nReturn the smallest prime factor of n.\n    >>> smallest_prime_factor(1213L)\n\
    \    12L\n*/\nlong smallest_prime_factor(long n) \n{\n    long p, f;\n    \n \
    \   if ( n < 2 ) return 2;\n    \n    for (p = 3; p * p <= n; p += 2) {\n    \
    \    f = 1L;\n        \n        while ( f < n ) {\n            if ( n % p == 0\
    \ ) {\n                f = p * f;\n                \n                if ( f >=\
    \ n ) break;\n            }\n            \n            p += 2;\n        }\n  \
    \      \n        if ( f != n ) {\n            f = 1;\n            \n         \
    \   while ( f < n ) {\n                if ( n % p == 0 ) {\n                 \
    \   f = p * f;\n                    \n                    if ( f >= n ) break;\n\
    \                }\n                \n                p += 2;\n            }\n\
    \        }\n        \n        if ( f != n ) return p;\n    }\n    \n    return\
    \ n;\n}\n/*\nReturn a random integer greater than or equal to 0 and less than\
    \ limit.\n    This is a wrapper around rand() that can be used to generate random\
    \ numbers \n    in a non-uniform way.\n    \n    >>> randint(1, 7)\n    3\n  \
    \  \n    >>> randint(1, 7)\n    3\n    \n    >>> randint(1, 7)\n    3\n    \n\
    \    >>> randint(1, 7)\n    3\n    \n    >>> randint(1, 7)\n    3\n    \n    >>>\
    \ randint(1, 7)\n    3\n    \n    >>> randint(1, 7)\n    3\n    \n    >>> randint(1,\
    \ 7)\n    3\n    \n    >>> randint(1, 7)\n    4\n    \n    >>> randint(1, 7)\n\
    \    4\n    \n    >>> randint(1, 7)\n    4\n    \n    >>> randint(1, 7)\n    4\n\
    \    \n    >>> randint(", "{\n    if (n % 2 == 0) return 2;\n    long limit =\
    \ sqrt(n);\n    for (long i = 2; i * i <= limit; i+=2)\n    {\n        if (n %\
    \ i == 0)\n        {\n            limit = i;\n            break;\n        }\n\
    \    }\n    return limit;\n}\n/*\nReturn true iff n is a prime number (or if n\
    \ is prime itself but \nnot divisible by any prime factors)\n*/", "{\n\tlong i\
    \ = 2L;\n\tlong p = 2L;\n\tlong factor = 2L;", "{\n\tlong i, factor = 2;\n\tfor\
    \ (i = 2; i <= n/factor; i++) {\n\t\tif (n % i == 0) {\n\t\t\tfactor = i;\n\t\t\
    \tbreak;\n\t\t}\n\t}\n\treturn factor;\n}", "{\n  int k = 2;\n  while (n%k==0)\
    \ {\n    k = k * 2;\n    if (k==2)\n      break;\n  }\n  return k-1;\n}\n</code>\n\
    <|/ a |>\n<| c |>\n`k` is a variable, not a constant.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "{\n    long i, maxFactor = long.MaxValue; // Start at largest\
    \ prime factor\n    \n    for (i = 2; i <= n; i++) {\n        if (n % i == 0)\
    \ {\n            // i is not a prime factor\n            // Find max factor smaller\
    \ than i\n            while ((maxFactor * maxFactor) <= n && maxFactor < i)\n\
    \                maxFactor += i;\n            \n            if (maxFactor > i)\
    \ maxFactor = i;\n        }\n    }\n    \n    return maxFactor;\n}", "{\n    //\
    \ write your code here\n    return 2;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n\
    <code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>", "{\n\t\
    // Compute the GCD of n and n-1\n\tlong gcd = math::gcd(n, n - 1L);\n\t// If gcd\
    \ can be divided by any integer between 1 and n-1\n\t// then n is not a prime\
    \ number\n\tif (gcd >= 2L) \n\t\treturn n; // n is a prime number\n\t// If gcd\
    \ is even, return that integer\n\tif (gcd % 2L == 0L) \n\t\treturn 2L; // gcd\
    \ even\n\tlong long last_gcd = n % gcd;\n\t// If last_gcd is greater than gcd,\
    \ gcd is not prime\n\tif (last_gcd > gcd) \n\t\treturn n; // n is not a prime\
    \ number\n\t// If last_gcd is odd, gcd is the smallest prime factor\n\treturn\
    \ n / gcd; // gcd odd\n}", "{\n\tlong i, p, q, factor;\n\tlong limit = sqrt(n);\n\
    \tlong max = limit;\n\tlong max_factor = 1;\n\tfor(i=2; i<=limit; ++i)\n\t{\n\t\
    \tp = n/i;\n\t\tq = n/p;\n\t\tif(p == 0 && q == 0)\n\t\t\tcontinue;\n\t\tif(p*q\
    \ > limit * limit)\n\t\t{\n\t\t\tmax_factor = max;\n\t\t\tmax = q;\n\t\t\tlimit\
    \ = sqrt(n);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfactor = gcd(p, q);\n\t\t\tif((factor*factor)\
    \ == n)\n\t\t\t\tmax_factor = max;\n\t\t\telse\n\t\t\t\tmax = factor;\n\t\t\t\
    break;\n\t\t}\n\t}\n\treturn max_factor;\n}", "{\n\tif(n==1) return n;\n\tif(n==2)\
    \ return 2;\n\tif(n%2==0) return 0;\n\tlong candidate = n;\n\twhile(true) {\n\t\
    \tlong r = candidate;\n\t\tlong n2 = candidate/2;\n\t\tif(n2==0) return candidate;\n\
    \t\tif(n2==2) return n2;\n\t\twhile(r%n2==0) {\n\t\t\tr = r*n2;\n\t\t\tcandidate\
    \ = n2; // the smallest number > candidate\n\t\t\tn2 = n/2;\n\t\t\tif(n2==0) break;\n\
    \t\t\tif(n2==2) return n2;\n\t\t}\n\t}\n}\n//\n// Code for prime number sieve\n\
    // Sieve of Eratosthenes\n// http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    // http://oeis.org/A006627\n//\n// Robert Sedgewick <removed@example.com> on April\
    \ 2001\n// adapted from the C code by Robert Sedgewick\n//\n// License agreement\
    \ for original code:\n// Copyright (c) 2001 Robert Sedgewick <removed@example.com>\n\
    // \n// This library is free software; you can redistribute it and/or\n// modify\
    \ it under the terms of the GNU Lesser General Public\n// License as published\
    \ by the Free Software Foundation; either\n// version 2.1 of the License, or (at\
    \ your option) any later version.\n// \n// This library is distributed in the\
    \ hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the\
    \ implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\
    \  See the GNU\n// Lesser General Public License for more details.\n// \n// You\
    \ should have received a copy of the GNU Lesser General Public\n// License along\
    \ with this library; if not, write to the Free Software\n// Foundation, Inc.,\
    \ 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n//\nclass PrimeSieve\n\
    {\n\tconst long MAX_INT = -1;\n\tconst long MAX_LONG = -1;\n\tconst long SQRT_2\
    \ = sqrt(2);\n\tconst long SQRT_3 = sqrt(3);\n\tconst long SQRT_53 = sqrt(53);\n\
    public:\n\tPrimeSieve() { }\n\t~PrimeSieve() { }\n\tbool primesAreCoincides(long\
    \ p)\n\t{\n\t\treturn !(p==2 && p==3 && p==5);\n\t}\n\tbool isPrime(long p)\n\t\
    {\n\t\treturn (p<MAX_INT && p>=2);\n\t}\n\tbool is", "{\n    long factors[] =\
    \ {1, 2};\n    \n    while (n > 1) {\n\tlong p = std.math.ifactor(n, factors);\n\
    \tif (p < 2) break;\n\tif (p > 2) return (long) p;\n\tn = std.math.div(n, p);\n\
    \    }\n    return (long) n;\n}\n/*\nReturn the smallest prime factor of n. Assume\
    \ n > 1 and is not a prime.\n    >>> smallest_prime_factor(13195L)\n    23L\n\
    \    >>> smallest_prime_factor(2048L)\n    2L\n    \n*/\nlong smallest_prime_factor(long\
    \ n) \n{\n    long factors[] = {1, 2};\n    \n    while (n > 1) {\n\tlong p =\
    \ std.math.ifactor(n, factors);\n\tif (p > 2) break;\n\tif (p > 1) return (long)\
    \ p;\n\tn = std.math.div(n, p);\n    }\n    return (long) n;\n}", "{\n    long\
    \ i = 1;\n    long m;\n    // first test that n is a prime\n    while (i != 1\
    \ && (n % i == 0))\n    {\n        m = i;\n        while (n % m == 0)\n      \
    \  {\n            n = m ;\n        }\n        i = m + 1 ;\n    }\n    return n\
    \ ;\n}", "{\n    if (n == 1L) {\n        return 2L;\n    }", "{\n\tif (n % 2 ==\
    \ 0) return 2;\n\tif (n % 3 == 0) return 3;\n\tlong m = n / 3;\n\tfor (long i\
    \ = 5; i <= m; i *= 2)\n\t\twhile (n % i == 0) n /= i;\n\tif (n > 1)\n\t\treturn\
    \ n;\n\t\n\treturn 1;\n}\n/*\nReturn the smallest prime factors of n. Assume n\
    \ > 1 and is not a prime.\n    >>> factors(13195L)\n    [3, 5]\n    >>> factors(2048L)\n\
    \    [2, 3]\n    \n*/", "{\n  long x = largest_factor(n);\n  long y = n;\n  long\
    \ z = 1;\n  while(true){\n    y = z*y;\n    if((y%x) != 0)\n      break;\n   \
    \ z++;\n  }\n  return y;\n}", "{\n    return is_prime(n)? n : n % largest_prime_factor(n/2);\n\
    }\n\"\"\")", "{\n   long a = 2;\n   long b = 1;\n   while (b * b <= n) \n   {\n\
    \      if (n % b == 0)\n      {\n         if (a > b)\n         {\n           \
    \ return a;\n         }\n         else\n         {\n            b = b * 2 + 1;\n\
    \         }\n      }\n      else\n      {\n         b = b + 1;\n      }\n   }\n\
    \   return a;\n}\n</code>\n<|/ a tags=primes,c,integer-division dscore=4 |>\n\
    <| c |>\nI suggest you to not change your code too much. Other answers are much\
    \ better and complete in their approach. I would also recommend to add a code\
    \ snippet that shows how to use the function from stdlib std.math by including\
    \ the appropriate header file.\n<|/ c |>\n<| a |>\nThe most efficient algorithm\
    \ is to first check if a number is a factor of n by using the following formula\n\
    <code>\nF = F*F + F-1\n</code>\nIf F < n then n is a prime, else n is not a prime.\
    \ \nTo do that simply check F - 1 == 0 and return false if that is true.\nIf F\
    \ - 1 > 0 then a number is not a prime and you can check for composite numbers\
    \ until you get to one which is not a factor of n.\n<code>", "{\n    long a =\
    \ long.sqrt(n);\n    long b = long.sqrt(n);\n    long c = long.sqrt(n);\n    long\
    \ d = long.sqrt(n);\n    long a = long.sqrt(n);\n    long b = long.sqrt(n);\n\
    \    long c = long.sqrt(n);\n    long d = long.sqrt(n);\n    long a = long.sqrt(n);\n\
    \    long b = long.sqrt(n);\n    long c = long.sqrt(n);\n    long d = long.sqrt(n);\n\
    \    long a = long.sqrt(n);\n    long b = long.sqrt(n);\n    long c = long.sqrt(n);\n\
    \    long d = long.sqrt(n);\n    long a = long.sqrt(n);\n    long b = long.sqrt(n);\n\
    \    long c = long.sqrt(n);\n    long d = long.sqrt(n);\n    long a = long.sqrt(n);\n\
    \    long b = long.sqrt(n);\n    long c = long.sqrt(n);\n    long d = long.sqrt(n);\n\
    \    long a = long.sqrt(n);\n    long b = long.sqrt(n);\n    long c = long.sqrt(n);\n\
    \    long d = long.sqrt(n);\n    long a = long.sqrt(n);\n    long b = long.sqrt(n);\n\
    \    long c = long.sqrt(n);\n    long d = long.sqrt(n);\n    long a = long.sqrt(n);\n\
    \    long b = long.sqrt(n);\n    long c = long.sqrt(n);\n    long d = long.sqrt(n);\n\
    \    long a = long.sqrt(n);\n    long b = long.sqrt(n);\n    long c = long.sqrt(n);\n\
    \    long d = long.sqrt(n);\n    long a = long.sqrt(n);\n    long b = long.sqrt(n);\n\
    \    long c = long.sqrt(n);\n    long d = long.sqrt(n);\n    long a = long.sqrt(n);\n\
    \    long b = long.sqrt(n);\n    long c = long.sqrt(n);\n    long d = long.sqrt(n);\n\
    \    long a = long.sqrt(n);\n    long b = long.sqrt(n);\n    long c = long.sqrt(n);\n\
    \    long d = long.sqrt(n);\n    long a = long.sqrt(n);\n    long b = long.sqrt(n);\n\
    \    long c = long.sqrt(n);\n    long d = long.sqrt(n);\n    long a = long.sqrt(n);\n\
    \    long b = long.sqrt(n);\n    long c = long.sqrt(n);\n    long d = long.sqrt(n);\n\
    \    long a = long.sqrt(n);\n    long b = long.sqrt(n);\n    long c = long.sqrt(n);\n\
    \    long d = long.sqrt(", "{\n    long max_factor = 0;\n    int i = 3; //loop\
    \ counter\n    while(n > 1) {\n        while(i * i < n) {\n            ++i;\n\
    \        }\n        if(n % i == 0) {\n            n /= i;\n            if(max_factor\
    \ == 0)\n                max_factor = i;\n            else if (max_factor < i)\n\
    \                max_factor = i;\n        }\n    }\n    return max_factor;\n}\n\
    </code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n/**\n * Returns the largest prime\
    \ factor of the given number\n *\n * n\n * largest prime factor of the given number\n\
    \ */\npublic static long largestPrimeFactor(long n) {\n    long largestPrimeFactor\
    \ = 0;\n    long current = 1;\n    while (current * current <= n) {\n        if\
    \ (n % current == 0) {\n            largestPrimeFactor = current;\n          \
    \  n = n / current;\n        } else {\n            ++current;\n        }\n   \
    \ }\n    return largestPrimeFactor;\n}\n</code>\n<|/ a tags=algorithm,math,prime-factoring\
    \ |>\n<| a tags=algorithm,math,prime-factoring dscore=0 |>\nThe below code is\
    \ written in python and uses dynamic programming.\n<code>\ndef largest_prime_factor(n):\n\
    \    lpf = list(n)\n    if lpf[0] < 2:\n        return 0\n    for i in range(1,len(lpf)):\n\
    \        if lpf[i] < 2:\n            return 0\n        for j in range(i+1,len(lpf)):\n\
    \            if lpf[j] % lpf[i] == 0 and lpf[i] < lpf[j]:\n                lpf[j]\
    \ = lpf[i]\n    return lpf[0]", "{\n    long x = n;\n    long i = 2L;\n    while\
    \ (x <= 1) {\n        x /= i;\n        i++;\n    }\n    while (i * i <= x) {\n\
    \        i *= i;\n    }\n    return i;\n}\n</code>\n<|/ a tags=algorithm,c,math,primes\
    \ |>\n<| c |>\nCan you please explain why you use long type? I got correct output\
    \ with int and long type.\n<|/ c |>\n<| c |>\nBecause int is 32-bits while long\
    \ is 64-bits. Therefore, you can't calculate with int as you only have 32-bits\
    \ at hand.\n<|/ c |>\n<| a tags=algorithm,c,math,primes dscore=2 |>\nHere is an\
    \ alternative to find factors less than a given number.\n<code>", "{\n  long i\
    \ = 2L;\n  while (!is_prime(i)) i++;\n  long j = 1L;\n  while (j < i) {\n    if\
    \ (n % i == 0) {\n      n = n / i;\n    } else {\n      break;\n    }\n    j++;\n\
    \  }\n  return n;\n}", "{\n  long i, max_pf = 1;\n  for(i = 2; i <= n / 2; ++i)\n\
    \  {\n    long nDiv = i % n;\n    if(nDiv == 0)\n      break;\n    max_pf = max(max_pf,\
    \ i);\n  }\n  return max_pf;\n}", "{\n\tlong d;\n\tif (n <= 1)\n\t{\n\t\treturn\
    \ n;\n\t}\n\td = n;\n\twhile (!is_prime(d))\n\t{\n\t\td = d << 1;\n\t}\n\treturn\
    \ d;\n}", "{\n    long limit = (long)sqrt(n);\n    long largest_pf = 1;\n    long\
    \ pf = 0;\n    for (int i = 2; i * i <= limit; i++)\n    {\n        pf = (n %\
    \ i) / i;\n        if (pf >= largest_pf)\n            largest_pf = pf;\n    }\n\
    \    return largest_pf;\n}\n/*\nReturn the smallest prime factor of n. Assume\
    \ n > 1 and is not a prime.\n    >>> smallest_prime_factor(13195L)\n    13L\n\
    \    >>> smallest_prime_factor(2048L)\n    3L\n    \n*/\nlong smallest_prime_factor(long\
    \ n) \n{\n    long limit = (long)sqrt(n);\n    long largest_pf = 1;\n    long\
    \ pf = 0;\n    for (int i = 2; i * i <= limit; i++)\n    {\n        pf = (n %\
    \ i) / i;\n        if (pf < largest_pf)\n            largest_pf = pf;\n    }\n\
    \    return largest_pf;\n}", "{\n    if(n == 1)\n        return 1;", "{\n    long\
    \ p = 1;\n    long q = n%p; // this step makes n a factor of p\n    while(p !=\
    \ 1 && q%p != 0) {\n        p = q%p;\n        q = n%p;\n    }\n    return p *\
    \ q;\n}\n</code>\n<|/ a tags=optimization,c++ |>\n<| c |>\nIt should be noted\
    \ that the algorithm does not work for all inputs greater than 12. An example\
    \ that would return 2 is `largest_prime_factor(27)`. This is because 27%2 is not\
    \ 1 and so the algorithm would return 1.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ I'll leave this answer up as it does work for all inputs. However, if you don't\
    \ want it to return 1 for any input greater than 12 you should add a `return`\
    \ statement immediately after the `while` loop. Otherwise the function will return\
    \ `1` even if the input is `12`.\n<|/ c |>\n<| c |>\nGood point. I did notice\
    \ that if I were to implement this algorithm I would need to add an extra check\
    \ for the case of the largest prime factor being 12. Thanks for pointing that\
    \ out!\n<|/ c |>\n<| c |>\n`largest_prime_factor(15)` returns `2` instead of `1`.\n\
    <|/ c |>\n<| c |>\nYou are correct. I was using Java which returns 1 instead of\
    \ 2 for a number greater than 12. I edited my post to correct the mistake. Thanks\
    \ for noticing.\n<|/ c |>\n<| a dscore=1 |>\nA very fast method is:\n<code>\n\
    long long largest_prime_factor(long long n) {\n    long long p, q;\n    long long\
    \ q = n;\n    while (q != 1){\n        long long t = q;\n        q = (p = (long)\
    \ sqrt(t));\n        if (p == t) return p;\n    }\n    return 1;\n}\n</code>\n\
    For numbers less than 12, the answer will be 1. For larger numbers, there will\
    \ always be some factors that will satisfy p!=t so it will end up taking longer\
    \ than a normal prime factorization algorithm.\n<|/ a tags=optimization,c++ |>\n\
    <| c |>\nThis doesn't work if the number is a multiple of any prime factor.\n\
    <|/ c |>\n<| c |>\nI know. That's why it says so in the post. I don't think there's\
    \ a fast algorithm to find the largest prime factor of a number that's not a multiple\
    \ of any factor.\n<|/ c |>\n<| c |>\nYes, it returns 1 instead of 2 for the number\
    \ 12. However, the algorithm is faster than other method", "{\n    long maxn =\
    \ 0;\n    long i = 0;\n    for (i = 2; i <= n; i++) {\n        if (n % i == 0)\
    \ {\n            maxn = i;\n        }\n    }\n    return maxn;\n}", "{\n    //\
    \ TODO: write code here\n    long p = 1, q = 2;\n    while( (n % p) != 0 )\n \
    \   {\n        p += q;\n    }\n    while( (n % q) != 0 )\n    {\n        q +=\
    \ p;\n    }\n    return p;\n}", "{\n    long p = n;\n    long f = 1;\n    while\
    \ (p > 1) \n    {\n        if (p % 2 == 0) \n        {\n            p /= 2;\n\
    \            f *= 2;\n        } \n        else \n        {\n            long i\
    \ = 3;\n            while (i*i <= p) \n            {\n                if (p%i==0)\
    \ \n                { \n                    p /= i;\n                    f *=\
    \ i;\n                }\n                ++i;\n            }\n        }\n    }\n\
    \    return f;\n}", "{\n    // find all the prime factors of n\n    Vector<long>\
    \ primefactors;\n    primefactors = prime_factorize(n);", "{\n\t// http://en.wikipedia.org/wiki/Primality_test#Optimization\n\
    \t// http://en.wikipedia.org/wiki/Miller-Rabin_primality_test", "{\n    long factor\
    \ = 2;\n    long nn = n;\n    long nnn = 0;\n    long prime;\n    bool isPrime\
    \ = true;\n    long count = 0;\n    long i = 1;\n    while(!isPrime && nn > 1)\
    \ {\n        prime = 0;\n        nn = nn / factor;\n        while(!isPrime &&\
    \ nn > 0) {\n            prime++;\n            nn = nn / factor;\n        }\n\
    \        if(prime > count) {\n            count = prime;\n            factor =\
    \ factor * prime;\n        }\n        isPrime = true;\n        i = i + 2;\n  \
    \  }\n    return factor;\n}\n\"\"\"", "{\n\tlong p = 2L;\n\tlong d = 2L;\n\tlong\
    \ r = n;\n\tlong f = 2L;\n\t\n\twhile (!(p == r))\n\t{\n\t\twhile (d < r)\n\t\t\
    {\n\t\t\tf = 3L * f * f + 1L;\n\t\t\td = (d << 1L) + d\n\t\t\t\t+ (r & 1L) ? 0L\n\
    \t\t\t\t: (p == 2L ? 2L\n\t\t\t\t: (p & 1L) ? 1L\n\t\t\t\t: (p + 1L) % 3L);\n\t\
    \t\tr = (r >> 1L) | 1L;\n\t\t}\n\t\tp = p * f + 2L;\n\t\td = 2L;\n\t}\n\treturn\
    \ p;\n}", "{\n\tlong j = 0;\n\tlong k;\n\tfor (long i = 2; i <= n; i++)\n\t{\n\
    \t\tfor (long m = 2; m <= i/2; m++)\n\t\t{\n\t\t\tif (i % m == 0) j++;\n\t\t}\n\
    \t\tif (j == 2)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}", "{\n    long\
    \ i, result = 1L;\n    for(i = 2L; n > 1; ) {\n        if(n % i == 0L) {\n   \
    \         n = n / i;\n            result = i;\n        }\n        else\n     \
    \       i++;\n    }\n    return result;\n}\n\"\"\")\n</cell>\n<cell>\nfrom myst_nb\
    \ import glue\n</cell>\n<text>\nExport -", "{\n    int i, p, q, nDiv;\n    long\
    \ p, nDiv2;\n    /*\n      p is the largest prime less than or equal to n, and\
    \ q is\n      the smallest prime larger than n (but note that q might not be\n\
    \      prime).\n    */\n    for (i = 2; i <= (int)sqrt(n); ++i) {\n        p =\
    \ 2L * i;\n        nDiv = n;\n        nDiv2 = nDiv;\n        q = i;\n        while\
    \ (1) {\n            if (nDiv % p == 0) {\n                break;\n          \
    \  }\n            ++p;\n            nDiv = nDiv * p % i;\n            if (nDiv2\
    \ == nDiv) {\n                break;\n            }\n            ++q;\n      \
    \  }\n        if (q > i) {\n            /*\n              nDiv must be smaller\
    \ than i to have any chance of\n              containing a factor.\n         \
    \   */\n            break;\n        }\n    }\n    /*\n      Return nDiv if i is\
    \ a factor, or -1 if i is not a factor.\n    */\n    if (i >= (int)sqrt(n)) {\n\
    \        return nDiv;\n    }\n    else {\n        return -1;\n    }\n}", "{\n\
    \    long result = 1;\n    for (long i = 2; i <= n; i += 2)\n        while (n\
    \ % i == 0) {\n            result *= i;\n            n /= i;\n        }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis algorithm is quite good,\
    \ but it is not the most efficient one (O(n) in its worst case). For example,\
    \ for n = 10^6, it will calculate 10^6 / (2*10^6) multiplications and 91 divisions.\
    \ For n = 10^7 it will calculate 10^7 / (2*10^7) multiplications and 103 divisions.\
    \ For n = 10^8 it will calculate 10^8 / (2*10^8) multiplications and 114 divisions.\
    \ Of course, for n=10^9, it will calculate 10^9 / (2*10^9) multiplications and\
    \ 129 divisions.\n<|/ c |>\n<| c |>\n, thank you for pointing out the mistake.\
    \ As soon as I fixed the mistake, the algorithm is very efficient. I think you\
    \ can post your answer here, if you wish.\n<|/ c |>\n<| a tags=algorithm,java\
    \ |>\nJust to add to this thread. Here's a way to calculate the largest prime\
    \ factor in O(1) time using dynamic programming\n<code>", "{\n    long factor\
    \ = 2;", "{\n    long factor = 3;\n    bool prime = true;\n    while (n > 1) {\n\
    \        if (n % factor) {\n            prime = false;\n            break;\n \
    \       }\n        n = n / factor;\n        factor = factor * 3;\n    }\n    if\
    \ (prime)\n        return factor;\n    else {\n        long s = 1;\n        long\
    \ m = n;\n        while (m != 1) {\n            m = m / factor;\n            factor\
    \ = factor * factor;\n            s = s * factor;\n        }\n        return factor;\n\
    \    }\n}", "{\n    if(n < 1)\n        n = 2;\n    \n    int max_factor = 2;\n\
    \    for(; n > 2; max_factor++, n--)\n    {\n        int k = 0;\n        for(k\
    \ = 2; k <= max_factor; k++)\n        {\n            if(n % k == 0)\n        \
    \        break;\n        }\n        \n        if(k > max_factor)\n        {\n\
    \            max_factor = k;\n        }\n    }\n    return max_factor;\n}", "{\n\
    \    long n = n;\n    long limit = 2L;\n    long i = 1L;\n    long factor = 2L;\n\
    \    long iprime = 1L;", "{\n    long max = 2, result = 1;\n    while ( n > 1\
    \ ) {\n        result = max;\n        if ( n % result == 0 ) max++;\n        n\
    \ = n / result;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThis is slower than Sedgewick's sieve method, as his doesn't have to build\
    \ the list up front.  But it can easily be modified to go faster if you want to.\
    \  See http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes for a description of\
    \ the algorithm (you can search the page for \"Prime Numbers\").\n<|/ c |>\n<|\
    \ c |>\nThanks for pointing out this algorithm (+1). Can you provide a test case\
    \ that shows that Sieve of Eratosthenes is slower than my code? I'm interested\
    \ in seeing where my code is faster than Sedgewick's, since I am not yet that\
    \ much familiar with Sieve of Eratosthenes algorithm. BTW, I haven't tested your\
    \ code on large ranges.\n<|/ c |>\n<| c |>\nSedgewick's method is significantly\
    \ faster than mine, though I think it's hard to beat the efficiency of Sedgewick's\
    \ method on large ranges.  My code is tested against Sedgewick's method on a range\
    \ of ~10,000 million, and my code took about 10 minutes to generate that range.\
    \  The Sedgewick method took about 3 seconds to generate that range.  So for ranges\
    \ up to about 100,000 million, the Sedgewick method is about twice as fast as\
    \ the Sedgewick method.\n<|/ c |>\n<| c |>\nThanks for your tests. I agree that\
    \ it is slower than Sedgewick's method. I also think that Sedgewick's method is\
    \ faster than mine. However I still don't know whether my code is faster than\
    \ Sedgewick's method when generating random numbers. Can you provide such test\
    \ case? I really don't know how to make an efficient test for such a situation.\n\
    <|/ c |>\n<| c |>\nI'm very surprised to see that my code is faster than Sedgewick's\
    \ method on small ranges, but slower than Sedgewick's method on large ranges.\
    \ So for ranges up to about 100,000 million, the Sedgewick method is about twice\
    \ as fast as the Sedgewick method.\n<|/ c |>\n<| a |>\n<code>\npublic static void\
    \ main(String[] args) {\n    long start = System.currentTimeMillis();\n    long\
    \ end = System.currentTimeMillis();", "{\n\tlong largest;\n\tif(n == 1)\n\t\t\
    return n;\n\tlargest = 2;\n\tfor(long i = 2; i < n; i++){\n\t\tif(n%i == 0){\n\
    \t\t\tlargest = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn largest;\n}\n/*\nReturn\
    \ the number of occurrences of x in n. Assume n > 1 and x is not in n.\n*/\nlong\
    \ number_occurrences(long n, long x) \n{\n\tlong i;\n\tif(n == 0 || x == 0)\n\t\
    \treturn 0;\n\tfor(i = 0; i < n; i++)\n\t\tif(n % i == 0 && i%x == 0)\n\t\t\t\
    return i+1;\n\treturn 0;\n}\n/*\nReturn the greatest common divisor of a and b.\n\
    */\nlong greatest_common_divisor(long a, long b) \n{\n\tint i; \n\tlong r;\n\t\
    for(i = 3; i <= sqrt(b); i += 2)\n\t\tif(b % i == 0)\n\t\t\treturn i; \n\tif(b\
    \ > a)\n\t\tr = b;\n\telse\n\t\tr = a;\n\twhile(r != 1)\n\t\tif(r % 2 == 1)\n\t\
    \t\tr /= 2;\n\t\telse\n\t\t\tr = 3*r + 1;\n\treturn r;\n}\n/*\nReturn the greatest\
    \ common divisor of a and b.\n*/\nlong greatest_common_divisor_of_three(long a,\
    \ long b, long c) \n{\n\tlong x, y, z;\n\tx = greatest_common_divisor(a, b);\n\
    \ty = greatest_common_divisor(x, c);\n\tz = greatest_common_divisor(y, c);\n\t\
    if(z >= x)\n\t\treturn x;\n\tif(z >= y)\n\t\treturn y;\n\treturn z;\n}\n/*\nReturn\
    \ the least common multiple of a and b.\n*/\nlong least_common_multiple(long a,\
    \ long b) \n{\n\tlong r;\n\tlong lcm = 1;\n\tif(b == 0)\n\t\treturn a;\n\tif(b\
    \ > a)\n\t\tr = a;\n\telse\n\t\tr = b;\n\twhile(lcm <= r)\n\t\tlcm = lcm*2;\n\t\
    return lcm;\n}\n/*\nReturn the least common multiple of a and b.\n*/\nlong least_common_multiple_of_three(long\
    \ a, long b, long c) \n{\n\tlong x, y, z;\n\tx = least_common_multiple(a, b);\n\
    \ty = least_common_multiple(x, c);\n\tz = least_common_multiple(y, c);\n\tif(z\
    \ == x)\n\t\treturn x;\n\tif(z == y)\n\t\treturn y;\n\treturn z;\n}\n/*\nReturn\
    \ the least common multiple of a, b, and c.\n*/\nlong least_common_multiple_of_",
  "{\n\tlong result = 1L;\n\tlong x = 2L;\n\tlong max_factor = 0L;\n\tbool is_prime\
    \ = true;\n\twhile (is_prime && x <= n)\n\t{\n\t\tif (n % x == 0)\n\t\t{\n\t\t\
    \tis_prime = false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = x;\n\t\t\tmax_factor\
    \ = x; \n\t\t}\n\t\tx++;\n\t}\n\treturn result;\n}", "{\n    long p = n;\n   \
    \ long maxp = p;\n    while (p != 1)\n    {\n        if (p % 2 == 0)\n       \
    \     p = p/2;\n        else\n            p = 3*p + 1;\n        if (maxp < p)\n\
    \            maxp = p;\n    }\n    return maxp;\n}", "{\n    long limit = (long)(sqrt(n));\n\
    \    long factor = 2L;\n    while (limit <= n) {\n        // assert(n % factor\
    \ == 0);\n        if (n % factor == 0) {\n            limit += factor;\n     \
    \   }\n        else {\n            limit += factor;\n            factor++;\n \
    \       }\n    }\n    return factor;\n}", "{\n    long res = 2L;\n    std.conv.longtoint.rename(\"\
    int\", \"x\");\n    std.conv.longtoint.rename(\"long\", \"y\");\n    while(n !=\
    \ 0) {\n        long d = longdiv(n, res);\n        if(d == res) res = d+1;\n \
    \       n /= d;\n    }\n    return res;\n}", "{\n\tlong res = 2;\n\tlong i = 2;",
  "{\n    long p = 2L;\n    while ((n % p) == 0)\n    {\n        p = p * 3L + 1L;\n\
    \    }\n    while ((n % p) != 0)\n    {\n        p = p * 2L + 1;\n    }\n    return\
    \ p;\n}", "{\n    long limit = 1;\n    long result = 0;\n    while (n > limit)\
    \ {\n        if (n % limit == 0) {\n            result ++;\n            while\
    \ (n % result == 0) {\n                result ++;\n            }\n        }\n\
    \        limit ++;\n    }\n    return result + 1;\n}", "{\n    long p = 2;\n \
    \   long q = floor(sqrt(n));\n    long factor = 0;\n    while(p <= q)\n    {\n\
    \        if(n%p == 0) \n        {\n            factor = p;\n            break;\n\
    \        }\n        p ++;\n    }\n    return factor;\n}\n</code>\n<|/ a tags=c++,algorithm,primes\
    \ dscore=3 |>\n<| a tags=c++,algorithm,primes dscore=2 |>\n<code>\n#include <iostream>\n\
    using namespace std;\n#define MAX 10000000000", "{\n    long p, i, j, factor =\
    \ 1;", "{\n\tlong long p = n;\n\tlong long a = 1;\n\tlong long b = 2;\n\twhile\
    \ ( p < n )\n\t{\n\t\twhile ( p%b == 0 )\n\t\t{\n\t\t\tp*=b;\n\t\t}\n\t\tif (\
    \ a % p == 0 )\n\t\t{\n\t\t\ta = b;\n\t\t\tp+=1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\
    \tb += 2;\n\t\t}\n\t}\n\treturn p;\n}\n'''", "{\n    if (n == 1) return 1;\n \
    \   long pmax = n;\n    long s = 2;\n    long r = 3;\n    long dp = 1;\n    while\
    \ (r * r > n)\n    {\n        // cout << \"r \" << r << endl;\n        // cout\
    \ << \"pmax \" << pmax << endl;\n        if ((dp * pmax) % r != 0)\n        {\n\
    \            r++;\n            // cout << \"r \" << r << endl;\n        }\n  \
    \      else\n        {\n            dp++;\n            // cout << \"dp \" << dp\
    \ << endl;\n        }\n    }\n    // cout << \"pmax \" << pmax << endl;\n    while\
    \ (r > 1)\n    {\n        if ((dp * pmax) % r != 0)\n        {\n            //\
    \ cout << \"r \" << r << endl;\n            r--;\n        }\n        else\n  \
    \      {\n            dp++;\n        }\n    }\n    return dp;\n}", "{\n    //\
    \ TODO: implement this by incorporating Miller-Rabin\n    long result = 1;\n \
    \   for (long i = 3; i <= n; i+= 2) {\n        while (i%2 == 0) {\n          \
    \  result *= 2;\n            i /= 2;\n        }\n        while (i%3 == 0) {\n\
    \            result *= 3;\n            i /= 3;\n        }\n        while (i%5\
    \ == 0) {\n            result *= 5;\n            i /= 5;\n        }\n    }\n \
    \   return result;\n}", "{\n\treturn 1;\n\t/*\n\t\t1) If n < 5, then return 1.\n\
    \t\t2) If n < 13, then return 2.\n\t\t3) If n < 17, return 3.\n\t\t4) If n < 19,\
    \ return 4.\n\t\t5) If n < 22, return 5.\n\t\t6) If n < 31, return 6.\n\t\t7)\
    \ If n < 53, return 7.\n\t\t8) If n < 106, return 8.\n\t\t9) If n < 137, return\
    \ 9.\n\t\t10) If n < 217, return 10.\n\t\t11) If n < 341, return 11.\n\t\t12)\
    \ If n < 1700, return 12.\n\t\t13) If n < 4704, return 13.\n\t\t14) If n < 28647,\
    \ return 14.\n\t\t15) If n < 39297, return 15.\n\t\t16) If n < 41863, return 16.\n\
    \t\t17) If n < 41863, return 17.\n\t\t18) If n < 41863, return 18.\n\t\t19) If\
    \ n < 41863, return 19.\n\t\t20) If n < 41863, return 20.\n\t\t21) If n < 41863,\
    \ return 21.\n\t\t22) If n < 41863, return 22.\n\t\t23) If n < 41863, return 23.\n\
    \t\t24) If n < 41863, return 24.\n\t\t25) If n < 41863, return 25.\n\t\t26) If\
    \ n < 41863, return 26.\n\t\t27) If n < 41863, return 27.\n\t\t28) If n < 41863,\
    \ return 28.\n\t\t29) If n < 41863, return 29.\n\t\t30) If n < 41863, return 30.\n\
    \t\t31) If n < 41863, return 31.\n\t\t32) If n < 41863, return 32.\n\t\t33) If\
    \ n < 41863, return 33.\n\t\t34) If n < 41863, return 34.\n\t\t35) If n < 41863,\
    \ return 35.\n\t\t36) If n < 41863, return 36.\n\t\t37) If n < 41863, return 37.\n\
    \t\t38) If n < 41863, return 38.\n\t\t39) If n < 41863, return 39.\n\t\t40) If\
    \ n < 41863, return 40.\n\t\t41) If n < 41863, return 41.\n\t\t42) If n < 41863,\
    \ return 42.\n\t\t43) If n < 41863, return 43.\n\t\t44) If n < 41863, return 44.\n\
    \t\t45) If n < 41863, return 45.\n\t\t46) If n < 41863, return 46.\n\t\t47) If\
    \ n < 41863, return 47.\n\t\t48) If n < 4", "{\n    long p = 1;\n    for(int i\
    \ = 3; i <= n; i += 2)\n    {\n        while(n % i == 0)\n        {\n        \
    \    p += i;\n            n /= i;\n        }\n    }\n    return p;\n}", "{\n \
    \   int max_factor = 0;\n    for (int i = 2; i <= n; i ++)\n    {\n        if\
    \ (n % i == 0)\n        {\n            // i divides n and is a factor\n      \
    \      // it may or may not be larger than max_factor\n            max_factor\
    \ = i;\n        }\n    }\n    return max_factor;\n}\n</cell>\n<cell>\nimport std.algorithm;\
    \ // pow\nimport std.stdio; // writeln", "{\n    \n    long result = n;\n    long\
    \ primes = 1;\n    \n    while (n > 2)\n    {\n        if (n % 2 == 0)\n     \
    \   {\n            primes = 2;\n        }\n        else\n        {\n         \
    \   for (int i = 0; i < primes; ++i)\n            {\n                long div\
    \ = n / i;\n                if (div != 0)\n                {\n               \
    \     if (div < result)\n                    {\n                        result\
    \ = div;\n                    }\n                }\n            }\n          \
    \  primes++;\n        }\n        n = n / 2;\n    }\n    \n    if (primes == 2)\n\
    \    {\n        result = 1;\n    }\n    \n    return result;\n}", "{\n    long\
    \ i, p = n;\n    long maxp = 1;\n    while (p*p > n) {\n        long q = p*p /\
    \ n;\n        if (q > maxp) maxp = q;\n        p /= n;\n    }\n    return maxp;\n\
    }", "{\n  int i;\n  int largest = 2;\n  for (i = 3; i <= n / i; i++) {\n    while\
    \ (n % i == 0) {\n      if (largest == i) {\n        return i;\n      }\n    \
    \  largest = i;\n    }\n  }\n  return largest;\n}", "{\n    long i, factor=1;\n\
    \    while (n > 1) {\n        if ((n % factor) == 0) \n            n /= factor;\n\
    \        else\n            factor++;\n    }\n    return factor;\n}", "{\n\tlong\
    \ d = 2L;\n\tlong p = 2L;\n\tlong q = n;\n\tlong r = n;\n\t\n\twhile (r != 1L)\n\
    \t{\n\t\twhile (r != 2L) {\n\t\t\tif (std.math.next_odd(q)) p++; \n\t\t\telse\
    \ break;\n\t\t\tr = q;\n\t\t\tq = std.math.next_odd(q);\n\t\t}\n\t\tif (std.math.next_odd(q))\
    \ q++; \n\t\telse break;\n\t\tr = q;\n\t\tq = std.math.next_odd(q);\n\t}\n\twhile\
    \ (r != 1L) {\n\t\tif (std.math.next_odd(p)) d++;\n\t\telse break;\n\t\tr = p;\n\
    \t\tp = std.math.next_odd(p);\n\t}\n\treturn d;\n}", "{\n    long max = 2;\n \
    \   long i;\n    for(i = 3; i <= n/2; i++){\n        if (std.intdiv(n, i) == 1)\n\
    \            max = i;\n    }\n    return max;\n}", "{\n\t// First look for trivial\
    \ cases (n = 2 *)\n\tif (n==2) return 2;\n\tif (n%2==0) return 2;\n\tif (n%3==0)\
    \ return 3;\n\tif (n%5==0) return 5;\n\tif (n%7==0) return 7;\n\tif (n%11==0)\
    \ return 11;\n\tif (n%13==0) return 13;\n\tif (n%17==0) return 17;", "{\n    int\
    \ i=0,factor=0,divisor=2;", "{\n\tlong result = 0;\n\tlong m = n;\n\twhile (m\
    \ != 1)\n\t{\n\t\tlong i = 1;\n\t\twhile (i <= m / i) {\n\t\t\tif (n % i == 0)\
    \ {\n\t\t\t\tresult = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tm =\
    \ m / result;\n\t}\n\treturn result;\n}", "{\n    long p;\n    long s = 1;\n \
    \   long r = n;\n    long d;\n    std.typecons.assert(n > 1);\n    while (!(r\
    \ % p)) {\n        p = r;\n        d =  (r*r) / p;\n        while (!(r % p) &&\
    \ r < p)\n            r += d;\n        if (r < p) \n            s += r;\n    }\n\
    \    return s;\n}", "{\n    /*\n    Algorithm from Hakan - 'The Art of Computer\
    \ Programming'\n    Algorithm 2.1.10 - 'Factorizing numbers'\n    */\n    if (n\
    \ <= 1) {\n        return 1;\n    }\n    \n    long a = 2; \n    long b = 2; \n\
    \    long c = n; \n    long d = 0;\n    \n    while (c != 1) {\n        if (c\
    \ % a == 0) {\n            d = 0;\n            break;\n        }\n        if (c\
    \ % b == 0) {\n            d = 1;\n            break;\n        }\n        \n \
    \       int t = a; \n        a = b;\n        b = t;\n    }\n    \n    if (d !=\
    \ 0) {\n        return b;\n    } else {\n        return a;\n    }\n}\n</code>\n\
    <|/ a tags=haskell,integer-overflow,ghc,math,algorithm dscore=4 |>\n<| a tags=haskell,integer-overflow,ghc,math,algorithm\
    \ |>\nThis problem can be solved in polynomial time using the Extended Euclidean\
    \ algorithm (which reduces the problem to a linear one). Here's some pseudocode\
    \ for the Extended Euclidean algorithm:\n<code>", "{\n    long p;\n    long d\
    \ = 1L;\n    while ((n % p) == 0)\n    {\n        p = p * d % n;\n        d++;\n\
    \    }\n    return (p == 1) ? n : p;\n}\n</code>\n<|/ a tags=python,primes |>\n\
    <| a tags=python,primes |>\n<code>\ndef prime_factors(n):\n    if n == 1:\n  \
    \      return [1]\n    if n < 2:\n        return []\n    factors = []\n    for\
    \ i in range(2, n):\n        if n % i == 0:\n            factors.append(i)\n \
    \           factors += prime_factors(n / i)\n    return factors\n</code>\n<|/\
    \ a dscore=4 |>\n<| c |>\nIt's interesting that you go through the same trouble\
    \ as OP; you basically go from 2 to n and divide them out one by one until you\
    \ get to the number 1. While this works, it's not particularly efficient since\
    \ it requires a division in every iteration. Also, you don't handle negative numbers,\
    \ and if the number happens to be larger than the biggest prime factor that can\
    \ occur, then it breaks down. There are probably more bugs and things to fix than\
    \ this.\n<|/ c |>\n<| c |>\nIn fact, your version doesn't even work for larger\
    \ numbers, as `n / i` will result in `inf` for any negative or positive `i`.\n\
    <|/ c |>\n<| c |>\nThe algorithm doesn't require division at all. Just one multiplication.\n\
    <|/ c |>\n<| c |>\nThis answer is the only one that handles negative numbers correctly.\
    \ This is a nice recursive approach that doesn't require any extra storage. I\
    \ didn't write it myself, just a copy and paste.\n<|/ c |>\n<| a tags=python,primes\
    \ |>\nTo find whether a number is a prime number, we can use Sieve of Eratosthenes.\n\
    <code>\ndef prime_check(num):\n  import math\n  prime = [False for i in range(num+1)]\n\
    \  prime[0] = True\n  limit = int(math.sqrt(num)+1)\n  for i in range(2,limit):\n\
    \    if (prime[i] == True):\n      for x in range(2,i*i,2):\n        prime[x]\
    \ = False\n  return prime[0]\n</code>\n<|/ a dscore=4 |>\n<| c |>\nIf you want\
    \ `prime` to store all prime numbers up to a given number `n`, you can change\
    \ `range(2,i*i,2)` to `range(2,i+1,2)`, to match the range of numbers in the question.\
    \ Also, `prime[x] = False` can be replaced with `del prime[x]`.\n<|/ c |>\n<|\
    \ a dscore=4 |>\nThe efficient Sieve of Eratosthenes is ", "{\n    long primes[]\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23};\n    int i;", "{\n    if(n == 0) return\
    \ 0L;\n    long max = (long)sqrt(n);\n    long x = 3;\n    long y = 2;\n    for(;;)\n\
    \    {\n        if(x%y == 0)\n        {\n            y *= max;\n            while(x\
    \ % y == 0)\n            {\n                y *= max;\n            }\n       \
    \ }\n        else \n        {\n            if(x == n) \n            {\n      \
    \          return y;\n            }\n            y /= max;\n        }\n      \
    \  x /= max;\n    }\n}", "{\n\tlong p = 1;\n\tlong q = 2;\n\tlong r = n;\n\twhile\
    \ (!is_prime(r))\n\t{\n\t\tif (r > p)\n\t\t{\n\t\t\tlong q = r - p;\n\t\t\twhile\
    \ (!is_prime(q))\n\t\t\t{\n\t\t\t\tif (q > p)\n\t\t\t\t{\n\t\t\t\t\tr = q + p;\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tq ++;\n\t\t\t}\n\t\t\tp = q;\n\t\t}\n\t\t\
    r = r;\n\t}\n\treturn p;\n}", "{\n    long limit = sqrt(n);\n    long a = 1;\n\
    \    for(long i = 2; i <= limit; ++i){\n        if((n % i) == 0) {\n         \
    \   a = i;\n            while(n > 1) {\n                if(n % a == 0) {\n   \
    \                 n /= a;\n                } else {\n                    break;\n\
    \                }\n            }\n            break;\n        }\n    }\n    return\
    \ a;\n}\n/*\nReturn the smallest prime factor of n. Assume n > 1 and is not a\
    \ prime.\n    >>> smallest_prime_factor(13195L)\n    3L\n    >>> smallest_prime_factor(2048L)\n\
    \    8L\n    \n*/\nlong smallest_prime_factor(long n) \n{\n    long limit = sqrt(n);\n\
    \    long a = 1;\n    for(long i = 2; i <= limit; ++i){\n        if((n % i) ==\
    \ 0) {\n            a = i;\n            while(n > 1) {\n                if(n %\
    \ a == 0) {\n                    n /= a;\n                } else {\n         \
    \           break;\n                }\n            }\n            break;\n   \
    \     }\n    }\n    return a;\n}\n/*\nReturn the sum of n and n-1. Assume n >\
    \ 0.\n    >>> prime_sum(4L)\n    8L\n    >>> prime_sum(11L)\n    21L\n    \n*/\n\
    long prime_sum(long n) \n{\n    long sum = (n+1);\n    for(long i = 2; i <= sqrt(n);\
    \ ++i) {\n        if(n % i == 0) {\n            sum /= i;\n        }\n    }\n\
    \    return sum;\n}", "{\n  long p = 2;\n  while(n>1) {\n    if(n%p==0) n = (n/p)*p;\n\
    \    else p = p*2+1;\n  }\n  return (p==2 ? n : n);\n}\n/*\nimport std.range;\n\
    import std.stdio;\nimport std.string;\nimport std.math;\nimport std.traits;\n\
    import std.algorithm;", "{\n    \n    /* Start with 2, since 2 has 1 factor */\n\
    \    long prime = 2;\n    long factor = 2;\n    long maxPrime = 2;\n    \n   \
    \ while (factor < n) {\n        while ((n % prime) == 0) {\n            n = n\
    \ / prime;\n            prime++;\n        }\n        factor++;\n    }", "{\n\t\
    long largestFactor = n;\n\tlong p2 = largest_prime_factor2(n);\n\twhile(p2 < n)\n\
    \t{\n\t\tlargestFactor = p2;\n\t\tp2 = largest_prime_factor2(p2);\n\t}\n\treturn\
    \ largestFactor;\n}\nlong largest_prime_factor2(long n) \n{\n\tif (n == 2)\n\t\
    {\n\t\treturn 2;\n\t}\n\telse\n\t{\n\t\tlong x = sqrt(n);\n\t\twhile (x > 1)\n\
    \t\t{\n\t\t\tlong y = n % x;\n\t\t\tif (y == 0 || y % 3 == 0)\n\t\t\t\treturn\
    \ x;\n\t\t\tx = x / 2;\n\t\t}\n\t\treturn 2;\n\t}\n}\n/*\nReturn the number of\
    \ prime factors of n. Assume n > 1.\n    >>> number_of_prime_factors(9)\n    2\n\
    \    >>> number_of_prime_factors(25)\n    3\n    \n*/\nlong number_of_prime_factors(long\
    \ n) \n{\n\tlong p = 1;\n\tlong n = largest_prime_factor(n);\n\twhile (p < n)\n\
    \t{\n\t\tp = p + 1;\n\t\tif (n % p == 0)\n\t\t\treturn p;\n\t\tn = largest_prime_factor2(n);\n\
    \t}\n\treturn p;\n}\n/*\nReturn the greatest common denominator of the numbers\
    \ n and m.\n    >>> greatest_common_denominator(13, 17)\n    11\n    >>> greatest_common_denominator(3,\
    \ 4)\n    3\n    \n*/\nlong greatest_common_denominator(long n, long m) \n{\n\t\
    long lcm = 1;\n\twhile (n != 0)\n\t{\n\t\tlcm = lcm % n;\n\t\tn = m % n;\n\t\t\
    m = lcm;\n\t}\n\treturn lcm;\n}\n/*\nReturn the smallest number k such that 2^k\
    \ % m == 1.\n    >>> smallest_prime_power_of_two(13, 17)\n    17\n    \n*/\nlong\
    \ smallest_prime_power_of_two(long n, long m) \n{\n\tlong p = 1;\n\tlong r = m;\n\
    \twhile (p < r) \n\t{\n\t\tif (p % 4 == 0 && p % 64 == 0)\n\t\t\treturn p; \n\t\
    \tp = p + 1;\n\t\tr = m;\n\t\twhile (p % 2 == 0)\n\t\t{\n\t\t\tr = r / 2;\n\t\t\
    \tp = p * 2;\n\t\t}\n\t}\n\treturn p; \n}\n/*\nReturn the value of the decimal\
    \ at position i of a string. Assume \n    that s is a string.\n    >>> decimal('3.141592653589793',\
    \ '1', 3)\n    2.718281828459045\n    \n*/\ndouble decimal(const char* s, char ",
  "{\n  int j;\n  long largest_factor = 1;\n  long i = 3;\n  long d;\n  while(i <\
    \ n){\n    d = i;\n    while(d % 2 == 0){\n      d /= 2;\n    }\n    if(d > largest_factor)\n\
    \      largest_factor = d;\n    i++;\n  }\n  if(largest_factor > 2)\n    return\
    \ largest_factor;\n  else\n    return 0;\n}", "{\n  long p = 2; \n  long max_p\
    \ = 1;\n  long tmp;\n  \n  while (p * p <= n) \n  {\n    tmp = p / p;\n    if\
    \ (tmp * tmp > n) break;\n    max_p = tmp;\n    p = p + 1;\n  }\n  return max_p;\n\
    }\n</code>\n<|/ a tags=c++,c++11 |>\n<| a tags=c++,c++11 dscore=4 |>\nJust for\
    \ the reference:\n<code>\n#include <iostream>\n#include <algorithm>\n#include\
    \ <string>", "{\n    long limit = n;\n    int i, j, k;", "{\n\tlong i = 1;\n\t\
    long largest = n-1;\n\twhile(true) {\n\t\twhile(n % i == 0) {\n\t\t\tn /= i;\n\
    \t\t\t++i;\n\t\t}\n\t\tif (n==1) { \n\t\t\treturn i;\n\t\t}\n\t\t++i;\n\t\tlargest\
    \ = i;\n\t}\n}\n// end function", "{\n\tif (n == 1)\n\t\treturn n;\n\tif (n %\
    \ 2 == 0)\n\t\treturn 2*largest_prime_factor(n / 2);\n\tif (n % 3 == 0)\n\t\t\
    return 3*largest_prime_factor(n / 3);\n\tif (n % 5 == 0)\n\t\treturn 5*largest_prime_factor(n\
    \ / 5);\n\treturn n; // it's a prime\n}", "{\n\tlong l=0;\n\tlong max_div=long::divide(n,2);\n\
    \twhile(n>=2)\n\t{\n\t\tif(n%2==0)\n\t\t{\n\t\t\tif(max_div%2==0)\n\t\t\t{\n\t\
    \t\t\tl=2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmax_div=long::divide(n,2);\n\t\t}\n\
    \t\telse\n\t\t{\n\t\t\tif(n%3==0)\n\t\t\t{\n\t\t\t\tl=3;\n\t\t\t\tbreak;\n\t\t\
    \t}\n\t\t\tmax_div=long::divide(n,3);\n\t\t}\n\t}\n\treturn l;\n}\n/*\nReturn\
    \ the smallest prime factor of n. Assume n > 1 and is not a prime.\n    >>> smallest_prime_factor(13195L)\n\
    \    21L\n    >>> smallest_prime_factor(2048L)\n    3L\n    \n*/\nlong smallest_prime_factor(long\
    \ n) \n{\n\tlong l=0;\n\tlong min_div=long::divide(n,2);\n\twhile(n>=2)\n\t{\n\
    \t\tif(n%2==0)\n\t\t{\n\t\t\tif(min_div%2==0)\n\t\t\t{\n\t\t\t\tl=2;\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t\tmin_div=long::divide(n,2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\
    \tif(n%3==0)\n\t\t\t{\n\t\t\t\tl=3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmin_div=long::divide(n,3);\n\
    \t\t}\n\t}\n\treturn l;\n}", "{\n    long p = 2;\n    long q = ceil(sqrt(n));\n\
    \    while (p <= q)\n    {\n        while ((n % p) == 0)\n            p++;\n \
    \       while ((n % p) != 0)\n            p++;\n        if (p > q)\n         \
    \   return (p);\n        n = n / p;\n    }\n    return (n);\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nIt is not necessary to use `sqrt` to get the square root of a number,\
    \ because the [`sqrt`](http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)\
    \ function has [a specialization that doesn't require the square root of a number](http://stackoverflow.com/a/12675775/832230)\n\
    <|/ c |>\n<| c |>\n: You're right that `sqrt` doesn't need the square root. However,\
    \ the [definition of `sqrt`](http://stackoverflow.com/a/12675775/832230) requires\
    \ that it be an approximation. On my machine (Linux x86-64), `sqrt` actually uses\
    \ a 64-bit approximation to a 32-bit `sqrt`, so there's no difference between\
    \ using `sqrt` or `sqrt64`.\n<|/ c |>\n<| c |>\n: Actually, [it does have to be\
    \ an approximation](http://stackoverflow.com/q/12675381/832230), though it does\
    \ so in a way that isn't necessarily worse than 64-bit rounding. For example,\
    \ on my 64-bit machine, `sqrt` is approximated with 16-bit rounding, whereas `sqrt64`\
    \ is approximated with 32-bit rounding.\n<|/ c |>\n<| c |>\n: That is certainly\
    \ a valid point. My point is that it is *more* likely to use an approximation\
    \ than to use 64-bit rounding. In the vast majority of situations, that would\
    \ mean that `sqrt` would be a better choice than `sqrt64` because it would use\
    \ a 32-bit approximation.\n<|/ c |>\n<| c |>\n: Sure - that's why I said \"a better\
    \ choice\". On my machine `sqrt` uses 64-bit approximation because it's faster\
    \ than 32-bit approximation (see my link above). That said, if you're worried\
    \ about performance (and it probably doesn't matter), then you can always use\
    \ `sqrt64`. Or just use a different definition of \"better\".\n<|/ c |>\n<| a\
    \ dscore=3 tags=c++,math |>\nHere's a variant which only uses square roots up\
    \ to the square root of the number to factorize:\n<code>", "{\n    int j = 0;\n\
    \    long k = 2;\n    long result = 0; //the result will be a long\n    while\
    \ (true) {\n        if (n % k == 0) {\n            j++;\n            while (n\
    \ % k == 0) {\n                j++;\n                k += 2;\n            }\n\
    \            if (j > result) {\n                result = k;\n            }\n \
    \       }\n        k += 2;\n        if (k > n) {\n            return result;\n\
    \        }\n    }\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=python,primes |>\n\
    Here is another approach:\n<code>\nfrom operator import sub\nfrom itertools import\
    \ count", "{\n    long p = 2;\n    while (true)\n    {\n        if ((n % p) ==\
    \ 0) \n        {\n            return p;\n        }\n        p++;\n        if (p\
    \ * p > n) \n        {\n            return n;\n        }\n    }\n}\n</code>\n\
    <|/ a dscore=1 tags=math,c# |>\n<| c |>\n`largest_prime_factor(10000L)` returns\
    \ `2L` which is an error.\n<|/ c |>\n<| c |>\nI didn't understand your question\n\
    <|/ c |>\n<| c |>\nI understood your question but you had a bug, that is why I\
    \ pointed it out as you did.  You fixed your bug and this isn't a great answer.\n\
    <|/ c |>\n<| c |>\nI don't think this algorithm works in the general case. I tried\
    \ it with n = 10000 and it gave me the wrong answer of 4396. I'm still working\
    \ on it.\n<|/ c |>\n<| c |>\n`largest_prime_factor(10000L)` returns `4L` which\
    \ is correct and I believe that is the answer you were looking for. As to why\
    \ you were downvoted I think there are many things to improve upon this code.\n\
    <|/ c |>\n<| a tags=math,c# |>\nI'm going to assume that n is a long.\n<code>\n\
    long primeFactor(long n)\n{\n    if (n%2 == 0) return 2;\n    long maxDivisor\
    \ = 3;\n    for(long i = 5; i<n; i+=2)\n    {\n        long divisible = n/i;\n\
    \        if (divisible > maxDivisor)\n        {\n            maxDivisor = divisible;\n\
    \        }\n    }\n    return maxDivisor;\n}\n</code>\nThis will loop through\
    \ the first 6 numbers from 5 to n, checking to see if the remainder is greater\
    \ than the greatest factor of the number, and if it is, changing that factor to\
    \ the greatest factor of the number.\n<|/ a dscore=1 |>\n<| c |>\nThis algorithm\
    \ works, but it does so by dividing by every integer between 5 and n. That's not\
    \ what the OP wanted; he wanted the largest prime factor, not the largest factor\
    \ of the number.\n<|/ c |>\n<| c |>\nYes I apologize, I did not read this properly,\
    \ but this algorithm was what I understood to be what the OP was asking for. \
    \ It could definitely be optimized a bit, but it would be a good starting point\
    \ for anyone else trying to understand this question.\n<|/ c |>\n<| a |>\nIn Python\
    \ you can ", "{\n    long x = n;\n    long y = 1;\n    while (y <= x) {\n    \
    \    long z = (x * x) % y;\n        if (z != 0) {\n            x = y;\n      \
    \      y = z;\n        }\n        x++;\n    }\n    return x;\n}", "{\n    int\
    \ counter;\n    long max_val;\n    long max_factor;\n    \n    for(counter = 2;\
    \ counter <= n; counter++) \n    {\n        if(n%counter == 0) \n        {\n \
    \           break;\n        }\n    }\n    max_val = counter;\n    max_factor =\
    \ 1;\n    \n    for(counter = counter + 1; counter <= n; counter++) \n    {\n\
    \        if(n % counter == 0) \n        {\n            if(max_factor < counter)\
    \ \n            {\n                max_factor = counter;\n            }\n    \
    \        \n            max_val = max(max_val,counter);\n        }\n    }\n   \
    \ \n    return max_factor;\n}", "{\n\tlong p, s, r, i;\n\tint count = 1;\n\t\n\
    \t/* start from square root of n to increase speed */\n\tlong root = sqrt(n);\n\
    \t\n\t/* increment until n has found a prime factor */\n\tfor (p = 2; p < root;\
    \ p++) {\n\t\t\n\t\t/* if n is not prime then we can skip this test */\n\t\tif\
    \ (!std.math.isPrime(p)) {\n\t\t\t\n\t\t\t/* check whether n is divisible by p\
    \ */\n\t\t\ts = std.math.gcd(n, p);\n\t\t\tif (s == 0) {\n\t\t\t\treturn p;\n\t\
    \t\t}\n\t\t}\n\t\t\n\t\t/* if n is prime then divide it to p, \n\t\t * increment\
    \ count and start again */\n\t\tr = std.math.gcd(n, p);\n\t\t\n\t\tcount += r;\n\
    \t\tn = r;\n\t}\n\t\n\treturn count;\n}", "{\n    long maxP;\n    \n    if (n\
    \ > 1) {\n        /* Set maxP = 2 because 2 is the only prime factor. */\n   \
    \     maxP = 2;\n        for (int p = 2; p * p <= n; p++) { \n            while\
    \ ((n % p) == 0) {\n                maxP = p;\n                n /= p;\n     \
    \       }\n        }\n        if (n > 1) {\n            /* Report any factor of\
    \ 2 since no prime factor is of greater \n               significance. */\n  \
    \          maxP = n;\n        }\n    }\n    return maxP;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=algorithm,c |>\nI guess this can be done in O(sqrt(n)) time using\
    \ divide and conquer approach.\nLet S(n) be the number of the largest prime factor\
    \ of n and P(n) be the number of the smallest prime factor of n. Then, P(n) is\
    \ equal to S(n) / 2.\nTo find S(n), you only need to check numbers up to sqrt(n),\
    \ which are less than or equal to S(n). After that, you check all the numbers\
    \ from sqrt(n) to S(n). After that, check every number from S(n) to 2*S(n) and\
    \ so on. \nI guess that is how you can solve this problem in O(sqrt(n)) time.\n\
    <|/ a dscore=1 |>\n<| c |>\nAh yes, I see what you mean. I'll try it out.\n<|/\
    \ c |>\n<| c |>\nThis does not work for large numbers, since the smallest prime\
    \ factor of 2^30 is 2. The naive algorithm would take more than 30 seconds to\
    \ find the largest prime factor of 2^30.\n<|/ c |>\n<| c |>\nI guess you are right.\
    \ I was thinking of a solution where S(n) is calculated using the naive algorithm,\
    \ and then used in P(n) to save time.\n<|/ c |>\n<| c |>\nOh I see. So this works,\
    \ but only for n < 2^30. Thank you for your solution.\n<|/ c |>\n<| a dscore=1\
    \ |>\nA solution in O(sqrt(n)) time using the sieve of Eratosthenes.\nThe algorithm\
    \ works by setting all numbers to \"not prime\" and then testing whether each\
    \ number is divisible by each of the primes up to sqrt(n). It does this by setting\
    \ the primes to \"not prime\" until the number being tested is found not to be\
    \ divisible by any prime less than sqrt(n).\n<code>\n#include <stdio.h>\n#include\
    \ <stdbool.h>", "{\n    long p = 2L;\n    while (!(p%2L)) p = p*2L;\n    while\
    \ (!(p%3L)) p = p*3L;\n    while (!(p%5L)) p = p*5L;\n    while (!(p%7L)) p =\
    \ p*7L;\n    while (!(p%11L)) p = p*11L;\n    while (!(p%13L)) p = p*13L;\n  \
    \  while (!(p%17L)) p = p*17L;\n    while (!(p%19L)) p = p*19L;\n    return p;\n\
    }", "{\n    // Sieve of Eratosthenes\n    long[] sieve = new long[512];\n    bool\
    \ is_prime = true;\n    for (int i = 2; i * i <= n; i++)\n    {\n        if (is_prime)\n\
    \        {\n            for (int k = i*i; k < n; k+=i)\n                sieve[k]\
    \ = false;\n        }", "{\n    /*\n     * OEIS\n    \n    \n    Algorithm C1:\
    \ Limit search to square-root of n\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n", "{\n    long p = 2, d;\n    if (n < 2) return 2;\n    while ((n % p)\
    \ == 0) p = p * 2;\n    d = isqrt(n)/(p-1);\n    return n / d;\n}", "{\n\tlong\
    \ r = 2;\n\tlong p = 1;\n\tlong factor = 2;\n\twhile((p <= n) && n % p == 0)\n\
    \t{\n\t\tp = p * factor;\n\t\tfactor++;\n\t}\n\tif(p == n)\n\t\treturn r;\n\t\
    else\n\t\treturn p;\n}", "{\n\t/* find largest power of 2 >= n */\n\tlong p =\
    \ n;\n\twhile ((p & 1) == 0) { p *= 2; }\n\tlong maxFactor = p;\n\t/* now iterate\
    \ up to sqrt(n) */\n\tlong sqrtn = std.math.sqrt(n);\n\tlong m = 3;\n\twhile (m\
    \ < sqrtn) { \n\t\tm += p;\n\t\tp *= 2L;\n\t\tif (p > maxFactor) {\n\t\t\tmaxFactor\
    \ = p;\n\t\t}\n\t}\n\t/* check for unlikely prime p with p>=sqrt(n) */\n\twhile\
    \ ((p&1) == 0) { p *= 2L; }\n\tif (p >= n) {\n\t\treturn n;\n\t}\n\t/* now we\
    \ can test p */\n\tlong q = 3;\n\tlong r = n;\n\twhile (r > 1) {\n\t\tq *= q;\n\
    \t\tr = (r-r)/2;\n\t}\n\tif (p > maxFactor) {\n\t\treturn n;\n\t}\n\t/* we've\
    \ got an invertible factor p - check if it's prime */\n\twhile (q < n) {\n\t\t\
    int s = (int)std.math.sqrt(q);\n\t\tif (s > 0 && q % s == 0) {\n\t\t\tbreak;\n\
    \t\t}\n\t\tq++;\n\t}\n\t/* if we get here then p was prime, check if it's composite\n\
    \t   by considering the factors 2,3,5,7,11,13,17,19 */\n\twhile (r > 1) {\n\t\t\
    int m = std.math.sqrt(r);\n\t\tint f = m*m*m;\n\t\tif (f > n) {\n\t\t\treturn\
    \ n;\n\t\t}\n\t\tint n = f%m;\n\t\tint n3 = n*3;\n\t\tint n5 = n*n*5*m;\n\t\t\
    if (f <= n3) {\n\t\t\tif (f <= n5) {\n\t\t\t\tif (f+2 <= n5) {\n\t\t\t\t\tif (f+4\
    \ <= n5) {\n\t\t\t\t\t\tif (f+6 <= n5) {\n\t\t\t\t\t\t\tif (f+8 <= n5) {\n\t\t\
    \t\t\t\t\t\tif (f+12 <= n5) {\n\t\t\t\t\t\t\t\t\treturn n+n+n+n+n+n+n+n+n+n+n+n+n+n+n;\n\
    \t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\
    \t}\n\t\t}\n\t\tr = m*r+n;\n\t\tq *= q;\n\t}\n\treturn p;\n}", "{\n    if(n %\
    \ 2 == 0) return 2;\n    \n    for(long c = 2; c <= n/2; c++)\n        if(n %\
    \ c == 0) \n        {\n            if(c == n/2) return n;\n            return\
    \ c;\n        }\n    \n    return n;\n}", "{\n    if (n == 1) {\n        return\
    \ 1;\n    }\n    if (n % 2 == 0) {\n        return 2;\n    }\n    long maxFactor\
    \ = n%(primes[n - 1] + 1);\n    long factor = 2;\n    for (long i = 5L; i <= maxFactor;\
    \ i += 7L) {\n        if (n % i == 0) {\n            if (factor < i) {\n     \
    \           factor = i;\n            }\n        }\n    }\n    return factor;\n\
    }\n</code>\n<|/ a tags=algorithm,java |>\n<| c |>\nWhile this code snippet may\
    \ solve the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a dscore=0 tags=algorithm,java |>\n<code>\nimport\
    \ java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport\
    \ java.util.concurrent.atomic.AtomicInteger;", "{\n  long p = n;\n  int k = 2;\n\
    \  while (p % k == 0)\n    {\n      p = p / k;\n      k++;\n    }\n  return p;\n\
    }", "{\n\tstd.typecons.List primes = std.typecons.List.new();\n\t\n\tfor (long\
    \ i = 2; i <= std.math.sqr(n); i++) {\n\t\tbool prime = true;\n\t\tfor (long j\
    \ = i; j < std.math.sqr(n); j++) {\n\t\t\tif (n % j == 0) {\n\t\t\t\tprime = false;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (prime)\n\t\t\tprimes.add(std.typecons.Long.fromLong(i));\n\
    \t}\n\t\n\tstd.typecons.Long maxFactor = primes.last.first;\n\tlong factor = 1;\n\
    \tfor (long i = 2; i <= std.math.sqr(n); i++) {\n\t\tbool prime = true;\n\t\t\
    for (long j = i; j < std.math.sqr(n); j++) {\n\t\t\tif (n % j == 0) {\n\t\t\t\t\
    prime = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (prime) {\n\t\t\tif (factor\
    \ > maxFactor.first)\n\t\t\t\tmaxFactor = std.typecons.Long.fromLong(i);\n\t\t\
    \tfactor = i;\n\t\t}\n\t}\n\t\n\treturn maxFactor;\n}", "{\n    long p;\n    long\
    \ f = 3L;\n    int i=2;", "{\n    // Assume n >= 2 and n != 2\n    \n    // Find\
    \ the largest factor of n.\n    long factor = n % 2 == 0 ? 2 : 3;\n    \n    //\
    \ Check if n is evenly divisible by any factor of 2 and 3\n    while (n%factor\
    \ == 0 && factor*factor <= n)\n    {\n        factor = factor * factor;\n    }\n\
    \    \n    // Check all possible factors of n to see if they are prime\n    for\
    \ (long i = 3; i <= n/factor; i++)\n    {\n        // n%i == 0 for all i, so we\
    \ can replace n by n/i each iteration\n        if (n%i == 0)\n        {\n    \
    \        return i;\n        }\n    }\n    \n    // No factor of n can be found,\
    \ so n is not prime\n    return 0;\n}\n</code>\n<|/ a tags=c++,math,algorithm,java,c\
    \ |>\n<| a |>\nI understand that this is an older post, but the OP doesn't have\
    \ a specific programming question on their post, so I will add my two cents.\n\
    In terms of efficiency, the original code as written is O(n ^ 2). Since it is\
    \ iterating over every possible divisor, the time complexity is O(n^2) which is\
    \ far worse than the other answers. To improve this, consider using prime factorization\
    \ of numbers. In particular, prime factorization is O(log n) and the OP had a\
    \ similar O(n^2) function as their original one. \n<code>\n#include <iostream>\n\
    #include <vector>\nusing namespace std;\nusing namespace math;", "{\n  int i =\
    \ 2;\n  while (i <= n/i)\n  {\n    if (n%i == 0)\n      return i;\n    i++;\n\
    \  }\n  return n;\n}", "{\n    long p;\n    long d;\n    long sqr = n%2;\n   \
    \ while( sqr == 0 ) {\n        n = sqr + 1;\n        sqr = n%2;\n    }\n    for(p\
    \ = sqrt(n); p>2; p--) {\n        d = n%p;\n        if( d == 0 ) {\n         \
    \   return p;\n        }\n        n = d;\n    }\n    return n;\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=2 |>\nIf you're looking for a purely functional approach using\
    \ FP, I'd recommend using Haskell's list-comprehension.\n<code>\nlargestPrimeFactors\
    \ n\n    | n <= 2 = [1]\n    | otherwise = [x | x <- [2..n], n `mod` x == 0]\n\
    </code>\n<|/ a tags=optimization,haskell,primes,algorithm |>\n<| c |>\nYou have\
    \ to change `mod` to `rem` if you want to do it that way (I believe, from Haskell\
    \ Report, p. 334). Also I think you mean `2` to be the only factor in the list.\n\
    <|/ c |>\n<| c |>\n`rem` is the same as `mod`, but with a different sign, `rem`\
    \ returns the remainder of a division operation and `mod` returns the modulus.\n\
    <|/ c |>\n<| a dscore=2 |>\nThe first thing to do is determine which of the factors\
    \ would make up the largest factor.  Let's say it's 5.  Now you can work out the\
    \ largest number that is a multiple of 5 (including it), which is 250.  You then\
    \ need to work out which of 25 numbers (25, 50, 100, 200, 500, 1000, and 1500)\
    \ would make up 250.  So you work out the largest * largest.\nThis can be done\
    \ in O(log n) by building a list of all the numbers from 2 to sqrt(n)-1, skipping\
    \ multiples of those numbers, until you find the one that isn't a multiple of\
    \ 5.\n<|/ a tags=optimization,haskell,primes,algorithm |>\n<| a dscore=2 tags=optimization,haskell,primes,algorithm\
    \ |>\nYou could use Data.Prime:\n<code>\nimport Data.List\nimport Data.Int", "{\n\
    \    // Find the largest prime factor\n    long a = 1;\n    while (n % a == 0)\
    \ {\n        a = next_prime(a);\n    }\n    return a;\n}\nlong next_prime(long\
    \ a)\n{\n    long b; \n    int i = 0;\n    // Look for next prime in range\n \
    \   for(b=a;b<MAX_INT;b+=2)\n    {\n        if(b == 1)\n            ++i;\n   \
    \     if(!(i%b))\n            break;\n    }\n    // If we did not find one, return\
    \ MAX_INT\n    if(i==0)\n        return MAX_INT;\n    else\n        return b;\n\
    }\n// End of largest_prime_factor\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\n\
    public long largestPrimeFactor(long number) {\n    long highest = 1;\n    long\
    \ smallest = 2;\n    for (int i = 3; i <= number; i++) {\n        int count =\
    \ 1;\n        while (count < i) {\n            if (number % i == 0) {\n      \
    \          count++;\n                break;\n            }\n        }\n      \
    \  if (count > i) {\n            smallest = i;\n            highest = count;\n\
    \        }\n    }\n    return highest;\n}\n</code>\n<|/ a tags=java,math,algorithm\
    \ dscore=0 |>\n<| a tags=java,math,algorithm |>\n<code>\npublic class Practice\
    \ {\n    public static void main(String[] args) {\n        int n = Integer.parseInt(args[0]);\n\
    \        int a = 2, b = 2;\n        while( a <= n / 2 )\n        {\n         \
    \   while( n % a == 0 && b < n / a )\n            {\n                b = b * a\
    \ + 1;\n            }\n            System.out.println( a );\n            a = a\
    \ + 2;\n        }\n    }\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=java,math,algorithm\
    \ |>\n<code>\npublic class LargestPrimeFactor {", "{\n  long nfactor = 1;\n  while(n\
    \ > 1) {\n    if (n % 2 == 0) {\n      nfactor = 2;\n      break;\n    }\n   \
    \ n = n / 2;\n    nfactor++;\n  }\n  return nfactor;\n}", "{\n    /*\n    Prime\
    \ factors of 2, 3, 5, 7, 11, and 13 are 1, 2, and 3.  \n    13 is prime because\
    \ it is evenly divisible by all primes <= 15.\n    */\n    long max_factor = 0;\n\
    \    long p;\n    long n = abs(n);", "{\n    long max_factor = 1L;\n    long d\
    \ = 2;\n    long i = 3L;", "{\n\tlong factor = 0;\n\twhile(n > 1)\n\t{\n\t\tif(n\
    \ % 2 == 0) \n\t\t{\n\t\t\tif(factor < 2) \n\t\t\t{\n\t\t\t\tfactor = 2;\n\t\t\
    \t\tn = n / 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tn /= 2;\n\t\t\t\tfactor++;\n\
    \t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif(factor < 3) \n\t\t\t{\n\t\t\t\tfactor\
    \ = 3;\n\t\t\t\tn = n / 3;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tn /= 3;\n\t\t\
    \t\tfactor++;\n\t\t\t}\n\t\t}\n\t}\n\treturn factor;\n}", "{\n    // check for\
    \ overflow \n    if(n >= (long) pow(2, 63)) {\n        throw new Exception(\"\
    Overflow\");\n    }\n    \n    long maxp = 1;\n    long maxn = n;\n    \n    while(true)\
    \ {\n        if(isPrime(maxn)) maxp++;\n        if(maxn <= (long) pow(2, maxp-1))\
    \ {\n            return maxp;\n        }\n        \n        // find the largest\
    \ integer factor\n        long tmpmaxp = (long) pow(2, maxp-2);\n        long\
    \ tmpmaxn = (long) pow(2, maxp-2);\n        \n        while(tmpmaxn > n) {\n \
    \           maxp += 2;\n            tmpmaxp = (long) pow(2, maxp-2);\n       \
    \     tmpmaxn = (long) pow(2, maxp-2);\n        }\n        \n        if(tmpmaxn\
    \ <= n) {\n            throw new Exception(\"Overflow\");\n        }\n       \
    \ \n        // check to see if maxp divides n\n        if(maxp % 2 == 1) {\n \
    \           if(!isPrime(tmpmaxn)) throw new Exception(\"Overflow\");\n       \
    \ }\n        \n        maxn = tmpmaxn;\n    }\n}\n</code>\n<|/ a |>\n<| a |>\n\
    The simplest way would be to generate all the primes up to the number n, then\
    \ iterate through them and keep only those that divide n. Since n is a prime,\
    \ you know that n-1 is also a prime and so on.\n<|/ a dscore=2 tags=primes,math,java,algorithm\
    \ |>\n<| a |>\nJust to add my two cents, I have implemented this in C# using a\
    \ little bit different approach, where I generate prime numbers upto a certain\
    \ number n (as in the OP) and then use a bit of LINQ to find the factors.\n<code>\n\
    private static IEnumerable<int> getFactors(int n)\n{\n    //check for factors\
    \ of 1 and n\n    if (n == 1)\n        yield return 1;\n    if (n == 2)\n    \
    \    yield return 2;\n    if (n % 2 == 0)\n        yield return 2;\n    if (n\
    \ == 3)\n        yield return 3;", "{\n    long result = 1L;\n    for (long i\
    \ = 1L; i <= n / 2L; i++)\n    {\n        if ((n % i) == 0)\n        {\n     \
    \       result += 1L;\n            while (n % i == 0)\n            {\n       \
    \         n /= i;\n                result += 1L;\n            }\n        }\n \
    \   }\n    return result == 1L ? n : result;\n}\n</code>\nThe second method is\
    \ as follows:\n<code>\nimport std.algorithm;\nimport std.conv;\nimport std.num;\n\
    import std.complex;", "{\n\tlong m = n;\n\tlong p = 2;\n\tbool flag = false;\n\
    \tlong res = 0;\n\tint i;\n\tlong d;\n\twhile(!flag) {\n\t\tflag = true;\n\t\t\
    for(i = 2*m; i <= n; i += p)\n\t\t{\n\t\t\td = i - m;\n\t\t\tif(n%i == 0 && i\
    \ != m) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(m > 1\
    \ && flag) {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\tres = i;\n\twhile(n >= res)\n\
    \t{\n\t\tn--;\n\t\tres += p;\n\t}\n\treturn res;\n}", "{\n    long i, p, factor=1;\n\
    \    \n    /* Check n is greater than 2 */\n    if (n < 2)\n        return n;\n\
    \    \n    /* Check for small factors */\n    if (n == 1)\n        return 1;\n\
    \    \n    /* Check for even factors */\n    if (n % 2 == 0) {\n        p = largest_prime_factor(n/2);\n\
    \        if (p == 1)\n            return p;\n        factor *= p;\n    }\n   \
    \ \n    /* Check for odd factors */\n    for (i = 3; i <= n/2; i += 2) {\n   \
    \     if (n % i == 0)\n            break;\n    }\n    \n    /* If n is a prime\
    \ number then return it */\n    if (n != 1 && i % n != 0)\n        return factor;\n\
    \    \n    /* Otherwise, loop until i is a prime number */\n    p = i;\n    while\
    \ (p < n) {\n        if (n % p == 0)\n            break;\n        p++;\n    }\n\
    \    \n    /* If we reach this point, the largest prime factor is p-1 */\n   \
    \ factor = p -1;\n    return factor;\n}", "{\n    long i = 1;\n    bool isPrime;\n\
    \    long max = 2;\n    while (i < n / 2) {\n        isPrime = true;\n       \
    \ for (i = 2; i <= n / i; i++) {\n            if (n % i == 0) {\n            \
    \    isPrime = false;\n                break;\n            }\n        }\n    \
    \    if (isPrime) {\n            max = i;\n        }\n        i += 2;\n    }\n\
    \    return max;\n}", "{\n\tlong i = 2L;\n\twhile (i * i <= n) \n\t{\n\t\tif (n\
    \ % i == 0) \n\t\t{\n\t\t\tif (i / n > n - 1) \n\t\t\t\treturn (n - 1L);\n\t\t\
    \treturn (long) i;\n\t\t}\n\t\ti += 2L;\n\t}\n\treturn (long) n;\n}", "{\n   \
    \ // TODO: write code\n    // TODO: write code\n    // TODO: write code\n    //\
    \ TODO: write code\n    // TODO: write code\n    // TODO: write code\n    // TODO:\
    \ write code\n    // TODO: write code\n    // TODO: write code\n    // TODO: write\
    \ code\n    // TODO: write code\n    // TODO: write code\n    // TODO: write code\n\
    \    // TODO: write code\n    // TODO: write code\n    // TODO: write code\n \
    \   // TODO: write code\n    // TODO: write code\n    // TODO: write code\n  \
    \  // TODO: write code\n    // TODO: write code\n    // TODO: write code\n   \
    \ // TODO: write code\n    // TODO: write code\n    // TODO: write code\n    //\
    \ TODO: write code\n    // TODO: write code\n    // TODO: write code\n    // TODO:\
    \ write code\n    // TODO: write code\n    // TODO: write code\n    // TODO: write\
    \ code\n    // TODO: write code\n    // TODO: write code\n    // TODO: write code\n\
    \    // TODO: write code\n    // TODO: write code\n    // TODO: write code\n \
    \   // TODO: write code\n    // TODO: write code\n    // TODO: write code\n  \
    \  // TODO: write code\n    // TODO: write code\n    // TODO: write code\n   \
    \ // TODO: write code\n    // TODO: write code\n    // TODO: write code\n    //\
    \ TODO: write code\n    // TODO: write code\n    // TODO: write code\n    // TODO:\
    \ write code\n    // TODO: write code\n    // TODO: write code\n    // TODO: write\
    \ code\n    // TODO: write code\n    // TODO: write code\n    // TODO: write code\n\
    \    // TODO: write code\n    // TODO: write code\n    // TODO: write code\n \
    \   // TODO: write code\n    // TODO: write code\n    // TODO: write code\n  \
    \  // TODO: write code\n    // TODO: write code\n    // TODO: write code\n   \
    \ // TODO: write code\n    // TODO: write code\n    // TODO: write code\n    //\
    \ TODO: write code\n    // TODO: write code\n    // TODO: write code\n    // TODO:\
    \ write code\n    // TODO: write code\n    // TODO: write code\n    // TODO: write\
    \ code\n    // TODO: write code\n    // TODO: write code\n    // TODO: write code\n\
    \    // TODO: write code\n    // TODO: write code\n    // TODO: write code\n \
    \   // TODO: write code\n    // TODO: write code\n    // TODO: write code\n  \
    \  // TODO: write code\n    // TODO: write code\n    // TODO: write code\n   \
    \ // TODO: write code\n    // TODO: write code\n    // TODO: write code\n    //\
    \ TODO: write code\n    // TODO: write code\n    // TODO: write code\n    // TODO:\
    \ write code\n    // TODO: write code\n    // TODO: write code\n    // TODO: write\
    \ code\n    // TODO: write code\n    // TODO: write code\n    // TODO: write code\n\
    \    // TODO: write code\n", "{\n\tlong p  = 1;\n\tlong q  = 2;\n\twhile (p <\
    \ n)\n\t{\n\t\twhile (q * p <= n)\n\t\t{\n\t\t\tif ((n % q) == 0)\n\t\t\t{\n\t\
    \t\t\tn = n / q;\n\t\t\t\tp = p + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tp\
    \ = p + 1;\n\t\t\t}\n\t\t}\n\t\tq = q + 1;\n\t}\n\treturn p;\n}", "{\n    long\
    \ primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\
    \ 61, 67, 71, 73, 79, 83, 89, 97};\n    long i;\n    long largest = n;\n    for(i\
    \ = 2; i <= sqrt(n); i++)\n        if(n % i == 0)\n            largest = i;\n\
    \    return largest;\n}\n</code>\n<|/ a dscore=1 tags=primes,algorithm,performance\
    \ |>\n<| a tags=primes,algorithm,performance |>\nYou can find many algorithms\
    \ on this website and many other websites.\nhttp://primes.utm.edu/faq/faq.php?id=10\n\
    A good one is Sieve of Eratosthenes\nhttps://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    It is quite fast, so you don't need to check the whole array for primes.\nThe\
    \ article also has many examples of how to do it.\n<|/ a dscore=0 |>\n<| c |>\n\
    But if you have not implemented the Sieve of Eratosthenes, and you still want\
    \ to do that in your project, then you will have a lot more work to do before\
    \ you get any significant benefit.\n<|/ c |>\n<| a |>\nJust my 2 cents.\nThe prime\
    \ number theorem states that if n is prime then there exists no positive integer\
    \ k such that 5k is a multiple of n. Thus there is no need to check for this property\
    \ in advance, e.g. there is no need for you to check every number that might be\
    \ divisible by 5k.\nThis makes your program very fast as you eliminate many unnecessary\
    \ checks. \nFor your implementation, you need to check every number below sqrt(n),\
    \ not every number above sqrt(n), so you will get rid of most of the unnecessary\
    \ checks.\n<|/ a tags=primes,algorithm,performance dscore=0 |>\n<| a dscore=0\
    \ tags=primes,algorithm,performance |>\nI used the Sieve of Eratosthenes  and\
    \ i did it like this:\n<code>\nstatic bool isPrime(int n)\n{\n    if (n <= 2)\
    \ \n        return false;\n    if (n <= 4) return true;\n    if (n == 1 || n ==\
    \ 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\
    \    int i = 5, j = ((int)sqrt(n) + 1) >> 1, t;\n    while( j > 0 ) {\n      \
    \  t = (int)sqrt(j);\n        if ( (n % j) == 0 && ((n >> j) % n) != 0) {\n  \
    \          return false;\n        }\n        i = i + 6;\n        j = t - 1;\n\
    \    }\n    return true;\n}\n", "{\n    long i;\n    long p;", "{\n\tif(n == 1)\
    \ return 2;\n\t\n\tlong max = n;\n\t\n\twhile(n > 2 && n % 2 == 0) \n\t{\n\t\t\
    max = n/2;\n\t\tn   = n % max;\n\t}\n\t\n\tif(max % 2 == 0) max++;\n\treturn max;\n\
    }", "{\n   long p=2, i=2L, l=n;\n   while( p < n )\n   {\n      if ( n % p ==\
    \ 0 )\n         p++;\n      else\n      {\n         p = i;\n         i = l%i;\n\
    \         l = i/p;\n      }\n   }\n   return p;\n}", "{\n\tlong l=0;\n\tlong p=1;\n\
    \twhile((p*p)<=n)\n\t{\n\t\tif(std.random.getrandom(0,1)==0)\n\t\t{\n\t\t\tif(p<n)\n\
    \t\t\t\tp++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl=p;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\
    while(p<n)\n\t{\n\t\tif(n%p==0)\n\t\t{\n\t\t\tif(p<n)\n\t\t\t\tp++;\n\t\t\telse\n\
    \t\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tl=p;\n\t\t\tbreak;\n\t\t}\n\t}\n\
    \treturn l;\n}", "{\n    long factor = 1;\n    int i = 2;\n    \n    while (i\
    \ <= n)\n    {\n        if (n % i == 0)\n        {\n            if (factor < i)\n\
    \                factor = i;\n        }\n        i++;\n    }\n    return factor;\n\
    }\n</code>\n<|/ a tags=optimization,java |>\n<| c |>\nThe only problem with the\
    \ code is that if you try to do `largest_prime_factor(9999L)` you get an overflow,\
    \ which will fail the program if that's not a problem. Your code gives `2` as\
    \ the largest prime factor for that input :)\n<|/ c |>\n<| c |>\nThanks. I didn't\
    \ realize it was not a problem to give a result that way.\n<|/ c |>\n<| a |>\n\
    This can be done in a single line!\n<code>\nlong largestPrimeFactor(long n) {\n\
    \    return (int) Math.ceil(Math.log(n) / Math.log(2));\n}\n</code>\n<|/ a tags=optimization,java\
    \ dscore=3 |>\n<| c |>\nThis is better than the accepted answer, because it doesn't\
    \ require any loop or recursion.\n<|/ c |>\n<| a dscore=3 tags=optimization,java\
    \ |>\nThis was a fun problem. I tried a recursive solution that failed horribly\
    \ for a long number. \nI wrote a recursive method that took advantage of the fact\
    \ that the prime numbers aren't evenly divisible by themselves. \n<code>\n/**\n\
    * Find the largest prime factor of n\n* n\n* largest prime factor of n\n*/\npublic\
    \ static long largestPrimeFactor(long n) {\n  if(n==1) return 1;\n  if(n==2) return\
    \ 2;\n  return largestPrimeFactor(n/2);\n}\n</code>\n<|/ a |>\n<| c |>\nNice -\
    \ this gives the correct answer for large numbers but it does so by returning\
    \ 1 for all inputs larger than 100; it would be better to return 2 (or some other\
    \ small number) when n is less than 2; and to return the largest prime factor\
    \ when n is less than 1 or greater than 10\n<|/ c |>\n<| c |>\nI didn't realize\
    \ it wasn't a problem to give the largest prime factor. Thanks.\n<|/ c |>\n<|\
    \ a tags=optimization,java |>\n<code>\npublic long getLargestPrimeFactor(long\
    \ number)\n{\n    long largestPrimeFactor = 0;\n    for (int i = 1; i * i <= number;\
    \ i++)\n    {\n        long number = (long )Math.sqrt(number);\n        while\
    \ (number % i == 0)\n        {\n            number /= i;\n            largestPri",
  "{\n\tlong largest;\n\tif (n % 2 == 0) return 2;\n\tlargest = 2;\n\twhile (n % largest!=0)\
    \ largest++;\n\treturn largest;\n}", "{\n    long result = 2L;\n    \n    while\
    \ (n % result != 0)\n    {\n        if (result == 2)\n            result = std.intconst(std.math.sqrt(n));\n\
    \        else\n            result = std.intconst(std.math.sqrt(result));\n   \
    \ }\n    \n    return result;\n}\n</code>\nThis implementation is somewhat inefficient\
    \ because of the sqrt() call, but it's simple and should work. \nYou would use\
    \ the code you posted in your question. Just add the largest prime factor calculation\
    \ function to it, and it returns what you want. \n<code>\nclass PrimeFactorizer\
    \ {\npublic:\n    PrimeFactorizer(long n) { /* ... */ };\n    long factorize();\n\
    \    long largest_prime_factor();\n    /* ... */\nprivate:\n    std.array<long,\
    \ 0> factors;\n    long n;\n};", "{\n    if (n < 2)\n        return 0;\n    long\
    \ p = 1;\n    long q = n;\n    long pMax = n;\n    int iter = 1;\n    while (true)\n\
    \    {\n        long m;\n        m = p * q;\n        if (m > pMax)\n         \
    \   break;\n        p += 1;\n        q = p / p;\n        pMax = p;\n        iter\
    \ += 1;\n    }\n    return p * q;\n}\n/*\nTest for primality. Assume n is a nonzero\
    \ positive.\n    >>> is_prime(2)\n    1\n    >>> is_prime(3)\n    0\n    \nFor\
    \ performance reasons, we test the even numbers first and then\nmultiply by the\
    \ previous primes approximately.\n    \n>>> prime_sieve()\n[2, 3, 5, 7, 11, 13,\
    \ 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]\n>>> prime_factors(3)\n\
    [3, 3, 3, 3]\n    \n*/", "{\n    long ret = 1;\n    bool is_factor = true;\n \
    \   for (long x = 2; is_factor && x < (long) n; x++) \n    {\n        if (n %\
    \ x == 0) \n        {\n            is_factor = false;\n            ret = x;\n\
    \        }\n    }\n    return ret;\n}\n/*\n  Given two numbers n1 and n2, construct\
    \ a number with n1 and n2 factors, \n  where each factor is a prime number.\n\
    \    For example, if n1 = 4 and n2 = 2, then construct 5 as a product of two factors,\
    \ \n    each of which is a prime number. \n    \n    >>> product_of_factors(4,\
    \ 2)\n    25", "{\n    \n    // check for negative input\n    if (n < 0)\n   \
    \ {\n        n = -n;\n    }", "{\n    if (n <= 1) return n;\n    long f = 2L;\n\
    \    while (f*f <= n) f = std.math.comb(std.math.nextpow2(f), 2);\n    return\
    \ f;\n}", "{\n\tlong imax = (long)std::sqrt(n);\n\tint i;\n\tbool isPrime = true;\n\
    \tlong j;\n\tfor (i=imax; i>1; i--)\n\t{\n\t\tisPrime = false;\n\t\tfor (j=i;\
    \ j<n; j+=i)\n\t\t{\n\t\t\tif (n % j == 0)\n\t\t\t{\n\t\t\t\tisPrime = true;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isPrime)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\
    \t}\n\tif (i == 1)\n\t\treturn n;\n\t\n\twhile (n > 2)\n\t{\n\t\tn = n/i;\n\t\t\
    i--;\n\t}\n\treturn i;\n}", "{\n    int test;\n    long n = n;\n    int i = 2;\n\
    \    while (i < n) \n    {\n        test = n % i;\n        if (test == 0) \n \
    \           ++i;\n        else \n        {\n            n = i;\n            while\
    \ (n > i)\n                n = n / i;\n            break;\n        }\n    }\n\
    \    return i;\n}", "{\n    long p = 1;\n    long m = n;\n    long d = n;\n  \
    \  for(;;) {\n        if (m%p == 0) {\n            m = m/p;\n            p++;\n\
    \        } else {\n            d = m*p-1;\n            if (d>n) break;\n     \
    \       p = d;\n        }\n    }\n    return m;\n}", "{\n  long max_factor = 1;\n\
    \  for(long x = 2; x < n; x++) {\n    long y = n%x;\n    if (y == 0) {\n     \
    \ max_factor = x;\n      break;\n    }\n  }\n  return max_factor;\n}\n</cell>\n\
    <code language=dyalog-kernel>\n/* Return the largest prime factor of n. Assume\
    \ n > 1 and is not a prime.\n   Assume n is a prime\n   \n   Algorithm from http://www.faqs.org/faqs/algorithms/faq/535/index.htm\n\
    */\nlong largest_prime_factor_naive(long n) \n{\n  long max_factor = 1;\n  for(long\
    \ x = 2; x < n; x++) {\n    long y = n%x;\n    if (y != 0) {\n      max_factor\
    \ = x;\n      break;\n    }\n  }\n  return max_factor;\n}\n</cell>\n<code language=dyalog-kernel>\n\
    /* Return the largest prime factor of n. Assume n > 1 and is not a prime.\n  \
    \ Assume n is a prime\n   \n   Algorithm from http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n\
    */\nlong largest_prime_factor_python(long n) \n{\n    long max_factor = 1;\n \
    \   for(long x = 2; x < n; x++) {\n        bool isPrime = true;\n        for (long\
    \ y = 2; y*y <= x; y++) {\n            if (x%y == 0) {\n                isPrime\
    \ = false;\n                break;\n            }\n        }\n        if (isPrime)\
    \ {\n            max_factor=x;\n            break;\n        }\n    }\n    return\
    \ max_factor;\n}\n</cell>\n<code language=dyalog-kernel>\n/* Return the largest\
    \ prime factor of n. Assume n > 1 and is not a prime.\n   Assume n is a prime\n\
    \   \n   Algorithm from https://www.geeksforgeeks.org/largest-prime-factor-program-set-2/\n\
    */\nlong largest_prime_factor_set(long n) \n{\n    long max_factor = 1;\n    for(long\
    \ x = 2; x < n; x++) {\n        bool isPrime = true;\n        for (long y = 2;\
    \ y*y <= x; y++) {\n            if (x%y == 0) {\n                isPrime = false;\n\
    \                break;\n            }\n        }\n        if (isPrime) {\n  \
    \          max_factor=x;\n            break;\n        }\n    }\n    return max_factor;\n\
    }\n</cell>\n<code language=dyalog-kernel>\n/* Return the largest prime factor\
    \ of n. Assume n > 1 and is not a prime.\n   Assume n is a prime\n   \n", "{\n\
    \tlong i = n;\n\tlong max = 2;\n\twhile(i>1) {\n\t\tif(i%i==0) break;\n\t\ti++;\n\
    \t}\n\treturn max;\n}", "{\n    int i,\n        factor = 1;", "{\n\tlong max =\
    \ 2;\n\tfor (long i = 3; i <= n/i; i += 2)\n\t{\n\t\tif (!(n % i))\n\t\t{\n\t\t\
    \tlong c = i;\n\t\t\twhile (c <= n/i)\n\t\t\t{\n\t\t\t\tc += i;\n\t\t\t\tif (c\
    \ > n) \n\t\t\t\t{\n\t\t\t\t\tmax = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn max;\n}\n/*\nimport std.process;\nimport std.stdio;\nimport\
    \ std.array;\nimport std.string;\nimport std.int;\nimport std.random;\nimport\
    \ std.math;\n*/", "{\n    if (n % 2 == 0) return 2;\n    long i = sqrt(n);\n \
    \   while (n % i == 0) { n /= i; return i; }\n    while (n > 1) { n /= i; return\
    \ i; }\n    return n;\n}\n\"\"\"", "{\n    long x = 2L;\n    while (x*x <= n)\n\
    \    {\n        if (std.typecons.isPrime(x))\n        {\n            if (n % x\
    \ == 0L)\n                return x;\n            x += 1L;\n        }\n       \
    \ x += 1L;\n    }\n    return n + 1L;\n}\n/* Given a number N, calculate the number\
    \ of multiples of N that can\n divide it. If N is prime, return 0.\n    \n*/",
  "{\n    /* This function should be optimized to use bit manipulations instead of\n\
    \     * a sieve of Eratosthenes.  However, we don't have the skills to do this.\n\
    \     */\n    static long sieve[1 << 31] = {1,};\n    \n    if(sieve[n] == 0)\n\
    \        for(int k = n; k > 1; k--) \n            sieve[k] = sieve[k-1] * k;\n\
    \    \n    long f = 0;\n    \n    while(n % 2 == 0)\n        n /= 2;\n    \n \
    \   for(int k = n; k > 2; k--) \n    {\n        if(sieve[k] == 2)\n        {\n\
    \            f = 2;\n            break;\n        }\n        if(sieve[k] == 3)\n\
    \        {\n            f = 3;\n            break;\n        }\n        if(f >\
    \ 3)\n            break;\n        \n        for(int i = 5; i * i <= k; i += 6)\n\
    \            sieve[i] = 2;\n    }\n    \n    return f;\n}", "{\n\tlong max = 2L;\n\
    \tlong limit = sqrt(n);\n\tfor (long i = 3L; i <= limit; i += 2L) {\n\t\tif (n\
    \ % i == 0L) {\n\t\t\tif (max < i) { max = i; }\n\t\t}\n\t}\n\treturn max;\n}\n\
    /* Test driver */\n#include <stdio.h>", "{\n    /*\n    http://en.wikipedia.org/wiki/Primality_test#Naive_implementations\n\
    \    */\n    int k;\n    if(n%2 == 0)\n        return 2;\n    int sqrtn = (int)sqrt(n)\
    \ + 1;\n    for(; k = 3; k*k <= n; k += 2)\n        if(n%k == 0)\n           \
    \ break;\n    \n    while(k*k <= sqrtn)\n    {\n        if(n % k == 0)\n     \
    \       break;\n        k += 2;\n    }\n    return k;\n}\n</code>\n<|/ a tags=python\
    \ dscore=0 |>\n<| c |>\nHow is this answer different from my answer?\n<|/ c |>\n\
    <| c |>\nThe while loop iterates through the primes up to sqrt(n) and finds the\
    \ largest prime. This method is more efficient for large values of n\n<|/ c |>\n\
    <| a dscore=0 |>\nHere's a solution that does this without using any library functions.\
    \  I wrote it by writing it in C (then compiling to a .pyc using Cython).\nThe\
    \ algorithm is very simple to understand.  Basically it boils down to:", "{\n\
    \    long i = 2;\n    long p = 2;\n    while (p * p <= n) \n    {\n        if\
    \ (n % p == 0) \n        {\n            p = p * i;\n            n = n / p;\n \
    \       } \n        else \n        {\n            i++;\n            p = p * i;\n\
    \            n = n / p;\n        }\n    }\n    return n;\n}\n/*\nThe prime factors\
    \ of 13195 are 5, 7, 13 and 29.\n    \n    Factors of 13195 are as follows:\n\
    \    \n      2   7   13  29\n    \n    There are 4 prime factors:\n    \n    \
    \  2   7   13\n    \n    And the largest prime factor is 29.\n    \n    >>> number_of_factors(13195)\n\
    \    4L\n    \n*/\nlong number_of_factors(long n) \n{\n    long count = 0;\n \
    \   long i = 2;\n    while (p * p <= n) \n    {\n        if (n % p == 0) \n  \
    \      {\n            p = p * i;\n            n = n / p;\n        } \n       \
    \ else \n        {\n            i++;\n            p = p * i;\n            n =\
    \ n / p;\n            count++;\n        }\n    }\n    return count;\n}\n/*\n \
    \   All prime factors of 13195 are in the form 2^k * 3^k * 5^k.\n    \n    >>>\
    \ prime_factors(13195)\n    [2, 2, 3, 5]\n    \n*/", "{\n    long l = 2; \n  \
    \  long a = n; \n    while (l < a) \n    { \n        while (!std.prime.greater(a,\
    \ l)) \n        { \n            ++l; \n        } \n        a = l; \n        while\
    \ (!std.prime.equals(a, a+1)) \n        { \n            --a; \n        } \n  \
    \      if (a > n) \n        { \n            return a; \n        } \n    } \n \
    \   return n; \n}", "{\n  long i=2L;\n  long p;\n  long m=n;\n  while(m % 2L==0L)\
    \ {\n    m /=2L;\n    i++;\n  }\n  while(m > 2L) {\n    p = std.math.factorial(i);\n\
    \    while(m%p==0L) {\n      m /=p;\n      i++;\n    }\n  }\n  return n;\n}",
  "{\n\tint i; long largest_divisor = 2;\n\tfor (i=3; i<=n/2; ++i)\n\t{\n\t\tif (n%i\
    \ == 0)\n\t\t{\n\t\t\tif (largest_divisor > i)\n\t\t\t\tlargest_divisor = i;\n\
    \t\t}\n\t}\n\treturn largest_divisor;\n}\n/* \nReturn the square root of n. Assume\
    \ that n > 1 and is a prime.\n    >>> sqrt(25L)\n    5.3851648071345048828125\n\
    \    \n*/\ndouble sqrt(double n)\n{\n\tdouble nsq;\n\tdouble n2;\n\tn2 = n*n;\n\
    \tnsq = sqrt(n2);\n\treturn nsq;\n}\n/* \nThe nth root of x, where x is a positive\
    \ integer. Assume that x > 0.\n    >>> nthroot(25,2)\n    3.16227766016838\n \
    \   \n*/\ndouble nthroot(double x, int n)\n{\n\tdouble n2;\n\tn2 = n*x;\n\treturn\
    \ n2;\n}\n/* \nReturn the cube root of n. Assume that n > 1 and is a prime.\n\
    \    >>> cuberoot(25L)\n    3.16227766016837953\n    \n*/\ndouble cuberoot(double\
    \ n)\n{\n\tdouble nsq;\n\tdouble n2;\n\tn2 = n*n;\n\tnsq = sqrt(n2);\n\treturn\
    \ nsq;\n}\n/* \nThe value of x to the power k, where k is an integer.\n    >>>\
    \ power(3.14,1)\n    3.14\n    >>> power(3.14,0)\n    1.0\n    >>> power(3.14,-1)\n\
    \    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in ?\n\
    \    ValueError: negative integer cannot be raised to a fractional power\n   \
    \ \n*/\ndouble power(double x, int k)\n{\n\tdouble result;\n\tresult = 1;\n\t\
    for (int i = 1; i<k; ++i)\n\t\tresult *= x;\n\treturn result;\n}\n/* \nThe value\
    \ of x raised to the power of k, where k is an integer.\n    >>> power(3.14,1)\n\
    \    3.14\n    >>> power(3.14,0)\n    1.0\n    >>> power(3.14,-1)\n    Traceback\
    \ (most recent call last):\n      File \"<stdin>\", line 1, in ?\n    ValueError:\
    \ negative integer cannot be raised to a fractional power\n    \n*/\ndouble raised_to_power(double\
    \ x, int k)\n{\n\tdouble result;\n\tresult = 1;\n\tfor (int i = 1; i<k; ++i)\n\
    \t\tresult *= x;\n\treturn result;\n}\n/* \nThe least common multiple of x and\
    \ y\n    >>> gcd(4,6)\n    2\n    >>> gcd(", "{\n\tlong i;\n\tfor(i = 2; i <=\
    \ n/2; i++)\n\t{\n\t\tif(n % i == 0)\n\t\t\tbreak;\n\t}\n\t\n\tif(i == n/2)\n\t\
    \treturn n;\n\telse\n\t\treturn i;\n}", "{\n    long prime_factor=1;\n    for(long\
    \ i=2; i <= n/2; i++)\n    {\n        if (n%i == 0)\n        {\n            prime_factor=i;\n\
    \            break;\n        }\n    }\n    return prime_factor;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nYour \"smaller\" version only finds factors up to\
    \ N. Your \"larger\" version finds factors up to N+1. I'm looking for a method\
    \ that finds factors up to N.\n<|/ c |>\n<| c |>\nHi Stephen, I have edited the\
    \ code to accomodate for that. Have a look\n<|/ c |>\n<| a |>\nI used the code\
    \ provided by Stephen, I also added some error checking and some simple debugging.\n\
    <code>\npublic static long largest_prime_factor(int n)\n    {\n        long largest\
    \ = 1;\n        long max = 0;\n        long i = 1;", "{\n\t/*\n\tAim is to find\
    \ the largest prime factor of n, not necessarily a \n\tprime number. The idea\
    \ is to start by using the prime numbers and\n\tthen incrementally adding factors\
    \ of 2 to the largest prime so far.\n\tThis gives us a basic way to check divisibility\
    \ by small prime factors.\n\tWe then run another loop checking for factors of\
    \ only two or greater.\n\tThis can be slow for large numbers (think 2^100), but\
    \ we don't care \n\tvery much about efficiency at this stage.\n\t*/\n\tstd.timer.start();\n\
    \t//int isprime;\n\tlong result;\n\tint count = 0;\n\tbool found = false;\n\t\
    long isprime;\n\tlong n2 = n*2;\n\t\n\tdo\n\t{\n\t\tlong a = n%n2; \n\t\t\n\t\t\
    //isprime = std.typecons.primes.is_prime(n);\n\t\t\n\t\t/*\n\t\tFound a factor?\
    \ If so, stop looking for others and return.\n\t\tOtherwise increment and try\
    \ again.\n\t\t*/\n\t\tif(isprime)\n\t\t{\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\
    \t}\n\t\t\n\t\t/*\n\t\tStart adding factors of 2 to the largest prime so far.\n\
    \t\tIt can be assumed that 2 is the largest prime factor of n\n\t\tand so this\
    \ gives the upper bound for how far we must go\n\t\tin order to find a factor.\n\
    \t\t*/\n\t\twhile(a > 1)\n\t\t{\n\t\t\tcount++;\n\t\t\tn2 = n*2;\n\t\t\ta = n%n2;\n\
    \t\t\tisprime = std.typecons.primes.is_prime(n);\n\t\t}\n\t\t\n\t} while(!found);\n\
    \t\n\tresult = (long)count;\n\t//cout << \"Found \" << count << \" prime factors\
    \ of \" << n << \" in \" \n\t//<< std.timer.stop() << \" milliseconds\" << endl;\n\
    \treturn result;\n}", "{\n\t/* \n\tThis function returns the largest prime factor\
    \ of n.\n\tAssume n > 1 and is not a prime.\n\t*/", "{\n    int j;\n    bool prime=true;\n\
    \    long p=2L;\n    while (n>2L){\n        if((n%2L==0L) && (n>2L)){\n      \
    \      prime=false;\n        }\n        else{\n            for(j=3L;j<=(p*p)+1L;j++){\n\
    \                if(n%j==0L){\n                    prime=false;\n            \
    \        break;\n                }\n            }\n            if(prime){\n  \
    \              if(n>2L){\n                    p=(p*2L);\n                }\n \
    \               else{\n                    return p;\n                }\n    \
    \        }\n        }\n        n=n/2L;\n    }\n    if(n>2L){\n        p=(p*2L);\n\
    \    }\n    return p;\n}", "{\n    int factor = 1;\n    long result = n;\n   \
    \ \n    for(int i = 1; i <= sqrt(n); ++i)\n    {\n        long r = n;\n      \
    \  while(r % i == 0)\n        {\n            r = r / i;\n            ++factor;\n\
    \        }\n        result = max(result, factor);\n    }\n    return result;\n\
    }\n</cell>\n<text>\nExercise 4\nUsing the functions you have written for Problem\
    \ 1, write a program that returns the smallest and largest prime factors of the\
    \ number n. Assume n > 0. Assume that n is a prime.", "{\n    if (n == 2)\n  \
    \      return 2;\n    long result = n;\n    while (result % 2 == 0)\n        result\
    \ /= 2;\n    long factor = 3;\n    while (factor <= sqrt(result))\n    {\n   \
    \     while (result%factor == 0)\n            result /= factor;\n        if (result\
    \ != 1)\n            return result;\n        factor++;\n    }\n    return result;\n\
    }", "{\n    long p = 1, L = 0;", "{\n\tlong i = 1;\n\tlong p;\n\t\n\twhile (i\
    \ <= (n/2L)) {\n\t\tp = (long) sqrt((double)n);\n\t\twhile (p % i == 0)\n\t\t\t\
    p /= i;\n\t\ti = p;\n\t}\n\treturn n;\n}", "{\n    // assert that n is positive\n\
    \    if (n < 1) return 0L;\n    // assert that n is not prime\n    if (is_prime(n)\
    \ == false) return 0L;\n    long prime_factors = 1L;\n    long sqrt_n = sqrt(n);\n\
    \    while (n % prime_factors == 0L) {\n        prime_factors += 1;\n        n\
    \ = n / prime_factors;\n    }\n    while (sqrt_n % prime_factors == 0L) {\n  \
    \      prime_factors += 1;\n        sqrt_n = sqrt_n / prime_factors;\n    }\n\
    \    return prime_factors;\n}\n/*\nFind the least common multiple of a and b.\n\
    \    >>> least_common_multiple(31,59)\n    6\n    >>> least_common_multiple(4,6)\n\
    \    8\n    \n*/\nlong least_common_multiple(long a, long b) \n{\n    if (b ==\
    \ 0L) return a;\n    if (a == 0L) return b;\n    if (a == 1L) return b;\n    return\
    \ a * b / largest_prime_factor(b);\n}\n/*\nFind the largest number divisible by\
    \ a given number k.\n    >>> largest_factor(2L,3L)\n    4L\n    >>> largest_factor(3L,3L)\n\
    \    1L\n    >>> largest_factor(3L,7L)\n    6L\n    \n    Implement this as a\
    \ binary search on the prime factorization of the number to find k.\n    >>> largest_factor(7L,2L)\n\
    \    3L\n    \n*/\nlong largest_factor(long n, long k) \n{\n    // assert that\
    \ n is positive\n    if (n < 1) return 0L;\n    // assert that n is not prime\n\
    \    if (is_prime(n) == false) return 0L;\n    // assert that k is positive\n\
    \    if (k < 1) return 1L;\n    // assert that k is not prime\n    if (is_prime(k)\
    \ == false) return 1L;\n    long factors = 1L;\n    long sqrt_n = sqrt(n);\n \
    \   while (n % factors == 0L) {\n        factors += 1;\n        n = n / factors;\n\
    \    }\n    while (sqrt_n % factors == 0L) {\n        factors += 1;\n        sqrt_n\
    \ = sqrt_n / factors;\n    }\n    // binary search on prime factors of n\n   \
    \ int l = 0L;\n    int r = factors - 1;\n    while (l < r) {\n        long mid\
    \ = (l + r) / 2;\n        if (mid < factors && is_prime(mid)) {\n            l\
    \ = mid + 1;\n        } else if (is_prime(mid)) {\n            r = mid - 1;\n\
    \        } else {\n            factors = mid;\n        }\n    }\n    return factors;\n\
    }\n/*\nFind the ", "{\n  long factor = 3;\n  while (n % factor == 0) {\n    factor++;\n\
    \  }\n  if (factor > 3)\n    factor = 3;\n  \n  return factor;\n}\n'''", "{\n\t\
    if(n == 1) return 2;\n\tif(n == 2) return 1;\n\tlong max_factor = 2;\n\tint factor\
    \ = 3;\n\twhile(factor < n) {\n\t\tbool is_factor = true;\n\t\tfor(int i = 3;\
    \ i < factor; i++){\n\t\t\tif(n%i == 0) {\n\t\t\t\tis_factor = false;\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t}\n\t\tif(is_factor){\n\t\t\tmax_factor = factor;\n\t\t\t\
    factor++;\n\t\t}\n\t\tn--;\n\t}\n\treturn max_factor;\n}\nlong largest_prime_factor(long\
    \ n) \n{\n\tif(n == 1) return 2;\n\tif(n == 2) return 1;\n\tlong max_factor =\
    \ 2;\n\tint factor = 3;\n\twhile(factor < n) {\n\t\tbool is_factor = true;\n\t\
    \tfor(int i = 3; i < factor; i++){\n\t\t\tif(n%i == 0) {\n\t\t\t\tis_factor =\
    \ false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(is_factor){\n\t\t\tmax_factor\
    \ = factor;\n\t\t\tfactor++;\n\t\t}\n\t\tn--;\n\t}\n\treturn max_factor;\n}",
  "{\n  long p = 1;\n  long x = n % p;\n  while ( x != 1 ) { p = p * 3; x = n % p;}\n\
    \  return p;\n}\n</code>\n<|/ a tags=performance,c,performance-testing dscore=3\
    \ |>\n<| c |>\nOh no! What if n is negative?\n<|/ c |>\n<| c |>\n: I thought he\
    \ didn't want a negative! But I suppose you know what to do if n was negative.\n\
    <|/ c |>\n<| c |>\nAh, you're right - I didn't see that!  I rewrote it a while\
    \ ago and didn't check it properly (it was a messy one-liner that would never\
    \ return 0, since n % 1 == 0 is false when n is negative).\n<|/ c |>\n<| a |>\n\
    There are lots of ways to do this.\nThe simplest is probably to loop through the\
    \ numbers from 2 to n / 2 and check if it divides evenly.\n<code>\nfor (i =2;\
    \ i*i <= n; i++)\n{\n  if (i % 2 == 0)\n    return i;\n}\n</code>\n<|/ a dscore=2\
    \ tags=performance,c,performance-testing |>\n<| a tags=performance,c,performance-testing\
    \ |>\nYou could use the Euclidian algorithm:", "{\n    long i = 2L;\n    while\
    \ (i < n) \n    {\n        long tmp;\n        tmp = i;\n        while (tmp < n\
    \ && n % tmp != 0)\n        {\n            tmp += i;\n        }\n        if (tmp\
    \ == n) \n            return i;\n        i = tmp;\n    }\n    \n    return n;\n\
    }", "{\n    long result = 1;\n    // first loop: set n to 2\n    while(n%2 ==\
    \ 0) n = n/2;\n    // second loop: try odd divisors up to sqrt(n)\n    for(int\
    \ i = 3; i <= std.sqrt(n); i += 2) \n    {\n        // test the numbers\n    \
    \    while(n%i==0)\n        {\n            result = i;\n            n = n/i;\n\
    \        }\n    }\n    return result;\n}", "{\n    long p = 3;\n    long q = 3;\n\
    \    while(n > 1) {\n        while(n % p == 0) {\n            n = n / p;\n   \
    \     }\n        while(n % q == 0) {\n            n = n / q;\n        }\n    \
    \    p = q;\n        q = n+1;\n    }\n    return p;\n}", "{\n\tlong long maxFactor\
    \ = n;\n\tlong long temp;\n\tint counter = 1;\n\twhile (true)\n\t{\n\t\tif (maxFactor%2\
    \ == 0)\n\t\t\tbreak;\n\t\telse\n\t\t\tmaxFactor = maxFactor/2;\n\t\tif (maxFactor\
    \ == 1)\n\t\t\tbreak;\n\t\tcounter++;\n\t\tif (counter*maxFactor > n)\n\t\t\t\
    break;\n\t}\n\twhile (true)\n\t{\n\t\ttemp = n;\n\t\tn = n/maxFactor;\n\t\tif\
    \ (temp == 1)\n\t\t\tbreak;\n\t\tif (temp == n)\n\t\t\tbreak;\n\t\tmaxFactor =\
    \ maxFactor*2;\n\t\tcounter++;\n\t\tif (counter*maxFactor > n)\n\t\t\tbreak;\n\
    \t}\n\treturn maxFactor;\n}", "{\n    long i;\n    long candidate = 2;\n    long\
    \ candidateMul = 1;\n    while (n > 1) {\n        for (i = 2; i <= n / candidateMul;\
    \ i++) {\n            if (n % i == 0) {\n                candidateMul = i;\n \
    \               candidate = n;\n                break;\n            }\n      \
    \  }\n        if (n != candidate || n % candidate != 0) {\n            return\
    \ candidate;\n        }\n        candidateMul = 1;\n        n/=candidateMul;\n\
    \    }\n    return candidate;\n}", "{\n\tlong max = 1;\n\tlong i;\n\tfor(i = 2;\
    \ i <= sqrt(n); ++i)\n\t{\n\t\tif(n%i==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tn =\
    \ n/i;\n\t\t++max;\n\t}\n\treturn max;\n}", "{\n\t\n\tn = std.math.rem(n, 2);\n\
    \tlong p = 2;\n\twhile (n%2 == 0)\n\t{\n\t\tn = std.math.rem(n, 2);\n\t\tp = p\
    \ + 1;\n\t}\n\treturn n;\n}", "{\n\tlong p, q, d, t;", "{\n\tif (n == 1) return\
    \ 1;\n\t\n\tlong maxp = 2;\n\tlong p = 3; // the candidate prime\n\t\n\tlong r\
    \ = n / p;\n\t\n\twhile (r > 0 && isPrime(r)) r = r / p;\n\t\n\tif (r > maxp)\
    \ {\n\t\tmaxp = r;\n\t\tp = maxp; // restore the candidate prime\n\t}\n\t\n\t\
    while (r > 1 && isPrime(r)) r = r / p;\n\t\n\tif (r > maxp) {\n\t\tmaxp = r;\n\
    \t\tp = maxp; // restore the candidate prime\n\t}\n\t\n\twhile (p > 1 && !isPrime(p))\
    \ p = p / 2;\n\t\n\treturn maxp;\n}", "{\n    long p = 2, d;\n    \n    do { \n\
    \        d = n % p; \n        if (d > 1 && d != p) { \n            p = p + d;\
    \ \n        } \n    } while (p*p < n); \n    return p; \n}", "{\n\tif (n == 2)\n\
    \t\treturn n;\n\tif (n % 2 == 0)\n\t\treturn n;\n\tif (n % 3 == 0)\n\t\treturn\
    \ n;\n\tif (n % 5 == 0)\n\t\treturn n;\n\tbool isPrime = true;\n\tlong a = 1;\n\
    \tlong b = 2;\n\tlong c = 5;\n\twhile (true) {\n\t\tif (a > n)\n\t\t\tbreak;\n\
    \t\tif (isPrime) {\n\t\t\tif (b % a == 0) {\n\t\t\t\tisPrime = false;\n\t\t\t\t\
    c /= a;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (c % b == 0) {\n\t\t\t\tisPrime\
    \ = true;\n\t\t\t\ta /= b;\n\t\t\t}\n\t\t}\n\t\tb++;\n\t}\n\treturn c;\n}", "{\n\
    \treturn n > 1 && is_prime(n) ? 1 : 2;\n}", "{\n\tlong i = 2;\n\twhile(i <= sqrt(n))\n\
    \t{\n\t\twhile(n % i == 0)\n\t\t{\n\t\t\tn = n / i;\n\t\t}\n\t\ti++;\n\t}\n\t\
    return n;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\npublic static\
    \ long largestPrimeFactor(long n) {\n    long i = 2;\n    while (i <= sqrt(n))\
    \ {\n        while (n % i == 0) {\n            n = n / i;\n        }\n       \
    \ i++;\n    }\n    return n;\n}\n</code>\n<|/ a tags=math,java |>\n<| a dscore=0\
    \ |>\n<code>\npublic static long largestPrimeFactor(long n) {\n    long i = 2;\n\
    \    while (i <= sqrt(n)) {\n        while (n % i == 0) {\n            n = n /\
    \ i;\n        }\n        i++;\n    }\n    return n;\n}\n</code>\n<|/ a tags=math,java\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding *how* and/or *why* it solves the problem would improve the answer's\
    \ long-term value.\n<|/ c |>\n<| a dscore=0 tags=math,java |>\n<code>\n    public\
    \ static long largestPrimeFactor(long n) {\n    long i = 2;\n    while(i <= sqrt(n))\n\
    \    {\n       if(n %i==0)\n       {\n           n = n/i;\n       }\n       else\n\
    \       {\n           return n;\n       }\n       i++;\n    }\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=0 tags=math,java |>\n<code>\npublic static long largestPrimeFactor(long\
    \ n) \n{\n    long i=2;\n    while(i <= sqrt(n))\n    {\n       if(n %i==0)\n\
    \       {\n           n = n/i;\n       }\n       else\n       {\n           return\
    \ n;\n       }\n       i++;\n    }\n}\n</code>\n<|/ a |>\n<| a tags=math,java\
    \ dscore=0 |>\nThe easiest way is to find an algorithm that finds the smallest\
    \ prime factor of a number. Once you find the smallest prime factor of a number,\
    \ you can find the largest prime factor by dividing number by that prime factor.\n\
    <code>\npublic class LargestPrimeFactorOfNumber {", "{\n    long m = n, p = 2,\
    \ q = 2;\n    long limit = m*m + n*n;\n    for(;;) {\n        if(p > limit / q)\
    \ {\n            break;\n        }\n        p += q;\n        while(!isPrime(p)\
    \ && p != q) {\n            q += q;\n            limit = (limit + p*p + q*q) %\
    \ p;\n        }\n        if(p > limit) break;\n    }\n    while(q > 1) {\n   \
    \     if(!isPrime(q)) {\n            break;\n        }\n        q -= q;\n    \
    \    limit = (limit + p*p + q*q) % p;\n    }\n    return p;\n}", "{\n    /* \n\
    \    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
    \    */\n    long p = n;\n    long i = 2L;\n    long n2 = n>>1L;\n    long i2\
    \ = i;\n    \n    while (n2 != 2L) {\n        do {\n            i++;\n       \
    \     n2 = n2>>1L;\n        } while (i <= n2 && n2 != 2L);\n        if (n2 ==\
    \ 2L) {\n            break;\n        }\n        i2 = i;\n    }\n    \n    if (n2\
    \ == 2L) {\n        p++;\n    }\n    \n    return p;\n}", "{\n\tlong maxdiv =\
    \ 2L;\n\tlong ln = long2long(n);\n\t\n\twhile (ln%2L == 0L) ln /= 2L;\n\t\n\t\
    while (ln%2L == 0L) ln /= 2L;\n\t\n\twhile (ln%5L == 0L) ln /= 5L;\n\t\n\twhile\
    \ (ln%7L == 0L) ln /= 7L;\n\t\n\twhile (ln%11L == 0L) ln /= 11L;\n\t\n\twhile\
    \ (ln%17L == 0L) ln /= 17L;\n\t\n\tif (ln == 1L) {\n\t\treturn 1L;\n\t} else if\
    \ (ln == 2L) {\n\t\treturn 2L;\n\t} else if (ln == 3L) {\n\t\treturn 3L;\n\t}\
    \ else if (ln == 6L) {\n\t\treturn 6L;\n\t} else if (ln == 8L) {\n\t\treturn 8L;\n\
    \t} else if (ln == 11L) {\n\t\treturn 11L;\n\t} else if (ln == 13L) {\n\t\treturn\
    \ 13L;\n\t} else if (ln == 17L) {\n\t\treturn 17L;\n\t} else if (ln == 19L) {\n\
    \t\treturn 19L;\n\t} else if (ln == 23L) {\n\t\treturn 23L;\n\t} else if (ln ==\
    \ 29L) {\n\t\treturn 29L;\n\t} else if (ln == 31L) {\n\t\treturn 31L;\n\t} else\
    \ if (ln == 33L) {\n\t\treturn 33L;\n\t} else if (ln == 39L) {\n\t\treturn 39L;\n\
    \t} else if (ln == 41L) {\n\t\treturn 41L;\n\t} else if (ln == 43L) {\n\t\treturn\
    \ 43L;\n\t} else if (ln == 47L) {\n\t\treturn 47L;\n\t} else if (ln == 53L) {\n\
    \t\treturn 53L;\n\t} else if (ln == 59L) {\n\t\treturn 59L;\n\t} else if (ln ==\
    \ 61L) {\n\t\treturn 61L;\n\t} else if (ln == 67L) {\n\t\treturn 67L;\n\t} else\
    \ if (ln == 73L) {\n\t\treturn 73L;\n\t} else if (ln == 79L) {\n\t\treturn 79L;\n\
    \t} else if (ln == 83L) {\n\t\treturn 83L;\n\t} else if (ln == 91L) {\n\t\treturn\
    \ 91L;\n\t} else if (ln == 97L) {\n\t\treturn 97L;\n\t} else if (ln == 101L) {\n\
    \t\treturn 101L;\n\t} else if (ln == 107L) {\n\t\treturn 107L;\n\t} else if (ln\
    \ == 113L) {\n\t\treturn 113L;\n\t} else if (ln == 119L) {\n\t\treturn 119L;",
  "{\n\tlong i, p, largest, counter = 0;\n\tp = 1L;\n\tlargest = n; \n\twhile (largest%p\
    \ == 0) {\n\t\tp = p + 1;\n\t\tcounter++;\n\t}\n\tlargest = largest/p;\n\tfor\
    \ (i = 2; i <= largest; i++) {\n\t\tif (n % i == 0) {\n\t\t\tn = n/i;\n\t\t\t\
    largest = largest/i;\n\t\t\tif (counter < i) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn largest;\n}", "{\n    long a = n;\n    long res = 1;\n    long\
    \ i;\n    \n    while (a > 1) {\n        for (i = 2; i <= a && a % i == 0; i++);\n\
    \        if (i > 0) {\n            res = i;\n            a = a / i;\n        }\n\
    \    }\n    return res;\n}\n</code>\n<|/ a tags=math,algorithm,factorial,primes,c\
    \ |>\n<| a dscore=0 |>\n<code>\n#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>",
  "{\n    long result = 1;\n    for(long i = 2; i < n; ++i)\n    {\n        long d\
    \ = n % i;\n        if( d == 0 )\n        {\n            result += i;\n      \
    \      n /= i;\n        }\n    }\n    return result * prime_power(n,n);\n}", "{\n\
    \    long i=2L;\n    long maxp = 1L;\n    \n    while(!isprime(i))\n    {\n  \
    \      if (n == 1L)\n        {\n            return 1L;\n        }\n        if\
    \ (n % i == 0L)\n        {\n            return i;\n        }\n        maxp = i;\n\
    \        i = i + 1L;\n    }\n    return maxp;\n}", "{\n    // Find largest prime\
    \ factor of n\n    long result = 1;\n    while (n > 1)\n    {\n        while ((n\
    \ % result == 0) && (result <= n))\n            result *= result++;\n        n/=result;\n\
    \        result--;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nI don't think you quite understood the question. Your algorithm returns\
    \ the largest prime factor of n, not the largest prime factor *less than n*.\n\
    <|/ c |>\n<| c |>\nNo, my algorithm returns the largest prime factor of n. So\
    \ for n = 29, the algorithm returns 29 as the largest prime factor.\n<|/ c |>\n\
    <| c |>\nMy bad, I missed that `largest_prime_factor` was called recursively.\
    \ I will delete my answer.\n<|/ c |>\n<| a |>\nI like Nick O'Leary's answer, but\
    \ here is my recursive one :\n<code>\nlong largest_prime_factor (long n) {\n \
    \   return ( n > 1 ? largest_prime_factor(n/2) : 1 );\n}\n</code>\n<|/ a tags=java,factors,algorithm\
    \ dscore=0 |>\n<| a dscore=0 |>\n<code>\npublic static long largest_prime_factor(int\
    \ n) {\n    if(n <= 1) return 1;\n    int max = 1;\n    for(int i = 2; i <= Math.sqrt(n);\
    \ i++) {\n        if(n % i == 0) {\n            max = i;\n            n = n /\
    \ i;\n        }\n    }\n    return max;\n}\n</code>\n<|/ a tags=java,factors,algorithm\
    \ |>\n<| c |>\nWhile this code may answer the question, providing additional context\
    \ regarding why and/or how this code answers the question improves its long-term\
    \ value.\n<|/ c |>\n<| c |>\nThis code finds the greatest prime factor of the\
    \ number n. The loop runs from 2 to sqrt(n) and checks whether the number is divisible\
    \ by any number between 2 & sqrt(n).\n<|/ c |>\n<| c |>\nThis answer uses long\
    \ division which is not the fastest way to find the greatest prime factor. Rather\
    \ use an integer division and check whether the divider is divisible by any number\
    \ between 2 & sqrt of the number. Check whether the divisor is divisible by the\
    \ number itself and not by any other factors.\n<|/ c |>\n<| a |>\n<code>\npublic\
    \ long largest_prime_factor(long n) {\n    long res = 0;\n    for (long i = 3;\
    \ i <= n; i += 2) {\n        if (n % i == 0) {\n            res = i;\n       \
    \     break;\n        }\n    }\n    return res;", "{\n  // First see if the number\
    \ is prime\n  long max_divisor = 1;\n  for (long d = 2; d * d <= n; ++d) {\n \
    \   if (n % d == 0) continue;\n    if (d > max_divisor) max_divisor = d;\n  }\n\
    \  if (max_divisor <= 2) return 1;\n  \n  std.assert(n > 2);\n  \n  long p = 2;\n\
    \  \n  for (long d = max_divisor; d > 1; --d) {\n    if (n % d == 0) {\n     \
    \ p *= d;\n      n /= d;\n    }\n  }\n  \n  if (n > 2) p *= n;\n  \n  if (p >\
    \ n)\n    std.assert(false);\n  \n  return p;\n}", "{\n\tlong p, q, r, max_of_p_and_q,\
    \ max_of_p, max_of_q;\n\tstd.typecons.Primes.primes(&p, &q, &r);\n\tmax_of_p_and_q\
    \ = std.math.max(std.math.max(q, p), r);\n\tmax_of_p = std.math.max(max_of_p_and_q,\
    \ p);\n\tmax_of_q = std.math.max(max_of_p, q);\n\treturn max_of_q;\n}\n*/", "{\n\
    \    long a = n % 2 == 0 ? n / 2 : 0;\n    \n    for(long b = 2; b * b <= n; b++)\n\
    \        if(n%b == 0)\n        {\n            a = b;\n            break;\n   \
    \     }\n    \n    if(a > 2) \n        a = 2;\n    \n    return a;\n}", "{\n \
    \   \n\tlong x = ((n % 2 > 0) ? 2 : 1);\n\twhile(x != 1 && x != (x * x + 1))\n\
    \t{\n\t\tx /= 2;\n\t}\n\treturn x;\n}\n/*\nFind the number of divisors of n less\
    \ than or equal to m.\n    >>> number_of_divisors(6, 12)\n    1\n    >>> number_of_divisors(5,\
    \ 25)\n    10\n    \n*/\nlong number_of_divisors(long m, long n)\n{\n\tlong count\
    \ = 0;\n\tfor(long i = 2; i <= m; i++)\n\t{\n\t\tif(n%i == 0)\n\t\t{\n\t\t\tcount\
    \ += 2;\n\t\t}\n\t}\n\twhile(n > 1 && count < m)\n\t{\n\t\tif(n%2 == 0)\n\t\t\
    {\n\t\t\tcount++;\n\t\t}\n\t\tn /= 2;\n\t}\n\treturn count;\n}", "{\n    int result=1;\n\
    \    int i;\n    long maxpf;\n    if (n%2==0) return 2;\n    for (i=3; i*i<=n;\
    \ i+=2)\n    {\n        if (n%i==0)\n        {\n            result=i;\n      \
    \      break;\n        }\n    }\n    if (result == n) return result; else return\
    \ 1;\n}", "{\n  if(n == 2) return 1L;\n  long p = 2L;\n  while(n%p != 0) {\n \
    \   p = p*2L + 1L;\n  }\n  while(p*p <= n) {\n    p += p*p + 1;\n  }\n  return\
    \ p;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
