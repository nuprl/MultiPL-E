language: d
name: HumanEval_18_how_many_times
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count_string = 0;\n\
    \tlong count_substring = 0;\n\t\n\t// We must convert both strings to lower case\
    \ before we begin\n\tstring lowercase_string = string;\n\t\n\t// Iterate over\
    \ the first string, converting it into a set of lower case characters\n\t// and\
    \ adding them to the set of possible matches (if they don't already exist)\n\t\
    for (string i = 0; i < lowercase_string; i++) {\n\t\tchar c = lowercase_string[i];\n\
    \t\t\n\t\tif (set_contains(substrings, c) == false) {\n\t\t\tset_add(substrings,\
    \ c);\n\t\t\tcount_substring++;\n\t\t}\n\t}\n\t\n\t// Iterate over the second\
    \ string, converting it into a set of lower case characters\n\t// and adding them\
    \ to the set of possible matches (if they don't already exist)\n\tfor (string\
    \ j = 0; j < lowercase_string; j++) {\n\t\tchar c = lowercase_string[j];\n\t\t\
    \n\t\tif (set_contains(substrings, c) == false) {\n\t\t\tset_add(substrings, c);\n\
    \t\t\tcount_substring++;\n\t\t}\n\t}\n\t\n\t// Iterate over the first string,\
    \ converting it into a set of lower case characters\n\t// and adding them to the\
    \ set of possible matches (if they don't already exist)\n\tfor (long i = 0; i\
    \ < string.len; i++) {\n\t\tchar c = string[i];\n\t\t\n\t\tif (set_contains(substrings,\
    \ c) == false) {\n\t\t\tset_add(substrings, c);\n\t\t\tcount_string++;\n\t\t}\n\
    \t}\n\t\n\t// Iterate over the second string, converting it into a set of lower\
    \ case characters\n\t// and adding them to the set of possible matches (if they\
    \ don't already exist)\n\tfor (long j = 0; j < string.len; i++) {\n\t\tchar c\
    \ = string[j];\n\t\t\n\t\tif (set_contains(substrings, c) == false) {\n\t\t\t\
    set_add(substrings, c);\n\t\t\tcount_string++;\n\t\t}\n\t}\n\t\n\t// Now that\
    \ we have converted both strings to lower case, we can do the actual search\n\t\
    for (long i = 0; i < substrings.len(); i++) {\n\t\tset_remove(substrings, substrings[i]);\n\
    \t\tcount_substring--;\n\t}\n\t\n\t// Return the total count of overlapping matches\
    \ between the two strings\n\treturn count_string + count_substring;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps0fgla16.d(19): Error: `string` is used as a type

    /tmp/tmps0fgla16.d(23): Error: `string` is used as a type

    /tmp/tmps0fgla16.d(26): Error: undefined identifier `set_contains`

    /tmp/tmps0fgla16.d(27): Error: undefined identifier `set_add`

    /tmp/tmps0fgla16.d(34): Error: `string` is used as a type

    /tmp/tmps0fgla16.d(37): Error: undefined identifier `set_contains`

    /tmp/tmps0fgla16.d(38): Error: undefined identifier `set_add`

    /tmp/tmps0fgla16.d(45): Error: no property `len` for type `string`

    /tmp/tmps0fgla16.d(48): Error: undefined identifier `set_contains`

    /tmp/tmps0fgla16.d(49): Error: undefined identifier `set_add`

    /tmp/tmps0fgla16.d(56): Error: no property `len` for type `string`

    /tmp/tmps0fgla16.d(56): Error: undefined identifier `i`

    /tmp/tmps0fgla16.d(59): Error: undefined identifier `set_contains`

    /tmp/tmps0fgla16.d(60): Error: undefined identifier `set_add`

    /tmp/tmps0fgla16.d(66): Error: undefined identifier `substrings`, did you mean
    variable `substring`?

    /tmp/tmps0fgla16.d(67): Error: undefined identifier `set_remove`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps0fgla16.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint start = 0, end =\
    \ string.length() - substring.length();\n\tstring search;\n\tint count = 0;\n\t\
    \n\twhile(start < end) {\n\t\tsearch = string.substr(start, substring.length());\n\
    \t\tif(string.find(search, start) == start) {\n\t\t\tstart = string.find(search,\
    \ start) + 1;\n\t\t\t++count;\n\t\t} else {\n\t\t\tstart++;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx52f630_.d(15): Error: no property `length` for type `string`

    /tmp/tmpx52f630_.d(15): Error: no property `length` for type `string`

    /tmp/tmpx52f630_.d(16): Error: `string` is used as a type

    /tmp/tmpx52f630_.d(21): Error: no property `find` for type `string`

    /tmp/tmpx52f630_.d(22): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx52f630_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   bool first = true;\n    for(auto it = string.begin(); it != string.end();\
    \ ++it) {\n        auto next = find(substring.begin(), substring.end(), *it);\n\
    \        if(first || (next != string.end() && next != it)) {\n            first\
    \ = false;\n            ++count;\n        }\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpum2qc50h.d(17): Error: no property `begin` for type `string`

    /tmp/tmpum2qc50h.d(17): Error: no property `end` for type `string`

    /tmp/tmpum2qc50h.d(18): Error: undefined identifier `find`, did you mean template
    `Bind(alias Template, args1...)`?

    /tmp/tmpum2qc50h.d(19): Error: no property `end` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpum2qc50h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong result = 0;\n\t\n\
    \tfor (int i = 0; i < string.length(); i++) \n\t{\n\t\tif (string.substr(i, substring.length()).compare(substring)\
    \ == 0) \n\t\t{\n\t\t\tresult += 1;\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9e1lilla.d(17): Error: no property `length` for type `string`

    /tmp/tmp9e1lilla.d(19): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9e1lilla.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t substring_length,\
    \ string_length;\n    size_t total_matches;\n    \n    substring_length = substring.length();\n\
    \    string_length = string.length();\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu07tudgu.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu07tudgu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164233
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong ret = 0;\n\tfor(var\
    \ i = 0; i < string.length; i++) \n\t{\n\t\tret += string.IndexOf(substring, i)\
    \ != -1 ? 1 : 0;\n\t}\n\treturn ret;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvv8ad5c4.d(16): Error: undefined identifier `var`

    /tmp/tmpvv8ad5c4.d(18): Error: no property `IndexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvv8ad5c4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tif (string.len() < substring.len())\
    \ {\n\t\treturn 0;\n\t} else {\n\t\tint n = 0;\n\t\tfor (long i = string.len()-1;\
    \ i >= 0; i--) {\n\t\t\tbool found = false;\n\t\t\tfor (long j = substring.len();\
    \ j >= 0; j--) {\n\t\t\t\tif (string[i] == substring[j]) {\n\t\t\t\t\tfound =\
    \ true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tn++;\n\
    \t\t\t}\n\t\t}\n\t\treturn n;\n\t}\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjuvxukx3.d(15): Error: no property `len` for type `string`

    /tmp/tmpjuvxukx3.d(15): Error: no property `len` for type `string`

    /tmp/tmpjuvxukx3.d(19): Error: no property `len` for type `string`

    /tmp/tmpjuvxukx3.d(21): Error: no property `len` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjuvxukx3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    map<string, long> m;\n\
    \    for (long i = 0; i < string.length(); i++) {\n        string s = string.substr(i,\
    \ substring.length());\n        if (m.containsKey(s)) {\n            m[s]++;\n\
    \        } else {\n            m[s] = 1;\n        }\n    }\n    return m[substring];\n\
    }\n'''\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpunv5shs0.d(15): Error: found `>` when expecting `.` following long

    /tmp/tmpunv5shs0.d(26): Error: unterminated character constant

    /tmp/tmpunv5shs0.d(26): Error: declaration expected, not `63U`

    /tmp/tmpunv5shs0.d(26): Error: unterminated character constant

    /tmp/tmpunv5shs0.d(31): Error: declaration expected, not `assert`

    /tmp/tmpunv5shs0.d(32): Error: declaration expected, not `assert`

    /tmp/tmpunv5shs0.d(33): Error: declaration expected, not `assert`

    /tmp/tmpunv5shs0.d(34): Error: declaration expected, not `assert`

    /tmp/tmpunv5shs0.d(35): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpunv5shs0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164233
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for (auto c : string)\n    {\n        if (c.equals(substring)) \n        {\n\
    \            count++;\n        }\n    }\n    return count;\n}\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ii1spuq.d(16): Error: no identifier for declarator `c`

    /tmp/tmp8ii1spuq.d(16): Error: expression expected, not `:`

    /tmp/tmp8ii1spuq.d(16): Error: found `string` when expecting `;` following `for`
    condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ii1spuq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164233
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long start = 0;\n \
    \   long end = string.find_first_of(substring);\n    while (end != string.length())\
    \ \n    {\n        if (string[end] == substring[0]) \n        {\n            if\
    \ (end < start) \n                start = end;\n            else\n           \
    \     end ++;\n        } \n        else \n        {\n            if (string[end]\
    \ == substring[substring.length() - 1]) \n            {\n                if (end\
    \ < start) \n                    start = end;\n                else\n        \
    \            end++;\n            }\n            else \n                end++;\n\
    \        }\n    }\n    \n    return end - start;\n}\n</code>\n<|/ a tags=string,c++,algorithm,c\
    \ dscore=0 |>\n<| c |>\n`int count=0; for (auto c : string) { if (c == substring[0])\
    \ { count++; } else { count--; } }`\n<|/ c |>\n<| a tags=string,c++,algorithm,c\
    \ |>\nJust in case anyone needs it in python. \n<code>\ndef count_sub_string(\
    \ string, substring ):\n    start = 0\n    end = len( string )\n    count = 0\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprqdf_r_l.d(42): Error: declaration expected, not `<`

    /tmp/tmprqdf_r_l.d(58): Error: declaration expected, not `assert`

    /tmp/tmprqdf_r_l.d(59): Error: declaration expected, not `assert`

    /tmp/tmprqdf_r_l.d(60): Error: declaration expected, not `assert`

    /tmp/tmprqdf_r_l.d(61): Error: declaration expected, not `assert`

    /tmp/tmprqdf_r_l.d(62): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprqdf_r_l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164233
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   int string_length = string.length();\n    int substring_length = substring.length();\n\
    \    \n    for (int i = 0; i < string_length; ++i)\n    {\n        if (string.compare(i,\
    \ substring_length) == 0)\n        {\n            count += substring_length;\n\
    \        }\n        else if (string.compare(i, substring_length) == 0)\n     \
    \   {\n            count += 1;\n        }\n    }\n    \n    return count;\n}\n\
    </code>\n<|/ a tags=string,algorithm,python |>\n<| c |>\nThank you for this very\
    \ complete answer. In the original problem, the strings are really long (1000x1000\
    \ characters) which means that this is very memory hungry, but for this problem,\
    \ it works perfectly!\n<|/ c |>\n<| a |>\n<code>\ndef count_substring(string,\
    \ sub_string):\n    count = 0\n    for i in range(len(string)-len(sub_string)+1):\n\
    \        if(string[i:i+len(sub_string)] == sub_string):\n            count +=\
    \ 1\n    return count\n</code>\n<|/ a tags=string,algorithm,python dscore=3 |>\n\
    <| a dscore=3 |>\nThis is a solution in C#:\n<code>\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpft_k2_m1.d(33): Error: declaration expected, not `<`

    /tmp/tmpft_k2_m1.d(55): Error: declaration expected, not `assert`

    /tmp/tmpft_k2_m1.d(56): Error: declaration expected, not `assert`

    /tmp/tmpft_k2_m1.d(57): Error: declaration expected, not `assert`

    /tmp/tmpft_k2_m1.d(58): Error: declaration expected, not `assert`

    /tmp/tmpft_k2_m1.d(59): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpft_k2_m1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164233
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t start = string.find(substring);\n\
    \    if(start == string.length())\n    {\n        return 0;\n    }\n    else\n\
    \    {\n        string left_sub = string.substr(0, start);\n        string right_sub\
    \ = string.substr(start + substring.length());\n        return left_sub.length()\
    \ + how_many_times(left_sub, substring) + how_many_times(right_sub, substring);\n\
    \    }\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdedfun5a.d(15): Error: no property `find` for type `string`

    /tmp/tmpdedfun5a.d(16): Error: no property `length` for type `string`

    /tmp/tmpdedfun5a.d(22): Error: `string` is used as a type

    /tmp/tmpdedfun5a.d(22): Error: no property `substr` for type `string`

    /tmp/tmpdedfun5a.d(23): Error: `string` is used as a type

    /tmp/tmpdedfun5a.d(23): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdedfun5a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint i = 0;\n\tlong count\
    \ = 0;\n\tfor(i = 0; i < string.length; i++)\n\t{\n\t\tstring substring2 = substring.substring(i);\n\
    \t\tif(string.startsWith(substring2))\n\t\t{\n\t\t\tstring substring3 = substring2.substring(substring.length());\n\
    \t\t\tcount += how_many_times(string.substring(i + 1), substring3);\n\t\t}\n\t\
    }\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqi_ic5c7.d(19): Error: `string` is used as a type

    /tmp/tmpqi_ic5c7.d(19): Error: no property `substring` for type `string`

    /tmp/tmpqi_ic5c7.d(20): Error: no property `startsWith` for type `string`

    /tmp/tmpqi_ic5c7.d(22): Error: `string` is used as a type

    /tmp/tmpqi_ic5c7.d(23): Error: no property `substring` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqi_ic5c7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long substringLength=substring.length();\n\
    \    long result=0L;\n    for(long i=1L; i<string.length(); i=(i+substringLength))\n\
    \    {\n        if(string.substr(i-1,substringLength)==substring)\n        {\n\
    \            result+=substringLength;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwbs1l2br.d(15): Error: no property `length` for type `string`

    /tmp/tmpwbs1l2br.d(17): Error: no property `length` for type `string`

    /tmp/tmpwbs1l2br.d(19): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwbs1l2br.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for(auto &c: substring) \n        if (string.find(c) != string::npos) count++;\n\
    \    return count;\n}\n</code>\n<|/ a tags=string,c++ |>\n<| c |>\nOh my god this\
    \ works perfectly. I never used the string class before so this is very helpful\n\
    <|/ c |>\n<| c |>\nThis can be made slightly more efficient by calculating `string.find(c)`\
    \ in a loop instead of calling `std::string::find()` multiple times.\n<|/ c |>\n\
    <| c |>\n: This is more efficient because `string.find()` does not need to scan\
    \ through the entire string looking for an occurrence of the substring.\n<|/ c\
    \ |>\n<| c |>\n: Thanks.  I fixed my answer.\n<|/ c |>\n<| c |>\n: You should\
    \ use [`std::find_first_of()`](http://en.cppreference.com/w/cpp/string/basic_string/find_first_of)\
    \ instead of `std::find_first_not_of()`\n<|/ c |>\n<| a tags=string,c++ |>\nHere\
    \ is some test code that works for me, and is faster than the other solutions\
    \ above. It also handles consecutive characters that need to be counted multiple\
    \ times.\n<code>\n#include <stdio.h>\n#include <iostream>\n#include <string>\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8yaa8dg_.d(16): Error: basic type expected, not `&`

    /tmp/tmp8yaa8dg_.d(16): Error: no identifier for declarator `_error_`

    /tmp/tmp8yaa8dg_.d(16): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmp8yaa8dg_.d(17): Error: found `:` when expecting `)`

    /tmp/tmp8yaa8dg_.d(17): Error: found `:` instead of statement

    /tmp/tmp8yaa8dg_.d(20): Error: declaration expected, not `<`

    /tmp/tmp8yaa8dg_.d(47): Error: declaration expected, not `assert`

    /tmp/tmp8yaa8dg_.d(48): Error: declaration expected, not `assert`

    /tmp/tmp8yaa8dg_.d(49): Error: declaration expected, not `assert`

    /tmp/tmp8yaa8dg_.d(50): Error: declaration expected, not `assert`

    /tmp/tmp8yaa8dg_.d(51): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8yaa8dg_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (string == \"\"\
    )\n        return 0;\nunittest\n{\n    alias candidate = how_many_times;\n\n \
    \   assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf2qou5l5.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf2qou5l5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tstringstream ss;\n\t\
    ss << string;\n\tstring substring_copy = substring;\n\tfor(long i = 0; i < how_many_times(substring,\
    \ substring_copy); i++)\n\t{\n\t\tstring old_substring_copy = substring_copy;\n\
    \t\tss >> substring_copy;\n\t\tif((ss >> string) != stringstream::eof())\n\t\t\
    \treturn i;\n\t}\n\treturn 0L;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdoknkci8.d(22): Error: found `:` when expecting `)`

    /tmp/tmpdoknkci8.d(22): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdoknkci8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong len = string.length();\n\
    \tint count = 0;\n\tint i = 0;\n\tint j = 0;\n\t\n\twhile (i < len && j < substring.length())\
    \ {\n\t\tint k = i + 1;\n\t\tint m = j + 1;\n\t\t\n\t\tint min = Math.min(k, m);\n\
    \t\tif (min == i) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (string.substr(min, 1).equals(substring.substr(j,\
    \ substring.length()))) {\n\t\t\tcount += 1;\n\t\t\ti += substring.length() -\
    \ 1;\n\t\t\tj += 1;\n\t\t}\n\t\telse if ((string.substr(i, 1).equals(substring.substr(j,\
    \ substring.length()))) && (i == k)) {\n\t\t\tcount += 1;\n\t\t\ti += substring.length()\
    \ - 1;\n\t\t\tj += 1;\n\t\t}\n\t\telse {\n\t\t\ti = k;\n\t\t\tj += 1;\n\t\t}\n\
    \t}\n\t\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv6mhvvek.d(15): Error: no property `length` for type `string`

    /tmp/tmpv6mhvvek.d(20): Error: no property `length` for type `string`

    /tmp/tmpv6mhvvek.d(24): Error: undefined identifier `Math`

    /tmp/tmpv6mhvvek.d(28): Error: no property `substr` for type `string`

    /tmp/tmpv6mhvvek.d(30): Error: no property `length` for type `string`

    /tmp/tmpv6mhvvek.d(33): Error: no property `substr` for type `string`

    /tmp/tmpv6mhvvek.d(35): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv6mhvvek.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   int len = substring.length();\n    for(int i = 0; i < string.length(); i++)\
    \ \n    {\n        if(string[i] == substring[0]) \n        {\n            if((string[i+1]\
    \ == substring[0] || string[i+1] == substring[len-1]) && i != len-1) \n      \
    \      {\n                count++;\n            }\n        }\n    }\n    return\
    \ count;\n}\n/*\n Remove consecutive duplicates in the original string. Return\
    \ new string.\n    >>> how_many_times(\"aaa\", \"aa\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aab\")\n    3L\n \
    \   \n*/\nstring remove_consecutives(string string) \n{\n    string new_string\
    \ = string;\n    for(int i = 1; i < new_string.length(); i++)\n    {\n       \
    \ if(new_string[i] == new_string[i-1]) \n        {\n            new_string = new_string.substr(0,\
    \ i) + \"_\" + new_string.substr(i + 1, new_string.length());\n        }\n   \
    \ }\n    return new_string;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmsq2nti2.d(16): Error: no property `length` for type `string`

    /tmp/tmpmsq2nti2.d(17): Error: no property `length` for type `string`

    /tmp/tmpmsq2nti2.d(41): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmsq2nti2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   bool found = false;\n    for (int i = 0; i < string.length; i++)\n    {\n\
    \        found = string.IndexOf(substring, i) != -1;\n        if (found)\n   \
    \     {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string-matching,c#,string dscore=1 |>\n<| a tags=string-matching,c#,string\
    \ |>\nHere's a function that counts the number of times any substring appears\
    \ in a string in O(N) time. It also handles overlapping matches by adding the\
    \ count of overlapping matches:\n<code>\npublic static long CountSubstring(string\
    \ text, string substring)\n{\n    var position = 0;\n    var count = 0;\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp35onq3iw.d(27): Error: declaration expected, not `<`

    /tmp/tmp35onq3iw.d(30): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp35onq3iw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    string pattern = substring;\n\
    \    int pos = 0;\n    long count = 0;\n    while ((pos = string.find(pattern,\
    \ pos)) != string.length())\n    {\n        ++count;\n        pos += pattern.length();\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    \", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring)\
    \ \n{\n    string pattern = substring;\n    int pos = 0;\n    long count = 0;\n\
    \    while ((pos = string.find(pattern, pos)) != string.length())\n    {\n   \
    \     ++count;\n        pos += pattern.length();\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring)\
    \ \n{\n    string pattern = substring;\n    int pos = 0;\n    long count = 0;\n\
    \    while ((pos = string.find(pattern, pos)) != string.length())\n    {\n   \
    \     ++count;\n        pos += pattern.length();\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring)\
    \ \n{\n    string pattern = substring;\n    int pos = 0;\n    long count = 0;\n\
    \    while ((pos = string.find(pattern, pos)) != string.length())\n    {\n   \
    \     ++count;\n        pos += pattern.length();\n    }\n    return count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    3L\n    \n*/\nlong how_many_\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxkd7rj6w.d(102): Error: semicolon expected, not `unittest`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxkd7rj6w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint count = 0;\n\tint\
    \ start = 0;\n\t\n\tfor (int i = 0; i < string.length() - substring.length() +\
    \ 1; i++)\n\t{\n\t\tif (string.startsWith(substring, start, substring.length()))\n\
    \t\t{\n\t\t\tstart++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount++;\n\t\t\tstart = i\
    \ + 1;\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find the index in the original string\
    \ of a given substring. Case sensitivity is ignored.\n    >>> how_many_times_index(\"\
    \", \"a\")\n    0L\n    >>> how_many_times_index(\"aaa\", \"a\")\n    1L\n   \
    \ >>> how_many_times_index(\"aaaa\", \"a\")\n    2L\n    \n*/\nlong how_many_times_index(string\
    \ string, string substring) \n{\n\tint count = 0;\n\tint start = 0;\n\t\n\tfor\
    \ (int i = 0; i < string.length() - substring.length() + 1; i++)\n\t{\n\t\tif\
    \ (string.equals(substring, start, substring.length()))\n\t\t{\n\t\t\tstart++;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tcount++;\n\t\t\tstart = i + 1;\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n/*\n Find the index in the original string of a given substring.\
    \ Case sensitivity is ignored.\n    >>> how_many_times_index(\"a\", \"\") \n \
    \   1L\n    >>> how_many_times_index(\"a\", \"a\") \n    1L\n    >>> how_many_times_index(\"\
    a\", \"b\") \n    0L\n    \n*/\nlong how_many_times_index(string string, string\
    \ substring, bool ignoreCase) \n{\n\tint count = 0;\n\tint start = 0;\n\t\n\t\
    for (int i = 0; i < string.length() - substring.length() + 1; i++)\n\t{\n\t\t\
    if (!ignoreCase)\n\t\t{\n\t\t\tif (string.charAt(i) == substring.charAt(0))\n\t\
    \t\t{\n\t\t\t\tif (string.startsWith(substring, start, substring.length()))\n\t\
    \t\t\t{\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\
    \t\t\t\t\tstart = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif\
    \ (string.equals(substring, start, substring.length()))\n\t\t\t\t{\n\t\t\t\t\t\
    start++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tstart\
    \ = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (string.charAt(i)\
    \ == substring.charAt(0))\n\t\t\t{\n\t\t\t\tif (string.startsWith(substring, start,\
    \ substring.length()))\n\t\t\t\t{\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t\telse\n\
    \t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\
    \t\telse\n\t\t\t{\n\t\t\t\tif (string.equalsIgnoreCase(substring, start, substring.length()))\n\
    \t\t\t\t{\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn9ydwua_.d(123): Error: found `unittest` instead of statement

    /tmp/tmpn9ydwua_.d(132): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpn9ydwua_.d(132): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpn9ydwua_.d(132): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpn9ydwua_.d(132): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn9ydwua_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  // Make sure that we\
    \ have the same type for this call and all string literals (string literals have\
    \ type string).\n  typedef string::const_iterator iter;\n  assert(string::traits_type::length\
    \ == string.size());\n  assert(string::traits_type::length == substring.size());\n\
    \  assert(string::traits_type::compare(string, substring, iter(string)) != string::npos\
    \ && string::traits_type::compare(substring, string, iter(string)) == 0);\n  \n\
    \  long result = 0;\n  \n  // Iterate over the substring\n  iter sub_pos = substring.begin();\n\
    \  iter sub_end = substring.end();\n  iter pos = string.begin();\n  iter end =\
    \ string.end();\n  \n  while (pos != end && sub_pos != sub_end)\n  {\n    // If\
    \ the current character matches the substring go ahead and increase the counter\n\
    \    if (string::traits_type::compare(string, pos, iter(string)) == 0)\n    {\n\
    \      ++result;\n      \n      // Move the iterator to the next position\n  \
    \    ++pos;\n    }\n    // If the current character does not match the substring\
    \ move the iterator to the next position\n    else if (string::traits_type::compare(string,\
    \ pos, iter(string)) != 0)\n    {\n      ++pos;\n    }\n    // If the substring\
    \ ends and the current character matches the substring go ahead and increase the\
    \ counter\n    else if (string::traits_type::compare(substring, sub_pos, iter(substring))\
    \ == 0)\n    {\n      ++result;\n      \n      // Move the iterator to the next\
    \ position\n      ++sub_pos;\n    }\n    // If the substring ends and the current\
    \ character does not match the substring move the iterator to the next position\n\
    \    else if (string::traits_type::compare(substring, sub_pos, iter(substring))\
    \ != 0)\n    {\n      ++sub_pos;\n    }\n  }\n  \n  return result;\n}\n</code>\n\
    <|/ a tags=stl,string,c++ |>\n<| a dscore=1 tags=stl,string,c++ |>\nThe best performance\
    \ is to use a std::unordered_map to count the occurrences of a substring, where\
    \ the substring is the std::string and the std::string is the input string.\n\
    An unordered_map has O(1) access. std::count is O(N) because count goes through\
    \ every element in the string to check if it matches the substring. Here is an\
    \ example using unordered_map to count the number of occurrences of substrings\
    \ in a string.\n<code>\n#include <iostream>\n#include <unordered_map>\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbrx35wdp.d(16): Error: found `string` when expecting `;` following
    statement

    /tmp/tmpbrx35wdp.d(16): Error: found `:` instead of statement

    /tmp/tmpbrx35wdp.d(17): Error: found `:` when expecting `)`

    /tmp/tmpbrx35wdp.d(17): Error: found `:` when expecting `;` following statement

    /tmp/tmpbrx35wdp.d(17): Error: use `.` for member lookup, not `::`

    /tmp/tmpbrx35wdp.d(17): Error: found `)` when expecting `;` following statement

    /tmp/tmpbrx35wdp.d(17): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpbrx35wdp.d(18): Error: found `:` when expecting `)`

    /tmp/tmpbrx35wdp.d(18): Error: found `:` when expecting `;` following statement

    /tmp/tmpbrx35wdp.d(18): Error: use `.` for member lookup, not `::`

    /tmp/tmpbrx35wdp.d(18): Error: found `)` when expecting `;` following statement

    /tmp/tmpbrx35wdp.d(18): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpbrx35wdp.d(19): Error: found `:` when expecting `)`

    /tmp/tmpbrx35wdp.d(19): Error: found `:` when expecting `;` following statement

    /tmp/'
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  int counter = 0;\n  int\
    \ i = 0;\n  int j = 0;\n  int n = string.length();\n  int m = substring.length();\n\
    \  \n  for (i=0; i<n; ++i)\n    for (j=0; j<m; ++j)\n      if (string.at(i) ==\
    \ substring.at(j))\n        ++counter;\n  \n  return counter;\n}\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm3qyx3um.d(18): Error: no property `length` for type `string`

    /tmp/tmpm3qyx3um.d(19): Error: no property `length` for type `string`

    /tmp/tmpm3qyx3um.d(23): Error: no property `at` for type `string`

    /tmp/tmpm3qyx3um.d(23): Error: no property `at` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm3qyx3um.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   string current_substring = string;\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy4zc7tl5.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy4zc7tl5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t pos = 0;\n \
    \   size_t start_pos = 0;\n    size_t end_pos = 0;\n    size_t count = 0;\n  \
    \  \n    start_pos = 0;\n    end_pos = string.length() - substring.length();\n\
    \    while ((pos = string.find(substring, start_pos)) != string.length())\n  \
    \  {\n        count += 1;\n        start_pos = pos + 1;\n    }\n    \n    return\
    \ count;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThanks for sharing this solution.\
    \ It is great but does not work for overlapping cases.\n<|/ c |>\n<| a tags=python,string,algorithm\
    \ |>\nHow about a regex?\n<code>\nIn [1]: import re\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphu21a7us.d(30): Error: declaration expected, not `<`

    /tmp/tmphu21a7us.d(43): Error: declaration expected, not `assert`

    /tmp/tmphu21a7us.d(44): Error: declaration expected, not `assert`

    /tmp/tmphu21a7us.d(45): Error: declaration expected, not `assert`

    /tmp/tmphu21a7us.d(46): Error: declaration expected, not `assert`

    /tmp/tmphu21a7us.d(47): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphu21a7us.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   int i;\n    \n    for (i = 0; i < (int)(string.length() - substring.length());\
    \ i++)\n    {\n        if (string.startsWith(substring, i) && (string.length()\
    \ - substring.length()) <= i) {\n            count += 1;\n        }\n    }\n \
    \   \n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp32ovp2ab.d(18): Error: C style cast illegal, use `cast(int)(string.length()
    - substring.length())`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp32ovp2ab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong counter = 0;\n\t\
    size_t size = string.length();\n\tsize_t substring_size = substring.length();\n\
    \tfor (size_t i = 0; i < size; i++) {\n\t\tif (string[i] == substring[0]) {\n\t\
    \t\tif (substring[0] == substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\
    \t\t}\n\t\t\tif (substring[0] != string[i+1]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\
    \t\t\tif (string[i+1] == substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\
    \t\t}\n\t\t\tif (substring[0] != string[i+2]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\
    \t\t\tif (string[i+1] != substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn counter;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlapping cases.\n    >>> how_many_times(\"\
    a\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    1L\n    >>> how_many_times(\"\
    aaaa\", \"a\")\n    2L\n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n\tlong counter = 0;\n\tsize_t size = string.length();\n\
    \tsize_t substring_size = substring.length();\n\tsize_t substring2_size = substring2.length();\n\
    \tfor (size_t i = 0; i < size; i++) {\n\t\tif (string[i] == substring[0]) {\n\t\
    \t\tif (substring[0] == substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\
    \t\t}\n\t\t\tif (substring[0] != string[i+1]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\
    \t\t\tif (string[i+1] == substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\
    \t\t}\n\t\t\tif (substring[0] != string[i+2]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\
    \t\t\tif (string[i+1] != substring[substring_size-1]) {\n\t\t\t\tcounter++;\n\t\
    \t\t}\n\t\t}\n\t\tif (string[i] == substring2[0]) {\n\t\t\tif (substring2[0] ==\
    \ substring2[substring2_size-1]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tif (substring2[0]\
    \ != string[i+1]) {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tif (string[i+1] == substring2[substring2_size-1])\
    \ {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t\tif (substring2[0] != string[i+2]) {\n\t\
    \t\t\tcounter++;\n\t\t\t}\n\t\t\tif (string[i+1] != substring2[substring2_size-1])\
    \ {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t}\n\treturn counter;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlapping cases.\n    >>> how_many_times(\"a\", \"a\", \"a\")\n    1L\n  \
    \  >>> how_many_times(\"aaa\", \"a\", \"a\")\n    2L\n    >>> how_many_times(\"\
    aaaa\", \"a\", \"a\")\n    2L\n    \n*/\nlong how_many_times(string string, string\
    \ substring, string substring2, string \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfnf1c1oi.d(103): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfnf1c1oi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   int string_length = string.size();\n    int substring_length = substring.size();\n\
    \    int i = 0;\n    for(i = 0 ; i < string_length - substring_length ; ++i)\n\
    \    {\n        if((string.at(i) == substring.at(i)) && (string.at(i + substring_length)\
    \ == substring.at(i + substring_length)))\n        {\n            ++count;\n \
    \           i += substring_length;\n        }\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp93x2rzuj.d(16): Error: no property `size` for type `string`

    /tmp/tmp93x2rzuj.d(17): Error: no property `size` for type `string`

    /tmp/tmp93x2rzuj.d(21): Error: no property `at` for type `string`

    /tmp/tmp93x2rzuj.d(21): Error: no property `at` for type `string`

    /tmp/tmp93x2rzuj.d(21): Error: no property `at` for type `string`

    /tmp/tmp93x2rzuj.d(21): Error: no property `at` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp93x2rzuj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if(string.size() <=\
    \ substring.size())\n    {\n        long count = string.count(substring);\n  \
    \      while(string.size() > substring.size())\n        {\n            string\
    \ newString = string.substr(0, string.size() - substring.size());\n          \
    \  count += newString.count(substring);\n            string = newString;\n   \
    \     }\n        return count;\n    }\n    else\n    {\n        long count = 0;\n\
    \        string newString = string;\n        while(string.size() > substring.size())\n\
    \        {\n            string newSubString = string.substr(0, string.size() -\
    \ substring.size());\n            count += newString.count(newSubString);\n  \
    \          newString = string.substr(string.size() - substring.size(), string.size());\n\
    \        }\n        return count;\n    }\n}\n</code>\n<|/ a tags=java,string,algorithm,substring\
    \ |>\n<| c |>\nThanks, this is really helpful.\n<|/ c |>\n<| c |>\nThis is still\
    \ O(n^2). At least in Java string.substring returns a view of the original string\
    \ which means that all it does is increment the internal pointer of the original\
    \ string until it hits the last character of the substring. Nothing fancy.\n<|/\
    \ c |>\n<| c |>\nThis is wrong if you need to count overlapping occurrences. I\
    \ believe that `string.count` counts overlapping occurrences.\n<|/ c |>\n<| a\
    \ dscore=5 |>\nI recently worked out a solution that only counts non-overlapping\
    \ occurrences of a given substring within a given string:\n<code>\npublic static\
    \ int countNonOverlappingOccurrences(String str, String substring) {\n    StringBuilder\
    \ sb = new StringBuilder(str);\n    int count = 0;\n    while (true) {\n     \
    \   boolean found = false;\n        for (int i = sb.indexOf(substring); i >= 0;\
    \ i = sb.indexOf(substring, i + 1)) {\n            if (found)\n              \
    \  sb.setCharAt(i, (char) 0);\n            else\n                found = true;\n\
    \        }\n        if (found)\n            count++;\n        else\n         \
    \   break;\n    }\n    return count;\n}\n</code>\n<|/ a tags=java,string,algorithm,substring\
    \ |>\n<| c |>\nThis is O(n^2). At least in Java string.substring returns a view\
    \ of the original string which means that all it does is increment the internal\
    \ pointer of the original string until it hits the last character of the substring.\
    \ Nothing fancy.\n<|/ c |>\n<| a dscore=4 |>\nIf you need to find occurrences\
    \ of substrings in string, then you could use regex expressions. I suggest using\
    \ Pattern (Java Doc), Matcher classes (Java Doc).\nIf you need to check whether\
    \ a string contains a substring \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9ls57enk.d(39): Error: declaration expected, not `<`

    /tmp/tmp9ls57enk.d(56): Error: declaration expected, not `while`

    /tmp/tmp9ls57enk.d(58): Error: declaration expected, not `for`

    /tmp/tmp9ls57enk.d(58): Error: no identifier for declarator `i`

    /tmp/tmp9ls57enk.d(58): Error: declaration expected, not `>=`

    /tmp/tmp9ls57enk.d(58): Error: no identifier for declarator `i`

    /tmp/tmp9ls57enk.d(58): Error: declaration expected, not `=`

    /tmp/tmp9ls57enk.d(61): Error: declaration expected, not `else`

    /tmp/tmp9ls57enk.d(63): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9ls57enk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   size_t pos = 0;\n    long len = (long) string.length();\n    long substrLen\
    \ = (long) substring.length();\n    \n    for(;pos<len;pos++) {\n        if(string.at(pos)==substring.at(pos))\
    \ count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuiha37np.d(17): Error: C style cast illegal, use `cast(long)string.length()`

    /tmp/tmpuiha37np.d(18): Error: C style cast illegal, use `cast(long)substring.length()`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuiha37np.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint startIndex=string.find(substring);\n\
    \tif (startIndex!=string.length()-1)\n\t{\n\t\tint endIndex=string.find(substring,\
    \ startIndex+1);\n\t\tif (endIndex!=-1)\n\t\t{\n\t\t\treturn endIndex-startIndex+1;\n\
    \t\t}\n\t}\n\treturn 0L;\n}\n/* \n Remove all the occurrences of a substring from\
    \ a string.\n    >>> remove_substring(\"aabbaab\", \"ab\")\n    'aabb'\n    >>>\
    \ remove_substring(\"aaaabbb\", \"ab\")\n    'aaa'\n    >>> remove_substring(\"\
    aaaabbb\", \"ab\", 3)\n    'aabb'\n*/\nstring remove_substring(string string,\
    \ string substring, int occurrence)\n{\n\tstring result;\n\tint startIndex=string.find(substring);\n\
    \tif (startIndex!=-1)\n\t{\n\t\tstring temp=string.substr(0, startIndex);\n\t\t\
    int endIndex=string.find(substring, startIndex+1);\n\t\tif (endIndex!=-1)\n\t\t\
    {\n\t\t\tresult=temp+string.substr(startIndex+1, endIndex-occurrence+1);\n\t\t\
    }\n\t\telse\n\t\t{\n\t\t\tresult=temp+string;\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\n Extract a substring from a string at the given start index and end index.\
    \ \n If the end index is omitted, the substring starts from the end of the string.\n\
    \    >>> substring(\"aaaabbb\", \"a\", 2, 3)\n    'b'\n    >>> substring(\"aaaabbb\"\
    , \"a\", 2)\n    'b'\n    >>> substring(\"aaaabbb\", \"a\")\n    ''\n*/\nstring\
    \ substring(string string, string substring, int startIndex, int endIndex)\n{\n\
    \tstring result;\n\tint startIndex=string.find(substring);\n\tif (startIndex!=-1)\n\
    \t{\n\t\tif (endIndex==-1)\n\t\t{\n\t\t\tresult=string.substr(startIndex);\n\t\
    \t}\n\t\telse\n\t\t{\n\t\t\tresult=string.substr(startIndex, endIndex-startIndex);\n\
    \t\t}\n\t}\n\treturn result;\n}\n/*\n Convert a string to a number \n    \n  \
    \  >>> string_to_number(\"123\")\n    123L\n    >>> string_to_number(\"1.3\")\n\
    \    13L\n    >>> string_to_number(\"-1.3\")\n    13L\n    >>> string_to_number(\"\
    123e45\")\n    123e45L\n    >>> string_to_number(\"123e-7\")\n    123.0e-07L\n\
    \    \n*/\nlong string_to_number(string string)\n{\n\tlong result;\n\tstringstream\
    \ ss(string);\n\tss >> result;\n\treturn result;\n}\n/*\n Convert a string to\
    \ a float\n    \n    >>> string_to_float(\"123\")\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfnnqdpth.d(103): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfnnqdpth.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   if (string.length <= substring.length)\n    {\n        count = 0;\n    }\n\
    \    else\n    {\n        string substrings = substring(string, substring);\n\
    \        string strings = substring(string, \"\");\n        long i;\n        for\
    \ (i = 0; i < substrings.length; i++)\n        {\n            count+=strings.length-substrings.length+i;\n\
    \            if (substrings[i] == strings[i])\n            {\n               \
    \ count+=strings.length-substrings.length+i;\n            }\n        }\n    }\n\
    \    return count;\n}\n/*\n Convert a string to lower case\n \n >>> convert_lower_case(\"\
    abcd\")\n \"abcd\"\n >>> convert_lower_case(\"aBcDe\")\n \"aBcDe\"\n >>> convert_lower_case(\"\
    A2B3c4\")\n \"a2b3c4\"\n \n */\nstring convert_lower_case(string string)\n{\n\
    \    string newString = \"\";\n    for (int i = 0; i < string.length; i++)\n \
    \   {\n        if (string[i] < 'A' || string[i] > 'Z')\n        {\n          \
    \  newString += string[i];\n        }\n    }\n    return newString;\n}\n/*\n Convert\
    \ a string to upper case\n \n >>> convert_upper_case(\"abcd\")\n \"ABCD\"\n >>>\
    \ convert_upper_case(\"aBcDe\")\n \"A_BcDe\"\n >>> convert_upper_case(\"A2B3c4\"\
    )\n \"A_2B_3C4\"\n \n */\nstring convert_upper_case(string string)\n{\n    string\
    \ newString = \"\";\n    for (int i = 0; i < string.length; i++)\n    {\n    \
    \    if (string[i] < 'a' || string[i] > 'z')\n        {\n            newString\
    \ += string[i];\n        }\n    }\n    return newString;\n}\n/*\n Find a substring\
    \ in a string that has at most n repetitions.\n \n >>> find_substring(\"abcabc\"\
    , \"abc\", 2)\n \"abc\"\n >>> find_substring(\"abcabc\", \"abc\", 1)\n \"a\"\n\
    \ >>> find_substring(\"abcabc\", \"ab\", 2)\n \"ab\"\n >>> find_substring(\"abcabc\"\
    , \"ab\", 3)\n \"abcabc\"\n >>> find_substring(\"abcabc\", \"bc\", 2)\n \"bc\"\
    \n >>> find_substring(\"abcabc\", \"bc\", 3)\n \"abcabc\"\n >>> find_substring(\"\
    abcabc\", \"bca\", 3)\n \"abcabc\"\n \n */\nstring find_substring(string string,\
    \ string substring, long n)\n{\n    string newString = \"\";\n    for (int i =\
    \ 0; i < string.length; i++)\n    {\n        if (string[i] != substring[0])\n\
    \        {\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpro4h_mxh.d(108): Error: found `unittest` instead of statement

    /tmp/tmpro4h_mxh.d(117): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpro4h_mxh.d(117): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpro4h_mxh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong result = long(0);\n\
    \t\n\tfor(int i = 0;i < string.size() - substring.length();i++)\n\t{\n\t\tif(string.substring\
    \ == substring)\n\t\t{\n\t\t\tresult += 1;\n\t\t}\n\t}\n\treturn result;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps4swq9bk.d(17): Error: no property `size` for type `string`

    /tmp/tmps4swq9bk.d(17): Error: no property `length` for type `string`

    /tmp/tmps4swq9bk.d(19): Error: no property `substring` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps4swq9bk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    int i = 0;\n    int j = 0;\n    \n    while(i < string.length())\n    {\n\
    \        // If we found the substring then add 1 to the result.\n        if (string.substr(i,\
    \ j) == substring)\n            result += 1;\n        \n        // Check if the\
    \ substring is at the beginning of the string.\n        if (i == 0)\n        {\n\
    \            if (string.substr(i, j) == substring)\n                result +=\
    \ 1;\n        }\n        \n        // Check if the substring is at the end of\
    \ the string.\n        if (i == string.length())\n        {\n            if (string.substr(i,\
    \ j) == substring)\n                result += 1;\n        }\n        \n      \
    \  // If we didn't find the substring then move to the next character.\n     \
    \   i += 1;\n        \n        // If the substring is longer than the string then\
    \ continue searching for the next substring.\n        if (string.length() < substring.length())\n\
    \        {\n            i = j;\n            j += 1;\n        }\n    }\n    \n\
    \    return result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp21ogvksw.d(19): Error: no property `length` for type `string`

    /tmp/tmp21ogvksw.d(22): Error: no property `substr` for type `string`

    /tmp/tmp21ogvksw.d(28): Error: no property `substr` for type `string`

    /tmp/tmp21ogvksw.d(33): Error: no property `length` for type `string`

    /tmp/tmp21ogvksw.d(35): Error: no property `substr` for type `string`

    /tmp/tmp21ogvksw.d(43): Error: no property `length` for type `string`

    /tmp/tmp21ogvksw.d(43): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21ogvksw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int pos;\n    int len\
    \ = (int) string.length();\n    string substring2 = substring;\n    long result\
    \ = 0;\n    int index = 0;\n    \n    // If substring is the same length\n   \
    \ if(len == (int)substring.length())\n    {\n        string substring2 = substring;\n\
    \        string str = string;\n        index = -1;\n        \n        for(int\
    \ i = 0; i < len; i++)\n        {\n            if(str.charAt(i) == substring2.charAt(i))\n\
    \            {\n                index++;\n            }\n        }\n        \n\
    \        if(index == 0)\n        {\n            result = 0;\n        }\n     \
    \   else\n        {\n            result = index;\n        }\n    }\n    \n   \
    \ // Substring is the same length, case insensitive\n    else\n    {\n       \
    \ string substring2 = substring.toLower();\n        string str = string.toLowerCase();\n\
    \        index = -1;\n        \n        for(int i = 0; i < len; i++)\n       \
    \ {\n            if(str.charAt(i) == substring2.charAt(i))\n            {\n  \
    \              index++;\n            }\n        }\n        \n        if(index\
    \ == 0)\n        {\n            result = 0;\n        }\n        else\n       \
    \ {\n            result = index;\n        }\n    }\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8egmtqqg.d(16): Error: C style cast illegal, use `cast(int)string.length()`

    /tmp/tmp8egmtqqg.d(22): Error: C style cast illegal, use `cast(int)substring.length()`

    /tmp/tmp8egmtqqg.d(70): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8egmtqqg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int count = 0;\n  \
    \  int current = 0;\n    int end = string.length();\n    while(current <= end){\n\
    \        current = (string[current - 1] == substring[end - 1])?current:current+1;\n\
    \        while(current <= end){\n            if (string[current] == substring[end\
    \ - 1]){\n                count++;\n                current = current+1;\n   \
    \             end--;\n            }\n            else{\n                current\
    \ = (string[current - 1] == substring[end - 1])?current:current+1;\n         \
    \   }\n        }\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_uclbkmt.d(17): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_uclbkmt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   \n    auto it = string.find(substring);\n    if(it!=string.npos)\n    {\n\
    \        count++;\n        while(it!=string.npos)\n        {\n            count\
    \ = overlaps(string, it) ? count + 1 : count;\n            it = string.find(substring,\
    \ it+1);\n        }\n    }\n    \n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd2ifljc3.d(17): Error: no property `find` for type `string`

    /tmp/tmpd2ifljc3.d(18): Error: no property `npos` for type `string`

    /tmp/tmpd2ifljc3.d(21): Error: no property `npos` for type `string`

    /tmp/tmpd2ifljc3.d(23): Error: undefined identifier `overlaps`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd2ifljc3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tfor(int\
    \ i = string.find(substring) + substring.length(); i < string.length(); i++) {\n\
    \t\tif(string[i] != string[i - 1]) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>>\
    \ how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"\
    aa\")\n    2L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string substring2) \n{\n\tlong count = 0;\n\tfor(int i = string.find(substring)\
    \ + substring.length(); i < string.length(); i++) {\n\t\tif(string[i] == substring[0])\
    \ {\n\t\t\tcount += how_many_times(string.substring(i), substring, substring2);\n\
    \t\t}\n\t\tif(string[i] == substring2[0]) {\n\t\t\tcount += how_many_times(string.substring(i),\
    \ substring, substring2);\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    2L\n    \n\
    */\nlong how_many_times(string string, string substring, string substring2, string\
    \ substring3) \n{\n\tlong count = 0;\n\tfor(int i = string.find(substring) + substring.length();\
    \ i < string.length(); i++) {\n\t\tif(string[i] == substring[0]) {\n\t\t\tcount\
    \ += how_many_times(string.substring(i), substring, substring2, substring3);\n\
    \t\t}\n\t\tif(string[i] == substring2[0]) {\n\t\t\tcount += how_many_times(string.substring(i),\
    \ substring, substring2, substring3);\n\t\t}\n\t\tif(string[i] == substring3[0])\
    \ {\n\t\t\tcount += how_many_times(string.substring(i), substring, substring2,\
    \ substring3);\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    2L\n    \n*/\nlong\
    \ how_many_times(string string, string substring, string substring2, string substring3,\
    \ string substring4) \n{\n\tlong count = 0;\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc20o0i5j.d(85): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc20o0i5j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tstring s0 = string;\n\
    \tstring s1 = substring;\n\tif (s0 == \"\" || s1 == \"\") return 0L;\n\tlong count\
    \ = 0;\n\tfor (int i = 0; i < s0.length(); i++) {\n\t\tif (s1.indexOf(s0[i]) >=\
    \ 0) {\n\t\t\tcount += 1;\n\t\t\ts0 = s0.substring(i);\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjwu2tdtx.d(15): Error: `string` is used as a type

    /tmp/tmpjwu2tdtx.d(16): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjwu2tdtx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  long count = 0;\n  int\
    \ i = 0;\n  \n  for (; i < string.length; i++)\n  {\n    if (string.compare(i,\
    \ substring.length, substring, 0, substring.length) == 0)\n    {\n      count++;\n\
    \    }\n  }\n  return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplhnlhzs5.d(20): Error: no property `compare` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplhnlhzs5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    auto iter = string.find(substring);\n\
    \    if (iter == string.length()) \n        return 0;\n    else \n        return\
    \ 1 + how_many_times(string.substr(iter+1), substring);\n}\n</code>\n<|/ a |>\n\
    <| c |>\nPlease add some explanation to your answer. While it might not be as\
    \ clever as some other answers, this one was extremely helpful to me!\n<|/ c |>\n\
    <| c |>\nThanks for your answer! It works, but I got this warning: \" warning:\
    \ implicit conversion loses integer precision: 'std::__1::__wrap_iter<char const\
    \ *>' {aka 'const char *'} to 'int' [-Wshorten-64-to-32]\" when I tried to compile\
    \ my code (which I wrote in my first post). Do you have any idea?\n<|/ c |>\n\
    <| c |>\nThe warning should be fixed. Make sure your compiler supports C++17 (`-std=c++17`).\
    \ Otherwise, just use `__builtin_ctzl` instead (this is an intrinsic function\
    \ from GCC 4.9+)\n<|/ c |>\n<| c |>\nThank you. Unfortunately, it didn't work.\
    \ I get this warning:\n<|/ c |>\n<| c |>\n\"error: \u2018__builtin_ctzl\u2019\
    \ was not declared in this scope\"\n<|/ c |>\n<| a |>\nI implemented a solution\
    \ based on answers, but it needs some optimizations on it. \nIt works well for\
    \ all cases, but some cases are not handled properly\nFor example for the string\
    \ \"a\" and \"aaaa\" it returns \"1\" for \"a\" and \"0\" for \"aaaa\" but \"\
    3\" for \"aaa\" and for \"a\" it returns \"1\" \n<code>\n#include <iostream>\n\
    #include <string>\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq68wk_lc.d(21): Error: declaration expected, not `<`

    /tmp/tmpq68wk_lc.d(33): Error: unterminated character constant

    /tmp/tmpq68wk_lc.d(49): Error: declaration expected, not `assert`

    /tmp/tmpq68wk_lc.d(50): Error: declaration expected, not `assert`

    /tmp/tmpq68wk_lc.d(51): Error: declaration expected, not `assert`

    /tmp/tmpq68wk_lc.d(52): Error: declaration expected, not `assert`

    /tmp/tmpq68wk_lc.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq68wk_lc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long l = 0;\n    long r = string.length() - substring.length;\n    while(r\
    \ > 0) {\n        if (string[l] == substring[r])\n            count++;\n     \
    \   l++;\n        r--;\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,python,c#,algorithm,c++\
    \ |>\n<| a tags=string,python,c#,algorithm,c++ |>\n<code>\ndef count(s, t):\n\
    \    i = j = 0\n    if s == \"\": return 0\n    while i < len(s) and j < len(t):\n\
    \        if s[i:j+1] == t:\n            i += j+1\n            j += 1\n       \
    \ else:\n            i += 1\n    return j\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Why did you change this from counting overlapping characters to counting overlapping\
    \ strings?\n<|/ c |>\n<| a |>\nPython solution:\n<code>\ndef count(s, t):\n  \
    \  i = 0\n    while i < len(s) and i < len(t):\n        if s[i] != t[i]:\n   \
    \         i += 1\n        else:\n            i += 1\n    return i\n</code>\n<|/\
    \ a dscore=1 tags=string,python,c#,algorithm,c++ |>\n<| a dscore=1 tags=string,python,c#,algorithm,c++\
    \ |>\nC# Solution:\n<code>\nclass Program\n{\n    public static void Main(string[]\
    \ args)\n    {\n        string myString = \"Hello\";\n        string mySubString\
    \ = \"llo\";\n        int count = 0;\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpltdp_9rp.d(26): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpltdp_9rp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tint\
    \ i, j;\n\tbool found = false;\n\t\n\tfor(i=string.length()-1; (i>=0) && (!found);\
    \ i--)\n\t{\n\t\tfound = false;\n\t\tfor(j=0; !found && (j<substring.length())\
    \ && (i>=0); j++)\n\t\t{\n\t\t\tfound = string[i+j] == substring[j];\n\t\t}\n\t\
    \tif(found)\n\t\t\tcount++;\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7nstfydd.d(19): Error: no property `length` for type `string`

    /tmp/tmp7nstfydd.d(22): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7nstfydd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long counter = 0;\n\
    \    int start = 0;\n    int end = 0;\n    while(start < string.length())\n  \
    \  {\n        end = string.length();\n        while(end > start && string.find(substring,\
    \ start) > 0) \n        {\n            end = string.find(substring, end);\n  \
    \      }\n        counter += end - start;\n        start = end + 1;\n    }\n \
    \   return counter;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4pqqep0y.d(18): Error: no property `length` for type `string`

    /tmp/tmp4pqqep0y.d(20): Error: no property `length` for type `string`

    /tmp/tmp4pqqep0y.d(21): Error: no property `find` for type `string`

    /tmp/tmp4pqqep0y.d(23): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4pqqep0y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\t\n\
    \tif (string.empty() == false && substring.empty() == false) \n\t{\n\t\tsize_t\
    \ s_len = string.size();\n\t\tsize_t s_start = 0, s_end = 0;\n\t\tsize_t e_len\
    \ = substring.size();\n\t\tsize_t e_start = 0, e_end = 0;\n\t\t\n\t\tfor (size_t\
    \ i = 0; i < s_len && i < e_len; i++) \n\t\t{\n\t\t\tstring substring2;\n\t\t\t\
    \n\t\t\tif (i >= e_start) \n\t\t\t{\n\t\t\t\tsubstring2 = substring.substr(e_start-s_start,e_end-s_start);\n\
    \t\t\t\te_start = e_end+e_len;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsubstring2\
    \ = substring.substr(s_start-e_start,s_end-e_start);\n\t\t\t\ts_start = s_end+s_len;\n\
    \t\t\t}\n\t\t\t\n\t\t\tif (string[i] == substring2[0]) \n\t\t\t{\n\t\t\t\tcount\
    \ += 1;\n\t\t\t\tif (substring2 == \"aa\") \n\t\t\t\t{\n\t\t\t\t\tcount += 2;\n\
    \t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (substring2 == \"aaaa\") \n\t\
    \t\t\t\t{\n\t\t\t\t\t\tcount += 4;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\
    \t\t\t\t\t\tcount += 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif\
    \ (e_start < e_len) \n\t\t{\n\t\t\tstring substring2;\n\t\t\tif (e_end > s_start)\
    \ \n\t\t\t{\n\t\t\t\tsubstring2 = substring.substr(e_start-s_start,e_end-s_start);\n\
    \t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tsubstring2 = substring.substr(s_start-e_start,s_end-e_start);\n\
    \t\t\t}\n\t\t\t\n\t\t\tif (string[s_end] == substring2[0]) \n\t\t\t{\n\t\t\t\t\
    count += 1;\n\t\t\t\tif (substring2 == \"aa\") \n\t\t\t\t{\n\t\t\t\t\tcount +=\
    \ 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (substring2 == \"aaaa\"\
    ) \n\t\t\t\t\t{\n\t\t\t\t\t\tcount += 4;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\
    \t{\n\t\t\t\t\t\tcount += 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\
    \treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n   \
    \ assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxlmf8yjx.d(17): Error: no property `empty` for type `string`

    /tmp/tmpxlmf8yjx.d(17): Error: no property `empty` for type `string`

    /tmp/tmpxlmf8yjx.d(19): Error: no property `size` for type `string`

    /tmp/tmpxlmf8yjx.d(21): Error: no property `size` for type `string`

    /tmp/tmpxlmf8yjx.d(26): Error: `string` is used as a type

    /tmp/tmpxlmf8yjx.d(62): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxlmf8yjx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0, index\
    \ = 0;\n    while ((index = string.find(substring, index)) != string::npos) \n\
    \    {\n        index = string.find(substring, index + 1);\n        count++;\n\
    \    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplud85nob.d(16): Error: found `:` when expecting `)`

    /tmp/tmplud85nob.d(16): Error: found `:` instead of statement

    /tmp/tmplud85nob.d(21): Error: declaration expected, not `return`

    /tmp/tmplud85nob.d(22): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplud85nob.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   size_t pos = 0;\n    while(string[pos] == substring[pos] && pos < string.size())\
    \ \n    {\n        count++;\n        pos++;\n    }\n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpla2_n2lu.d(17): Error: no property `size` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpla2_n2lu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (string.length()\
    \ < substring.length())\n        throw new Exception(\"String length must be greater\
    \ than substring length.\");\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1_exc5e9.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1_exc5e9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  // convert from string\
    \ to char* so we don't have to worry about unicode\n  char[] char_str = string.ToCharArray();\n\
    \  // convert substring to char* so we don't have to worry about unicode\n  char[]\
    \ char_sub = substring.ToCharArray();\n  long num_times = 0L;\n  long i = 1;\n\
    \  while(i < char_str.length)\n  {\n    if (char_str[i] == char_sub[0])\n    {\n\
    \      i++;\n      if (i < char_str.length && char_str[i] == char_sub[0]) // check\
    \ for overlapping cases\n      {\n        char c = char_str[i];\n        while(i\
    \ + 1 < char_str.length && char_str[i + 1] == c) // check for overlapping cases\n\
    \        {\n          i++;\n        }\n      }\n      num_times += 1;\n    }\n\
    \    else \n    {\n      i++;\n    }\n  }\n  return num_times;\n}\n</code>\n<|/\
    \ a dscore=1 tags=c#,algorithm,string |>\n<| c |>\nThis is pretty good, but it\
    \ is not exactly what the OP is asking for. I think he wants to count overlapping\
    \ sub-strings within the entire string.\n<|/ c |>\n<| c |>\nI suspect that overlapping\
    \ sub-strings is the desired output, but it may be misinterpreted.\n<|/ c |>\n\
    <| c |>\nI guessed that too, but the problem statement says: \"count overlaping\
    \ cases\" which could be interpreted to mean overlapping sub-strings.\n<|/ c |>\n\
    <| c |>\nThis solution is good enough, but in addition to this, there should be\
    \ an algorithm to detect the overlap with other string. For example, if we have\
    \ the strings aaa and bbb, the overlapping string is ab where ab should be counted\
    \ 4 times.\n<|/ c |>\n<| a tags=c#,algorithm,string dscore=0 |>\nI used a dictionary\
    \ to store the counts of each sub-string in the original string. I then iterated\
    \ through the dictionary to find the maximum value and the sub-string with that\
    \ max value.\n<code>\nusing System;\nusing System.Collections.Generic;\nusing\
    \ System.Linq;\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwx7gkma4.d(43): Error: declaration expected, not `<`

    /tmp/tmpwx7gkma4.d(61): Error: semicolon expected, not `.`

    /tmp/tmpwx7gkma4.d(61): Error: no identifier for declarator `.Collections.Generic`

    /tmp/tmpwx7gkma4.d(62): Error: semicolon expected, not `.`

    /tmp/tmpwx7gkma4.d(62): Error: no identifier for declarator `.Linq`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwx7gkma4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    string result = \"\"\
    ;\n    long index = 0;\n    for(int i=0; i < string.length(); i++) \n    {\n \
    \       if(string[i] == substring[index]) \n        {\n            string sub\
    \ = string.substr(index, substring.length());\n            \n            for(int\
    \ j=i+1; j < string.length(); j++) \n            {\n                if(string[j]\
    \ != sub[j] && string[i] != sub[j]) \n                {\n                    break;\n\
    \                }\n            }\n            \n            if(string[i] == sub[j]\
    \ && string.length() > substring.length()) \n            {\n                result\
    \ += j - i + 1;\n            }\n            index++;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp95zw8h3e.d(15): Error: `string` is used as a type

    /tmp/tmp95zw8h3e.d(17): Error: no property `length` for type `string`

    /tmp/tmp95zw8h3e.d(21): Error: `string` is used as a type

    /tmp/tmp95zw8h3e.d(21): Error: no property `substr` for type `string`

    /tmp/tmp95zw8h3e.d(23): Error: no property `length` for type `string`

    /tmp/tmp95zw8h3e.d(31): Error: no property `length` for type `string`

    /tmp/tmp95zw8h3e.d(31): Error: no property `length` for type `string`

    /tmp/tmp95zw8h3e.d(33): Error: undefined identifier `j`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp95zw8h3e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   int index1 = 0;\n    int index2 = 0;\n    int i = string.find(substring);\n\
    \    while (i != -1)\n    {\n        i += substring.find(string[index1], i);\n\
    \        i += substring.find(string[index2], i);\n        count++;\n        index1++;\n\
    \        index2++;\n        i = string.find(substring, i);\n    }\n    return\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps9w8cf5_.d(18): Error: no property `find` for type `string`

    /tmp/tmps9w8cf5_.d(21): Error: no property `find` for type `string`

    /tmp/tmps9w8cf5_.d(22): Error: no property `find` for type `string`

    /tmp/tmps9w8cf5_.d(26): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps9w8cf5_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  // TODO: Write a better\
    \ version\n  long count = 0;\n  foreach(char c in string){\n    bool is_substring\
    \ = contains(substring, c);\n    count += (is_substring);\n  }\n  return count;\n\
    }\n// Test it out\nstring str = \"aaaaaabcde\";\nstring sub = \"aa\";\nlong result\
    \ = how_many_times(str, sub);\nprintln(result);\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nI haven't read the question closely, but this is definitely a good\
    \ improvement.  I didn't notice that `how_many_times` didn't return `long`.\n\
    <|/ c |>\n<| c |>\n: Yeah, this was a quick test and I forgot about `long` truncation.\
    \ Added the `long long` version now.\n<|/ c |>\n<| c |>\nThe return type was specified\
    \ as `long`, but it seems it's actually supposed to be `long long`. Also, what\
    \ if the string is very long and the substring is very short? It would be better\
    \ if your function took a `long` instead of a `long long`. If the string is very\
    \ long, the time complexity will be O(n^2), which is not good!\n<|/ c |>\n<| c\
    \ |>\n: Yeah, I realized that too late and fixed it. Also fixed the typo in the\
    \ return type, now it returns a `long long`.\n<|/ c |>\n<| a dscore=3 |>\nUsing\
    \ regular expressions in Boost.Regex:\n<code>\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4i0p19tl.d(17): Error: found `in` when expecting `;`

    /tmp/tmp4i0p19tl.d(27): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp4i0p19tl.d(27): Error: no identifier for declarator `println(result)`

    /tmp/tmp4i0p19tl.d(28): Error: declaration expected, not `<`

    /tmp/tmp4i0p19tl.d(31): Error: unterminated character constant

    /tmp/tmp4i0p19tl.d(31): Error: unterminated character constant

    /tmp/tmp4i0p19tl.d(31): Error: unterminated character constant

    /tmp/tmp4i0p19tl.d(37): Error: unterminated character constant

    /tmp/tmp4i0p19tl.d(49): Error: declaration expected, not `assert`

    /tmp/tmp4i0p19tl.d(50): Error: declaration expected, not `assert`

    /tmp/tmp4i0p19tl.d(51): Error: declaration expected, not `assert`

    /tmp/tmp4i0p19tl.d(52): Error: declaration expected, not `assert`

    /tmp/tmp4i0p19tl.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4i0p19tl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n   long count = 0;\n  \
    \ for (int i=0;i<string.length()-1;i++) {\n      bool found = true;\n      for\
    \ (int j=0;j<substring.length();j++) {\n         if (string[i+j] != substring[j])\
    \ {\n            found = false;\n            break;\n         }\n      }\n   \
    \   if (found)\n         count++;\n   }\n   return count;\n}\n/*\n Given a string,\
    \ find out what kind of string it is (letter, number, symbol, none)\n    \n >>>\
    \ find_type(\"\")\n    'None'\n >>> find_type(\"a\")\n    'Letter'\n >>> find_type(\"\
    1aaa\")\n    'Number'\n >>> find_type(\"1aaa\")\n    'Number'\n >>> find_type(\"\
    a\")\n    'Letter'\n >>> find_type(\"1a\")\n    'Letter'\n >>> find_type(\"1aa\"\
    )\n    'Letter'\n >>> find_type(\"1aa\")\n    'Letter'\n >>> find_type(\"1aa\"\
    )\n    'Letter'\n >>> find_type(\"1a1a\")\n    'Letter'\n >>> find_type(\"1aa1\"\
    )\n    'Letter'\n >>> find_type(\"1aa1\")\n    'Letter'\n >>> find_type(\"1aaaaaa\"\
    )\n    'Symbol'\n >>> find_type(\"1aaaaaa\")\n    'Symbol'\n >>> find_type(\"\
    1aaaaaa\")\n    'Symbol'\n >>> find_type(\"1aaaaaaa\")\n    'Symbol'\n >>> find_type(\"\
    1aaaaaaa\")\n    'Symbol'\n >>> find_type(\"1aaaaaaa\")\n    'Symbol'\n >>> find_type(\"\
    1aaaaaaaa\")\n    'Symbol'\n >>> find_type(\"1aaaaaaaa\")\n    'Symbol'\n >>>\
    \ find_type(\"1aaaaaaaa\")\n    'Symbol'\n >>> find_type(\"1aaaaaaaa\")\n    'Symbol'\n\
    \ >>> find_type(\"1aaaaaaa1\")\n    'Symbol'\n >>> find_type(\"1aaaaaaa1\")\n\
    \    'Symbol'\n >>> find_type(\"1aaaaaaa1\")\n    'Symbol'\n >>> find_type(\"\
    1aaaaaaa11\")\n    'Symbol'\n >>> find_type(\"1aaaaaaa11\")\n    'Symbol'\n >>>\
    \ find_type(\"1aaaaaaa11\")\n    'Symbol'\n >>> find_type(\"1aaaaaaa11\")\n  \
    \  'Symbol'\n >>> find_type(\"1aaaaaaa1111\")\n    'Symbol'\n >>> find_type\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp54ehyh1i.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp54ehyh1i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return string.length()\
    \ - string.find(substring) -\n    (string.find(substring, string.length()) !=\
    \ string.length()) ? 1 : 0;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl3qbx18y.d(15): Error: no property `length` for type `string`

    /tmp/tmpl3qbx18y.d(15): Error: no property `find` for type `string`

    /tmp/tmpl3qbx18y.d(16): Error: no property `find` for type `string`

    /tmp/tmpl3qbx18y.d(16): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl3qbx18y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   int i = string.find(substring);\n    while( i != string.length() - substring.length()\
    \ )\n    {\n        count++;\n        i = string.find(substring, i + 1);\n   \
    \ }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptt7dnxfj.d(16): Error: no property `find` for type `string`

    /tmp/tmptt7dnxfj.d(17): Error: no property `length` for type `string`

    /tmp/tmptt7dnxfj.d(17): Error: no property `length` for type `string`

    /tmp/tmptt7dnxfj.d(20): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptt7dnxfj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  long result = 0;\n  if(string.find(substring)\
    \ == string.npos) \n    return 0L;\n  long len = string.length();\n  long sublen\
    \ = substring.length();\n  long mid = string.length() / 2;\n  string sub = substring;\n\
    \  while(string.find(sub) != string::npos) \n  {\n    if(string.find(sub, mid)\
    \ != string::npos) \n      result++;\n    sub = substring(mid);\n  }\n  return\
    \ result;\n}\n/*\n Find the first occurrence of a substring in a string.\n   \
    \ >>> find_substring(\"\", \"a\")\n    0L\n    >>> find_substring(\"a\", \"aaaa\"\
    )\n    2L\n    \n*/\nlong find_substring(string string, string substring) \n{\n\
    \  long result = 0;\n  if(string.find(substring) == string::npos) \n    return\
    \ -1L;\n  while(string.find(substring) != string::npos) \n  {\n    result++;\n\
    \    string = substring(string.find(substring));\n  }\n  return result;\n}\n/*\n\
    \ Find the first occurrence of a substring in a string in a specific range.\n\
    \    >>> find_substring(\"\", \"a\", \"b\")\n    -1L\n    >>> find_substring(\"\
    a\", \"b\", \"c\");\n    -1L\n    \n*/\nlong find_substring(string string, string\
    \ substring, long offset1, long offset2) \n{\n  if(offset1 < 0 || offset2 < 0)\
    \ \n    return -1L;\n  string str = string;\n  if(string.find(substring) == string::npos)\n\
    \    return -1L;\n  long result = 0;\n  string sub = substring(offset1);\n  while(string.find(sub)\
    \ != string::npos)\n  {\n    if(string.find(sub, offset2) != string::npos) \n\
    \      result++;\n    str = substring(str.find(sub));\n    sub = substring(offset1);\n\
    \  }\n  return result;\n}\n/*\n Find the last occurrence of a substring in a string.\n\
    \    >>> find_substring(\"\", \"a\")\n    0L\n    >>> find_substring(\"a\", \"\
    aaaa\")\n    2L\n    \n*/\nlong find_last_substring(string string, string substring)\
    \ \n{\n  long result = 0;\n  if(string.find(substring) == string::npos)\n    return\
    \ -1L;\n  while(string.find(substring) != string::npos)\n  {\n    result++;\n\
    \    string = substring(string.find(substring));\n  }\n  return result;\n}\n/*\n\
    \ Find the last occurrence of a substring in a string in a specific range.\n \
    \   >>> find_last_substring(\"\", \"a\", \"b\")\n    1L\n    >>> find_last_substring(\"\
    a\", \"b\", \"c\");\n    1L\n    \n*/\nlong find_last_substring(string string,\
    \ \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuyxt9_83.d(22): Error: found `:` when expecting `)`

    /tmp/tmpuyxt9_83.d(22): Error: found `:` instead of statement

    /tmp/tmpuyxt9_83.d(28): Error: declaration expected, not `return`

    /tmp/tmpuyxt9_83.d(29): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuyxt9_83.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long pos = 0;\n   \
    \ long count = 0;\n    long l1 = string.length();\n    long l2 = substring.length();\n\
    \    while(pos < l1)\n    {\n        while(pos < l1 && !(string[pos] == substring[pos])\
    \ && pos < l1)\n        {\n            pos++;\n        }\n        if(pos < l1)\n\
    \        {\n            string temp;\n            temp = string.substr(pos, l1);\n\
    \            string temp2;\n            temp2 = substring.substr(0, l2);\n   \
    \         if(temp == temp2)\n                count++;\n        }\n        pos++;\n\
    \    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjo5_ew7u.d(17): Error: no property `length` for type `string`

    /tmp/tmpjo5_ew7u.d(18): Error: no property `length` for type `string`

    /tmp/tmpjo5_ew7u.d(27): Error: `string` is used as a type

    /tmp/tmpjo5_ew7u.d(29): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjo5_ew7u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  // TODO consider using\
    \ a different algorithm to count overlaps\n  long count = 0L;\n  long pos = 0;\n\
    \  string last = \"\";\n  string current;\n  string current2;\n  string current3;\n\
    \  string substring_2;\n  \n  while ((pos = string.find(substring, pos)) != string::npos)\
    \ {\n    current = string.substr(0, pos);\n    last = current;\n    current2 =\
    \ string.substr(pos);\n    current3 = string.substr(pos + substring.length());\n\
    \    \n    if (current.length() <= substring.length()) {\n      substring_2 =\
    \ substring;\n    } else {\n      substring_2 = current.substr(0, substring.length());\n\
    \    }\n    \n    count += count_overlaps(last, current2, substring_2);\n    count\
    \ += count_overlaps(last, current3, substring_2);\n    pos += substring.length();\n\
    \    \n  }\n  \n  return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdorbsd_0.d(24): Error: found `:` when expecting `)`

    /tmp/tmpdorbsd_0.d(24): Error: found `:` instead of statement

    /tmp/tmpdorbsd_0.d(42): Error: declaration expected, not `return`

    /tmp/tmpdorbsd_0.d(43): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdorbsd_0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tfor\
    \ (auto it = string.begin(); it != string.end(); it++)\n\t{\n\t\tlong start =\
    \ 0;\n\t\tfor (auto it2 = substring.begin(); it2 != substring.end(); it2++)\n\t\
    \t{\n\t\t\tif ((*it) == (char)it2[0])\n\t\t\t{\n\t\t\t\tstart = it2;\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t}\n\t\tif (start != 0)\n\t\t{\n\t\t\tstring substring_start\
    \ = string.substr(start, substring.size());\n\t\t\tif (substring_start.compare(substring)\
    \ == 0)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\
    /*\n Find how many times a given substring can be found in the original string.\
    \ Count all cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring)\n{\n\tlong count = 0;\n\
    \tfor (auto it = string.begin(); it != string.end(); it++)\n\t{\n\t\tlong start\
    \ = 0;\n\t\tfor (auto it2 = substring.begin(); it2 != substring.end(); it2++)\n\
    \t\t{\n\t\t\tif ((*it) == (char)it2[0])\n\t\t\t{\n\t\t\t\tstart = it2;\n\t\t\t\
    \tbreak;\n\t\t\t}\n\t\t}\n\t\tif (start != 0)\n\t\t{\n\t\t\tstring substring_start\
    \ = string.substr(start, substring.size());\n\t\t\tif (substring_start == substring)\n\
    \t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ overlapping cases in reverse order.\n    >>> how_many_times_reverse(\"\", \"\
    a\")\n    0L\n    >>> how_many_times_reverse(\"aaa\", \"a\")\n    3L\n    >>>\
    \ how_many_times_reverse(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times_reverse(string\
    \ string, string substring) \n{\n\tlong count = 0;\n\tfor (auto it = string.rbegin();\
    \ it != string.rend(); it++)\n\t{\n\t\tlong start = 0;\n\t\tfor (auto it2 = substring.rbegin();\
    \ it2 != substring.rend(); it2++)\n\t\t{\n\t\t\tif ((*it) == (char)it2[0])\n\t\
    \t\t{\n\t\t\t\tstart = it2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (start !=\
    \ 0)\n\t\t{\n\t\t\tstring substring_start = string.substr(start, substring.size());\n\
    \t\t\tif (substring_start.\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp36tbqah3.d(21): Error: C style cast illegal, use `cast(char)it2[0]`

    /tmp/tmp36tbqah3.d(56): Error: C style cast illegal, use `cast(char)it2[0]`

    /tmp/tmp36tbqah3.d(91): Error: C style cast illegal, use `cast(char)it2[0]`

    /tmp/tmp36tbqah3.d(101): Error: identifier expected following `.`, not `unittest`

    /tmp/tmp36tbqah3.d(102): Error: found `{` when expecting `)`

    /tmp/tmp36tbqah3.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp36tbqah3.d(110): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp36tbqah3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   size_t index = string.find(substring);\n    while ((index != string::npos)\
    \ && (index < string.length()-1))\n    {\n        count += 1;\n        index =\
    \ string.find(substring, index+1);\n    }\n    return count;\n}\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqtpmh3y_.d(17): Error: found `:` when expecting `)`

    /tmp/tmpqtpmh3y_.d(17): Error: found `:` when expecting `)`

    /tmp/tmpqtpmh3y_.d(17): Error: found `)` when expecting `;` following statement

    /tmp/tmpqtpmh3y_.d(17): Error: found `&&` instead of statement

    /tmp/tmpqtpmh3y_.d(22): Error: declaration expected, not `return`

    /tmp/tmpqtpmh3y_.d(23): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqtpmh3y_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tfor\
    \ (int i = 0; i <= string.length() - substring.length(); ++i) \n\t{\n\t\tif (string[i]\
    \ == substring[0] && string[i + substring.length()] == substring[substring.length()\
    \ - 1]) \n\t\t{\n\t\t\t++count;\n\t\t\ti += substring.length();\n\t\t}\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases in different directions.\n    >>> how_many_times(\"\
    \", \"a\", -1)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", -1)\n    1L\n \
    \   >>> how_many_times(\"aaaa\", \"aa\", -1)\n    1L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, int direction)\n{\n\tlong count = 0;\n\tfor (int i\
    \ = direction == 0? string.length() - substring.length(): 0; i < string.length()\
    \ - substring.length() + direction; ++i)\n\t{\n\t\tif (string[i] == substring[0]\
    \ && string[i + substring.length()] == substring[substring.length() - 1]) \n\t\
    \t{\n\t\t\t++count;\n\t\t\ti += substring.length();\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*\n Find how many times a given substring can be found in the original string.\
    \ Count overlaping cases in different directions.\n    >>> how_many_times(\"\"\
    , \"a\", 2)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", 2)\n    2L\n    >>>\
    \ how_many_times(\"aaaa\", \"aa\", 2)\n    2L\n    \n*/\nlong how_many_times(string\
    \ string, string substring, int direction, bool search_backwards)\n{\n\tlong count\
    \ = 0;\n\tfor (int i = direction == 0? string.length() - substring.length(): 0;\
    \ i < string.length() - substring.length() + direction; ++i)\n\t{\n\t\tif (string[i]\
    \ == substring[0] && string[i + substring.length()] == substring[substring.length()\
    \ - 1]) \n\t\t{\n\t\t\t++count;\n\t\t\ti += substring.length();\n\t\t}\n\t}\n\t\
    if (search_backwards) \n\t{\n\t\tfor (int i = direction == 0? 0: string.length()\
    \ - substring.length(): 0; i < string.length() - substring.length() + direction;\
    \ ++i)\n\t\t{\n\t\t\tif (string[string.length() - i - 1] == substring[0] && string[string.length()\
    \ - i - substring.length() - 1] == substring[substring.length() - 1]) \n\t\t\t\
    {\n\t\t\t\t++count;\n\t\t\t\ti -= substring.length();\n\t\t\t}\n\t\t}\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases in different directions.\n    >>> how_many_times(\"\
    \", \"a\", 3, False)\n\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwg24p3pr.d(72): Error: semicolon expected, not `:`

    /tmp/tmpwg24p3pr.d(72): Error: expression expected, not `:`

    /tmp/tmpwg24p3pr.d(72): Error: found `0` when expecting `;` following `for` condition

    /tmp/tmpwg24p3pr.d(72): Error: expression expected, not `;`

    /tmp/tmpwg24p3pr.d(72): Error: found `i` when expecting `)`

    /tmp/tmpwg24p3pr.d(72): Error: found `<` instead of statement

    /tmp/tmpwg24p3pr.d(72): Error: found `)` when expecting `;` following statement

    /tmp/tmpwg24p3pr.d(83): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwg24p3pr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    string result = \"\"\
    ;\n    int i = 0;\n    int j = 0;\n    int counter = 0;\n    size_t len = string.length();\n\
    \    size_t lensub = substring.length();\n    for(;i<len;i++)\n    {\n       \
    \ for(;j<lensub;j++)\n        {\n            if(string[i]==substring[j])\n   \
    \         {\n                counter++;\n                j++;\n            }\n\
    \            else\n            {\n                counter = 0;\n             \
    \   break;\n            }\n        }\n        if(counter==lensub)\n        {\n\
    \            result+=string[i];\n            counter = 0;\n        }\n       \
    \ \n    }\n    return string.length() - result.length();\n}\nunittest\n{\n   \
    \ alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdv__c7ij.d(15): Error: `string` is used as a type

    /tmp/tmpdv__c7ij.d(19): Error: no property `length` for type `string`

    /tmp/tmpdv__c7ij.d(20): Error: no property `length` for type `string`

    /tmp/tmpdv__c7ij.d(43): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdv__c7ij.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   int pos = 0;\n    while(pos < string.length()) {\n        int pos_next = string.find(substring,\
    \ pos);\n        if(pos_next == string.length())\n            break;\n       \
    \ if(pos_next == pos) {\n            count++;\n        }\n        pos = pos_next;\n\
    \    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjmaqe7zj.d(17): Error: no property `length` for type `string`

    /tmp/tmpjmaqe7zj.d(18): Error: no property `find` for type `string`

    /tmp/tmpjmaqe7zj.d(19): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjmaqe7zj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int count = 0;\n  \
    \  int endindex = string.find(substring);\n    while (endindex != string.length()\
    \ - 1)\n    {\n        if ((string.find(substring, endindex) != string.length()\
    \ - 1) && (endindex > 0))\n        {\n            count++;\n        }\n      \
    \  endindex = string.find(substring, endindex + 1);\n    }\n    return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1le5ucg6.d(16): Error: no property `find` for type `string`

    /tmp/tmp1le5ucg6.d(17): Error: no property `length` for type `string`

    /tmp/tmp1le5ucg6.d(19): Error: no property `find` for type `string`

    /tmp/tmp1le5ucg6.d(19): Error: no property `length` for type `string`

    /tmp/tmp1le5ucg6.d(23): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1le5ucg6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tlong\
    \ len = string.length();\n\tlong i = len-1;\n\twhile(i >= 0) {\n\t\tlong ls =\
    \ string.find_first_of(substring, i);\n\t\tif (ls == -1) {\n\t\t\tbreak;\n\t\t\
    }\n\t\ti += ls + 1;\n\t\t++count;\n\t}\n\treturn count;\n}\n//#include \"std.string\"\
    \n/*\n Given a string, return an array of integers containing the number of occurrences\
    \ of each character in the string. \n    >>> char_count(\"a\")\n    [0, 0, 0]\n\
    \    >>> char_count(\"ab\")\n    [2, 0]\n    >>> char_count(\"aba\")\n    [3,\
    \ 2, 1]\n*/\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc5uxk_m0.d(16): Error: no property `length` for type `string`

    /tmp/tmpc5uxk_m0.d(19): Error: no property `find_first_of` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc5uxk_m0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if(string == substring)\
    \ return 0L;\n    string search = substring;\n    search = replace(search, \"\
    a\", \"\");\n    search = replace(search, \"b\", \"\");\n    search = replace(search,\
    \ \"c\", \"\");\n    search = replace(search, \"d\", \"\");\n    search = replace(search,\
    \ \"e\", \"\");\n    search = replace(search, \"f\", \"\");\n    search = replace(search,\
    \ \"g\", \"\");\n    search = replace(search, \"h\", \"\");\n    search = replace(search,\
    \ \"i\", \"\");\n    search = replace(search, \"j\", \"\");\n    search = replace(search,\
    \ \"k\", \"\");\n    search = replace(search, \"l\", \"\");\n    search = replace(search,\
    \ \"m\", \"\");\n    search = replace(search, \"n\", \"\");\n    search = replace(search,\
    \ \"o\", \"\");\n    search = replace(search, \"p\", \"\");\n    search = replace(search,\
    \ \"q\", \"\");\n    search = replace(search, \"r\", \"\");\n    search = replace(search,\
    \ \"s\", \"\");\n    search = replace(search, \"t\", \"\");\n    search = replace(search,\
    \ \"u\", \"\");\n    search = replace(search, \"v\", \"\");\n    search = replace(search,\
    \ \"w\", \"\");\n    search = replace(search, \"x\", \"\");\n    search = replace(search,\
    \ \"y\", \"\");\n    search = replace(search, \"z\", \"\");\n    search = replace(search,\
    \ \"0\", \"\");\n    search = replace(search, \"1\", \"\");\n    search = replace(search,\
    \ \"2\", \"\");\n    search = replace(search, \"3\", \"\");\n    search = replace(search,\
    \ \"4\", \"\");\n    search = replace(search, \"5\", \"\");\n    search = replace(search,\
    \ \"6\", \"\");\n    search = replace(search, \"7\", \"\");\n    search = replace(search,\
    \ \"8\", \"\");\n    search = replace(search, \"9\", \"\");\n    search = replace(search,\
    \ \"+\", \"\");\n    search = replace(search, \"-\", \"\");\n    search = replace(search,\
    \ \".\", \"\");\n    search = replace(search, \"/\", \"\");\n    search = replace(search,\
    \ \";\", \"\");\n    search = replace(search, \"%\", \"\");\n    search = replace(search,\
    \ \"\\\\\", \"\");\n    search = replace(search, \"'\", \"\");\n    search = replace(search,\
    \ \" \", \"\");\n    search = replace(search, \"[\", \"\");\n    search = replace(search,\
    \ \"]\", \"\");\n    search = replace(search, \"{\", \"\");\n    search = replace(search,\
    \ \"}\", \"\");\n    search = replace(search, \"(\"\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1u14samv.d(67): Error: found `unittest` when expecting `,`

    /tmp/tmp1u14samv.d(76): Error: found `void` when expecting `,`

    /tmp/tmp1u14samv.d(76): Error: found `{` when expecting `,`

    /tmp/tmp1u14samv.d(76): Error: expression expected, not `}`

    /tmp/tmp1u14samv.d(76): Error: found `End of File` when expecting `,`

    /tmp/tmp1u14samv.d(76): Error: found `End of File` when expecting `)`

    /tmp/tmp1u14samv.d(76): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmp1u14samv.d(76): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1u14samv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long number_of_times\
    \ = 0L;\n    int string_length = string.length();\n    for(int i = 0; i < string_length;\
    \ i++)\n    {\n        int string_pos = i;\n        int substring_length = substring.length();\n\
    \        for(int j = 0; j < substring_length; j++)\n        {\n            if(string[string_pos]\
    \ == substring[j])\n            {\n                string_pos++;\n           \
    \     j++;\n            }\n            else\n            {\n                break;\n\
    \            }\n        }\n        if(string_pos == string_length && i == string_length\
    \ - 1)\n        {\n            number_of_times++;\n        }\n    }\n    return\
    \ number_of_times;\n}\n</code>\n<|/ a dscore=2 tags=string,c++,search,algorithm\
    \ |>\n<| c |>\nWhy do you declare string_length at every iteration? You redefine\
    \ string_length at every iteration of the loop. Also, your code doesn't work because\
    \ string_pos will never reach string_length.\n<|/ c |>\n<| c |>\nThe code does\
    \ work. I ran it before answering. It doesn't matter if the declaration is in\
    \ or outside the loop.\n<|/ c |>\n<| c |>\nI edited it because I forgot to change\
    \ the string_length inside the loop.\n<|/ c |>\n<| c |>\nI still think it's a\
    \ bad idea to change the length of string inside the loop. You should use an additional\
    \ variable to store the length of the original string and increment it instead\
    \ of changing the length of the string inside the loop.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing out the mistake. I have edited my code to reflect that.\n<|/ c\
    \ |>\n<| a dscore=2 tags=string,c++,search,algorithm |>\nThis code will perform\
    \ better and is also a bit more readable (although not as pretty as other answers):\n\
    <code>\n#include <string>\n#include <iostream>\n#include <algorithm>\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpks6qbn_c.d(40): Error: declaration expected, not `<`

    /tmp/tmpks6qbn_c.d(43): Error: unterminated character constant

    /tmp/tmpks6qbn_c.d(46): Error: unterminated character constant

    /tmp/tmpks6qbn_c.d(52): Error: unterminated character constant

    /tmp/tmpks6qbn_c.d(67): Error: declaration expected, not `assert`

    /tmp/tmpks6qbn_c.d(68): Error: declaration expected, not `assert`

    /tmp/tmpks6qbn_c.d(69): Error: declaration expected, not `assert`

    /tmp/tmpks6qbn_c.d(70): Error: declaration expected, not `assert`

    /tmp/tmpks6qbn_c.d(71): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpks6qbn_c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tint\
    \ len = string.length();\n\tfor(int i = 0; i < len; ++i)\n\t{\n\t\tint j = string.find(substring,\
    \ i);\n\t\tif((j >= 0) && ((j + substring.length()) == len))\n\t\t\tcount++;\n\
    \t\ti += substring.length();\n\t}\n\treturn count;\n}\n/*\n Find how many times\
    \ a given substring can be found in the original string. Count all cases.\n  \
    \  >>> how_many_times_all(\"a\", \"\")\n    0L\n    >>> how_many_times_all(\"\
    a\", \"a\")\n    1L\n    >>> how_many_times_all(\"aa\", \"a\")\n    1L\n    >>>\
    \ how_many_times_all(\"aaa\", \"a\")\n    2L\n*/\nlong how_many_times_all(string\
    \ string, string substring) \n{\n\tlong count = 0;\n\tint len = string.length();\n\
    \tfor(int i = 0; i < len; ++i)\n\t{\n\t\tint j = string.find(substring, i);\n\t\
    \tif((j >= 0) && ((j + substring.length()) == len))\n\t\t\tcount++;\n\t}\n\treturn\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count all cases including overlaping cases.\n    >>> how_many_times_all_overlap(\"\
    a\", \"\")\n    0L\n    >>> how_many_times_all_overlap(\"a\", \"a\")\n    1L\n\
    \    >>> how_many_times_all_overlap(\"aa\", \"a\")\n    1L\n    >>> how_many_times_all_overlap(\"\
    aaa\", \"a\")\n    2L\n*/\nlong how_many_times_all_overlap(string string, string\
    \ substring) \n{\n\tlong count = 0;\n\tint len = string.length();\n\tfor(int i\
    \ = 0; i < len; ++i)\n\t{\n\t\tint j = string.find(substring, i);\n\t\tif((j >=\
    \ 0) && ((j + substring.length()) == len))\n\t\t\tcount++;\n\t\ti++;\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count all cases including overlaping cases.\n    >>> how_many_times_all_overlap_overlap(\"\
    a\", \"\")\n    0L\n    >>> how_many_times_all_overlap_overlap(\"a\", \"a\")\n\
    \    1L\n    >>> how_many_times_all_overlap_overlap(\"aa\", \"a\")\n    1L\n \
    \   >>> how_many_times_all_overlap_overlap(\"aaa\", \"a\")\n    2L\n*/\nlong how_many_times_all_overlap_overlap(string\
    \ string, string substring) \n{\n\tlong count = 0;\n\tint len = string.length();\n\
    \tfor(int i = 0; i < \nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplar_e79o.d(89): Error: expression expected, not `unittest`

    /tmp/tmplar_e79o.d(90): Error: found `{` when expecting `;` following `for` condition

    /tmp/tmplar_e79o.d(91): Error: expression expected, not `alias`

    /tmp/tmplar_e79o.d(91): Error: found `candidate` when expecting `)`

    /tmp/tmplar_e79o.d(91): Error: found `=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplar_e79o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  int lenSubstring = string.length();\n\
    \  int lenString = string.length();\n  int currentIndex = 0;\n  long count = long.MaxValue;\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcv3qr88y.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcv3qr88y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint count = 0;\n\tint\
    \ length = string.Length;\n\tint substringLength = substring.Length;\n\tint i;\n\
    \tint j;\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjrsr0558.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjrsr0558.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint i, j, c=0, m=0;\n\
    \tlong count = 0;\n\tfor(i = 0; i < string.length(); i++)\n\t{\n\t\tfor(j = 0;\
    \ j < substring.length(); j++)\n\t\t{\n\t\t\tif(i == 0 && j == 0)\n\t\t\t\tcontinue;\n\
    \t\t\telse if(i == 0)\n\t\t\t\tbreak;\n\t\t\telse if(i == string.length() - 1\
    \ && j == substring.length() - 1)\n\t\t\t\tbreak;\n\t\t\telse if(string[i-1] ==\
    \ substring[j-1])\n\t\t\t\tc++;\n\t\t}\n\t\tif(c == substring.length())\n\t\t\
    {\n\t\t\tm++;\n\t\t\tc = 0;\n\t\t}\n\t}\n\tcount = substring.length() * m;\n\t\
    return count;\n}\n/*\n Remove all spaces from a string\n    >>> remove_spaces(\"\
    \")\n    ''\n    >>> remove_spaces(\"  \")\n    ''\n    >>> remove_spaces(\"a\
    \ b c\")\n    'abc'\n*/\nstring remove_spaces(string string) \n{\n\tstring t =\
    \ string;\n\tsize_t pos = 0;\n\twhile(pos < t.length() && t[pos] == ' ') pos++;\n\
    \tif(pos < t.length()) \n\t\tt.erase(pos, t.length() - pos);\n\treturn t;\n}\n\
    /*\n Get the index of the first occurrence of the substring in string, or -1 if\
    \ none is found.\n    >>> get_substring_index(\"\", \"\")\n    0L\n    >>> get_substring_index(\"\
    \", \"a\")\n    0L\n    >>> get_substring_index(\"\", \"b\")\n    1L\n    >>>\
    \ get_substring_index(\"\", \"aa\")\n    2L\n    >>> get_substring_index(\"\"\
    , \"ab\")\n    -1L\n    >>> get_substring_index(\"a\", \"ab\")\n    0L\n    \n\
    */\nlong get_substring_index(string string, string substring) \n{\n\tint i, pos\
    \ = 0;\n\tlong count = 0;\n\tfor(i = 0; i < string.length(); i++)\n\t{\n\t\tpos\
    \ = string.find(substring, pos);\n\t\tif(pos == -1)\n\t\t\tbreak;\n\t\tpos++;\n\
    \t}\n\treturn pos;\n}\n/*\n Get the last index of the first occurrence of the\
    \ substring in string, or -1 if none is found.\n    >>> get_last_substring_index(\"\
    \", \"\")\n    0L\n    >>> get_last_substring_index(\"\", \"a\")\n    0L\n   \
    \ >>> get_last_substring_index(\"\", \"b\")\n    1L\n    >>> get_last_substring_index(\"\
    \", \"aa\")\n    2L\n    >>> get_last_substring_index(\"\", \"ab\")\n    -1L\n\
    \    >>> get_last_substring_index(\"a\", \"ab\")\n    0L\n    \n*/\nlong get_last_substring_index(string\
    \ string, string substring) \n{\n\tint i, pos = 0;\n\tlong count = 0;\n\tfor(i\
    \ = 0; i < string.length(); i++)\n\t{\n\t\tpos = \nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpurgy029d.d(109): Error: expression expected, not `unittest`

    /tmp/tmpurgy029d.d(110): Error: found `{` when expecting `;` following statement

    /tmp/tmpurgy029d.d(118): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpurgy029d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if(string.length()\
    \ <= substring.length()){\n        return 0;\n    }\n    string result = string;\n\
    \    int i = 1;\n    int n = string.length();\n    while(i < n)\n    {\n     \
    \   i++;\n        int j = i;\n        int k = 0;\n        while(j < n && k < substring.length())\n\
    \        {\n            if(string[j] == substring[k])\n            {\n       \
    \         k++;\n                j++;\n            }\n            else\n      \
    \      {\n                k = 0;\n            }\n        }\n        if(k == substring.length())\n\
    \        {\n            result += string[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9rlsyvjt.d(15): Error: no property `length` for type `string`

    /tmp/tmp9rlsyvjt.d(15): Error: no property `length` for type `string`

    /tmp/tmp9rlsyvjt.d(18): Error: `string` is used as a type

    /tmp/tmp9rlsyvjt.d(20): Error: no property `length` for type `string`

    /tmp/tmp9rlsyvjt.d(26): Error: no property `length` for type `string`

    /tmp/tmp9rlsyvjt.d(38): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9rlsyvjt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long index = 0;\n    for (index = 0; string[index]; ++index)\n        if (string[index]\
    \ == substring[0]) \n            count++;\n        else if (string[index] == substring[1])\n\
    \        {\n            if (++index >= string.length) \n                break;\n\
    \            count += how_many_times(string.substr(index), substring);\n     \
    \   }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy4wduhdc.d(24): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy4wduhdc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long n = 0;\n    for\
    \ (int i = 0; i < string.length(); i++)\n    {\n        if (string.compare(string[i],\
    \ substring) == 0)\n            ++n;\n    }\n    return n;\n}\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3ingu0s8.d(16): Error: no property `length` for type `string`

    /tmp/tmp3ingu0s8.d(18): Error: no property `compare` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3ingu0s8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int n = string.length();\n\
    \    if (substring.length() <= n) return 0;\n    long count = 0;\n    bool isFound\
    \ = false;\n    for (int i = 0, imax = string.length() - substring.length() +\
    \ 1; i < imax; ++i) {\n        if (string.substring(i, i + substring.length())\
    \ == substring) {\n            count += 1;\n            isFound = true;\n    \
    \        break;\n        }\n    }\n    if (!isFound) {\n        string reverseString\
    \ = string;\n        reverseString.reverse();\n        for (int i = 0, imax =\
    \ substring.length() - 1; i < imax; ++i) {\n            if (reverseString.substring(i,\
    \ i + substring.length()) == substring) {\n                count += 1;\n     \
    \           break;\n            }\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=c#,python |>\n<| c |>\nThis does not answer the question. The OP asked\
    \ how to count overlapping occurrences of characters, not how often a substring\
    \ exists in a string.\n<|/ c |>\n<| a |>\nAnother approach is using the String.IndexOfAny()\
    \ method to find all matches of the substring then increment the counter if it\
    \ exists in a string. \n<code>\nstring str = \"aaabbbccd\";\nstring substring\
    \ = \"aa\";\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphh2nnuek.d(38): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphh2nnuek.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong howmany = 0;\n\t\
    int len = string.length() - substring.length();\n\tfor (int i = 0; i < len; i++)\n\
    \t{\n\t\tif (string.charAt(i) == substring.charAt(i))\n\t\t{\n\t\t\thowmany++;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tif (string.charAt(i) == substring.charAt(len - (i\
    \ + 1)))\n\t\t\t{\n\t\t\t\thowmany++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\
    if (string.charAt(i) == substring.charAt(0))\n\t\t\t\t{\n\t\t\t\t\thowmany++;\n\
    \t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (string.charAt(i) == substring.charAt(len\
    \ - (len - (i - 1))))\n\t\t\t\t\t{\n\t\t\t\t\t\thowmany++;\n\t\t\t\t\t}\n\t\t\t\
    \t}\n\t\t\t}\n\t\t}\n\t}\n\treturn howmany;\n}\n/*\n Given a substring and a string,\
    \ return a new string in which all characters have been repeated the exact number\
    \ of times.\n    >>> repeat_string(\"ab\", \"ababab\")\n    \"abababababababababababababab\"\
    \n*/\nstring repeat_string(string substring, string string)\n{\n\tint length =\
    \ 0;\n\tbool found = false;\n\tfor (int i = 0; i < string.length(); i++)\n\t{\n\
    \t\tif (string.charAt(i) == substring.charAt(0))\n\t\t{\n\t\t\tfound = true;\n\
    \t\t\tlength = 1;\n\t\t}\n\t\telse if (string.charAt(i) == substring.charAt(1))\n\
    \t\t{\n\t\t\tlength++;\n\t\t}\n\t\telse if (string.charAt(i) == substring.charAt(length))\n\
    \t\t{\n\t\t\tlength++;\n\t\t}\n\t\telse if (!found)\n\t\t{\n\t\t\treturn string\
    \ + string;\n\t\t}\n\t}\n\treturn string;\n}\n/*\n Given two strings, return a\
    \ new string in which all characters from string have been repeated the exact\
    \ number of times.\n    >>> repeat_string(\"ab\", \"ababab\")\n    \"abababababababababababababab\"\
    \n*/\nstring repeat_string2(string substring, string string)\n{\n\tint length\
    \ = 0;\n\tbool found = false;\n\tfor (int i = 0; i < string.length(); i++)\n\t\
    {\n\t\tif (string.charAt(i) == substring.charAt(length))\n\t\t{\n\t\t\tlength++;\n\
    \t\t}\n\t\telse if (string.charAt(i) == substring.charAt(0))\n\t\t{\n\t\t\tlength\
    \ = 1;\n\t\t\tfound = true;\n\t\t}\n\t\telse if (!found)\n\t\t{\n\t\t\treturn\
    \ string + string;\n\t\t}\n\t}\n\treturn string;\n}\n/*\n Given a string and a\
    \ number, return a new string in which all characters have been repeated the exact\
    \ number of times.\n    >>> repeat_string(\"ab\", 2)\n    \"ababab\"\n*/\nstring\
    \ repeat_string3(string string, int number)\n{\n\tstring result = \"\";\n\tint\
    \ length = 0;\n\tbool found = false;\n\tfor (int i = 0; i < string.length(); i++)\n\
    \t{\n\t\tif (string.charAt(\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8khcf_09.d(118): Error: expression expected, not `unittest`

    /tmp/tmp8khcf_09.d(119): Error: found `{` when expecting `,`

    /tmp/tmp8khcf_09.d(120): Error: expression expected, not `alias`

    /tmp/tmp8khcf_09.d(120): Error: found `candidate` when expecting `,`

    /tmp/tmp8khcf_09.d(120): Error: expression expected, not `=`

    /tmp/tmp8khcf_09.d(120): Error: found `how_many_times` when expecting `,`

    /tmp/tmp8khcf_09.d(120): Error: expression expected, not `;`

    /tmp/tmp8khcf_09.d(122): Error: found `assert` when expecting `,`

    /tmp/tmp8khcf_09.d(122): Error: found `;` when expecting `,`

    /tmp/tmp8khcf_09.d(123): Error: found `;` when expecting `,`

    /tmp/tmp8khcf_09.d(124): Error: found `;` when expecting `,`

    /tmp/tmp8khcf_09.d(125): Error: found `;` when expecting `,`

    /tmp/tmp8khcf_09.d(126): Error: expression expected, not `}`

    /tmp/tmp8khcf_09.d(127): Error: found `void` when expecting `,`

    /tmp/tmp8khcf_09.d(127): Error: found `{` when expecting `,`

    /tmp/tmp8khcf_09.d(127): Error: expression expected, not `}`

    /tmp/tmp'
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0, i =\
    \ string.find(substring);\n    while (i>=0) {\n        count++;\n        i = string.find(substring,\
    \ i+1);\n    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpla9cdah1.d(15): Error: no property `find` for type `string`

    /tmp/tmpla9cdah1.d(18): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpla9cdah1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int count = 0;\n  \
    \  string p = string;\n    long len = string.length();\n    \n    while (p !=\
    \ substring) {\n        p = p.substr(0, p.length() - 1);\n        len--;\n   \
    \ }\n    \n    while (p != string) {\n        p = p.substr(0, p.length() - 1);\n\
    \        count++;\n    }\n    return count;\n}\n</code>\n<|/ a tags=algorithm\
    \ |>\n<| c |>\nI'm a bit confused -- why `string.length() - 1` instead of just\
    \ `string.length()`?\n<|/ c |>\n<| c |>\nBecause if the string was the empty string\
    \ then `string.length()` is 0.\n<|/ c |>\n<| a tags=algorithm |>\nThis works by\
    \ checking every substring against the entire string and adding 1 each time that\
    \ string occurs.\n<code>\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnyatdclt.d(30): Error: declaration expected, not `<`

    /tmp/tmpnyatdclt.d(33): Error: unterminated character constant

    /tmp/tmpnyatdclt.d(45): Error: declaration expected, not `assert`

    /tmp/tmpnyatdclt.d(46): Error: declaration expected, not `assert`

    /tmp/tmpnyatdclt.d(47): Error: declaration expected, not `assert`

    /tmp/tmpnyatdclt.d(48): Error: declaration expected, not `assert`

    /tmp/tmpnyatdclt.d(49): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnyatdclt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   size_t pos = 0;\n    while(pos < string.length())\n    {\n        size_t endpos\
    \ = string.find(substring, pos);\n        if(endpos != string.length())\n    \
    \    {\n            count += 1;\n            pos = endpos + substring.length();\n\
    \        }\n        else\n        {\n            pos = string.length();\n    \
    \    }\n    }\n    return count;\n}\n/*\n Find if one string is contained in another.\
    \ Case insensitive.\n    >>> contains_substring(\"abcdefg\", \"abc\")\n    True\n\
    \    >>> contains_substring(\"abcdefg\", \"bcd\")\n    False\n    \n*/\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoulsvi35.d(17): Error: no property `length` for type `string`

    /tmp/tmpoulsvi35.d(19): Error: no property `find` for type `string`

    /tmp/tmpoulsvi35.d(20): Error: no property `length` for type `string`

    /tmp/tmpoulsvi35.d(23): Error: no property `length` for type `string`

    /tmp/tmpoulsvi35.d(27): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoulsvi35.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t len = string.length();\n\
    \    size_t n1 = substring.length();\n    size_t n2 = substring.length();\n  \
    \  long count = 0;\n    \n    size_t start = 0, end = 0;\n    while(start < len)\
    \ {\n        end = string.find(substring, start);\n        \n        if(end ==\
    \ string::npos) {\n            return count;\n        }\n        \n        count\
    \ += end - start;\n        start = end + n2;\n    }\n    return count;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThat doesn't do overlapped cases.\n<|/ c |>\n<| c |>\n: I didn't\
    \ look at the example cases, but I suspect that they were all covered.\n<|/ c\
    \ |>\n<| c |>\nYou're right, I missed the overlapped cases.  I edited my answer.\n\
    <|/ c |>\n<| c |>\nOh that is really nice. I will try this one. Thanks\n<|/ c\
    \ |>\n<| c |>\nYou don't have to make a new string if you just want to increment\
    \ a variable. `count++;` will do fine and I believe that the compiler would optimize\
    \ that even further.\n<|/ c |>\n<| a tags=c++,algorithm,python |>\nThis seems\
    \ to work quite well - it's fast and doesn't do all the complicated logic for\
    \ the edge cases (it finds the overlapping substrings twice).\n<code>\n>>> def\
    \ how_many_times(string, substring):\n...     count = 0\n...     for c in string:\n\
    ...         if substring in string:\n...             count = string.count(substring)\n\
    ...             break\n...         elif c in substring:\n...             count\
    \ += 1\n...             substring = substring.replace(c, \"\")\n...     return\
    \ count\n... \n>>> how_many_times(\"ab\", \"bc\")\n2\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nOh that is really nice. I will try this one. Thanks\n<|/ c |>\n\
    <| c |>\nThis is not an efficient way to do it.  It will take O(n^2) time in the\
    \ worst case.\n<|/ c |>\n<| c |>\n- What do you suggest as an improvement?\n<|/\
    \ c |>\n<| c |>\nThe best answer would be to give a correct answer with O(n) runtime\
    \ and O(n) space.  I doubt it's possible to get better than that.\n<|/ c |>\n\
    <| c |>\n: In that case, my answer below should be used.\n<|/ c |>\n<| a dscore=1\
    \ |>\n\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfhhrqlaf.d(24): Error: found `:` when expecting `)`

    /tmp/tmpfhhrqlaf.d(24): Error: found `:` instead of statement

    /tmp/tmpfhhrqlaf.d(31): Error: declaration expected, not `return`

    /tmp/tmpfhhrqlaf.d(32): Error: unrecognized declaration

    /tmp/tmpfhhrqlaf.d(36): Error: unterminated character constant

    /tmp/tmpfhhrqlaf.d(39): Error: unterminated character constant

    /tmp/tmpfhhrqlaf.d(42): Error: unterminated character constant

    /tmp/tmpfhhrqlaf.d(48): Error: unterminated character constant

    /tmp/tmpfhhrqlaf.d(51): Error: unterminated character constant

    /tmp/tmpfhhrqlaf.d(51): Error: unterminated character constant

    /tmp/tmpfhhrqlaf.d(78): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfhhrqlaf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count;\n    if\
    \ (string.empty())\n        return 0;\n    if (substring.empty())\n        return\
    \ string.count(substring);\n    string first_half = string.substr(0, string.find(substring));\n\
    \    string last_half = string.substr(string.find(substring) + substring.length());\n\
    \    count = first_half.count(substring);\n    if (first_half.empty())\n     \
    \   return count;\n    count = first_half.count(substring) + count;\n    return\
    \ count + how_many_times(last_half, substring);\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nNice idea but the OP said he wanted the result to be a `long` which doesn't\
    \ allow for multiple occurrences.\n<|/ c |>\n<| c |>\n- Yes, I realized that,\
    \ and updated the solution. Thanks for the suggestion!\n<|/ c |>\n<| a tags=algorithm,string,search,java,data-structures\
    \ dscore=1 |>\nThe OP asked for a solution that doesn't use regex. Here is a solution\
    \ using String methods and some simple recursion.\n<code>\npublic long howManyTimes(String\
    \ s, String p)\n{\n    if (s == null || s == p)\n        return 1;\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0doohmv2.d(28): Error: declaration expected, not `<`

    /tmp/tmp0doohmv2.d(31): Error: unterminated character constant

    /tmp/tmp0doohmv2.d(37): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0doohmv2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint result = 0;\n\tint\
    \ l1 = string.find(substring);\n\tif(l1 != -1){\n\t\tint l2 = string.find(substring,\
    \ l1+1);\n\t\twhile(l2 != -1 && l2 != l1){\n\t\t\tl1++;\n\t\t\tl2++;\n\t\t\tresult++;\n\
    \t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmv97u8ma.d(16): Error: no property `find` for type `string`

    /tmp/tmpmv97u8ma.d(18): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmv97u8ma.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    return string.length()\
    \ - string.toLowerCase().indexOf(substring.toLowerCase()) - string.toLowerCase().indexOf(string.toLowerCase(),\
    \ string.toLowerCase().indexOf(substring) + substring.length());\n}\n</code>\n\
    <|/ a tags=algorithm,c++ |>\n<| c |>\nYour solution assumes case-insensitivity,\
    \ which may not be the case. See my answer.\n<|/ c |>\n<| c |>\nI edited the answer\
    \ to include a case insensitive search. Thanks.\n<|/ c |>\n<| c |>\nI appreciate\
    \ the effort put into this, but in practice, this solution is both slow (because\
    \ you are converting to lowercase and searching), and even slower because you\
    \ are iterating over the string twice.\n<|/ c |>\n<| c |>\nIt's not the iterating\
    \ twice.  Both indexOf and toLowerCase will iterate over the string twice per\
    \ call.  The slow part is actually the lowercasing.  The other part is iterating\
    \ over the string once and storing the start index of each substring so you can\
    \ count how many of each it found at one time.\n<|/ c |>\n<| a tags=algorithm,c++\
    \ dscore=2 |>\nHere's a Python implementation of Christopher Taylor's algorithm:\n\
    <code>\ndef how_many_times(string, substring):\n    pos = 0\n    while pos < len(string):\n\
    \        pos = string.index(substring, pos)\n        pos += 1\n        if pos\
    \ == len(string):\n            return 1\n    return 0\n</code>\n<|/ a |>\n<| c\
    \ |>\nI thought I did the same in C++.  I guess not.  It was more or less the\
    \ exact same thing.\n<|/ c |>\n<| a dscore=2 |>\nThis solution uses only standard\
    \ library functions. It works with case-insensitive searches only.\n<code>\n#include\
    \ <string>\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjcct4kej.d(17): Error: declaration expected, not `<`

    /tmp/tmpjcct4kej.d(29): Error: unterminated character constant

    /tmp/tmpjcct4kej.d(32): Error: unterminated character constant

    /tmp/tmpjcct4kej.d(32): Error: unterminated character constant

    /tmp/tmpjcct4kej.d(55): Error: declaration expected, not `assert`

    /tmp/tmpjcct4kej.d(56): Error: declaration expected, not `assert`

    /tmp/tmpjcct4kej.d(57): Error: declaration expected, not `assert`

    /tmp/tmpjcct4kej.d(58): Error: declaration expected, not `assert`

    /tmp/tmpjcct4kej.d(59): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjcct4kej.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\t\n\
    \tstring temp_substring = substring;\n\t\n\tdo\n\t{\n\t\tlong substring_index\
    \ = string.find(temp_substring);\n\t\t\n\t\tif (substring_index == string.length()\
    \ - temp_substring.length())\n\t\t\treturn count;\n\t\t\n\t\tcount += substring_index;\n\
    \t\t\n\t\ttemp_substring += \"a\";\n\t} while (temp_substring.length() < substring.length());\n\
    \t\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw7pq4wl1.d(17): Error: `string` is used as a type

    /tmp/tmpw7pq4wl1.d(21): Error: no property `find` for type `string`

    /tmp/tmpw7pq4wl1.d(23): Error: no property `length` for type `string`

    /tmp/tmpw7pq4wl1.d(29): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw7pq4wl1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long length = 0;\n\
    \    long count = 0;\n    string tmp = \"\";\n    \n    for (int i = 0; i < string.size();\
    \ ++i)\n    {\n        if (string[i] == substring[0]) \n        {\n          \
    \  tmp = substring;\n            \n            for (int j = 1; j < substring.length();\
    \ ++j)\n            {\n                if (string[i + j] != substring[j])\n  \
    \              {\n                    tmp += string[i + j];\n                \
    \    break;\n                }\n                tmp += string[i + j];\n      \
    \      }\n            \n            count++;\n            \n            tmp =\
    \ tmp.substr(0, tmp.length() - 1);\n            \n            if (tmp == substring)\n\
    \                length += (substring.length() - 1);\n        }\n    }\n    \n\
    \    return count;\n}\n/*\n Find the longest substring that begins with a given\
    \ substring.\n    >>> longest_substring(\"\", \"a\")\n    \"\"\n    >>> longest_substring(\"\
    \", \"ab\")\n    \"b\"\n    >>> longest_substring(\"ab\", \"c\")\n    \"bc\"\n\
    \    >>> longest_substring(\"ab\", \"bc\")\n    \"bc\"\n    \n*/\nstring longest_substring(string\
    \ string, string substring) \n{\n    long len = 0;\n    string result = \"\";\n\
    \    \n    for (int i = 0; i < string.size(); ++i)\n    {\n        if (string[i]\
    \ == substring[0]) \n        {\n            result = substring;\n            \n\
    \            for (int j = 1; j < substring.length(); ++j)\n            {\n   \
    \             if (string[i + j] != substring[j])\n                {\n        \
    \            result += string[i + j];\n                    break;\n          \
    \      }\n                result += string[i + j];\n            }\n          \
    \  \n            len += (substring.length() - 1);\n        }\n    }\n    \n  \
    \  return result.substr(0, len);\n}\n/*\n Reverse a string\n    >>> reverse_string(\"\
    hello\")\n    \"olleh\"\n    \n*/\nstring reverse_string(string string) \n{\n\
    \    string reverse = \"\";\n    \n    for (int i = 0; i < string.size(); ++i)\n\
    \    {\n        reverse += string[string.size() - 1 - i];\n    }\n    \n    return\
    \ reverse;\n}\n/*\n Convert an IP address string into four integers.\n    >>>\
    \ ip_to_int(\"127.0.0.1\")\n    (127, 0, 0, 1)\n    >>> ip_to_int(\"255.255.255.255\"\
    )\n    (255, 255, 255, 255)\n    \n*/\nvector<int> ip_to_int(string ip) \n{\n\
    \    vector<int> values;\n    \n    for (int i = ip.find(\".\") - 1; i <= ip.length();\
    \ ++i)\n    {\n        if (i == 0)\n        {\n            values.push_back(0);\n\
    \        }\n        else\n        {\n            values.push_back(ip - ip.substr(0,\
    \ i));\n        }\n    }\n    \n    return values;\n}\n\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkjmk3h8n.d(110): Error: no identifier for declarator `vector`

    /tmp/tmpkjmk3h8n.d(110): Error: declaration expected, not `<`

    /tmp/tmpkjmk3h8n.d(114): Error: declaration expected, not `for`

    /tmp/tmpkjmk3h8n.d(114): Error: no identifier for declarator `i`

    /tmp/tmpkjmk3h8n.d(114): Error: declaration expected, not `<=`

    /tmp/tmpkjmk3h8n.d(114): Error: declaration expected, not `++`

    /tmp/tmpkjmk3h8n.d(119): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkjmk3h8n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long len = string.length();\n\
    \    if(len == 0) return 0L;\n    long pos = string[len - substring.lenght()].indexOf(substring);\n\
    \    if(pos == -1) return 0L;\n    long start = 0; \n    long end = len;\n   \
    \ while(end > start) {\n        long mid = (end - start) / 2 + start;\n      \
    \  if(string[mid].equals(substring)) {\n            return mid - start;\n    \
    \    }\n        if(string[mid].compareEndsWith(substring) == 1) {\n          \
    \  end = mid;\n        } else {\n            start = mid;\n        }\n    }\n\
    \    return len;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n  \
    \  assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt5il36tv.d(15): Error: no property `length` for type `string`

    /tmp/tmpt5il36tv.d(17): Error: no property `lenght` for type `string`

    /tmp/tmpt5il36tv.d(23): Error: no property `equals` for type `immutable(char)`

    /tmp/tmpt5il36tv.d(26): Error: no property `compareEndsWith` for type `immutable(char)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt5il36tv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    // count overlaping\
    \ cases by summing up each substring with each substring in the string\n    long\
    \ sum = 0;\n    for(int i = 0; i < string.length(); i++) {\n        for(int j\
    \ = i; j < string.length(); j++) {\n            sum += how_many_times(string.substr(i,\
    \ j+1), substring);\n        }\n    }\n    return sum;\n}\n</code>\nThe function\
    \ how_many_times() takes substrings in two string parameters and returns the number\
    \ of substrings within the first string that are also found within the second\
    \ string. For example, how_many_times(\"abra\", \"bra\") returns 1, because the\
    \ first substring \"bra\" contains itself within \"abra\".\n<|/ a dscore=2 |>\n\
    <| a tags=algorithm,string |>\nThis is an old thread but I am new to python and\
    \ I hope this helps.\nHere is code using python 3.7.1.\n<code>\ndef overlapping_substring(text1,\
    \ text2):\n    temp = []\n    count = 0\n    for index in range(len(text1)):\n\
    \        temp.extend([text1[i:i + len(text2)] for i in range(len(text1) - index\
    \ + 1)])\n    for substring in temp:\n        if substring[::-1] in text2:\n \
    \           count += 1\n    return count\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp__e1qmnq.d(24): Error: declaration expected, not `<`

    /tmp/tmp__e1qmnq.d(44): Error: declaration expected, not `assert`

    /tmp/tmp__e1qmnq.d(45): Error: declaration expected, not `assert`

    /tmp/tmp__e1qmnq.d(46): Error: declaration expected, not `assert`

    /tmp/tmp__e1qmnq.d(47): Error: declaration expected, not `assert`

    /tmp/tmp__e1qmnq.d(48): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp__e1qmnq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tstring substr;\n\tsize_t\
    \ substrLen = substring.Length;\n\tlong times = 0;\n\tstring str;\n\t\n\tstr =\
    \ string;\n\twhile (str.Length > 0)\n\t{\n\t\tsubstr = str.Substring(0,substrLen);\n\
    \t\tif (string.StartsWith(substring))\n\t\t{\n\t\t\t++times;\n\t\t}\n\t\tstr =\
    \ str.Substring(substrLen);\n\t}\n\treturn times;\n}\n'''\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwhw1b8cq.d(32): Error: unterminated character constant

    /tmp/tmpwhw1b8cq.d(32): Error: declaration expected, not `63U`

    /tmp/tmpwhw1b8cq.d(32): Error: unterminated character constant

    /tmp/tmpwhw1b8cq.d(37): Error: declaration expected, not `assert`

    /tmp/tmpwhw1b8cq.d(38): Error: declaration expected, not `assert`

    /tmp/tmpwhw1b8cq.d(39): Error: declaration expected, not `assert`

    /tmp/tmpwhw1b8cq.d(40): Error: declaration expected, not `assert`

    /tmp/tmpwhw1b8cq.d(41): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwhw1b8cq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  // Count all occurrences\
    \ first\n  long total = 0;\n  long substringLen = string.length();\n  long i =\
    \ string.length() - substringLen;\n  while(i >= 0) \n  {\n    while(i >= 0 &&\
    \ !string[i] == substring[0]) {\n      i -= 1;\n    }\n    \n    if(i < 0) break;\n\
    \    \n    total += 1;\n    \n    string subStringWithAtLeastOneMore = string.substr(0,\
    \ i);\n    total += how_many_times(subStringWithAtLeastOneMore, substring);\n\
    \    \n    string subStringWithAtMostOneMore = string.substr(i);\n    total +=\
    \ how_many_times(subStringWithAtMostOneMore, substring);\n    \n    i -= 1;\n\
    \  }\n  \n  // Now subtract from total those that don't match\n  long subStringLen\
    \ = substring.length();\n  long j = 0;\n  string subStringWithAtLeastOneLess =\
    \ substring;\n  while(j < substringLen) {\n    if(!string[j] == subStringWithAtLeastOneLess[j])\
    \ {\n      total -= 1;\n      subStringWithAtLeastOneLess = string.substr(j +\
    \ 1);\n    }\n    \n    j ++;\n  }\n  \n  return total;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx_wftvwa.d(17): Error: no property `length` for type `string`

    /tmp/tmpx_wftvwa.d(18): Error: no property `length` for type `string`

    /tmp/tmpx_wftvwa.d(29): Error: `string` is used as a type

    /tmp/tmpx_wftvwa.d(29): Error: no property `substr` for type `string`

    /tmp/tmpx_wftvwa.d(32): Error: `string` is used as a type

    /tmp/tmpx_wftvwa.d(32): Error: no property `substr` for type `string`

    /tmp/tmpx_wftvwa.d(39): Error: no property `length` for type `string`

    /tmp/tmpx_wftvwa.d(41): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx_wftvwa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (string.empty())\
    \ return 0;\n    if (substring.empty()) return 0;\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcoew_117.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcoew_117.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    string lower_string\
    \ = string;\n    string upper_string = string;\n    string lower_substring = substring;\n\
    \    string upper_substring = substring;\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5ag_9hmn.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5ag_9hmn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for(int i = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j\
    \ < substring.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count++;\n                break;\n           \
    \ }\n        }\n    }\n    return count;\n}\n/*\n Split a string into substrings\
    \ of size size chars.\n    Each substring will be of length size-1 and the substring\
    \ before the last will be of size size\n    Each substring will be of length size-1\
    \ and the substring after the first will be of size size\n    >>> how_many_times(\"\
    aaabccabdaa\", \"ab\", 2)\n    5L\n    >>> how_many_times(\"aaabccabdaa\", \"\
    ab\", 1)\n    4L\n*/\ntuple<string, string, int> how_many_times(string string,\
    \ string substring, int size) \n{\n    for(int i = 0; i < string.length(); i +=\
    \ size)\n    {\n        if(how_many_times(string.substr(i, size), substring, size)\
    \ == 1)\n        {\n            if(how_many_times(string.substr(i, size - 1),\
    \ substring, size) == 0)\n            {\n                return make_pair(string.substr(i,\
    \ size), string.substr(i + 1, size), size);\n            }\n        }\n    }\n\
    \    throw runtime_error(\"Substring not found\");\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd0ddtdjl.d(38): Error: no identifier for declarator `tuple`

    /tmp/tmpd0ddtdjl.d(38): Error: declaration expected, not `<`

    /tmp/tmpd0ddtdjl.d(40): Error: no identifier for declarator `i`

    /tmp/tmpd0ddtdjl.d(40): Error: declaration expected, not `<`

    /tmp/tmpd0ddtdjl.d(40): Error: no identifier for declarator `i`

    /tmp/tmpd0ddtdjl.d(40): Error: declaration expected, not `+=`

    /tmp/tmpd0ddtdjl.d(47): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd0ddtdjl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t pos = string.find(substring);\n\
    \    if(pos == string.length() - substring.length())\n        return 0L;\n   \
    \ \n    long result = 0L;\n    \n    for(size_t i = 1; i < substring.length();\
    \ ++i)\n    {\n        string substring_copy = substring;\n        \n        while(string.find(substring_copy)\
    \ != string.length() - substring.length())\n            substring_copy += substring;\n\
    \        \n        result += string.find(substring_copy, pos + substring.length())\
    \ - pos;\n    }\n    \n    return result;\n}\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlapping cases and keep\
    \ only the first occurrence.\n    >>> how_many_times(\"\", \"a\")\n    0L\n  \
    \  >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    2L\n    \n*/\nlong how_many_times_keep_first_occurrence(string\
    \ string, string substring)\n{\n    size_t pos = string.find(substring);\n   \
    \ if(pos == string.length() - substring.length())\n        return 0L;\n    \n\
    \    long result = 0L;\n    \n    for(size_t i = 1; i < substring.length(); ++i)\n\
    \    {\n        string substring_copy = substring;\n        \n        while(string.find(substring_copy)\
    \ != string.length() - substring.length())\n            substring_copy += substring;\n\
    \        \n        if(string.find(substring_copy, pos + substring.length()) !=\
    \ string.length() - substring.length())\n            continue;\n        \n   \
    \     result += string.find(substring_copy, pos + substring.length()) - pos;\n\
    \        \n        break;\n    }\n    \n    return result;\n}\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1q1nl906.d(15): Error: no property `find` for type `string`

    /tmp/tmp1q1nl906.d(16): Error: no property `length` for type `string`

    /tmp/tmp1q1nl906.d(16): Error: no property `length` for type `string`

    /tmp/tmp1q1nl906.d(21): Error: no property `length` for type `string`

    /tmp/tmp1q1nl906.d(23): Error: `string` is used as a type

    /tmp/tmp1q1nl906.d(25): Error: no property `find` for type `string`

    /tmp/tmp1q1nl906.d(25): Error: no property `length` for type `string`

    /tmp/tmp1q1nl906.d(25): Error: no property `length` for type `string`

    /tmp/tmp1q1nl906.d(28): Error: no property `find` for type `string`

    /tmp/tmp1q1nl906.d(45): Error: no property `find` for type `string`

    /tmp/tmp1q1nl906.d(46): Error: no property `length` for type `string`

    /tmp/tmp1q1nl906.d(46): Error: no property `length` for type `string`

    /tmp/tmp1q1nl906.d(51): Error: no property `length` for type `string`

    /tmp/tmp1q1nl906.d(53): Error: `string` is used as a type

    /tmp/tmp1q1nl906.d(55): Error: no property `find` for type `string`

    /tmp/tmp'
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tfor\
    \ (int i = 0; i < string.size(); i++)\n\t{\n\t\tif (string[i] == substring[0]\
    \ && string[i + 1] == substring[1])\n\t\t{\n\t\t\tcount++;\n\t\t\ti += 2;\n\t\t\
    }\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn count;\n}\n//#include <Python.h>\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2ak8h8md.d(16): Error: no property `size` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2ak8h8md.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tbool\
    \ found = false;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string.substring(i,\
    \ i + substring.length()) == substring) {\n\t\t\tfound = true;\n\t\t\tcount++;\n\
    \t\t}\n\t\telse if (found) {\n\t\t\treturn count;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaqp5xx_e.d(17): Error: no property `length` for type `string`

    /tmp/tmpaqp5xx_e.d(18): Error: no property `substring` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaqp5xx_e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong length_string =\
    \ string.length();\n\tlong length_substring = substring.length();\n\tint count_substr\
    \ = 0;\n\tfor(int i = 0; i < length_string; i++)\n\t{\n\t\tfor(int j = 0; j <\
    \ length_substring; j++)\n\t\t{\n\t\t\tif(string[i] == substring[j])\n\t\t\t{\n\
    \t\t\t\tcount_substr++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn count_substr;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2zcs0tzs.d(15): Error: no property `length` for type `string`

    /tmp/tmp2zcs0tzs.d(16): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2zcs0tzs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if(string.length()\
    \ <= substring.length())\n        return 0;\n    if(string.compare(0, substring.length(),\
    \ substring) == 0)\n        return 1;\n    int index = string.find(substring);\n\
    \    while(index != -1) {\n        int startIndex = index;\n        index = string.find(substring,\
    \ index + 1);\n        if(startIndex < index)\n            index -= index - startIndex\
    \ + 1;\n        else\n            index -= startIndex;\n    }\n    return 1;\n\
    }\n</code>\n<|/ a tags=string,substring,c# |>\n<| a dscore=4 |>\nI have written\
    \ a generic function which you can use to count how many times a substring can\
    \ be found in a string. \n<code>\nstring word = \"hello\";\nstring sub = \"l\"\
    ;\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpslecczd2.d(30): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpslecczd2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (string.find(substring)\
    \ == string.length())\n    {\n        return 0;\n    }\n    \n    string substring1\
    \ = substring;\n    \n    size_t start = 0;\n    size_t end = string.length();\n\
    \    size_t pos;\n    \n    string result=substring1;\n    \n    while(start <\
    \ string.length() && end > 0)\n    {\n        pos = string.find(substring1, start);\n\
    \        if (pos != string.length())\n        {\n            result = substring1\
    \ + result;\n            start = pos+1;\n        }\n        else\n        {\n\
    \            start = end-1;\n            end = 0;\n        }\n    }\n    \n  \
    \  if (end == 0)\n    {\n        result = substring1 + result;\n    }\n    \n\
    \    return string.length() - result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq3epilh8.d(15): Error: no property `find` for type `string`

    /tmp/tmpq3epilh8.d(15): Error: no property `length` for type `string`

    /tmp/tmpq3epilh8.d(20): Error: `string` is used as a type

    /tmp/tmpq3epilh8.d(23): Error: no property `length` for type `string`

    /tmp/tmpq3epilh8.d(26): Error: `string` is used as a type

    /tmp/tmpq3epilh8.d(28): Error: no property `length` for type `string`

    /tmp/tmpq3epilh8.d(30): Error: no property `find` for type `string`

    /tmp/tmpq3epilh8.d(31): Error: no property `length` for type `string`

    /tmp/tmpq3epilh8.d(48): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq3epilh8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for (auto it = string.begin(); it != string.end(); ++it) {\n        if (it==string.length())\
    \ break;\n        if (string[it] == substring[0]) {\n            count++;\n  \
    \          if (it == string.length() || (string[it+1] == substring[1])) {\n  \
    \              count++;\n                if (it == string.length() || (string[it+2]\
    \ == substring[2])) {\n                    count++;\n                }\n     \
    \       }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0 tags=string,algorithm\
    \ |>\n<| a tags=string,algorithm |>\nI created this function for c++\n<code>\n\
    #include<bits/stdc++.h>\nusing namespace std;\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzh2at37l.d(30): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzh2at37l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t string_len =\
    \ string.length();\n    size_t substring_len = substring.length();\n    size_t\
    \ counter = 0;\n    size_t i = 0, j = 0;\n    while (i < string_len) {\n     \
    \   while (j < substring_len) {\n            if (string[i] == substring[j])\n\
    \                counter++;\n            else\n                break;\n      \
    \      j++;\n        }\n        i = i + 1;\n        j = 0;\n    }\n    return\
    \ counter;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppkpk8zut.d(15): Error: no property `length` for type `string`

    /tmp/tmppkpk8zut.d(16): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppkpk8zut.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong length = (string.length()+substring.length())\
    \ - 1;\n\tfor(int i = 0; i <= length; i++) \n\t{\n\t\tint j;\n\t\tfor (j = 0;\
    \ j < substring.length(); j++) \n\t\t{\n\t\t\tif (string[i+j] != substring[j])\n\
    \t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == substring.length())\n\t\t\
    {\n\t\t\treturn i+1;\n\t\t}\n\t}\n\treturn 0L;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, string substring, int startIndex, int endIndex)\
    \ \n{\n\tlong length = (string.length()+substring.length()) - 1;\n\tfor(int i\
    \ = startIndex; i <= endIndex; i++) \n\t{\n\t\tint j;\n\t\tfor (j = 0; j < substring.length();\
    \ j++) \n\t\t{\n\t\t\tif (string[i+j] != substring[j])\n\t\t\t{\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\tif (j == substring.length())\n\t\t{\n\t\t\treturn i+1;\n\t\
    \t}\n\t}\n\treturn 0L;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int startIndex) \n{\n\tlong length = (string.length()+substring.length()) -\
    \ 1;\n\tfor(int i = startIndex; i <= length; i++) \n\t{\n\t\tint j;\n\t\tfor (j\
    \ = 0; j < substring.length(); j++) \n\t\t{\n\t\t\tif (string[i+j] != substring[j])\n\
    \t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == substring.length())\n\t\t\
    {\n\t\t\treturn i+1;\n\t\t}\n\t}\n\treturn 0L;\n}\n/*\n Find how many times a\
    \ given substring can be found in the original string. Count overlaping cases.\n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\n\
    long how_many_times(string string, \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk88ynpcl.d(104): Error: basic type expected, not `unittest`

    /tmp/tmpk88ynpcl.d(104): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk88ynpcl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    string result = \"\"\
    ;\n    string tmp = string;\n    long count = 0;\n    int len = substring.length;\n\
    \    int i;\n    \n    for(i = 0; i < tmp.length(); ++i) {\n        string t =\
    \ tmp[i];\n        if(t.length() == len)\n            if(t == substring) {\n \
    \               count ++;\n            } else {\n                if(count == 0)\
    \ {\n                    result = tmp;\n                    break;\n         \
    \       }\n                if(count > 1) {\n                    result = \"(\"\
    \ + result + \")\";\n                }\n                result = \"(\" + tmp +\
    \ \")\";\n                count = -1;\n            }\n    }\nunittest\n{\n   \
    \ alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvgs2knd1.d(38): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvgs2knd1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong counter = 0;\n\t\
    for (int i = 0; i < string.length(); i++) \n\t{\n\t\tif (string[i] == substring[0])\
    \ \n\t\t{\n\t\t\tfor (int j = 1; j < substring.length(); j++) \n\t\t\t{\n\t\t\t\
    \tif (string[i + j] != substring[j]) \n\t\t\t\t{\n\t\t\t\t\t++counter;\n\t\t\t\
    \t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn counter;\n}\n/*\n Find how\
    \ many times a given substring can be found in the original string. Count overlaping\
    \ cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string pattern) \n{\n\
    \tlong counter = 0;\n\tfor (int i = 0; i < string.length(); i++) \n\t{\n\t\tif\
    \ (string[i] == substring[0]) \n\t\t{\n\t\t\tfor (int j = 1; j < substring.length();\
    \ j++) \n\t\t\t{\n\t\t\t\tif (string[i + j] != substring[j]) \n\t\t\t\t{\n\t\t\
    \t\t\tif (string.find(pattern, i) == string.find(pattern, i) + pattern.length())\n\
    \t\t\t\t\t\t++counter;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ counter;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count overlaping cases.\n    >>> how_many_times(\"\", \"a\"\
    )\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string pattern, int start) \n{\n\tlong counter = 0;\n\tfor (int i = start; i\
    \ < string.length(); i++) \n\t{\n\t\tif (string[i] == substring[0]) \n\t\t{\n\t\
    \t\tfor (int j = 1; j < substring.length(); j++) \n\t\t\t{\n\t\t\t\tif (string[i\
    \ + j] != substring[j]) \n\t\t\t\t{\n\t\t\t\t\tif (string.find(pattern, i) ==\
    \ string.find(pattern, i) + pattern.length())\n\t\t\t\t\t\t++counter;\n\t\t\t\t\
    \tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn counter;\n}\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxi_l491l.d(16): Error: no property `length` for type `string`

    /tmp/tmpxi_l491l.d(20): Error: no property `length` for type `string`

    /tmp/tmpxi_l491l.d(45): Error: no property `length` for type `string`

    /tmp/tmpxi_l491l.d(49): Error: no property `length` for type `string`

    /tmp/tmpxi_l491l.d(53): Error: no property `find` for type `string`

    /tmp/tmpxi_l491l.d(53): Error: no property `find` for type `string`

    /tmp/tmpxi_l491l.d(53): Error: no property `length` for type `string`

    /tmp/tmpxi_l491l.d(75): Error: no property `length` for type `string`

    /tmp/tmpxi_l491l.d(79): Error: no property `length` for type `string`

    /tmp/tmpxi_l491l.d(83): Error: no property `find` for type `string`

    /tmp/tmpxi_l491l.d(83): Error: no property `find` for type `string`

    /tmp/tmpxi_l491l.d(83): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxi_l491l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tsize_t offset = 0;\n\t\
    size_t substringLen = substring.length();\n\tsize_t stringLen = string.length();\n\
    \tsize_t count = 0;\n\tsize_t maxCount = 0;\n\tfor (size_t i = 0; i < stringLen;\
    \ ++i)\n\t{\n\t\tsize_t j;\n\t\tfor (j = 0; j < substringLen; ++j)\n\t\t{\n\t\t\
    \tif (string[i] == substring[j]) \n\t\t\t{\n\t\t\t\tcount += 1;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\tif (count == substringLen)\n\t\t{\n\t\t\tmaxCount = count;\n\
    \t\t\tcount = 0;\n\t\t\t++i;\n\t\t}\n\t\telse if (count > maxCount)\n\t\t{\n\t\
    \t\tmaxCount = count;\n\t\t}\n\t}\n\treturn maxCount;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp640hdm4i.d(16): Error: no property `length` for type `string`

    /tmp/tmp640hdm4i.d(17): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp640hdm4i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong num_occurrences\
    \ = 0;\n\tfor (auto i = 0; i < string.length(); ++i) {\n\t\tfor (auto j = 0; j\
    \ < substring.length(); ++j) {\n\t\t\tif (string.substr(i, j) == substring) {\n\
    \t\t\t\t++num_occurrences;\n\t\t\t}\n\t\t\tif (string.substr(i, j + 1) != substring)\
    \ {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn num_occurrences;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzgwlr04q.d(16): Error: no property `length` for type `string`

    /tmp/tmpzgwlr04q.d(17): Error: no property `length` for type `string`

    /tmp/tmpzgwlr04q.d(18): Error: no property `substr` for type `string`

    /tmp/tmpzgwlr04q.d(21): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzgwlr04q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tstring s = string;\n\t\
    long count = 0;\n\tfor (int i = 0; i < s.length(); i++)\n\t{\n\t\tint found =\
    \ 0;\n\t\tfor (int j = 0; j < substring.length(); j++)\n\t\t{\n\t\t\tif (s[i]\
    \ == substring[j])\n\t\t\t{\n\t\t\t\tfound++;\n\t\t\t}\n\t\t}\n\t\tif (found ==\
    \ substring.length())\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq9eyfygz.d(15): Error: `string` is used as a type

    /tmp/tmpq9eyfygz.d(20): Error: no property `length` for type `string`

    /tmp/tmpq9eyfygz.d(27): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq9eyfygz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int i=0;\n    while(string[i]!='\\\
    0')\n    {\n        int j=0;\n        while(substring.compare(string,j,i+1,1)==0)\n\
    \        {\n            j++;\n        }\n        if(j==string.length())\n    \
    \    {\n            return i;\n        }\n        i++;\n    }\n    return -1L;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr0qvd7je.d(19): Error: no property `compare` for type `string`

    /tmp/tmpr0qvd7je.d(23): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr0qvd7je.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  long result = 0;\n  for\
    \ (int i = 0; i < string.length(); i++) {\n    int len = substring.size();\n \
    \   if (len > string.length() - i)\n      len = string.length() - i;\n    for\
    \ (int j = 0; j < len; j++) {\n      if (string.substr(i, j+len) == substring)\
    \ {\n        result++;\n        i += len;\n        continue;\n      }\n      if\
    \ (string.substr(i, j) == substring) {\n        result += 1;\n      }\n    }\n\
    \  }\n  return result;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count overlaping cases.\n    >>> how_many_times(\"\"\
    , \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"\
    aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ bool allow_overlap) \n{\n  long result = 0;\n  for (int i = 0; i < string.length();\
    \ i++) {\n    int len = substring.size();\n    if (len > string.length() - i)\n\
    \      len = string.length() - i;\n    for (int j = 0; j < len; j++) {\n     \
    \ if (string.substr(i, j+len) == substring) {\n        result++;\n        i +=\
    \ len;\n        continue;\n      }\n      if (string.substr(i, j) == substring)\
    \ {\n        result += 1;\n      }\n    }\n  }\n  if (allow_overlap && result\
    \ > 0) {\n    return result - 1;\n  }\n  return result;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9cvdshsw.d(16): Error: no property `length` for type `string`

    /tmp/tmp9cvdshsw.d(17): Error: no property `size` for type `string`

    /tmp/tmp9cvdshsw.d(18): Error: no property `length` for type `string`

    /tmp/tmp9cvdshsw.d(19): Error: no property `length` for type `string`

    /tmp/tmp9cvdshsw.d(21): Error: no property `substr` for type `string`

    /tmp/tmp9cvdshsw.d(26): Error: no property `substr` for type `string`

    /tmp/tmp9cvdshsw.d(46): Error: no property `length` for type `string`

    /tmp/tmp9cvdshsw.d(47): Error: no property `size` for type `string`

    /tmp/tmp9cvdshsw.d(48): Error: no property `length` for type `string`

    /tmp/tmp9cvdshsw.d(49): Error: no property `length` for type `string`

    /tmp/tmp9cvdshsw.d(51): Error: no property `substr` for type `string`

    /tmp/tmp9cvdshsw.d(56): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9cvdshsw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t i, size = string.length();\n\
    \    long count = 0;\n    for(i = 0; i < size; ++i) {\n        if(string[i] ==\
    \ substring[0]) {\n            string substring_no_0 = substring.substr(1, substring.length());\n\
    \            if(how_many_times(string.substr(1, i), substring_no_0) > 0) ++count;\n\
    \        }\n    }\n    return count;\n}\n</cell>\n<cell>\n%timeit how_many_times(\"\
    \", \"a\")\n</cell>\n<cell>\n%timeit how_many_times(\"aaa\", \"a\")\n</cell>\n\
    <cell>\n%timeit how_many_times(\"aaaa\", \"aa\")\n</cell>\n<cell>\n%timeit how_many_times(\"\
    aaaaa\", \"a\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"a\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"b\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"c\") # c is not present in the input\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"d\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"e\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"f\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"g\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"h\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"i\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"j\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"k\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"l\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"m\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\
    , \"n\")\n</cell>\n<cell>\nhow_many_times(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_4nqw6fg.d(25): Error: declaration expected, not `<`

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character '')'' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character ''='' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character ''='' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character ''L'' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character '')'' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character '';'' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character ''s'' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character ''s'' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character ''r'' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character ''t'' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character ''('' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character ''n'' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character ''i'' in hex string

    /tmp/tmp_4nqw6fg.d(86): Error: non-hex character ''t'' in hex string

    /tmp/tmp_4nqw6fg.d(86): E'
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for(auto iter: string) \n    {\n        if(iter.find(substring) != string::npos)\
    \ \n        {\n            count++;\n        }\n    }\n    return count;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz16jdhy6.d(16): Error: no identifier for declarator `iter`

    /tmp/tmpz16jdhy6.d(16): Error: expression expected, not `:`

    /tmp/tmpz16jdhy6.d(16): Error: found `string` when expecting `;` following `for`
    condition

    /tmp/tmpz16jdhy6.d(18): Error: found `:` when expecting `)`

    /tmp/tmpz16jdhy6.d(18): Error: found `:` instead of statement

    /tmp/tmpz16jdhy6.d(23): Error: declaration expected, not `return`

    /tmp/tmpz16jdhy6.d(24): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz16jdhy6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    string substring_lowercase,\
    \ result_lowercase, how_many_times_lowercase, result;\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4m_4k_a_.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4m_4k_a_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count_matches\
    \ = 0;\n    size_t pos = 0;\n    size_t start_pos = 0;\n    string search_string\
    \ = substring;\n    if (string.length() == 0) \n        return 0L;\n    \n   \
    \ for(size_t i = 1; i < string.length(); i++) \n    {\n        while ( search_string.length()\
    \ > 0 && search_string[pos] == string[i] ) \n        {\n            pos++;\n \
    \           search_string = search_string.substr(1);\n            count_matches\
    \ += (pos - start_pos);\n        }\n        start_pos = pos;\n        pos = 0;\n\
    \    }\n    return count_matches;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprcaxp0o1.d(18): Error: `string` is used as a type

    /tmp/tmprcaxp0o1.d(19): Error: no property `length` for type `string`

    /tmp/tmprcaxp0o1.d(22): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprcaxp0o1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tif\
    \ (string == substring)\n\t{\n\t\treturn 1;\n\t}\n\t\n\tif (string.Length > substring.Length)\n\
    \t{\n\t\treturn 0;\n\t}\n\t\n\tfor (int i = 0; i < string.Length; i++)\n\t{\n\t\
    \tfor (int j = 0; j < substring.Length; j++)\n\t\t{\n\t\t\tif (string[i] == substring[j])\n\
    \t\t\t{\n\t\t\t\tcount += how_many_times(string.Substring(i + 1, string.Length\
    \ - i), substring);\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n  \
    \  alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeg8usdku.d(21): Error: no property `Length` for type `string`

    /tmp/tmpeg8usdku.d(21): Error: no property `Length` for type `string`

    /tmp/tmpeg8usdku.d(26): Error: no property `Length` for type `string`

    /tmp/tmpeg8usdku.d(28): Error: no property `Length` for type `string`

    /tmp/tmpeg8usdku.d(32): Error: no property `Substring` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeg8usdku.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0; //keep\
    \ count of how many times the substring was found\n    for(int i = 0; i < string.length();\
    \ i++) //go through each letter in the string\n    {\n        //if current letter\
    \ is equal to or smaller than the substring, then we're done searching\n     \
    \   if(string[i] < substring.size() || string[i] == substring.size())\n      \
    \  {\n            count++; //increment the counter by 1\n            continue;\
    \ //skip the rest of the loop\n        }\n        string substring_copy = substring;\
    \ //make a new substring from our substring\n        //remove the first letter\
    \ from the substring\n        substring_copy.erase(0, 1); \n        //if the current\
    \ letter is equal to the substring, then increment the counter by 1\n        if(string[i]\
    \ == substring_copy[0])\n            count++; \n    }\n    return count;\n}\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppmklprgm.d(16): Error: no property `length` for type `string`

    /tmp/tmppmklprgm.d(19): Error: no property `size` for type `string`

    /tmp/tmppmklprgm.d(19): Error: no property `size` for type `string`

    /tmp/tmppmklprgm.d(24): Error: `string` is used as a type

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppmklprgm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n   long count = 0;\n  \
    \ for (int i = 0; i < string.length(); i++)\n   {\n      if (string.substr(i,\
    \ substring.length()) == substring)\n         count++;\n   }\n   return count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwcr8fjjn.d(16): Error: no property `length` for type `string`

    /tmp/tmpwcr8fjjn.d(18): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwcr8fjjn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint i, j, k, l, found=0;\n\
    \tfor(i=0, j=string.length()-1; i<j; i++,j--)\n\t{\n\t\tfor(l=0; l<substring.length();\
    \ l++)\n\t\t{\n\t\t\tif (string[i+l] == substring[l])\n\t\t\t{\n\t\t\t\tfound++;\n\
    \t\t\t\tif (found>1) return found;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n\
    \ Find the longest substring which is all zeros in the original string.\n    >>>\
    \ find_longest_zeros(\"00001110010000000\")\n    '0'\n    >>> find_longest_zeros(\"\
    1110010000000\")\n    '111001000000'\n    \n*/\nstring find_longest_zeros(string\
    \ string) \n{\n\tlong max_len=string.length();\n\tint i, j, k;\n\tfor(j=max_len-1,\
    \ i=string.length()-1; j>0; i--,j--)\n\t{\n\t\tif (string[j]=='0') break;\n\t\
    }\n\tk=j;\n\tfor(j=max_len-1, i=string.length()-1; j>0; i--,j--)\n\t{\n\t\tif\
    \ (string[j]!='0') break;\n\t}\n\t\n\tstring ret=string.substr(k, j);\n\t\n\t\
    return ret;\n}\n/*\n Find the number of occurrences of any substring in the original\
    \ string.\n    >>> find_substring_occurrences(\"abcabc\", \"abc\")\n    2\n  \
    \  >>> find_substring_occurrences(\"abcabc\", \"cba\")\n    1\n    \n*/\nlong\
    \ find_substring_occurrences(string string, string substring) \n{\n\tint i, j,\
    \ k, found=0;\n\tfor(i=0, j=string.length()-1; i<j; i++,j--)\n\t{\n\t\tfor(l=0;\
    \ l<substring.length(); l++)\n\t\t{\n\t\t\tif (string[i+l] == substring[l])\n\t\
    \t\t{\n\t\t\t\tfound++;\n\t\t\t\tif (found>1) return found;\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn 0;\n}\n/*\n Find the number of occurrences of any substring in the\
    \ original string in reverse order.\n    >>> find_substring_occurrences_reverse(\"\
    abcabc\", \"abc\")\n    2\n    >>> find_substring_occurrences_reverse(\"abcabc\"\
    , \"cba\")\n    1\n    \n*/\nlong find_substring_occurrences_reverse(string string,\
    \ string substring) \n{\n\tint i, j, k, found=0;\n\tfor(i=string.length()-1, j=0;\
    \ i>j; i--,j++)\n\t{\n\t\tfor(l=0; l<substring.length(); l++)\n\t\t{\n\t\t\tif\
    \ (string[i+l] == substring[l])\n\t\t\t{\n\t\t\t\tfound\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0oz8rk3p.d(97): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmp0oz8rk3p.d(106): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp0oz8rk3p.d(106): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp0oz8rk3p.d(106): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp0oz8rk3p.d(106): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0oz8rk3p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   long current = 0;\n    \n    for( int i = 0; i < string.length(); i++ )\n\
    \    {\n        if( string[i] == substring[0] )\n        {\n            if( current\
    \ == 0 )\n            {\n                current = i;\n            }\n       \
    \ }\n        else if( string[i] == substring[1] && current > 0 )\n        {\n\
    \            current = 0;\n        }\n        else if( string[i] == substring[2]\
    \ && current > 0 )\n        {\n            current = i;\n        }\n        else\n\
    \        {\n            current = 0;\n        }\n        \n        count++;\n\
    \    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count non-overlapping cases.\n    >>> how_many_times_nooverlap(\"\
    \", \"\")\n    0L\n    >>> how_many_times_nooverlap(\"a\", \"\") \n    0L\n  \
    \  >>> how_many_times_nooverlap(\"aaa\", \"a\") \n    1L\n    >>> how_many_times_nooverlap(\"\
    aaaa\", \"aa\") \n    0L\n    \n*/\nlong how_many_times_nooverlap(string string,\
    \ string substring) \n{\n    long count = 0;\n    long current = 0;\n    \n  \
    \  for( int i = 0; i < string.length(); i++ )\n    {\n        if( string[i] ==\
    \ substring[0] )\n        {\n            if( current == 0 )\n            {\n \
    \               current = i;\n            }\n        }\n        else if( string[i]\
    \ == substring[1] && current > 0 )\n        {\n            current = 0;\n    \
    \    }\n        else if( string[i] == substring[2] && current > 0 )\n        {\n\
    \            current = i;\n        }\n        else\n        {\n            current\
    \ = 0;\n        }\n        \n        count++;\n    }\n    \n    return count;\n\
    }\n/*\n Return a list of substring occurrences from the original string in a list.\n\
    \    >>> find_occurrences_list(\"\", \"a\")\n    []\n    >>> find_occurrences_list(\"\
    a\", \"a\")\n    [(0, 0)]\n    >>> find_occurrences_list(\"aaa\", \"a\")\n   \
    \ [(0, 0)]\n    >>> find_occurrences_list(\"aaa\", \"a\")\n    [(0, 0), (1, 1)]\n\
    \    >>> find_occurrences_list(\"aaaa\", \"aa\")\n    [(0, 0)]\n    >>> find_occurrences_list(\"\
    aaaa\", \"aa\")\n    [(0, 0), (1, 1)]\n    \n*/\nvector< pair<long, long> > find_occurrences_list(string\
    \ string, string substring) \n{\n    vector< pair<long, long> > occurrences;\n\
    \    \n    for( int i = 0; i < string.length(); i++ )\n    {\n        if( string[i]\
    \ == substring[0] )\n        {\n            occurrences.push_back( make_pair(i,\
    \ 0) );\n        }\n        else if( string[i] == substring\nunittest\n{\n   \
    \ alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0lv3hqt9.d(105): Error: no identifier for declarator `vector`

    /tmp/tmp0lv3hqt9.d(105): Error: declaration expected, not `<`

    /tmp/tmp0lv3hqt9.d(109): Error: declaration expected, not `for`

    /tmp/tmp0lv3hqt9.d(109): Error: no identifier for declarator `i`

    /tmp/tmp0lv3hqt9.d(109): Error: declaration expected, not `<`

    /tmp/tmp0lv3hqt9.d(109): Error: no identifier for declarator `i`

    /tmp/tmp0lv3hqt9.d(109): Error: declaration expected, not `++`

    /tmp/tmp0lv3hqt9.d(114): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0lv3hqt9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long counter = 0;\n\
    \    string temp = \"\";\n    for (int i = 0; i < string.length(); i++) \n   \
    \ {\n        for (int j = 0; j < substring.length(); j++)\n        {\n       \
    \     if (string[i] == substring[j]) \n            {\n                if (temp\
    \ == \"\")\n                {\n                    temp = string[i];\n       \
    \             counter++;\n                }\n                else\n          \
    \      {\n                    temp = temp + string[i];\n                    counter++;\n\
    \                }\n                temp = \"\";\n            }\n        }\n \
    \   }\n    return counter;\n}\n</code>\n<|/ a tags=java,algorithm,string,substring,dynamic-programming\
    \ |>\n<| c |>\nwhat about `how_many_times(\"aaaa\",\"aa\")` this should return\
    \ 2 but your function returns 3 !! .. i think there is some logical error !\n\
    <|/ c |>\n<| c |>\nAha yes, you are right. Corrected it\n<|/ c |>\n<| a |>\nThis\
    \ is an alternative solution using regex. Just my 2ct: \n<code>\npublic class\
    \ Test {\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcwyiwc2m.d(39): Error: declaration expected, not `<`

    /tmp/tmpcwyiwc2m.d(55): Error: declaration expected, not `assert`

    /tmp/tmpcwyiwc2m.d(56): Error: declaration expected, not `assert`

    /tmp/tmpcwyiwc2m.d(57): Error: declaration expected, not `assert`

    /tmp/tmpcwyiwc2m.d(58): Error: declaration expected, not `assert`

    /tmp/tmpcwyiwc2m.d(59): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcwyiwc2m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long result = 0;\n\
    \    int len_s = string.length();\n    int len_p = substring.length();\n    int\
    \ len_sub = len_p;\n    string prefix = string.substr(0,len_s-len_p);\n    string\
    \ suffix = string.substr(len_s-len_p);\n    int i = 0;\n    while ((i < len_p)\
    \ && (string.find(substring, i) != string::npos))\n    {\n        if (string.find(substring,\
    \ i) == 0)\n        {\n            result += 1;\n            i += len_sub - 1;\n\
    \        }\n        else\n            i += 1;\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nI used a for loop for this\n<code>\n\
    package algorithms;\nunittest\n{\n    alias candidate = how_many_times;\n\n  \
    \  assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9d3q9p5j.d(22): Error: found `:` when expecting `)`

    /tmp/tmp9d3q9p5j.d(22): Error: found `:` when expecting `)`

    /tmp/tmp9d3q9p5j.d(22): Error: found `)` when expecting `;` following statement

    /tmp/tmp9d3q9p5j.d(22): Error: found `)` instead of statement

    /tmp/tmp9d3q9p5j.d(29): Error: declaration expected, not `else`

    /tmp/tmp9d3q9p5j.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9d3q9p5j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tstring p1 = substring,\
    \ p2 = substring;\n\tfor (auto c: string)\n\t{\n\t\tif (c == p1) p2++;\n\t\telse\
    \ p1++;\n\t\tstring partial = string.substr(0, p2);\n\t\tif (string.find(partial)\
    \ == string::npos)\n\t\t\treturn 0L;\n\t\tp1 = p2;\n\t\tp2 = partial;\n\t}\n\t\
    return string.size() - p2.size();\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6zvbo9e8.d(16): Error: no identifier for declarator `c`

    /tmp/tmp6zvbo9e8.d(16): Error: expression expected, not `:`

    /tmp/tmp6zvbo9e8.d(16): Error: found `string` when expecting `;` following `for`
    condition

    /tmp/tmp6zvbo9e8.d(21): Error: found `:` when expecting `)`

    /tmp/tmp6zvbo9e8.d(21): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6zvbo9e8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tassert(!string.IsNullOrEmpty());\n\
    \tassert(!substring.IsNullOrEmpty());\n\t\n\tif (string.length() == 0) return\
    \ 0L;\n\tif (string.length() < substring.length()) return 0L;\n\tif (string.length()\
    \ == substring.length()) return 1L;\n\t\n\tint i = 0, j = 0;\n\t\n\twhile ((i\
    \ < string.length()) && (string.at(i) == substring.at(j))) {\n\t\ti++;\n\t\tj++;\n\
    \t}\n\t\n\treturn (j == substring.length() ? 0L : j - i + 1);\n}\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsr79dyzo.d(15): Error: no property `IsNullOrEmpty` for type `string`

    /tmp/tmpsr79dyzo.d(16): Error: no property `IsNullOrEmpty` for type `string`

    /tmp/tmpsr79dyzo.d(18): Error: no property `length` for type `string`

    /tmp/tmpsr79dyzo.d(19): Error: no property `length` for type `string`

    /tmp/tmpsr79dyzo.d(19): Error: no property `length` for type `string`

    /tmp/tmpsr79dyzo.d(20): Error: no property `length` for type `string`

    /tmp/tmpsr79dyzo.d(20): Error: no property `length` for type `string`

    /tmp/tmpsr79dyzo.d(24): Error: no property `length` for type `string`

    /tmp/tmpsr79dyzo.d(24): Error: no property `at` for type `string`

    /tmp/tmpsr79dyzo.d(24): Error: no property `at` for type `string`

    /tmp/tmpsr79dyzo.d(29): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsr79dyzo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for (long i = 0; i < string.length(); i++) {\n        if (string.at(i) ==\
    \ substring.at(0)) {\n            count++;\n            for (long j = i; j < string.length();\
    \ j++) {\n                if (string.at(j) == substring.at(0)) {\n           \
    \         count++;\n                }\n                else {\n              \
    \      break;\n                }\n            }\n        }\n        else {\n \
    \           break;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=1 |>\nThis simple python code solves the problem in a single line.\n\
    <code>\nlen(re.findall('a|b', your_string))\n</code>\n<|/ a tags=python,string,substring\
    \ |>\n<| c |>\n`re.findall('a|b', your_string)` would be much more efficient than\
    \ `your_string.count('a') + your_string.count('b')`.\n<|/ c |>\n<| a |>\nTry this\
    \ in C++\n<code>\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfyr9uzmm.d(34): Error: declaration expected, not `<`

    /tmp/tmpfyr9uzmm.d(39): Error: unterminated character constant

    /tmp/tmpfyr9uzmm.d(39): Error: unterminated character constant

    /tmp/tmpfyr9uzmm.d(52): Error: declaration expected, not `assert`

    /tmp/tmpfyr9uzmm.d(53): Error: declaration expected, not `assert`

    /tmp/tmpfyr9uzmm.d(54): Error: declaration expected, not `assert`

    /tmp/tmpfyr9uzmm.d(55): Error: declaration expected, not `assert`

    /tmp/tmpfyr9uzmm.d(56): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfyr9uzmm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int count = 0, end\
    \ = 0;\n    for (int i = 0; i < string.length(); i++) {\n        end = string.length();\n\
    \        while (end > 0 && (string[end - 1] == substring[end]))\n            end--;\n\
    \        if (string[i] == substring[end])\n            count++;\n    }\n    return\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph7__0esj.d(16): Error: no property `length` for type `string`

    /tmp/tmph7__0esj.d(17): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph7__0esj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong i = 0;\n\tsize_t\
    \ pos = 0;\n\tsize_t length = string.length();\n\twhile(pos < length) \n\t{\n\t\
    \tpos = string.find(substring, pos);\n\t\tif (pos == string::npos)\n\t\t\treturn\
    \ i; // Not found (returns 0 on failure)\n\t\ti = i + 1;\n\t\tpos = pos + substring.length();\n\
    \t}\n\treturn i;\n}\n/*\n Convert a string to a floating point type\n \n    >>>\
    \ string_to_float(\"1.0\")\n    1.0\n    >>> string_to_float(\"1.0e1\")\n    1.0e1\n\
    \    >>> string_to_float(\"1.0e-1\")\n    1.0e-1\n    \n*/\nfloat string_to_float(string\
    \ string) \n{\n\tdouble retVal = 0;\n\tsize_t pos = 0;\n\tpos = string.find(\"\
    .\");\n\tif (pos == string::npos)\n\t\treturn 0.0f;\n\tstring endString = string.substr(pos\
    \ + 1);\n\tretVal = std.convert.strtonum(string);\n\tretVal = std.convert.strtonum(endString);\n\
    \treturn retVal;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n  \
    \  assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppi5c_dx6.d(21): Error: found `:` when expecting `)`

    /tmp/tmppi5c_dx6.d(21): Error: found `:` instead of statement

    /tmp/tmppi5c_dx6.d(44): Error: found `:` when expecting `)`

    /tmp/tmppi5c_dx6.d(44): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppi5c_dx6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tfor\
    \ (int i = 0; i < string.length(); i++) {\n\t\tif (string.compare(i, substring.length(),\
    \ substring) == 0) {\n\t\t\tcount += 1;\n\t\t}\n\t\telse {\n\t\t\tif (string.compare(i,\
    \ substring.length(), substring) == 0) {\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t\t\
    else if (string.compare(i, substring.length(), substring) > 0) {\n\t\t\t\tcount\
    \ += 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwnq_48yd.d(16): Error: no property `length` for type `string`

    /tmp/tmpwnq_48yd.d(17): Error: no property `compare` for type `string`

    /tmp/tmpwnq_48yd.d(21): Error: no property `compare` for type `string`

    /tmp/tmpwnq_48yd.d(24): Error: no property `compare` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwnq_48yd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong  count = 0;\n\t\
    for (int i = 0; i < string.size(); i++) {\n\t\tfor (int j = 0; j < substring.size();\
    \ j++) {\n\t\t\tif (string[i] == substring[j])\n\t\t\t\tcount++;\n\t\t}\n\t}\n\
    \treturn count;\n}\n/*\n Find how many times this substring can be found in this\
    \ string. Count overlapping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string pattern) \n{\n\tlong  count = 0;\n\tfor (int i = 0; i < string.size();\
    \ i++) {\n\t\tfor (int j = 0; j < pattern.size(); j++) {\n\t\t\tif (string[i]\
    \ == pattern[j] && pattern[j] != substring[j])\n\t\t\t\tcount++;\n\t\t}\n\t}\n\
    \treturn count;\n}\n/*\n Find the number of occurrences of this substring in this\
    \ string. Count overlapping cases.\n    >>> how_many_times(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times(\"aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    3L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ string pattern, bool ignore_case) \n{\n\tlong  count = 0;\n\tfor (int i = 0;\
    \ i < string.size(); i++) {\n\t\tfor (int j = 0; j < pattern.size(); j++) {\n\t\
    \t\tif (string[i] == pattern[j] && pattern[j] != substring[j]) {\n\t\t\t\tif (ignore_case)\n\
    \t\t\t\t\tcount++;\n\t\t\t\telse\n\t\t\t\t\tcount += 0;\n\t\t\t}\n\t\t}\n\t}\n\
    \treturn count;\n}\n/*\n Find the number of occurrences of this substring in this\
    \ string.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n\
    */\nlong how_many_times(string string, string substring, string pattern, bool\
    \ ignore_case, bool ignore_newline) \n{\n\tlong  count = 0;\n\tfor (int i = 0;\
    \ i < string.size(); i++) {\n\t\tfor (int j = 0; j < pattern.size(); j++) {\n\t\
    \t\tif (string[i] == pattern[j] && pattern[j] != substring[j]) {\n\t\t\t\tif (ignore_case)\n\
    \t\t\t\t\tcount++;\n\t\t\t\telse\n\t\t\t\t\tcount += 0;\n\t\t\t}\n\t\t}\n\t}\n\
    \treturn count;\n}\n/*\n Find the number of occurrences of this substring in this\
    \ string.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    3L\n    >>> how_many_times(\"aaaa\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmfmkn3a2.d(95): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmfmkn3a2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tstring[] char_array =\
    \ string.to_char_array();\n\tint[] char_array_length = std.array.length(char_array);\n\
    \tstring[] substring_array = substring.to_char_array();\n\tint[] substring_array_length\
    \ = std.array.length(substring_array);\n\t\n\tint substring_index_start = 0;\n\
    \tint substring_index_end = substring_index_start + std.array.length(substring_array);\n\
    \tint char_index_start = 0;\n\tint char_index_end = char_index_start + std.array.length(char_array);\n\
    \tint index = 0;\n\t\n\tlong count = 0;\n\twhile (char_index_start < char_index_end)\
    \ {\n\t\tif (substring_array_length == 0) {\n\t\t\treturn count;\n\t\t}\n\t\t\
    if (substring_array[substring_index_end] == char_array[char_index_end]) {\n\t\t\
    \tsubstring_index_end++;\n\t\t\tchar_index_end++;\n\t\t\tcount++;\n\t\t\tcontinue;\n\
    \t\t}\n\t\t\n\t\t// Find first character that does not match.\n\t\twhile (char_index_start\
    \ < char_index_end && char_array[char_index_start] == substring_array[substring_index_start])\
    \ {\n\t\t\tsubstring_index_start++;\n\t\t\tchar_index_start++;\n\t\t}\n\t\t\n\t\
    \tint current_index = substring_index_start;\n\t\twhile (current_index < substring_index_end)\
    \ {\n\t\t\tif (char_array[char_index_end] == substring_array[current_index]) {\n\
    \t\t\t\tchar_index_end++;\n\t\t\t\tcount++;\n\t\t\t\tcurrent_index++;\n\t\t\t\t\
    continue;\n\t\t\t}\n\t\t\tif (current_index == substring_index_end - 1) {\n\t\t\
    \t\treturn count;\n\t\t\t}\n\t\t\tcurrent_index++;\n\t\t}\n\t}\n\treturn count;\n\
    }\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphka_jp7u.d(15): Error: `string` is used as a type

    /tmp/tmphka_jp7u.d(15): Error: no property `to_char_array` for type `string`

    /tmp/tmphka_jp7u.d(16): Error: undefined identifier `array` in package `std`

    /tmp/tmphka_jp7u.d(17): Error: `string` is used as a type

    /tmp/tmphka_jp7u.d(17): Error: no property `to_char_array` for type `string`

    /tmp/tmphka_jp7u.d(18): Error: undefined identifier `array` in package `std`

    /tmp/tmphka_jp7u.d(21): Error: undefined identifier `array` in package `std`

    /tmp/tmphka_jp7u.d(23): Error: undefined identifier `array` in package `std`

    /tmp/tmphka_jp7u.d(28): Error: incompatible types for `(substring_array_length)
    == (0)`: `int[]` and `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphka_jp7u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    auto pos = string.find(substring);\n\
    \    if (pos != string::npos)\n        return string.length() - pos;\n    else\n\
    \        return 0L;\n}\n/*\n Split a substring into a list of substrings in O(n).\n\
    \    >>> split_in_O(\"\", \"a\", \"b\")\n    [\"\"]\n    >>> split_in_O(\"a\"\
    , \"a\", \"b\")\n    [\"a\"]\n    >>> split_in_O(\"a\", \"a\", \"c\")\n    Traceback\
    \ (most recent call last):\n        ...\n    ValueError: Substring must not be\
    \ an empty string.\n*/\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnbimvfg_.d(16): Error: found `:` when expecting `)`

    /tmp/tmpnbimvfg_.d(16): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnbimvfg_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   \n    for(string::iterator i = string.begin();i!= string.end();i++)\n    {\n\
    \        if(substring == *i)\n        {\n            count++;\n        }\n   \
    \ }\n    return count;\n}\n</code>\n<|/ a tags=string,substr,c dscore=1 |>\n<|\
    \ c |>\nWhat about overlapping cases (`aaa` vs `aa`)?\n<|/ c |>\n<| c |>\nThe\
    \ OP wrote in the question that he was using C. Also, the question states that\
    \ it is written in Python.\n<|/ c |>\n<| c |>\nI know, sorry for that. I just\
    \ wanted to point out a common pitfall for the OP who is probably not aware of\
    \ it (maybe he was just looking for a Python answer because he wanted to use Python\
    \ and didn't know that C was also a supported language).\n<|/ c |>\n<| a |>\n\
    I think you're looking for a C solution and so I went ahead and converted it to\
    \ C++.\nAs far as I know, there's no way to count characters (substrings) in a\
    \ string without iterating through the string and counting characters individually,\
    \ so this algorithm is going to be O(n).\n<code>\nlong how_many_times(string string,\
    \ string substring) \n{\n    long count = 0;\n    \n    for(string::iterator i\
    \ = string.begin();i!= string.end();i++)\n    {\n        if(substring == *i)\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    I didn't convert this to C, but it should still be pretty easy to do.\n<|/ a tags=string,substr,c\
    \ dscore=0 |>\n<| a |>\nI believe that for efficiency, a better algorithm would\
    \ be:\n<code>\nlong howMany(const std::string &str, const std::string &sub) {\n\
    \  std::string s = str;\n  for (auto iter = s.begin(); iter != s.end(); ) {\n\
    \    if (s.find(sub, iter) != iter) {\n      return 0;\n    }\n    iter += sub.size();\n\
    \  }\n  return s.size();\n}\n</code>\n<|/ a dscore=0 tags=string,substr,c |>\n\
    <| a |>\n<code>\n#include<iostream>\n#include<string>\nusing namespace std;\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3f0spr5j.d(17): Error: use `.` for member lookup, not `::`

    /tmp/tmp3f0spr5j.d(17): Error: found `i` when expecting `;` following `for` condition

    /tmp/tmp3f0spr5j.d(17): Error: expression expected, not `=`

    /tmp/tmp3f0spr5j.d(17): Error: found `string` when expecting `)`

    /tmp/tmp3f0spr5j.d(17): Error: found `)` when expecting `;` following statement

    /tmp/tmp3f0spr5j.d(26): Error: declaration expected, not `<`

    /tmp/tmp3f0spr5j.d(35): Error: unterminated character constant

    /tmp/tmp3f0spr5j.d(38): Error: unterminated character constant

    /tmp/tmp3f0spr5j.d(39): Error: unterminated character constant

    /tmp/tmp3f0spr5j.d(45): Error: declaration expected, not `for`

    /tmp/tmp3f0spr5j.d(45): Error: no identifier for declarator `i`

    /tmp/tmp3f0spr5j.d(45): Error: declaration expected, not `!=`

    /tmp/tmp3f0spr5j.d(45): Error: no identifier for declarator `i`

    /tmp/tmp3f0spr5j.d(45): Error: declaration expected, not `++`

    /tmp/tmp3f0spr5j.d(50): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/t'
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for(int i = 1; i < string.size(); ++i)\n    {\n        if(string.substr(0,\
    \ i) == substring)\n        {\n            ++count;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n    >>> how_many_times(\"a\", \"a\")\n    1L\n\
    \    >>> how_many_times(\"aaa\", \"aa\")\n    2L\n    >>> how_many_times(\"aaaa\"\
    , \"aa\")\n    1L\n*/\nlong how_many_times_2(string string, string substring)\
    \ \n{\n    string substring_2 = substring + substring;\n    string substring_3\
    \ = substring + substring + substring;\n    \n    long count = 0;\n    for(int\
    \ i = 1; i < string.size(); ++i)\n    {\n        string sub_i = string.substr(0,\
    \ i);\n        if(sub_i == substring_1 || sub_i == substring_2 || sub_i == substring_3)\n\
    \        {\n            ++count;\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases.\n    >>> how_many_times(\"a\", \"a\")\n    1L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    2L\n    >>> how_many_times(\"aaaa\", \"a\")\n    1L\n*/\nlong\
    \ how_many_times_3(string string, string substring) \n{\n    string substring_2\
    \ = substring + substring;\n    string substring_3 = substring + substring + substring;\n\
    \    \n    long count = 0;\n    for(int i = 1; i < string.size(); ++i)\n    {\n\
    \        string sub_i = string.substr(0, i);\n        if(sub_i == substring ||\
    \ sub_i == substring_2 || sub_i == substring_3)\n        {\n            ++count;\n\
    \        }\n    }\n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases.\n    >>> how_many_times(\"\
    a\", \"a\")\n    1L\n    >>> how_many_times(\"aaa\", \"a\")\n    2L\n    >>> how_many_times(\"\
    aaaa\", \"a\")\n    1L\n*/\nlong how_many_times_4(string string, string substring)\
    \ \n{\n    string substring_2 = substring + substring;\n    string substring_3\
    \ = substring + substring + substring;\n    \n    long count = 0;\n    for(int\
    \ i = 1; i < string.size(); ++i)\n    {\n        string sub_i = string.substr(0,\
    \ i);\n        if(sub_i == substring || sub_i == sub\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxe_9myyi.d(94): Error: found `unittest` when expecting `)`

    /tmp/tmpxe_9myyi.d(103): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpxe_9myyi.d(103): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxe_9myyi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int i = 0;\n    int\
    \ j = 0;\n    int count = 0;\n    \n    while(i < string.length() && j<substring.length())\n\
    \    {\n        switch(tolower(string[i]))\n        {\n            switch(tolower(substring[j]))\n\
    \            {\n                case (tolower(substring[j])):\n              \
    \  {\n                    count++;\n                    break;\n             \
    \   }\n                case (tolower(substring[j+1])):\n                {\n  \
    \                  count++;\n                    j++;\n                }\n   \
    \             case (tolower(substring[j+2])):\n                {\n           \
    \         count++;\n                    j++;\n                    i++;\n     \
    \           }\n                default:\n                {\n                 \
    \   i++;\n                    j++;\n                }\n            }\n       \
    \ }\n    }\n    \n    return count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count overlaping cases. Cases in middle\
    \ of substring.\n    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"\
    aaa\", \"a\")\n    1L\n    >>> how_many_times(\"aaaa\", \"a\")\n    2L\n    >>>\
    \ how_many_times(\"aaaa\", \"aa\")\n    2L\n    >>> how_many_times(\"aaaa\", \"\
    aaa\")\n    2L\n    \n*/\nlong how_many_times(string string, string substring,\
    \ int startIndex, int endIndex)\n{\n    int i = 0;\n    int j = 0;\n    int count\
    \ = 0;\n    \n    while(i < string.length() && j<substring.length())\n    {\n\
    \        switch(tolower(string[i]))\n        {\n            switch(tolower(substring[j]))\n\
    \            {\n                case (tolower(substring[j])):\n              \
    \  {\n                    count++;\n                    break;\n             \
    \   }\n                case (tolower(substring[j+1])):\n                {\n  \
    \                  count++;\n                    j++;\n                }\n   \
    \             case (tolower(substring[j+2])):\n                {\n           \
    \         count++;\n                    j++;\n                    i++;\n     \
    \           }\n                default:\n                {\n                 \
    \   i++;\n                    j++;\n                }\n            }\n       \
    \ }\n        if(startIndex < i && endIndex > j)\n            return count;\n \
    \       i++;\n        j++;\n    }\n    \n    return count;\n}\n/*\n Find how many\
    \ times a given substring can be found in the original string. Count overlaping\
    \ cases. Cases in middle of substring.\n    >>> how_many_times(\"\", \"a\", 1,\
    \ 1)\n    0L\n    >>> how_many_times(\"aaa\", \"a\", 1, 1)\n    0L\n    >>> how_many_times(\"\
    aaaa\", \"a\", 1, 1)\n    0L\n    >>> how_many_times(\"aaaa\", \"a\", 1, 2)\n\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphtg3ljh5.d(109): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphtg3ljh5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    \n    long count =\
    \ 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        for(int j =\
    \ 0; j < substring.length(); j++)\n        {\n            if(string.sub(i,1) ==\
    \ substring.subj)\n            {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    \n    return count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=string,c# |>\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph1epuh73.d(31): Error: declaration expected, not `<`

    /tmp/tmph1epuh73.d(36): Error: semicolon expected, not `.`

    /tmp/tmph1epuh73.d(36): Error: no identifier for declarator `.Collections.Generic`

    /tmp/tmph1epuh73.d(37): Error: semicolon expected, not `.`

    /tmp/tmph1epuh73.d(37): Error: no identifier for declarator `.Linq`

    /tmp/tmph1epuh73.d(38): Error: semicolon expected, not `.`

    /tmp/tmph1epuh73.d(38): Error: no identifier for declarator `.Text`

    /tmp/tmph1epuh73.d(39): Error: semicolon expected, not `.`

    /tmp/tmph1epuh73.d(39): Error: no identifier for declarator `.Text.RegularExpressions`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph1epuh73.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int pos = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string.at(i) == substring.at(i))\
    \ {\n            pos++;\n        } else {\n            if(pos > 0) return pos;\n\
    \            pos = 0;\n        }\n    }\n    return pos;\n}\n/*\n Return True\
    \ if the substring has exactly one occurrence in the original string. \n    \n\
    \    >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\",\
    \ \"a\")\n    1L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    1L\n    \n*/\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5jbi__g9.d(16): Error: no property `length` for type `string`

    /tmp/tmp5jbi__g9.d(17): Error: no property `at` for type `string`

    /tmp/tmp5jbi__g9.d(17): Error: no property `at` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5jbi__g9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int i = 0, j = 0;\n\
    \    int count = 0;\n    string result = \"\";\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8gelfld8.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8gelfld8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong cnt = 0;\n\tsize_t\
    \ pos = 0;\n\tsize_t last = 0;\n\twhile(pos < string.size()) {\n\t\tif (string.find_first_of(substring,\
    \ pos) == string::npos)\n\t\t\tbreak;\n\t\tcnt += string.find_first_not_of(substring,\
    \ pos) - last;\n\t\tlast = string.find_first_of(substring, pos);\n\t\tpos++;\n\
    \t}\n\treturn cnt;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpihoyarfa.d(19): Error: found `:` when expecting `)`

    /tmp/tmpihoyarfa.d(19): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpihoyarfa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n   long count = 0L;\n \
    \  char c = string.at(0);\n   for (long i = 0; i < string.size(); i++) \n   {\n\
    \      if (c == substring.at(i)) \n      {\n         count++;\n         while\
    \ (i < string.size() && c == substring.at(i)) i++;\n         \n         if (i\
    \ >= string.size()) break;\n         \n         c = string.at(i);\n         \n\
    \      }\n   }\n   return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr6x6_2hx.d(16): Error: no property `at` for type `string`

    /tmp/tmpr6x6_2hx.d(17): Error: no property `size` for type `string`

    /tmp/tmpr6x6_2hx.d(19): Error: no property `at` for type `string`

    /tmp/tmpr6x6_2hx.d(22): Error: no property `size` for type `string`

    /tmp/tmpr6x6_2hx.d(22): Error: no property `at` for type `string`

    /tmp/tmpr6x6_2hx.d(24): Error: no property `size` for type `string`

    /tmp/tmpr6x6_2hx.d(26): Error: no property `at` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr6x6_2hx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0L;\n\
    \    for (auto it = string.begin(); it != string.end(); ++it) {\n        if (*it\
    \ == substring[0]) {\n            string substring_without = substring;\n    \
    \        substring_without.erase(substring_without.begin(), substring_without.end());\n\
    \            if (string.find(substring_without, it + 1) != string::npos) {\n \
    \               count = count + 1L;\n            }\n        }\n    }\n    return\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprt6hjogt.d(20): Error: found `:` when expecting `)`

    /tmp/tmprt6hjogt.d(20): Error: found `:` instead of statement

    /tmp/tmprt6hjogt.d(25): Error: declaration expected, not `return`

    /tmp/tmprt6hjogt.d(26): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprt6hjogt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for (int i = 0; i < string.length(); i++) {\n        for (int j = 0; j < substring.length();\
    \ j++) {\n            if (string[i] == substring[j]) count++;\n        }\n   \
    \ }\n    return count;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Count non-overlaping cases.\n    >>> how_many_times_ns(\"\
    \", \"a\")\n    0L\n    >>> how_many_times_ns(\"aaa\", \"a\")\n    3L\n    >>>\
    \ how_many_times_ns(\"aaaa\", \"aa\")\n    0L\n    \n*/\nlong how_many_times_ns(string\
    \ string, string substring) \n{\n    long count = 0;\n    for (int i = 0; i <\
    \ string.length(); i++) {\n        for (int j = 0; j < substring.length(); j++)\
    \ {\n            if (string[i] == substring[j] && i != j) count++;\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count non-overlaping cases.\n    >>> how_many_times_n_ss(\"\
    \", \"a\")\n    0L\n    >>> how_many_times_n_ss(\"aaa\", \"a\")\n    3L\n    >>>\
    \ how_many_times_n_ss(\"aaaa\", \"aa\")\n    0L\n    \n*/\nlong how_many_times_n_ss(string\
    \ string, string substring) \n{\n    long count = 0;\n    for (int i = 0; i <\
    \ string.length(); i++) {\n        for (int j = 0; j < substring.length(); j++)\
    \ {\n            if (string[i] == substring[j] && i != j) count++;\n        }\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count overlaping cases.\n    >>> how_many_times_nt(\"\
    \", \"a\")\n    0L\n    >>> how_many_times_nt(\"aaa\", \"a\")\n    3L\n    >>>\
    \ how_many_times_nt(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong how_many_times_nt(string\
    \ string, string substring) \n{\n    long count = 0;\n    for (int i = 0; i <\
    \ string.length(); i++) {\n        for (int j = 0; j < substring.length(); j++)\
    \ {\n            if (string[i] == substring[j] && i != j) count++;\n        }\n\
    \    }\n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0vsaky_m.d(16): Error: no property `length` for type `string`

    /tmp/tmp0vsaky_m.d(17): Error: no property `length` for type `string`

    /tmp/tmp0vsaky_m.d(36): Error: no property `length` for type `string`

    /tmp/tmp0vsaky_m.d(37): Error: no property `length` for type `string`

    /tmp/tmp0vsaky_m.d(56): Error: no property `length` for type `string`

    /tmp/tmp0vsaky_m.d(57): Error: no property `length` for type `string`

    /tmp/tmp0vsaky_m.d(76): Error: no property `length` for type `string`

    /tmp/tmp0vsaky_m.d(77): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0vsaky_m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int i = 0;\n    int\
    \ j = 0;\n    int count = 0;\n    while (i < string.Length - substring.length)\
    \ \n    {\n        if (string.Substring(i, substring.length).Equals(substring))\n\
    \        {\n            count++;\n        }\n        i += substring.length + 1;\n\
    \    }\n    return count;\n}\n/*\n Find how many times a given substring can be\
    \ found in the original string. Count non-overlapping cases.\n    >>> how_many_times_no_overlap(\"\
    \", \"a\")\n    0L\n    >>> how_many_times_no_overlap(\"aaa\", \"a\")\n    2L\n\
    \    >>> how_many_times_no_overlap(\"aaaa\", \"aa\")\n    2L\n*/\nlong how_many_times_no_overlap(string\
    \ string, string substring) \n{\n    int i = 0;\n    int j = 0;\n    int count\
    \ = 0;\n    while (i < string.Length - substring.length) \n    {\n        if (string.Substring(i,\
    \ substring.length).Equals(substring))\n        {\n            count++;\n    \
    \    }\n        i += substring.length + 1;\n    }\n    return count;\n}\n/*\n\
    \ Find how many times a given substring can be found in the original string. Count\
    \ overlaping cases. \n    >>> how_many_times_no_overlap(\"\", \"a\")\n    0L\n\
    \    >>> how_many_times_no_overlap(\"aaa\", \"a\")\n    2L\n    >>> how_many_times_no_overlap(\"\
    aaaa\", \"aa\")\n    2L\n*/\nlong how_many_times_no_overlap_v2(string string,\
    \ string substring) \n{\n    int i = 0;\n    int j = 0;\n    int count = 0;\n\
    \    while (i < string.Length - substring.length) \n    {\n        if (string.Substring(i,\
    \ substring.length).Equals(substring))\n        {\n            count++;\n    \
    \    }\n        i += substring.length + 1;\n    }\n    return count;\n}\n/*\n\
    \ Return the string with the longest common prefix with the given suffix.\n >>>\
    \ longest_common_prefix(\"hello\", \"lo\")\n 'he'\n >>> longest_common_prefix(\"\
    hello\", \"he\")\n 'h'\n*/\nstring longest_common_prefix(string s1, string s2)\n\
    {\n    int i = 0;\n    int j = 0;\n    string prefix = string.Empty;\n    while\
    \ (i < s1.Length - s2.Length + 1 && j < s2.Length) \n    {\n        if (s1.Substring(i,\
    \ s2.Length).Equals(s2))\n        {\n            prefix = s2.Substring(0, j);\n\
    \            break;\n        }\n        if (s1.Substring(i, s2.Length).Equals(s2))\n\
    \        {\n            prefix = s2.Substring(0, j);\n            break;\n   \
    \     }\n        i += s1.Length - s2.Length + 1;\n        j = s2.Length;\n   \
    \ }\n\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpht5k3s94.d(104): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpht5k3s94.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\t\n\
    \tint i = 0;\n\t\n\twhile (i < string.length()) {\n\t\tint end = i + substring.length();\n\
    \t\t\n\t\tif (end > string.length()) end = string.length();\n\t\t\n\t\tif (string.compare(i,\
    \ end, substring, 0, substring.length()) == 0) {\n\t\t\tcount++;\n\t\t\ti = end;\n\
    \t\t}\n\t\telse {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn count;\n}\nunittest\n{\n \
    \   alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5bcoe363.d(19): Error: no property `length` for type `string`

    /tmp/tmp5bcoe363.d(20): Error: no property `length` for type `string`

    /tmp/tmp5bcoe363.d(22): Error: no property `length` for type `string`

    /tmp/tmp5bcoe363.d(22): Error: no property `length` for type `string`

    /tmp/tmp5bcoe363.d(24): Error: no property `compare` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5bcoe363.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if(string.size() <\
    \ substring.size())\n        return 0;\n    \n    long count = 0;\n    \n    for(int\
    \ i = 0; i < string.size(); ++i)\n    {\n        if(string.at(i) == substring.at(i))\n\
    \            count++;\n    }\n    \n    return count;\n}\n    \n//#include <iostream>\n\
    unittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\"\
    , \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps23inmxt.d(15): Error: no property `size` for type `string`

    /tmp/tmps23inmxt.d(15): Error: no property `size` for type `string`

    /tmp/tmps23inmxt.d(20): Error: no property `size` for type `string`

    /tmp/tmps23inmxt.d(22): Error: no property `at` for type `string`

    /tmp/tmps23inmxt.d(22): Error: no property `at` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps23inmxt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tfor\
    \ (int i = 0; i < (int)string.length(); i++) {\n\t\tif (string[i] == substring[0])\
    \ {\n\t\t\tfor (int j = 1; j < substring.length(); j++) {\n\t\t\t\tif (string[i\
    \ + j] != substring[j]) {\n\t\t\t\t\tcount = count + 1;\n\t\t\t\t\tbreak;\n\t\t\
    \t\t}\n\t\t\t}\n\t\t\tfor (int j = substring.length() - 1; j >= 0; j--) {\n\t\t\
    \t\tif (string[i + j] != substring[j]) {\n\t\t\t\t\tcount = count + 1;\n\t\t\t\
    \t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find a substring\
    \ in a string and replace it with a new one. \n    >>> replace(\"Hello!\", \"\
    !\", \"X\")\n    'HelloX'\n*/\nstring replace(string string, string substring,\
    \ string replacement) \n{\n\tstring result = string;\n\tfor (int i = 0; i < (int)string.length();\
    \ i++) {\n\t\tif (string[i] == substring[0]) {\n\t\t\tfor (int j = 1; j < substring.length();\
    \ j++) {\n\t\t\t\tif (string[i + j] != substring[j]) {\n\t\t\t\t\tresult = result\
    \ + replacement;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = substring.length()\
    \ - 1; j >= 0; j--) {\n\t\t\t\tif (string[i + j] != substring[j]) {\n\t\t\t\t\t\
    result = result + replacement;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn result;\n}\n/*\n Return an int array containing two elements. \n \
    \   >>> \"1,2,3\".split(\",\")\n    [1, 2, 3]\n*/\nstring split(string string,\
    \ string delimiter) {\n\tstring array[] = string.split(delimiter);\n\tstring result\
    \ = \"\";\n\tfor (int i = 0; i < array.length; i++) {\n\t\tif (i == array.length\
    \ - 1) {\n\t\t\tresult += array[i];\n\t\t} else {\n\t\t\tresult += array[i] +\
    \ \",\";\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Create a string of a given size\
    \ filled with spaces\n    >>> make_str(10)\n    '    '\n*/\nstring make_str(long\
    \ n) {\n\tstring result = \"\";\n\tfor (int i = 0; i < (int)n; i++) {\n\t\tresult\
    \ += \" \";\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps5wkdfcr.d(16): Error: C style cast illegal, use `cast(int)string.length()`

    /tmp/tmps5wkdfcr.d(42): Error: C style cast illegal, use `cast(int)string.length()`

    /tmp/tmps5wkdfcr.d(66): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] array`

    /tmp/tmps5wkdfcr.d(84): Error: C style cast illegal, use `cast(int)n`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps5wkdfcr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  if (string.Length ==\
    \ 0) \n  {\n    return 0;\n  }\n  \n  return \n  string.length() - string.find(substring,\
    \ 0) \n  - string.length() + string::find(string, substring, string::npos);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a |>\nYou can use Regex\n<code>\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj8ppsd_a.d(22): Error: found `:` when expecting `;` following `return`
    statement

    /tmp/tmpj8ppsd_a.d(22): Error: found `:` instead of statement

    /tmp/tmpj8ppsd_a.d(24): Error: declaration expected, not `<`

    /tmp/tmpj8ppsd_a.d(33): Error: declaration expected, not `assert`

    /tmp/tmpj8ppsd_a.d(34): Error: declaration expected, not `assert`

    /tmp/tmpj8ppsd_a.d(35): Error: declaration expected, not `assert`

    /tmp/tmpj8ppsd_a.d(36): Error: declaration expected, not `assert`

    /tmp/tmpj8ppsd_a.d(37): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj8ppsd_a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for(int i = 0; i < string.length(); i++)\n    {\n        for(int j = i; j\
    \ < string.length(); j++)\n        {\n            if(string[i] == substring[j])\n\
    \            {\n                count += 1;\n                break;\n        \
    \    }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ a lot, this was really helpful. I did some testing and it seems that your code\
    \ is faster than the other answers by about 3%.\n<|/ c |>\n<| a tags=string,python,search,algorithm,performance\
    \ |>\nUsing list comprehension\n<code>\ndef how_many_times(s, x):\n    return\
    \ sum(1 for i,j in enumerate(s) if (j==x) and (i<len(s) and s[i:i+len(x)]==x))\n\
    </code>\n<|/ a dscore=2 |>\n<| a tags=string,python,search,algorithm,performance\
    \ |>\nHere's a simple implementation, which can work with repeated substrings,\
    \ not just single characters:\n<code>\ndef how_many_times(s, sub):\n    ans =\
    \ 0\n    for start in range(len(s)):\n        for end in range(start+1, len(s)):\n\
    \            if s[start:end] == sub:\n                ans += 1\n    return ans\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\ndef how_many_times(string,\
    \ substring):\n    count = 0\n    i = 0\n    while True:\n        if string[i:i+len(substring)]\
    \ == substring:\n            count += 1\n            i += len(substring)\n   \
    \     else:\n            i = 0\n        if i == len(string):\n            return\
    \ count\n</code>\n<|/ a tags=string,python,search,algorithm,performance |>\n<|\
    \ c |>\nThis doesn't work for repeated substrings. For example, how_many_times(\"\
    aba\", \"a\") returns 2, but how_many_times(\"aba\", \"aa\") returns 3.\n<|/ c\
    \ |>\n<| c |>\nThanks, this works. However it seems slow for larger substrings.\n\
    <|/ c |>\n<| a tags=string,python,search,algorithm,performance dscore=1 |>\nTry\
    \ this :\n<code>\ndef how_many_times(string, substring):\n    count = 0\n    i\
    \ = 0\n    while i < len(string):\n        if string[i:i+len(substring)] == substring:\n\
    \            count += 1\n            i += len(substring)\n        else:\n    \
    \        i = i\n    return count\n</code>\n<|/ a |>\n<| c |>\nThanks. I edited\
    \ your answer to fix the indentation. :)\n<|/ c |>\n<| c |>\nThanks. In\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi9x557tl.d(29): Error: declaration expected, not `<`

    /tmp/tmpi9x557tl.d(42): Error: unterminated character constant

    /tmp/tmpi9x557tl.d(69): Error: unterminated character constant

    /tmp/tmpi9x557tl.d(98): Error: declaration expected, not `assert`

    /tmp/tmpi9x557tl.d(99): Error: declaration expected, not `assert`

    /tmp/tmpi9x557tl.d(100): Error: declaration expected, not `assert`

    /tmp/tmpi9x557tl.d(101): Error: declaration expected, not `assert`

    /tmp/tmpi9x557tl.d(102): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi9x557tl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    // find the number\
    \ of matches\n    long n = 0;\n    int i = 0, j = 0;\n    while (j < string.size())\
    \ {\n        if ((i < string.size()) && (string[i] == substring[j])) {\n     \
    \       i++;\n            j++;\n            n++;\n        }\n        else if ((i\
    \ >= string.size()) || (string[i] == substring[j])) {\n            break;\n  \
    \      }\n        else {\n            i = 0;\n            j = 0;\n        }\n\
    \    }\n    \n    return n;\n}\n</code>\nThis code is easy to understand, and\
    \ doesn't have to be a function. It can just be at the top level of a program\
    \ file.\n<|/ a |>\n<| a tags=string,java |>\nThis can be done by simply converting\
    \ both strings to character array and iterating through each characters. Once\
    \ we see that character is same for both strings then increment the count else\
    \ continue with the iteration.\n<|/ a dscore=0 |>\n<| c |>\nYes. But converting\
    \ them to char[] is not a solution, only a workaround. I suggest that the OP researchs\
    \ methods to do this with Strings.\n<|/ c |>\n<| c |>\nIt is not a workaround,\
    \ it is **the solution**.  String has a method `toCharArray`.\n<|/ c |>\n<| c\
    \ |>\n: If you want help with your code, post it.\n<|/ c |>\n<| a dscore=0 |>\n\
    This can be done by converting both strings to character array and iterating through\
    \ each characters. Once we see that character is same for both strings then increment\
    \ the count else continue with the iteration\n<|/ a tags=string,java |>\n<| c\
    \ |>\nWelcome to Stack Overflow! While this code snippet may solve the question,\
    \ [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a tags=string,java |>\n<code>\nimport java.util.*;\n\
    class StringLength {\n    public static void main(String[] args) {\n        Scanner\
    \ scanner = new Scanner(System.in);\n        int firstValue = scanner.nextInt();\n\
    \        int secondValue = scanner.nextInt();\n        System.out.println(\"first\
    \ String is \"+firstValue+\" chars long\");\n        System.out.println(\"second\
    \ String is \"+secondValue+\" chars long\");\n        int firstStringLength =\
    \ firstValue+1;\n        int secondStringLength = secondValue+1;\n        int\
    \ maxString\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp328j0ay2.d(35): Error: declaration expected, not `<`

    /tmp/tmp328j0ay2.d(36): Error: unterminated character constant

    /tmp/tmp328j0ay2.d(61): Error: identifier expected following `.`, not `in`

    /tmp/tmp328j0ay2.d(64): Error: identifier expected following `.`, not `out`

    /tmp/tmp328j0ay2.d(65): Error: identifier expected following `.`, not `out`

    /tmp/tmp328j0ay2.d(69): Error: semicolon expected, not `unittest`

    /tmp/tmp328j0ay2.d(69): Error: found `unittest` instead of statement

    /tmp/tmp328j0ay2.d(78): Error: `}` expected following members in `class` declaration
    at /tmp/tmp328j0ay2.d(59)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp328j0ay2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int pos = 0;\n    for\
    \ (auto it = string.begin(); (it != string.end()) && (pos < substring.size());\
    \ ++it, ++pos) {\n        if (*it == substring[pos])\n            ++count;\n \
    \   }\n    return count;\n}\n</code>\n<|/ a tags=string,c++ dscore=1 |>\n<| c\
    \ |>\nPlease don't post only code as an answer, but also provide an explanation\
    \ what your code does and how it solves the problem of the question. Answers with\
    \ an explanation are usually more helpful and of better quality, and are more\
    \ likely to attract upvotes.\n<|/ c |>\n<| c |>\nI don't think this really answers\
    \ the question. While it might get OP started, it doesn't really answer the question\
    \ in any way. I think your answer should have been a comment...\n<|/ c |>\n<|\
    \ c |>\nThe code is not intended to be complete.\n<|/ c |>\n<| c |>\nI edited\
    \ the question for clarity and added an explanation that hopefully helps.\n<|/\
    \ c |>\n<| c |>\nThe code *does* compile and work though.\n<|/ c |>\n<| a dscore=1\
    \ tags=string,c++ |>\nA simple and straightforward solution would be to start\
    \ off with the longest possible sub string, scan the whole string and see if every\
    \ character is equal to the sub string.\nThe complexity would be O(n) where n\
    \ is the length of the sub string, while counting the number of overlapping occurrences\
    \ would be O(n).\nThe idea of doing it this way is by making the code more general\
    \ so that it can be used regardless of the sub string length. For example, if\
    \ you only had the sub string to be \"a\" and wanted to find out how many times\
    \ the string \"abacaba\" occurred (counting overlapping occurrences), you could\
    \ just use the code above with a slight modification so that it checks for an\
    \ occurrence of the sub string in the rest of the string and doesn't do so for\
    \ the first character of the sub string.\n<|/ a |>\n<| c |>\nThis is an O(n) algorithm,\
    \ not O(n log n).\n<|/ c |>\n<| c |>\nHow is this an O(n) algorithm? Am I missing\
    \ something?\n<|/ c |>\n<| c |>\n`O(n log n)` means \"worst case\". So the best\
    \ case is `O(n)` (no time complexity given). But in the worst case you have to\
    \ look at every character in the string for every character, so it's `O(n)` also.\n\
    <|/ c |>\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzo6bk03q.d(22): Error: declaration expected, not `<`

    /tmp/tmpzo6bk03q.d(25): Error: unterminated character constant

    /tmp/tmpzo6bk03q.d(28): Error: unterminated character constant

    /tmp/tmpzo6bk03q.d(28): Error: unterminated character constant

    /tmp/tmpzo6bk03q.d(42): Error: unterminated character constant

    /tmp/tmpzo6bk03q.d(51): Error: unterminated character constant

    /tmp/tmpzo6bk03q.d(57): Error: declaration expected, not `assert`

    /tmp/tmpzo6bk03q.d(58): Error: declaration expected, not `assert`

    /tmp/tmpzo6bk03q.d(59): Error: declaration expected, not `assert`

    /tmp/tmpzo6bk03q.d(60): Error: declaration expected, not `assert`

    /tmp/tmpzo6bk03q.d(61): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzo6bk03q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (string == substring)\n\
    \        return 1L;\n    return string.length() - string.indexOf(substring) +\
    \ how_many_times(string.substr(string.indexOf(substring) + substring.length()),\
    \ substring);\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvfisao_s.d(17): Error: no property `length` for type `string`

    /tmp/tmpvfisao_s.d(17): Error: no property `indexOf` for type `string`

    /tmp/tmpvfisao_s.d(17): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvfisao_s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long n = string.length();\n\
    \    long m = substring.length();\n    long count = 0;\n    for (long i = 0; i\
    \ < n; i++) {\n        if (string.charAt(i) == substring.charAt(0)) {\n      \
    \      for (long j = i; j < m; j++) {\n                if (string.charAt(j) ==\
    \ substring.charAt(1)) {\n                    count += 2;\n                  \
    \  if (j == m-1) {\n                        break;\n                    }\n  \
    \              }\n            }\n        }\n    }\n    return count;\n}\n/*\n\
    \ Find how many times each given substring can be found in a string of given length.\n\
    \    >>> how_many_times(\"abcde\", \"abc\")\n    (1, 1, 1)\n    >>> how_many_times(\"\
    abcde\", \"ac\")\n    (0, 0)\n    >>> how_many_times(\"abcde\", \"ae\")\n    (0,\
    \ 1)\n    \n*/\ntuple<int,int,int> how_many_times(string string, string substring,\
    \ int length) \n{\n    long n = string.length();\n    long m = substring.length();\n\
    \    int counts[2] = { 0, 0 };\n    for (long i = 0; i < n; i++) {\n        if\
    \ (string.charAt(i) == substring.charAt(0)) {\n            for (long j = i; j\
    \ < m; j++) {\n                if (string.charAt(j) == substring.charAt(1)) {\n\
    \                    counts[0]++;\n                    if (j == m-1) {\n     \
    \                   break;\n                    }\n                }\n       \
    \     }\n        }\n    }\n    \n    for (long i = m-2; i >= 0; i--) {\n     \
    \   counts[1] += counts[0];\n        if (string.length() < i-1 || string.charAt(i)\
    \ != string.charAt(i+1)) {\n            break;\n        }\n    }\n    \n    return\
    \ tuple<int, int, int>(counts[0], counts[1], counts[0] + counts[1]);\n}\n/*\n\
    \ Find the minimum number of times each substring can be found in a string of\
    \ given length.\n    >>> how_many_times_min(\"abcde\", \"abc\")\n    (1, 1, 1)\n\
    \    >>> how_many_times_min(\"abcde\", \"ac\")\n    (1, 0)\n    >>> how_many_times_min(\"\
    abcde\", \"ae\")\n    (0, 0)\n    \n*/\ntuple<int,int,int> how_many_times_min(string\
    \ string, string substring, int length) \n{\n    long n = string.length();\n \
    \   long m = substring.length();\n    int counts[2] = { 0, 0 };\n    for (long\
    \ i = 0; i < n; i++) {\n        if (string.charAt(i) == substring.charAt(0)) {\n\
    \            for (long j = i; j < m; j++) {\n                if (string.charAt(j)\
    \ == substring.charAt(1)) {\n                    counts[0]++;\n              \
    \      if (j == m-1) {\n                        break;\n                    }\n\
    \                }\n            }\n        }\n    }\n    \n    for (long \nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdk51vrnl.d(42): Error: no identifier for declarator `tuple`

    /tmp/tmpdk51vrnl.d(42): Error: declaration expected, not `<`

    /tmp/tmpdk51vrnl.d(46): Deprecation: instead of C-style syntax, use D-style syntax
    `int[2] counts`

    /tmp/tmpdk51vrnl.d(47): Error: declaration expected, not `for`

    /tmp/tmpdk51vrnl.d(47): Error: no identifier for declarator `i`

    /tmp/tmpdk51vrnl.d(47): Error: declaration expected, not `<`

    /tmp/tmpdk51vrnl.d(47): Error: no identifier for declarator `i`

    /tmp/tmpdk51vrnl.d(47): Error: declaration expected, not `++`

    /tmp/tmpdk51vrnl.d(49): Error: no identifier for declarator `j`

    /tmp/tmpdk51vrnl.d(49): Error: declaration expected, not `<`

    /tmp/tmpdk51vrnl.d(49): Error: no identifier for declarator `j`

    /tmp/tmpdk51vrnl.d(49): Error: declaration expected, not `++`

    /tmp/tmpdk51vrnl.d(52): Error: declaration expected, not `if`

    /tmp/tmpdk51vrnl.d(54): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdk51vrnl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count=0;\n   \
    \ string temp=string;\n    bool flag=false;\n    \n    while(string!=\"\" && string!=substring){\n\
    \        if(string.find(substring,0,string.length())!=string.length()){\n    \
    \        flag=true;\n            count=count+1;\n        }\n        else{\n  \
    \          flag=false;\n        }\n        string=string.substr(string.length()-1);\n\
    \    }\n    \n    if(flag){\n        return count;\n    }\n    else{\n       \
    \ return -1;\n    }\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptbjt8jba.d(16): Error: `string` is used as a type

    /tmp/tmptbjt8jba.d(20): Error: no property `find` for type `string`

    /tmp/tmptbjt8jba.d(20): Error: no property `length` for type `string`

    /tmp/tmptbjt8jba.d(27): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptbjt8jba.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tfor\
    \ (int i = 0; i < string.length(); i++)\n\t{\n\t\tif (string[i] == substring[0]\
    \ && string[i + 1] == substring[1])\n\t\t{\n\t\t\tif (i + substring.length() ==\
    \ string.length())\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\
    \t\t\tcount += how_many_times(string.substring(i + 1), substring);\n\t\t\t}\n\t\
    \t}\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq36x5uc8.d(16): Error: no property `length` for type `string`

    /tmp/tmpq36x5uc8.d(20): Error: no property `length` for type `string`

    /tmp/tmpq36x5uc8.d(20): Error: no property `length` for type `string`

    /tmp/tmpq36x5uc8.d(26): Error: no property `substring` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq36x5uc8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   \n    for(auto c: string){\n        if(string.find(substring) != string::npos){\n\
    \            count += 1;\n            \n            string sub_sub = string.substr(string.find(substring),\
    \ substring.length());\n            \n            string sub_sub_lastpart = string.substr(string.find(substring)\
    \ + substring.length());\n            \n            string sub_sub_midpart = string.substr(string.find(substring),\
    \ substring.length() - substring.length());\n            \n            string\
    \ sub_sub_midpart_lastpart = string.substr(string.find(substring) + substring.length(),\
    \ substring.length());\n            \n            count += how_many_times(sub_sub,\
    \ substring);\n            count += how_many_times(sub_sub_midpart, substring);\n\
    \            count += how_many_times(sub_sub_midpart_lastpart, substring);\n \
    \       }\n        \n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbhfvk10p.d(17): Error: no identifier for declarator `c`

    /tmp/tmpbhfvk10p.d(17): Error: expression expected, not `:`

    /tmp/tmpbhfvk10p.d(17): Error: found `string` when expecting `;` following `for`
    condition

    /tmp/tmpbhfvk10p.d(18): Error: found `:` when expecting `)`

    /tmp/tmpbhfvk10p.d(18): Error: found `:` instead of statement

    /tmp/tmpbhfvk10p.d(35): Error: declaration expected, not `return`

    /tmp/tmpbhfvk10p.d(36): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbhfvk10p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if(string.size() <=\
    \ substring.length())\n        return 0;\n    \n    long count = 0;\n    string\
    \ temp = string;\n    for(int i = 0; i < string.length(); i++)\n    {\n      \
    \  for(int j = 0; j < substring.length(); j++)\n        {\n            if(temp.at(j)\
    \ == substring.at(j))\n                count++;\n        }\n        temp = temp\
    \ + string.at(i);\n    }\n    return count;\n}\n</code>\n<|/ a dscore=4 |>\n<|\
    \ a |>\nI'm a bit late to the party, but I had to do this myself recently so I\
    \ wrote this in Haskell. It uses the standard Data.Text package which has a number\
    \ of functions for string manipulation. I believe that the code is pretty self\
    \ explanatory.\n<code>\nimport qualified Data.Text as T\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf3w1yl9j.d(31): Error: declaration expected, not `<`

    /tmp/tmpf3w1yl9j.d(34): Error: unterminated character constant

    /tmp/tmpf3w1yl9j.d(41): Error: declaration expected, not `assert`

    /tmp/tmpf3w1yl9j.d(42): Error: declaration expected, not `assert`

    /tmp/tmpf3w1yl9j.d(43): Error: declaration expected, not `assert`

    /tmp/tmpf3w1yl9j.d(44): Error: declaration expected, not `assert`

    /tmp/tmpf3w1yl9j.d(45): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf3w1yl9j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t length = string.length();\n\
    \    size_t stringLength = string.length();\n    size_t substringLength = substring.length();\n\
    \    size_t count = 0;\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3u21yy4r.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3u21yy4r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tstring\
    \ temp_str = string;\n\tlong max_count = 0; \n\twhile(temp_str.size() > substring.size())\
    \ {\n\t\ttemp_str = temp_str.erase(substring.size() - 1);\n\t\tcount ++;\n\t}\n\
    \tfor(int i = 0; i < temp_str.size(); i++) {\n\t\tif(temp_str[i] == substring[0])\
    \ {\n\t\t\tstring temp_sub = temp_str.substr(0, i);\n\t\t\tstring temp_sub2 =\
    \ temp_str.substr(i);\n\t\t\tif(temp_sub.size() == substring.size() && how_many_times(temp_sub,\
    \ substring) > 0) {\n\t\t\t\tcount += how_many_times(temp_sub, substring);\n\t\
    \t\t\tif(how_many_times(temp_sub2, substring) == 0) {\n\t\t\t\t\tcount += how_many_times(temp_sub2,\
    \ substring);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcount += how_many_times(temp_sub,\
    \ substring);\n\t\t\t}\n\t\t}\n\t}\n\t/*if(count > max_count) {\n\t\tmax_count\
    \ = count;\n\t}*/\n\treturn count;\n}\n/*\n Find the first instance of a substring\
    \ in a string. Return -1 in case that the substring is not found.\n    >>> find_first_instance(\"\
    aaaaaa\", \"a\")\n    2\n    >>> find_first_instance(\"aaaaaa\", \"bb\")\n   \
    \ -1\n*/\nlong find_first_instance(string string, string substring) \n{\n\tstring\
    \ temp_str = string;\n\tlong count = 0;\n\twhile(temp_str.size() > substring.size())\
    \ {\n\t\ttemp_str = temp_str.erase(substring.size() - 1);\n\t\tcount ++;\n\t}\n\
    \tfor(int i = 0; i < temp_str.size(); i++) {\n\t\tif(temp_str[i] == substring[0])\
    \ {\n\t\t\tstring temp_sub = temp_str.substr(0, i);\n\t\t\tif(temp_sub.size()\
    \ == substring.size() && find_first_instance(temp_sub, substring) > 0) {\n\t\t\
    \t\treturn count;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n/*\n Find the last instance\
    \ of a substring in a string. Return -1 in case that the substring is not found.\n\
    \    >>> find_last_instance(\"aaaaaa\", \"a\")\n    3\n    >>> find_last_instance(\"\
    aaaaaa\", \"bb\")\n    -1\n*/\nlong find_last_instance(string string, string substring)\
    \ \n{\n\tstring temp_str = string;\n\tlong count = 0;\n\twhile(temp_str.size()\
    \ > substring.size()) {\n\t\ttemp_str = temp_str.erase(substring.size() - 1);\n\
    \t\tcount ++;\n\t}\n\tfor(int i = 0; i < temp_str.size(); i++) {\n\t\tif(temp_str[i]\
    \ == substring[0]) {\n\t\t\tstring temp_sub = temp_str.substr(0, i);\n\t\t\tif(temp_sub.size()\
    \ == substring.size() && find_last_instance(temp_sub, substring) > 0) {\n\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgnnltirl.d(86): Error: found `unittest` instead of statement

    /tmp/tmpgnnltirl.d(95): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpgnnltirl.d(95): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpgnnltirl.d(95): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgnnltirl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164234
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\t\n\
    \tfor (int i = 0; i < string.length(); i++) {\n\t\tfor (int j = 0; j < substring.length();\
    \ j++) {\n\t\t\tif (string.charAt(i) == substring.charAt(j)) {\n\t\t\t\tcount++;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn count;\n}\nunittest\n{\n   \
    \ alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl7kcsfz4.d(17): Error: no property `length` for type `string`

    /tmp/tmpl7kcsfz4.d(18): Error: no property `length` for type `string`

    /tmp/tmpl7kcsfz4.d(19): Error: no property `charAt` for type `string`

    /tmp/tmpl7kcsfz4.d(19): Error: no property `charAt` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl7kcsfz4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if (string == substring)\n\
    \        return 1;\n    if (string.find(substring) == string.length()-1)\n   \
    \     return 1;\n    long count = 1;\n    int substring_index = 0;\n    for (int\
    \ i = 0; i < string.length()-1; ++i) {\n        if (string.compare(i, substring_index,\
    \ substring.length(), 0, substring.length()) == 0)\n            ++count;\n   \
    \     substring_index += 1;\n    }\n    return count;\n}\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfpc_uni5.d(17): Error: no property `find` for type `string`

    /tmp/tmpfpc_uni5.d(17): Error: no property `length` for type `string`

    /tmp/tmpfpc_uni5.d(21): Error: no property `length` for type `string`

    /tmp/tmpfpc_uni5.d(22): Error: no property `compare` for type `string`

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    size_t start = 0;\n\
    \    size_t index = string.find(substring, start);\n    long count = string.size()\
    \ - index;\n    if (index != string::npos) \n        count += how_many_times(string.substr(start,\
    \ index + 1), substring);\n    return count;\n}\n</code>\n<|/ a tags=c++,algorithm,string\
    \ |>\n<| a tags=c++,algorithm,string dscore=1 |>\nI came up with this solution:\n\
    <code>\n long HowManyTimes(string searchFor, string myString)\n    {\n       \
    \ string str1 = \"\";\n        string str2 = \"\";\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5joyoslc.d(18): Error: found `:` when expecting `)`

    /tmp/tmp5joyoslc.d(18): Error: found `:` instead of statement

    /tmp/tmp5joyoslc.d(22): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5joyoslc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   int i, j;\n    \n    for(i = 0; i < string.Length; i++)\n    {\n        if(string[i]\
    \ == substring[0]) {\n            for(j = i; j < string.Length; j++) {\n     \
    \           if(string[j] == substring[1]) {\n                    count++;\n  \
    \                  break;\n                }\n            }\n        }\n    }\n\
    \    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpum7lxw4e.d(18): Error: no property `Length` for type `string`

    /tmp/tmpum7lxw4e.d(21): Error: no property `Length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpum7lxw4e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    if(string.length ==\
    \ substring.length) return 0;\n    if(string.length == 0 || substring.length ==\
    \ 0) return 0;\n    \n    long n = string.length();\n    long m = substring.length();\n\
    \    long count = 0;\n    \n    for(long i = 0; i < n; ++i) {\n        for(long\
    \ j = 0; j < m; ++j) {\n            if(string[i] == substring[j])\n          \
    \      count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string-matching,python,string,pattern-matching\
    \ |>\n<| c |>\nThis was the fastest and easiest to understand solution for me.\
    \ Great job!\n<|/ c |>\n<| a dscore=5 |>\nPython has a number of string methods\
    \ for searching text.\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp56_otzmg.d(30): Error: declaration expected, not `<`

    /tmp/tmp56_otzmg.d(41): Error: declaration expected, not `assert`

    /tmp/tmp56_otzmg.d(42): Error: declaration expected, not `assert`

    /tmp/tmp56_otzmg.d(43): Error: declaration expected, not `assert`

    /tmp/tmp56_otzmg.d(44): Error: declaration expected, not `assert`

    /tmp/tmp56_otzmg.d(45): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp56_otzmg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    // TODO Optimize by\
    \ counting the overlaps instead of doing a linear scan\n    long total = 0;\n\
    \    \n    // Iterate over the string until we find the substring\n    for(string::iterator\
    \ ii = string.begin(); ii != string.end(); ++ii)\n    {\n        for(string::iterator\
    \ si = substring.begin(); si != substring.end(); ++si) \n        {\n         \
    \   string a = *ii;\n            string b = *si;\n            if(a.find(b) !=\
    \ string::npos) \n            {\n                ++total;\n            }\n   \
    \     }\n    }\n    \n    return total;\n}\nunittest\n{\n    alias candidate =\
    \ how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpby36kppk.d(19): Error: use `.` for member lookup, not `::`

    /tmp/tmpby36kppk.d(19): Error: found `ii` when expecting `;` following `for` condition

    /tmp/tmpby36kppk.d(19): Error: expression expected, not `=`

    /tmp/tmpby36kppk.d(19): Error: found `string` when expecting `)`

    /tmp/tmpby36kppk.d(19): Error: found `)` when expecting `;` following statement

    /tmp/tmpby36kppk.d(21): Error: use `.` for member lookup, not `::`

    /tmp/tmpby36kppk.d(21): Error: found `si` when expecting `;` following `for` condition

    /tmp/tmpby36kppk.d(21): Error: expression expected, not `=`

    /tmp/tmpby36kppk.d(21): Error: found `substring` when expecting `)`

    /tmp/tmpby36kppk.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmpby36kppk.d(25): Error: found `:` when expecting `)`

    /tmp/tmpby36kppk.d(25): Error: found `:` instead of statement

    /tmp/tmpby36kppk.d(32): Error: declaration expected, not `return`

    /tmp/tmpby36kppk.d(33): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpby36kppk'
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  int len = substring.length();\n\
    \  int count = 0;\n  if (string == substring) return count; // 0 matches\n  if\
    \ (string.length() == 0) return count; // empty string\n  for (int i = 0; i <\
    \ string.length(); i++) {\n    if (string[i] == substring[0])\n      if (substring.length()\
    \ == 1) return count; // single match\n      else count += how_many_times(string.substring(i\
    \ + 1), substring);\n  }\n  return count;\n}\n</code>\nNote that this implementation\
    \ is O(n). You can find other efficient algorithms for finding substring occurrences\
    \ here.\n<|/ a |>\n<| c |>\nThis only works if the substring is at the beginning\
    \ of the string. I'm pretty sure this is what OP is looking for though.\n<|/ c\
    \ |>\n<| c |>\nYou're right, good catch. The OP should clarify what the expected\
    \ behaviour is.\n<|/ c |>\n<| a tags=algorithm,string,c++ dscore=2 |>\nO(N) solution,\
    \ also with C++\n<code>\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprwuq6aq9.d(26): Error: declaration expected, not `<`

    /tmp/tmprwuq6aq9.d(30): Error: unterminated character constant

    /tmp/tmprwuq6aq9.d(33): Error: unterminated character constant

    /tmp/tmprwuq6aq9.d(42): Error: declaration expected, not `assert`

    /tmp/tmprwuq6aq9.d(43): Error: declaration expected, not `assert`

    /tmp/tmprwuq6aq9.d(44): Error: declaration expected, not `assert`

    /tmp/tmprwuq6aq9.d(45): Error: declaration expected, not `assert`

    /tmp/tmprwuq6aq9.d(46): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprwuq6aq9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   if (string.Length <= substring.Length) return 0;\n    for (int i = 0; i <\
    \ string.Length; i++)\n    {\n        if (string[i] != substring[i]) break;\n\
    \        count++;\n    }\n    return count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfogmdl7i.d(16): Error: no property `Length` for type `string`

    /tmp/tmpfogmdl7i.d(16): Error: no property `Length` for type `string`

    /tmp/tmpfogmdl7i.d(17): Error: no property `Length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfogmdl7i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   \n    bool start = true;\n    for(int i = 0; i < string.length(); i++)\n \
    \   {\n        if(string.at(i) == substring.at(0))\n        {\n            if(start)\n\
    \                start = false;\n            else\n                count++;\n\
    \        }\n        else if(string.at(i) == substring.at(1))\n        {\n    \
    \        if(start)\n                count++;\n        }\n        else\n      \
    \      count = 0;\n    }\n    return count;\n}\n/*\n Write a function to find\
    \ all substrings that occur in a given string. \n Examples:\n    >>> find_substrings(\"\
    a\", \"bcdaefiklnmoprstuwxy\")\n    [\"bcda\", \"ef\", \"kl\", \"mo\", \"pr\"\
    , \"stu\", \"wxy\"]\n    >>> find_substrings(\"asdfjkl;\", \";\")\n    []\n  \
    \  >>> find_substrings(\"asdfjkl;\", \"asdfjkl;\")\n    [\"asdfjkl;\"]\n*/\nvector<string>\
    \ find_substrings(string string, string substring)\n{\n    vector<string> substrings;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j\
    \ < substring.length(); j++)\n        {\n            if(string.at(i) == substring.at(j))\n\
    \            {\n                substrings.push_back(string.substr(i, substring.length()));\n\
    \            }\n        }\n    }\n    return substrings;\n}\n/*\n Write a function\
    \ to remove all occurrences of substrings that occur in a given string. \n Examples:\n\
    \    >>> remove_substrings(\"a\", \"bcdaefiklnmoprstuwxy\")\n    \"bcdacdefiklnmoprstuwxy\"\
    \n    >>> remove_substrings(\"asdfjkl;\", \";\")\n    \"asdfjkl;\"\n*/\nstring\
    \ remove_substrings(string string, string substring)\n{\n    string out = string;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        for(int j = 0; j\
    \ < substring.length(); j++)\n        {\n            if(string.at(i) == substring.at(j))\n\
    \            {\n                out = out.substr(0, i) + out.substr(i + substring.length(),\
    \ string.length() - i - substring.length());\n            }\n        }\n    }\n\
    \    return out;\n}\n/*\n Write a function that accepts a string and two functions\
    \ as parameters. \n The first function will be used to generate all possible substrings\
    \ of a given string. \n The second function will be used to compare a given substring\
    \ to a given string. \n If the given substring matches a substring in the given\
    \ string, then the given function will be called with the substring. \n Otherwise\
    \ the given function will be called without parameters. \n Examples:\n    >>>\
    \ generate_substrings(\"asdfjkl;\", \";\")\n    [\"asdfjkl;\"]\n\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsx5ymwsn.d(47): Error: no identifier for declarator `vector`

    /tmp/tmpsx5ymwsn.d(47): Error: declaration expected, not `<`

    /tmp/tmpsx5ymwsn.d(50): Error: declaration expected, not `for`

    /tmp/tmpsx5ymwsn.d(50): Error: no identifier for declarator `i`

    /tmp/tmpsx5ymwsn.d(50): Error: declaration expected, not `<`

    /tmp/tmpsx5ymwsn.d(50): Error: no identifier for declarator `i`

    /tmp/tmpsx5ymwsn.d(50): Error: declaration expected, not `++`

    /tmp/tmpsx5ymwsn.d(52): Error: no identifier for declarator `j`

    /tmp/tmpsx5ymwsn.d(52): Error: declaration expected, not `<`

    /tmp/tmpsx5ymwsn.d(52): Error: no identifier for declarator `j`

    /tmp/tmpsx5ymwsn.d(52): Error: declaration expected, not `++`

    /tmp/tmpsx5ymwsn.d(57): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsx5ymwsn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long cnt = 0;\n   \
    \ int minlen = substring.size();\n    if (string.empty()) {\n        return 0;\n\
    \    }\n    if (string.size() <= minlen) {\n        return 0;\n    }\n    int\
    \ pos = string[minlen];\n    int start = 0;\n    while (pos != 0) {\n        if\
    \ (string.compare(minlen, minlen + pos) == 0) {\n            cnt++;\n        \
    \    pos += 1;\n        } else {\n            if (string.compare(minlen, minlen\
    \ + pos) > 0) {\n                cnt++;\n                pos += 1;\n         \
    \   } else if (string.compare(minlen, minlen + pos) < 0) {\n                pos\
    \ += 1;\n            } else {\n                break;\n            }\n       \
    \ }\n    }\n    return cnt;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgjs353kb.d(16): Error: no property `size` for type `string`

    /tmp/tmpgjs353kb.d(17): Error: no property `empty` for type `string`

    /tmp/tmpgjs353kb.d(20): Error: no property `size` for type `string`

    /tmp/tmpgjs353kb.d(26): Error: no property `compare` for type `string`

    /tmp/tmpgjs353kb.d(30): Error: no property `compare` for type `string`

    /tmp/tmpgjs353kb.d(33): Error: no property `compare` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgjs353kb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tint\
    \ len1 = string.length();\n\tint len2 = substring.length();\n\tfor(int i = 0;\
    \ i < len1; i++)\n\t{\n\t\tfor(int j = 0; j < len2; j++)\n\t\t{\n\t\t\tif(string[i]\
    \ == substring[j])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tif(i == len1 - 1 || j ==\
    \ len2 - 1 || string[i+1] != substring[j+1]) count++;\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t}\n\t}\n\treturn count;\n}\n/*\n Find the index of a substring in a string.\n\
    \    >>> indexof(\"apple\", \"apple\")\n    0L\n    >>> indexof(\"apple\", \"\
    aple\")\n    0L\n    >>> indexof(\"apple\", \"aplle\")\n    1L\n*/\nlong indexof(string\
    \ string, string substring) \n{\n\tlong index = string.length();\n\tint len1 =\
    \ string.length();\n\tint len2 = substring.length();\n\tfor(int i = 0; i < len1;\
    \ i++)\n\t{\n\t\tif(string[i] == substring[0]) index--;\n\t\tfor(int j = 0; j\
    \ < len2; j++)\n\t\t{\n\t\t\tif(string[i+j] != substring[j]) break;\n\t\t\tif(j\
    \ == len2-1) index++;\n\t\t}\n\t\tif(index == 0) break;\n\t}\n\treturn index;\n\
    }\n/*\n Find the last index of a substring in a string.\n    >>> lastindexof(\"\
    apple\", \"apple\")\n    0L\n    >>> lastindexof(\"apple\", \"aple\")\n    4L\n\
    \    >>> lastindexof(\"apple\", \"aplle\")\n    4L\n*/\nlong lastindexof(string\
    \ string, string substring) \n{\n\tlong index = string.length();\n\tint len1 =\
    \ string.length();\n\tint len2 = substring.length();\n\tfor(int i = len1-1; i\
    \ >= 0; i--)\n\t{\n\t\tif(string[i] == substring[0]) index--;\n\t\tfor(int j =\
    \ 0; j < len2; j++)\n\t\t{\n\t\t\tif(string[i+j] != substring[j]) break;\n\t\t\
    \tif(j == len2-1) index--;\n\t\t}\n\t\tif(index == 0) break;\n\t}\n\treturn index;\n\
    }\n/*\n Search the string for the first occurrence of a substring\n    >>> findin(\"\
    apple\", \"apple\")\n    3L\n    >>> findin(\"apple\", \"aple\")\n    1L\n   \
    \ >>> findin(\"apple\", \"aplle\")\n    6L\n*/\nlong findin(string string, string\
    \ substring) \n{\n\tlong index = string.length();\n\tint len1 = string.length();\n\
    \tint len2 = substring.length();\n\tfor(int i = 0; i < len1; i++)\n\t{\n\t\tif(string[i]\
    \ == substring[0]) index--;\n\t\tfor(int j = 0; j < len2; j++)\n\t\t{\n\t\t\t\
    if(string[i+j] != substring[j]\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp1mnfd5j.d(104): Error: found `unittest` when expecting `)`

    /tmp/tmpp1mnfd5j.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpp1mnfd5j.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpp1mnfd5j.d(113): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp1mnfd5j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for(int i = 0, j = string.length() - substring.length(); i < string.length()\
    \ - substring.length(); i++, j++)\n    {\n        if(string.charAt(i) == substring.charAt(j))\n\
    \        {\n            count++;\n            i += substring.length();\n     \
    \   }\n        else\n        {\n            break;\n        }\n    }\n    return\
    \ count;\n}\n</code>\nAnd here is the new version of the function, now it counts\
    \ overlapped cases:\n<code>\n#include <stdio.h>\n#include <string.h>\n#include\
    \ <stdlib.h>\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcsrhppzb.d(30): Error: declaration expected, not `<`

    /tmp/tmpcsrhppzb.d(40): Error: declaration expected, not `assert`

    /tmp/tmpcsrhppzb.d(41): Error: declaration expected, not `assert`

    /tmp/tmpcsrhppzb.d(42): Error: declaration expected, not `assert`

    /tmp/tmpcsrhppzb.d(43): Error: declaration expected, not `assert`

    /tmp/tmpcsrhppzb.d(44): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcsrhppzb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long i = 0;\n    size_t\
    \ len = string.size();\n    size_t s_len = substring.size();\n    string sub =\
    \ substring;\n    if(s_len == 0)\n        return 0;\n    while(i < len) {\n  \
    \      size_t j = string.find(sub);\n        if(j == string::npos)\n         \
    \   return 0L;\n        if(i < j) \n            i++;\n        else {\n       \
    \     i += s_len+1;\n            ++j;\n            if(j == len)\n            \
    \    break;\n            else\n                sub += substring[j];\n        }\n\
    \    }\n    return i - string.find(sub);\n}\n/*\n Return true if the string starts\
    \ with substring. Otherwise, return false.\n Note: This function is not case sensitive.\
    \ \n*/\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpls4mjc0w.d(23): Error: found `:` when expecting `)`

    /tmp/tmpls4mjc0w.d(23): Error: found `:` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpls4mjc0w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tstring s_dup = string;\n\
    \tstring substr_dup = substring;\n\tbool found;\n\tlong count = 0;\n\t\n\tfor\
    \ (int i = 0; i < substr_dup.length(); i++)\n\t{\n\t\tfound = false;\n\t\tfor\
    \ (int j = 0; j < s_dup.length(); j++)\n\t\t{\n\t\t\tif (s_dup[j] == substr_dup[i])\n\
    \t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\
    \t\t\tbreak;\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring\
    \ can be found in the original string. Count only the first occurrences.\n   \
    \ >>> how_many_times_first(\"aaa\", \"a\")\n    1L\n    >>> how_many_times_first(\"\
    aaaa\", \"a\")\n    0L\n*/\nlong how_many_times_first(string string, string substring)\
    \ \n{\n\tstring s_dup = string;\n\tstring substr_dup = substring;\n\tbool found;\n\
    \tlong count = 0;\n\t\n\tfor (int i = 0; i < substr_dup.length(); i++)\n\t{\n\t\
    \tfound = false;\n\t\tfor (int j = 0; j < s_dup.length(); j++)\n\t\t{\n\t\t\t\
    if (s_dup[j] == substr_dup[i])\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\treturn count;\n}\n/*\n Find\
    \ how many times a given substring can be found in the original string. Count\
    \ only the last occurrences.\n    >>> how_many_times_last(\"aaa\", \"a\")\n  \
    \  1L\n    >>> how_many_times_last(\"aaaa\", \"a\")\n    0L\n*/\nlong how_many_times_last(string\
    \ string, string substring) \n{\n\tstring s_dup = string;\n\tstring substr_dup\
    \ = substring;\n\tbool found;\n\tlong count = 0;\n\t\n\tfor (int i = 0; i < substr_dup.length();\
    \ i++)\n\t{\n\t\tfound = false;\n\t\tfor (int j = s_dup.length(); j > 0; j--)\n\
    \t\t{\n\t\t\tif (s_dup[j-1] == substr_dup[i])\n\t\t\t{\n\t\t\t\tfound = true;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\tbreak;\n\t}\n\treturn count;\n\
    }\n/*\n Find the first occurrence of a given substring in the original string.\
    \ Return index if found or -1 if not found.\n    >>> how_many_times(\"aaa\", \"\
    aa\")\n    1L\n    >>> how_many_times(\"aaaa\", \"a\")\n    1L\n    >>> how_many_times(\"\
    aaaa\", \"b\")\n    -1L\n*/\nlong how_many_times(string string, string substring,\
    \ bool from_start) \nunittest\n{\n    alias candidate = how_many_times;\n\n  \
    \  assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd0a5tn6a.d(106): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd0a5tn6a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int pos = 0;\n    long\
    \ count = 0L;\n    string sub;\n    \n    while (pos < string.length()) {\n  \
    \      sub = string.substr(pos, substring.length());\n        if (sub == substring)\n\
    \            count++;\n        pos = pos + substring.length();\n    }\n    \n\
    \    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp43wfxq5k.d(17): Error: `string` is used as a type

    /tmp/tmp43wfxq5k.d(19): Error: no property `length` for type `string`

    /tmp/tmp43wfxq5k.d(23): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp43wfxq5k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long length = 0;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string.substring_of(i,\
    \ string.length() - substring.length()) == substring)\n            length++;\n\
    \    }\n    return length;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwij6g6zr.d(16): Error: no property `length` for type `string`

    /tmp/tmpwij6g6zr.d(18): Error: no property `substring_of` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwij6g6zr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tif (string == \"\") return\
    \ 0;\n\tif (string.length == 0) return 0;\n\tlong count = 0, i = 0;\n\twhile (i<string.length\
    \ && string[i] == substring[0])\n\t{\n\t\tif (string[i] == substring[0] && substring[0]\
    \ == string.substr(i+1, substring.length).c_str()[0]) \n\t\t\ti++;\n\t\telse i++;\n\
    \t\tcount++;\n\t}\n\treturn count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1o03x6lu.d(20): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1o03x6lu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int j = 0;\n    long\
    \ count = 0;\n    string tmp = string;\n    while(tmp[j] != substring[j])\n  \
    \  {\n        if(j == string.length()-1)\n            break;\n        j++;\n \
    \   }\n    int endj = j;\n    for(int i = j+1;i < string.length(); i++)\n    {\n\
    \        if(string[i] == substring[j])\n            count++;\n        else\n \
    \           break;\n        j++;\n    }\n    return count;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis code has two bugs: 1) It miscounts overlapping occurrences\
    \ of substring.  2) It miscounts occurrences of substring at the first position\
    \ of the string.  You need to fix these bugs.  Also, it would be better to use\
    \ `int j = 0, i = 0` to avoid these problems.\n<|/ c |>\n<| c |>\n: Thanks Jason.\
    \ I didn't know these issues. I have edited my answer.\n<|/ c |>\n<| c |>\n: Thanks,\
    \ I didn't know that Jason mentions them. Edited my answer.\n<|/ c |>\n<| a dscore=1\
    \ |>\nYou can try the following:\n<code>\n// Count the number of substrings in\
    \ a string\n// by looking for the next occurrence of a substring\nunittest\n{\n\
    \    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") ==\
    \ 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgdlrwtew.d(35): Error: declaration expected, not `<`

    /tmp/tmpgdlrwtew.d(41): Error: unterminated character constant

    /tmp/tmpgdlrwtew.d(44): Error: unterminated character constant

    /tmp/tmpgdlrwtew.d(55): Error: declaration expected, not `assert`

    /tmp/tmpgdlrwtew.d(56): Error: declaration expected, not `assert`

    /tmp/tmpgdlrwtew.d(57): Error: declaration expected, not `assert`

    /tmp/tmpgdlrwtew.d(58): Error: declaration expected, not `assert`

    /tmp/tmpgdlrwtew.d(59): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgdlrwtew.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int i = 0;\n    int\
    \ j = 0;\n    while(i < string.len) {\n        j = string.find(substring, j);\n\
    \        if(j >= 0)\n            i += j - i;\n        ++j;\n    }\n    return\
    \ i;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=string,c++,performance |>\nI needed\
    \ a function that takes a string as input and gives a map of substrings to the\
    \ number of times they occur.  My solution turned out to be fairly simple - I\
    \ just needed an if-statement and a loop.  \n<code>\n#include <string>\n#include\
    \ <map>\n#include <stdio.h>\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp06p5iqv_.d(25): Error: declaration expected, not `<`

    /tmp/tmp06p5iqv_.d(37): Error: declaration expected, not `assert`

    /tmp/tmp06p5iqv_.d(38): Error: declaration expected, not `assert`

    /tmp/tmp06p5iqv_.d(39): Error: declaration expected, not `assert`

    /tmp/tmp06p5iqv_.d(40): Error: declaration expected, not `assert`

    /tmp/tmp06p5iqv_.d(41): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp06p5iqv_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count;\n    for\
    \ (count = 0L; count < string.length(); count++) \n    {\n        if ((string.indexOf(string[count],\
    \ substring) == 0L) \n          && (string.indexOf(string[count+1]) == string.length()-1))\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=string,performance,python |>\n<| c |>\n+1 Good job (but you made it\
    \ even more confusing by naming the method `how_many_times`). But I still prefer\
    \ your `search` solution (even if it is a little bit longer :).\n<|/ c |>\n<|\
    \ c |>\nAgreed. `search` may look a little easier to understand when you are coming\
    \ from other languages. In Python `search` isn't that great either, but if one\
    \ was to write it in C, the `for` loop would look very similar. :) The `search`\
    \ method is pretty simple and intuitive to understand though. :P\n<|/ c |>\n<|\
    \ c |>\n`search` is better because it doesn't require a `for` loop. But the `for`\
    \ loop is probably going to be the fastest solution, because you are only searching\
    \ a short substring in a longer string.\n<|/ c |>\n<| a tags=string,performance,python\
    \ dscore=2 |>\nSince this is a common problem with a common solution, I'll give\
    \ you a little perspective on how it can be solved:\nPython has a built-in method\
    \ called \"in\" that can tell you if a substring is inside a string:\n<code>\n\
    if \"foo\" in \"foobar\":\n    print \"foo is in foobar\"\nelse:\n    print \"\
    foo is not in foobar\"\n</code>\nThis code is also extremely concise and clearly\
    \ shows the intent of the solution. Notice that Python has built-in functions\
    \ for many common tasks such as this one. So, why write your own solution? You\
    \ probably know this already, but you might want to look into the string methods\
    \ available in the stdlib module. Think of this module as your \"language\" of\
    \ choice for doing string manipulation. \nNow, you might want to do something\
    \ really cool with the string you find, such as remove duplicates, replace characters,\
    \ or maybe even replace them with a different character. Perhaps you could get\
    \ fancy with your code, but the built-in string methods are a great place to start.\
    \ \nIn conclusion, yes, it would be great to be able to use these built-in functions,\
    \ and it's perfectly fine to do so. But don't bother with the complexity of implementing\
    \ your own \"string\" class. Use Python's string methods. \nHope that \nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplgggvv_p.d(26): Error: declaration expected, not `<`

    /tmp/tmplgggvv_p.d(32): Error: unterminated character constant

    /tmp/tmplgggvv_p.d(35): Error: unterminated character constant

    /tmp/tmplgggvv_p.d(38): Error: unterminated character constant

    /tmp/tmplgggvv_p.d(48): Error: unterminated character constant

    /tmp/tmplgggvv_p.d(48): Error: unterminated character constant

    /tmp/tmplgggvv_p.d(48): Error: unterminated character constant

    /tmp/tmplgggvv_p.d(54): Error: declaration expected, not `assert`

    /tmp/tmplgggvv_p.d(55): Error: declaration expected, not `assert`

    /tmp/tmplgggvv_p.d(56): Error: declaration expected, not `assert`

    /tmp/tmplgggvv_p.d(57): Error: declaration expected, not `assert`

    /tmp/tmplgggvv_p.d(58): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplgggvv_p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int index = substring.find(string);\n\
    \    if (index == string.length()) {\n        return 0;\n    }\n    return ((string.length\
    \ - index) * long(substring.length())) + how_many_times(string.substr(index),\
    \ substring);\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxiz4l_v0.d(15): Error: no property `find` for type `string`

    /tmp/tmpxiz4l_v0.d(16): Error: no property `length` for type `string`

    /tmp/tmpxiz4l_v0.d(19): Error: no property `length` for type `string`

    /tmp/tmpxiz4l_v0.d(19): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxiz4l_v0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  long count = 0;\n  int\
    \ i;\n  for(i = 0; i < string.length; ++i)\n  {\n    if(string[i] == substring[0])\n\
    \    {\n      ++count;\n      for(int j = 1; j < substring.length; ++j)\n    \
    \    if(string[i + j] != substring[j]) break;\n      if(j == substring.length)\
    \ \n        ++count;\n    }\n  }\n  return count;\n}\n/*\n Find how many times\
    \ a given substring can be found in a string. Count overlaping cases.\n    >>>\
    \ how_many_times(\"aba\", \"b\")\n    2L\n    >>> how_many_times(\"aba\", \"ba\"\
    )\n    2L\n    \n*/\nlong how_many_times(string string, string substring) \n{\n\
    \  long count = 0;\n  int i;\n  for(i = 0; i < string.length; ++i)\n  {\n    if(string[i]\
    \ == substring[0])\n    {\n      int j;\n      for(j = 1; j < substring.length;\
    \ ++j)\n        if(string[i + j] != substring[j]) break;\n      if(j == substring.length)\
    \ \n        ++count;\n    }\n  }\n  return count;\n}\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp02gy1jhw.d(24): Error: undefined identifier `j`

    /tmp/tmp02gy1jhw.d(59): Error: `tmp02gy1jhw.how_many_times` called with argument
    types `(string, string)` matches both:

    /tmp/tmp02gy1jhw.d(13):     `tmp02gy1jhw.how_many_times(string string, string
    substring)`

    and:

    /tmp/tmp02gy1jhw.d(38):     `tmp02gy1jhw.how_many_times(string string, string
    substring)`

    /tmp/tmp02gy1jhw.d(60): Error: `tmp02gy1jhw.how_many_times` called with argument
    types `(string, string)` matches both:

    /tmp/tmp02gy1jhw.d(13):     `tmp02gy1jhw.how_many_times(string string, string
    substring)`

    and:

    /tmp/tmp02gy1jhw.d(38):     `tmp02gy1jhw.how_many_times(string string, string
    substring)`

    /tmp/tmp02gy1jhw.d(61): Error: `tmp02gy1jhw.how_many_times` called with argument
    types `(string, string)` matches both:

    /tmp/tmp02gy1jhw.d(13):     `tmp02gy1jhw.how_many_times(string string, string
    substring)`

    and:

    /tmp/tmp02gy1jhw.d(38):     `tmp02gy1jhw.how_many_times(string string, string
    substring)`

    /tmp/tmp02gy1jhw.d(62): Error: `tmp02gy1jhw.how_many_'
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tint i = 0;\n\tint j =\
    \ 0;\n\tint count = 0;\n\tlong max = 0;\n\twhile(i < string.size() && j < substring.size())\
    \ {\n\t\tif(string[i] == substring[j]) {\n\t\t\ti++;\n\t\t\tj++;\n\t\t\tcount++;\n\
    \t\t\tif(count > max)\n\t\t\t\tmax = count;\n\t\t\telse {\n\t\t\t\tcount = 0;\n\
    \t\t\t}\n\t\t}\n\t\telse if(i == string.size()) {\n\t\t\tj++;\n\t\t\tif(j >= substring.size())\n\
    \t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tcount++;\n\t\t\tif(count > max)\n\t\t\t\t\
    max = count;\n\t\t\telse {\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\
    \t\tj++;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\treturn max;\n}\n\t\n/*\n Return the\
    \ longest substring that occurs in \"substring\".\n */\nstring longest_substring(string\
    \ substring, string haystack)\n{\n\tassert(haystack.size() >= substring.size());\n\
    \tint i = 0;\n\tint j = 0;\n\tstring result = \"\";\n\tstring temp = \"\";\n\t\
    while(i < haystack.size() && j < substring.size()) {\n\t\tif(haystack[i] == substring[j])\
    \ {\n\t\t\tresult += haystack[i];\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse if(i\
    \ == haystack.size()) {\n\t\t\tresult += haystack[i];\n\t\t\ti++;\n\t\t\tj++;\n\
    \t\t}\n\t\telse {\n\t\t\tj++;\n\t\t\tresult = haystack[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv11m27is.d(19): Error: no property `size` for type `string`

    /tmp/tmpv11m27is.d(19): Error: no property `size` for type `string`

    /tmp/tmpv11m27is.d(30): Error: no property `size` for type `string`

    /tmp/tmpv11m27is.d(32): Error: no property `size` for type `string`

    /tmp/tmpv11m27is.d(55): Error: no property `size` for type `string`

    /tmp/tmpv11m27is.d(55): Error: no property `size` for type `string`

    /tmp/tmpv11m27is.d(60): Error: no property `size` for type `string`

    /tmp/tmpv11m27is.d(60): Error: no property `size` for type `string`

    /tmp/tmpv11m27is.d(62): Error: slice `result` is not mutable

    /tmp/tmpv11m27is.d(66): Error: no property `size` for type `string`

    /tmp/tmpv11m27is.d(67): Error: slice `result` is not mutable

    /tmp/tmpv11m27is.d(73): Error: cannot implicitly convert expression `haystack[cast(ulong)i]`
    of type `immutable(char)` to `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv11m27is.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int start = string.find(substring);\n\
    \    if(start != string.length()-1) {\n        return 1 + how_many_times(string.substr(start+1),\
    \ substring);\n    }\n    return 0;\n}\n</code>\n<|/ a tags=string,c++ |>\n<|\
    \ c |>\nI don't want to import any libraries, just standard c++.\n<|/ c |>\n<|\
    \ c |>\nAh, I didn't even realize you were not allowed to import a library (as\
    \ evidenced by your question).\n<|/ c |>\n<| c |>\nThis code has some problems\
    \ though: what happens if `string` is an empty string and a substring to be found\
    \ in that string? The solution will not consider that. I suggest adding `if (string\
    \ != \"\" && substring != \"\")` to the start of the `how_many_times` function\
    \ and it should solve the problem.\n<|/ c |>\n<| a tags=string,c++ |>\nHere's\
    \ a solution using strstr(). The downside of strstr() is that the search string\
    \ must be present in the entire string, which is not always true.\n<code>\n#include\
    \ <iostream>\n#include <cstring>\nusing namespace std;\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_fbzvp_e.d(21): Error: declaration expected, not `<`

    /tmp/tmp_fbzvp_e.d(24): Error: unterminated character constant

    /tmp/tmp_fbzvp_e.d(27): Error: unterminated character constant

    /tmp/tmp_fbzvp_e.d(33): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_fbzvp_e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int count = 0;\n  \
    \  for (int i = 0; i < string.length(); i++) {\n        for (int j = i; j < string.length();\
    \ j++) {\n            if (string.substring(i, j).equals(substring)) {\n      \
    \          count++;\n                break;\n            }\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=c++,string |>\n<| c |>\nThat seems\
    \ a bit too much effort just to get the number of occurrences of a substring.\n\
    <|/ c |>\n<| c |>\nIt works, I wouldn't want to do that in production code, I\
    \ used it here for illustrative purposes only.\n<|/ c |>\n<| c |>\nHmm... that\
    \ `break` is going to break the inner loop. That's not going to get you the right\
    \ answer. Maybe I misunderstood the question?\n<|/ c |>\n<| c |>\nyeah, it breaks\
    \ out of that inner loop, but that's not what he wants. He wants the number of\
    \ *unique* occurrences of the substring within the string, which can be done by\
    \ removing the inner `break` statement.\n<|/ c |>\n<| c |>\nOk, I see what you\
    \ mean, but `break` will break the inner loop anyway. My mistake.\n<|/ c |>\n\
    <| a dscore=1 tags=c++,string |>\nHere's a quick and dirty way that I think is\
    \ faster than the other suggestions. I haven't tested it though:\n<code>\n#include\
    \ <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing\
    \ namespace std;\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp97hrmgjq.d(26): Error: declaration expected, not `<`

    /tmp/tmp97hrmgjq.d(32): Error: unterminated character constant

    /tmp/tmp97hrmgjq.d(35): Error: unterminated character constant

    /tmp/tmp97hrmgjq.d(38): Error: unterminated character constant

    /tmp/tmp97hrmgjq.d(44): Error: unterminated character constant

    /tmp/tmp97hrmgjq.d(44): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp97hrmgjq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   if(string.find(substring) == string.length())\n        return count;\n   \
    \ \n    int start = 0;\n    int end = string.length();\n    int index = string.find(substring);\n\
    \    while(index != -1)\n    {\n        \n        if(string.find(substring, index)\
    \ == index)\n        {\n            if(start < index)\n                start =\
    \ index;\n            if(end < index)\n                end = index;\n        }\n\
    \        index = string.find(substring, index+1);\n        count++;\n    }\n \
    \   \n    return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjand2i59.d(16): Error: no property `find` for type `string`

    /tmp/tmpjand2i59.d(16): Error: no property `length` for type `string`

    /tmp/tmpjand2i59.d(20): Error: no property `length` for type `string`

    /tmp/tmpjand2i59.d(21): Error: no property `find` for type `string`

    /tmp/tmpjand2i59.d(25): Error: no property `find` for type `string`

    /tmp/tmpjand2i59.d(32): Error: no property `find` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjand2i59.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n   long count = 0;\n  \
    \ for(int i = 0; i < string.length() - substring.length(); i++) {\n      for(int\
    \ j = 0; j < substring.length(); j++) {\n         if(string.substr(i, substring.length())\
    \ == substring)\n            count++;\n         else\n            break;\n   \
    \   }\n   }\n   return count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3qe9sz7u.d(16): Error: no property `length` for type `string`

    /tmp/tmp3qe9sz7u.d(16): Error: no property `length` for type `string`

    /tmp/tmp3qe9sz7u.d(17): Error: no property `length` for type `string`

    /tmp/tmp3qe9sz7u.d(18): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3qe9sz7u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int n = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        for(int j = 0; j < substring.length();\
    \ j++) {\n            if(i == string.length() - 1) {\n                n = n +\
    \ string.find_first_not_of(substring[j], 0, j);\n            } else {\n      \
    \          n = n + string.find_first_not_of(substring[j], i, string.length());\n\
    \            }\n        }\n    }\n    return n;\n}\n</code>\n<|/ a tags=string,substring\
    \ dscore=1 |>\n<| a |>\nThis is a C++ answer that uses the standard library (std::search,\
    \ std::find_first_of, std::find_first_not_of, and std::count_if - and some algorithms\
    \ from <algorithm> that you may not have seen yet):\n<code>\nunittest\n{\n   \
    \ alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp07byxuy9.d(27): Error: declaration expected, not `<`

    /tmp/tmp07byxuy9.d(36): Error: declaration expected, not `assert`

    /tmp/tmp07byxuy9.d(37): Error: declaration expected, not `assert`

    /tmp/tmp07byxuy9.d(38): Error: declaration expected, not `assert`

    /tmp/tmp07byxuy9.d(39): Error: declaration expected, not `assert`

    /tmp/tmp07byxuy9.d(40): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp07byxuy9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    // Count overlaping\
    \ cases.\n    long count = 0;\n    \n    // Find the first occurrence of the substring.\n\
    \    int pos = string.find(substring);\n    while (pos != string::npos) \n   \
    \ {\n        count++;\n        // Find the next occurrence of the substring.\n\
    \        pos = string.find(substring, pos + substring.length());\n    }\n    return\
    \ count;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzj8dz_lk.d(20): Error: found `:` when expecting `)`

    /tmp/tmpzj8dz_lk.d(20): Error: found `:` instead of statement

    /tmp/tmpzj8dz_lk.d(26): Error: declaration expected, not `return`

    /tmp/tmpzj8dz_lk.d(27): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzj8dz_lk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    map<long, string> m;\n\
    \    for(long i = 0; i < string.length(); i++)\n    {\n        m[count(substring,\
    \ string[i])] = string[i];\n    }\n    return m[substring.size()];\n}\n</code>\n\
    <|/ a tags=string,c++,algorithm dscore=0 |>\n<| c |>\nHmm.. i don't think that\
    \ is a valid solution for `\"aaaaa\"` and `\"a\"`. Your algorithm would give `1`\
    \ for `\"aaa\"`\n<|/ c |>\n<| c |>\nOops, yeah you're right. Fixed the algorithm.\n\
    <|/ c |>\n<| c |>\nThis solution only works if the string is a prefix of the search\
    \ string.  If the string is a suffix the results won't be as expected.\n<|/ c\
    \ |>\n<| c |>\nIt's a good solution but doesn't take in to account the fact that\
    \ you can have multiple times the same character in a string. E.g. `how_many_times(\"\
    aaaabbb\", \"a\")` would return `3` and not `2`.\n<|/ c |>\n<| c |>\n, good point.\
    \ I have edited the answer to take account of multiple instances of the substring\
    \ as well. Thanks.\n<|/ c |>\n<| a |>\nIf you want a c++ solution here's mine:\n\
    <code>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n\
    using namespace std;\nunittest\n{\n    alias candidate = how_many_times;\n\n \
    \   assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"\
    x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphxw_q5zk.d(15): Error: found `,` when expecting `.` following long

    /tmp/tmphxw_q5zk.d(15): Error: found `>` when expecting `;` following statement

    /tmp/tmphxw_q5zk.d(22): Error: declaration expected, not `<`

    /tmp/tmphxw_q5zk.d(25): Error: unterminated character constant

    /tmp/tmphxw_q5zk.d(28): Error: unterminated character constant

    /tmp/tmphxw_q5zk.d(31): Error: unterminated character constant

    /tmp/tmphxw_q5zk.d(34): Error: unterminated character constant

    /tmp/tmphxw_q5zk.d(34): Error: unterminated character constant

    /tmp/tmphxw_q5zk.d(40): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphxw_q5zk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for(int i = 0; i < string.size(); ++i)\n    {\n        if(string.at(i) ==\
    \ substring[0])\n        {\n            for(int j = i; j < string.size(); ++j)\n\
    \            {\n                if(string.at(j) == substring.at(0))\n        \
    \        {\n                    if(string.at(j + 1) != substring.at(1))\n    \
    \                    break;\n                    else\n                      \
    \  ++count;\n                }\n                else\n                    break;\n\
    \            }\n            \n        }\n    }\n    \n    return count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuc6dllqm.d(16): Error: no property `size` for type `string`

    /tmp/tmpuc6dllqm.d(18): Error: no property `at` for type `string`

    /tmp/tmpuc6dllqm.d(20): Error: no property `size` for type `string`

    /tmp/tmpuc6dllqm.d(22): Error: no property `at` for type `string`

    /tmp/tmpuc6dllqm.d(22): Error: no property `at` for type `string`

    /tmp/tmpuc6dllqm.d(24): Error: no property `at` for type `string`

    /tmp/tmpuc6dllqm.d(24): Error: no property `at` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuc6dllqm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong result = 0;\n\t\
    size_t pos;\n\tfor(pos=string.find(substring);pos!=string::npos;pos=string.find(substring))\n\
    \t{\n\t\tif(string[pos]!=substring[0]) \n\t\t{\n\t\t\tif((pos+1)==string.size())\
    \ \n\t\t\t\tresult += 1;\n\t\t\telse \n\t\t\t\tresult += how_many_times(string.substr(pos+1),substring);\n\
    \t\t}\n\t}\n\treturn result;\n}\n/*\n Get how many times a given substring can\
    \ be found in the original string. Count overlaping cases.\n    >>> how_many_times_case_insensitive(\"\
    \", \"A\")\n    0L\n    >>> how_many_times_case_insensitive(\"aaa\", \"A\")\n\
    \    3L\n    >>> how_many_times_case_insensitive(\"aaaa\", \"A\")\n    3L\n  \
    \  \n*/\nlong how_many_times_case_insensitive(string string, string substring)\
    \ \n{\n\tlong result = 0;\n\tsize_t pos;\n\tfor(pos=string.find(substring);pos!=string::npos;pos=string.find(substring))\n\
    \t{\n\t\tif(string[pos]==substring[0]) \n\t\t{\n\t\t\tif((pos+1)==string.size())\
    \ \n\t\t\t\tresult += 1;\n\t\t\telse \n\t\t\t\tresult += how_many_times_case_insensitive(string.substr(pos+1),substring);\n\
    \t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2_mdlz60.d(17): Error: found `:` when expecting `;` following `for`
    condition

    /tmp/tmp2_mdlz60.d(17): Error: expression expected, not `:`

    /tmp/tmp2_mdlz60.d(17): Error: found `npos` when expecting `)`

    /tmp/tmp2_mdlz60.d(17): Error: use `{ }` for an empty statement, not `;`

    /tmp/tmp2_mdlz60.d(17): Error: found `)` when expecting `;` following statement

    /tmp/tmp2_mdlz60.d(43): Error: found `:` when expecting `;` following `for` condition

    /tmp/tmp2_mdlz60.d(43): Error: expression expected, not `:`

    /tmp/tmp2_mdlz60.d(43): Error: found `npos` when expecting `)`

    /tmp/tmp2_mdlz60.d(43): Error: use `{ }` for an empty statement, not `;`

    /tmp/tmp2_mdlz60.d(43): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2_mdlz60.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong start = 0;\n\tlong\
    \ end = 0;\n\tlong overlaps = 0;\n\tlong n = 0;\n\tlong substring_index = 0;\n\
    \t\n\twhile(end < string.size())\n\t{\n\t\tsubstring_index = string.find(substring,\
    \ end);\n\t\tif(substring_index == string::npos)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\
    \t\t\n\t\tstart = end - substring_index;\n\t\tend = start + 1;\n\t\t\n\t\toverlaps\
    \ += (end - start);\n\t\t\n\t\t++n;\n\t}\n\t\n\treturn overlaps;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu7c19gmo.d(24): Error: found `:` when expecting `)`

    /tmp/tmpu7c19gmo.d(24): Error: found `:` instead of statement

    /tmp/tmpu7c19gmo.d(37): Error: declaration expected, not `return`

    /tmp/tmpu7c19gmo.d(38): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu7c19gmo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for (int i=0; i < string.length(); i++) \n    {\n        if ( string.find(substring,\
    \ i, string.length()) == string.length() ) \n        {\n            count++;\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=string,search,algorithm,c++\
    \ |>\n<| c |>\nThis answer is very similar to the one by user348711.\n<|/ c |>\n\
    <| c |>\nActually, this one avoids creating intermediate strings, which is good\
    \ if memory is a concern.\n<|/ c |>\n<| a tags=string,search,algorithm,c++ |>\n\
    Here is an example in Javascript of a function that returns a count of characters\
    \ in a string that match a pattern. Using regular expressions makes it easy to\
    \ find patterns in strings and it takes care of overlaps.\nThe pattern can be\
    \ a substring of a string you are searching. It works by using a RegExp object\
    \ to find each of the patterns in the given string. Each pattern is matched to\
    \ a different capture group. Once all patterns are found the function checks to\
    \ see if the first capture group has anything in it. If so, it returns true. If\
    \ not, it returns false.\nThe pattern is written so that it uses two capture groups.\
    \ One group is for the entire pattern, and the other group is for the characters\
    \ that match the pattern.\n<code>\nfunction checkPattern(pattern, string){\n \
    \   if(!pattern)\n        return false;\n    pattern = new RegExp(pattern);\n\
    \    let totalMatches = 0;\n    let totalChars = 0;\n    let captureGroupMatches\
    \ = true;\n    while(captureGroupMatches){\n        captureGroupMatches = false;\n\
    \        let matchArray = string.match(pattern);\n        if(matchArray){\n  \
    \          for(let i = 0; i < matchArray.length; i++){\n                let match\
    \ = matchArray[i];\n                if(i === 0){\n                    totalChars\
    \ += matchArray[i].length;\n                    totalMatches += 1;\n         \
    \       }\n                else{\n                    let char = match.slice(-1);\n\
    \                    totalChars += char.length;\n                    if(char ===\
    \ matchArray[i-1].slice(-1)){\n                        totalMatches += 1;\n  \
    \                  }\n                }\n            }\n        }\n    }\n   \
    \ return totalMatches === totalChars;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    What if pattern = \"^.*a\" where you want to get count of number of times \"a\"\
    \ appears in string \"aab\"?\n<|/ c |>\n<| c |>\nThis is pretty much what I was\
    \ trying to do with my code above. `pattern` is `^.*a` and I was checking that\
    \ the count of chars was the same as the number of matches.\n<|/ c |>\n<| c |>\n\
    I think this could be \nunittest\n{\n    alias candidate = how_many_times;\n\n\
    \    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\",\
    \ \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int i, j;\n    \n \
    \   int l = min(string.size(), substring.length());\n    for (i = 0; i < l; ++i)\n\
    \    {\n        if (string[i] == substring[i])\n        {\n            continue;\n\
    \        }\n        for (j = i + 1; j < l; ++j)\n        {\n            if (string[j]\
    \ == substring[j])\n            {\n                return j - i;\n           \
    \ }\n        }\n    }\n    return 0L;\n}\nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptuimpvm5.d(17): Error: undefined identifier `min`, did you mean
    function `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptuimpvm5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n  long count = 0;\n  long\
    \ length_string = string.length;\n  long length_substring = substring.length;\n\
    \  if (length_substring == 0) {\n    return count;\n  }\nunittest\n{\n    alias\
    \ candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n \
    \   assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwifi7358.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwifi7358.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    auto count = string.length();\n\
    \    for(long i = 0; i < string.length(); i++)\n    {\n        size_t j = 0;\n\
    \        while(string[j] == substring[j])\n        {\n            j++;\n     \
    \   }\n        bool overlap = j > 1 && string[i...j] == substring[1...j];\n  \
    \      if(overlap)\n        {\n            count += (i - j);\n        }\n    }\n\
    \    return count;\n}\n</code>\n<|/ a tags=string,java dscore=2 |>\n<| a tags=string,java\
    \ |>\nJava 8 solution:\n<code>\nlong how_many_times(String string, String substring)\
    \ {\n    return string.chars()\n                 .filter(c -> c == substring.charAt(0))\n\
    \                 .count() + string.chars()\n                                \
    \ .filter(c -> c == substring.charAt(substring.length() - 1))\n              \
    \                   .count();\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\n\
    public static void main(String[] args)\n{\n        String string = \"abcde\";\n\
    \        String subString = \"bc\";\n        int count = 0;\nunittest\n{\n   \
    \ alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n\
    \    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\"\
    , \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") == 1L);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj6pk8a4v.d(23): Error: found `...` when expecting `,`

    /tmp/tmpj6pk8a4v.d(23): Error: found `...` when expecting `,`

    /tmp/tmpj6pk8a4v.d(31): Error: declaration expected, not `<`

    /tmp/tmpj6pk8a4v.d(42): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj6pk8a4v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   for (char c : string) \n    {\n        if (c == substring[0]) \n        {\n\
    \            count += how_many_times(string.substring(1));\n        }\n      \
    \  if (c == substring[1]) \n        {\n            count += how_many_times(string.substring(1));\n\
    \        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=python\
    \ |>\n<code>\ndef countChar(string, char):\n    counter = 0\n    for i in range(len(string)):\n\
    \        if string[i] == char:\n            counter += 1\n    return counter\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nThis will work but will take longer if you\
    \ have to do this several times (once for each character). Also it will not work\
    \ if you want to know how many times any two characters occur in the string. This\
    \ is because you are only counting when `string[i]==char` but you need to count\
    \ it for two characters.\n<|/ c |>\n<| a tags=python |>\n<code>\n>>> from collections\
    \ import Counter\n>>> s = \"aaaaaa\"\n>>> c = Counter()\n>>> for i,c in enumerate(s):\n\
    ...     c[c]+=1\n...     if i > 0 and c == s[i-1]:\n...         c[c]+=1\n... \n\
    >>> c\nCounter({'a': 3, 'b': 2, 'c': 1})\n</code>\n<|/ a dscore=3 |>\n<| a |>\n\
    I believe this solution is O(n) complexity (it uses recursion):\n<code>\ndef count(string,\
    \ char):\n    res = 0\n    for i in range(len(string)):\n        if string[i]\
    \ == char:\n            res += count(string[:i], char) + count(string[i+1:], char)\n\
    \    return res\n</code>\n<|/ a dscore=3 tags=python |>\n<| c |>\nThis solution\
    \ is O(n^2) (it uses two recursions)\n<|/ c |>\n<| a dscore=2 |>\nHere's a short\
    \ and simple solution for python 2.6+ using generator expression:\n<code>\ndef\
    \ count_char(text, c):\n    return (c for c in text if c == c)\n</code>\n<|/ a\
    \ tags=python |>\n<| a tags=python dscore=2 |>\n<code>\ndef count_char(string,\
    \ char):\n  count = 0\n  for i in range(len(string)):\n    if string[i] == char:\n\
    \      count += 1\n  return count\n</code>\n<|/ a |>\n<| a dscore=2 tags=python\
    \ |>\n<code>\ndef count_char(string, char):\n    count = 0\n    for i in range(len(string)):\n\
    \        if string[i] == char:\n            count += 1\n    return count\n</code>\n\
    <|/ a |>\n<| c |>\nWhile this code may \nunittest\n{\n    alias candidate = how_many_times;\n\
    \n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\"\
    , \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"\
    john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_hkkdwy5.d(16): Error: semicolon expected, not `:`

    /tmp/tmp_hkkdwy5.d(16): Error: expression expected, not `:`

    /tmp/tmp_hkkdwy5.d(16): Error: found `string` when expecting `;` following `for`
    condition

    /tmp/tmp_hkkdwy5.d(29): Error: declaration expected, not `<`

    /tmp/tmp_hkkdwy5.d(73): Error: unterminated character constant

    /tmp/tmp_hkkdwy5.d(105): Error: declaration expected, not `assert`

    /tmp/tmp_hkkdwy5.d(106): Error: declaration expected, not `assert`

    /tmp/tmp_hkkdwy5.d(107): Error: declaration expected, not `assert`

    /tmp/tmp_hkkdwy5.d(108): Error: declaration expected, not `assert`

    /tmp/tmp_hkkdwy5.d(109): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hkkdwy5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tsize_t length = (size_t)\
    \ string.length();\n\tsize_t foundLength = 0;\n\tsize_t count = 0;\n\t\n\tif (substring\
    \ == string)\n\t\treturn 0;\n\t\n\tfor (size_t i = 0; i <= length; i++)\n\t{\n\
    \t\tif (string.find(substring, i) != string::npos) \n\t\t{\n\t\t\tfoundLength++;\n\
    \t\t\tcount += length - (i - foundLength);\n\t\t}\n\t}\n\treturn count;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1trncfb9.d(15): Error: C style cast illegal, use `cast(size_t)string.length()`

    /tmp/tmp1trncfb9.d(24): Error: found `:` when expecting `)`

    /tmp/tmp1trncfb9.d(24): Error: found `:` instead of statement

    /tmp/tmp1trncfb9.d(30): Error: declaration expected, not `return`

    /tmp/tmp1trncfb9.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1trncfb9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n\tlong count = 0;\n\tint\
    \ i = 0;\n\tfor (;; string[i] = 0)\n\t{\n\t\ti++;\n\t\tif (string[i] == 0 || string[i]\
    \ == substring[0])\n\t\t\tbreak;\n\t\tif (string[i] == substring[0] && string[i+1]\
    \ == substring[1])\n\t\t\tcount++;\n\t\tif (string[i] == substring[0])\n\t\t\t\
    break;\n\t}\n\treturn count;\n}\n/*\n Find how many times a given substring can\
    \ be found in the original string. Count overlapping cases.\n    >>> how_many_times(\"\
    aaa\", \"bb\")\n    3L\n*/\nlong how_many_times(string string, string substring,\
    \ int offset) \n{\n\tlong count = 0;\n\tint i = 0;\n\tfor (;; string[i] = 0)\n\
    \t{\n\t\ti++;\n\t\tif (string[i] == 0)\n\t\t\tbreak;\n\t\tif (string[i] == substring[offset])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset] && string[i+1] == substring[offset+1])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset])\n\t\t\tbreak;\n\t}\n\t\
    return count;\n}\n/*\n Find how many times a given substring can be found in the\
    \ original string. Count overlapping cases. Add offset to result.\n    >>> how_many_times(\"\
    aaa\", \"bb\", 3)\n    3L\n*/\nlong how_many_times(string string, string substring,\
    \ int offset) \n{\n\tlong count = 0;\n\tint i = 0;\n\tfor (;; string[i] = 0)\n\
    \t{\n\t\ti++;\n\t\tif (string[i] == 0)\n\t\t\tbreak;\n\t\tif (string[i] == substring[offset])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset] && string[i+1] == substring[offset+1])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset])\n\t\t\tbreak;\n\t}\n\t\
    return count + offset;\n}\n/*\n Count how many times a given substring can be\
    \ found in the original string. Add offset to result.\n    >>> how_many_times(\"\
    aba\", \"ca\")\n    3L\n*/\nlong how_many_times(string string, string substring,\
    \ int offset) \n{\n\tlong count = 0;\n\tint i = 0;\n\tfor (;; string[i] = 0)\n\
    \t{\n\t\ti++;\n\t\tif (string[i] == 0)\n\t\t\tbreak;\n\t\tif (string[i] == substring[offset])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset] && string[i+1] == substring[offset+1])\n\
    \t\t\tcount++;\n\t\tif (string[i] == substring[offset])\n\t\t\tbreak;\n\t}\n\t\
    return count + offset;\n}\n/*\n Find how many times a given substring can be found\
    \ in the original string. Add offset to result.\n    >>> how_many_times(\"aba\"\
    , \"ca\", \nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_4_fyjkp.d(98): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_4_fyjkp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    int len = string.length();\n\
    \    for(int i = 0; i < len; ++i)\n    {\n        if(string.charAt(i) == substring.charAt(0))\n\
    \        {\n            int start = i + 1;\n            while(string.charAt(start)\
    \ == substring.charAt(0))\n                ++start;\n            long num = 1;\n\
    \            for(int j = start; j < len; ++j)\n            {\n               \
    \ if(string.charAt(j) == substring.charAt(1))\n                    ++num;\n  \
    \          }\n            return num;\n        }\n    }\n    return 0L;\n}\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppmc2owb5.d(15): Error: no property `length` for type `string`

    /tmp/tmppmc2owb5.d(18): Error: no property `charAt` for type `string`

    /tmp/tmppmc2owb5.d(18): Error: no property `charAt` for type `string`

    /tmp/tmppmc2owb5.d(21): Error: no property `charAt` for type `string`

    /tmp/tmppmc2owb5.d(21): Error: no property `charAt` for type `string`

    /tmp/tmppmc2owb5.d(26): Error: no property `charAt` for type `string`

    /tmp/tmppmc2owb5.d(26): Error: no property `charAt` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppmc2owb5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0; \n\
    \    long position = 0; \n    \n    while(position != string.Length) \n    {\n\
    \        position = string.IndexOf(substring, position, position+1); \n      \
    \  \n        if(position != -1) \n        { \n            count++; \n        \
    \    position = string.IndexOf(substring, position+1, position+2); \n        }\
    \ \n        else\n        {\n            break;\n        }\n    }\n    return\
    \ count; \n}\nunittest\n{\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\
    \", \"x\") == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9uzh6jj3.d(18): Error: no property `Length` for type `string`

    /tmp/tmp9uzh6jj3.d(20): Error: no property `IndexOf` for type `string`

    /tmp/tmp9uzh6jj3.d(25): Error: no property `IndexOf` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9uzh6jj3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   string current = string;\n    while (current.length() > substring.length())\
    \ {\n        current = current.substr(0, current.length()-1);\n        if (current.length()\
    \ != substring.length()) { count++; };\n    }\n    current = string;\n    while\
    \ (current.length() < substring.length()) {\n        current = current + substring;\n\
    \        count++;\n    }\n    return count;\n}\n/*\n Find the longest common substring\
    \ in a string\n    \n This function uses dynamic programming to calculate the\
    \ longest common substring of a string.\n    \n It was a challenge that I had\
    \ to solve and I thought it would be interesting to see how long it takes to calculate.\n\
    \    \n It took about 50 seconds to calculate the longest common substring of\
    \ a string with 1000 characters.\n    \n It is also interesting to see how long\
    \ it takes to calculate the longest common substring of a string with millions\
    \ of characters.\n    \n The code was quite straightforward, so I didn't optimize\
    \ it. You can optimize it by writing a custom version of find_lcs. You would have\
    \ to write it in a very simple language that doesn't have any looping or recursion.\
    \ One could even use a simple language like Fortran. \n    \n I wrote the function\
    \ so that it would be easy to follow along with an explanation of how it works.\
    \ To read it, think of it as a function with two arguments: a string, and a substring.\
    \ The function returns the number of times that the substring can be found in\
    \ the string. There is also a third argument, a minimum length that is allowed\
    \ between the two strings. So if you want it to return 3 for \"aaa\" and \"aa\"\
    , you would set the minimum length to 2.\n    \n I wrote the function so that\
    \ it would return the longest common substring in a string and the minimum length\
    \ of the substring between the two strings. It would return (0,0,0) if the minimum\
    \ length argument is greater than the length of the strings. The function returns\
    \ a tuple of the two values (the longest common substring and the minimum length\
    \ of the substring). \n    \n For example, how_many_times(\"aaa\", \"a\") would\
    \ return (2L, 0L, 0L) and how_many_times(\"aaaa\", \"aa\") would return (3L, 3L,\
    \ 0L).\n    \n A final note: the code is not very efficient or elegant. There\
    \ might be better ways to do this, but it should be very easy to read and understand.\n\
    */\n(string, string, long, long) -> long\nhow_many_times(string string, string\
    \ substring, long min_length)\n{\n    if (string.length() < min_length) { return\
    \ (0, 0, 0L); };\n    int max_l = min(string.length(), substring.length());\n\
    \    string substring2 = substring.substr(0, max_l);\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7rktkd0h.d(19): Deprecation: use `{ }` for an empty statement,
    not `;`

    /tmp/tmp7rktkd0h.d(49): Error: declaration expected, not `(`

    /tmp/tmp7rktkd0h.d(52): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7rktkd0h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    long count = 0;\n \
    \   int size = string.size();\n    int offset = substring.size();\nunittest\n\
    {\n    alias candidate = how_many_times;\n\n    assert(candidate(\"\", \"x\")\
    \ == 0L);\n    assert(candidate(\"xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"\
    cacacacac\", \"cac\") == 4L);\n    assert(candidate(\"john doe\", \"john\") ==\
    \ 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphex60e5h.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphex60e5h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Find how many times a given\
    \ substring can be found in the original string. Count overlaping cases.\n   \
    \ >>> how_many_times(\"\", \"a\")\n    0L\n    >>> how_many_times(\"aaa\", \"\
    a\")\n    3L\n    >>> how_many_times(\"aaaa\", \"aa\")\n    3L\n    \n*/\nlong\
    \ how_many_times(string string, string substring) \n{\n    string result;\n  \
    \  long count = 1;\n    long lastindex = 0;\nunittest\n{\n    alias candidate\
    \ = how_many_times;\n\n    assert(candidate(\"\", \"x\") == 0L);\n    assert(candidate(\"\
    xyxyxyx\", \"x\") == 4L);\n    assert(candidate(\"cacacacac\", \"cac\") == 4L);\n\
    \    assert(candidate(\"john doe\", \"john\") == 1L);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdyl5va2q.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdyl5va2q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164235
