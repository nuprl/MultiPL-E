name: HumanEval_57_monotonic
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn true is array elements\
  \ are monotonically increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n\
  \    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
  \ 1L, 0L, -10L])\n    true\n    \n*/\nbool monotonic(long[] l) \n"
tests: "unittest\n{\n    alias candidate = monotonic;\n\n    assert(candidate([1L,\
  \ 2L, 4L, 10L]) == true);\n    assert(candidate([1L, 2L, 4L, 20L]) == true);\n \
  \   assert(candidate([1L, 20L, 4L, 10L]) == false);\n    assert(candidate([4L, 1L,\
  \ 0L, -10L]) == true);\n    assert(candidate([4L, 1L, 1L, 0L]) == true);\n    assert(candidate([1L,\
  \ 2L, 3L, 2L, 5L, 60L]) == false);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 60L])\
  \ == true);\n    assert(candidate([9L, 9L, 9L, 9L]) == true);\n}\nvoid main(){}"
completions: ["{\n\tlong i;\n\tint j;\n\tfor (j=1; j < l.length; ++j)\n\t{\n\t\tif\
    \ (!(std.maxi(l[j-1], l[j]) <= std.mini(l[j-1], l[j])))\n\t\t{\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\t\n\tfor (j=1; j < l.length; ++j)\n\t{\n\t\tfor (i=j-1; i>=0; --i)\n\
    \t\t{\n\t\t\tif (std.mini(l[j], l[i]) <= std.maxi(l[j-1], l[i]))\n\t\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\t\n\treturn true;\n}", "{\n\tlong l = l[0];\n\tbool is_increasing\
    \ = true;\n\tbool is_decreasing = true;\n\tbool is_monotonic_increasing = true;\n\
    \tbool is_monotonic_decreasing = true;\n\tbool is_strictly_decreasing = true;\n\
    \tbool is_strictly_increasing = true;\n\tfor(int i=1; i<l.length; i++)\n\t{\n\t\
    \tlong v = l[i];\n\t\tif(v > l)\n\t\t{\n\t\t\tis_decreasing = false;\n\t\t}\n\t\
    \telse if(v < l)\n\t\t{\n\t\t\tis_increasing = false;\n\t\t}\n\t\telse if(v ==\
    \ l)\n\t\t{\n\t\t\tis_monotonic_increasing = false;\n\t\t\tis_strictly_decreasing\
    \ = false;\n\t\t\tis_strictly_increasing = false;\n\t\t}\n\t\telse if(v == l-1)\n\
    \t\t{\n\t\t\tis_monotonic_decreasing = false;\n\t\t\tis_strictly_increasing =\
    \ false;\n\t\t\tis_strictly_decreasing = false;\n\t\t}\n\t\telse if(v == l-2)\n\
    \t\t{\n\t\t\tis_monotonic_increasing = false;\n\t\t\tis_strictly_increasing =\
    \ false;\n\t\t\tis_strictly_decreasing = false;\n\t\t}\n\t}\n\tbool result = is_increasing;\n\
    \tresult |= is_decreasing;\n\tresult |= is_monotonic_increasing;\n\tresult |=\
    \ is_monotonic_decreasing;\n\tresult |= is_strictly_decreasing;\n\tresult |= is_strictly_increasing;\n\
    \treturn result;\n}\n/*\nReturn true is array elements are strictly decreasing\
    \ or increasing.\n    >>> strictly_decreasing([1L, 2L, 4L, 20L])\n    true\n \
    \   >>> strictly_decreasing([1L, 4L, 3L, 20L])\n    false\n    >>> strictly_decreasing([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/", "{\n   if(l.length < 2)\n       return\
    \ true;\n   long long max = 0;\n   for(int i = 0; i < l.length-1; i++)\n   {\n\
    \       long a = l[i];\n       long b = l[i+1];\n       if(b < a)\n          \
    \ return false;\n       if(max < a)\n           max = a;\n   }\n   return true;\n\
    }", "{\n  long last = l[0];\n  long curr = l[1];\n  \n  if(curr <= last)\n   \
    \ return true;\n  \n  for(int i = 2; i < l.length; ++i) {\n    long next = l[i];\n\
    \    if(curr > next)\n      return true;\n    else if(curr < next)\n      return\
    \ false;\n    else\n      curr = next;\n  }\n  \n  return false;\n}", "{\n   \
    \ long i = 0;\n    long j = l.length - 1;\n    long min_i = l[0];\n    long min_j\
    \ = l[0];\n    while (i < j) {\n        while (i<j && l[i] < min_j) ++i;\n   \
    \     while (j>i && l[j] > min_i) --j;\n        if (i<j) {\n            min_i\
    \ = l[i];\n            min_j = l[j];\n        }\n        else {\n            min_i\
    \ = l[i];\n            min_j = l[j];\n        }\n    }\n    if (min_i < l[0])\
    \ {\n        return true;\n    }\n    return false;\n}\n'''", "{\n\tint i = 0;\n\
    \tint j = 1;\n\tint m = 1;\n\tlong max = l[0];\n\tfor (; i < l.length; i++)\n\t\
    \tif (l[i] > max)\n\t\t\tm = j;\n\t\telse if (l[i] < max)\n\t\t\tj = m;\n\t\t\
    else\n\t\t\tbreak;\n\tif (j == m)\n\t\treturn false;\n\telse\n\t\treturn true;\n\
    }", "{\n    int j;\n    for (int i = 1; i < l.length; ++i)\n    {\n        long\
    \ x = l[i];\n        if (x < l[i - 1] || x > l[j])\n        {\n            j =\
    \ i;\n        }\n    }\n    return j > i;\n}", "{\n    var len = l.length;\n \
    \   if(len == 0)\n        return true;\n    if(len == 1)\n        return l[0]\
    \ > l[1];\n    if(l[0] > l[len - 1])\n        return false;", "{\n  long previous\
    \ = 0;\n  for (int i = 0; i < l.length-1; ++i) {\n    if (l[i] > l[i+1]) {\n \
    \     return false;\n    }\n    previous = l[i];\n  }\n  return true;\n}", "{\n\
    \    int i,j,k,k,l;\n    bool c;\n    for(i=1;i<l.length;++i){\n        if(l[i]<=l[i-1])\
    \ continue;\n        k=0;\n        for(j=0;j<i;++j){\n            if(l[j]<=l[k]){\n\
    \                c=true;\n                for(l=j+1;l<i;++l)\n               \
    \     if(l[j+1]>l[k])\n                        c=false;\n                break;\n\
    \            }\n            ++k;\n        }\n        if(c)return false;\n    }\n\
    \    return true;\n}", "{\n    long min = l[0];\n    bool mono = true;\n    for\
    \ (long i=1; i<l.length; ++i)\n    {\n        if (l[i] < min)\n        {\n   \
    \         mono = false;\n            break;\n        }\n        else if (l[i]\
    \ > min)\n        {\n            min = l[i];\n        }\n    }\n    return mono;\n\
    }\n/*\nGiven a range of integer values, return a list of ranges of integers\n\
    that have the same size, where the ranges overlap\n    \n    >>> split_ranges([0,\
    \ 1, 2, 3, 4])\n    [(0, 1), (2, 3, 4)]\n    >>> split_ranges([0, 4, 9, 9, 9])\n\
    \    [(0, 4), (9, 9)]\n    \n*/\nList<Tuple<long, long>> split_ranges(long[] l)\n\
    {\n    List<Tuple<long, long>> result = new List<Tuple<long, long>>();\n    bool\
    \ mono = monotonic(l);\n    long first = l[0], last = l[l.length-1];\n    if (first\
    \ == last)\n    {\n        Tuple<long, long> t = new Tuple<long, long>(first,\
    \ first);\n        result.Add(t);\n        return result;\n    }\n    for (long\
    \ i=first; i<=last; ++i)\n    {\n        if (mono)\n        {\n            Tuple<long,\
    \ long> t = new Tuple<long, long>(i, i);\n            result.Add(t);\n       \
    \ }\n        else\n        {\n            Tuple<long, long> t = new Tuple<long,\
    \ long>(last, i);\n            result.Add(t);\n        }\n    }\n    return result;\n\
    }\n/*\nGiven a range of integer values, return a list of ranges of integers\n\
    that have the same size, where the ranges overlap and are \n    \n    1) all monotonic\
    \ increasing\n    2) all monotonic decreasing\n    3) all non-monotonic increasing\n\
    \    4) all non-monotonic decreasing\n    \n    >>> split_ranges([0, 1, 2, 3])\n\
    \    [(0, 3), (2, 3), (4, 3), (5, 3)]\n    >>> split_ranges([0, 4, 9, 9])\n  \
    \  [(0, 4), (9, 9)]\n    \n    \n    >>> split_ranges([0, 1, 2, 3, 4])\n    [(0,\
    \ 1), (2, 3, 4), (4, 5)]\n    >>> split_ranges([0, 4, 9, 9, 9])\n    [(0, 4),\
    \ (9, 9)]\n    \n    \n    >>> split_ranges([0, 1, 2, 3, 4])\n    [(0, 1), (2,\
    \ 3, 4), (4, 5)]\n    >>> split_ranges([0, 4, 9, 9, 9])\n    [(0, 4), (9, 9)]\n\
    \    \n*/\nList<Tuple<long, long>> split_ranges(long[] l, bool allMonotonic)\n\
    {\n    List<Tuple<long, long>> result = new ", "{\n    if (l.length == 1) return\
    \ false;\n    long first = l[0];\n    long last = l[0];\n    for(int i = 0; i\
    \ < l.length-1; i++){\n        long cur = l[i];\n        long next = l[i+1];\n\
    \        if (cur < last){\n            last = cur;\n        }\n        else if\
    \ (cur > next){\n            first = cur;\n        }\n    }\n    return first\
    \ < l[l.length-1];\n}", "{\n  int i = 0;\n  int j = 1;\n  bool prev = true;\n\
    \  long prev2 = 0;\n  long cur = l[0];\n  long cur2 = l[i];\n  \n  while(j < l.length\
    \ && cur < l[j]) {\n    cur2 = l[j];\n    prev = cur > cur2;\n    cur = cur2;\n\
    \    i++;\n    j++;\n  }\n  if(j > 1) {\n    if(prev) {\n      if(prev2 < cur2)\
    \ {\n        return true;\n      } else {\n        prev2 = cur2;\n        prev\
    \ = cur > prev2;\n        j++;\n      }\n    } else {\n      if(cur2 < prev2)\
    \ {\n        return true;\n      } else {\n        prev2 = cur2;\n        prev\
    \ = cur > prev2;\n        i++;\n      }\n    }\n  }\n  return false;\n}", "{\n\
    \    for(int i = 1; i < l.size(); i++)\n        if(l[i-1] <= l[i])\n         \
    \   return false;\n    return true;\n}\n/*\nReturn the first non-null value in\
    \ the array.\n>>> first([null, 1, \"\", 2, \"\", 4, \"\", null])\n\"\"\n>>> first([null,\
    \ 1, \"\", 2, \"\", 4, \"\", null], null)\nnull\n>>> first([null, 1, \"\", 2,\
    \ \"\", 4, \"\", null], \"hi\")\n\"hi\"\n*/\nstring first(T[] a, T t) \n{\n  \
    \  for(T x : a) {\n        if(t != null)\n            return x;\n    }\n    return\
    \ null;\n}\n/*\nReturn the last non-null value in the array.\n>>> last([null,\
    \ 1, \"\", 2, \"\", 4, \"\", null])\nnull\n>>> last([null, 1, \"\", 2, \"\", 4,\
    \ \"\", null], null)\nnull\n>>> last([null, 1, \"\", 2, \"\", 4, \"\", null],\
    \ \"hi\")\n\"hi\"\n*/\nstring last(T[] a, T t) \n{\n    for(T x : a) {\n     \
    \   if(t != null)\n            return x;\n    }\n    return null;\n}\n/*\nReturn\
    \ the index of the first item in the array that matches the key.\n>>> indexOf([{a:1},\
    \ {a:2}, {a:3}, {a:4}, {a:5}, {a:6}, {a:7}], {a:4})\n1\n>>> indexOf([{a:1}, {a:2},\
    \ {a:3}, {a:4}, {a:5}, {a:6}, {a:7}], {a:100})\n-1\n>>> indexOf([{a:1}, {a:2},\
    \ {a:3}, {a:4}, {a:5}, {a:6}, {a:7}], {a:\"hi\"})\n-1\n>>> indexOf([{a:1}, {a:2},\
    \ {a:3}, {a:4}, {a:5}, {a:6}, {a:7}], 100)\n-1\n>>> indexOf([{a:1}, {a:2}, {a:3},\
    \ {a:4}, {a:5}, {a:6}, {a:7}], \"hi\")\n-1\n>>> indexOf([{a:1}, {a:2}, {a:3},\
    \ {a:4}, {a:5}, {a:6}, {a:7}], \"ho\")\n-1\n*/", "{\n    if (l.length < 1)\n \
    \       return true;", "{\n    if(l.length==1) return true; // Nothing to do\n\
    \    int n = l.length;\n    int m = (n>1)?(n-1):1;\n    for(int i=0; i<n; i=i+m)\n\
    \        if(l[i]>=l[i+1]) return true;\n    return false;\n}", "{\n    for (long\
    \ i = 0; i < l.length - 1; i++)\n    {\n        if (l[i] < l[i + 1])\n       \
    \     return false;\n    }\n    return true;\n}", "{\n    for (int i = 0; i <\
    \ l.length-1; i++)\n    {\n        if (l[i+1] < l[i])\n        {\n           \
    \ return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nIt won't work for `monotonic([0, 0])`. Also, you can save a lot of time\
    \ by comparing `l[i+1] > l[i]` instead of `l[i+1] < l[i]`.\n<|/ c |>\n<| c |>\n\
    This is not true, please check [this answer](https://stackoverflow.com/a/47017351/3221007).\n\
    <|/ c |>\n<| a tags=c++,arrays |>\nHere is another solution which I believe is\
    \ faster than the other answers:\n<code>", "{\n    int n = l.Length;\n    for\
    \ (int i = 0; i < n; i++)\n    {\n        if (l[i] > l[i - 1]) \n        {\n \
    \           return false;\n        }\n    }\n    return true;\n}\n// ---------------------------------------------------------------------------",
  "{\n  long i;\n  long len = l.length;\n  bool res = true;\n  if (len == 0)\n   \
    \ return false;\n  if (len == 1)\n    return true;\n  for (i = 1; i < len; i++)\n\
    \    if (l[i-1] >= l[i])\n      res = false;\n  return res;\n}", "{\n    return\
    \ monotonic(l, l.length-1);\n}", "{\n    var i=0;\n    var i1=l.length-1;\n  \
    \  var m1=1;\n    var m2=0;\n    var j1=i;\n    var j2=i;\n    var j=0;\n    for(;j1<=i1;j1++)\n\
    \    {\n        if (l[j1]>l[j])\n        {\n            return false;\n      \
    \  }\n        else\n        {\n            m1=1;\n        }\n        j++;\n  \
    \  }\n    for(;j2<=i1;j2++)\n    {\n        if (l[j2]<l[j])\n        {\n     \
    \       return false;\n        }\n        else\n        {\n            m2=1;\n\
    \        }\n        j++;\n    }\n    return m2>m1;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nNice, this one was the best solution for me.\n<|/ c |>\n<| c |>\n\
    Ouch. Thanks. Fixed now.\n<|/ c |>\n<| a |>\nIt can be done in O(n).\nSort the\
    \ array and then compare adjacent elements with each other. If current elements\
    \ are greater than previous one, then they have to be in descending order, if\
    \ they are less than previous one, then they have to be in ascending order (i.e.\
    \ the array is in increasing order).\nThis algorithm is similar to selection algorithm,\
    \ but the logic is applied on the array instead of on the subarray(s) and is independent\
    \ of the size of subarray.\n<|/ a tags=arrays,algorithm,sorting dscore=1 |>\n\
    <| c |>\nI didn't know that selection algorithms were O(n) time complexity. Learn\
    \ something new every day.\n<|/ c |>\n<| c |>\nWell, it is not the selection algorithm\
    \ that is the O(n) time complexity but just iterating through the array elements.\
    \ Even if this is true selection algorithm, it would be O(n) because we are not\
    \ iterating through all the elements of the array.\n<|/ c |>\n<| c |>\nYes, I\
    \ agree it is the selection algorithm (selection sort is the worst case scenario\
    \ - but O(n) time complexity)\n<|/ c |>\n<| c |>\nIf this was the best answer,\
    \ you should mark it as such.  It's also not O(n) for a general case - if you\
    \ have some specific case where it is, then we can find a solution.\n<|/ c |>\n\
    <| a tags=arrays,algorithm,sorting |>\nOne easy way to do it is to sort it, then\
    \ compare the difference between successive elements to see if the order is ascending,\
    \ descending. \nPseudocode:\n<code>", "{\n    return monotonic(l, l);\n}", "{\n\
    \    long prev = 0;\n    long curr = 1;\n    long first = 1;\n    for (int i =\
    \ 0; i < l.length; ++i)\n    {\n        if (l[i] < prev) \n        {\n       \
    \     first = prev;\n            break;\n        }\n        prev = curr;\n   \
    \     curr = curr*l[i] + (1 - l[i])*first;\n    }\n    return !(curr < first);\n\
    }", "{\n    if (l.length < 2) return false;\n    long x1 = l[0];\n    long x2\
    \ = l[1];\n    for(int i = 2; i < l.length; i++) \n    {\n        long x3 = l[i];\n\
    \        if (x1 > x3) x1 = x3;\n        else if (x1 < x3) x2 = x3;\n    }\n  \
    \  return x1 < x2;\n}\n//===========================================================================================\n\
    /*\n    AdaptiveHistogram is described in detail in the paper:\n    Rainer Roelofs,\
    \ Markus Schmidt, and Josef Van Steenkiste.\n    \"Efficient Adaptive Histogram-Based\
    \ Medical Image Analysis\".\n    https://www.sciencedirect.com/science/article/pii/S0167214871300011",
  "{\n    for(long i = l.length; i > 0; --i) \n        if(l[i-1] <= l[i])\n      \
    \      return false;\n    return true;\n}", "{\n  bool decreasing = true;\n  int\
    \ i = 1;\n  while (i<l.length && l[i-1] <= l[i]) {\n    i++;\n  }\n  if (i==l.length)\
    \ return decreasing;\n  while (decreasing && l[i-1] > l[i]) {\n    decreasing\
    \ = !decreasing;\n    i++;\n  }\n  return decreasing;\n}", "{\n    long first\
    \ = l[0];\n    bool res = true;\n    for(int i = 1; i < l.length; ++i)\n     \
    \   if (l[i] < first)\n        {\n            res = false;\n            break;\n\
    \        }\n        else\n            first = l[i];\n    return res;\n}\n/*\n\
    Return true is array elements are monotonically increasing or decreasing.\n  \
    \  >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L,\
    \ 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n*/", "{\n\
    \tint n = l.length;\n\tif(n == 0) return true;\n\tif(n == 1) return l[0] >= l[1]\
    \ || l[0] == l[1];\n\tif(l[0] != l[n-1]) return false;\n\tif(n == 2) return l[0]\
    \ > l[1];\n\treturn true;\n}", "{\n    long x = l[0];\n    long y = l[l.length-1];\n\
    \    bool xIncr = (x >= y);\n    bool yIncr = (x <= y);\n    bool yDcr = (y >=\
    \ x);\n    return xIncr == yIncr && xIncr == yDcr;\n}\n/*\nReturn true is array\
    \ elements are monotonically increasing or decreasing.\n    >>> monotonic([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n\
    \    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/", "{\n\tint len = l.length;\n\
    \tif (len <= 1) return true;\n\tlong a = l[0];\n\tlong b = l[1];\n\tfor (int i\
    \ = 2; i < len; i++) {\n\t\tlong c = l[i];\n\t\tif (c < a || (a == c && b < c))\
    \ return false;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn true;\n}", "{\n    if (l.Length\
    \ == 0)\n    {\n        return false;\n    }\n    long min = l[0];\n    bool minChanged\
    \ = false;\n    for (int i = 1; i < l.Length; i++)\n    {\n        long current\
    \ = l[i];\n        bool currentChanged = false;\n        if (current < min)\n\
    \        {\n            min = current;\n            minChanged = true;\n     \
    \       currentChanged = true;\n        }\n        else if (current == min)\n\
    \        {\n            if (i < l.Length - 1)\n            {\n               \
    \ long nextVal = l[i + 1];\n                currentChanged = nextVal < current;\n\
    \                if (currentChanged)\n                {\n                    min\
    \ = nextVal;\n                }\n            }\n        }\n        else\n    \
    \    {\n            if (current < min)\n            {\n                min = current;\n\
    \                minChanged = true;\n            }\n        }\n        \n    \
    \    if (minChanged)\n        {\n            break;\n        }\n    }\n    return\
    \ minChanged;\n}\n/*\nReturn true is array elements are monotonically increasing\
    \ or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n\
    \    \n*/", "{\n    int n = l.length-1;\n    int m = -1;\n    for(int i=0; i<n;\
    \ i++) {\n        if(l[i] >= l[i+1]) {\n            m = i;\n            break;\n\
    \        }\n    }\n    if(m != -1 && l[m] >= l[m+1]) {\n        return true;\n\
    \    }\n    return false;\n}\n</code>\n<|/ a dscore=1 tags=arrays,c++ |>\n<| a\
    \ |>\n<code>\n#include <bits/stdc++.h>\nusing namespace std;", "{\n    for(size_t\
    \ i = 1; i < l.length; ++i)\n        if(l[i] > l[i-1]) return false;\n    return\
    \ true;\n}", "{\n    int i = 0;\n    int j = l.length - 1;\n    int min_i = -1;\n\
    \    int max_i = 0;\n    int min_j = -1;\n    int max_j = 0;\n    \n    while\
    \ (i < j)\n    {\n        int m_i = l[i];\n        int m_j = l[j];\n        int\
    \ max_val = std::max(m_i, m_j);\n        int min_val = std::min(m_i, m_j);\n \
    \       if (min_i > -1) \n        {\n            if (min_val > max_val)\n    \
    \            return false;\n            if (min_val < min_i)\n            {\n\
    \                min_i = min_val;\n                min_j = m_i;\n            }\n\
    \        }\n        else\n        {\n            if (max_val > max_i)\n      \
    \      {\n                max_i = max_val;\n                max_j = m_i;\n   \
    \         }\n        }\n        \n        if (m_i > m_j)\n            i += 1;\n\
    \        else\n            j -= 1;\n    }\n    \n    if (min_i < max_i) \n   \
    \ {\n        if (min_j > max_j)\n        {\n            min_j = max_j;\n     \
    \       min_i = max_i;\n        }\n    }\n    \n    return true;\n}\n</code>\n\
    <|/ a tags=list,functional-programming,arrays,c++ |>\n<| c |>\nThis algorithm\
    \ does not correctly answer the OP's question, which asks for non-increasing (or\
    \ non-decreasing) ranges of the array. Rather than checking that the elements\
    \ increase monotonically, it checks that there are no gaps in the array. As long\
    \ as the array is sorted and non-decreasing, this algorithm works correctly in\
    \ all cases, even if the elements aren't sequential and don't increase monotonically.\n\
    <|/ c |>\n<| a dscore=4 |>\nA simple and fast solution using only standard library\
    \ functions is to sort the range and then check if the difference between consecutive\
    \ elements is positive. This requires O(n log n) comparisons and O(n log n) memory\
    \ allocations.\n<code>\n#include <algorithm>\n#include <cstdio>", "{\n  int i\
    \ = 0; \n  while (i<l.length-1) {\n    if (l[i+1] < l[i]) {\n      return true;\n\
    \    } else if (l[i+1] > l[i]) {\n      return false;\n    }\n    i++;\n  }\n\
    \  return false;\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nJust a comment: I like\
    \ this solution the best.  It is the most efficient solution to this problem and\
    \ easy to read.  For others who may find it useful, I found this post because\
    \ I was looking for something that would work with c# and couldn't find it.  Using\
    \ this solution allowed me to easily get my own c# implementation for unit testing\
    \ to pass.\n<|/ c |>\n<| c |>\nI added an answer in C# for this question, see\
    \ below.\n<|/ c |>\n<| c |>\nIt should be noted that some implementations may\
    \ return false positives. For example, for arrays where every element appears\
    \ at least twice, `monotonic` will return false.\n<|/ c |>\n<| c |>\n, It should\
    \ be noted that Monotonic is a requirement for array sorting, not just for sorting.\
    \ Many sorting algorithms require monotonic sorting.\n<|/ c |>\n<| c |>\n: Indeed,\
    \ not all sorting algorithms do require monotonic sorting. For example, you can\
    \ sort a list in O(n) if you use a list as an array and use the same algorithm\
    \ for sorting. I did a blog post about this a while back: https://dev.to/paolostefanatico/algorithm-for-fast-monotonic-array-sorting-2jh8\n\
    <|/ c |>\n<| a tags=arrays,monotonic,sorting,algorithm,c# |>\nThis question was\
    \ asked long before C++11 and even before C++20, but I wanted to provide an answer\
    \ in case someone comes across this question with other languages/programming\
    \ languages.\nIn C++, there is the is_sorted function in <algorithm> that checks\
    \ if a container is sorted:\n<code>\n#include <algorithm>\n#include <iostream>",
  "{\n\tif (l.length <= 1) \n\t\treturn true;\n\tauto i = 1;\n\tauto j = l.length\
    \ - 2;\n\twhile (i <= j) \n\t{\n\t\tauto mid = (i + j) >> 1;\n\t\tif (l[mid] >\
    \ l[i]) \n\t\t\tj = mid;\n\t\telse if (l[mid] < l[i]) \n\t\t\ti = mid + 1;\n\t\
    \telse \n\t\t\treturn true;\n\t}\n\treturn false;\n}", "{\n    long[] h = new\
    \ long[l.length];\n    long mn = l[0], mx = l[0], mnI = 0, mxI = 0;\n    for (int\
    \ i = 1; i < l.length; i++) \n    {\n        long v = l[i];\n        long k =\
    \ h[v];\n        if (k == 0) \n        {\n            h[v] = i;\n        }\n \
    \       else \n        {\n            if (k < i) \n            {\n           \
    \     mnI = i;\n                mn = 0;\n            }\n            mx = v;\n\
    \            mxI = i;\n        }\n    }\n    if (mn == 0) \n    {\n        return\
    \ true;\n    }\n    long m = mn, M = mx, Mi = mn, MxI = mn, Mx = 0;\n    for (int\
    \ i = 0; i < l.length; i++) \n    {\n        long v = l[i];\n        long k =\
    \ h[v];\n        if (k != i) \n        {\n            if (k < i) \n          \
    \  {\n                Mi = i;\n                MxI = i;\n                Mx =\
    \ 0;\n            }\n            else\n            {\n                M = v;\n\
    \                MxI = i;\n                Mx = v;\n            }\n        }\n\
    \    }\n    long n = 0;\n    for (int i = l.length - 1; i >= 0; i--) \n    {\n\
    \        long v = l[i];\n        long k = h[v];\n        if (k != i) \n      \
    \  {\n            if (k < i) \n            {\n                n = 1;\n       \
    \     }\n            else\n            {\n                if (MxI > i) \n    \
    \            {\n                    MxI = i;\n                }\n            }\n\
    \        }\n        else\n        {\n            if (MxI > i) \n            {\n\
    \                n = 1;\n            }\n            else\n            {\n    \
    \            M = v;\n                MxI = i;\n                Mx = v;\n     \
    \       }\n        }\n    }\n    if (n == 0) \n    {\n        return false;\n\
    \    }\n    boolean ok = true;\n    if (MxI < mxI) \n    {\n        ok = false;\n\
    \    }\n    return ok;\n}\n</code>\n<|/ a |>\n<| a tags=list,search,algorithm,c#\
    \ |>\n<code>\npublic class IntList\n{\n    public int Min { get; private set;\
    \ }\n    public int Max { get; private set; }", "{\n    int i;\n    if (l[0] ==\
    \ 0L) return true; // no elements are less than or equal to 0\n    i = 1;\n  \
    \  while (i < l.length) \n    {\n        if (l[i-1] > l[i]) \n            return\
    \ false;\n        i++;\n    }\n    return true;\n}", "{\n    for (int i = 0; i\
    \ < l.length-1; ++i) {\n        if (l[i+1] < l[i]) {\n            return false;\n\
    \        }\n    }\n    return true;\n}", "{\n\tint i, n = (int)l.length;\n\tif\
    \ (n < 2) return true;\n\tif (n < 4) return true;\n\tfor (i = 1; i < n - 1; i++)\
    \ \n\t\tif (l[i] < l[i - 1]) return false;\n\treturn true;\n}", "{\n    for (int\
    \ i = 0; i < l.length; ++i) {\n        if (l[i] < l[i - 1]) \n            return\
    \ false;\n        if (l[i] > l[i + 1]) \n            return true;\n    }\n   \
    \ return true;\n}\n</code>\n<|/ a |>\n<| a tags=python,algorithm |>\nI realize\
    \ this is an old question, but I came across it while searching for an increasing\
    \ subsequence problem in Python, so I thought I would share my solution here in\
    \ case it helps anyone.\nI created an increasing subsequence function using the\
    \ bisect library (available on PyPi as bisect). The function takes an array and\
    \ returns the indices of increasing subsequences of length 1. Here is the function:\n\
    <code>\ndef increasing_subsequence(array):\n    indices = []\n    \n    \n   \
    \ for i, element in enumerate(array):\n        low = i\n        while low < len(array)\
    \ and array[low] <= element:\n            low += 1\n        indices.append(low)\n\
    \        \n        if i == low:\n            return indices\n            \n  \
    \      upper = i\n        while upper < len(array) and array[upper] >= element:\n\
    \            upper -= 1\n        indices.append(upper)\n    \n    return indices\n\
    </code>\nHope this is helpful!\n<|/ a dscore=2 |>\n<| a tags=python,algorithm\
    \ |>\nHere's my solution in JavaScript that works pretty well:\n<code>\nfunction\
    \ monotonic(a) {\n    var result = 0;\n    var current = 0;\n    for (var i =\
    \ 0; i < a.length; i++) {\n        if (a[i] > current) {\n            result++;\n\
    \            current = 0;\n        } else if (a[i] < current) {\n            result--;\n\
    \        }\n        current = a[i];\n    }\n    return (result == 0);\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nIf this answer is what you were looking for, then\
    \ you should accept it so others can see it works and also upvote it if you want.\n\
    <|/ c |>\n<| a |>\nI believe this is a very interesting problem. My solution relies\
    \ on Python's sorted data structure and Python slices:\n<code>\ndef monotonic(seq):\n\
    \    return seq == sorted(seq)[0:len(seq) - 1]\n</code>\n<|/ a dscore=1 tags=python,algorithm\
    \ |>\n<| c |>\nThat works fine if you only need `monotonic` for a single sequence.\
    \ How about if you wanted a function that works for any sequence? This wouldn't\
    \ be possible with this solution.\n<|/ c |>\n<| c |>\n- That's a good point, but\
    \ I do think it still works well for many sequences. If you want a function that\
    \ works for any sequence, you'll need a recursive solution.\n<|/ ", "{\n    int\
    \ n = l.Length;\n    if(n == 0) return true;\n    if(n < 2) return false;\n  \
    \  long last = l[n - 1];\n    int i = 0;\n    for(; i < n - 2; i++) \n    {\n\
    \        if(l[i] > last) break;\n        last = l[i];\n    }\n    if(i == n -\
    \ 2) return true;\n    if(l[i] < last) \n    {\n        for(int j = i + 1; j <\
    \ n; j++) \n        {\n            if(l[j] > l[i]) return true;\n        }\n \
    \       return false;\n    }\n    return false;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    What about this case? monotonic([1L, 2L, 3L, 4L, 2L, 3L, 4L, 2L, 3L, 4L, 5L])\
    \ ? The answer is false\n<|/ c |>\n<| c |>\nGood catch!  I fixed the code so it\
    \ doesn't go over the edge of the array.\n<|/ c |>\n<| a dscore=3 tags=algorithm,c#\
    \ |>\nI assume you mean the most efficient algorithm.\nI wrote a little C# program\
    \ to test it. In fact, I just ran it with LinqPad to check the result.\n<code>\n\
    // from http://codereview.stackexchange.com/questions/57468/c-program-to-determine-whether-an-large-array-is-monotonically-inceasing-or-deceasing\n\
    static bool IsMonotonic(int[] arr)\n{\n    int N = arr.Length;\n    if (N < 2)\
    \ return true;", "{\n    int m = 0;\n    int n = l.length - 1;", "{\n  return\
    \ std.typecons.lessThan(l, std.sort(std.copy(l)));\n}\n/// Returns true if array\
    \ elements are monotonically increasing or decreasing.", '{', "{\n    \n    int\
    \ m = l.length - 1;\n    bool result = false;\n    int left = l[m];\n    int right\
    \ = l[m+1];\n    \n    while (m >= 0)\n    {\n        if (left > right)\n    \
    \    {\n            result = true;\n            break;\n        }\n        if\
    \ (l[m] < l[m-1])\n        {\n            left++;\n        }\n        else\n \
    \       {\n            right--;\n        }\n        m--;\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nGreat solution and very intuitive! I'd\
    \ add that one can use \"bool result = left < right\" instead of the while loop.\
    \ The compiler might optimize it the same way, but just to be safe.\n<|/ c |>\n\
    <| c |>\nAs an aside, since you are dealing with strictly monotonic lists, you\
    \ could use `if(l[m] >= l[m-1])` (note the order comparison)\n<|/ c |>\n<| a tags=c#,math,list\
    \ dscore=2 |>\nThe other answers don't quite work in my case. \n<code>\npublic\
    \ static bool IsMonotonic(this IList<long> list)\n    {\n        var list = list.OrderByDescending(a\
    \ => a);", "{\n    int n = l.length-1;\n    if (l[n] > l[n+1])\n        return\
    \ false;\n    for (int i = 0; i < n; i++) {\n        if (l[i] > l[i+1])\n    \
    \        return false;\n    }\n    return true;\n}", "{\n    int n = l.Length;\n\
    \    long a = l[n-1];\n    for (int i = 0; i < n; ++i)\n    {\n        if (l[i]\
    \ < a)\n            return false;\n    }\n    return true;\n}\n</code>\n<|/ a\
    \ dscore=3 |>\n<| a |>\nFor some reason I got some downvotes on this but after\
    \ reading through some more I think my answer was really good. I'm assuming you\
    \ want something more general than just increasing or decreasing but I'll still\
    \ post it anyway in case it's helpful to anyone else.\nFor example if your array\
    \ was this:\n<code>\n[4, 6, 5, 8, 3]\n</code>\nYour answer would return true because\
    \ 6 is greater than 4 but less than 5.\nAnd if your array was this:\n<code>\n\
    [4, 6, 5, 8, 7, 3]\n</code>\nYour answer would return false because 6 is greater\
    \ than 4 but less than 5.\nThis code does exactly that:\n<code>\nfunction bool\
    \ IncreasingOrDecreasing(int[] arr) {\n    bool ret = false;\n    foreach (int\
    \ i in arr) {\n        for (int j = 0; j < arr.Length; j++) {\n            if\
    \ (j != i)\n                if (arr[j] > arr[j + 1])\n                    ret\
    \ = true;\n            }\n        }\n        return ret;\n    }\n</code>\n<|/\
    \ a tags=algorithm,c# dscore=2 |>\n<| a |>\nThis is an old thread but I wanted\
    \ to add another option if you were dealing with float arrays instead of ints.\
    \ \nMy goal was to identify if the input array was monotonic or not, and I did\
    \ not want to deal with comparing each element with each other element. I wanted\
    \ to create a method that would determine if the array was monotonic or not.\n\
    <code>\npublic class MonotonicComparer<T> : IEqualityComparer<T>\n{\n    public\
    \ bool Equals(T x, T y)\n    {\n        return Math.Abs(x - y) <= 0.00000000001f;\n\
    \    }\n    public int GetHashCode(T obj)\n    {\n        return 0;\n    }\n}",
  "{\n    ulong first=0, last=0;\n    ulong maxi=0;\n    ulong mini=0;\n    bool is_sorted\
    \ = false;\n    foreach(ulong e in l) {\n        if (is_sorted) {\n          \
    \  last = e;\n        } else {\n            is_sorted = true;\n            first\
    \  = e;\n        }\n        \n        if (e < first) {\n            mini = e;\n\
    \        } else if (e > last) {\n            maxi = e;\n        }\n    }\n   \
    \ if (maxi-mini > 0) {\n        if (maxi == mini) {\n            return true;\n\
    \        } else if (maxi > mini) {\n            return false;\n        }\n   \
    \ }\n    if (maxi != 0) {\n        return maxi > mini;\n    }\n    return false;\n\
    }", "{\n    var x = l[0], y = l[0], z = l[0];\n    var i = 0;\n    while(i < l.length)\
    \ {\n        var k = i;\n        for(var j = i+1; j < l.length; j++) {\n     \
    \       if(l[k] <= l[j]) {\n                k = j;\n            }\n        }\n\
    \        if(k - i == 1) {\n            if(x < l[k]) {\n                x = l[k];\n\
    \            }\n        } else if(k - i == -1) {\n            if(y < l[k]) {\n\
    \                y = l[k];\n            }\n        }\n        i++;\n    }\n  \
    \  return x != l[0] && y != l[0];\n}", "{\n    return monotonic(l, l.length-1);\n\
    }", "{\n    if (l.Length < 2) return true;\n    int cmp = long.MaxValue;\n   \
    \ for (int i = 1; i < l.Length; i++)\n    {\n        cmp = long.MinValue.Compare(l[i],\
    \ l[i - 1]);\n        if (cmp != 0) return false;\n    }\n    return true;\n}",
  "{\n\tif (l.length==0) \n\t\treturn true;\n\tlong prev = l[0];\n\tfor (int i=1;\
    \ i<l.length; ++i)\n\t{\n\t\tif (l[i]<prev)\n\t\t\treturn false;\n\t\tprev = l[i];\n\
    \t}\n\treturn true;\n}", "{\n  if (l.length == 0) return true;\n  bool first =\
    \ true;\n  for (auto element : l) {\n    if (!first) \n    {\n      if (element\
    \ > l[i - 1]) return false;\n    }\n    else\n    {\n      if (element < l[i -\
    \ 1]) return false;\n    }\n    first = false;\n  }\n  return true;\n}", "{\n\
    \    int i, j, k, l;\n    long x;\n    bool b;\n    long max, min;\n    long ans;",
  "{\n\tbool result = true;\n\tint i = 0;\n\twhile(i < l.length - 1 && l[i] > l[i+1])\
    \ ++i;\n\tif(i < l.length - 1 && l[i] < l[i+1]) result = false;\n\telse {\n\t\t\
    i = 0;\n\t\twhile(i < l.length - 1 && l[i] < l[i+1]) ++i;\n\t\tif(i < l.length\
    \ - 1 && l[i] > l[i+1]) result = false;\n\t}\n\treturn result;\n}", "{\n  if(l.length<=2)\n\
    \    return true;\n  bool res = true;\n  for(int i=0; i<l.length-1; ++i)\n  {\n\
    \    if(l[i]>l[i+1])\n      res = false;\n  }\n  return res;\n}", "{\n\tint i\
    \ = 0;\n\tint j = l.length - 1;\n\twhile (i < j) \n\t{\n\t\tif (l[i] <= l[j])\n\
    \t\t\ti++;\n\t\telse\n\t\t\tj--;\n\t}\n\treturn (i < j);\n}", "{\n    long last\
    \ = l[0];\n    bool increasing = true;\n    for (int i = 1; i < l.length; ++i)\
    \ {\n        long current = l[i];\n        if (current > last) {\n           \
    \ increasing = false;\n        } else {\n            last = current;\n       \
    \ }\n    }\n    return increasing;\n}", "{\n    long i = 1;\n    long j = -1;\n\
    \    while (i<l.length && j>0) {\n        long k = l[i];\n        if (k < l[j])\
    \ {\n            if (k == l[j]) return false;\n        }\n        if (k > l[j])\
    \ {\n            if (k == l[j]) return true;\n        }\n        j--;\n      \
    \  i++;\n    }\n    return (i==l.length);\n}", "{\n    if (l.length < 2) return\
    \ true;\n    if (l.length == 1) return l[0] == l[1];\n    \n    long max = l[0];\n\
    \    for (long i = 1; i < l.length; i++)\n    {\n        if (max < l[i]) return\
    \ false;\n        max = l[i];\n    }\n    return true;\n}", "{\n\tuint i = 0;\n\
    \tuint j = 0;\n\tlong prev = l[0];\n\tbool incr = true;\n\tfor(; i < l.length\
    \ && l[i] >= prev; prev = l[i], incr = !incr) {\n\t\tif(incr) j++;\n\t\telse j--;\n\
    \t}\n\treturn i > j;\n}", "{\n  bool result = true;", "{\n    // O(n^2) naive\
    \ algorithm \n    int max = l.length - 1;\n    for (int i = 0; i < max; ++i) {\n\
    \        for (int j = i + 1; j <= max; ++j) {\n            if (l[i] < l[j]) {\n\
    \                return true;\n            }\n            if (l[i] > l[j]) {\n\
    \                return false;\n            }\n        }\n    }\n    return false;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is not monotonic. Consider for example `monotonic([1,\
    \ 2, 3])`. Returns `true` which is wrong.\n<|/ c |>\n<| c |>\n: You are right.\
    \ There was a bug on the last `for` loop condition. It has been fixed.\n<|/ c\
    \ |>\n<| c |>\nA little bit slower than my version, but you get my vote :)\n<|/\
    \ c |>\n<| a dscore=1 |>\nHere is a simple and fast solution:\n<code>", "{\n\t\
    if(l.length==1) return false;\n\tlong first=l[0], last=l[0];\n\tbool found=false;\n\
    \tfor(long i=1;i<l.length;++i) {\n\t\tif(i<l.length-1 && (first<l[i+1] || first==l[i+1]\
    \ && last>l[i])) {\n\t\t\tlast=l[i];\n\t\t\tfound=true;\n\t\t}\n\t\tfirst=l[i];\n\
    \t}\n\treturn found;\n}", "{\n    bool b = true;\n    for(int i=0;i<l.length;i++)\
    \ {\n        if(l[i] <= l[i-1]) {\n            b = false;\n        }\n    }\n\
    \    return b;\n}", "{\n    if (l.length == 0)\n        return true;\n    long\
    \ last = 0;\n    long min = l[0];\n    for (int i = 1; i < l.length; i++)\n  \
    \  {\n        if (l[i] > last)\n            return false;\n        if (l[i] <\
    \ min)\n        {\n            min = l[i];\n            last = l[i];\n       \
    \ }\n    }\n    return true;\n}\n/* Given an array of monotonically increasing\
    \ or decreasing numbers,\nreturn its median.\n    \nIf there are an even number\
    \ of elements, then the median is the average of the two.\nIf there are an odd\
    \ number of elements, then the median is the middle one.\n */", "{\n\tlong last\
    \ = l[0];\n\tbool hasFirst = false, hasLast = false;", "{\n\tint i = (int) length(l)\
    \ - 1;\n\twhile(i > 0)\n\t{\n\t\tif(l[i] > l[i-1]) return false;\n\t\ti--;\n\t\
    }\n\treturn true;\n}\n/*\nReturn true is array elements are monotonically increasing\
    \ or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n\
    \    \n*/", "{\n  int i;\n  bool flag;\n  bool inc;\n  bool dec;\n  long last\
    \ = 0;\n  for (i = 1; i < l.length; i++) {\n    if (l[i] < last)\n      continue;\n\
    \    if (l[i] > last) {\n      flag = false;\n      inc = false;\n      dec =\
    \ true;\n      break;\n    }\n  }\n  for (last = 0; !flag; last = l[l.length -\
    \ 1]) {\n    flag = true;\n    for (i = 1; i < l.length; i++) {\n      if (l[i]\
    \ <= last) {\n        flag = false;\n        inc = true;\n      }\n      else\
    \ {\n        inc = false;\n      }\n      if (l[i] >= last) {\n        dec = true;\n\
    \      }\n      else {\n        dec = false;\n      }\n    }\n    if (inc) {\n\
    \      if (dec)\n        return true;\n    }\n    else {\n      if (dec)\n   \
    \     return false;\n    }\n  }\n  return false;\n}\n/*\nReturn true if array\
    \ elements are sorted increasing or decreasing.\n    >>> monotonic_down([1L, 2L,\
    \ 4L, 20L])\n    true\n    >>> monotonic_down([1L, 20L, 4L, 10L])\n    false\n\
    \    >>> monotonic_down([4L, 1L, 0L, -10L])\n    true\n    \n*/", "{\n    for\
    \ (int i = 0; i < l.length-1; ++i)\n    {\n        if (l[i] > l[i+1]) return false;\n\
    \    }\n    return true;\n}\n'''", "{\n    int m = l.length;\n    int i = 0;\n\
    \    int j = 0;\n    for(int n=0;n<m;n++)\n    {\n        if(l[n] > l[n+1])\n\
    \        {\n            if(l[n] > l[i])\n            {\n                return\
    \ true;\n            }\n            else\n            {\n                return\
    \ false;\n            }\n        }\n        if(l[n] < l[i])\n        {\n     \
    \       if(l[n] < l[j])\n            {\n                return true;\n       \
    \     }\n            else\n            {\n                return false;\n    \
    \        }\n        }\n        i++;\n        j++;\n    }\n    return false;\n\
    }\n</code>\n<|/ a dscore=4 tags=arrays,sorting,algorithm,c++,javascript |>\n<|\
    \ a dscore=4 |>\n<code>\npublic static bool IsMonotonic(this List<long> list,\
    \ int direction)\n{\n    if(direction == 1)\n        return list.OrderBy(i =>\
    \ i).SequenceEqual(list.Reverse());\n    else\n        return list.OrderByDescending(i\
    \ => i).SequenceEqual(list.Reverse());\n}\n</code>\n<|/ a tags=arrays,sorting,algorithm,c++,javascript\
    \ |>\n<| c |>\nFor those who don't know what `SequenceEqual` does. it checks if\
    \ the two sequences are equal in length and the same elements at the same position.\
    \ `1` will never be compared to `10` so this checks that both sequences are equal\
    \ in order. `10` will never be compared to `1` so this checks that the second\
    \ sequence is equal in order and in the same order as the first sequence. `IsMonotonic([1,2,3,4,5])`\
    \ will always return `true` because `SequenceEqual` will return `true` for both\
    \ sequences that are equal in length.\n<|/ c |>\n<| c |>\nThis is the best answer\
    \ so far. Thanks very much!\n<|/ c |>\n<| a dscore=3 |>\nSort the array in O(N\
    \ log N)\nIf the length of the array is even, check that every even item is lower\
    \ than the one before it (same for odd lengths).\nIf the length of the array is\
    \ odd, check that the odd item is lower than the one after it.\nIf the length\
    \ of the array is even, then check that the even item is lower than the one before\
    \ it.\nIf even and odd lengths match, then the array is monotonic\n<|/ a tags=arrays,sorting,algorithm,c++,javascript\
    \ |>\n<| c |>\nThis fails for `1, 2, 5, 4`. It should be `1, 2, 4, 5`.\n<|/ c\
    \ |>\n<| c |>\n: I think the example is wrong. `1, 2, 5, 4` ", "{\n\tbool r =\
    \ true;\n\tlong xl = l[0];\n\tlong xr = l[0];\n\tfor (int i = 1; i < l.length;\
    \ i++) {\n\t\tif (l[i] < xl) {\n\t\t\tr = false;\n\t\t}\n\t\tif (l[i] > xr) {\n\
    \t\t\tr = true;\n\t\t}\n\t\tif (r == false) {\n\t\t\txr = l[i];\n\t\t}\n\t\tif\
    \ (r == true) {\n\t\t\txl = l[i];\n\t\t}\n\t}\n\treturn r;\n}", "{\n   long min\
    \ = l[0], max = l[0];\n   for (int i = 1; i < l.length; i++)\n   {\n      if (l[i]\
    \ < min)\n      {\n         min = l[i];\n      }\n      else if (l[i] > max)\n\
    \      {\n         max = l[i];\n      }\n   }\n   return (min <= max);\n}", "{\n\
    \tif (l==null)\n\t\treturn false;\n\tif (l.length==0)\n\t\treturn true;\n\t\n\t\
    bool leftmost= l[0] < l[1];\n\tbool rightmost= l[0] > l[1];\n\t\n\tfor (int i=0;i<l.length-1;\
    \ i+=2)\n\t{\n\t\tbool thisLeft= l[i] < l[i+1];\n\t\tbool thisRight= l[i] > l[i+1];\n\
    \t\tbool right= thisLeft && thisRight;\n\t\tbool left= !(thisLeft || thisRight);\n\
    \t\t\n\t\tbool thisLeftM= rightmost;\n\t\tbool thisRightM= leftmost;\n\t\t\n\t\
    \tif (right)\n\t\t{\n\t\t\tif (leftmost) \n\t\t\t\tthisLeftM=false;\n\t\t\telse\n\
    \t\t\t\tthisRightM=false;\n\t\t}\n\t\t\n\t\tif (left)\n\t\t{\n\t\t\tif (rightmost)\
    \ \n\t\t\t\tthisLeftM=false;\n\t\t\telse\n\t\t\t\tthisRightM=false;\n\t\t}\n\t\
    \t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tbool leftMinusRight=thisLeftM;\n\t\tbool\
    \ rightMinusLeft=thisRightM;\n\t\tif (right) \n\t\t{\n\t\t\trightMinusLeft=!leftMinusRight;\n\
    \t\t}\n\t\t\n\t\tif (left) \n\t\t{\n\t\t\tleftMinusRight=!rightMinusLeft;\n\t\t\
    }\n\t\t\n\t\t\n\t\tif (leftMinusRight && rightMinusLeft)\n\t\t\treturn true;\n\
    \t\telse if (!leftMinusRight && !rightMinusLeft)\n\t\t\treturn false;\n\t}\n\t\
    return false;\n}", "{\n    bool monotonic = false;", "{\n\tif (l.length < 2)\n\
    \t\treturn false;\n\tlong last = l[0];\n\tlong mid = l[1];\n\tfor (int i = 2;\
    \ i < l.length; ++i)\n\t{\n\t\tlong next = l[i];\n\t\tif (mid > next)\n\t\t\t\
    return true;\n\t\tif (mid == next && last > next)\n\t\t\treturn false;\n\t\tlast\
    \ = next;\n\t\tmid = next;\n\t}\n\treturn false;\n}\nimport std.stdio;\nimport\
    \ std.string;\nimport std.file;", "{\n  int N=l.length;\n  if (N<2) return true;\n\
    \  long prev=l[0];\n  for (int i=1; i<N; i++) {\n    if (l[i]>prev) return true;\n\
    \    prev=l[i];\n  }\n  return false;\n}", "{\n    long min = l[0];\n    long\
    \ max = l[0];\n    int n = l.length;\n    for (int i = 0; i < n; i++) {\n    \
    \    if (l[i] < min)\n            min = l[i];\n        if (l[i] > max)\n     \
    \       max = l[i];\n    }\n    if (min < 0)\n        min = 0;\n    if (max >=\
    \ 0)\n        max--;\n    if (max - min == 0)\n        return true;\n    int m\
    \ = (n + 1) >> 1;\n    int t = 0;\n    while (m >= 2) {\n        if (l[t * 2]\
    \ - l[t * 2 + 1] < min)\n            return false;\n        if (l[t * 2] - l[t\
    \ * 2 + 1] > max)\n            return false;\n        t++;\n        m >>= 1;\n\
    \    }\n    return true;\n}", "{\n\tif (l.length==1)\n\t\treturn true;\n\tlong\
    \ a = l[0], b = l[1], c = l[2];\n\tlong d = c-b;\n\tif (d == 0) {\n\t\treturn\
    \ true;\n\t}\n\tlong e = a-c;\n\tif (e < 0) {\n\t\tint sign = 1;\n\t\ta = c;\n\
    \t\tc = b;\n\t\tb = sign * a;\n\t\td = sign * d;\n\t\te = sign * e;\n\t}\n\tlong\
    \ f = a-b;\n\tif (f < 0) {\n\t\tint sign = 1;\n\t\ta = c;\n\t\tc = b;\n\t\tb =\
    \ sign * a;\n\t\tf = sign * f;\n\t}\n\tif (f == 0) {\n\t\treturn true;\n\t}\n\t\
    if (d == d*f) {\n\t\tdouble x = std.math.abs(d);\n\t\tdouble y = std.math.abs(f);\n\
    \t\treturn (x>y)? true:false;\n\t} else {\n\t\treturn false;\n\t}\n}\n/*\nReturn\
    \ true if the first argument is less than the second.\n    >>> isLess(1L, 1L)\n\
    \    true\n    >>> isLess(1L, 3L)\n    false\n*/", "{\n    int len = l.length;\n\
    \    long curr = l[0];\n    long next = l[0];\n    for (int i = 1; i < len; i++)\n\
    \    {\n        long curr = next;\n        next = l[i];\n        if (curr > next)\n\
    \            return false;\n    }\n    return true;\n}", "{\n\tint leng = l.Length;\n\
    \tint lastIndex = leng-1;\n\tbool increasing = true;\n\tfor (int i = 0; i < leng;\
    \ i++)\n\t{\n\t\tif (l[i] < l[lastIndex])\n\t\t{\n\t\t\tincreasing = false;\n\t\
    \t}\n\t\telse if (l[i] > l[lastIndex])\n\t\t{\n\t\t\tlastIndex = i;\n\t\t}\n\t\
    }\n\treturn increasing;\n}", "{\n    int i, j, k;\n    for (i = 1; i < l.length;\
    \ i++)\n        if (l[i] < l[i - 1]) {\n            for (j = i; j > 0; j--)\n\
    \                if (l[j] < l[j - 1]) {\n                    return false;\n \
    \               }\n            break;\n        }\n    return true;\n}", "{\n\t\
    long prev = l[0];\n\tfor (long i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] <\
    \ prev) return true;\n\t\telse if (l[i] > prev) return false;\n\t\tprev = l[i];\n\
    \t}\n\treturn true;\n}\n/* \n    \n*/\nlong[] monotonic(long[] l) \n{\n\tlong[]\
    \ ret = new long[l[l.length-1] + 1];\n\tint i = 0;\n\tret[i] = l[0];\n\tint j\
    \ = 0;\n\tfor (long k = 1; k < l.length; k++) \n\t{\n\t\tif (l[k] < l[j]) \n\t\
    \t{\n\t\t\tret[i] = l[k];\n\t\t\ti++;\n\t\t\tj++;\n\t\t} \n\t\telse if (l[k] >\
    \ l[j]) \n\t\t{\n\t\t\tret[i] = l[k];\n\t\t\ti++;\n\t\t} \n\t\telse \n\t\t{\n\t\
    \t\tret[i] = l[j];\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\
    /* \n    \n*/", "{\n    long curr = l[0], prev=curr, count = 1;\n    for (int\
    \ i=1; i < l.length; i++)\n    {\n        if (curr > l[i])\n        {\n      \
    \      curr = l[i];\n            prev = l[i-1];\n            count++;\n      \
    \  }\n        else if (curr < l[i])\n        {\n            return false;\n  \
    \      }\n        else if (curr == prev)\n        {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n</code>\n<|/ a tags=algorithm,sorting,c,performance\
    \ |>\n<| c |>\nWhile the solution works fine, it doesn't help the OP understand\
    \ the problem and solve it.\n<|/ c |>\n<| c |>\nYes, I agree, I will fix it.\n\
    <|/ c |>\n<| c |>\nThe \"count\" variable should be initialized with `1` instead\
    \ of `0`.\n<|/ c |>\n<| c |>\nyes, my mistake, should be 1. I am still learning\
    \ programming, so forgive my mistake.\n<|/ c |>\n<| c |>\nWhile this may answer\
    \ the question, please also explain why this would work and what it does.\n<|/\
    \ c |>\n<| a |>\nThis code can help you\n<code>\n#include <stdio.h>\n#include\
    \ <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <math.h>", "{\n\
    \  int n = l.length-1;\n  bool left = true;\n  bool right = left; // default\n\
    \  long curr = l[n];\n  for (int n = 0; n < l.length; n++)\n  {\n    if (curr\
    \ < l[n])\n    {\n      right = false;\n      curr = l[n];\n    }\n    else if\
    \ (curr > l[n])\n    {\n      left = false;\n      curr = l[n];\n    }\n  }\n\
    \  return left && right;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt's a nice\
    \ solution, I just tried it and it seems that it fails for cases where the first\
    \ element is lower than the second one.  e.g. monotonic([10,20,30,50]) returns\
    \ false, but monotonic([10,20,30,51,60]) returns true.\n<|/ c |>\n<| c |>\nThanks\
    \ for your comment and your solution! The algorithm seems to work pretty well.\
    \ However, I tested it with your example and it doesn't work correctly in my machine.\
    \ I have two questions: 1. Do you know why? 2. Is there a way to improve the performance\
    \ (for large arrays)?\n<|/ c |>\n<| c |>\nI am sorry it fails for cases where\
    \ the first element is lower than the second one. e.g. monotonic([10,20,30,50])\
    \ returns false, but monotonic([10,20,30,51,60]) returns true.\n<|/ c |>\n<| c\
    \ |>\n: I tested with your examples and it seems to work correctly for me with\
    \ both C# and C++.\n<|/ c |>\n<| c |>\n: Thanks for the input. My code is working\
    \ fine but I am curious about your approach. Have you tried to modify the implementation\
    \ to make it work with a large array (say one million elements)?\n<|/ c |>\n<|\
    \ a tags=sorting,java,arrays dscore=1 |>\nHere's a C# implementation using LINQ's\
    \ OrderBy and ThenBy extensions:\n<code>\n    static void Main(string[] args)\n\
    \    {\n        List<long> list = new List<long>() { 7, 8, 1, 9, 2, 10 };", "{\n\
    \  int maxi = l[0];\n  int mini = l[0];\n  for(int i = 1; i < l.length; ++i) \n\
    \  {\n    if(l[i] < mini) \n    {\n      mini = l[i];\n    }\n    else if(l[i]\
    \ > maxi) \n    {\n      maxi = l[i];\n    }\n  }\n  if(mini == maxi) \n  {\n\
    \    return false;\n  }\n  else\n  {\n    return true;\n  }\n}\n</code>\nThe second\
    \ function can then be used to identify the minimum element and maximum element\
    \ in an array.\n<code>\nlong minElement(long[] l) \n{\n    long minL = l[0];\n\
    \    for(int i = 1; i < l.length; ++i)\n    {\n        if(minL > l[i])\n     \
    \   {\n            minL = l[i];\n        }\n    }\n    return minL;\n}", "{\n\t\
    for(int i = 1; i < l.length; ++i) {\n\t\tif(l[i-1] < l[i]) {\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\t\n\treturn true;\n}", "{\n    return \n        l.length >= 2\n \
    \       && \n        !std.isNegative(l[0])\n        && !std.isNegative(l[l.length-1])\n\
    \        && \n        !std.isNegative(l[l.length-2])\n        &&\n        std.isNumeric(l[1])\n\
    \        &&\n        std.isNumeric(l[l.length-1])\n        &&\n        std.isNumeric(l[l.length-2])\n\
    \        &&\n        std.isNumeric(l[1]);\n        \n}", "{\n    long[] d = {l[0],\
    \ l[1], l[0], l[1]};\n    std.sort(d);\n    return l[0] == d[0] && l[1] == d[1];\n\
    }", "{\n    for(size_t i=1; i<l.size(); i++)\n        if(l[i-1] > l[i])\n    \
    \        return false;\n    return true;\n}", "{\n    for (int i = 0; i < l.length;\
    \ i++) \n    {\n        if (l[i] < l[i - 1]) \n        {\n            return false;\n\
    \        }\n        else if (l[i] > l[i - 1]) \n        {\n            return\
    \ true;\n        }\n    }\n    return true;\n}\n'''", "{\n    bool increasing\
    \ = true;\n    long last = l[0];\n    bool isIncreasing = true;\n    for (int\
    \ i=1; i < l.length; ++i) {\n        long cur = l[i];\n        if (cur != last)\
    \ {\n            isIncreasing = !isIncreasing;\n            last = cur;\n    \
    \    }\n        if (!isIncreasing) break;\n    }\n    return isIncreasing;\n}",
  "{\n    if (l.length<2) return false;\n    int i=0;\n    int j=1;\n    long d=0;\n\
    \    int e=l.length;\n    while (i<e)\n    {\n        if (l[i]<l[j]) d=1;\n  \
    \      else d=-1;\n        if (d!=0) break;\n        i++;\n        j++;\n    }\n\
    \    if (i==e) return true;\n    i=0;\n    j=1;\n    e=l.length;\n    while (i<e)\n\
    \    {\n        if (l[i]<l[j]) d=-1;\n        else d=1;\n        if (d!=0) break;\n\
    \        i++;\n        j++;\n    }\n    if (i==e) return true;\n    else return\
    \ false;\n}\n/*\nReturn true is array elements are monotonically increasing or\
    \ decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L,\
    \ 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n\
    \    \n*/", "{\n    int len = l.length;\n    if (len <= 1) return true;\n    \n\
    \    if (l[0] > l[1]) return true;\n    \n    if (l[len - 1] < l[len - 2]) {\n\
    \        // two consecutive elements\n        if (l[len - 3] < l[len - 4]) return\
    \ true;\n    }\n    return false;\n}\n/* \nReturn array size or maximum size.\n\
    \    >>> arrsize([1L, 2L, 4L, 20L])\n    4\n    >>> arrsize([1L, 20L, 4L, 10L])\n\
    \    10\n    \n*/", "{\n    long[] u = { 0L, 1L, 2L };\n    return monotonic(l,\
    \ u);\n}", "{\n\tint i = 0;\n\tbool isdecreasing = false;\n\tbool isincreasing\
    \ = true;\n\twhile (i < l.Length-1) {\n\t\tif (l[i+1] <= l[i]) {\n\t\t\ti++;\n\
    \t\t\tif (i == l.Length-1) isincreasing = false;\n\t\t\telse isincreasing = true;\n\
    \t\t} else {\n\t\t\ti++;\n\t\t\tif (i == l.Length-1) isdecreasing = false;\n\t\
    \t\telse isdecreasing = true;\n\t\t}\n\t}\n\treturn isdecreasing || isincreasing;\n\
    }", "{\n    return ( l.length() > 1 && l[0] > l[l.length -1]);\n}", "{\n    int\
    \ n = l.Length;\n    if (n<=1)\n        return true;", "{\n    if (l.length==0)\
    \ return false;\n    return std.carrays.issorted(l, l.length);\n}\n#endif", "{\n\
    \tlong i = 1;\n\twhile (i < l.length && l[i-1] <= l[i])\n\t\ti += 1;\n\treturn\
    \ i == l.length;\n}", "{\n    int m1, m2, m3, m4;\n    int i;\n    int j;\n  \
    \  long m;\n    bool r;", "{\n    // The first element must be greater than the\
    \ last\n    long first = l[0];\n    long last = l[l.length-1];\n    // The difference\
    \ between first and last must be greater than zero\n    long diff = first - last;\n\
    \    // If the difference is zero, then the list is monotonically increasing\n\
    \    // or decreasing. \n    if (diff > 0) \n    {\n        return true;\n   \
    \ }\n    // If the first element is greater than the last, \n    // then the list\
    \ is not monotonically increasing. \n    else if (first > last) \n    {\n    \
    \    return false;\n    }\n    // If the first element is less than the last,\
    \ \n    // then the list is not monotonically decreasing. \n    else \n    {\n\
    \        return !((diff < 0) == (l[l.length-2] < l[l.length-1]));\n    }\n}\n\
    </code>\n<|/ a tags=c++,arrays |>\n<| c |>\n: Thanks I fixed it\n<|/ c |>\n<|\
    \ c |>\nYour code does not work for the case `monotonic([1, 2, 3, 5])`.\n<|/ c\
    \ |>\n<| c |>\n: That's a case I did not test for. Your solution also returns\
    \ true for monotonic([1, 2, 3, 5]). I will add an if statement to account for\
    \ that case\n<|/ c |>\n<| c |>\nThis answer is incorrect for monotonic monotonic\
    \ decreasing sequences. For example, monotonic([1, 2, 5, 3]) returns true and\
    \ should not be used.\n<|/ c |>\n<| a tags=c++,arrays |>\nIf you use std::vector\
    \ instead of array, then you can use std::is_sorted.\n<code>\n#include <algorithm>\n\
    #include <vector>", "{\n\tlong min;\n\tlong max;\n\tint i;\n\tfor(i = 0; i < l.length;\
    \ i++){\n\t\tmin = max = l[i];\n\t\tfor(; min < max; min++){\n\t\t\tif(max < min\
    \ + 1) return false;\n\t\t}\n\t\tfor(; max > min; max--){\n\t\t\tif(min > max\
    \ - 1) return false;\n\t\t}\n\t}\n\treturn true;\n}", "{\n\t// first sort (descending)\n\
    \tArrays.sort(l, l.length, (l1, l2) => l2.l - l1.l);\n\t\n\tfor (int i = 0; i\
    \ < l.length - 1; i++) \n\t{\n\t\tif (l[i + 1].l > l[i].l) \n\t\t{\n\t\t\treturn\
    \ false;\n\t\t}\n\t}\n\t\n\treturn true;\n}", "{\n    if(l.length<=1)\n      \
    \  return true;\n    \n    int i=0;\n    long maxvalue=l[0];\n    long minvalue=l[0];\n\
    \    for(long el:l)\n    {\n        if(el>maxvalue)\n            maxvalue=el;\n\
    \        \n        if(el<minvalue)\n            minvalue=el;\n        \n     \
    \   if(el>maxvalue-minvalue)\n            return false;\n    }\n    return true;\n\
    }", "{\n    auto itEnd = l.end();\n    for (auto itBegin = l.begin(); itBegin\
    \ != itEnd; ++itBegin)\n    {\n        auto itCurrent = itBegin + 1; \n      \
    \  if (*itCurrent > *itBegin)\n        {\n            return false;\n        }\n\
    \    }\n    return true;\n}", "{\n  int i = 0;\n  int j = 1;\n  long k = l[0];\n\
    \  long l2 = l[1];\n  long u2 = l2;\n  while((i < l.length) && ((j > 0) && (l[j]\
    \ >= k)))\n  {\n    i++;\n    j++;\n    k = l[i];\n  }\n  while((i < l.length)\
    \ && (l[j] == k))\n  {\n    i++;\n    j++;\n    k = l[i];\n  }\n  while((i < l.length)\
    \ && (l[j] > k))\n  {\n    i++;\n    k = l[i];\n  }\n  while((i < l.length) &&\
    \ (l[j] < k))\n  {\n    j++;\n    k = l[i];\n  }\n  \n  if ((i < l.length) &&\
    \ (l[j] < u2))\n  {\n    return true;\n  }\n  else\n  {\n    return false;\n \
    \ }\n}", "{\n\tif (l.length < 2) return true;", "{\n\tif (l.length==0) return\
    \ true;\n\tif (l[0]<l[1]) return false;\n\treturn (monotonic(l[2:])||l[0]<l[2]);\n\
    }\n/*\nReturn a new array that is an array of monotonically increasing\nor decreasing\
    \ elements with the specified number of elements. \nMonotonic arrays are assumed\
    \ to have non-negative elements.\n    >>> monotonic_with_size([1L, 2L, 4L, 20L],\
    \ 3)\n    [1, 1, 1]\n    >>> monotonic_with_size([1L, 2L, 4L, 20L], 4)\n    [1,\
    \ 2, 4]\n    >>> monotonic_with_size([1L, 2L, 4L, 20L], 1)\n    [1, 2]\n    \n\
    */\nlong[] monotonic_with_size(long[] l, int size_of_array)\n{\n\tint size = (int)size_of_array;\n\
    \tif (l==null) return null;\n\tif (l[0]<l[1]) return new long[size];\n\tif (l[0]<l[2])\
    \ return new long[size];\n\tif (l[0]<l[3]) return new long[size];\n\treturn new\
    \ long[size];\n}\n/*\nReturn a new array that is an array of monotonically increasing\n\
    or decreasing elements with the specified number of elements. \nMonotonic arrays\
    \ are assumed to have non-negative elements.\n    >>> monotonic_with_size([1L,\
    \ 2L, 4L, 20L], 3)\n    [1, 1, 1]\n    >>> monotonic_with_size([1L, 2L, 4L, 20L],\
    \ 4)\n    [1, 2, 4]\n    >>> monotonic_with_size([1L, 2L, 4L, 20L], 1)\n    [1,\
    \ 2]\n    \n*/\nlong[] monotonic_with_size(long[] l, int size_of_array,int max_element)\n\
    {\n\tint size = (int)size_of_array;\n\tif (l==null) return null;\n\tlong max_value\
    \ = (max_element>0?max_element:Integer.MAX_VALUE);\n\tif (max_value>l[0]) return\
    \ new long[size];\n\tif (max_value>l[1]) return new long[size];\n\tif (max_value>l[2])\
    \ return new long[size];\n\tif (max_value>l[3]) return new long[size];\n\treturn\
    \ new long[size];\n}", "{\n\tif (l.length == 0) {\n\t\treturn false;\n\t}\n\t\
    if (l[0] == 0L) {\n\t\treturn false;\n\t}\n\tbool isDecreasing = true;\n\tlong\
    \ first = l[0];\n\tlong last = l[0];\n\tlong curr = l[0];\n\tlong count = 0;\n\
    \tfor (int i = 1; i < l.length; ++i) {\n\t\tlong next = l[i];\n\t\tif (curr <\
    \ last) {\n\t\t\tisDecreasing = false;\n\t\t}\n\t\tif (curr == last && curr <\
    \ next) {\n\t\t\tisDecreasing = true;\n\t\t}\n\t\tlast = curr;\n\t\tcurr = next;\n\
    \t\tcount++;\n\t}\n\tif (count > 0) {\n\t\tisDecreasing = (first < last);\n\t\
    }\n\treturn isDecreasing;\n}\n/*\nReturn true if all array elements are monotonically\
    \ increasing or decreasing.\n    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n\
    \    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L, 1L,\
    \ 0L, -10L])\n    true\n    \n*/", "{\n\tlong first=l[0], last=l[0];\n\tfor (int\
    \ i=1; i<l.length; ++i)\n\t{\n\t\tlong el = l[i];\n\t\tif (el < first) first=el;\n\
    \t\tif (el > last) last=el;\n\t}\n\treturn !((first < last) || (first == last));\n\
    }", "{\n\tif(l.length < 2)\n\t\treturn true;\n\treturn l[1] < l[0];\n}", "{\n\
    \    return monotonic_inverse(monotonic_inverse(l), l);\n}", "{\n\tif  (l == null)\n\
    \t\treturn true;\n\t\n\tint h = 0;\n\tint j = l.length-1;\n\tlong lh = l[0];\n\
    \tlong lj= l[j];\n\tif (lj > lh)\n\t\treturn false;\n\t\n\twhile (j < h.max) {\n\
    \t\tint i = (j + h.min)/2;\n\t\tlong l = l[i];\n\t\tlong lh = l[0];\n\t\tlong\
    \ lj= l[j];\n\t\tif (lj > lh)\n\t\t\treturn false;\n\t\t\n\t\th.min = i;\n\t\t\
    h = i;\n\t\tj = i;\n\t}\n\treturn true;\n}", "{\n    return std.typecons.maxIndex(l)\
    \ == std.typecons.minIndex(l)-1;\n}", "{\n    long l = l.length;\n    int k =\
    \ 0;\n    for(int i = 1; i < l; ++i)\n    {\n        if(l[i] < l[k])\n       \
    \ {\n            return false;\n        }\n        else if(l[i] > l[k])\n    \
    \    {\n            return true;\n        }\n        ++k;\n    }\n    return true;\n\
    }", "{\n    return monotonicAux(l,0,l.length-1);\n}\n/*\nReturn true is array\
    \ elements are monotonically increasing or decreasing.\n    >>> monotonicAux([1L,\
    \ 2L, 4L, 20L], 0, 0)\n    true\n    >>> monotonicAux([1L, 20L, 4L, 10L], 0, 0)\n\
    \    false\n    >>> monotonicAux([4L, 1L, 0L, -10L], 0, 0)\n    true\n    \n*/",
  "{\n   long prev = l[0], current = l[0];\n   for (int i=1; i<l.length; ++i)\n  \
    \ {\n      if (current > prev) \n      {\n         return false;\n      }\n  \
    \    if (l[i] > current)\n      {\n         return false;\n      }\n      prev\
    \ = current;\n      current = l[i];\n   }\n   return true;\n}\n/*\nReturn true\
    \ is array elements are monotonically increasing or decreasing.\n    >>> monotonic([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n\
    \    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/", "{\n    long prev\
    \ = 0;\n    long x = 0;\n    long y = 0;\n    bool decreasing = true;\n    for\
    \ (int i = 0; i < l.length; i++)\n    {\n        if (l[i] < prev)\n        {\n\
    \            if (l[i] < x)\n            {\n                x = l[i];\n       \
    \     }\n            if (l[i] < y)\n            {\n                y = l[i];\n\
    \            }\n        }\n        else\n        {\n            if (l[i] > prev)\n\
    \            {\n                if (l[i] > x)\n                {\n           \
    \         x = l[i];\n                }\n                if (l[i] > y)\n      \
    \          {\n                    y = l[i];\n                }\n            }\n\
    \        }\n        prev = l[i];\n    }\n    return decreasing ? (x > y) : (x\
    \ < y);\n}\n</code>\n<|/ a tags=arrays,c++,performance,algorithm,sorting |>\n\
    <| c |>\nThis doesn't seem to work for the case `monotonic([4L, 1L, 0L, -10L])`.\
    \ What should be returned in this case is `monotonic([4L, 1L, -10L, 0L])` but\
    \ `monotonic([4L, 1L, -10L, 0L], true)` is `false`.\n<|/ c |>\n<| c |>\nThe problem\
    \ is that the input list should _only_ contain negative integers. A sorted array\
    \ could have duplicates, `monotonic([4L, 1L, 0L, -10L], true)` returns `false`.\n\
    <|/ c |>\n<| c |>\nYes, you're right. I didn't think that through. I've edited\
    \ my answer to fix the issue. Thanks for noticing.\n<|/ c |>\n<| c |>\n: This\
    \ is just amazing. I've tested your `monotonic` implementation with negative and\
    \ positive numbers and it works. Thank you.\n<|/ c |>\n<| a tags=arrays,c++,performance,algorithm,sorting\
    \ |>\nIf array is not sorted, you may want to consider using std::lower_bound\
    \ from the algorithms library to find the first element that is greater than the\
    \ one you have. After that you can move the array until you reach the element\
    \ you want.\n<|/ a dscore=0 |>\n<| a dscore=0 tags=arrays,c++,performance,algorithm,sorting\
    \ |>\nOne can use std::set_if to solve this in O(n log n) time, O(n) space, using\
    \ std::greater as the predicate and std::adjacent_find:\n<code>\n#include <iostream>\n\
    #include <iterator>\n#include <algorithm>\n#include <vector>", "{\n\tif (l.length==0)\n\
    \t\treturn true;\n\tif (l[0]>l[1])\n\t\treturn false;\n\tint i=2;\n\tlong prev=l[0];\n\
    \tdo\n\t{\n\t\tif (prev<l[i-1])\n\t\t\treturn false;\n\t\ti++;\n\t\tprev=l[i];\n\
    \t}while(i != l.length-1);\n\treturn true;\n}\n/*\nReturn a slice of a string\
    \ with start and stop indexes and optional step value.\n    >>> \"abcd\"[2:5]\n\
    \    \"bcd\"\n    >>> \"abcd\"[2:]\n    \"bcd\"\n    >>> \"abcd\"[2:5]\n    \"\
    bcd\"\n    >>> \"abcd\"[2:5:2]\n    \"bd\"\n    >>> \"abcd\"[2:5:-1]\n    \"c\"\
    \n*/\nstring slice(string s, int start, int stop, int step)\n{\n\tif (step<0)\n\
    \t\tstep=1;\n\tif (start<0)\n\t\tstart=s.length+start;\n\tif (step>0)\n\t\treturn\
    \ s.substr(start, stop-start+1);\n\telse\n\t\treturn s.substr(start);\n}", "{\n\
    \    // This assumes that l has at least two elements.\n    if(l.length == 0)\
    \ return false;\n    long prev = l[0], current = l[0], change, changePrev, changeNext,\
    \ next, nextPrev, nextNext;\n    \n    for(int i = 1; i < l.length; ++i) \n  \
    \  {\n        next = l[i];\n        \n        if(next > current)\n        {\n\
    \            change = current - prev;\n            changePrev = prev;\n      \
    \      changeNext = next;\n        }\n        else\n        {\n            change\
    \ = next - prev;\n            changePrev = prev;\n            changeNext = current;\n\
    \        }\n        \n        if(change < 0)\n        {\n            change =\
    \ -change;\n            changePrev = -changePrev;\n            changeNext = -changeNext;\n\
    \        }\n        \n        prev = current;\n        current = next;\n     \
    \   \n        if(change == 0)\n        {\n            // Next monotonic increasing\
    \ or decreasing.\n            if(changeNext > changePrev && changeNext <= -changePrev)\n\
    \                return true;\n            \n            // Previous monotonic\
    \ increasing or decreasing.\n            if(changePrev <= changeNext && changePrev\
    \ <= -changeNext)\n                return true;\n            \n            //\
    \ Neither monotonic.\n            return false;\n        }\n    }\n    \n    return\
    \ false;\n}", "{\n    long max = l[0], min = l[0];\n    for(int i = 1; i < l.length;\
    \ i++) \n    {\n        if(l[i] > max) max = l[i];\n        if(l[i] < min) min\
    \ = l[i];\n    }\n    return min < max;\n}", "{\n\t\n    int n = l.length;\n \
    \   int i, j;\n    int min = l[0];\n    int max = l[0];\n    int minval = l[0];\n\
    \    int maxval = l[0];\n    for (i=1; i<n; i++) {\n        int curr = l[i];\n\
    \        if (curr < min) {\n            min = curr;\n        } else if (curr >\
    \ max) {\n            max = curr;\n        }\n        minval = Math.min(minval,\
    \ curr);\n        maxval = Math.max(maxval, curr);\n    }\n    bool isMonotonic\
    \ = true;\n    for (i=1; i<n; i++) {\n        int curr = l[i];\n        if (curr\
    \ < min) {\n            isMonotonic = false;\n            break;\n        } else\
    \ if (curr > max) {\n            isMonotonic = false;\n            break;\n  \
    \      } else if (curr != l[i-1]) {\n            isMonotonic = false;\n      \
    \      break;\n        }\n    }\n    return isMonotonic;\n}\n/*\nReturn a new\
    \ array created by removing all occurrences of element 'e' from the original array.\n\
    \    If the input array is empty, then 'e' is returned.\n    >>> remove([1L, 2L,\
    \ 3L, 1L], 1L)\n    [2L, 3L]\n    >>> remove([1L, 2L, 3L, 1L], 0L)\n    [2L, 3L]\n\
    \    \n*/\nlong[] remove(long[] l, long e) \n{\n    int i;\n    int n = l.length;\n\
    \    long[] ret = new long[n];\n    if (n == 0) {\n        return e;\n    }\n\
    \    for (i=0; i<n; i++) {\n        if (l[i] == e) {\n            ret = removeAt(ret,\
    \ i);\n        }\n    }\n    return ret;\n}\n/*\nReturn a new array created by\
    \ removing all occurrences of element 'e' from the original array.\n    If the\
    \ input array is empty, then 'e' is returned.\n    >>> removeAt([]L, 1L)\n   \
    \ []\n    >>> removeAt([]L, 0L)\n    []\n    \n*/\nlong[] removeAt(long[] l, int\
    \ i) \n{\n    int n = l.length;\n    long[] ret = new long[n];\n    int j = 0;\n\
    \    if (n == 0) {\n        return l;\n    }\n    for (; j<n; j++) {\n       \
    \ if (l[j] == i) {\n            ret = removeAt(ret, j);\n        }\n    }\n  \
    \  return ret;\n}\n/*\nReturn a new array created by removing all occurrences\
    \ of element 'e' from the original array.\n    If the input array is empty, then\
    \ 'e' is returned.\n    >>> removeAll([1L, 2L, 3L, 1L], 1L)\n    [2L, 3L]\n  \
    \  >>> removeAll([1L, 2L, 3L, 1L], 0L)\n    [1L, 2L, 3L]", "{\n\tif(l.length==0)\n\
    \t\treturn true;\n\tint lo=0,hi=l.length-1;\n\tbool s=true;\n\twhile(lo<=hi)\n\
    \t{\n\t\tbool t=s[hi-lo-1];\n\t\tif(t==false)\n\t\t{\n\t\t\ts[hi-lo-1]=true;\n\
    \t\t\tlo++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint mid=(lo+hi)/2;\n\t\t\tt=s[mid-lo-1];\n\
    \t\t\tif(!t)\n\t\t\t\treturn false;\n\t\t\tif(!t)\n\t\t\t\tlo=mid+1;\n\t\t\telse\n\
    \t\t\t\thi=mid-1;\n\t\t}\n\t}\n\treturn true;\n}\n/*\nSum an array in linear time\
    \ O(N).\n    The algorithm uses merge sort.\n*/\nlong sum(int[] a)\n{\n\tint n=a.length;\n\
    \tint lo,hi,k;\n\tlong  sum=0;\n\tif(n<2)\n\t\treturn 0;\n\thi=n-1;\n\tlo=0;\n\
    \tk=0;\n\twhile(k<n && lo<hi)\n\t{\n\t\tif(a[lo]>a[hi])\n\t\t{\n\t\t\tsum+=a[lo++]-a[k++];\n\
    \t\t\tsum+=a[lo++]-a[k++];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum+=a[lo++]-a[k++];\n\
    \t\t}\n\t}\n\twhile(k<n)\n\t{\n\t\tsum+=a[++lo]-a[k++];\n\t}\n\treturn sum;\n\
    }\n/*\nCompute the mean of an array of numbers in linear time O(N).\n    The algorithm\
    \ uses merge sort.\n*/\ndouble mean(int[] a)\n{\n\tdouble sum=sum(a);\n\tdouble\
    \ count=sum;\n\tfor(int i=0;i<a.length;i++)\n\t{\n\t\tsum+=a[i];\n\t\tcount++;\n\
    \t}\n\treturn sum/count;\n}", "{\n    if(l.length == 0)\n        return true;\n\
    \    long first = l[0];\n    int pos = 0;\n    while(pos < l.length-1 && l[pos]\
    \ < first)\n        pos++;\n    return pos == l.length-1;\n}\n/*\nReturn true\
    \ is array elements are monotonically increasing or decreasing.\n    >>> monotonic([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n\
    \    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/", "{\n\tint[] a = argmin(l);\n\
    \tint[] b = argmin(l);\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i]\
    \ < a[a[i]])\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse if(l[i] > b[b[i]])\n\t\
    \t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "{\n    long i = 1;\n\
    \    long last = l[0]; // First element.\n    bool increasing = true;\n    bool\
    \ decreasing = false;\n    while(true)\n    {\n        bool same = true;\n   \
    \     for(size_t j = 0; j < l.size(); j++)\n        {\n            if(l[j] !=\
    \ l[j+1])\n            {\n                same = false;\n                break;\n\
    \            }\n        }\n        if(same)\n            break;\n        increasing\
    \ ^= increasing;\n        decreasing ^= decreasing;\n        last = l[i];\n  \
    \      l[i] = i;\n        i++;\n    }\n    return increasing || decreasing;\n\
    }\n</code>\nEDIT: As pointed out by in the comments, this method has some issues: ",
  "{\n\tuint i = 0;\n\tuint j = 1;\n\tbool result = true;", "{\n\tint i, j, cnt;\n\
    \tbool ret = false;\n\tcnt = count(l);\n\tfor(i=1; i<cnt; i++) {\n\t\tfor(j=i;\
    \ j<cnt; j++) {\n\t\t\tif(!less(l[i], l[j])) {\n\t\t\t\tret = !ret;\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t}\n\t\tif(ret) break;\n\t}\n\treturn ret;\n}", "{\n\tlong\
    \ first = l[0], last = l[0];\n\tint i = 0;\n\tfor(i = 0; i < l.length; ++i)\n\t\
    {\n\t\tbool isIncreasing = last < l[i];\n\t\tlast = l[i];\n\t\tif (!isIncreasing)\n\
    \t\t\treturn false;\n\t}\n\treturn true;\n}\n/*\nReturn true if array elements\
    \ are monotonically increasing or decreasing.\n\tThis assumes monotonic increasing\
    \ values will increase by more than 1 each time.\n    >>> monotonic([1L, 2L, 4L,\
    \ 20L])\n    true\n    >>> monotonic([1L, 20L, 4L, 10L])\n    false\n    >>> monotonic([4L,\
    \ 1L, 0L, -10L])\n    true\n*/", "{\n  if (l.length <= 1) return true;", "{\n\
    \    if (l==null || l.length==0)\n        return true;\n    if (l.length==1)\n\
    \        return true;\n    return std.math.isIncreasing(_montOf(l));\n}", "{\n\
    \treturn std.sort.sort.isSorted(l, \n\t\t\t\t\t\t \tstd.sort.sort.isMonotonic);\n\
    }", "{\n    if (l.length == 0)\n        return true;\n    long first = l[0];\n\
    \    long last = l[0];\n    long minIndex = -1;\n    bool isFirst = true;\n  \
    \  for (int i = 1; i < l.length; ++i) {\n        long curr = l[i];\n        if\
    \ (isFirst) {\n            minIndex = i;\n            isFirst = false;\n     \
    \       last = curr;\n        } else {\n            long diff = curr - last;\n\
    \            if (diff > 0)\n                return false;\n            last =\
    \ curr;\n        }\n    }\n    minIndex = -1;\n    long lastMin = first;\n   \
    \ for (int i = l.length - 1; i >= 0; --i) {\n        long curr = l[i];\n     \
    \   if (last < curr && minIndex == -1) {\n            minIndex = i;\n        \
    \    lastMin = curr;\n        } else {\n            long diff = curr - lastMin;\n\
    \            if (diff > 0)\n                return false;\n            lastMin\
    \ = curr;\n        }\n    }\n    return true;\n}", "{\n  int i;\n  for(i = 1;\
    \ i < l.length; ++i)\n    if(l[i] < l[i-1]) return true;\n  return false;\n}",
  "{\n\tif (l.length < 2)\n\t\treturn false;", "{\n\tlong lmax = l.length - 1;\n\t\
    bool isLarger = true;\n\tbool isSmaller = true;\n\tlong lmin = l[0];\n\tfor (int\
    \ i = 1; i < l.length; i++) {\n\t\tif (lmax == i) {\n\t\t\tisLarger = false;\n\
    \t\t} else if (lmin == i) {\n\t\t\tisSmaller = false;\n\t\t}\n\t\tif (l[i] < lmin)\
    \ lmin = l[i];\n\t\tif (l[i] > lmax) lmax = l[i];\n\t}\n\tif (isLarger) {\n\t\t\
    for (long i = l.length - 2; i >= 0; i--) {\n\t\t\tif (l[i] == lmax - 1) {\n\t\t\
    \t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tif (isSmaller) {\n\
    \t\tfor (long i = l.length - 2; i >= 0; i--) {\n\t\t\tif (l[i] == lmin) {\n\t\t\
    \t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}",
  "{\n  if(l.length<3)\n    return true;\n  long a=l[0];\n  long b=l[1];\n  int i=2;\n\
    \  while (i<l.length&&l[i]>b)\n  {\n    a=b;\n    b=l[i];\n    i++;\n  }\n  if\
    \ (i==l.length&&l[i]==b)\n  {\n    return (a-b)>=0;\n  }\n  a=l[0];\n  b=l[1];\n\
    \  i=2;\n  while (i<l.length&&l[i]<b)\n  {\n    a=b;\n    b=l[i];\n    i++;\n\
    \  }\n  return (a-b)>=0;\n}\n/*\nReturn true is array elements are strictly increasing\
    \ or strictly decreasing.\n    >>> strictly_increasing([2L, 1L, 4L, 20L])\n  \
    \  true\n    >>> strictly_decreasing([2L, 1L, 4L, 20L])\n    false\n    >>> strictly_increasing([4L,\
    \ 1L, 0L, -10L])\n    true\n    \n*/", "{\n\tlong max = l[0];\n\tlong min = l[0];\n\
    \tbool swap;\n\tfor(int i = 1; i < l.length; ++i)\n\t{\n\t\tswap = l[i] > max;\n\
    \t\tmax = l[i] > min ? l[i] : max;\n\t\tmin = l[i] < max ? l[i] : min;\n\t}\n\t\
    return swap ? min > max : min < max;\n}", "{\n\tbool first = false;\n\tbool last\
    \ = true;\n\tint i = 0; // index\n\tlong prevVal = l[i];\n\t\n\twhile(!last &&\
    \ i < l.length) \n\t{\n\t\tif (l[i] == prevVal)\n\t\t{\n\t\t\tlast = false;\n\t\
    \t}\n\t\telse\n\t\t{\n\t\t\tfirst = true;\n\t\t}\n\t\ti++;\n\t\tprevVal = l[i];\n\
    \t}\n\treturn (first == last);\n}", "{\n\tif (l.length <= 1) \n\t\treturn true;\n\
    \tif (l[0] == l[1]) \n\t\treturn false;\n\tdouble m = l[0];\n\tfor (int i = 1;\
    \ i < l.length; i++) {\n\t\tif (l[i] < m && l[i - 1] > m)\n\t\t\treturn false;\n\
    \t\tif (l[i] > m && l[i - 1] < m)\n\t\t\treturn false;\n\t}\n\treturn true;\n\
    }\n/*\nReturn true if the array elements are monotonically increasing or decreasing.\n\
    \    >>> monotonic([1L, 2L, 4L, 20L])\n    true\n    >>> monotonic([1L, 20L, 4L,\
    \ 10L])\n    false\n    >>> monotonic([4L, 1L, 0L, -10L])\n    true\n    \n*/",
  "{\n    long max;\n    if (l.length==0) return true;\n    max = l[0];\n    for (int\
    \ i = 1; i < l.length; ++i)\n        if (l[i] > max) return false;\n    return\
    \ true;\n}", "{\n    int i = 0;\n    int j = l.length - 1;\n    int cmp = 0;\n\
    \    while (i < j) {\n        cmp = l[j] - l[i];\n        if (cmp > 0) {\n   \
    \         i++;\n        } else if (cmp < 0) {\n            j--;\n        } else\
    \ {\n            // l[i] > l[j] or l[i] == l[j]\n            // We are done\n\
    \            break;\n        }\n    }\n    return i == j;\n}\n</code>\n<|/ a tags=sorting,c#,performance\
    \ |>\n<| c |>\nI believe this algorithm is O(n^2), so it's only applicable to\
    \ a small list\n<|/ c |>\n<| c |>\n, can you explain it a bit more? It's a O(n)\
    \ algorithm, and I don't see how it could be O(n^2)?\n<|/ c |>\n<| c |>\nHe pointed\
    \ out that he was using a `while` loop and a `for` loop in the same `for` loop.\
    \ He meant to say that he was using the `while` loop twice and that he was using\
    \ the `for` loop once, where he also used a `for` loop.\n<|/ c |>\n<| c |>\nIt's\
    \ O(n) because it's one loop rather than two, since it's being run n times. The\
    \ while loop isn't being run n times. It's being run once. He also said that he\
    \ had two loops within that one loop, he said that he had two loops when he said\
    \ that he had one loop in the for loop, which he said was O(n).\n<|/ c |>\n<|\
    \ c |>\nBut he also said that the for loop ran n times, which is O(n).\n<|/ c\
    \ |>\n<| a tags=sorting,c#,performance |>\nYou don't need two loops. You need\
    \ to use only one loop and then compare the next element of the array to the previous\
    \ one. If they are equal, continue to the next one. If the difference between\
    \ the current and previous value is greater than 1, break the loop. Otherwise\
    \ the array is sorted.\n<code>", "{\n\tlong prev=0;\n\tbool flag=false;\n\tlong\
    \ mid;\n\t\n\tfor(int i=0;i<l.length-1;i++)\n\t{\n\t\tmid=l[i];\n\t\tif(mid<prev)\n\
    \t\t{\n\t\t\tflag=true;\n\t\t\tbreak;\n\t\t}\n\t\tprev=mid;\n\t}\n\treturn flag;\n\
    }", "{\n    int i;\n    long last;\n    bool up;\n    \n    if (l.length==0) return\
    \ false;\n    last = l[0];\n    up = false;\n    \n    for (i=1; i<l.length; ++i)\
    \ {\n        if (l[i]<last) up=false;\n        else if (l[i]>last) up=true;\n\
    \        else if (up) return false;\n        last=l[i];\n    }\n    return true;\n\
    }", "{\n    long max = l[0], min = l[0], cur;\n    for (int i = 1; i < l.length;\
    \ ++i) {\n        cur = l[i];\n        if (max < cur) {\n            max = cur;\n\
    \        } else if (min > cur) {\n            min = cur;\n        }\n    }\n \
    \   if (max < min) return false;\n    return true;\n}", "{\n    if(l.length ==\
    \ 0)\n        return true;\n    return l[0] > l[l.length-1];\n}", "{\n\tint i\
    \ = 1;\n\tint n = l.length;\n\tbool is_increasing = true;\n\tbool is_decreasing\
    \ = true;\n\tlong min_value = l[0];\n\tlong max_value = l[0];\n\twhile (i<n) {\n\
    \t\tif (l[i] < min_value) min_value = l[i];\n\t\telse if (l[i] > max_value) max_value\
    \ = l[i];\n\t\tif (l[i] < max_value) {\n\t\t\tis_decreasing = false;\n\t\t\tbreak;\n\
    \t\t}\n\t\tif (l[i] > min_value) {\n\t\t\tis_increasing = false;\n\t\t\tbreak;\n\
    \t\t}\n\t\ti++;\n\t}\n\tif (is_increasing) {\n\t\tif (is_decreasing) {\n\t\t\t\
    return true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tif (is_decreasing)\
    \ {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n}", "{\n\
    \    if (l.length <= 1)\n        return true;\n    \n    int pos = 0;\n    long\
    \ last = l[0];\n    for (int i = 1; i < l.length; ++i) {\n        long current\
    \ = l[i];\n        if (current == last) {\n            pos++;\n        } else\
    \ {\n            last = current;\n            pos = 1;\n        }\n    }\n   \
    \ return pos == 1;\n}\n</code>\n<|/ a tags=java,arrays |>\n<| a |>\n<code>\npublic\
    \ class monotonicArr {\n    public boolean isMonotonic(int[] arr) {\n        return\
    \ monotonic(arr, 0, arr.length - 1);\n    }", "{\n    int n = l.length-1;\n  \
    \  return !((n>0 && l[n]<=l[n-1]) || (n==0 && l[0]>=l[1]));\n}\n'''", "{\n   \
    \ long last = l[0];\n    bool first = true;\n    for(int i=1; i<l.length; i++)\
    \ {\n        if (l[i]<last) {\n            if (first) {\n                first\
    \ = false;\n                return true;\n            }\n            else {\n\
    \                return false;\n            }\n        }\n        last = l[i];\n\
    \    }\n    return true;\n}", "{\n  bool first = true;\n  int curr = 1;\n  bool\
    \ curr = true;\n  bool last = true;\n  long previous = l[0];\n  long lastIndex\
    \ = l.length-1;\n  while(curr <= lastIndex){\n    bool next = true;\n    for(int\
    \ i=0; i<l.length; i++){\n      if(l[i] < previous){\n\tnext = false;\n\tbreak;\n\
    \      }\n    }\n    if(next){\n      previous = l[curr];\n      curr++;\n   \
    \   first = false;\n    }else{\n      last = false;\n      curr--;\n    }\n  }\n\
    \  if(first || last){\n    return false;\n  }\n  return true;\n}", "{\n    if\
    \ (l.length == 0)\n        return true;\n    long prev = l[0];\n    for(int i\
    \ = 0; i < l.length - 1; ++i)\n        if (l[i+1] < prev)\n            return\
    \ false;\n        return true;\n}\n</code>\n<|/ a tags=c++,arrays dscore=2 |>\n\
    <| a dscore=2 |>\nThe easiest way is to sort the array first, then check if the\
    \ first and last elements are the same.\n<|/ a tags=c++,arrays |>\n<| a dscore=1\
    \ tags=c++,arrays |>\nA simple approach would be to sort it and then compare the\
    \ first and last elements of the array.\n<code>", "{\n  int n = l.length-1;\n\
    \  \n  if (n <= 0)\n    return false;", "{\n    int j = l.length-1;\n    while\
    \ (j >= 0) {\n        if (l[j] > l[j+1]) return true;\n        else if(l[j] <\
    \ l[j+1]) return false;\n        j--;\n    }\n    return false;\n}\n</code>\n\
    <|/ a tags=algorithm,sorting,arrays,language-agnostic |>\n<| c |>\nWhat does this\
    \ have to do with arrays?\n<|/ c |>\n<| c |>\n`monotonic()` sorts any kind of\
    \ sequence. An array of numbers is just one kind of sequence.\n<|/ c |>\n<| c\
    \ |>\nIt's also pretty inefficient if you're sorting an array of integers. You're\
    \ copying the whole array every time, even when you could just compare two integers\
    \ right away. Also, it's wrong if the array contains any duplicates.\n<|/ c |>\n\
    <| c |>\nYes, it is very inefficient to copy the array for every comparison. But\
    \ it can be improved using binary search. Also it is incorrect if the array contains\
    \ any duplicates. In case you know that the array won't have duplicates, then\
    \ you can use the solution I've posted and it will work fine.\n<|/ c |>\n<| c\
    \ |>\nWhat if the array is sorted in ascending order? It will give wrong result?\n\
    <|/ c |>\n<| a tags=algorithm,sorting,arrays,language-agnostic |>\n<code>", "{\n\
    \  for(int i = 0; i < l.length; i++)\n    if(l[i] > l[i+1]) return true;\n  return\
    \ false;\n}", "{\n\t// check base case\n\tif (l.length==1) return true;\n\t//\
    \ sort array and take the first element as reference\n\tint j=1;\n\tfor (int i\
    \ = 0; i < l.length; ++i) {\n\t\tlong x = l[i];\n\t\tl[i] = l[j];\n\t\tl[j] =\
    \ x;\n\t\t++j;\n\t}\n\t\n\t// find first non-monotonic element\n\tint i=0;\n\t\
    for (; i < l.length; ++i) {\n\t\tlong x = l[i];\n\t\tif (l[i-1] <= x && x <= l[i])\
    \ return false; // no non-monotonic here\n\t}\n\treturn true;\n}\n/*\nReturn a\
    \ new array that is a copy of the original but with a new element appended.\n\
    \    >>> appendElement(1L, []) -> []\n    >>> appendElement(1L, [2L]) -> [2L]\n\
    \    >>> appendElement(1L, [2L, 2L]) -> [2L, 2L, 2L]\n    >>> appendElement(2L,\
    \ [2L, 2L]) -> [2L, 2L, 2L, 2L]\n    \n*/\nlong[] appendElement(long x, long[]\
    \ l) \n{\n\tlong[] result = new long[l.length+1];\n\tSystem.arraycopy(l, 0, result,\
    \ 0, l.length);\n\tresult[l.length] = x;\n\treturn result;\n}", "{\n    int m\
    \ = l.Length;\n    if (m < 1)\n        return false;\n    for (int i = 0; i <\
    \ m - 1; ++i)\n        if (l[i] > l[i + 1])\n            return false;\n    return\
    \ true;\n}", "{\n\tif (l.length < 2)\n\t\treturn true;\n\tint min = l[0];\n\t\
    int max = l[0];\n\tfor (int i = 1; i < l.length; ++i)\n\t{\n\t\tmin = l[i];\n\t\
    \tmax = l[i];\n\t\tif (max < min)\n\t\t{\n\t\t\tif (max > 0)\n\t\t\t\treturn false;\n\
    \t\t\treturn true;\n\t\t}\n\t\tif (max < max)\n\t\t\tmax = l[i];\n\t}\n\treturn\
    \ true;\n}", "{\n    int i=0;\n    int j=1;\n    long temp;\n    while(true)\n\
    \    {\n        if(i>=l.length-1)\n            break;\n        temp = l[i+1];\n\
    \        if(temp<l[i])\n        {\n            return false;\n        }\n    \
    \    j++;\n        i++;\n    }\n    while(true)\n    {\n        if(i<0)\n    \
    \        return true;\n        temp = l[i];\n        if(temp>l[j])\n        {\n\
    \            return false;\n        }\n        j++;\n        i++;\n    }\n}",
  "{\n    long i = 0;\n    long j = 0;\n    bool ans = false;", "{\n    int i,j,k;\n\
    \    long curr = l[0];\n    bool increasing = true;\n    for (i=1; i<l.length;\
    \ i++) {\n        if (curr > l[i]) {\n            increasing = false;\n      \
    \      break;\n        }\n    }\n    for (j=1; j<l.length; j++) {\n        if\
    \ (l[j-1] < curr) {\n            increasing = false;\n            break;\n   \
    \     }\n    }\n    for (k=0; k<l.length; k++) {\n        if (l[k-1] > curr) {\n\
    \            increasing = false;\n            break;\n        }\n    }\n    return\
    \ increasing;\n}\n</code>\n<|/ a tags=stl,c++ |>\n<| c |>\nNice solution, just\
    \ be careful that you test the condition `j < i` rather than `j >= i` in the second\
    \ for loop. Otherwise you get false positives such as `monotonic([10, 9, 1])`\n\
    <|/ c |>\n<| c |>\nI see your point. Thank you!\n<|/ c |>\n<| a dscore=4 |>\n\
    This is not really an answer, but a suggestion...\nThe data structure that comes\
    \ to mind for doing something like this would be a binary tree.  Specifically,\
    \ a red-black tree for binary trees.  In any binary tree, the left and right branches\
    \ of the root node will always have the same color as the root node.  Any time\
    \ the root node is changed color, the entire tree is unbalanced.  In a red-black\
    \ tree, the minimum number of colors that is required to achieve balanced tree\
    \ is 2.  \nYou can easily see that there are two coloring properties for a red-black\
    \ tree.  The root color is always the minimum color that is needed to ensure that\
    \ the tree is balanced.  Anytime a change is made to any node's color, the entire\
    \ tree is unbalanced.  So, you can easily write a function that will test if your\
    \ binary tree is balanced or not.\n<code>", "{\n    std.sort(l, std.greaterLong);\n\
    \    return !std.is_empty(l.slice(0, l.length-1));\n}\n\"\"\")\n    \n    \n \
    \   def _is_monotonic(self, l, cmp):\n        # NOTE: this isn't very efficient:\
    \ we sort a copy of\n        # l. \n        # But that's ok, we'll just have to\
    \ deal with the O(n^2)\n        # runtime of sorting a copy. \n        # So we\
    \ sort the copy as we go along, then \n        # we'll only ever have to look\
    \ at each element once.\n        \n        std.sort(l, cmp)\n        \n      \
    \  has_last_element = std.is_empty(l[:-1])\n        \n        # first element\
    \ is increasing\n        is_increasing = True\n        \n        for i in range(1,\
    \ len(l)):\n            this_val = l[i]\n            next_val = l[i+1]\n     \
    \       \n            if has_last_element:\n                if this_val != next_val:\n\
    \                    # not monotonic if last element is not increasing\n     \
    \               return False\n            else:\n                if this_val >\
    \ next_val:\n                    # not monotonic if last element is not increasing\n\
    \                    return False\n                    \n            has_last_element\
    \ = True\n            \n        return is_increasing\n    \n    \n    def _is_monotonic(self,\
    \ l, cmp):\n        # NOTE: this isn't very efficient: we sort a copy of\n   \
    \     # l. \n        # But that's ok, we'll just have to deal with the O(n^2)\n\
    \        # runtime of sorting a copy. \n        # So we sort the copy as we go\
    \ along, then \n        # we'll only ever have to look at each element once.\n\
    \        \n        std.sort(l, cmp)\n        \n        has_last_element = std.is_empty(l[:-1])\n\
    \        \n        # first element is increasing\n        is_increasing = True\n\
    \        \n        for i in range(1, len(l)):\n            this_val = l[i]\n \
    \           next_val = l[i+1]\n            \n            if has_last_element:\n\
    \                if this_val != next_val:\n                    # not monotonic\
    \ if last element is not increasing\n                    return False\n      \
    \      else:\n                if this_val > next_val:\n                    # not\
    \ monotonic if last element is not increasing\n                    return False\n\
    \                    \n            has_last_element = True\n            \n   \
    \     return is_increasing\n    \n    \n    def _is_monotonic(self, l, cmp):\n\
    \        # NOTE: this isn't very efficient: we sort a copy of\n        # l. \n\
    \        # But that's ok, we'll just have to deal with the O(n^2)\n        # runtime\
    \ of sorting a copy. \n        # So we sort the copy as we go along, then \n \
    \       # we'll only ever have to look at each element once.\n", "{\n    if (l.length\
    \ == 0)\n    {\n        return true;\n    }", "{\n  int n = l.Length;\n  if (n<2L)\
    \ return true; // empty array is monotonic\n  if (n==2L) return (compare(l[0],l[1])<0L);\n\
    \  long prev = l[0];\n  long x0 = l[1];\n  for (int i=2L; i<n; i++) {\n    long\
    \ x = l[i];\n    if (x<prev) {\n      if (x<x0) return false;\n    }\n    else\
    \ if (x>prev) {\n      return true;\n    }\n    prev=x;\n  }\n  long x1 = l[n-1];\n\
    \  return (compare(x0,x1)>0L);\n}", "{\n\tlong min = l[0];\n\tlong max = l[0];",
  "{\n\tlong min_value = l[0], max_value = l[0];\n\tbool result = true;\n\tfor(long\
    \ i=1; i<l.length; i++)\n\t{\n\t\tlong v = l[i];\n\t\tresult = result && (v >\
    \ max_value) || (v < min_value);\n\t\tmin_value = Math.min(min_value, v);\n\t\t\
    max_value = Math.max(max_value, v);\n\t}\n\treturn result;\n}", "{\n    ulong\
    \ count = 0;\n    ulong min = 0;\n    ulong max = l[0]; // first element is always\
    \ the largest", "{\n\tlong l = l[0];\n\tfor (int i = 1; i < l.length; i++)\n\t\
    {\n\t\tif (l[i] < l)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tl = l[i];\n\t}\n\t\
    return true;\n}", "{\n  long max= l[0];\n  long min= l[0];\n  for( int i=1; i<l.length;\
    \ i++ ) {\n    if ( l[i] < min ) min= l[i];\n    if ( l[i] > max ) max= l[i];\n\
    \  }\n  return ( min < max );\n}\n'''\n    ", "{\n    long last=l[0], next=l[1];\n\
    \    bool is_increasing = true;\n    bool is_decreasing = true;\n    for (long\
    \ i=2; i<l.length; ++i)\n    {\n        long a = last;\n        long b = next;\n\
    \        // if the array is decreasing, the min of next and last must be < a\n\
    \        if (is_decreasing) {\n            if (a > b) {\n                is_decreasing\
    \ = false;\n            }\n            // if the array is increasing, the max\
    \ of next and last must be > a\n        } else {\n            if (a < b) {\n \
    \               is_increasing = false;\n            }\n        }\n        last\
    \ = next;\n        next = l[i];\n    }\n    return is_increasing || is_decreasing;\n\
    }", "{\n    long first  = l[0];\n    long last = l[0];\n    bool flag = true;\n\
    \    for (int i = 1; i < l.length; ++i) {\n        if (l[i] < last) {\n      \
    \      last = l[i];\n        } else {\n            if (flag) {\n             \
    \   flag = false;\n                return false;\n            }\n        }\n \
    \   }\n    return flag;\n}\n</code>\n<|/ a dscore=3 tags=c#,algorithm |>\n<| c\
    \ |>\nYou don't need a second variable here, `last` already holds the most recent\
    \ value.\n<|/ c |>\n<| c |>\n: Yes, you are right. The variable last is not necessary\
    \ for the algorithm.\n<|/ c |>\n<| a |>\nAnother solution, with different time\
    \ complexity (O(n^2) vs O(n)). Here we have to use extra array. \n<code>\nprivate\
    \ static bool IsMonotonic(List<long> list)\n{\n    if (list == null || list.Count\
    \ < 2)\n    {\n        return false;\n    }", "{\n    long prev = 0;\n    long\
    \ curr;\n    long min = l[0];\n    long max = l[0];\n    int imax;\n    int j;\n\
    \    for (imax = 0; imax < l.length; imax++) {\n        curr = l[imax];\n    \
    \    for (j = imax; j > 0; j--) {\n            if (l[j - 1] > curr) break;\n \
    \           prev = curr;\n            curr = l[j - 1];\n        }\n        max\
    \ = l[imax - 1];\n        if (max < prev) {\n            max = prev;\n       \
    \ }\n        if (min > curr) {\n            min = curr;\n        }\n    }\n  \
    \  return !std.compareLong(max, min);\n}", "{\n\tbool res = false;\n\tfor (int\
    \ i = 0; i < l.length; ++i)\n\t\tfor (int j = i; j < l.length; ++j)\n\t\t\tif\
    \ (l[i] < l[j] && l[j] != 0) {\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\t}\n\
    \treturn res;\n}\n\"\"\")", "{\n    for(long i=0;i<l.length;i++) \n    {\n   \
    \     if (l[i]>l[i-1]) return true;\n        if (l[i]<l[i-1]) return false;\n\
    \    }\n    return false;\n}", "{\n  if (l.length == 0)\n    return true;\n  long\
    \ m = l[0];\n  for (int i=1; i<l.length; ++i) {\n    long cur = l[i];\n    if\
    \ (cur > m)\n      return false;\n    m = cur;\n  }\n  return true;\n}", "{\n\t\
    if (l.length <= 1) return false;\n\tlong min = l[0];\n\tlong max = l[0];\n\tfor\
    \ (long i : l) {\n\t\tif (i < min)\n\t\t\tmin = i;\n\t\tif (i > max)\n\t\t\tmax\
    \ = i;\n\t}\n\treturn max < min;\n}", "{\n    long long max = l[0];\n    bool\
    \ result = true;\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ > max)\n        {\n            max = l[i];\n            result = false;\n  \
    \      }\n    }\n    return result;\n}\n/*\nReturn true if array elements are\
    \ all unique\n    >>> unique([0, 2, 2, 3, 5])\n    true\n    >>> unique([1, 1,\
    \ 3])\n    false\n    \n*/", "{\n    if(l.length==0) return false;\n    int x0\
    \ = l[0], x1 = l[1], x_next = x0;\n    int x0_1 = x0, x1_1 = x1;\n    while(true)\n\
    \    {\n        bool x0_diff = x0_1 > x1;\n        bool x1_diff = x1_1 > x0;\n\
    \        if(x0_diff!=x1_diff)\n        {\n            return (x0_diff || x1_diff);\n\
    \        }\n        x_next = (x_next + 1) % 10;\n        if(x0 == l[x_next]) return\
    \ true;\n        x0 = x0_1;\n        x1 = x1_1;\n        x0_1 = x1;\n        x1_1\
    \ = x_next;\n    }\n    return false;\n}\n</code>\n<|/ a |>\n<| c |>\nWhile this\
    \ code may answer the question, providing additional context regarding how and/or\
    \ why it solves the problem would improve the answer's long-term value.\n<|/ c\
    \ |>\n<| c |>\nThank you for the feedback :)\n<|/ c |>\n<| a tags=arrays,java,sorting\
    \ dscore=1 |>\nThe idea is to use a single array to store the values and compare\
    \ the values in two for loops.\n<code>\npublic class Test {\n  public static void\
    \ main(String[] args) {\n    int[] array = {-4,3,5,1,6,2,7,8,9};\n    Arrays.sort(array);\n\
    \    boolean first = true;", "{\n    int min = long.MAX_VALUE;\n    int max =\
    \ long.MIN_VALUE;\n    for (int i = 0; i < l.length; i++)\n    {\n        if (l[i]\
    \ > max)\n            max = l[i];\n        else if (l[i] < min)\n            min\
    \ = l[i];\n    }\n    return min <= max;\n}", "{\n    long i = 0;\n    long j\
    \ = l.length - 1;", "{\n  long min=0;\n  long max = l[l.length-1];\n  for(int\
    \ i=0; i<l.length-1; i++)\n  {\n    if(l[i]<min)\n    {\n      min=l[i];\n   \
    \ }\n    if(l[i]>max)\n    {\n      max=l[i];\n    }\n  }\n  return max<=min;\n\
    }", "{\n    if (l.length < 2) \n\t{\n\treturn true;\n\t}", "{\n    long maxix\
    \ = 0, minix = l[0] - 1;\n    for (int i = 1; i < l.length; ++i) {\n        if\
    \ (l[i] > l[maxix]) {\n            maxix = i;\n        }\n        if (l[i] < l[minix])\
    \ {\n            minix = i;\n        }\n    }\n    return (l[maxix] < l[minix]);\n\
    }\n</code>\n<|/ a tags=c#,sorting,arrays,algorithm dscore=4 |>\n<| c |>\n`Array.IndexOf`\
    \ will give you `-1` for the first element of the array and it will also give\
    \ you `-1` for the last element of the array, so you don't need to check for `-1`\
    \ before using it.\n<|/ c |>\n<| c |>\nThe first answer was correct. But the others\
    \ have a good point. The answer below is better.\n<|/ c |>\n<| c |>\nThe first\
    \ answer assumes monotonicity but that is not the case in the examples in question\
    \ 2. Also, this answer doesn't use any sorting algorithm so it is slower than\
    \ other answers.\n<|/ c |>\n<| c |>\nWhy does it assume monotonicity? The question\
    \ clearly states that `1 2 3 4` should return `false`.\n<|/ c |>\n<| c |>\nIt\
    \ does, because in all those examples the elements are monotonically increasing\
    \ or decreasing. Only the second example is `1 20 4 10` which returns `true`.\n\
    <|/ c |>\n<| a dscore=4 |>\nThis will return true if the array is sorted and false\
    \ if not:\n<code>", "{\n\tlong prev = 0;\n\tlong curr = 1;", "{\n\tif (l.length\
    \ < 2) return false;\n\tbool increasing = true;\n\tfor (int i = 0; i < l.length\
    \ - 1; ++i) {\n\t\tif (l[i] > l[i + 1]) increasing = false;\n\t}\n\treturn increasing;\n\
    }", "{\n\tlong i, j, k, l;\n\tfor (i=1; i<l.length; ++i)\n\t{\n\t\tj = i;\n\t\t\
    k = i;\n\t\twhile (j > 0 && l[j-1] > l[j])\n\t\t{\n\t\t\tl[k] = l[j-1];\n\t\t\t\
    j--;\n\t\t\tk--;\n\t\t}\n\t\tif (j == 0)\n\t\t{\n\t\t\tl[k+1] = l[i];\n\t\t}\n\
    \t}\n\tl = l;\n\tif (l.length == 0)\n\t{\n\t\treturn true;\n\t}\n\tfor (int i\
    \ = l.length-1; i > 0; --i)\n\t{\n\t\tk = i;\n\t\tl = i;\n\t\twhile (l > 0 &&\
    \ l[l - 1] > l[l])\n\t\t{\n\t\t\tl--; \n\t\t\tk--;\n\t\t}\n\t\tif (l == 0)\n\t\
    \t{\n\t\t\tl++;\n\t\t}\n\t\tif (l-1 == k || l-1 == k-1)\n\t\t{\n\t\t\treturn false;\n\
    \t\t}\n\t}\n\treturn true;\n}", "{\n    int i=0;\n    for(; i < l.length; i++)\
    \ \n    {\n        if(l[i] <= l[i+1]) return false;\n    }\n    return true;\n\
    }", "{\n    for(int i=0; i < l.length-1; i++)\n    {\n        if(l[i] >= l[i+1])\n\
    \            return false;\n    }\n    return true;\n}", "{\n  if (l.length <\
    \ 2) \n    return false;\n  var first=l[0];\n  var last=l[l.length-1];\n  return\
    \ isZero(first - last);\n}", "{\n\tlong last = l[0];\n\tfor (int i = 1; i < l.length;\
    \ i++) {\n\t\tif (l[i] < last) {\n\t\t\treturn false;\n\t\t}\n\t\tlast = l[i];\n\
    \t}\n\treturn true;\n}", "{\n    int low = l[0];\n    int high = l[0];\n    int\
    \ i;\n    for(i=1; i<l.length; ++i) {\n        long ll = l[i];\n        if(ll>high)\
    \ return false;\n        if(ll<low) return false;\n        high = ll;\n    }\n\
    \    return true;\n}", "{\n    long long first = l[0];\n    long long last = l[0];\n\
    \    for (long i = 1; i < l.length; i++) {\n        if (l[i] < last) {\n     \
    \       return false;\n        } else if (l[i] > first) {\n            return\
    \ false;\n        }\n        last = l[i];\n    }\n    return true;\n}\n/*\nReturn\
    \ true if the array is sorted from low to high.\n    >>> monotonicSorted([1L,\
    \ 2L, 4L, 20L])\n    true\n    >>> monotonicSorted([1L, 20L, 4L, 10L])\n    false\n\
    \    >>> monotonicSorted([4L, 1L, 0L, -10L])\n    true\n    \n*/", "{\n    for(var\
    \ i=0;i<l.length-1;i++) \n        if(l[i+1]<l[i]) return false;\n    return true;\n\
    }", "{\n    long prev = l[0];\n    long curr = l[0];\n    for(long i = 1; i <\
    \ l.length; ++i)\n    {\n        long next = l[i];\n        if(next < prev)\n\
    \            return true;\n        else if(next > curr)\n            return false;\n\
    \        prev = next;\n        curr = next;\n    }\n    return true;\n}", "{\n\
    \    if (l.length < 2) return false;\n    long last = l[0];\n    for (long i =\
    \ 1, j = l[1]; i <= l.length; i++, j++) {\n        if (l[i] > last || l[j] < last)\n\
    \            return false;\n        last = l[i];\n    }\n    return true;\n}",
  "{\n    long lo = l[0];\n    long hi = l[1];\n    if (lo < hi) {\n        long m\
    \ = lo + ((hi - lo) >> 1);\n        if (m == lo) {\n            return false;\n\
    \        }\n        if (m > hi) {\n            return true;\n        }\n     \
    \   \n        while (m < hi) {\n            m += m;\n            if (m == hi)\
    \ {\n                return false;\n            }\n        }\n        \n     \
    \   return true;\n    }\n    return false;\n}", "{\n    int min = l[0];\n    int\
    \ max = l[0];\n    int minIndex = 0;\n    int maxIndex = 0;\n    for (int i=1;\
    \ i<l.length; i++) {\n        if (l[i] < min) {\n            min = l[i];\n   \
    \         minIndex = i;\n        }\n        if (l[i] > max) {\n            max\
    \ = l[i];\n            maxIndex = i;\n        }\n    }\n    if (maxIndex-minIndex\
    \ > 1) {\n        return true;\n    } else {\n        return false;\n    }\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
