name: HumanEval_14_all_prefixes
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Return array of all prefixes\
  \ from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n\
  \    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string) \n"
tests: "unittest\n{\n    alias candidate = all_prefixes;\n\n    assert(candidate(\"\
  \") == []);\n    assert(candidate(\"asdfgh\") == [\"a\", \"as\", \"asd\", \"asdf\"\
  , \"asdfg\", \"asdfgh\"]);\n    assert(candidate(\"WWW\") == [\"W\", \"WW\", \"\
  WWW\"]);\n}\nvoid main(){}"
completions: ["{\n\tint[]  prefixes = (int[]) std.typecons.array(int[string.size()],\
    \ 0);\n\tint     i;\n\t\n\tfor (i = 0; i < string.size(); ++i) \n\t\tprefixes[i]\
    \ = 0;", "{\n  int n = string.Length;\n  if (n == 0) \n  {\n    return null;\n\
    \  }\n  string[] ret = new string[n];\n  for (int i = 0; i < n; ++i)\n  {\n  \
    \  ret[i] = string.Substring(0, i);\n  }\n  return ret;\n}\n/*\n Return array\
    \ of all suffixes from shortest to longest of the input string\n    >>> all_suffixes(\"\
    abc\")\n    [\"ab\", \"bc\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string)\
    \ \n{\n  int n = string.Length;\n  if (n == 0) \n  {\n    return null;\n  }\n\
    \  string[] ret = new string[n];\n  for (int i = 0; i < n; ++i)\n  {\n    ret[i]\
    \ = string.Substring(i);\n  }\n  return ret;\n}\n/*\n Return array of all substrings\
    \ from shortest to longest of the input string\n    >>> all_substrings(\"abc\"\
    )\n    [\"a\", \"ab\", \"abc\", \"ac\", \"b\", \"bc\", \"c\", \"ca\", \"cb\",\
    \ \"cc\"]\n    \n*/\nstring[] all_substrings(string string) \n{\n  int n = string.Length;\n\
    \  if (n == 0) \n  {\n    return null;\n  }\n  string[] ret = new string[n];\n\
    \  for (int i = 0; i < n; ++i)\n  {\n    ret[i] = string.Substring(0, i);\n  }\n\
    \  return ret;\n}", "{\n    string s = string;\n    string res = \"\";\n    int\
    \ length = s.length();\n    \n    for (int i = 0; i < length; i++) {\n       \
    \ res += s[i];\n    }\n    \n    int result = 0;\n    \n    for(int i = 0; i <\
    \ length; i++)\n    {\n        result += (int)s[i];\n        result *= (int)Math.Pow(2,\
    \ i);\n    }\n    \n    \n    int result2 = 0;\n    for (int i = length - 1; i\
    \ >= 0; i--) {\n        result2 = (int)s[length - i];\n        result2 *= (int)Math.Pow(2,\
    \ i);\n        result += result2;\n    }\n    \n    \n    return s.Substring(0,\
    \ (int)result) + res;\n}\n/*\n Return array of all suffixes from shortest to longest\
    \ of the input string\n    >>> all_suffixes(\"abc\")\n    [\"b\", \"bc\", \"c\"\
    ]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    string s = string;\n\
    \    string res = \"\";\n    int length = s.length();\n    \n    for (int i =\
    \ length - 1; i >= 0; i--) {\n        res += s[length - i];\n    }\n    \n   \
    \ int result = 0;\n    \n    for(int i = 0; i < length; i++)\n    {\n        result\
    \ += (int)s[length - i];\n        result *= (int)Math.Pow(2, i);\n    }\n    \n\
    \    \n    int result2 = 0;\n    for (int i = 0; i < length; i++) {\n        result2\
    \ = (int)s[i];\n        result2 *= (int)Math.Pow(2, i);\n        result += result2;\n\
    \    }\n    \n    \n    return s.Substring(0, (int)result) + res;\n}\n/*\n Return\
    \ array of all substring with length from shortest to longest of the input string\n\
    \    >>> all_substrings(\"abc\")\n    [\"abc\"]\n    \n*/\nstring[] all_substrings(string\
    \ string) \n{\n    string s = string;\n    string res = \"\";\n    int length\
    \ = s.length();\n    \n    for (int i = 0; i < length; i++) {\n        res +=\
    \ s.Substring(i, 1);\n    }\n    \n    int result = 0;\n    \n    for(int i =\
    \ 0; i < length; i++)\n    {\n        result += (int)s[i];\n        result *=\
    \ (int)Math.Pow(2, i);\n    }\n    \n    \n    int result2 = 0;\n    for (int\
    \ i = length - 1; i >= 0; i--) {\n        result2 = (int)s[length - i];\n    \
    \    result2 *= (int)Math.Pow(2, i);\n        result += result2;\n    }\n    \n\
    \    \n    return s.Substring(0, (int)result) + res;\n}\n/*\n Return array of\
    \ all substring with length from shortest to longest of the input string\n   \
    \ >>> all_substrings(\"abc\")\n    [\"abc\"]\n    \n*/\nstring[] all_substrings_len(string\
    \ string, int length) \n{\n    string s = string;\n    string res = \"\";", "{\n\
    \tif (string.empty()) return new[] {\"\"};\n\t\n\t// Build prefix tree\n\tTrie*\
    \ trie = new Trie();\n\tfor (int i = 0; i < (int)(string.size()); i++) {\n\t\t\
    string prefix = string.substr(0, i);\n\t\tstring str = string.substr(i);\n\t\t\
    trie->insert(prefix.size() == 0, prefix, str);\n\t}\n\t\n\t// Find all prefixes\
    \ using depth first search\n\tqueue<string> prefixes = new();\n\ttrie.depthFirstTraversal(prefixes.push,\
    \ false);\n\t\n\tstring[] result = new string[prefixes.size()];\n\tint i = 0;\n\
    \tforeach (string prefix, string[] strs) \n\t{\n\t\tresult[i++] = prefix;\n\t\
    }\n\t\n\treturn result;\n}", "{\n int i = 1;\n int len = string.length();\n int\
    \ lenMax = len;\n string[] ans = new string[lenMax];\n while(i < len) \n {\n \
    \ if(string[i] == string[0]) \n  {\n   ans[len - i] = string[i];\n   lenMax =\
    \ len - i;\n  }\n  else \n  {\n   ans[len - i - 1] = string[i];\n  }\n  i++;\n\
    \ }\n return ans;\n}", "{\n    string[] allPre = new string[string.size()+1];\n\
    \    int i=0;\n    while (i < string.size()) \n    {\n        allPre[i] = string[i];\n\
    \        i = i + 1;\n    }\n    allPre[string.size()] = \"\";\n    return allPre;\n\
    }\n</code>\n<|/ a tags=string,arrays,c++ |>\n<| c |>\nThis isn't valid C++\n<|/\
    \ c |>\n<| c |>\n- It compiles just fine in VC++ 2012 and g++ (Ubuntu 8.1.0-5ubuntu12)\
    \ 5.2.0 .\n<|/ c |>\n<| c |>\nYou still need to import `string`\n<|/ c |>\n<|\
    \ c |>\n- Yes, I did import it.\n<|/ c |>\n<| a tags=string,arrays,c++ |>\n<code>\n\
    #include <iostream>\n#include <string>", "{\n  return map(string.length, \n  \
    \          compose(range(0,string.length), \n                    map(string[string.length-1].length),\
    \ \n                    compose(range(0,string.length-1), \n                 \
    \           map(string[string.length-1][string.length-1]), \n                \
    \            map(string[string.length-1]), \n                            map(string[string.length],\
    \ string[string.length-1].concat(string[string.length]), string)));\n}", "{\n\t\
    int[] result = new int[string.length];\n\tfor(int i = 0; i < string.length; ++i)\
    \ \n\t{\n\t\tint j = i;\n\t\twhile(j > 0 && string.charAt(j) != string.charAt(j-1))\
    \ --j;\n\t\tresult[i] = j;\n\t}\n\treturn std.array.toArray(result);\n}\n/*\n\
    \ Return array of all prefixes from longest to shortest of the input string\n\
    \    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[]\
    \ all_prefixes(string string) \n{\n\tint[] result = new int[string.length];\n\t\
    for(int i = 0; i < string.length; ++i) \n\t{\n\t\tint j = i;\n\t\twhile(j > 0\
    \ && string.charAt(j) != string.charAt(j-1)) --j;\n\t\tresult[i] = j;\n\t}\n\t\
    return std.array.toArray(result);\n}", "{\n    var result = new array<string>(string.length);\n\
    \    \n    for (ulong i = 0ul; i < string.length; i++) \n    {\n        result[i]\
    \ = string[string.len() - i - 1];\n    }\n    \n    string[] result = new array<string>(string.length);\n\
    \    \n    for (ulong i = 0ul; i < string.length; i++) \n    {\n        result[i]\
    \ = string[string.len() - i - 1];\n    }\n    \n    return result;\n}", "{\n \
    \   int length = get_length(string);\n    string[] result = new string[length];\n\
    \    int current_index = 0;\n    for(int i = 0; i < length; ++i)\n        result[i]\
    \ = string[i];\n    while(true)\n    {\n        ++current_index;\n        for(int\
    \ i = current_index; i < length; ++i)\n            result[i] = string[i] + result[i\
    \ - current_index];\n        if(current_index == length) break;\n    }\n    return\
    \ result;\n}", "{\n    int n = string.length();\n    \n    string[] result = new\
    \ string[n];\n    for (int i = n - 1; i >= 0; --i)\n    {\n        result[i] =\
    \ string.Substring(0, i);\n    }\n    \n    return result;\n}", "{\n    string\
    \ prefix = string;\n    string[] array = new string[256];\n    array[0] = prefix;\n\
    \    int i = 0;\n    while (i < 256) {\n        string temp = prefix + string[i]\
    \ + string[i + 1];\n        array[i] = temp;\n        i++;\n    }\n    return\
    \ array;\n}", "{\n    string[] result;\n    int len = string.Length;\n    int\
    \ pos = 0;\n    char[] chars = string.ToCharArray();\n    \n    result = (string[])Array.CreateInstance(typeof(string),\
    \ 1);\n    result[0] = \"null\";\n    \n    for (int i = 0; i <= len; i++) {\n\
    \        pos = i;\n        \n        for (int j = i; j < len; j++) {\n       \
    \     if (chars[j] == chars[i]) \n                pos++;\n            \n     \
    \       result[pos] = string.Substring(i, pos - i);\n            i = j;\n    \
    \        \n            break;\n        }\n        \n        \n        if (i !=\
    \ len) \n            result[pos] = string.Substring(i, len - i);\n    }\n    \n\
    \    return result;\n}", "{\n    string[] result = new string[string.length()];\n\
    \    \n    int max = 0;\n    \n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        if(string[i].length() > max)\n        {\n            max = string[i].length();\n\
    \        }\n    }\n    \n    for(int i = 0; i < string.length(); i++)\n    {\n\
    \        if(string[i].length() >= max)\n        {\n            result[i - max]\
    \ = string[i];\n        }\n    }\n    return result;\n}", "{\n    if(string.Length\
    \ == 0) return new string[0];\n    var result = new string[string.Length];\n \
    \   for(int i = 0; i < string.Length; i++)\n    {\n        result[i] = string[0]+string.Substring(1);\n\
    \    }\n    return result;\n}", "{\n\tvar prefixes = new string[string.length];\n\
    \tfor( int i = 0; i <= string.length; ++i ) {\n\t\tprefixes[i] = string.Substring(0,i);\n\
    \t}\n\t\n\treturn prefixes;\n}\n/*\n Return array of all suffixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"bc\",\
    \ \"c\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n\tvar suffixes =\
    \ new string[string.length];\n\tfor( int i = string.length; i >= 0; --i ) {\n\t\
    \tsuffixes[i] = string.Substring(i);\n\t}\n\t\n\treturn suffixes;\n}\n/*\n Return\
    \ array of all substring matches from shortest to longest of the input string\n\
    \    >>> all_substrings(\"abc\")\n    [[\"ab\", \"ac\", \"bc\"]]\n    \n*/\nlist<string[]>\
    \ all_substrings(string string) \n{\n\tvar substrings = new list<string[]>();\n\
    \tfor( int i = 0; i <= string.length; ++i ) {\n\t\tstring substr = string.Substring(0,i);\n\
    \t\tstring match = string.Substring(i);\n\t\t\n\t\tif( match.Length < substr.Length\
    \ ) {\n\t\t\tsubstrings.add(new string[] { substr, match } );\n\t\t}\n\t}\n\t\
    return substrings;\n}\n/*\n Return array of all word matches from shortest to\
    \ longest of the input string\n    >>> all_words(\"abc def\")\n    [[\"ab\", \"\
    cd\", \"ef\", \"gh\"]]\n    \n*/\nlist<string[]> all_words(string string) \n{\n\
    \tvar words = new list<string[]>();\n\tvar words = all_substrings(string);\n\t\
    \n\tforeach( var subset in words ) {\n\t\tvar substrings = subset;\n\t\t\n\t\t\
    foreach( var substring in substrings ) {\n\t\t\tvar match = substring;\n\t\t\t\
    \n\t\t\tif( substring.Length > match.Length ) {\n\t\t\t\tsubstring += match.Substring(0,substring.Length-match.Length);\n\
    \t\t\t\t\n\t\t\t\tsubstrings.Remove(substring);\n\t\t\t\tsubstrings.Add(new string[]\
    \ { substring, match } );\n\t\t\t}\n\t\t}\n\t\t\n\t\tforeach( var subset in substrings\
    \ ) {\n\t\t\tforeach( var substring in subset ) {\n\t\t\t\tvar match = substring;\n\
    \t\t\t\t\n\t\t\t\tif( substring.Length > match.Length ) {\n\t\t\t\t\tsubstring\
    \ += match.Substring(0,substring.Length-match.Length);\n\t\t\t\t\t\n\t\t\t\t\t\
    substrings.Remove(substring);\n\t\t\t\t\tsubstrings.Add(new string[] { substring,\
    \ match } );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n", "{\n  string[] prefixes = new\
    \ string[string.length];\n  \n  for (int i = 0; i < string.length; i++)\n  {\n\
    \    string a = string.Substring(0,i);\n    string b = string.Substring(i);\n\
    \    prefixes[i] = a+b;\n  }\n  return prefixes;\n}", "{\n    int length = string.Length;\n\
    \    string[] prefixes = new string[length];\n    \n    int i = 0;\n    while\
    \ (i < length) \n    {\n        prefixes[i++] = string.Substring(0, i);\n    }\n\
    \    \n    return prefixes;\n}\n/*\n Return array of all prefixes from shortest\
    \ to longest of the input string\n    >>> all_prefixes_no_length(\"abc\")\n  \
    \  [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes_no_length(string\
    \ string) \n{\n    int length = string.Length;\n    string[] prefixes = new string[length];\n\
    \    \n    int i = 0;\n    while (i < length) \n    {\n        prefixes[i++] =\
    \ string.Substring(i);\n    }\n    \n    return prefixes;\n}\n/*\n Return array\
    \ of all suffixes from shortest to longest of the input string\n    >>> all_suffixes(\"\
    abc\")\n    [\"c\", \"bc\", \"abc\"]\n    \n*/\nstring[] all_suffixes(string string)\
    \ \n{\n    int length = string.Length;\n    string[] suffixes = new string[length];\n\
    \    \n    int i = 0;\n    while (i < length) \n    {\n        suffixes[i++] =\
    \ string.Substring(i + 1);\n    }\n    \n    return suffixes;\n}\n/*\n Return\
    \ array of all suffixes from shortest to longest of the input string\n    >>>\
    \ all_suffixes_no_length(\"abc\")\n    [\"c\", \"bc\", \"abc\"]\n    \n*/\nstring[]\
    \ all_suffixes_no_length(string string) \n{\n    int length = string.Length;\n\
    \    string[] suffixes = new string[length];\n    \n    int i = 0;\n    while\
    \ (i < length) \n    {\n        suffixes[i++] = string.Substring(i + 1);\n   \
    \ }\n    \n    return suffixes;\n}\n/*\n Return array of all chars from shortest\
    \ to longest of the input string\n    >>> all_chars(\"abc\")\n    [\"a\", \"b\"\
    , \"c\", \"ab\", \"ac\", \"bc\", \"abc\"]\n    \n*/\nstring[] all_chars(string\
    \ string) \n{\n    int length = string.Length;\n    string[] chars = new string[length];\n\
    \    \n    int i = 0;\n    while (i < length) \n    {\n        chars[i++] = string.Substring(i);\n\
    \    }\n    \n    return chars;\n}\n/*\n Return array of all chars from shortest\
    \ to longest of the input string\n    >>> all_chars_no_length(\"abc\")\n    [\"\
    a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", \"abc\"]\n    \n*/\nstring[] all_chars_no_length(string\
    \ string) \n{\n    int length = string.Length;\n", "{\n\tassert(!string.empty());\n\
    \tstring result;\n\t\n\t// Use memoization, if possible\n\tstring cacheKey = \"\
    all-prefixes-\" + string;\n\tresult = _memoizationCache.get(cacheKey);\n\tif (result.empty())\n\
    \t{\n\t\tresult = _prefixesInternal(string);\n\t\t_memoizationCache.set(cacheKey,\
    \ result);\n\t}\n\treturn result;\n}", "{\n\tint[] l = {0};\n\tfor(int i=string.length-1;\
    \ i>=0; i--) \n\t\tl[i]++;\n\t\n\tfor(int i=0; i<l.length; i++) \n\t\tl[i] = min(l[i],\
    \ string.length-1);\n\t\n\tstring[] ret = new string[l.length];\n\t\n\tfor(int\
    \ i=0; i<l.length; i++) \n\t\tret[i] = string.substr(0, l[i]);\n\t\t\n\treturn\
    \ ret;\n}", "{\n  var result = [];\n  var prefixLength = string.length\n  if (prefixLength\
    \ == 0) return result;\n  \n  if (string.length == 1) return [string];\n  \n \
    \ var allPrefixes = all_prefixes(string.substr(0,prefixLength-1));\n  allPrefixes.unshift(string);\n\
    \  \n  return allPrefixes;\n}", "{\n  int length = _max(string.len, 1);\n  int\
    \ current = 0;\n  string[] result = new string[length];\n  for(int i = length-1;\
    \ i>=0; i--)\n  {\n    result[i] = string.sub(i, current);\n    current = string.sub(i,\
    \ i+1).len;\n  }\n  return result;\n}\n</code>\n<|/ a dscore=3 tags=string,arrays,c#,algorithm\
    \ |>\n<| c |>\n`for(int i = length-1; i>=0; i--)` looks more \"correct\" to me.\
    \ `i` never gets negative, since `string.Sub` is never passed a negative index.\n\
    <|/ c |>\n<| c |>\nIt's not that simple. Try \"abcde\".\n<|/ c |>\n<| c |>\nNo,\
    \ \"e\".Sub(1, 1) is \"\"\n<|/ c |>\n<| c |>\nIf you can only use C# standard\
    \ library, you can try this `var result = string.Join(string.Empty, all_prefixes(\"\
    abcde\"));`\n<|/ c |>\n<| c |>\nOh, I just realized that \"e\".Sub(1, 2) will\
    \ be \"e\"\n<|/ c |>\n<| a |>\nUsing C# and only using string and math:\n<code>\n\
    using System;", "{\n    int len = string.length;\n    if(len==0) return new string[0];\n\
    \    var ans = new string[len];\n    \n    var i = -1;\n    var j = 0; \n    while\
    \ (j<len)\n    {\n        var c = string[j];\n        j++;\n        var prefix;\n\
    \        while(j<len)\n        {\n            var c = string[j];\n           \
    \ j++;\n            prefix = prefix+c;\n            ans[j] = prefix;\n       \
    \ }\n        ans[i] = prefix;\n        i++;\n    }\n    return ans;\n}\n</code>\n\
    <|/ a dscore=4 tags=string,algorithm,c# |>\n<| c |>\n`prefixes` function has a\
    \ bug\n<|/ c |>\n<| a tags=string,algorithm,c# |>\nHere's an algorithm that uses\
    \ no arrays, but has linear complexity. It splits the input string into two halves\
    \ (left and right). Then it creates two new strings left, right and recursively\
    \ calls itself with each of the halves. The recursion stops when one of the halves\
    \ is empty. If both halves have not been empty, then it concatenates each of the\
    \ halves together. Here is the code for the algorithm:\n<code>", "{\n    int[]\
    \ counter = new int[char]{ 0 };\n    int[] length = new int[char]{ 0 };\n    int\
    \ len = string.Length;\n    \n    for (int i = 0; i < len; i++)\n    {\n     \
    \   counter[string[i]]++;\n        length[string[i]]++;\n    }\n    \n    string[]\
    \ result = new string[len];\n    int k = len - 1;\n    \n    while (k > 0)\n \
    \   {\n        if (length[k] > counter[k])\n        {\n            result[k] =\
    \ string.Substring(0, k);\n            counter[k] = 0;\n        }\n        k--;\n\
    \    }\n    \n    return result;\n}\n/*\n Return array of all prefixes from shortest\
    \ to longest of the input string\n    >>> all_prefixes(\"abcde\")\n    [\"a\"\
    , \"ab\", \"abc\", \"abd\", \"abde\", \"abcde\"]\n    \n*/\nstring[] all_prefixes(string\
    \ string, int prefixLength) \n{\n    int[] counter = new int[char]{ 0 };\n   \
    \ int[] length = new int[char]{ 0 };\n    int len = string.Length;\n    int prefixes\
    \ = prefixLength;\n    \n    for (int i = 0; i < len; i++)\n    {\n        counter[string[i]]++;\n\
    \        length[string[i]]++;\n    }\n    \n    string[] result = new string[len];\n\
    \    int k = len - 1;\n    \n    while (k > 0)\n    {\n        if (length[k] >\
    \ counter[k])\n        {\n            result[k] = string.Substring(0, k);\n  \
    \          counter[k] = 0;\n        }\n        else if (length[k] == counter[k]\
    \ && length[k] == prefixes)\n        {\n            result[k] = string.Substring(0,\
    \ k);\n            counter[k] = prefixes;\n        }\n        k--;\n    }\n  \
    \  \n    return result;\n}\n/*\n Return array of all prefixes from shortest to\
    \ longest of the input string\n    >>> all_prefixes(\"abcde\", 2)\n    [\"ab\"\
    , \"abc\", \"abd\", \"abde\", \"abcde\"]\n    \n*/\nstring[] all_prefixes(string\
    \ string, int prefixLength, int minLength) \n{\n    int[] counter = new int[char]{\
    \ 0 };\n    int[] length = new int[char]{ 0 };\n    int len = string.Length;\n\
    \    int prefixes = prefixLength;\n    int minLength = minLength;\n    \n    for\
    \ (int i = 0; i < len; i++)\n    {\n        counter[string[i]]++;\n        length[string[i]]++;\n\
    \    }\n    \n    string[] result = new string[len];\n    int k = len - 1;\n \
    \   \n    while (k > 0)\n    {\n        if (length[k] > counter[k])\n        {",
  "{\n  string[] ret = new string[string.length];\n  int i = string.length-1;\n  while(i\
    \ >= 0){\n    ret[i] = string.Substring(0, i);\n    i--;\n  }\n  return ret;\n\
    }", "{\n    List<string> result = new List<string>(string.length);", "{\n  string[]\
    \ result = new string[string.length];\n  for (int i = 0; i < string.length; ++i)\n\
    \    result[i] = string;\n  for (int i = 1; i < string.length; ++i) {\n    string\
    \ prefix = string;\n    while (i > 0) {\n      --i;\n      prefix = string.substring(0,\
    \ i) + prefix;\n      result[i] = prefix;\n    }\n  }\n  return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThat looks really interesting. Can you explain a little bit\
    \ how it works?\n<|/ c |>\n<| c |>\nSure, it's essentially the same algorithm\
    \ as's but with some tweaks. It's just not as elegant because I'm looping over\
    \ the string twice, so it might not be as quick for large strings. In fact, I\
    \ thought that using recursion with `StringBuilder` might be faster. I'll see\
    \ if I can come up with a more elegant solution.\n<|/ c |>\n<| a tags=c#,prefix,algorithm,string\
    \ dscore=2 |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing\
    \ System.Linq;\nusing System.Text;", "{\n    string[] prefixes = new string[string.length];\n\
    \    prefixes[0] = string;\n    for (int i = 1; i < prefixes.length; ++i) {\n\
    \        prefixes[i] = prefixes[i - 1] + string.Substring(0, i);\n    }\n    return\
    \ prefixes;\n}", "{\n    var result = [];\n    \n    if(string == \"\")\n    \
    \    return result;", "{\n\tstring[] result = new string[string.Length];\n\t\n\
    \tint i = 0;\n\twhile (i < string.Length)\n\t{\n\t\tresult[i] = string.Substring(0,\
    \ i);\n\t\t\n\t\tint j = i;\n\t\twhile (j + 1 < string.Length && string.Substring(j,\
    \ 1) == string.Substring(j + 1, 1))\n\t\t{\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tif (j\
    \ + 1 >= string.Length)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\
    \t\t}\n\t}\n\t\n\treturn result;\n}", "{\n    string[] array = new string[string.Length];\n\
    \    for(int i = 0; i < array.Length; i++)\n    {\n        array[i] = string.Substring(0,i);\n\
    \    }\n    return array;\n}\n/*\n Return array of all prefixes from shortest\
    \ to longest of the input string\n    >>> all_prefixes(\"abbc\")\n    [\"a\",\
    \ \"ab\", \"abbc\"]\n    \n*/", "{\n    string[] ret = new string[string.length];\n\
    \    for (int i = 0; i < string.length; i++)\n        ret[i] = string.substring(0,\
    \ i);\n    return ret;\n}\n</code>\n<|/ a tags=string,c# |>\n<| a tags=string,c#\
    \ |>\nI made a slight change to the code of Zabuza to make it work as expected\
    \ (no empty strings in the output array):\n<code>\nstring[] Prefixes = PrefixesOf(\"\
    abc\");\n    \n    static void Main(string[] args)\n    {\n        \n        foreach\
    \ (var item in Prefixes)\n        {\n            Console.WriteLine(item);\n  \
    \      }\n        \n        \n        Console.ReadKey();\n    }", "{\n    int\
    \ len = string.length();\n    bool first = true;\n    bool found = false;\n  \
    \  string[] ret = new string[len];\n    \n    for(int i=0; i<len; ++i)\n    {\n\
    \        if(string[i] == '_') continue;\n        for(int j=0; j<i; ++j)\n    \
    \    {\n            if(string[i] == string[j])\n            {\n              \
    \  if(first)\n                {\n                    first = false;\n        \
    \            ret[i] = string[i];\n                    found = true;\n        \
    \        }\n                else\n                    ret[i] += string[i];\n \
    \           }\n        }\n        if(!found)\n        {\n            ret[i] =\
    \ \"unknown\";\n        }\n        found = false;\n    }\n    \n    return ret;\n\
    }", "{\n    int len = string.length();\n    string[] result = new string[len];\n\
    \    for(int i = 0; i < len; i++)\n    {\n        result[i] = string.Substring(0,\
    \ i+1);\n    }\n    return result;\n}\n/*\n Return array of all prefixes from\
    \ shortest to longest of the input string\n    >>> all_prefixes(\"abcde\")\n \
    \   [\"a\", \"abc\", \"abcde\"]\n    \n*/\nstring[] all_prefixes(string string,\
    \ string substr) \n{\n    int len = string.length();\n    string[] result = new\
    \ string[len];\n    for(int i = 0; i < len; i++)\n    {\n        if(string.Substring(0,\
    \ i+1).Equals(substr))\n        {\n            result[i] = string.Substring(0,\
    \ i+1);\n        }\n    }\n    return result;\n}", "{\n    string[] result = new\
    \ string[string.length];\n    for (int i = 0; i < string.length; i++)\n      \
    \  result[i] = string.substring(0, i);\n    return result;\n}", "{\n  int len\
    \ = string.length();\n  if (len == 0)\n    return string[]();", "{\n\tint i =\
    \ 1;\n\twhile(true)\n\t{\n\t\tstring[] result = new string[i];\n\t\tfor(int j=0;\
    \ j<i; j++)\n\t\t{\n\t\t\tresult[j] = string.substring(0,j+1);\n\t\t}\n\t\ti++;\n\
    \t\tif(string.length == i)\n\t\t\tbreak;\n\t}\n\treturn result;\n}", "{\n   const\
    \ int prefixCount = string.length();\n   \n   int prefixLength = prefixCount;\n\
    \   string prefixes;", "{\n  if(string.length < 2) return [];\n  \n  string prefix_list\
    \ = \"\";\n  string prefix = \"\";\n  int prefix_len = string.length;\n  int prefix_idx\
    \ = 0;\n  \n  while(true) {\n    string new_prefix = prefix_list + prefix;\n \
    \   if(string[prefix_idx] == '_') {\n      prefix_idx += 1;\n      if(prefix_idx\
    \ >= prefix_len) break;\n      prefix += string[prefix_idx];\n    } else if(string[prefix_idx]\
    \ == '-') {\n      prefix += \"-\";\n      prefix_idx += 1;\n      if(prefix_idx\
    \ >= prefix_len) break;\n      if(string[prefix_idx] == '-') {\n        prefix\
    \ += \"-\";\n        prefix_idx += 1;\n        if(prefix_idx >= prefix_len) break;\n\
    \      }\n      \n    } else {\n      break;\n    }\n    prefix_list = new_prefix;\n\
    \  }\n  \n  prefix_list = prefix_list + prefix;\n  \n  int len = prefix_list.length;\n\
    \  \n  string[] prefix_array = new string[len];\n  \n  int idx_in = 0;\n  int\
    \ idx_out = 0;\n  \n  string currPrefix = prefix_list;\n  \n  prefix_array[idx_out]\
    \ = currPrefix;\n  \n  for(; idx_in < prefix_len; idx_in += 1) {\n    if(string[idx_in]\
    \ == '_') {\n      prefix_list[idx_out] = currPrefix;\n      \n      currPrefix\
    \ = prefix_list;\n      \n      prefix_array[idx_out] = currPrefix;\n      \n\
    \      idx_out += 1;\n      idx_in = prefix_len - 1;\n      \n    } else if(string[idx_in]\
    \ == '-') {\n      prefix_list[idx_out] = currPrefix;\n      \n      currPrefix\
    \ = prefix_list;\n      \n      prefix_array[idx_out] = currPrefix;\n      \n\
    \      idx_out += 1;\n      idx_in = 0;\n      \n    } else {\n      prefix_array[idx_out]\
    \ = prefix_list[idx_in];\n      \n      idx_in += 1;\n      idx_out += 1;\n  \
    \  }\n  }\n  \n  return prefix_array;\n}", "{\n    string result = \"\";\n   \
    \ string current = string;\n    while (true)\n    {\n        result = current\
    \ + result;\n        current = reverseString(current);\n        if (current.length()\
    \ == 0)\n            break;\n    }\n    \n    string[] result = new string[result.length()];\n\
    \    \n    for (int i = 1; i < result.length; i++)\n        result[i] = result[i\
    \ - 1] + result.substring (0, i);\n    \n    return result;\n}\n/*\n Return array\
    \ of all suffixes from shortest to longest of the input string\n    >>> all_suffixes(\"\
    abc\")\n    [\"abc\", \"b\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string)\
    \ \n{\n    string current = string;\n    string result = \"\";\n    while (true)\n\
    \    {\n        result = result + current;\n        current = reverseString(current);\n\
    \        if (current.length() == 0)\n            break;\n    }\n    \n    string[]\
    \ result = new string[result.length()];\n    \n    for (int i = result.length\
    \ - 1; i >= 0; i--)\n        result[i] = current + result.substring (0, i + 1);\n\
    \    \n    return result;\n}\n/*\n Return array of all substring from shortest\
    \ to longest of the input string\n    >>> all_substrings(\"abc\")\n    [\"a\"\
    , \"ab\", \"abc\", \"b\", \"bc\", \"c\"]\n    \n*/\nstring[] all_substrings(string\
    \ string) \n{\n    string result = \"\";\n    string current = string;\n    while\
    \ (true)\n    {\n        result = current + result;\n        current = reverseString(current);\n\
    \        if (current.length() == 0)\n            break;\n    }\n    \n    string[]\
    \ result = new string[result.length()];\n    \n    for (int i = 0; i < result.length;\
    \ i++)\n        result[i] = result.substring (0, i);\n    \n    return result;\n\
    }\n/*\n Return array of all substrings containing specific characters\n    >>>\
    \ all_substrings(\"abcdefg\", new char[]{'a','e','i','o','u'})\n    [\"ab\", \"\
    abc\", \"abce\", \"abcde\", \"abef\", \"abefe\", \"abefgi\", \"abefgio\", \"abefgiou\"\
    , \"abefgioux\", \"abefu\"]\n    \n*/\nstring[] all_substrings(string string,\
    \ char[] chars) \n{\n    string result = \"\";\n    string current = string;\n\
    \    while (true)\n    {\n        result = current + result;\n        current\
    \ = reverseString(current);\n        if (current.length() == 0)\n            break;\n\
    \    }\n    \n    string[] result = new string[result.length()];\n    \n    for\
    \ (int i = 0; i < result.length; i++)\n        result[i] = result.substring (0,\
    \ i).split(chars);\n    \n    return result;\n}\n/*\n Return array of all substrings\
    \ containing specific characters ", "{\n    int l = string.length();\n    string\
    \ a = string;\n    string[] array = new string[l];\n    for (int i = 0; i<l; i++)\
    \ {\n        int index = string.indexOf(a);\n        while (index != -1) {\n \
    \           a = string.substr(0,index) + string.substr(index+1, string.length());\n\
    \            array[i] = string.substr(0,index);\n            index = string.indexOf(a);\n\
    \        }\n    }\n    return array;\n}\n/*\n Return array with all prefixes from\
    \ shortest to longest of the input string\n    >>> all_prefixes_including(\"abc\"\
    )\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes_including(string\
    \ string) \n{\n    int l = string.length();\n    string a = string;\n    string[]\
    \ array = new string[l];\n    string prefix = \"\";\n    for (int i = 0; i<l;\
    \ i++) {\n        int index = string.indexOf(a);\n        while (index != -1)\
    \ {\n            a = string.substr(0,index) + string.substr(index+1, string.length());\n\
    \            array[i] = string.substr(0,index) + prefix;\n            prefix =\
    \ string.substr(index+1, string.length());\n            index = string.indexOf(a);\n\
    \        }\n    }\n    return array;\n}\n/*\n Return array of all suffixes from\
    \ shortest to longest of the input string\n    >>> all_suffixes(\"abc\")\n   \
    \ [\"abc\", \"b\", \"c\", \"ab\"]\n    \n*/\nstring[] all_suffixes(string string)\
    \ \n{\n    int l = string.length();\n    string a = string;\n    string[] array\
    \ = new string[l];\n    for (int i = 0; i<l; i++) {\n        int index = string.indexOf(a);\n\
    \        while (index != -1) {\n            a = string.substr(index+1, string.length())\
    \ + a;\n            array[i] = string.substr(index+1, string.length());\n    \
    \        index = string.indexOf(a);\n        }\n    }\n    return array;\n}\n\
    /*\n Return array with all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes_including(\"abc\")\n    [\"abc\", \"b\", \"c\", \"ab\"]\n\
    \    \n*/\nstring[] all_suffixes_including(string string) \n{\n    int l = string.length();\n\
    \    string a = string;\n    string[] array = new string[l];\n    string suffix\
    \ = \"\";\n    for (int i = 0; i<l; i++) {\n        int index = string.indexOf(a);\n\
    \        while (index != -1) {\n            a = string.substr(index+1, string.length())\
    \ + a;\n            array[i] = string.substr(index+1, string.length()) + suffix;\n\
    \            suffix = string.substr(index+1, string.length());\n            index\
    \ = string.indexOf(a);\n        }\n    }\n    return array;\n}\n/*\n Return array\
    \ of all substrings from shor", "{\n    Vector<string> result = Vector<string>(string.Length);\n\
    \    \n    for (ulong i = 0; i < string.Length; ++i)\n    {\n        result[string.Length\
    \ - 1 - i] = string[i];\n    }\n    \n    ulong n = result.Length;\n    \n   \
    \ while (n > 1)\n    {\n        n--;\n        result[n] = result[n + 1];\n   \
    \ }\n    \n    result[n] = \"\\0\";\n    \n    return result;\n}", "{\n    int\
    \ N = string.length, M = N + 1;", "{\n    string rep = string;\n    int n = string.length();\n\
    \    string[] result = new string[n];\n    for (int i = 0; i < n; i++)\n    {\n\
    \        result[i] = rep;\n        rep = rep.substring(0, i);\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis won't work in C#. It doesn't\
    \ support `for` loops. Also it uses `+=` which isn't available in C#. Also, this\
    \ doesn't compile in C#.\n<|/ c |>\n<| a tags=.net,c# |>\nHere is a simple recursive\
    \ solution. It just uses String.Substring() and String.Concat()\n<code>\nstring\
    \ prefixes(string prefixes, string s)\n{\n    var result = new StringBuilder();\n\
    \    var i = s.Length;\n    do\n    {\n        result.Append(prefixes);\n    \
    \    result.Append(s.Substring(0, i));\n        i--;\n    } while (i >= 0);\n\
    \    return result.ToString();\n}\n</code>\nTest\n<code>\nvar s = prefixes(\"\
    abc\", \"defghijk\");\nConsole.WriteLine(s);\n</code>\nOutput\n<code>\nabcdefghijk\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=.net,c# |>\nHere is one solution\n<code>\n\
    class Program\n    {\n        static void Main(string[] args)\n        {\n   \
    \         string str= \"abcdefghijk\";\n            string prefixes = \"ab\";\n\
    \            String res = prefixes(str, prefixes);\n            Console.WriteLine(str\
    \ + \":\" + res);\n        }", "{\n    var result : array<string> = [];\n    var\
    \ length : int = string.length;\n    if (length > 0)\n    {\n        result[0]:\
    \ string.substr(0,1);\n    }\n    \n    for (int i=1; i<length; ++i)\n    {\n\
    \        result[i]: string.substr(0,i);\n    }\n    \n    return result;\n}\n\
    /*\n Return array of all prefixes from shortest to longest of the input string\n\
    \    >>> all_prefixes(\"abcabc\")\n    [\"a\", \"ab\", \"abc\", \"abcab\", \"\
    abcabc\", \"abc\", \"b\"]\n    \n*/\nstring[] all_prefixes(string string, int\
    \ upperbound) \n{\n    var result : array<string> = [];\n    var length : int\
    \ = string.length;\n    if (length > 0)\n    {\n        result[0]: string.substr(0,1);\n\
    \    }\n    \n    for (int i=1; i<length; ++i)\n    {\n        result[i]: string.substr(0,i);\n\
    \    }\n    \n    return result;\n}", "{\n\tstring[] result = new string[string.length()];\n\
    \tstd.algorithm.reverse(string,0,string.length()-1);\n\tfor(int i = 0;i < string.length();++i)\n\
    \t{\n\t\tresult[i] = string.substring(i+1,string.length());\n\t}\n\treturn result;\n\
    }", "{\n  string prefix = \"\";\n  string rest = string;\n  while (string.Length\
    \ > 0) {\n    if (string.Length > prefix.Length) prefix = string.Substring(prefix.Length);\n\
    \    else rest = string.Substring(1);\n    if (rest.length == 0) {\n      yield\
    \ return prefix;\n      break;\n    }\n    yield return prefix;\n    prefix =\
    \ string.Substring(prefix.Length + 1);\n    rest = string.Substring(1);\n  }\n\
    }\n</code>\n(This code is not thread safe, so be careful if you are using it from\
    \ multiple threads)\n<|/ a tags=string,prefix,c# |>\n<| a dscore=2 |>\nIt sounds\
    \ like you are looking for this \n<code>\npublic static List<string> Prefixes(this\
    \ string str)\n{\n    if (string.IsNullOrEmpty(str))\n    {\n        return new\
    \ List<string>();\n    }\n    List<string> ret = new List<string>();\n    int\
    \ length = str.Length;\n    char currentChar = str[0];\n    for (int i = 1; i\
    \ < length; i++)\n    {\n        if (currentChar != str[i])\n        {\n     \
    \       ret.Add(new string(new char[] {currentChar}));\n            currentChar\
    \ = str[i];\n        }\n        else\n        {\n            currentChar = str[i];\n\
    \        }\n    }\n    ret.Add(new string(new char[] {currentChar}));\n    return\
    \ ret;\n}\n</code>\n<|/ a tags=string,prefix,c# |>\n<| c |>\nI think your code\
    \ is wrong. You're returning a list of prefixes but your code actually returns\
    \ a list of all possible substrings.\n<|/ c |>\n<| c |>\nAh you are right.  That\
    \ was my bad. I've fixed it now.\n<|/ c |>\n<| c |>\nThis answer is wrong - it\
    \ returns all possible substrings, but the OP wants only the prefixes (ie, \"\
    aaa\" should only return \"a\"). Also, your code is missing a closing brace on\
    \ the `if` statement.\n<|/ c |>\n<| a dscore=2 |>\n<code>\nstatic IEnumerable<string>\
    \ GetPrefixes(string s)\n{\n    int start = 0;\n    int length = s.Length;\n \
    \   while(start + 1 < length)\n    {\n        yield return s.Substring(start,\
    \ length-start);\n        start += 1;\n    }\n    yield return s.Substring(start,\
    \ length);\n}\n</code>\n<|/ a tags=string,prefix,c# |>\n<| c |>\nThis does not\
    \ work when s contains zero characters. And `s.Length == 0`\n<|/ c |>\n<| a tags=string,prefix,c#\
    \ |>\n<code>\npublic static IEnumerable<string> GetPrefixes(", "{\n    string[]\
    \ result = new string[string.length];\n    for (int i = 0; i < string.length;\
    \ i++) \n    {\n        result[i] = string.Substring(0, i);\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. \nI modified\
    \ my question a little bit. I only need the last 4 character of the string. For\
    \ example, I want the result to be  [\"abc\", \"bc\", \"c\", \"ab\"] but not [\"\
    abc\", \"abc\", \"a\", \"ab\"]. Because the shortest string is not equal to \"\
    abc\", only the longest string.\n<|/ c |>\n<| c |>\nOh I understand. So you want\
    \ to get all prefixes of the longest string from the shortest string. Let me edit\
    \ my answer to reflect that.\n<|/ c |>\n<| a dscore=1 tags=string,c# |>\nThis\
    \ is my solution to this problem:\n<code>\nstring shortestString = \"abc\";\n\
    string longestString = \"abx\";", "{\n    var results = new string[string.Length];\n\
    \    var j = 0;\n    for (var i = 0; i < string.Length; i++)\n    {\n        results[j++]\
    \ = string.Substring(i, 1);\n    }", "{\n  int len = string.length;\n  \n  List<string>\
    \ prefixes = new List<string>();\n  \n  for(int i = 1; i <= len; i++)\n  {\n \
    \   prefixes.Add(string.Substring(0, i));\n  }\n  \n  return prefixes;\n}\n</code>\n\
    <|/ a tags=c#,algorithm,string |>\n<| c |>\nWhile this code may answer the question,\
    \ it would be better to include some _context_, explaining _how_ it works and\
    \ _when_ to use it\n<|/ c |>\n<| c |>\nYeah thanks for the heads up. I added some\
    \ explanation.\n<|/ c |>\n<| a |>\nThis is an old post but I have been thinking\
    \ about this same problem for a couple days now, trying to make a really fast\
    \ solution so I thought I would share my findings.\nFirst let's look at how I\
    \ came to the solution above:\nI created an array of chars and then I filled it\
    \ with all the possible substrings from the original string.  From there I iterated\
    \ through the array to find all strings that contained the first char and then\
    \ I iterated through all the remaining chars and added all the strings that had\
    \ a char at that index.  I then iterated through the array of strings and added\
    \ all the strings that started with those characters and ended with the next char.\
    \  I then iterated through the array of strings and added all the strings that\
    \ started with the chars and ended with the char that was at the end of any of\
    \ the strings.  This made the most amount of string comparisons possible.\nIn\
    \ each iteration, I added the string to the array of strings.  I used a dictionary\
    \ to ensure that a given string was only added once.\nOnce I got to a point where\
    \ I was adding all the strings to the array, I started a timer (using System.Diagnostics.Stopwatch).\
    \  Then I iterated through the array and found the longest string that had a particular\
    \ char at the end that had a char at any index.  From there I iterated through\
    \ the list of strings and found the longest string that started with that char\
    \ and had a char at any index.  Then I iterated through the list of strings and\
    \ found the longest string that started with that char and ended with the char\
    \ that was at the end of any of the strings.  Then I added the longest string\
    \ that started with the char and ended with the char that was at the end of any\
    \ of the strings to another list which was added to the dictionary. I also added\
    \ the chars used to generate the strings to the dictionary also.  This made the\
    \ most amount of string comparisons possible (for my current test cases).\nThen,\
    \ I iterated through the dictionary and found the longest string that had a particular\
    \ char at the end that had a char at any index (the longest string ", "{\n   \
    \ string temp = string;\n    string[] result;\n    while(!temp.empty())\n    {\n\
    \        result = new string[temp.size()];\n        int i = 0;\n        for(int\
    \ j=0; j<temp.size(); j++)\n        {\n            result[i++] = temp[j];\n  \
    \      }\n        temp = string.join(\"\",result); //to remove duplicates\n  \
    \  }\n    return result;\n}", "{\n    int nchars = string.Length;\n    for(int\
    \ i = 0;  i < nchars;  i++)\n    {\n        string prefix = \"\";\n        for(int\
    \ j = 0;  j < i;  j++)\n            prefix += string[j];\n        for(int j =\
    \ i;  j < nchars;  j++)\n            prefix += string[j];\n        for(int j =\
    \ i;  j < nchars;  j++)\n            string += string[j];\n        \n        yield\
    \ return prefix;\n    }\n}", "{\n  var result =new List<TreeNode>();\n  foreach\
    \ (char character in string) \n  {\n    TreeNode node = new TreeNode(character);\n\
    \    TreeNode longest = node;\n    foreach (char c in string) \n    {\n      TreeNode\
    \ child = new TreeNode(c);\n      child.height = max(child.height, longest.height);\n\
    \      longest.children.Add(child);\n    }\n    result.Add(node);\n  }\n  TreeNode\
    \ root = new TreeNode('', result);\n  return root.children.Select(n => n.value).ToArray();\n\
    }\n</code>\n<|/ a |>\n<| a |>\nA C# implementation based on Igor's code:\n<code>\n\
    using System;\nusing System.Collections.Generic;\nusing System.Linq;", "{\n  \
    \  var result = new string[string.Length];\n    \n    var index = 0;\n    \n \
    \   while (index < string.Length)\n    {\n        var current = char.ToUpper(string[index]);\n\
    \        \n        if (current.Equals('A'))\n        {\n            result[index]\
    \ = 'A';\n        }\n        else if (current.Equals('B'))\n        {\n      \
    \      result[index] = 'B';\n        }\n        else if (current.Equals('C'))\n\
    \        {\n            result[index] = 'C';\n        }\n        else if (current.Equals('D'))\n\
    \        {\n            result[index] = 'D';\n        }\n        else if (current.Equals('E'))\n\
    \        {\n            result[index] = 'E';\n        }\n        else if (current.Equals('F'))\n\
    \        {\n            result[index] = 'F';\n        }\n        else if (current.Equals('G'))\n\
    \        {\n            result[index] = 'G';\n        }\n        else if (current.Equals('H'))\n\
    \        {\n            result[index] = 'H';\n        }\n        else if (current.Equals('I'))\n\
    \        {\n            result[index] = 'I';\n        }\n        else if (current.Equals('J'))\n\
    \        {\n            result[index] = 'J';\n        }\n        else if (current.Equals('K'))\n\
    \        {\n            result[index] = 'K';\n        }\n        else if (current.Equals('L'))\n\
    \        {\n            result[index] = 'L';\n        }\n        else if (current.Equals('M'))\n\
    \        {\n            result[index] = 'M';\n        }\n        else if (current.Equals('N'))\n\
    \        {\n            result[index] = 'N';\n        }\n        else if (current.Equals('O'))\n\
    \        {\n            result[index] = 'O';\n        }\n        else if (current.Equals('P'))\n\
    \        {\n            result[index] = 'P';\n        }\n        else if (current.Equals('Q'))\n\
    \        {\n            result[index] = 'Q';\n        }\n        else if (current.Equals('R'))\n\
    \        {\n            result[index] = 'R';\n        }\n        else if (current.Equals('S'))\n\
    \        {\n            result[index] = 'S';\n        }\n        else if (current.Equals('T'))\n\
    \        {\n            result[index] = 'T';\n        }\n        else if (current.Equals('U'))\n\
    \        {\n            result[index] = 'U';\n        }\n        else if (current.Equals('V'))\n\
    \        {\n            result[index] = 'V';\n        }\n        else if (current.Equals('W'))\n\
    \        {\n            result[index] = 'W';\n        }\n        else if (current.Equals('X'))\n\
    \        {\n            result[index] = 'X';\n        }\n        else if (current.Equals('Y'))\n\
    \        {\n            result[index] = 'Y';\n        }\n        else if (current.Equals('Z'))\n\
    \        {\n            result[index] = 'Z';\n        }\n        else if (current.Equals('0'))\n\
    \        {\n            result[index] = '0';\n        }\n        else if (current.Equals('1'))\n\
    \        {\n            result[index] = '1';", "{\n    string[] result = new string[string.length()];\n\
    \    int i = 0;\n    while (i < string.length()) {\n        result[i++] = string.substr(0,\
    \ i);\n    }\n    return result;\n}", "{\n\tassert(string != null);\n\tint len\
    \ = string.length();\n\tstring[] ret = new string[len];\n\tint i;\n\t\n\tfor(i=0;i<len;i++)\
    \ {\n\t\tret[i] = string.substr(0,i);\n\t}\n\t\n\tfor(i=len;i>0;i--) {\n\t\tret[i-1]\
    \ = ret[i-2] + (string.substr(0,i));\n\t}\n\treturn ret;\n}\n/*\n Return array\
    \ of all suffixes from shortest to longest of the input string\n    >>> all_suffixes(\"\
    abc\")\n    [\"c\", \"bc\", \"abc\"]\n    \n*/\nstring[] all_suffixes(string string)\
    \ \n{\n\tassert(string != null);\n\tint len = string.length();\n\tstring[] ret\
    \ = new string[len];\n\tint i;\n\t\n\tfor(i=0;i<len;i++) {\n\t\tret[i] = string.substr(i,string.length());\n\
    \t}\n\t\n\tfor(i=len;i>0;i--) {\n\t\tret[i-1] = ret[i-2] + (string.substr(0,i));\n\
    \t}\n\treturn ret;\n}", "{\n  var results: any[] = [];\n  var length: uint = string.Length;\n\
    \  var last: uint = 0;\n  while (length > 0) {\n    last = string.IndexOf(string.Substring(0,\
    \ length), last);\n    if (last < 0) break;\n    results[] = string.Substring(0,\
    \ last);\n    length -= last;\n  }\n  return results;\n}", "{\n    stack<string>\
    \ sstack;\n    sstack = new stack<string>();\n    sstack.push(string);\n    string[]\
    \ arr = new string[string.length];\n    while(!sstack.empty())\n    {\n      \
    \  string word = sstack.top();\n        sstack.pop();\n        for(int i = 0;\
    \ i < word.length; i++)\n        {\n            arr[i] = word;\n        }\n  \
    \      for(int i = word.length - 1; i >= 0; i--)\n        {\n            sstack.push(word.substr(0,i));\n\
    \        }\n    }\n    return arr;\n}", "{\n  // Base case: empty string\n  if\
    \ (string.length == 0)\n      return new string[] { string };\n  \n  string[]\
    \ result = new string[string.length];\n  \n  // Recursive case: remove first character\
    \ of string and recurse\n  for (int i = 0; i < string.length; i++)\n  {\n    \
    \ string prefix = string.substring(0, i);\n     \n     // Recurse with remaining\
    \ strings\n     result[i] = all_prefixes(prefix) + prefix;\n  }\n  \n  return\
    \ result;\n}\n</code>\n<|/ a tags=string,c# |>\n<| a tags=string,c# dscore=4 |>\n\
    Using LINQ:\n<code>\nvar result = new string(string.Join(\"\", chars.Select((c,\
    \ i) => new {c, i}).OrderBy(x => x.i).Select(x => x.c).TakeWhile(x => x) != \"\
    \\0\").ToArray());\n</code>\n<|/ a |>\n<| c |>\nThis one should be the accepted\
    \ answer because it will not allocate any memory and only uses Linq.\n<|/ c |>\n\
    <| c |>\n`TakeWhile(x => x)` would do the trick without ordering the characters.\n\
    <|/ c |>\n<| c |>\nNo, it would only return `null` if the character at index `i`\
    \ was `\\0`, which is what the OP wants to strip out before concatenating the\
    \ remaining strings.\n<|/ c |>\n<| a |>\nHere is a way using a StringBuilder\n\
    <code>\nvar strings = new List<string>{ \"Hello\", \"World!\", \"This\", \"is\"\
    , \"a\", \"test\" };", "{\n    int[] count = new int[256];\n    int i, j;", "{\n\
    \    int maxLen = string.length() - 1;\n    int[] dp = new int[maxLen + 1];\n\
    \    \n    for (int i = 0; i <= maxLen; i++)\n    {\n        dp[i] = string.length();\n\
    \    }\n    \n    for (int i = 0; i < string.length(); i++)\n    {\n        for\
    \ (int j = i; j <= maxLen; j++)\n        {\n            if (string[j] != string[i])\n\
    \            {\n                dp[j] = Math.min(dp[j], dp[j + 1]);\n        \
    \    }\n        }\n    }\n    \n    int[] result = new int[string.length()];\n\
    \    for (int i = 0; i <= maxLen; i++)\n    {\n        result[i] = dp[i];\n  \
    \  }\n    \n    return result;\n}", "{\n    var list = new List<dynamic>();\n\
    \    var str = string;\n    var len = string.length;\n    bool flag = true;\n\
    \    while(flag)\n    {\n        for(int i = 0; i < len; i++)\n        {\n   \
    \         if(string[i] == str[0] && string[i+1] == str[1])\n            {\n  \
    \              list.add(string[i]);\n                flag = false;\n         \
    \       break;\n            }\n        }\n        if(!flag)\n            break;\n\
    \        for(int i = 0; i < len; i++)\n        {\n            if(string[i] ==\
    \ str[1] && string[i+1] == str[2])\n            {\n                list.add(string[i]);\n\
    \                flag = false;\n                break;\n            }\n      \
    \  }\n        if(!flag)\n            break;\n        for(int i = 0; i < len; i++)\n\
    \        {\n            if(string[i] == str[2] && string[i+1] == str[3])\n   \
    \         {\n                list.add(string[i]);\n                flag = false;\n\
    \                break;\n            }\n        }\n        if(!flag)\n       \
    \     break;\n        for(int i = 0; i < len; i++)\n        {\n            if(string[i]\
    \ == str[3] && string[i+1] == str[4])\n            {\n                list.add(string[i]);\n\
    \                flag = false;\n                break;\n            }\n      \
    \  }\n        if(!flag)\n            break;\n        for(int i = 0; i < len; i++)\n\
    \        {\n            if(string[i] == str[4] && string[i+1] == str[5])\n   \
    \         {\n                list.add(string[i]);\n                flag = false;\n\
    \                break;\n            }\n        }\n        if(!flag)\n       \
    \     break;\n        for(int i = 0; i < len; i++)\n        {\n            if(string[i]\
    \ == str[5] && string[i+1] == str[6])\n            {\n                list.add(string[i]);\n\
    \                flag = false;\n                break;\n            }\n      \
    \  }\n        if(!flag)\n            break;\n        for(int i = 0; i < len; i++)\n\
    \        {\n            if(string[i] == str[6] && string[i+1] == str[7])\n   \
    \         {\n                list.add(string[i]);\n                flag = false;\n\
    \                break;\n            }\n        }\n        if(!flag)\n       \
    \     break;\n        for(int i = 0; i < len; i++)\n        {\n            if(string[i]\
    \ == str[7] && string[i+1] == str[8])\n            {\n                list.add(string[i]);\n\
    \                flag = false;\n                break;\n            }\n      \
    \  }\n        if(!flag)\n            break;\n        for(int i = 0; i < len; i++)\n\
    \        {\n            if(string[i] == str[8] && string[i+1] == str[9])\n   \
    \         {\n                list.add(string[i]);\n                flag = false;\n\
    \                break;\n            }\n        }\n        if(!flag)\n       \
    \     break;\n        for(int i = 0; i < len; i++)\n        {\n            if(string[i]\
    \ == str[9] && string[i+1] == str[10])\n            {\n                list.add(string[i]);\n\
    \                flag = false;\n                break;\n            }\n      \
    \  }\n        if(!flag)\n            break;\n        for(int i = 0; i < len; i++)\n\
    \        {\n            if(string[i] == str[10] && string[i+1] == str[11])\n \
    \           {\n", "{\n    int len = string.length;\n    if(len == 1) return string.chars;\n\
    \    \n    Stack<string> stack = new Stack<string>(string.chars);\n    stack.Push(string.chars[0]);\n\
    \    \n    for(int i=1; i < len; ++i)\n    {\n        string nextString = string.chars[i];\n\
    \        int j = i+1;\n        for(; j+1 < len; ++j)\n        {\n            string\
    \ prefix = string.Substring(i, j-1);\n            if(i==j) continue;\n       \
    \     string suffix = string.Substring(j+1);\n            \n            stack.TryPush(prefix\
    \ + \"+\" + suffix);\n        }\n        stack.TryPush(nextString);\n    }\n \
    \   \n    string[] prefixes = new string[stack.Count];\n    int i=0;\n    while\
    \ (stack.Count > 0)\n    {\n        prefixes[i++] = stack.Pop();\n    }\n    return\
    \ prefixes;\n}", "{\n\tstring[] result=new string[string.length];\n\tfor (int\
    \ i=0;i<string.length;++i)\n\t{\n\t\tresult[i]=string.Substring(i);\n\t}\n\tArrays.sort(result);\n\
    \treturn result;\n}\n/*\n Return array with all unique prefixes of input string\n\
    \    >>> all_unique_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\n\
    string[] all_unique_prefixes(string string) \n{\n\tstring[] result=new string[string.length];\n\
    \tfor (int i=0;i<string.length;++i)\n\t{\n\t\tresult[i]=string.Substring(i);\n\
    \t}\n\tArrays.sort(result);\n\tfor (int i=0;i<string.length;++i)\n\t{\n\t\tfor\
    \ (int j=i+1;j<string.length;++j)\n\t\t{\n\t\t\tif (result[i]==result[j])\n\t\t\
    \t{\n\t\t\t\tstring tmp=string.Substring(0,i);\n\t\t\t\ttmp+=string.Substring(j);\n\
    \t\t\t\tresult[j]=tmp;\n\t\t\t}\n\t\t}\n\t}\n\tArrays.sort(result);\n\treturn\
    \ result;\n}\n/*\n Return array of all suffixes from shortest to longest of the\
    \ input string\n    >>> all_suffixes(\"abc\")\n    [\"b\", \"bc\", \"c\"]\n  \
    \  \n*/\nstring[] all_suffixes(string string) \n{\n\tstring[] result=new string[string.length];\n\
    \tfor (int i=string.length-1;i>=0;--i)\n\t{\n\t\tresult[i]=string.Substring(i);\n\
    \t}\n\tArrays.sort(result);\n\treturn result;\n}\n/*\n Return array of all unique\
    \ suffixes of input string\n    >>> all_unique_suffixes(\"abc\")\n    [\"b\",\
    \ \"bc\", \"c\"]\n    \n*/\nstring[] all_unique_suffixes(string string) \n{\n\t\
    string[] result=new string[string.length];\n\tfor (int i=string.length-1;i>=0;--i)\n\
    \t{\n\t\tresult[i]=string.Substring(i);\n\t}\n\tArrays.sort(result);\n\tfor (int\
    \ i=0;i<string.length;++i)\n\t{\n\t\tfor (int j=i+1;j<string.length;++j)\n\t\t\
    {\n\t\t\tif (result[i]==result[j])\n\t\t\t{\n\t\t\t\tstring tmp=string.Substring(0,i);\n\
    \t\t\t\ttmp+=string.Substring(j);\n\t\t\t\tresult[j]=tmp;\n\t\t\t}\n\t\t}\n\t\
    }\n\tArrays.sort(result);\n\treturn result;\n}\n/*\n Return array of all consecutive\
    \ substrings of input string\n    >>> all_substrings(\"abc\")\n    [\"a\", \"\
    b\", \"c\", \"ab\", \"ac\", \"bc\", \"abc\"]\n    \n*/\nstring[] all_substrings(string\
    \ string) ", "{\n    int len = string.length();\n    string[] result = new string[len];\n\
    \    for(int i = 0; i < len; ++i)\n    {\n        result[i] = string.Substring(0,\
    \ i);\n    }\n    return result;\n}", "{\n    \n    \n    bool prefix = false;\n\
    \    int len = 0;\n    string[] ret = new string[0];\n    stack<string> s;\n \
    \   \n    for(var i = 0; i < string.length; i++)\n    {\n        \n        if(string[i]\
    \ == '_')\n        {\n            prefix = false;\n            len = 0;\n    \
    \        \n        }\n        else\n        {\n            if(!prefix)\n     \
    \       {\n                prefix = true;\n                s.push(string);\n \
    \           }\n            len++;\n            \n        }\n        \n       \
    \ \n        if(len > 0)\n        {\n            string pre = s.top();\n      \
    \      ret[ret.length] = pre;\n            s.pop();\n        }\n        \n   \
    \ }\n    \n    return ret;\n    \n}", "{\n    string[] arr;\n    string pre;\n\
    \    string cur;\n    string last;\n    arr = new string[string.length()];\n \
    \   cur = string;\n    last = cur;\n    while(string.length() > 0)\n    {\n  \
    \      pre = cur;\n        last = cur;\n        while(string.length() > 0)\n \
    \       {\n            last = cur;\n            cur = cur.substr(1);\n       \
    \     if(cur != \"\" && cur.length() > 0)\n                arr[arr.length] = cur;\n\
    \        }\n        pre = last;\n    }\n    return arr;\n}\n/*\n Return array\
    \ of all suffixes from shortest to longest of the input string\n    >>> all_suffixes(\"\
    abc\")\n    [\"c\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    string[]\
    \ arr;\n    string pre;\n    string cur;\n    string last;\n    arr = new string[string.length()];\n\
    \    cur = string;\n    last = cur;\n    while(string.length() > 0)\n    {\n \
    \       pre = cur;\n        last = cur;\n        while(string.length() > 0)\n\
    \        {\n            last = cur;\n            cur = cur.substr(0, cur.length()-1);\n\
    \            if(cur != \"\" && cur.length() > 0)\n                arr[arr.length]\
    \ = cur;\n        }\n        pre = last;\n    }\n    return arr;\n}\n/*\n Return\
    \ array of all substrings of size k from shortest to longest of the input string\n\
    \    >>> all_substrings(\"abc\", 2)\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\n\
    string[] all_substrings(string string, int k) \n{\n    string[] arr;\n    string\
    \ pre;\n    string cur;\n    string last;\n    arr = new string[string.length()];\n\
    \    cur = string;\n    last = cur;\n    while(string.length() > 0)\n    {\n \
    \       pre = cur;\n        last = cur;\n        while(string.length() > 0)\n\
    \        {\n            last = cur;\n            cur = cur.substr(0, cur.length()-(k+1));\n\
    \            if(cur != \"\" && cur.length() > 0)\n                arr[arr.length]\
    \ = cur;\n        }\n        pre = last;\n    }\n    return arr;\n}\n/*\n Return\
    \ array of all substrings of size k of characters from shortest to longest of\
    \ the input string\n    >>> all_substrings(\"abc\", 2)\n    [\"a\", \"ab\", \"\
    abc\"]\n    \n*/\nstring[] all_substrings(string string, char k) \n{\n    string[]\
    \ arr;\n    string pre;\n    string cur;\n    string ", "{\n\tint i = 0;\n\tstring[]\
    \ result = new string[string.size()];\n\twhile (i < string.size())\n\t{\n\t\t\
    result[i++] = string.substr(0, i);\n\t}\n\treturn result;\n}", "{\n\tint[] char_counts\
    \ = new int[char.maxValue+1];\n\tfor(int i=0; i<string.Length; i++) {\n\t\tchar_counts[string[i]]\
    \ += 1;\n\t}\n\tList<string> prefixes = new List<string>();\n\tfor(int i=0; i<char_counts.length;\
    \ i++) {\n\t\tif(char_counts[i] == 0) break;\n\t\tprefixes.Add(char.GetName(char.Parse((char)i)));\n\
    \t}\n\treturn prefixes.ToArray();\n}\n/*\n Return array of all suffixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"abc\"\
    , \"b\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n\tint[] char_counts\
    \ = new int[char.maxValue+1];\n\tfor(int i=0; i<string.Length; i++) {\n\t\tchar_counts[string[i]]\
    \ += 1;\n\t}\n\tList<string> suffixes = new List<string>();\n\tfor(int i=0; i<char_counts.length;\
    \ i++) {\n\t\tif(char_counts[i] == 0) break;\n\t\tsuffixes.Add(char.GetName(char.Parse((char)i)));\n\
    \t}\n\treturn suffixes.ToArray();\n}\n/*\n Return array of all substrings from\
    \ shortest to longest of the input string\n    >>> all_substrings(\"abc\")\n \
    \   [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_substrings(string string)\
    \ \n{\n\tList<string> substrings = new List<string>();\n\tfor(int i=0;i<string.Length;i++)\
    \ {\n\t\tsubstrings.Add(string.Substring(i, string.Length-i));\n\t}\n\treturn\
    \ substrings.ToArray();\n}\n/*\n Return array of all substrings from shortest\
    \ to longest of the input string\n    >>> all_substrings(\"abc\")\n    [\"a\"\
    , \"ab\", \"abc\"]\n    \n*/\nstring[] all_substrings(string string) \n{\n\tList<string>\
    \ substrings = new List<string>();\n\tfor(int i=0;i<string.Length;i++) {\n\t\t\
    substrings.Add(string.Substring(i, string.Length-i));\n\t}\n\treturn substrings.ToArray();\n\
    }\n/*\n Return array of all substrings with length between shortest to longest\
    \ of the input string\n    >>> all_substrings(\"abc\", 1, 2)\n    [\"a\", \"ab\"\
    , \"abc\"]\n    \n*/\nstring[] all_substrings(string string, int minimumLength,\
    \ int maximumLength) \n{\n\tList<string> substrings = new List<string>();\n\t\
    for(int i=0;i<string.Length;i++) {\n\t\tif(minimumLength <= i && maximumLength\
    \ >= i && minimumLength <= string.Length - i && maximumLength >= string.Length\
    \ - i) \n\t\t\tsubstrings.Add(string.Substring(i, string.Length-i));\n", "{\n\
    \    int[] prefixes = new int[string.length];\n    int prefix = 0;\n    int i;\n\
    \    bool isPrefixOdd;\n    \n    for (i = 0; i < string.length; i++) {\n    \
    \    prefixes[i] = prefix;\n        isPrefixOdd = (prefix%2 != 0);\n        prefix\
    \ = prefix+(string.length-i)+isPrefixOdd;\n    }\n    return prefixes;\n}\n/*\n\
    \ Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"bc\", \"c\"]\n    \n*/\nstring[] all_suffixes(string\
    \ string) \n{\n    int[] suffixes = new int[string.length];\n    int suffix =\
    \ 0;\n    int i;\n    bool isSuffixOdd;\n    \n    for (i = string.length-1; i\
    \ >= 0; i--) {\n        suffixes[i] = suffix;\n        isSuffixOdd = (suffix%2\
    \ != 0);\n        suffix = suffix+(string.length-i)+isSuffixOdd;\n    }\n    return\
    \ suffixes;\n}\n/*\n Return array of all common prefixes from shortest to longest\
    \ of the input string\n    >>> all_common_prefixes(\"abracadabra\")\n    [\"abra\"\
    , \"abracabra\", \"abracad\", \"abracadabra\"]\n    \n*/\nstring[] all_common_prefixes(string\
    \ string) \n{\n    string[] prefixes = all_prefixes(string);\n    int[] common_prefixes\
    \ = all_common_prefixes_index(prefixes);\n    \n    int[] result = new int[string.length];\n\
    \    int index = 0;\n    int i = 0;\n    int j;\n    \n    while (i < prefixes.length)\
    \ {\n        while (i < common_prefixes[i] && index < string.length){\n      \
    \      result[index] = string[i];\n            index++;\n            i++;\n  \
    \      }\n        i++;\n    }\n    \n    int[] suffixes = all_suffixes(string);\n\
    \    int[] common_suffixes = all_common_suffixes_index(suffixes);\n    \n    index\
    \ = 0;\n    \n    while (i < common_suffixes.length && index < string.length)\
    \ {\n        while (i < common_suffixes[i] && index < string.length) {\n     \
    \       result[index] = string[index];\n            index++;\n            i++;\n\
    \        }\n        i++;\n    }\n    \n    \n    return result.ToArray();\n}\n\
    /*\n Return array of all common suffixes from shortest to longest of the input\
    \ string\n    >>> all_common_suffixes(\"abracadabra\")\n    [\"ra\", \"raca\"\
    , \"racad\", \"racadabra\"]\n    \n*/", "{\n    int len = string.length;\n   \
    \ int[] l = new int[len];\n    l[0] = 0;\n    for(int i=1; i<len; ++i)\n     \
    \   l[i] = i;\n    \n    int cur = 0;\n    while(string[cur] != '\\0')\n    {\n\
    \        while(cur < len && l[cur] < string[cur+1])\n            cur++;\n    \
    \    \n        l.swap(cur, cur+1);\n        cur++;\n    }", "{\n    int[] counts\
    \ = countChars(string);\n    \n    int minCount = Integer.MAX_VALUE;\n    \n \
    \   for(int i = 0 ; i < counts.length ; i++)\n    {\n        if(counts[i] < minCount)\n\
    \        {\n            minCount = counts[i];\n        }\n    }\n    \n    int[]\
    \ prefixes = new int[minCount + 1];\n    \n    for(int i = 0 ; i < counts.length\
    \ ; i++)\n    {\n        int currentCount = counts[i];\n        if(currentCount\
    \ < minCount)\n        {\n            for(int j = currentCount ; j < minCount\
    \ ; j++)\n            {\n                prefixes[j] = string.charAt(i);\n   \
    \         }\n        }\n        else\n        {\n            int startIndex =\
    \ i;\n            int endIndex = i + 1;\n            \n            while(endIndex\
    \ < counts.length && string.charAt(endIndex) == string.charAt(endIndex + 1))\n\
    \            {\n                endIndex++;\n            }\n            \n   \
    \         prefixes[currentCount] = string.substring(startIndex, endIndex);\n \
    \       }\n    }\n    \n    return prefixes;\n}\n/*\n Return array of all suffixes\
    \ from shortest to longest of the input string\n    >>> all_suffixes(\"abc\")\n\
    \    [\"abc\", \"b\", \"b\"]\n    \n*/\nstring[] all_suffixes(string string) \n\
    {\n    int[] counts = countChars(string);\n    \n    int minCount = Integer.MAX_VALUE;\n\
    \    \n    for(int i = 0 ; i < counts.length ; i++)\n    {\n        if(counts[i]\
    \ < minCount)\n        {\n            minCount = counts[i];\n        }\n    }\n\
    \    \n    int[] suffixes = new int[minCount + 1];\n    \n    for(int i = 0 ;\
    \ i < counts.length ; i++)\n    {\n        int currentCount = counts[i];\n   \
    \     if(currentCount < minCount)\n        {\n            for(int j = currentCount\
    \ ; j < minCount ; j++)\n            {\n                suffixes[j] = string.charAt(i);\n\
    \            }\n        }\n        else\n        {\n            int startIndex\
    \ = i;\n            int endIndex = i + 1;\n            \n            while(endIndex\
    \ < counts.length && string.charAt(endIndex) == string.charAt(endIndex + 1))\n\
    \            {\n                endIndex++;\n            }\n            \n   \
    \         suffixes[currentCount] = string.substring(startIndex, endIndex);\n \
    \       }\n    }\n    \n    return suffixes;\n}\n/*\n Return array of all prefixes\
    \ from shortest to longest of the input string\n    >>> all_prefixes(\"aabc\"\
    )\n    [\"a\"]\n    \n*/\nstring[] all_prefixes(string string) \n{\n    int[]\
    \ counts = countChars(string);\n    \n    int minCount = Integer.MAX_", "{\n \
    \   string[] results = new string[string.Length];\n    for (int i = 0; i < string.Length;\
    \ i++)\n    {\n        results[i] = string.Substring(0, i);\n    }\n    return\
    \ results;\n}\n</code>\n<|/ a tags=c#,.net |>\n<| c |>\nThat was an extremely\
    \ useful function and I really appreciate you sharing it. It worked for me in\
    \ C# with the exception of some special cases which I will post here as an edit.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's a function that doesn't use string concatenation\
    \ and uses String.Format and yields the expected results. It's also fast.\n<code>\n\
    using System.Text;\nusing System.Linq;", "{\n    string prefix = \"\";\n    string\
    \ currentString = \"\";", "{\n    string[] arr = new string[string.length()];\n\
    \    int j = 0;\n    for(int i = 0; i < string.length(); ++i)\n    {\n       \
    \ arr[j] = string.substr(0, i);\n        ++j;\n    }\n    return arr;\n}\n</code>\n\
    <|/ a |>\n<| a tags=string,c#,algorithm dscore=1 |>\nHere is another simple solution\
    \ which is similar to Kirill's answer:\n<code>\nstring input = Console.ReadLine();\n\
    var result = new List<string>();\nvar prefixes = input.ToLower().Select(x => x.Substring(0,\
    \ 1).ToLower()).ToArray();\nforeach (var item in prefixes)\n{\n    if (input.Contains(item))\n\
    \    {\n        var index = Array.IndexOf(input, item);\n        if (index ==\
    \ 0)\n        {\n            continue;\n        }\n        result.Add(string.Concat(new\
    \ string[] { input.Substring(0, index), item }));\n    }\n}\nConsole.WriteLine(string.Join(\"\
    ,\", result));\n</code>\n<|/ a |>\n<| a tags=string,c#,algorithm |>\n<code>\n\
    string input = \"string\";\nvar list = new List<string>();\nforeach (var c in\
    \ input)\n{\n    list.Add(c.ToString() + input.Substring(c.ToString().Length));\n\
    }\nConsole.WriteLine(list.ToArray().ToString());\n</code>\n<|/ a dscore=1 |>\n\
    <| a |>\n<code>\nstring input = \"string\";\nvar list = new List<string>();\n\
    foreach (var c in input)\n{\n    list.Add(string.Concat(new string[] { c, input.Substring(c.ToString().Length)\
    \ }));\n}\nConsole.WriteLine(string.Join(\",\", list.ToArray()));\n</code>\n<|/\
    \ a tags=string,c#,algorithm dscore=1 |>\n<| a dscore=0 |>\n<code>\n        string\
    \ s = \"string\";\n        List<string> list = s.Select(c => c + s.Substring(c.Length)).ToList();\n\
    \        Console.WriteLine(string.Join(\",\", list));\n</code>\n<|/ a tags=string,c#,algorithm\
    \ |>\n<| a dscore=0 |>\n<code>\nstring[] prefixes(string string){\n  string[]\
    \ arr = new string[string.length()];\n  int j = 0;\n  for(int i = 0; i < string.length();\
    \ ++i)\n  {\n    arr[j] = string.substr(0, i);\n    ++j;\n  }\n  return arr;\n\
    }\n</code>\n<|/ a tags=string,c#,algorithm |>\n<| c |>\nPlease add some explanation\
    \ to your answer.\n<|/ c |>\n<| a tags=string,c#,algorithm |>\n", "{\n    int\
    \ n = string.length();\n    char[] chars = string.ToCharArray();\n    \n    int\
    \ i = 0;\n    while(i < n && chars[i] == ' ') \n    {\n        i++;\n    }\n \
    \   \n    while(i < n) \n    {\n        if(chars[i] == ' ') \n        {\n    \
    \        i++;\n            continue;\n        }\n        \n        if(i < n -\
    \ 1 && chars[i + 1] == ' ') \n        {\n            chars[i] = '-';\n       \
    \     i++;\n            continue;\n        }\n        \n        while(i < n -\
    \ 1 && chars[i + 1] == chars[i]) \n        {\n            i++;\n        }\n  \
    \      \n        if(i < n - 1) \n        {\n            chars[i] = '-';\n    \
    \    }\n        \n        i++;\n    }\n    \n    List<string> res = new List<string>();\n\
    \    for(int i = 0; i < chars.length; i++) \n    {\n        if(chars[i] == '-')\
    \ \n        {\n            res.Add(chars.Substring(0, i));\n        }\n    }\n\
    \    \n    return res.ToArray();\n}\n</code>\n<|/ a tags=c#,string,prefix,linq,arrays\
    \ |>\n<| c |>\nThank you for the answer. I haven't tried it yet but looks good\
    \ :)\n<|/ c |>\n<| c |>\nIf there is only one word in the input, it's supposed\
    \ to return `[\"the\"]`.  But your algorithm returns `[\"the\", \"the\"]`.  So\
    \ I edited my answer to include the extra `if` statement to handle single word\
    \ input.\n<|/ c |>\n<| c |>\nIt's not my algorithm. It's someone else's.\n<|/\
    \ c |>\n<| a |>\nI assume that you want to return a list of prefixes from the\
    \ string that contain the most unique characters (the prefix with the most occurrences\
    \ of the characters).\n<code>\npublic static List<string> PrefixesContainingMostUniqueCharacters(string\
    \ string) \n{\n    int characters = 1;\n    int uniqueCharacters = 0;\n    foreach\
    \ (var s in string.Split(' '))\n    {\n        var uniqueChars = s.ToCharArray().Distinct().Count();\n\
    \        if (uniqueChars > uniqueCharacters)\n        {\n            characters\
    \ = uniqueChars;\n            uniqueCharacters = uniqueChars;\n        }\n   \
    \ }", "{\n    int[] chars = std.int[].of(string);\n    int prefix_len = length(string)\
    \ - 1;\n    int[] prefix = new int[prefix_len];\n    prefix[0] = chars[0];\n \
    \   int i, j, k;\n    bool done = true;\n    bool seen_zero = true;\n    while\
    \ (!done) {\n        done = false;\n        for (i = 1; i < prefix_len; i++) {\n\
    \            prefix[i] = chars[i];\n            k = i;\n            for (j = 0;\
    \ j < prefix_len; j++, k++) {\n                if (prefix[k] == chars[j]) {\n\
    \                    done = true;\n                    break;\n              \
    \  }\n            }\n            if (!done) {\n                break;\n      \
    \      }\n        }\n        if (done) {\n            break;\n        }\n    \
    \    for (i = prefix_len - 1; i >= 0; i--) {\n            prefix[i] = chars[prefix_len\
    \ - 1 - i];\n            k = i;\n            for (j = 0; j < prefix_len; j++,\
    \ k++) {\n                if (prefix[k] == chars[j]) {\n                    done\
    \ = true;\n                    break;\n                }\n            }\n    \
    \        if (!done) {\n                break;\n            }\n        }\n    \
    \    if (done) {\n            break;\n        }\n        for (i = prefix_len -\
    \ 1; i >= 0; i--) {\n            prefix[i] = chars[i];\n            k = i;\n \
    \           for (j = 0; j < prefix_len; j++, k++) {\n                if (prefix[k]\
    \ == chars[j]) {\n                    done = true;\n                    break;\n\
    \                }\n            }\n            if (!done) {\n                break;\n\
    \            }\n        }\n        if (done) {\n            break;\n        }\n\
    \        if (!seen_zero) {\n            seen_zero = true;\n            for (i\
    \ = 0; i < prefix_len; i++) {\n                if (prefix[i] == 0) {\n       \
    \             break;\n                }\n            }\n        }\n    }\n   \
    \ string[] result = new string[prefix_len];\n    for (i = 0, j = 0; i < prefix_len;\
    \ i++) {\n        result[j] = prefix[i].toString();\n        j++;\n    }\n   \
    \ return result;\n}\n/*\n Return array of all prefixes from shortest to longest\
    \ of the input string\n    >>> all_prefixes(\"abcde\")\n    [\"a\", \"ab\", \"\
    abc\", \"abcd\", \"abcde\"]\n    \n*/\nstring[] all_prefixes(string string) \n\
    {\n    int[] chars = std.int[].of(string);\n    int prefix_len = length(string)\
    \ - 1;\n    int[] prefix = new int[prefix_len];\n    prefix[0] = chars[0];\n \
    \   int i, j, k;\n    bool done = true;\n    bool seen_zero = true;\n    while\
    \ (!done) {\n        done = false;\n        for (i = 1; i < prefix_len; i++) {\n\
    \            prefix[i] = chars[i];\n            k = i;\n            for (j = 0;\
    \ j < prefix_len; j++, k++) {\n                if (prefix[k] == chars[j]) {\n\
    \                    done = true;\n                    break;\n              \
    \  }\n            }\n            if (!done) {\n                break;\n      \
    \      }\n        }\n        if (done) {\n            break;\n        }\n    \
    \    for (i = prefix_len - 1; i >= ", "{\n    // Return value\n    List<string>\
    \ prefixes = new List<string>();\n    // Initialize variables\n    int n = string.Length;\n\
    \    int i = 0;\n    while (i < n) \n    {\n        // Find index of next character\
    \ starting from current index\n        i = string.IndexOfAny(_allValidPrefixes,\
    \ i);\n        // Check if prefix exists\n        if (i < 0) break;\n        //\
    \ Add prefix to result\n        prefixes.Add(string.Substring(i, _allValidPrefixes[i].Length));\n\
    \    }\n    // Return result\n    return prefixes;\n}\n// Define arrays of all\
    \ valid prefixes\nstatic string[] _allValidPrefixes = \"abc \".ToCharArray();\n\
    /*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"a\", \"bc\", \"c\"]\n    \n*/\nstring[]\
    \ all_suffixes(string string) \n{\n    // Return value\n    List<string> suffixes\
    \ = new List<string>();\n    // Initialize variables\n    int n = string.Length;\n\
    \    int i = 0;\n    while (i < n) \n    {\n        // Find index of next character\
    \ starting from current index\n        i = string.IndexOfAny(_allValidSuffixes,\
    \ i);\n        // Check if prefix exists\n        if (i < 0) break;\n        //\
    \ Add prefix to result\n        suffixes.Add(string.Substring(i, _allValidSuffixes[i].Length));\n\
    \    }\n    // Return result\n    return suffixes;\n}\n// Define arrays of all\
    \ valid suffixes\nstatic string[] _allValidSuffixes = \"abc \".ToCharArray();\n\
    /*\n Return array of all substrings with length at least k from shortest to longest\
    \ of the input string\n    >>> all_substrings(\"abracadabra\", 3)\n    [\"ab\"\
    , \"ac\", \"ad\", \"b\", \"br\", \"aca\", \"cad\", \"b\", \"ra\", \"car\", \"\
    ada\", \"raba\", \"carra\", \"cadar\", \"carrad\", \"arab\", \"rara\", \"carad\"\
    , \"rabad\"]\n    \n*/\nList<string> all_substrings(string string, int k) \n{\n\
    \    // Return value\n    List<string> substrings = new List<string>();\n    //\
    \ Initialize variables\n    int n = string.Length;\n    int i = 0;\n    while\
    \ (i < n) \n    {\n        // Find index of next character starting from current\
    \ index\n        i = string.IndexOfAny(_allValidSubstrings, i);\n        // Check\
    \ if prefix exists\n        if (i < 0) break;\n        // Add prefix to result\n\
    \        substrings.Add(string.Substring(i, _allValidSubstrings[i].Length));\n\
    \    }\n    // Return result\n    return substrings;\n}\n// Define arrays of all\
    \ valid substrings\n", "{\n    ArrayList result = new ArrayList();\n    Stack\
    \ st = new Stack();\n    for(int i=0;i<string.length;i++)\n    {\n        char\
    \ c = string.charAt(i);\n        if(st.isEmpty())\n        {\n            st.push(c);\n\
    \        }\n        else if(!st.isEmpty())\n        {\n            char last =\
    \ st.peek();\n            if(c == last)\n                st.pop();\n         \
    \   else st.push(c);\n        }\n        else\n        {\n            st.push(c);\n\
    \        }\n        if(st.isEmpty())\n        {\n            result.add(\"\");\n\
    \        }\n        else\n        {\n            string prefix = \"\";\n     \
    \       for(int j=0;j<st.getSize();j++)\n                prefix += st.pop();\n\
    \            result.add(prefix);\n        }\n    }\n    string[] array = new string[result.size()];\n\
    \    for(int i=0;i<result.size();i++)\n    {\n        array[i] = result.get(i);\n\
    \    }\n    return array;\n}", "{\n    std.string.char[] chars = string.chars;\n\
    \    string[] result = new string[chars.length];\n    for(int i = 0; i < chars.length;\
    \ ++i) {\n        result[i] = chars[chars.length - 1 - i];\n    }\n    return\
    \ result;\n}", "{\n    int n = string.length();\n    string[] res = new string[n\
    \ + 1];\n    \n    for(int i = 0; i < n; ++i) {\n        res[i] = string.substr(0,\
    \ i);\n    }\n    \n    res[n] = \"\";\n    \n    for(int i = n + 2; i <= string.length();\
    \ ++i) {\n        res[i] = string.substr(0, i - 1);\n    }\n    \n    return res;\n\
    }", "{\n    int result[] = new int[string.length];\n    int i = 0;\n    for (int\
    \ j = 1; j < string.length; j++)\n    {\n        if (string[j] == string[i])\n\
    \            result[j - 1]++;\n        else\n        {\n            result[j]\
    \ = 1;\n            i = j;\n        }\n    }\n    \n    string result = new string[result.length];\n\
    \    \n    for (int k = 0; k < result.length; k++)\n        result[k] = result[k]\
    \ < 2 ? \"\" : string.Substring(i, result[k]);\n    \n    return result;\n}\n\
    /*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"bc\", \"c\"]\n    \n*/\nstring[] all_suffixes(string\
    \ string)\n{\n    int result[] = new int[string.length];\n    int i = 0;\n   \
    \ for (int j = 1; j < string.length; j++)\n    {\n        if (string[j] == string[i])\n\
    \            result[j - 1]++;\n        else\n        {\n            result[j]\
    \ = 1;\n            i = j;\n        }\n    }\n    \n    string result = new string[result.length];\n\
    \    \n    for (int k = 0; k < result.length; k++)\n        result[k] = result[k]\
    \ < 2 ? \"\" : string.Substring(i + 1, result[k]);\n    \n    return result;\n\
    }", "{\n    var prefixes = new List<string>(string.length);\n    for(int i = 0;\
    \ i<string.length; ++i)\n        prefixes.Add(string.substring(0, i));\n    return\
    \ prefixes.ToArray();\n}\n/*\n Return array of all suffixes from shortest to longest\
    \ of the input string\n    >>> all_suffixes(\"abc\")\n    [\"c\", \"b\"]\n   \
    \ \n*/\nstring[] all_suffixes(string string) \n{\n    var suffixes = new List<string>(string.length);\n\
    \    for(int i = 0; i<string.length; ++i)\n        suffixes.Add(string.substring(i+1,\
    \ string.length));\n    return suffixes.ToArray();\n}\n/*\n Return array of all\
    \ suffixes from shortest to longest of the input string\n    >>> all_suffixes(\"\
    abc\")\n    [\"c\"]\n    \n*/\n/*\n Return array of all prefixes from shortest\
    \ to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"\
    ab\", \"abc\"]\n    \n*/\n/*\n Return array of all prefixes from shortest to longest\
    \ of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"\
    ]\n    \n*/\n/*\n Return array of all prefixes from shortest to longest of the\
    \ input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n\
    \    \n*/\n/*\n Return array of all prefixes from shortest to longest of the input\
    \ string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n\
    */\n/*\n Return array of all prefixes from shortest to longest of the input string\n\
    \    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\n/*\n Return\
    \ array of all prefixes from shortest to longest of the input string\n    >>>\
    \ all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\n/*\n Return array\
    \ of all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\n/*\n Return array of all prefixes\
    \ from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n\
    \    [\"a\", \"ab\", \"abc\"]\n    \n*/\n/*\n Return array of all prefixes from\
    \ shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n   \
    \ [\"a\", \"ab\", \"abc\"]\n    \n*/\n/*\n Return array of all prefixes from shortest\
    \ to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"",
  "{\n    string[] results = new string[string.length];\n    for(int i=0;i<string.length;i++)\n\
    \    {\n        results[results.length-1] = string[i];\n    }\n    for(int i=0;i<results.length;i++)\n\
    \    {\n        results[i] = results[i].substring(0, results[i].length-1);\n \
    \   }\n    return results;\n}\n/*\n Return array of all prefixes from shortest\
    \ to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"\
    ab\", \"abc\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    string[]\
    \ results = new string[string.length];\n    for(int i=0;i<string.length;i++)\n\
    \    {\n        results[results.length-1] = string[i];\n    }\n    for(int i=0;i<results.length;i++)\n\
    \    {\n        results[i] = results[i].substring(0,results[i].length-1);\n  \
    \  }\n    return results;\n}\n/*\n Return array of all prefixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"abc\"\
    , \"b\", \"c\"]\n    \n*/\nstring[] all_suffixes_prefix(string string) \n{\n \
    \   string[] results = new string[string.length];\n    for(int i=0;i<string.length;i++)\n\
    \    {\n        results[results.length-1] = string[i];\n    }\n    for(int i=0;i<results.length;i++)\n\
    \    {\n        results[i] = results[i].substring(0,results[i].length-1);\n  \
    \  }\n    return results;\n}\n/*\n Return array of all suffixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"abc\"\
    , \"b\", \"c\"]\n    \n*/\nstring[] all_prefixes_suffix(string string) \n{\n \
    \   string[] results = new string[string.length];\n    for(int i=0;i<string.length;i++)\n\
    \    {\n        results[results.length-1] = string[i];\n    }\n    for(int i=0;i<results.length;i++)\n\
    \    {\n        results[i] = results[i].substring(0,results[i].length-1);\n  \
    \  }\n    return results;\n}\n/*\n Return true if string is equal to another string\n\
    \    >>> equal(\"\",\"\")\n    True\n    >>> equal(\"abc\",\"abc\")\n    True\n\
    \    >>> equal(\"a\",\"b\")\n    False\n*/", "{\n    size_t length = string.length();\n\
    \    size_t resultLength = length;\n    string[] result = new string[length];",
  "{\n  int[] prefixLengths = new int[string.length];\n  for (int i=0;i<string.length;i++)\
    \ {\n    prefixLengths[i] = string[i].length;\n  }\n  \n  int[] sortedPrefixLengths\
    \ = prefixLengths.sort();\n  \n  string[] result = new string[prefixLengths.maxIndex()];\n\
    \  for (int i = 0; i < prefixLengths.maxIndex(); ++i) {\n    int j = prefixLengths.indexOfLast(sortedPrefixLengths);\n\
    \    result[i] = string.substring(0,j+1);\n  }\n  \n  return result;\n}", "{\n\
    \    string[] result=new string[string.Length];\n    for(int i=0;i<string.Length;i++)\n\
    \    {\n        result[i]=string.Substring(0,i);\n    }\n    return result;\n}",
  "{\n    var ret = new string[string.length];\n    for (var i = string.length - 1;\
    \ i >= 0; i--) \n    {\n        ret[i] = string[i] + (string.length - i - 1);\n\
    \    }\n    return ret;\n}\n/*\n Return array of all suffixes from shortest to\
    \ longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"b\", \"bc\"\
    , \"c\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    var ret = new\
    \ string[string.length];\n    for (var i = string.length - 1; i >= 0; i--) \n\
    \    {\n        ret[i] = (string.length - i - 1) + string[i];\n    }\n    return\
    \ ret;\n}\n/*\n Return array of all substrings of input string separated by delimiter\n\
    \    delimiter: string; \"char\" or \"string\", default \",\" (comma)\n    separator:\
    \ string; \"char\" or \"string\", default \"|\" (vertical bar)\n    \n    >>>\
    \ all_substrings(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n    >>> all_substrings(\"\
    abc\", \"|\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_substrings(string\
    \ string, char delimiter, string separator) \n{\n    var ret = new string[string.length];\n\
    \    for (var i = 0, s = string.length; i < s; i++) \n    {\n        ret[i] =\
    \ string[i] + string[i++];\n    }\n    return ret;\n}\n/*\n Return array of all\
    \ substrings of input string separated by delimiter\n    delimiter: string; \"\
    char\" or \"string\", default \",\"\n    separator: string; \"char\" or \"string\"\
    , default \"|\"\n    \n    >>> all_substrings(\"abc\", \"|\")\n    [\"a\", \"\
    ab\", \"abc\"]\n    \n*/\nstring[] all_substrings(string string, char delimiter\
    \ = ',') \n{\n    return all_substrings(string, delimiter, delimiter);\n}\n/*\n\
    \ Return array of all substrings of input string separated by delimiter\n    delimiter:\
    \ string; \"char\" or \"string\", default \",\"\n    separator: string; \"char\"\
    \ or \"string\", default \"|\"\n    \n    >>> all_substrings(\"abc\", \"|\")\n\
    \    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_substrings(string string,\
    \ char delimiter = ',', char separator = '|') \n{\n    return all_substrings(string,\
    \ delimiter, separator);\n}\n/*\n Return array of all substrings of input string\
    \ separated by delimiter\n    delimiter: string; \"char\" or \"string\", default\
    \ \",\"\n    separator: string; \"char\" or \"string\", default \"|\"\n    \n\
    \    >>> all_substrings(\"abc\", \"|\")\n    [\"a\", \"ab\", \"abc\"]\n    \n\
    */\nstring[] ", "{\n    string[] array = new string[string.Length];\n    for (int\
    \ i = 0; i < string.Length; i++)\n    {\n        array[i] = string.Substring(0,\
    \ i);\n    }\n    sort(array, (x, y) => stringCompare(x, y));\n    return array;\n\
    }\n/*\n Return array of all prefixes from shortest to longest of the input string\n\
    \    >>> all_prefixes(\"ab\")\n    [\"a\", \"ab\"]\n    \n*/\nstring[] all_prefixes(string\
    \ string, int length) \n{\n    string[] array = new string[length];\n    for (int\
    \ i = 0; i < length; i++)\n    {\n        array[i] = string.Substring(0, i);\n\
    \    }\n    sort(array, (x, y) => stringCompare(x, y));\n    return array;\n}\n\
    /*\n Return array of all prefixes from shortest to longest of the input string\n\
    \    >>> all_prefixes(\"ab\", 1)\n    [\"ab\"]\n    \n*/\nstring[] all_prefixes(string\
    \ string, int length, int start) \n{\n    string[] array = new string[length];\n\
    \    for (int i = start; i < length; i++)\n    {\n        array[i] = string.Substring(0,\
    \ i);\n    }\n    sort(array, (x, y) => stringCompare(x, y));\n    return array;\n\
    }\n/*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"bc\", \"c\", \"cba\"]\n    \n*/\nstring[]\
    \ all_suffixes(string string) \n{\n    string[] array = new string[string.Length];\n\
    \    for (int i = 0; i < string.Length; i++)\n    {\n        array[i] = string.Substring(i);\n\
    \    }\n    sort(array, (x, y) => stringCompare(x, y));\n    return array;\n}\n\
    /*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"ab\")\n    [\"a\", \"ab\"]\n    \n*/\nstring[] all_suffixes(string\
    \ string, int length) \n{\n    string[] array = new string[length];\n    for (int\
    \ i = 0; i < length; i++)\n    {\n        array[i] = string.Substring(i);\n  \
    \  }\n    sort(array, (x, y) => stringCompare(x, y));\n    return array;\n}\n\
    /*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"ab\", 1)\n    [\"ab\"]\n    \n*/\nstring[] all_suffixes(string\
    \ string, int length, int start) \n{\n    string[] array = new string[length];\n\
    \    for (int i = start; i < length; i++)\n    {\n        array[i] = string.Substring(i);\n\
    \    }\n    sort(array, (x, y) => stringCompare(x, ", "{\n   \n    string longestPrefix\
    \ = \"\";\n    foreach(char c in string) \n    {\n      if (c == '_') continue;\n\
    \      if (longestPrefix.Length > c.Length) \n      {\n         longestPrefix\
    \ = c;\n      }\n      \n      if (c == string.LastIndexOf(c)) \n      {\n   \
    \      return new[] {longestPrefix};\n      }\n    }\n    \n    \n    // TODO:\
    \ remove this line when this bug is fixed\n    throw new Exception(\"Error finding\
    \ prefixes\");\n}", "{\n    Vector<string> result = new Vector<string>(string.length());\n\
    \    for(int i = 0, len = string.length(); i < len; ++i)\n    {\n        result.append(string);\n\
    \        result.append(Character.toString(string.charAt(i)));\n    }\n    \n \
    \   sort(result);\n    \n    int i = 0;\n    while(i < result.length())\n    {\n\
    \        while(i < result.length() && result[i] == result[i + 1])\n        {\n\
    \            ++i;\n        }\n        \n        if(i >= result.length())\n   \
    \     {\n            break;\n        }\n        \n        result[i] = result[i].substring(0,\
    \ result[i].length() - 1);\n        ++i;\n    }\n    \n    return result.toArray();\n\
    }\n</code>\n<|/ a tags=string,algorithm,arrays,c++,prefix dscore=5 |>\n<| c |>\n\
    `int i = string.size() - 1; i >= 0; --i` is more idiomatic. Of course, one could\
    \ use `std::reverse` for the `for` loop (since C++11).\n<|/ c |>\n<| c |>\nThis\
    \ one is a bit better in that it is still O(n) while mine is O(n log n). Yours\
    \ is O(n^2) though, but that doesn't matter as much in practice.\n<|/ c |>\n<|\
    \ c |>\nI agree with you on that. It's a matter of taste though. With this one\
    \ we could also make it O(n).\n<|/ c |>\n<| c |>\n`string.length()` returns number\
    \ of elements in a `std::string`, so it should be `string.length() - 1` right?\n\
    <|/ c |>\n<| a tags=string,algorithm,arrays,c++,prefix |>\nHere is a naive implementation\
    \ for prefix finding algorithm which gives O(n) runtime complexity, \n<code>\n\
    #include <iostream>\n#include <string>\nusing namespace std;", "{\n    string\
    \ prefix = \"\";\n    char[] chars = string.ToCharArray();\n    int i = 0;\n \
    \   while (i < chars.Length)\n    {\n        prefix = chars.Substring(i, prefix.Length);\n\
    \        i = chars.IndexOfAny(chars, i+1, chars.Length);\n        char[] chars2\
    \ = chars.Substring(i+1, chars.Length-i);\n        char[] chars3 = chars.Substring(0,\
    \ i);\n        char[] chars4 = chars.Substring(0, i+1);\n        \n        if(prefix.Length\
    \ != chars2.Length)\n            chars2 = chars2.Insert(prefix.Length, chars2[0]);\n\
    \        if(prefix.Length != chars3.Length)\n            chars3 = chars3.Insert(prefix.Length,\
    \ chars3[0]);\n        if(prefix.Length != chars4.Length)\n            chars4\
    \ = chars4.Insert(prefix.Length, chars4[0]);\n        \n        char[] chars5\
    \ = chars2 + chars3 + chars4;\n        \n        string prefix2 = chars5.ToString();\n\
    \        char[] chars6 = prefix2.ToCharArray();\n        \n        prefixes.Add(prefix2);\n\
    \    }\n    return prefixes.ToArray();\n}\n/*\n Return all prefixes and suffixes\
    \ from shortest to longest of the input string\n    >>> all_prefixes_suffixes(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes_suffixes(string\
    \ string) \n{\n    string prefix = \"\";\n    char[] chars = string.ToCharArray();\n\
    \    int i = 0;\n    while (i < chars.Length)\n    {\n        prefix = chars.Substring(i,\
    \ prefix.Length);\n        i = chars.IndexOfAny(chars, i+1, chars.Length);\n \
    \       char[] chars2 = chars.Substring(i+1, chars.Length-i);\n        char[]\
    \ chars3 = chars.Substring(0, i);\n        char[] chars4 = chars.Substring(0,\
    \ i+1);\n        \n        if(prefix.Length != chars2.Length)\n            chars2\
    \ = chars2.Insert(prefix.Length, chars2[0]);\n        if(prefix.Length != chars3.Length)\n\
    \            chars3 = chars3.Insert(prefix.Length, chars3[0]);\n        if(prefix.Length\
    \ != chars4.Length)\n            chars4 = chars4.Insert(prefix.Length, chars4[0]);\n\
    \        \n        char[] chars5 = chars2 + chars3 + chars4;\n        \n     \
    \   string prefix2 = chars5.ToString();\n        char[] chars6 = prefix2.ToCharArray();\n\
    \        ", "{\n    string[] prefixes = new string[string.length()];\n    prefixes[0]\
    \ = \"\";\n    \n    for (int i = 0; i < string.length(); i++) {\n        prefixes[i\
    \ + 1] = prefixes[i] + string.chars[i];\n    }\n    \n    return prefixes;\n}\n\
    /*\n Return array of all prefixes from shortest to longest of the input string\n\
    \    >>> all_prefixes(\"abc-abc\")\n    [\"a\", \"ab\", \"abc\", \"abc-\", \"\
    abc-abc\"]\n    \n*/\nstring[] all_prefixes(string string, char delimiter) \n\
    {\n    string[] prefixes = new string[string.length()];\n    prefixes[0] = \"\"\
    ;\n    \n    for (int i = 0; i < string.length(); i++) {\n        string prefix\
    \ = prefixes[i] + string.chars[i];\n        if (string.chars[i] != delimiter)\
    \ prefix = string.chars[i] + prefix;\n        prefixes[i + 1] = prefix;\n    }\n\
    \    \n    return prefixes;\n}\n/*\n Return array of all prefixes from shortest\
    \ to longest of the input string\n    >>> all_prefixes(\"abc-abc-def-ghi-jkl\"\
    )\n    [\"a\", \"ab\", \"abc\", \"abc-\", \"abc-abc\", \"abc-abc-\", \"abc-abc-def\"\
    , \"abc-abc-def-\", \"abc-abc-def-ghi\", \"abc-abc-def-ghi-\", \"abc-abc-def-ghi-jkl\"\
    ]\n    \n*/\nstring[] all_prefixes(string string, char delimiter, char splitter)\
    \ \n{\n    string[] prefixes = new string[string.length()];\n    prefixes[0] =\
    \ \"\";\n    \n    for (int i = 0; i < string.length(); i++) {\n        string\
    \ prefix = prefixes[i] + string.chars[i];\n        if (string.chars[i] != delimiter)\
    \ prefix = string.chars[i] + prefix;\n        if (string.chars[i] == splitter)\
    \ prefix = string.chars[i] + prefix;\n        prefixes[i + 1] = prefix;\n    }\n\
    \    \n    return prefixes;\n}\n/*\n Return array of all prefixes from shortest\
    \ to longest of the input string\n    >>> all_prefixes(\"abc-abc-def-ghi-jkl\"\
    , splitter='-')\n    [\"a\", \"ab\", \"abc\", \"abc-\", \"abc-abc\", \"abc-abc-\"\
    , \"abc-abc-def\", \"abc-abc-def-\", \"abc-abc-def-ghi\", \"abc-abc-def-ghi-\"\
    , \"abc-abc-def-ghi-jkl\"]\n    \n*/\nstring[] all_prefixes(string string, char\
    \ delimiter, char splitter, char includeDelimiter) \n{", "{\n    int length =\
    \ string.length;\n    int n = std.string.find(string, \"a\", 0);\n    string[]\
    \ result = new string[length];\n    for (int i = 0; i <= n; i++) \n    {\n   \
    \     result[i - 1] = string.substring(i, i + 1);\n    }\n    return result;\n\
    }\n/* \n Return array of all prefixes from shortest to longest of the input string\n\
    \    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[]\
    \ all_prefixes(string string, char a) \n{\n    int length = string.length;\n \
    \   int n = std.string.find(string, a, 0);\n    string[] result = new string[length];\n\
    \    for (int i = 0; i <= n; i++) \n    {\n        result[i - 1] = string.substring(i,\
    \ i + 1);\n    }\n    return result;\n}\n/* \n Return array of all prefixes from\
    \ shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n   \
    \ [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string, char\
    \ a, char b) \n{\n    int length = string.length;\n    int n = std.string.find(string,\
    \ a, b);\n    string[] result = new string[length];\n    for (int i = 0; i <=\
    \ n; i++) \n    {\n        result[i - 1] = string.substring(i, i + 1);\n    }\n\
    \    return result;\n}\n/* \n Return array of all prefixes from shortest to longest\
    \ of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"\
    ]\n    \n*/\nstring[] all_prefixes(string string, char a, char b, char c) \n{\n\
    \    int length = string.length;\n    int n = std.string.find(string, a, b, c);\n\
    \    string[] result = new string[length];\n    for (int i = 0; i <= n; i++) \n\
    \    {\n        result[i - 1] = string.substring(i, i + 1);\n    }\n    return\
    \ result;\n}\n/* \n Return array of all prefixes from shortest to longest of the\
    \ input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n\
    \    \n*/\nstring[] all_prefixes(string string, char a, char b, char c, char d)\
    \ \n{\n    int length = string.length;\n    int n = std.string.find(string, a,\
    \ b, c, d);\n    string[] result = new string[length];\n    for (int i = 0; i\
    \ <= n; i++) \n    {\n        result[i - 1] = string.substring(i, i + 1);\n  \
    \  }\n    return result;\n}\n/* \n Return array of all prefixes from shortest\
    \ to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"\
    ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string, char a, char ",
  "{\n    int n = string.length();\n    \n    stack<string> st;\n    \n    st.push(string);\n\
    \    \n    string[] ret = new string[n];\n    \n    while (!st.empty()) {\n  \
    \      ret[st.top()] = \"\";\n        st.pop();\n    }\n    \n    return ret;\n\
    }\n/*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"c\"]\n    \n*/\nstring[] all_suffixes(string\
    \ string) \n{\n    int n = string.length();\n    \n    stack<string> st;\n   \
    \ \n    st.push(string);\n    \n    string[] ret = new string[n];\n    \n    while\
    \ (!st.empty()) {\n        string s = st.top();\n        st.pop();\n        ret[ret.length-1]\
    \ += s;\n    }\n    \n    return ret;\n}", "{\n    string[] result = new string[string.length];\n\
    \    for (int i = 0; i < string.length; ++i)\n    {\n        result[i] = string.substr(0,\
    \ i + 1);\n    }\n    return result;\n}", "{\n    Stack<string> prefixes = new\
    \ Stack<string>();\n    string s = string;\n    prefixes.Push(s);\n    \n    while\
    \ (prefixes.Count > 0)\n    {\n        s = prefixes.Pop();\n        for (int i\
    \ = 0; i <= s.length; i++)\n        {\n            string prefix = s.Substring(0,\
    \ i);\n            prefixes.Push(prefix);\n        }\n    }\n    \n    string[]\
    \ result = new string[prefixes.Count];\n    for (int i = 0; i < prefixes.Count;\
    \ i++)\n    {\n        result[i] = prefixes.Pop();\n    }\n    \n    return result;\n\
    }\n/*\n Return array of all prefixes from shortest to longest of the input string\n\
    \    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\n</code>\n\
    <|/ a tags=algorithm,string |>\n<| a tags=algorithm,string |>\nSince you know\
    \ the starting character, it's easy:\n<code>\nprivate static void PrintPrefix(string\
    \ s) {\n    Console.WriteLine(string.Join(\",\", s.TakeWhile(x => x != s[0])));\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis is the best answer. It is the fastest\
    \ in C#.\n<|/ c |>\n<| c |>\nIf you're writing this in C# you might as well write\
    \ it in an extension method. \n    public static string PrintPrefix(this string\
    \ s)\n    {\n        Console.WriteLine(string.Join(\",\", s.TakeWhile(x => x !=\
    \ s[0])));\n        return s;\n    }\n<|/ c |>\n<| a dscore=4 |>\nHere's an implementation\
    \ in JavaScript:\n<code>\nfunction prefixes(s) {\n    return s.split('').map((v,i)\
    \ => s.substr(0,i)).filter(Boolean);\n}\n</code>\n<|/ a tags=algorithm,string\
    \ |>\n<| c |>\nThis doesn't work for strings with multiple prefixes. For example\
    \ `\"test1234\"` will produce `[\"test\", \"1234\"]` instead of `[\"test\", \"\
    test1\", \"test12\", \"test123\", \"test1234\"]`. Not downvoting, but just wanted\
    \ to point that out.\n<|/ c |>\n<| c |>\n: It works, try it out. The result is\
    \ an array with a single element that is an array. The inner array contains all\
    \ the prefixes, e.g. `[\"test\", \"test1\", \"test12\", \"test123\", \"test1234\"\
    ]`.\n<|/ c |>\n<| c |>\nAh yes, I thought you were just showing what was returned.\
    \ You are right it does work. Sorry for the confusion. +1\n<|/ c |>\n<| a |>",
  "{\n    int n = string.length();\n    for(int i = 0; i < n; ++i)\n    {\n      \
    \  string prefix = string.substr(0, i);\n        for(int j = i; j < n; ++j)\n\
    \        {\n            string next = string.substr(0, j);\n            string\
    \ result = prefix+next;\n            if(all_prefixes.Contains(result))\n     \
    \       {\n                string last = result;\n                while(all_prefixes.Contains(last))\n\
    \                    last = last.RemoveLast(1);\n                string newLast\
    \ = last;\n                while(all_prefixes.Contains(newLast))\n           \
    \         newLast = newLast.RemoveLast(1);\n                string newLast2 =\
    \ newLast;\n                while(all_prefixes.Contains(newLast2))\n         \
    \           newLast2 = newLast2.RemoveLast(1);\n                string newLast3\
    \ = newLast2;\n                while(all_prefixes.Contains(newLast3))\n      \
    \              newLast3 = newLast3.RemoveLast(1);\n                string newLast4\
    \ = newLast3;\n                while(all_prefixes.Contains(newLast4))\n      \
    \              newLast4 = newLast4.RemoveLast(1);\n                string newLast5\
    \ = newLast4;\n                while(all_prefixes.Contains(newLast5))\n      \
    \              newLast5 = newLast5.RemoveLast(1);\n                string newLast6\
    \ = newLast5;\n                while(all_prefixes.Contains(newLast6))\n      \
    \              newLast6 = newLast6.RemoveLast(1);\n                string newLast7\
    \ = newLast6;\n                while(all_prefixes.Contains(newLast7))\n      \
    \              newLast7 = newLast7.RemoveLast(1);\n                string newLast8\
    \ = newLast7;\n                while(all_prefixes.Contains(newLast8))\n      \
    \              newLast8 = newLast8.RemoveLast(1);\n                string newLast9\
    \ = newLast8;\n                while(all_prefixes.Contains(newLast9))\n      \
    \              newLast9 = newLast9.RemoveLast(1);\n                string newLast10\
    \ = newLast9;\n                while(all_prefixes.Contains(newLast10))\n     \
    \               newLast10 = newLast10.RemoveLast(1);\n                string newLast11\
    \ = newLast10;\n                while(all_prefixes.Contains(newLast11))\n    \
    \                newLast11 = newLast11.RemoveLast(1);\n                string\
    \ newLast12 = newLast11;\n                while(all_prefixes.Contains(newLast12))\n\
    \                    newLast12 = newLast12.RemoveLast(1);\n                string\
    \ newLast13 = newLast12;\n                while(all_prefixes.Contains(newLast13))\n\
    \                    newLast13 = newLast13.RemoveLast(1);\n                string\
    \ newLast14 = newLast", "{\n\tint n = string.length;\n\tint min = 0;\n\t\n\tfor(int\
    \ i = 1; i < n; i++)\n\t{\n\t\tif(string[i] != string[0])\n\t\t{\n\t\t\tmin =\
    \ i;\n\t\t}\n\t}\n\t\n\tint index = 0;\n\tstring[] res = new string[n];\n\tres[0]\
    \ = string;\n\t\n\tfor(int i = min + 1; i < n; i++)\n\t{\n\t\tres[index] = string.Substring(i,\
    \ n - i);\n\t\tindex++;\n\t}\n\t\n\treturn res;\n}", "{\n    int[] counter = new\
    \ int[string.length];\n    foreach(var letter in string)\n    {\n        counter[letter]++;\n\
    \    }\n    var res = new string[counter.max];\n    foreach(var letter in string)\n\
    \    {\n        res[counter[letter] - 1] = letter;\n    }\n    return res;\n}\n\
    /*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"b\", \"bc\", \"c\"]\n    \n*/\nstring[]\
    \ all_suffixes(string string) \n{\n    int[] counter = new int[string.length];\n\
    \    foreach(var letter in string)\n    {\n        counter[string.lenght-letter-1]++;\n\
    \    }\n    var res = new string[counter.max];\n    foreach(var letter in string)\n\
    \    {\n        res[counter[string.lenght-letter-1]-1] = letter;\n    }\n    return\
    \ res;\n}\n/*\n Return array of all possible combinations from the array of input\
    \ strings\n    >>> all_combos\n    [\"abc\", \"def\"]\n    \n*/\nstring[] all_combos(string[]\
    \ array) \n{\n    var all = new string[array.max()];\n    foreach(var a in array)\n\
    \    {\n        foreach(var b in array)\n        {\n            foreach(var c\
    \ in array)\n            {\n                all[counter[a]+counter[b]+counter[c]]\
    \ = a + b + c;\n            }\n        }\n    }\n    return all;\n}\n/*\n Return\
    \ array of all possible combinations from the array of input strings\n    >>>\
    \ all_combos\n    [\"abc\", \"def\"]\n    \n*/\nstring[] all_combos(string[] array)\
    \ \n{\n    var all = new string[array.max()];\n    foreach(var a in array)\n \
    \   {\n        foreach(var b in array)\n        {\n            foreach(var c in\
    \ array)\n            {\n                all[counter[a]+counter[b]+counter[c]]\
    \ = a + b + c;\n            }\n        }\n    }\n    return all;\n}\n/*\n Return\
    \ array of all possible combinations from the array of input strings\n    >>>\
    \ all_combos\n    [\"abc\", \"def\"]\n    \n*/\nstring[] all_combos(string[] array)\
    \ \n{\n    var all = new string[array.max()];\n    foreach(var a in array)\n \
    \   {\n        foreach(var b in array)\n        {\n            foreach(var c in\
    \ array)\n            {\n                all[counter[a]+counter[b]+counter[c]]\
    \ = a + b + c;\n            }\n        }\n    }\n    return all;\n}\n/*\n Return\
    \ array of all possible combinations from the array of input strings", "{\n  \
    \  int[] result = new int[string.length];\n    int j = 0;\n    for(int i = 0;\
    \ i < string.length; i++) \n    {\n        result[i] = i;\n        if(string[i]\
    \ == '\\'') j++;\n        else j--;\n    }\n    ArrayList al = new ArrayList();\n\
    \    for(int i = 0; i < j; i++) \n    {\n        al.add(new string(string.Substring(result[i],1));\n\
    \        result[i]++;\n    }\n    al.add(new string(string.Substring(result[j],1));\n\
    \    return al.toArray();\n}", "{\n   vector<char> vector;\n   vector<char> prefixes;\n\
    \   for(int i = 0; i < string.length(); i++)\n   {\n      if(string.at(i) != '\\\
    0')\n         vector.push_back(string.at(i));\n      else\n      {\n         prefixes.push_back(vector[0]);\n\
    \         vector.clear();\n      }\n   }", "{\n    string[] result= new string[string.length];\n\
    \    for(int i=0; i<string.length; i++)\n    {\n        result[i] = string.substr(0,\
    \ i);\n    }\n    return result;\n}\n/*\n Return array of all suffixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"c\"]\n\
    \    \n*/\nstring[] all_suffixes(string string) \n{\n    string[] result= new\
    \ string[string.length];\n    for(int i=1; i<string.length; i++)\n    {\n    \
    \    result[i-1]= string.substr(i, string.length-i);\n    }\n    return result;\n\
    }\n/*\n Return array of all substrings of shortest to longest of the input string\n\
    \    >>> all_substrings(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[]\
    \ all_substrings(string string) \n{\n    string[] result= new string[string.length];\n\
    \    for(int i=0; i<string.length; i++)\n    {\n        result[i] = string.substr(0,\
    \ i) + string.substr(i, string.length-i) + string.substr(i+1, string.length-i);\n\
    \    }\n    return result;\n}\n/*\n Return array of all substrings of shortest\
    \ to longest of the input string with specific prefix\n    >>> all_substrings(\"\
    abc\", \"a\")\n    [\"ab\", \"abc\"]\n    \n*/\nstring[] all_substrings(string\
    \ string, string prefix)\n{\n    string[] result= new string[string.length];\n\
    \    for(int i=0; i<string.length; i++)\n    {\n        result[i] = string.substr(0,\
    \ i) + prefix + string.substr(i, string.length-i) + string.substr(i+1, string.length-i);\n\
    \    }\n    return result;\n}\n/*\n Return array of all substrings of shortest\
    \ to longest of the input string with specific suffix\n    >>> all_substrings(\"\
    abc\", \"c\")\n    [\"abc\"]\n    \n*/\nstring[] all_substrings(string string,\
    \ string suffix)\n{\n    string[] result= new string[string.length];\n    for(int\
    \ i=0; i<string.length; i++)\n    {\n        result[i] = string.substr(0, i) +\
    \ string.substr(i, string.length-i) + suffix;\n    }\n    return result;\n}\n\
    /*\n Return array of all substrings of shortest to longest of the input string\
    \ with specific prefix\n    >>> all_substrings(\"abc\", \"a\", \"c\")\n    [\"\
    abc\"]\n    \n*/\nstring[] all_substrings(string string, string prefix, string\
    \ suffix)\n{\n    string[] result= new string[string.length];\n    for(int i=0;\
    \ i<string.length; i++)\n    {\n        result[i] = string.substr(0, i) + prefix\
    \ + string.substr(i, string.length-i) + suffix;\n    }\n    return result;\n}",
  "{\n    string[] result = new string[string.Length];\n    int j = 0;\n    for (int\
    \ i = 0; i < string.Length; i++)\n    {\n        if (i < result.Length)\n    \
    \    {\n            result[j] = string.Substring(i, 1);\n            j++;\n  \
    \      }\n    }\n    return result;\n}", "{\n    string[] result = new string[string.length];\n\
    \    \n    for (int i = 0; i < string.length; i++)\n    {\n        result[i] =\
    \ \"\";\n        result[i] += string[i];\n        \n        for (; string.length\
    \ > i && string[i] != string[string.length-1]; i--)\n            result[i] +=\
    \ string[i];\n    }\n    return result;\n}", "{\n    int len = 0;\n    int i;\n\
    \    for(int i = 0; i < string.length; i++)\n    {\n        len += string[i];\n\
    \    }\n    string[] result = new string[len];\n    for(i = 0; i < string.length;\
    \ i++)\n    {\n        result[i] = string.substr(0, i);\n    }\n    return result;\n\
    }\n/*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"bc\", \"b\"]\n    \n*/\nstring[] all_suffixes(string\
    \ string) \n{\n    int len = 0;\n    int i;\n    for(int i = 0; i < string.length;\
    \ i++)\n    {\n        len += string[i];\n    }\n    string[] result = new string[len];\n\
    \    for(i = string.length - 1; i >= 0; i--)\n    {\n        result[i] = string.substr(i);\n\
    \    }\n    return result;\n}\n/*\n Return array of all substrings from shortest\
    \ to longest of the input string\n    >>> all_substrings(\"abc\")\n    [\"abc\"\
    ]\n    \n*/\nstring[] all_substrings(string string) \n{\n    string[] substrings\
    \ = new string[string.length()];\n    int min = 0;\n    int max = string.length()\
    \ - 1;\n    while(min < max)\n    {\n        int mid = (min + max) / 2;\n    \
    \    int midLength = string[mid].length;\n        for(int i = midLength; i <=\
    \ string.length; i++)\n        {\n            substrings[mid] = string.substr(0,\
    \ mid) + string.substr(i);\n            if(midLength < string[mid].length)\n \
    \           {\n                min = mid + 1;\n            }\n            else\
    \ if(midLength > string[mid].length)\n            {\n                max = mid\
    \ - 1;\n            }\n        }\n    }\n    return substrings;\n}\n/*\n Return\
    \ array of all permutations of input string with repetitions\n    >>> all_permutations(\"\
    abc\")\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n    \n*/\n\
    string[] all_permutations(string string) \n{\n    string[] result = new string[string.length()];\n\
    \    string s;\n    for(int i = 0; i < string.length(); i++)\n    {\n        s\
    \ = string.substr(0, i);\n        for(int j = 0; j < string.length(); j++)\n \
    \       {\n            s += string.substr(j);\n            result[j + i] = s;\n\
    \        }\n    }\n    return result;\n}\n/*\n Return array of all combinations\
    \ of input string with repetitions\n    >>> all_combinations(\"abc\")\n    [\"\
    abc\", \"ab\", \"ac\", \"ba\", \"bb\", \"bc\", \"ca\", \"cb\", \"cc\"]\n    \n\
    */\nstring[] all_combinations(string string) \n{\n    string[] ", "{\n\tList<string>\
    \ result = new List<string>();\n\tforeach(string str in string.length == string.Length\
    \ ? string : string.Reverse())\n\t{\n\t\tresult.add(str);\n\t}\n\treturn result.ToArray();\n\
    }\n/*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"abc\", \"a\", \"b\"]\n*/\nstring[] all_suffixes(string\
    \ string) \n{\n\tList<string> result = new List<string>();\n\tforeach(string str\
    \ in string.length == string.Length ? string : string.Reverse())\n\t{\n\t\tresult.Add(str.Substring(0,\
    \ str.Length - str.Count()));\n\t}\n\treturn result.ToArray();\n}\n/*\n Return\
    \ array of all adjacent substrings of shortest to longest of the input string\n\
    \    >>> all_sub(\"abc\")\n    [\"a\", \"ab\", \"abc\", \"b\", \"c\", \"ac\",\
    \ \"bca\", \"cab\", \"cba\"]\n*/\nstring[] all_sub(string string) \n{\n\tList<string>\
    \ result = new List<string>();\n\tforeach(string str in string.length == string.Length\
    \ ? string : string.Reverse())\n\t{\n\t\tresult.Add(str.Substring(0, str.Length\
    \ - str.Count(str => str == str.Substring(0, str.Length - str.Count()))));\n\t\
    }\n\treturn result.ToArray();\n}\n/*\n Return array of all prefixes of shortest\
    \ to longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"\
    ab\", \"abc\"]\n*/\nstring[] all_prefixes(string string, char character) \n{\n\
    \tList<string> result = new List<string>();\n\tforeach(string str in string.length\
    \ == string.Length ? string : string.Reverse())\n\t{\n\t\tresult.Add(str);\n\t\
    }\n\treturn result.ToArray();\n}\n/*\n Return array of all suffixes of shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"abc\"\
    , \"a\", \"b\"]\n*/\nstring[] all_suffixes(string string, char character) \n{\n\
    \tList<string> result = new List<string>();\n\tforeach(string str in string.length\
    \ == string.Length ? string : string.Reverse())\n\t{\n\t\tresult.Add(str.Substring(0,\
    \ str.Length - str.Count(str => str == str.Substring(0, str.Length - str.Count()))));\n\
    \t}\n\treturn result.ToArray();\n}\n/*\n Return array of all adjacent substrings\
    \ of shortest to longest of the input string\n    >>> all_sub(\"abc\")\n    [\"\
    a\", \"ab\", \"abc\", \"", "{\n    string[] result = new string[string.length];\n\
    \    char previous = ' ';\n    int i = 0;\n    while (i < string.length)\n   \
    \ {\n        char current = string[i];\n        int prefix_length = previous.length\
    \ + current.length;\n        result[i] = string.substr(0, prefix_length);\n  \
    \      previous = current;\n        i++;\n    }\n    \n    return result;\n}\n\
    /*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"c\", \"bc\", \"abc\"]\n    \n*/\nstring[]\
    \ all_suffixes(string string) \n{\n    string[] result = new string[string.length];\n\
    \    char previous = ' ';\n    int i = 0;\n    while (i < string.length)\n   \
    \ {\n        char current = string[i];\n        int prefix_length = previous.length\
    \ + current.length;\n        result[i] = string.substr(prefix_length, string.length\
    \ - prefix_length);\n        previous = current;\n        i++;\n    }\n    \n\
    \    return result;\n}\n/*\n Return array of all prefixes from shortest to longest\
    \ of the input string\n    >>> all_suffixes(\"abc\")\n    [\"abc\"]\n    \n*/\n\
    string[] all_suffixes(string string) \n{\n    string[] result = new string[string.length];\n\
    \    char previous = ' ';\n    int i = 0;\n    while (i < string.length)\n   \
    \ {\n        char current = string[i];\n        int prefix_length = previous.length\
    \ + current.length;\n        result[i] = string.substr(0, string.length - prefix_length);\n\
    \        previous = current;\n        i++;\n    }\n    \n    return result;\n\
    }\n/*\n Return array of all prefixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"abc\"]\n    \n*/\nstring[] all_suffixes(string\
    \ string) \n{\n    string[] result = new string[string.length];\n    char previous\
    \ = ' ';\n    int i = 0;\n    while (i < string.length)\n    {\n        char current\
    \ = string[i];\n        int prefix_length = previous.length + current.length;\n\
    \        result[i] = string.substr(prefix_length, string.length - prefix_length);\n\
    \        previous = current;\n        i++;\n    }\n    \n    return result;\n\
    }\n/*\n Return array of all prefixes from shortest to longest of the input string\n\
    \    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[]\
    \ all_prefixes(string string) \n{\n    string[] result = new string[string.length];\n\
    \    char previous = ' ';\n    int i = 0;\n    while (i < string.length)\n   \
    \ {\n        char current = string[i];\n        int prefix_length = previous.length",
  "{\n    int len = string.length;\n    if (len < 2) return new string[0];\n    string[]\
    \ prefix = new string[len];\n    for (int i = 0; i < len; ++i)\n        prefix[i]\
    \ = string.substr(0, i);\n    return prefix;\n}\n/*\n Return array of all prefixes\
    \ from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n\
    \    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string)\n\
    {\n    int len = string.length;\n    if (len < 2) return new string[0];\n    string[]\
    \ prefix = new string[len];\n    for (int i = 0; i < len; ++i)\n        prefix[i]\
    \ = string.substr(0, i);\n    return prefix;\n}\n/*\n Return array of all prefixes\
    \ from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n\
    \    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string)\n\
    {\n    int len = string.length;\n    if (len < 2) return new string[0];\n    string[]\
    \ prefix = new string[len];\n    for (int i = 0; i < len; ++i)\n        prefix[i]\
    \ = string.substr(0, i);\n    return prefix;\n}\n/*\n Return array of all prefixes\
    \ from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n\
    \    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string)\n\
    {\n    int len = string.length;\n    if (len < 2) return new string[0];\n    string[]\
    \ prefix = new string[len];\n    for (int i = 0; i < len; ++i)\n        prefix[i]\
    \ = string.substr(0, i);\n    return prefix;\n}", "{\n\tstring s = string;\n\t\
    string[] prefixes = new string[s.Length];", "{\n  var maxLen = string.length,\
    \ len = 1, prefix = \"\";\n  while (len <= maxLen)\n  {\n    prefix = string.substr(0,\
    \ len);\n    len++;\n  }\n  return string.Split('').Select(p => prefix+p).ToArray();\n\
    }", "{\n    int len = string.length, \n        max = -1;\n    for(int i=1; i<=len;\
    \ ++i)\n        if(string.charAt(i) != string.charAt(max-i)) \n        {\n   \
    \         max = i;\n        }\n    return string.chars().takeWhile((int c) =>\
    \ !string.charAt(max-i) == c).toArray();\n}\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ |>\nHere's a JavaScript implementation in ES6:", "{\n    size_t pos = 0;\n \
    \   size_t len = string.length;\n    string[] result = new string[len];\n    while(\
    \ pos < len )\n    {\n        result[pos] = string.substr(0, pos);\n        pos\
    \ = pos + 1;\n    }\n    return result;\n}", "{\n    int n = string.length();\n\
    \    int[] ans = new int[n];\n    for(int i=0; i<n; ++i)\n        ans[i] = i;\n\
    \    for(int i=n-1; i>0; --i)\n    {\n        for(int j=i-1; j>=0; --j)\n    \
    \    {\n            if(string[i]==string[j])\n                break;\n       \
    \ }\n        if(i==j)\n            break;\n        swap(ans[i],ans[j]);\n    }\n\
    \    string an = \"\";\n    for(int i=0; i<n; ++i)\n    {\n        an = string.substr(ans[i],\
    \ 1);\n        ans[ans.indexof(ans[i])] = i;\n    }\n    return Arrays.copyOf(ans,\
    \ ans.length);\n}", "{\n  var prefixes = new[] {\"\"};\n  for (int i = 0; i <\
    \ string.Length; ++i)\n  {\n    var prefix = prefixes.Last();\n    prefixes.Add(string[0]\
    \ + prefix);\n  }\n  return prefixes;\n}", "{\n    string[] array = string.Split(new\
    \ char[] { 'a' });\n    for (int i = 0; i < array.Length; i++)\n    {\n      \
    \  array[i] += '_';\n    }\n    return array;\n}", "{\n    int length = 0;\n \
    \   char[] charArray = string.to_char_array();\n    for (int i = 0; i < charArray.length;\
    \ i++)\n    {\n        length++;\n        if (charArray[i] == charArray[i + 1])\n\
    \        {\n            break;\n        }\n    }\n    charArray = charArray.slice(1,\
    \ length);\n    string result = \"\";\n    for (int i = 0; i < charArray.length;\
    \ i++)\n    {\n        result += charArray[i];\n    }\n    return result;\n}\n\
    /*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"b\", \"bc\", \"c\"]\n    \n*/\nstring[]\
    \ all_suffixes(string string) \n{\n    int length = 0;\n    char[] charArray =\
    \ string.to_char_array();\n    for (int i = 0; i < charArray.length; i++)\n  \
    \  {\n        length++;\n        if (charArray[i] == charArray[length - 1])\n\
    \        {\n            break;\n        }\n    }\n    charArray = charArray.slice(1,\
    \ length);\n    string result = \"\";\n    for (int i = 0; i < charArray.length;\
    \ i++)\n    {\n        result += charArray[i];\n    }\n    return result;\n}",
  "{\n    var result: Array = [];\n    for(int i = 0; i < string.length; ++i)\n  \
    \  {\n        for(int j = 0; j < result.length; ++j)\n        {\n            if(string.startsWith(result[j],\
    \ i))\n            {\n                result.add(string.substring(i, i + result[j].length));\n\
    \                i = i + result[j].length;\n                break;\n         \
    \   }\n        }\n    }\n    \n    return result;\n}\n</code>\n<|/ a tags=c#,algorithm,string\
    \ |>\n<| c |>\nThis is very slow - it takes about 50 seconds on my computer.\n\
    <|/ c |>\n<| c |>\n: Ohh my bad it was taking more time as compared to previous\
    \ answer. Thanks for noticing it.\n<|/ c |>\n<| c |>\nI think you mean `string\
    \ shortest = string.Concat(prefixes);` :-)\n<|/ c |>\n<| c |>\n: Thanks for catching\
    \ it.\n<|/ c |>\n<| a dscore=0 |>\nHere's a way to do it with LINQ.  It should\
    \ be relatively fast because it doesn't have to check a bunch of prefixes for\
    \ each character.\n<code>\nvar s = \"foobar\";\nvar prefixes = s.Select(x => x.ToString()).ToArray();\n\
    var prefixCount = prefixes.Distinct().Count();\nvar result = (Enumerable.Range(0,\
    \ s.Length)\n    .Where(x => x < prefixCount)\n    .SelectMany(x => prefixes.Take(x))\n\
    \    .Reverse()\n    .ToArray())\n    .Reverse();\n</code>\n<|/ a tags=c#,algorithm,string\
    \ |>\n<| c |>\nThis code is giving me the wrong result: it returns [\"fo\", \"\
    foo\", \"for\"] instead of [\"foo\", \"fo\", \"for\"]\n<|/ c |>\n<| c |>\nYeah,\
    \ that's probably because I used an arbitrary prefix count rather than finding\
    \ the right one by searching through the string for each character.\n<|/ c |>\n\
    <| c |>\nYeah, this is pretty horribly slow - takes about 50 seconds to run on\
    \ mine - I wonder if there is a faster way?\n<|/ c |>\n<| a dscore=0 |>\nHere\
    \ is my suggestion:\n<code>\nvar s = \"foofoo\";", "{\n    string str = \"\";\n\
    \    \n    //find the length of the string\n    long len = string.length();\n\
    \    \n    //return empty array if length <= 1\n    if (len <= 1)\n        return\
    \ \"\";\n    \n    //initialize an array to store all the prefixes\n    string[]\
    \ prefixes = new string[len];\n    \n    //initialize the first prefix\n    prefixes[0]\
    \ = string.substr(0, 1);\n    \n    //iterate through the rest of the string\n\
    \    for (int i = 2; i < len; i++) \n    {\n        //if the current character\
    \ is not the last one\n        if (i < len - 1)\n        {\n            //add\
    \ it to the first prefix\n            prefixes[i] = prefixes[i-1] + string.substr(0,\
    \ 1);\n        }\n        \n        //else the current character is the last one\
    \ \n        else\n        {\n            //then append the whole string\n    \
    \        prefixes[i] = string;\n        }\n    }\n    \n    return prefixes;\n\
    }", "{\n    std.string[] result = new std.string[string.length];\n    std.string[]\
    \ prefixes = new std.string[string.length];\n    \n    //initialize with all prefixes\
    \ of length 1\n    std.arraycopy(prefixes, 0, result, 0, prefixes.length);\n \
    \   \n    int iMax = string.length - 1;\n    \n    for (int i = 1; i< iMax; ++i)\n\
    \    {\n        std.arraycopy(prefixes, 0, result, i, prefixes.length);\n    \
    \    prefixes[i] = string + '0' + i;\n    }\n    \n    return result;\n}\n/*\n\
    \ Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"bc\", \"c\"]\n    \n*/\nstring[] all_suffixes(string\
    \ string) \n{\n    std.string[] result = new std.string[string.length];\n    std.string[]\
    \ suffixes = new std.string[string.length];\n    \n    //initialize with all suffixes\
    \ of length 1\n    std.arraycopy(suffixes, 0, result, 0, suffixes.length);\n \
    \   \n    int iMax = string.length - 1;\n    \n    for (int i = 1; i< iMax; ++i)\n\
    \    {\n        std.arraycopy(suffixes, 0, result, i, suffixes.length);\n    \
    \    suffixes[i] = string + '0' + i;\n    }\n    \n    return result;\n}", "{\n\
    \  string[] ret = new string[string.length];\n  int i = 0;\n  while (i < string.length)\
    \ \n  {\n    ret[i] = string.Substring(0, i);\n    i += ret[i].length + 1;\n \
    \ }\n  return ret;\n}\n</code>\nAnd you get an implementation like this:\n<code>\n\
    string[] all_prefixes(string string) \n{\n  return all_prefixes_impl(string.AsCharArray(),\
    \ 0, string.Length);\n}\n</code>\n<|/ a |>\n<| c |>\nThis does NOT return all\
    \ the prefixes in a given string\n<|/ c |>\n<| c |>\n-JinKim It does, I just tried\
    \ it.\n<|/ c |>\n<| c |>\nI edited your answer with a corrected version of my\
    \ code.\n<|/ c |>\n<| c |>\n-JinKim Great, thanks for the correction.\n<|/ c |>\n\
    <| a dscore=2 |>\nThis question isn't necessarily about STL (though many people\
    \ who come up with similar solutions probably come from STL).\nThe algorithmic\
    \ complexity is O(n).\n<code>\nfunction List<String> AllPrefixes(String s) {\n\
    \  var prefixes = [];\n  for (var i = 0; i < s.length; ++i) \n    for (var j =\
    \ i; j < s.length; ++j)\n      prefixes.push(s.substring(0, j));\n  return prefixes;\n\
    }\n</code>\nThis doesn't use any STL algorithms (except for looping).\n<|/ a tags=c#,algorithm\
    \ |>\n<| a |>\nI like the answer of Jeff House but in C# I would go with this\
    \ one:\n<code>\npublic static IEnumerable<string> AllPrefixes(string str)\n{\n\
    \    for (int i = 0; i < str.Length; i++)\n    {\n        yield return str.Substring(0,\
    \ i);\n    }\n}\n</code>\n<|/ a tags=c#,algorithm dscore=2 |>\n<| c |>\nYou don't\
    \ need the yield statement here because you have the full array as return value.\
    \ But nice answer\n<|/ c |>\n<| a tags=c#,algorithm |>\n<code>\npublic List<string>\
    \ GetAllPrefixes(string str)\n{\n    int len = str.Length;\n    List<string> ret\
    \ = new List<string>();\n    int counter = -1;", "{\n    return string[]._split(string,\
    \ true, null, true);\n}\n/*\n Return array of all suffixes from shortest to longest\
    \ of the input string\n    >>> all_suffixes(\"abc\")\n    [\"abc\", \"c\", \"\
    b\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    return string[]._split(string,\
    \ true, null, false);\n}\n/*\n Return array of all words from shortest to longest\
    \ of the input string\n    >>> all_words(string) \n    [\"abc\", \"b\", \"abc\"\
    ]\n    \n*/\nstring[] all_words(string string) \n{\n    return string[]._split(string,\
    \ true, null, true);\n}\n/*\n Return array of all substrings from shortest to\
    \ longest of the input string\n    >>> all_substrings(\"abc\")\n    [\"a\", \"\
    ab\", \"abc\"]\n    \n*/\nstring[] all_substrings(string string) \n{\n    return\
    \ string[]._split(string, true, null, false);\n}\n/*\n Return array of all prefixes\
    \ from shortest to longest of the input string\n    >>> all_substrings(\"abc\"\
    )\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_substrings(string string)\
    \ \n{\n    return string[]._split(string, true, null, true);\n}\n/*\n Return array\
    \ of all suffixes from shortest to longest of the input string\n    >>> all_substrings(\"\
    abc\")\n    [\"abc\", \"c\", \"b\"]\n    \n*/\nstring[] all_substrings(string\
    \ string) \n{\n    return string[]._split(string, true, null, false);\n}\n/*\n\
    \ Return array of all substrings from shortest to longest of the input string\n\
    \    >>> all_substrings(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[]\
    \ all_substrings(string string) \n{\n    return string[]._split(string, true,\
    \ null, true);\n}\n/*\n Return array of all substrings from shortest to longest\
    \ of the input string\n    >>> all_substrings(\"abc\")\n    [\"a\", \"ab\", \"\
    abc\"]\n    \n*/\nstring[] all_substrings(string string) \n{\n    return string[]._split(string,\
    \ true, null, true);\n}\n/*\n Return array of all substrings from shortest to\
    \ longest of the input string\n    >>> all_substrings(\"abc\")\n    [\"a\", \"\
    ab\", \"abc\"]\n    \n*/\nstring[] all_substrings(string string) \n{\n    return\
    \ string[]._split(string, true, null, true);\n}\n/*\n Return array of all substrings\
    \ from shortest to longest of the input string\n    >>> all_substrings(\"abc\"\
    )\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_substrings(string ", "{\n\
    \    string prefix = \"\";\n    int length = string.length;\n    \n    for(int\
    \ i = 0; i < length; ++i)\n    {\n        prefix += string[i];\n        \n   \
    \     if(i < length - 1)\n        {\n            string prefix2 = prefix + string[i+1];\n\
    \            \n            if(prefix2.length() > prefix.length())\n          \
    \  {\n                prefix = prefix2;\n            }\n        }\n    }\n   \
    \ \n    string[] result = new string[prefix.length()];\n    \n    for(int i =\
    \ 0; i < result.length; ++i)\n    {\n        result[i] = prefix;\n        \n \
    \       for(int j = i + 1; j < result.length; ++j)\n        {\n            result[i]\
    \ += string[j];\n        }\n    }\n    \n    return result;\n}", "{\n    if (string.empty())\n\
    \        return string[];\n    \n    stack<char> st;\n    \n    for (int i = 0;\
    \ i <= string.length(); i++)\n        st.push(string[i]);\n    \n    string s;\n\
    \    \n    string[] results = {\"\"};\n    while (!st.empty()) {\n        s =\
    \ tolower(st.top());\n        st.pop();\n        if (st.empty())\n           \
    \ results.push_back(s);\n        else {\n            string t = s;\n         \
    \   while (!st.empty() && tolower(st.top()) == tolower(t))\n                st.pop();\n\
    \            results.push_back(s);\n        }\n    }\n    \n    return results;\n\
    }\n/*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"bc\", \"c\", \"b\"]\n    \n*/\nstring[]\
    \ all_suffixes(string string) \n{\n    if (string.empty())\n        return string[];\n\
    \    \n    stack<char> st;\n    \n    for (int i = 0; i <= string.length(); i++)\n\
    \        st.push(string[i]);\n    \n    string s;\n    \n    string[] results\
    \ = {\"\"};\n    while (!st.empty()) {\n        s = tolower(st.top());\n     \
    \   st.pop();\n        if (st.empty())\n            results.push_back(s);\n  \
    \      else {\n            string t = s;\n            while (!st.empty() && tolower(st.top())\
    \ == tolower(t))\n                st.pop();\n            results.push_back(s);\n\
    \        }\n    }\n    \n    return results;\n}", "{\n    return array[0..(string.length\
    \ - 1)] of string;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks, I missed that\
    \ in the description. I've updated the post to reflect this.\n<|/ c |>\n<| c |>\n\
    Yes, that's what I meant, the length of the prefix is always the number of chars\
    \ in the input, I thought it was some kind of recursive definition. Thanks for\
    \ the code!\n<|/ c |>\n<| a dscore=2 |>\nThis solution takes into account the\
    \ length of prefixes and also the case where there are more than one possible\
    \ prefix length possible (for example \"ab\" and \"aa\")\n<code>\nimport std.algorithm:\
    \ join;\nimport std.array: array;\nimport std.conv: to;\nimport std.range: last;\n\
    import std.range: length;", "{\n    int[] counter = new int[string.length];\n\
    \    prefixes(string, counter);\n    \n    string[] result = new string[counter.max];\n\
    \    int i=0;\n    foreach(int c in counter)\n    {\n        result[i++] = c;\n\
    \    }\n    \n    return result;\n}", "{\n    var prefix = new string[string.length];\n\
    \    var current = 0;\n    \n    for (var i = 0, j = 0; i < string.length; i++)\n\
    \    {\n        if (string[i] == string[0])\n        {\n            prefix[j++]\
    \ = string.Substring(0, i);\n            current = i;\n        }\n    }\n    \n\
    \    for (int k = j - 1; k >= 0; k--)\n    {\n        prefix[k] = string.Substring(current\
    \ + 1, k);\n    }\n    \n    return prefix;\n}\n/*\n Return array of all suffixes\
    \ from shortest to longest of the input string\n    >>> all_suffixes(\"abc\")\n\
    \    [\"b\", \"bc\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string)\n\
    {\n    var prefix = new string[string.length];\n    var current = 0;\n    \n \
    \   for (var i = 0, j = 0; i < string.length; i++)\n    {\n        if (string[i]\
    \ == string[string.length - 1])\n        {\n            prefix[j++] = string.Substring(i,\
    \ string.length - i);\n            current = i;\n        }\n    }\n    \n    for\
    \ (int k = j - 1; k >= 0; k--)\n    {\n        prefix[k] = string.Substring(k,\
    \ string.length - k);\n    }\n    \n    return prefix;\n}\n/*\n Return array of\
    \ all common prefixes from shortest to longest of the input string\n    >>> all_commonprefixes(\"\
    abc\")\n    [\"a\", \"ab\"]\n    \n*/\nstring[] all_commonprefixes(string string)\n\
    {\n    var prefix = new string[string.length];\n    \n    var current = 0;\n \
    \   \n    for (var i = 0, j = 0; i < string.length; i++)\n    {\n        if (string[i]\
    \ == string[0])\n        {\n            prefix[j++] = string.Substring(0, i);\n\
    \            current = i;\n        }\n    }\n    \n    for (int k = j - 1; k >=\
    \ 0; k--)\n    {\n        prefix[k] = string.Substring(current + 1, k);\n    }\n\
    \    \n    return prefix;\n}\n/*\n Return array of all common suffixes from shortest\
    \ to longest of the input string\n    >>> all_commonsuffixes(\"abc\")\n    [\"\
    ab\", \"bc\"]\n    \n*/\nstring[] all_commonsuffixes(string string)\n{\n    var\
    \ prefix = new string[string.length];\n    \n    var current = 0;\n    \n    for\
    \ (var i = 0, j = 0; i < string.length; i++)\n    {\n        if (string[i] ==\
    \ string[string.length - 1])\n        {\n            prefix[j++] = string.Substring(i,\
    \ string.length - i);\n            current = i;\n        }\n    }\n    \n    for\
    \ (int k = j - 1; k >= 0; k--)\n    {\n        prefix[k] = string.Substring(k,\
    \ string.length - k);\n    }\n    \n    return prefix;\n}\n/*", "{\n    int n\
    \ = string.Length;\n    string[] result = new string[n];\n    int i=0;\n    while\
    \ (i < n) \n    {\n        result[i] = string.Substring(0, i); \n        i = i+1;\n\
    \    }\n    return result;\n}", "{\n    string[] prefixes = new string[std.array.size(string)];\n\
    \    for (int i = 0; i < std.array.size(string); i++) \n    {\n        if (string.length\
    \ == 0)\n            break;\n        string sub = string.slice(0, i).trim();\n\
    \        if (sub.length == 0)\n            break;\n        prefixes[i] = sub;\n\
    \    }\n    return prefixes;\n}\n/*\n Return array of all prefixes from longest\
    \ to shortest of the input string\n    >>> all_prefixes(\"abca\")\n    [\"a\"\
    , \"ab\", \"abc\", \"ac\"]\n    \n*/\nstring[] all_prefixes_reversed(string string)\
    \ \n{\n    string[] prefixes = new string[std.array.size(string)];\n    for (int\
    \ i = 0; i < std.array.size(string); i++) \n    {\n        if (string.length ==\
    \ 0)\n            break;\n        string sub = string.slice(-i).trim();\n    \
    \    if (sub.length == 0)\n            break;\n        prefixes[i] = sub;\n  \
    \  }\n    return prefixes;\n}\n/*\n Find longest common prefix\n    >>> longest_common_prefix(\"\
    abc\", \"ac\")\n    \"a\"\n    \n*/\nstring longest_common_prefix(string a, string\
    \ b)\n{\n    if (a.length < b.length)\n        return longest_common_prefix_reverse(a,\
    \ b);\n    if (b.length < a.length)\n        return longest_common_prefix_reverse(b,\
    \ a);\n    for (int i = 0; i < std.array.size(a); i++)\n        if (a[i] != b[i])\n\
    \            return a[i];\n    return a[0];\n}", "{\n    int len = string.length;\n\
    \    int min_len = len;\n    int max_len = len;\n    \n    for(int i=len-1;i>=0;i--)\n\
    \    {\n        max_len = max(max_len, len - i);\n        min_len = min(min_len,\
    \ len);\n        if(string[i] == \"_\")\n        {\n            string sub = string.subarray(len\
    \ - 1, len);\n            sub = sub + \"_\";\n            string sub2 = string.subarray(i,\
    \ len);\n            sub2 = sub2 + \"_\";\n            \n            if(sub ==\
    \ sub2)\n            {\n                array.push_back(sub);\n            }\n\
    \        }\n    }\n    \n    return array.array;\n}\n/*\n Return array of all\
    \ prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"\
    aaa\")\n    [\"a\"]\n    \n*/\nstring[] all_prefixes(string string) \n{\n    int\
    \ len = string.length;\n    int min_len = len;\n    int max_len = len;\n    \n\
    \    for(int i=len-1;i>=0;i--)\n    {\n        max_len = max(max_len, len - i);\n\
    \        min_len = min(min_len, len);\n        if(string[i] == \"_\")\n      \
    \  {\n            string sub = string.subarray(len - 1, len);\n            sub\
    \ = sub + \"_\";\n            string sub2 = string.subarray(i, len);\n       \
    \     sub2 = sub2 + \"_\";\n            \n            if(sub == sub2)\n      \
    \      {\n                array.push_back(sub);\n            }\n        }\n  \
    \  }\n    \n    return array.array;\n}\n/*\n Return array of all prefixes from\
    \ shortest to longest of the input string\n    >>> all_prefixes(\"aaa\")\n   \
    \ []\n    \n*/\nstring[] all_prefixes(string string) \n{\n    int len = string.length;\n\
    \    int min_len = len;\n    int max_len = len;\n    \n    for(int i=len-1;i>=0;i--)\n\
    \    {\n        max_len = max(max_len, len - i);\n        min_len = min(min_len,\
    \ len);\n        if(string[i] == \"_\")\n        {\n            string sub = string.subarray(len\
    \ - 1, len);\n            sub = sub + \"_\";\n            string sub2 = string.subarray(i,\
    \ len);\n            sub2 = sub2 + \"_\";\n            \n            if(sub ==\
    \ sub2)\n            {\n                array.push_back(sub);\n            }\n\
    \        }\n    }\n    \n    return array.array;\n}", "{\n    List<string> result\
    \ = new List<string>();\n    int len = string.Length;\n    for (int i = 1; i <=\
    \ len; i++)\n    {\n        result.Add(string.Substring(0, i));\n    }\n    return\
    \ result;\n}\n/*\n Return array of all prefixes from shortest to longest of the\
    \ input string\n    >>> all_prefixes(\"abba\")\n    [\"a\", \"ab\", \"abb\", \"\
    abba\"]\n    \n*/\nstring[] all_prefixes_d1(string string)\n{\n    List<string>\
    \ result = new List<string>();\n    int len = string.Length;\n    for (int i =\
    \ 1; i <= len; i++)\n    {\n        result.Add(string.Substring(0, i));\n    }\n\
    \    return result;\n}", "{\n    if (string.length < 2)\n    {\n        return\
    \ new[] {string};\n    }\n    \n    string firstTwoChars = string.Substring(0,\
    \ 2);\n    \n    var result = new[] {firstTwoChars};\n    \n    foreach(var pref\
    \ in all_prefixes(string.Substring(1, string.length)))\n    {\n        foreach(var\
    \ s in new[] {pref})\n        {\n            result.Add(s);\n        }\n    }\n\
    \    \n    return result;\n}", "{\n    int len = string.length();\n    string[]\
    \ result = new string[len];", "{\n    int len = string.length;\n    if(len < 2)\n\
    \    {\n        return string;\n    }\n    int i = 0;\n    int leng = len;\n \
    \   string[] result = new string[leng];\n    while(i < leng)\n    {\n        result[i]\
    \ = string.Substring(0, leng - 1);\n        i += 1;\n        leng -= 1;\n    }\n\
    \    return result;\n}", "{\n  assert(string.size() > 1);\n  \n  int n = string.size();\n\
    \  int prefixLength = string.size() - 1;\n  \n  string[] result = new string[n];\n\
    \  \n  prefixLength = Math.max(prefixLength, 1);\n  \n  int j = 0;\n  for(int\
    \ i = 0; i < n; i++, j++)\n  {\n    result[j] = string.substr(0, prefixLength);\n\
    \    \n    prefixLength = string.size() - i - 1;\n    \n    if(prefixLength ==\
    \ 0)\n      break;\n  }\n  \n  for(int i = 0; i < n; i++)\n  {\n    for(int j\
    \ = i + 1; j < n; j++)\n    {\n      string[] tmp = all_prefixes(result[j]);\n\
    \      \n      for(int k = 0; k < tmp.length; k++)\n        result[j] += tmp[k];\n\
    \    }\n  }\n  \n  return result;\n}\n/*\n Return array of all suffixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"c\", \"\
    bc\", \"abc\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n  assert(string.size()\
    \ > 1);\n  \n  int n = string.size();\n  int suffixLength = string.size() - 1;\n\
    \  \n  string[] result = new string[n];\n  \n  suffixLength = Math.max(suffixLength,\
    \ 1);\n  \n  int j = 0;\n  for(int i = n; i >= 0; i--, j--)\n  {\n    result[j]\
    \ = string.substr(0, suffixLength);\n    \n    suffixLength = string.size() -\
    \ i - 1;\n    \n    if(suffixLength == 0)\n      break;\n  }\n  \n  for(int i\
    \ = n; i >= 0; i--)\n  {\n    for(int j = i + 1; j < n; j++)\n    {\n      string[]\
    \ tmp = all_suffixes(result[j]);\n      \n      for(int k = 0; k < tmp.length;\
    \ k++)\n        result[j] += tmp[k];\n    }\n  }\n  \n  return result;\n}\n/*\n\
    \ Return array of all substrings of the input string from shortest to longest\
    \ of the input string\n    >>> all_substrings(\"abc\")\n    [\"a\", \"ab\", \"\
    abc\", \"b\"]\n    \n*/\nstring[] all_substrings(string string) \n{\n  assert(string.size()\
    \ > 1);\n  \n  int n = string.size();\n  \n  string[] result = new string[n];\n\
    \  \n  int j = 0;\n  for(int i = 0; i < n; i++)\n  {\n    result[j] = string.substr(0,\
    \ i);\n    \n    if(i == 0)\n      break;\n    \n    j++;\n  }\n  \n  return result;\n\
    }\n/*\n Return array of all permutations of input string\n    >>> all_permutations(\"\
    abc\")", "{\n    string[] result = new string[string.Length];\n    \n    for(int\
    \ i = 0; i < string.Length; i++)\n        result[i] = string.Substring(0, i);\n\
    \        \n    return result;\n}\n/*\n Return array of all suffixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"c\"]\n\
    \    \n*/\nstring[] all_suffixes(string string) \n{\n    string[] result = new\
    \ string[string.Length];\n    \n    for(int i = string.Length - 1; i >= 0; i--)\n\
    \        result[i] = string.Substring(i);\n        \n    return result;\n}\n/*\n\
    \ Return array of all substrings from shortest to longest of the input string\n\
    \    >>> all_substrings(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[]\
    \ all_substrings(string string) \n{\n    string[] result = new string[string.Length];\n\
    \    \n    for(int i = 0; i < string.Length; i++)\n        result[i] = string.Substring(i);\n\
    \        \n    return result;\n}\n/*\n Return array of all substring in original\
    \ input string from shortest to longest \n    of the input string\n    >>> all_substrings_in_string(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_substrings_in_string(string\
    \ string) \n{\n    string[] result = new string[string.Length];\n    \n    for(int\
    \ i = 0; i < string.Length; i++)\n        result[i] = string;\n        \n    return\
    \ result;\n}\n/*\n Return array of all substring in original input string from\
    \ shortest to longest \n    of the input string\n    >>> all_substrings_in_string_length(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_substrings_in_string_length(string\
    \ string) \n{\n    string[] result = new string[string.Length];\n    \n    for(int\
    \ i = 0; i < string.Length; i++)\n        result[i] = string.Substring(0, i);\n\
    \        \n    return result;\n}\n/*\n Return array of all substring in original\
    \ input string from shortest to longest \n    of the input string\n    >>> all_substrings_in_string_length(\"\
    abc\", 3)\n    [\"ab\", \"abc\"]\n    \n*/\nstring[] all_substrings_in_string_length_3(string\
    \ string) \n{\n    string[] result = new string[string.Length];\n    \n    for(int\
    \ i = 0; i < string.Length; i++)\n        result[i] = string.Substring(0, i);\n\
    \        \n    return result;\n}\n/*\n Return array of all substrings from shortest\
    \ to longest of the input string\n    >>> all_substrings(\"abc\", 2)\n    [\"\
    ab\", \"bc\", \"ca\", \"cb\"]\n    \n*/\nstring[] all_substrings(string string,\
    \ int length", "{\n    var array = new string[string.length];\n    for (int i\
    \ = 0; i < string.length; i++)\n    {\n        array[i] = string.Substring(0,\
    \ i);\n    }\n    return array;\n}\n/*\n Return array of all suffixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"b\", \"\
    bc\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    var array\
    \ = new string[string.length];\n    for (int i = string.length - 1; i >= 0; i--)\n\
    \    {\n        array[i] = string.Substring(i);\n    }\n    return array;\n}\n\
    /*\n Return an array of all possible prefixes of input string\n    >>> all_prefixes(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string)\n\
    {\n    return all_prefixes(string, string.Substring(0, string.Length - 1));\n\
    }\n/*\n Return array of all possible suffixes of input string\n    >>> all_suffixes(\"\
    abc\")\n    [\"b\", \"bc\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string)\n\
    {\n    return all_suffixes(string, string.Substring(0, string.Length - 1));\n}",
  "{\n    string prefixes = \"\";\n    int length = string.length();\n    int i =\
    \ 0;\n    while(i < length)\n    {\n        string current = string.subspan(i,\
    \ 1);\n        if(current.length == 0) \n            i += 1;\n        else \n\
    \        {\n            prefixes = prefixes + current;\n            i += 1;\n\
    \        }\n    }\n    \n    return prefixes.split('\\0');\n}", "{\n\tint[] array\
    \ = new int[string.Length];\n\tint[] prefixes = new int[string.Length];\n\tint\
    \ i = 0;\n\twhile (i < string.Length) {\n\t\tarray[i] = i;\n\t\tprefixes[i] =\
    \ i;\n\t\ti++;\n\t}\n\twhile (true) {\n\t\tint j = 0;\n\t\tfor (int k = 0; k <\
    \ string.Length; k++) {\n\t\t\tif (prefixes[k] == string.Length) {\n\t\t\t\tprefixes[k]\
    \ = j;\n\t\t\t\tj++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == string.Length)\
    \ break;\n\t\tarray[i] = j;\n\t\ti++;\n\t}\n\tstring[] results = new string[string.Length];\n\
    \tint k = 0;\n\tfor (int j = 0; j < string.Length; j++) {\n\t\tresults[k] = string.Substring(array[k],\
    \ prefixes[j]);\n\t\tk++;\n\t}\n\treturn results;\n}\n/*\n Return array of all\
    \ suffixes from shortest to longest of the input string\n    >>> all_suffixes(\"\
    abc\")\n    [\"abc\", \"b\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string)\
    \ \n{\n\tint[] array = new int[string.Length];\n\tint[] suffixes = new int[string.Length];\n\
    \tint i = 0;\n\twhile (i < string.Length) {\n\t\tarray[i] = string.Length - i;\n\
    \t\tsuffixes[i] = i;\n\t\ti++;\n\t}\n\twhile (true) {\n\t\tint j = 0;\n\t\tfor\
    \ (int k = 0; k < string.Length; k++) {\n\t\t\tif (suffixes[k] == string.Length)\
    \ {\n\t\t\t\tsuffixes[k] = j;\n\t\t\t\tj++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\
    \tif (j == string.Length) break;\n\t\tarray[i] = j;\n\t\ti++;\n\t}\n\tstring[]\
    \ results = new string[string.Length];\n\tint k = 0;\n\tfor (int j = 0; j < string.Length;\
    \ j++) {\n\t\tresults[k] = string.Substring(j, suffixes[j]);\n\t\tk++;\n\t}\n\t\
    return results;\n}\n/*\n Return array of all single letters of the input string\
    \ in all cases with prefixes and suffixes\n    >>> all_single_letters(\"abc\"\
    )\n    [\"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", \"abc\"]\n    \n*/\nstring[]\
    \ all_single_letters(string string) \n{\n\tstring[] results = new string[string.Length];\n\
    \tint[] prefixes = new int[string.Length];\n\tint[] suffixes = new int[string.Length];\n\
    \tint i = 0;\n\twhile (i < string.Length) {\n\t\tprefixes[i] = 0;\n\t\tsuffixes[i]\
    \ = string.Length - i;\n\t\tresults[i] = string.Substring(i).ToLower", "{\n  \
    \  List<string> result = new List<string>();\n    for (int i = 0; i < string.length;\
    \ i++)\n    {\n        char c = string[i];\n        for (int j = i; j < string.length;\
    \ j++)\n        {\n            char d = string[j];\n            if (c == d)\n\
    \            {\n                result.Add(string.Concat(new string[] { c, d }));\n\
    \            }\n        }\n    }\n    return result.ToArray();\n}\n/*\n Return\
    \ all substrings from shortest to longest of the input string\n    >>> all_substrings(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_substrings(string\
    \ string)\n{\n    List<string> result = new List<string>();\n    for (int i =\
    \ 0; i < string.length; i++)\n    {\n        string substring = string.Substring(i);\n\
    \        if (result.Contains(substring))\n            continue;\n        foreach\
    \ (string s in all_prefixes(string))\n        {\n            result.Add(string.Concat(new\
    \ string[] { substring, s }));\n        }\n    }\n    return result.ToArray();\n\
    }\n/*\n Return sum of all numbers in input string\n    >>> sum_numbers(\"123 456\
    \ 789\")\n    987\n*/", "{\n    string[] prefixes = { \"\", \"\" };\n    \n  \
    \  for(int i=0;i<string.length();i++) {\n        prefixes[1] += string[i];\n \
    \       prefixes[0] += string[i];\n    }\n    \n    for(int i=2;i<prefixes.length;i++)\
    \ {\n        prefixes[i] = prefixes[1] + prefixes[0];\n    }\n    \n    return\
    \ prefixes;\n}\n</code>\n<|/ a dscore=0 tags=c++,algorithm,string |>\n<| a tags=c++,algorithm,string\
    \ |>\nAs someone stated in comment a brute force algorithm is very inefficient.\
    \ If your purpose is just to learn algorithms, here are my solutions to your problem.",
  "{\n    int n = string.Length;\n    string prefix = string.Substring(0, 1);\n  \
    \  string[] result;\n    \n    if (n == 0) return new string[0];\n    \n    result\
    \ = new string[n];\n    \n    for (int i = 0; i < n; ++i) \n    {\n        result[i]\
    \ = prefix + (n - (i + 1));\n        prefix = prefix + string.Substring(i);\n\
    \    }\n    \n    return result;\n}\n/*\n Return all prefixes from shortest to\
    \ longest of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\"\
    , \"abc\"]\n    \n*/\nstring[] all_prefixes_v1(string string) \n{\n    int n =\
    \ string.Length;\n    string prefix = string.Substring(0, 1);\n    string[] result;\n\
    \    \n    if (n == 0) return new string[0];\n    \n    result = new string[n];\n\
    \    \n    for (int i = 0; i < n; ++i) \n    {\n        result[i] = prefix + (n\
    \ - (i + 1));\n        prefix = prefix + string.Substring(i);\n    }\n    \n \
    \   return result;\n}\n/*\n Return all prefixes from shortest to longest of the\
    \ input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n\
    \    \n*/\nList<string> all_prefixes_v2(string string) \n{\n    List<string> result\
    \ = new List<string>();\n    int n = string.Length;\n    string prefix = string.Substring(0,\
    \ 1);\n    \n    for (int i = 0; i < n; ++i)\n    {\n        result.Add(prefix\
    \ + (n - (i + 1)));\n        prefix = prefix + string.Substring(i);\n    }\n \
    \   \n    return result;\n}\n/*\n Return all prefixes from shortest to longest\
    \ of the input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"\
    ]\n    \n*/\nList<string> all_prefixes_v3(string string) \n{\n    int n = string.Length;\n\
    \    string prefix = string.Substring(0, 1);\n    List<string> result = new List<string>();\n\
    \    \n    for (int i = 0; i < n; ++i)\n    {\n        result.Add(prefix + (n\
    \ - (i + 1)));\n        prefix = prefix + string.Substring(i);\n    }\n    \n\
    \    return result;\n}\n/*\n Return all prefixes from shortest to longest of the\
    \ input string\n    >>> all_prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n\
    \    \n*/\nList<string> all_prefixes_v4(string string) \n{\n    int n = string.Length;\n\
    \    string prefix = string.Substring(0, 1);\n    List<string> result = new List<string>();\n\
    \    \n    for (int i = 0; i < n; ++i)\n    {\n        result.Add(prefix + (n\
    \ - (i + 1)));\n        prefix = ", "{\n    // create array to store prefixes\n\
    \    string[] result = new string[string.length];\n    int n = string.length;\n\
    \    int i = 0;\n    while (i<n) {\n        // copy prefix\n        result[i++]\
    \ = string.Substring(0, i);\n        // remove prefix\n        string = string.Substring(i);\n\
    \    }\n    return result;\n}\n/*\n Return array of all suffixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"b\", \"\
    c\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    // create\
    \ array to store suffixes\n    string[] result = new string[string.length];\n\
    \    int n = string.length;\n    int i = 0;\n    while (i<n) {\n        // copy\
    \ suffix\n        result[i++] = string.Substring(i+1, string.Length - i);\n  \
    \      // remove suffix\n        string = string.Substring(0, string.Length -\
    \ i);\n    }\n    return result;\n}\n/*\n Return array of all possible substrings\
    \ from shortest to longest of the input string\n    >>> all_substrings(\"abc\"\
    )\n    [\"a\", \"ab\", \"abc\", \"ab\", \"ac\", \"bc\", \"c\", \"abc\", \"b\"\
    ]\n    \n*/\nstring[] all_substrings(string string) \n{\n    // create array to\
    \ store substrings\n    string[] result = new string[string.length];\n    int\
    \ n = string.length;\n    int i = 0;\n    while (i<n) {\n        // copy substring\
    \ from i to n\n        result[i++] = string.Substring(i,n);\n        // remove\
    \ substring from i to n\n        string = string.Substring(0, i);\n    }\n   \
    \ return result;\n}\n/*\n Return array of all possible substrings of length k\
    \ from shortest to longest of the input string\n    >>> all_substrings(\"abc\"\
    , 2)\n    [\"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\", \"ab\", \"ac\", \"bc\"\
    ]\n    \n*/\nstring[] all_substrings(string string, int k) \n{\n    // create\
    \ array to store substrings\n    string[] result = new string[k];\n    int n =\
    \ string.length;\n    int i = 0;\n    while (i<k) {\n        // copy substring\
    \ from i to n\n        result[i++] = string.Substring(i,n);\n        // remove\
    \ substring from i to n\n        string = string.Substring(0, i);\n    }\n   \
    \ return result;\n}\n/*\n Return array of all possible substrings of length k\
    \ from shortest to longest of the input string\n    >>> all_substrings(\"abc\"\
    , 3)\n    [\"a\", \"ab\", \"ab\", \"abc\", \"b\", \"bc\", \"c\", \"ac\", \"bc\"\
    , \"c\", \"b\", \"bc\", \"c\", \"abc\"]\n    \n*/\nstring[] all_substrings(string\
    \ string, int k) \n{\n    // create array to ", "{\n   if(string.Length == 0)\n\
    \       return new string[] { \"\" };\n   var prefix = new string[string.Length];\n\
    \   prefix[0] = string[0];\n   for(int i = 1; i < prefix.Length; i++)\n   {\n\
    \       prefix[i] = prefix[i - 1] + string[i];\n   }\n   \n   return prefix;\n\
    }", "{\n\tint i;\n\tstring[] array = new string[(int)string.Length];\n\tfor (i\
    \ = 0; i < string.Length; i++)\n\t{\n\t\tarray[i] = string.Substring(0, i);\n\t\
    }\n\treturn array;\n}", "{\n\tstring[] array = string.Split(\" \");\n\tfor(int\
    \ i = 0; i < array.Length; i++)\n\t{\n\t\tstring prefix = \"\";\n\t\tfor(int j\
    \ = 0; j < i; j++)\n\t\t{\n\t\t\tprefix += array[j];\n\t\t}\n\t\tarray[i] = prefix;\n\
    \t}\n\treturn array;\n}\n/*\n Return array with all occurrences of substrings\
    \ array from shortest to longest of the input string\n    >>> all_occurrences(\"\
    abc abc abc\", \"abc\")\n    [\"abc\", \"abc abc\"]\n    \n*/\nstring[] all_occurrences(string\
    \ string, string[] array) \n{\n\tstring[] array = string.Split(\" \");\n\tfor(int\
    \ i = 0; i < array.Length; i++)\n\t{\n\t\tstring prefix = \"\";\n\t\tfor(int j\
    \ = 0; j < i; j++)\n\t\t{\n\t\t\tprefix += array[j];\n\t\t}\n\t\tarray[i] = prefix;\n\
    \t}\n\tfor(int i = 0; i < array.Length; i++)\n\t{\n\t\tfor(int j = 0; j < array.Length;\
    \ j++)\n\t\t{\n\t\t\tif(array[i] == array[j]) \n\t\t\t{\n\t\t\t\tif(j == array.Length\
    \ - 1)\n\t\t\t\t{\n\t\t\t\t\tstring newString = array[i] + \" \";\n\t\t\t\t\t\
    if(newString.Length > 0)\n\t\t\t\t\t\tnewString += \"$\";\n\t\t\t\t\treturn newString;\n\
    \t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\tstring newString = array[i] + \"\
    \ \";\n\t\t\t\t\tif(newString.Length > 0)\n\t\t\t\t\t\tnewString += \"$\";\n\t\
    \t\t\t\tstring newString2 = array[j] + \" \";\n\t\t\t\t\tif(newString2.Length\
    \ > 0)\n\t\t\t\t\t\tnewString2 += \"$\";\n\t\t\t\t\treturn newString + newString2;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}", "{\n\tif (string.length <=\
    \ 1)\n\t\treturn string[] {string};\n\t\n\tfor (int i = 0; i < string.length;\
    \ ++i)\n\t\tfor (int j = i; j < string.length; ++j)\n\t\t\tif (string[j] == string[i])\n\
    \t\t\t\treturn string[] {string[i], string.Substring(0,j)};\n\treturn string[]\
    \ {string};\n}", "{\n\tint len = string.length();\n\tint[] dp = new int[len +\
    \ 1];\n\tdp[0] = 0;\n\tfor(int i = 0; i <= len; i++)\n\t{\n\t\tfor(int j = 1;\
    \ j <= len; j++)\n\t\t{\n\t\t\tif(i + j < len)\n\t\t\t{\n\t\t\t\tstring s = string.Substring(i\
    \ + 1, j - i);\n\t\t\t\tdp[i + j] = Math.Max(dp[i + j], dp[i] + 1, dp[i + j +\
    \ 1] + 1);\n\t\t\t\tif(dp[i + j] == dp[i + 1])\n\t\t\t\t{\n\t\t\t\t\tdp[i + j]\
    \ = dp[i + j + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn Array[new string[len\
    \ + 1]](dp);\n}", "{\n    string[] result;\n    stringstream s(string);\n    copy(istream_iterator<string>(s),\n\
    \         istream_iterator<string>(),\n         back_inserter(result));\n    return\
    \ result;\n}", "{\n    List<string> result = new List<string>();\n    foreach(char\
    \ c in string)\n    {\n        if (c.isLetter())\n        {\n            string\
    \ s = c + \"a\";\n            result.AddRange( all_prefixes(s));\n        }\n\
    \        else\n        {\n            result.Add(c);\n        }\n    }\n    return\
    \ result.toArray();\n}\n/*\n Return array of all suffixes from shortest to longest\
    \ of the input string\n    >>> all_suffixes(\"abc\")\n    [\"ab\", \"c\", \"b\"\
    ]\n*/\nstring[] all_suffixes(string string) \n{\n    List<string> result = new\
    \ List<string>();\n    foreach(char c in string)\n    {\n        if (c.isLetter())\n\
    \        {\n            string s = c + \"a\";\n            result.AddRange( all_suffixes(s));\n\
    \        }\n        else\n        {\n            result.Add(c);\n        }\n \
    \   }\n    return result.toArray();\n}\n/*\n Return array of all unique prefixes\
    \ from shortest to longest of the input string\n    >>> all_unique_prefixes(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_unique_prefixes(string\
    \ string) \n{\n    List<string> result = new List<string>();\n    foreach(char\
    \ c in string)\n    {\n        if (c.isLetter())\n        {\n            string\
    \ s = c + \"a\";\n            result.AddRange( all_unique_prefixes(s));\n    \
    \    }\n        else\n        {\n            result.Add(c);\n        }\n    }\n\
    \    \n    for(int i = 0; i < result.Count; i++)\n    {\n        for(int j = i;\
    \ j < result.Count; j++)\n        {\n            string prefix = result[i];\n\
    \            string suffix = result[j];\n            bool isPresent = false;\n\
    \            foreach(char c in prefix)\n            {\n                isPresent\
    \ = prefix + c == suffix;\n                if (!isPresent)\n                 \
    \   break;\n            }\n            if(!isPresent)\n            {\n       \
    \         result.RemoveAt(i);\n                i--;\n            }\n        }\n\
    \    }\n    return result.toArray();\n}\n/*\n Return array of all unique suffixes\
    \ from shortest to longest of the input string\n    >>> all_unique_suffixes(\"\
    abc\")\n    [\"abc\", \"b\", \"c\"]\n    \n*/\nstring[] all_unique_suffixes(string\
    \ string) \n{\n    List<string> result = new List<string>();\n    foreach(char\
    \ c in string)\n    {\n        if (c.isLetter())\n        {\n            string\
    \ s = c + \"a\";\n            result.AddRange( all_unique_suffixes(s));\n    \
    \    }\n        else\n        {\n            result.Add(c);\n        }\n    }\n\
    \    \n    for(int i = 0; i < result.Count; i++)\n    {\n        ", "{\n    var\
    \ prefixes = new List<string>();\n    for (int i = string.length; i > 0; i--)\
    \ \n    {\n        string prefix = string.Substring(0, i);\n        prefixes.Add(prefix);\n\
    \    }\n    return prefixes.ToArray();\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=algorithm,c#,.net\
    \ |>\nI couldn't get the accepted answer to work with C# 7.0 which was the environment\
    \ I needed to use, so I came up with this:\n<code>\nstatic List<string> AllPrefixes(string\
    \ input)\n{\n    var prefixes = new List<string>();", "{\n    int length = string.length;\n\
    \    \n    string subString = \"\";\n    string[] prefixes = new string[length];\n\
    \    \n    for (int i = 0; i < length; i++) \n    {\n        subString = string.substring(i,\
    \ length);\n        prefixes[i] = subString;\n    }\n    \n    return prefixes;\n\
    }\n/*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"b\", \"bc\", \"c\"]\n    \n*/\nstring[]\
    \ all_suffixes(string string) \n{\n    int length = string.length;\n    \n   \
    \ string subString = \"\";\n    string[] suffixes = new string[length];\n    \n\
    \    for (int i = length; i >= 0; i--) \n    {\n        subString = string.substring(0,\
    \ i);\n        suffixes[i] = subString;\n    }\n    \n    return suffixes;\n}\n\
    /*\n Return array of all prefixes and suffixes from shortest to longest of the\
    \ input string\n    >>> all_prefixes_suffixes(\"abc\")\n    [[\"a\", \"b\", \"\
    c\"], [\"ab\", \"bc\", \"c\"]]\n    \n*/\ntuple<string[], string[]> all_prefixes_suffixes(string\
    \ string) \n{\n    int length = string.length;\n    \n    string subString = \"\
    \";\n    string[] prefixes = new string[length];\n    string[] suffixes = new\
    \ string[length];\n    \n    for (int i = 0; i < length; i++) \n    {\n      \
    \  subString = string.substring(i, length);\n        prefixes[i] = subString;\n\
    \        suffixes[length - (i + 1)] = subString;\n    }\n    \n    return tuple<string[],\
    \ string[]> (prefixes, suffixes);\n}\n/*\n Return array of prefixes from shortest\
    \ to longest of the input string\n    >>> prefixes(\"abc\")\n    [\"a\", \"ab\"\
    , \"abc\"]\n    \n*/\nstring[] prefixes(string string) \n{\n    int length = string.length;\n\
    \    \n    string subString = \"\";\n    string[] prefixes = new string[length];\n\
    \    \n    for (int i = 0; i < length; i++) \n    {\n        subString = string.substring(i,\
    \ length);\n        prefixes[i] = subString;\n    }\n    \n    return prefixes;\n\
    }\n/*\n Return array of suffixes from shortest to longest of the input string\n\
    \    >>> suffixes(\"abc\")\n    [\"b\", \"bc\", \"c\"]\n    \n*/\nstring[] suffixes(string\
    \ string) \n{\n    int length = string.length;\n    \n    string subString = \"\
    \";\n    string[] suffixes = new string[length];\n    \n    for (int i = length;\
    \ i >= 0; i--) \n    {\n", "{\n   Arrays.fill(prefixes, \"\");\n   prefixes[0]\
    \ = string;", "{\n    int[] a = new int[string.length];\n    for(int i = 0; i\
    \ < string.length; ++i)\n    {\n        a[i] = 0;\n    }\n    for(int i = 0; i\
    \ < string.length; ++i)\n    {\n        if(string[i] != '1')\n        {\n    \
    \        a[string[i] - '1'] = i;\n        }\n    }\n    int[] res = new int[a.length];\n\
    \    for(int i = 0; i < a.length; ++i)\n    {\n        res[i] = a[a[i]];\n   \
    \ }\n    return res;\n}", "{\n  int len = string.lenght;\n  string [] prefixes\
    \ = string.get_array();\n  prefixes[prefixes.length] = \"\";\n  while(prefixes.length\
    \ > 0)\n  {\n    int index = string.find(\"/\", prefixes.length);\n    int length\
    \ = string.lenght - index;\n    string new_prefix = string.subarray(prefixes.length,\
    \ index + 1);\n    prefixes[prefixes.length] = new_prefix;\n  }\n  return prefixes;\n\
    }", "{\n    string[] prefixes = new string[string.Length];\n    int prefix = 0;\n\
    \    int pos = 0;\n    while(pos < string.Length)\n    {\n        if (string.charAt(pos)\
    \ == string.charAt(prefix))\n        {\n            prefixes[prefix] = string.Substring(0,pos);\n\
    \            prefix = prefix+1;\n        }\n        pos = pos+1;\n    }\n    return\
    \ prefixes;\n}\n/*\n Return array of all suffixes from shortest to longest of\
    \ the input string\n    >>> all_suffixes(\"abc\")\n    [\"c\", \"ba\", \"abc\"\
    ]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    string[] suffixes =\
    \ new string[string.Length];\n    int suffix = 0;\n    int pos = string.Length\
    \ - 1;\n    while(pos >= 0)\n    {\n        if (string.charAt(pos) == string.charAt(suffix))\n\
    \        {\n            suffixes[suffix] = string.Substring(pos,string.Length\
    \ - 1 - suffix);\n            suffix = suffix-1;\n        }\n        pos = pos-1;\n\
    \    }\n    return suffixes;\n}\n/*\n Return array of all prefixes and suffixes\
    \ from shortest to longest of the input string\n    >>> all_prefixes_suffixes(\"\
    abc\")\n    [\"abc\", \"ab\", \"a\", \"bc\", \"b\", \"ca\", \"c\", \"ab\", \"\
    bc\", \"ac\", \"a\", \"c\", \"b\", \"ca\", \"b\", \"ac\", \"c\", \"ab\", \"ac\"\
    , \"bc\", \"abc\"]\n    \n*/\nstring[] all_prefixes_suffixes(string string) \n\
    {\n    string[] prefixes = new string[string.Length];\n    string[] suffixes =\
    \ new string[string.Length];\n    int prefix = 0;\n    int pos = 0;\n    int suffix\
    \ = 0;\n    while(pos < string.Length)\n    {\n        if (string.charAt(pos)\
    \ == string.charAt(prefix))\n        {\n            prefixes[prefix] = string.Substring(0,pos);\n\
    \            prefix = prefix+1;\n        }\n        pos = pos+1;\n    }\n    pos\
    \ = string.Length - 1;\n    while(pos >= 0)\n    {\n        if (string.charAt(pos)\
    \ == string.charAt(suffix))\n        {\n            suffixes[suffix] = string.Substring(pos,string.Length\
    \ - 1 - suffix);\n            suffix = suffix-1;\n        }\n        pos = pos-1;\n\
    \    }\n    return prefixes.Concat(suffixes);\n}\n/*\n Return array of all prefixes\
    \ and suffixes from shortest to longest of the input string\n    >>> all_prefixes_suffixes(\"\
    abc\")\n    [\"abc\", \"ab\", \"a\", \"bc\", \"b\", \"ca\", \"c\", \"ab\", \"\
    bc\", \"ac\", \"a\", \"c\", \"b\", \"ca\", \"b\", \"ac\", \"c\", \"ab\", \"ac\"\
    , \"bc\", \"abc\"]\n    \n*/", "{\n\tstring[] result = new string[string.size()];\n\
    \t\n\tfor (int i=0; i<string.size(); ++i)\n\t{\n\t\tresult[i] = string(string[i]);\n\
    \t}\n\t\n\tstring[] shortest = result;\n\t\n\tfor (int i=1; i<result.length; ++i)\n\
    \t{\n\t\tint j = shortest.length-1;\n\t\tstring temp = \"\";\n\t\twhile (j>=0\
    \ && (string[i] != shortest[j]))\n\t\t{\n\t\t\ttemp = shortest[j];\n\t\t\tshortest[j]\
    \ = string[i];\n\t\t\t--j;\n\t\t}\n\t\t\n\t\tshortest[j] = temp;\n\t}\n\t\n\t\
    return shortest;\n}", "{\n    int len = string.length;\n    string longest = \"\
    \";\n    string result = \"\";\n    \n    for(int i=0; i < len; i++)\n    {\n\
    \        result += string[i];\n        if(len > i)\n        {\n            if(\
    \ string[i].length() > longest.length() )\n                longest = string[i];\n\
    \        }\n    }\n    \n    for(int i=0; i < longest.length(); i++)\n    {\n\
    \        result += string[0] + longest.substring(i) ;\n    }\n    \n    return\
    \ string[](result, result);\n}\n/*\n Return array of all suffixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"abc\"\
    , \"b\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    int len\
    \ = string.length;\n    string longest = \"\";\n    string result = \"\";\n  \
    \  \n    for(int i=len-1; i>=0; i--)\n    {\n        result += string[i];\n  \
    \      if(len > i)\n        {\n            if( string[i].length() > longest.length()\
    \ )\n                longest = string[i];\n        }\n    }\n    \n    for(int\
    \ i=longest.length(); i>0; i--)\n    {\n        result += string[string.length()-1]\
    \ + longest.substring(i);\n    }\n    \n    return string[](result, result);\n\
    }\n/*\n Return array of all single chars from shortest to longest of the input\
    \ string\n    >>> all_single_chars(\"ab\")\n    [\"a\", \"b\"]\n    \n*/\nstring[]\
    \ all_single_chars(string string) \n{\n    string longest = \"\";\n    string\
    \ result = \"\";\n    \n    for(int i=0; i < string.length(); i++)\n    {\n  \
    \      if( string[i].length() > longest.length() )\n            longest = string[i];\n\
    \    }\n    \n    for(int i=0; i < longest.length(); i++)\n    {\n        result\
    \ += string[0] + longest.substring(i) ;\n    }\n    \n    return string[](result,\
    \ result);\n}\n/*\n Return array of all single chars from shortest to longest\
    \ of the input string\n    >>> all_single_chars(\"abc\")\n    [\"a\", \"b\", \"\
    c\"]\n    \n*/\nstring[] all_single_chars_suffix(string string) \n{\n    string\
    \ longest = \"\";\n    string result = \"\";\n    \n    for(int i=0; i < string.length();\
    \ i++)\n    {\n        if( string[i].length() > longest.length() )\n         \
    \   longest = string[i];\n    }\n    \n    for(int i=0; i < longest.length();\
    \ i++)\n    {\n        result += string[0] + longest.substring(i) ;\n    }\n \
    \   \n    return string[](result, result);\n}\n/*\n Return array of all single\
    \ chars from shortest to longest of the input string", "{\n  return string.find_prefixes\n\
    }\n/*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"abc\", \"b\", \"c\"]\n    \n*/\nstring[]\
    \ all_suffixes(string string) \n{\n  return string.find_suffixes\n}\n/*\n Return\
    \ array of all non-empty prefixes from shortest to longest of the input string\n\
    \    >>> all_non_prefixes(\"abc\")\n    [\"a\", \"bc\", \"c\"]\n    \n*/\nstring[]\
    \ all_non_prefixes(string string) \n{\n  return string.find_non_prefixes\n}\n\
    /*\n Return array of all non-empty suffixes from shortest to longest of the input\
    \ string\n    >>> all_non_suffixes(\"abc\")\n    [\"abc\", \"c\"]\n    \n*/\n\
    string[] all_non_suffixes(string string) \n{\n  return string.find_non_suffixes\n\
    }\n/*\n Return array of all occurrences of substr in the input string\n    >>>\
    \ occurrences(\"aaaba\", \"aa\")\n    [1, 2]\n    \n*/", "{\n    string[] prefixes\
    \ = { string.substr(0, string.size()) };\n    for (int i = 1; i < string.size();\
    \ i++)\n    {\n        prefixes[string.size() - i] = prefixes[string.size() -\
    \ i - 1] + string.substr(i, string.size() - i);\n    }\n    return prefixes;\n\
    }", "{\n  vector<string> prefixes;\n  if (string.empty()) \n    return prefixes;\n\
    \  string head = string;\n  while (head.size() > 1) {\n    prefixes.push_back(head);\n\
    \    head = head.substr(0, head.size() - 1);\n  }\n  prefixes.push_back(head);\n\
    \  return prefixes;\n}", "{\n\tint[] a = new int[string.length];\n\tfor(int i\
    \ = 0; i < a.length; i++)\n\t{\n\t\ta[i] = i;\n\t}\n\t\n\tint[] index = new int[a.length];\n\
    \tfor(int i = 0; i < a.length; i++)\n\t{\n\t\tindex[i] = i;\n\t}\n\t\n\tstack<int>\
    \ stack = new stack<int>();\n\tstack<int> indexStack = new stack<int>();\n\t\n\
    \twhile(!stack.empty())\n\t{\n\t\tint i = stack.top();\n\t\tstack.pop();\n\t\t\
    indexStack.pop();\n\t\t\n\t\twhile(indexStack.empty())\n\t\t{\n\t\t\tindexStack.push(index[i]);\n\
    \t\t\twhile(indexStack.top() != i)\n\t\t\t{\n\t\t\t\tindexStack.pop();\n\t\t\t\
    }\n\t\t\tindexStack.push(index[i]);\n\t\t\tint j = i - 1;\n\t\t\twhile(indexStack.top()\
    \ != j)\n\t\t\t{\n\t\t\t\tindexStack.pop();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(indexStack.top()\
    \ == i)\n\t\t\t{\n\t\t\t\tindexStack.pop();\n\t\t\t\tindexStack.push(i - 1);\n\
    \t\t\t\tint k = i + 1;\n\t\t\t\twhile(indexStack.top() != k)\n\t\t\t\t{\n\t\t\t\
    \t\tindexStack.pop();\n\t\t\t\t}\n\t\t\t\tindexStack.push(k);\n\t\t\t\tstack.push(k);\n\
    \t\t\t}\n\t\t\telse if(indexStack.top() == j)\n\t\t\t{\n\t\t\t\tindexStack.pop();\n\
    \t\t\t\tindexStack.push(k);\n\t\t\t\tint l = i - 1;\n\t\t\t\twhile(indexStack.top()\
    \ != l)\n\t\t\t\t{\n\t\t\t\t\tindexStack.pop();\n\t\t\t\t}\n\t\t\t\tindexStack.push(l);\n\
    \t\t\t\tstack.push(l);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tindexStack.pop();\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\tint[] result = new int[a.length];\n\tfor(int\
    \ i = 0; i < a.length; i++)\n\t{\n\t\tresult[i] = index[a.length - i - 1];\n\t\
    }\n\treturn result;\n}", "{\n    string[] result = new string[string.length()];\n\
    \    int i = 0;\n    while (i < string.length())\n    {\n        result[result.length]\
    \ = string.substr(0, i);\n        i += 1;\n    }\n    return result;\n}", "{\n\
    \  int n = string.length;\n  string[] r = new string[n];\n  \n  for(int i = 0;\
    \ i < n; ++i)\n    r[i] = string.Substring(0, i);\n  \n  return r;\n}\n/*\n Return\
    \ array of all suffixes from shortest to longest of the input string\n    >>>\
    \ all_suffixes(\"abc\")\n    [\"c\", \"\", \"bc\", \"abc\"]\n    \n*/\nstring[]\
    \ all_suffixes(string string) \n{\n  int n = string.length;\n  string[] r = new\
    \ string[n];\n  \n  for(int i = 0; i < n; ++i)\n    r[i] = string.Substring(i);\n\
    \  \n  return r;\n}\n/*\n Return array of all substrings starting from shortest\
    \ to longest of the input string\n    >>> all_substrings(\"abc\")\n    [\"abc\"\
    , \"bca\", \"cab\", \"cba\"]\n    \n*/\nstring[] all_substrings(string string)\
    \ \n{\n  int n = string.length;\n  string[] r = new string[n];\n  \n  for(int\
    \ i = 0; i < n; ++i)\n    r[i] = string.Substring(i * 2, (i + 1) * 2);\n  \n \
    \ return r;\n}\n/*\n Return array of all substrings starting from shortest to\
    \ longest of the input string\n    >>> all_substrings(\"abc\")\n    [\"abc\",\
    \ \"bca\", \"cab\", \"cba\"]\n    \n*/\nstring[] all_substrings(string string)\
    \ \n{\n  int n = string.length;\n  string[] r = new string[n];\n  \n  for(int\
    \ i = 0; i < n; ++i)\n    r[i] = string.Substring(i * 2, (i + 1) * 2);\n  \n \
    \ return r;\n}\n/*\n Return array of all substrings starting from shortest to\
    \ longest of the input string\n    >>> all_substrings(\"abc\")\n    [\"abc\",\
    \ \"bca\", \"cab\", \"cba\"]\n    \n*/\nstring[] all_substrings(string string)\
    \ \n{\n  int n = string.length;\n  string[] r = new string[n];\n  \n  for(int\
    \ i = 0; i < n; ++i)\n    r[i] = string.Substring(i * 2, (i + 1) * 2);\n  \n \
    \ return r;\n}\n/*\n Return array of all substrings starting from shortest to\
    \ longest of the input string\n    >>> all_substrings(\"abc\")\n    [\"abc\",\
    \ \"bca\", \"cab\", \"cba\"]\n    \n*/\nstring[] all_substrings(string string)\
    \ \n{\n  int n = string.length;\n  string[] r = new string[n];\n  \n  for(int\
    \ i = 0; i < n; ++i)\n    r[i] = string.Substring(i * 2, (i + 1) * 2);\n  \n \
    \ return r;\n}\n/*\n Return array of all ", "{\n    map<string,string> myMap;\n\
    \    foreach(string i in string) \n    {\n        string subString;\n        myMap.insert(pair<string,\
    \ string>(i, subString));\n    }\n    \n    string[] prefixes = new string[myMap.size()];\n\
    \    int i = 0;\n    foreach(map<string,string>::iterator it = myMap.begin();\
    \ it != myMap.end(); ++it) \n    {\n        string prefix;\n        prefix = it->first;\n\
    \        prefixes[i] = prefix;\n        i++;\n    }\n    return prefixes;\n}\n\
    /*\n Return array of all prefixes from shortest to longest of the input string\n\
    \    >>> all_prefixes(\"ab\")\n    [\"a\", \"b\"]\n    \n*/\n</code>\n<|/ a dscore=2\
    \ |>\n<| a |>\n<code>\nimport std.stdio;\nimport std.array;", "{\n    int n =\
    \ string.length;\n    string[] result = new string[n];\n    for (int i = 0; i\
    \ < n; ++i)\n    {\n        int j = i;\n        while (j < n && string[j] == string[i])\n\
    \        {\n            j++;\n        }\n        result[i] = string.substring(0,\
    \ j);\n    }\n    return result;\n}", "{\n  var result: Array = new Array();\n\
    \  var prefix = 0;\n  \n  foreach(var c in string){\n   result.push(string.SubString(prefix,\
    \ 1));\n   prefix = prefix + 1;\n  }\n  return result;\n}", "{\n\tstring[] res\
    \ = new string[string.Length];\n\tfor(int i=0; i<string.Length; i++)\n\t{\n\t\t\
    string s = string.Substring(0,i);\n\t\tres[i] = s;\n\t}\n\treturn res;\n}", "{\n\
    \    if(string == \"\")\n        return [\"\"];\n    string[] result = new string[1];\n\
    \    result[0] = string;\n    for(int i = 1; i <= string.length(); i++)\n    {\n\
    \        string prefix = string[0:i];\n        result[0] += prefix;\n        string[]\
    \ prefix = all_prefixes(result[0]);\n        for(int j = 0; j < prefix.Length;\
    \ j++)\n            result[prefix.Length + j] = prefix[j];\n    }\n    return\
    \ result;\n}", "{\n    int length = 1;\n    while(string.length > length){\n \
    \       string pre = string.substr(0, length);\n        if (std.string.isPrefixOf(string,\
    \ pre)) {\n            return new string[]{pre};\n        }\n        ++length;\n\
    \    }\n    return new string[0];\n}\n/*\n Return array of all suffixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"b\", \"\
    bc\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    int length\
    \ = 1;\n    while(string.length > length){\n        string suf = string.substr(0,\
    \ length);\n        if (std.string.isSuffixOf(string, suf)) {\n            return\
    \ new string[]{suf};\n        }\n        ++length;\n    }\n    return new string[0];\n\
    }\n/*\n Return array of all substrings from shortest to longest of the input string\n\
    \    >>> all_substrings(\"abc\")\n    [\"abc\"]\n    \n*/\nstring[] all_substrings(string\
    \ string) \n{\n    int length = 1;\n    while(string.length > length){\n     \
    \   string sub = string.substr(0, length);\n        if (std.string.isSubstring(string,\
    \ sub)) {\n            return new string[]{sub};\n        }\n        ++length;\n\
    \    }\n    return new string[0];\n}\n/*\n Return array of all substrings whose\
    \ prefix is a prefix of the input string\n    >>> all_prefix_substrings(\"abc\"\
    , \"a\") \n    [\"ab\"]\n    \n*/\nstring[] all_prefix_substrings(string string)\
    \ \n{\n    int length = 1;\n    string pre = string.substr(0, length);\n    while(string.length\
    \ > length){\n        string sub = string.substr(0, length);\n        if (std.string.isSubstring(string,\
    \ pre, sub)) {\n            return new string[]{sub};\n        }\n        ++length;\n\
    \    }\n    return new string[0];\n}\n/*\n Return array of all substrings whose\
    \ suffix is a suffix of the input string\n    >>> all_suffix_substrings(\"abc\"\
    , \"a\") \n    [\"bc\"]\n    \n*/\nstring[] all_suffix_substrings(string string)\
    \ \n{\n    int length = 1;\n    string suf = string.substr(0, length);\n    while(string.length\
    \ > length){\n        string sub = string.substr(0, length);\n        if (std.string.isSubstring(string,\
    \ suf, sub)) {\n            return new string[]{sub};\n        }\n        ++length;\n\
    \    }\n    return new string[0];\n}\n/*\n Return array of all common prefixes\
    \ of shortest to longest of the input string\n    >>> all_common_prefixes(\"abc\"\
    , \"abcdef\")\n    [\"a\", \"ab\", \"abc\", \"bc\", \"bcd\", \"c", "{\n    string\
    \ result = \"\";\n    for (int i = 0; i < string.size(); ++i) \n    {\n      \
    \  string temp = \"\";\n        bool found = false;\n        while (!found &&\
    \ i < string.size()) \n        {\n            temp = string + \"_\" + temp;\n\
    \            if (string[i] != temp[i]) \n            {\n                temp =\
    \ string + \"_\" + temp;\n                found = true;\n            }\n     \
    \       ++i;\n        }\n        if (!found) \n        {\n            result =\
    \ temp;\n        }\n    }\n    return result.split(\"_\");\n}\n</code>\n<|/ a\
    \ tags=string,c++,prefixes,arrays |>\n<| a dscore=0 tags=string,c++,prefixes,arrays\
    \ |>\nFor a string of length k that has at most k prefixes, you can have at most\
    \ k copies of a substring. Thus if you make an array of k elements (say, of size\
    \ k), then each element will be a vector of size k (the prefixes of the string).\
    \ Then you sort this array of vectors lexicographically by size. This will give\
    \ you the prefixes in the order you need. After that you can walk over the array\
    \ of vectors and build the final string by joining each vector with its predecessor\
    \ vector.\n<|/ a |>\n<| a tags=string,c++,prefixes,arrays dscore=0 |>\n<code>\n\
    #include <vector>\n#include <algorithm>\n#include <string>", "{\n\tif (string\
    \ == \"\") return new string[0]; \n\t\n\tstring[] prefix = new string[string.Length];\n\
    \t\n\tstring substring;\n\tint i, len = 0;\n\t\n\tfor(i = 0; i < string.Length;\
    \ ++i) \n\t{\n\t\tsubstring = string.Substring(0, i);\n\t\tlen += substring.Length;\n\
    \t\tprefix[len] = substring;\n\t}\n\t\n\treturn prefix;\n}", "{\n    int min =\
    \ string.Length;\n    string prefix;\n    int j;\n    string[] prefixes;\n   \
    \ \n    while (string.Length > 0) {\n        prefix = string.Substring(0, min);\n\
    \        j = 1;\n        while (j++ < string.Length) {\n            string rest\
    \ = string.Substring(j);\n            if (rest.StartsWith(prefix)) {\n       \
    \         min = Math.Min(rest.Length, min);\n                min = Math.Min(min,\
    \ j + 1);\n            }\n        }\n        \n        prefixes = new string[min];\n\
    \        int k = 0;\n        for (j = 1; j <= min; j++)\n            prefixes[k++]\
    \ = string.Substring(j, string.Length-j);\n        \n        string = new string(prefixes);\n\
    \        \n    }\n    \n    return prefixes;\n}\n</code>\n<|/ a tags=string,arrays,c#\
    \ |>\n<| c |>\nHis code already uses a `for` loop to iterate through the characters\
    \ in the string.  He wants to return an array of all possible prefixes that could\
    \ be created from the input string.  Your code does not do that.\n<|/ c |>\n<|\
    \ c |>\nI think my code returns the correct list of prefixes. I've added an example\
    \ output to the answer to show it.\n<|/ c |>\n<| c |>\nNo, his code does not return\
    \ all the prefixes that could be created. For example, given the string `\"abc\"\
    `, your function returns `[\"a\", \"ab\", \"abc\"]`, which means it returns the\
    \ *prefixes that could be created from the input* `abc`.  That does not include\
    \ `ab`, since it does not contain `a`.  Your code returns `[\"a\", \"ab\", \"\
    abc\"]`, which means it returns *all the prefixes* that could be created from\
    \ the input `abc`.\n<|/ c |>\n<| c |>\nAh! I see. I must have misunderstood his\
    \ question. Thanks for clarifying!\n<|/ c |>\n<| c |>\nYeah I definitely misunderstood\
    \ his question. Thanks for clarifying!\n<|/ c |>\n<| a tags=string,arrays,c# dscore=0\
    \ |>\nI know this question is a bit old and you already got an accepted answer,\
    \ but this question was the first on Google and I wanted to provide a solution\
    \ that uses LINQ.\nThis solution can be easily adapted to a method that returns\
    \ an array or string[] as requested.\n<code>\n    string input = \"abc\";\n  \
    \  \n    var query = from i in Enumerable.Range(0, input.Length)\n           \
    \     let pos = input.Substring(0, i).ToArray()\n                where i < input.",
  "{\n\tint i;\n\tstring[] result = new string[string.length];\n\tfor(i=0; i<string.length;\
    \ i++) {\n\t\tresult[i] = string;\n\t\twhile(string.Length > 0) {\n\t\t\tstring[i]=string[i][0];\n\
    \t\t\tstring.length--;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Return array of\
    \ all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string)\
    \ \n{\n\tint i;\n\tstring[] result = new string[string.length];\n\tfor(i=0; i<string.length;\
    \ i++) {\n\t\tresult[i] = string;\n\t\twhile(string.Length > 0) {\n\t\t\tstring[i]=string[i][0];\n\
    \t\t\tstring.length--;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Return array of\
    \ all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string)\
    \ \n{\n\tint i;\n\tstring[] result = new string[string.length];\n\tfor(i=0; i<string.length;\
    \ i++) {\n\t\tresult[i] = string;\n\t\twhile(string.Length > 0) {\n\t\t\tstring[i]=string[i][0];\n\
    \t\t\tstring.length--;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Return array of\
    \ all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string)\
    \ \n{\n\tint i;\n\tstring[] result = new string[string.length];\n\tfor(i=0; i<string.length;\
    \ i++) {\n\t\tresult[i] = string;\n\t\twhile(string.Length > 0) {\n\t\t\tstring[i]=string[i][0];\n\
    \t\t\tstring.length--;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Return array of\
    \ all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string)\
    \ \n{\n\tint i;\n\tstring[] result = new string[string.length];\n\tfor(i=0; i<string.length;\
    \ i++) {\n\t\tresult[i] = string;\n\t\twhile(string.Length > 0) {\n\t\t\tstring[i]=string[i][0];\n\
    \t\t\tstring.length--;\n\t\t}\n\t}\n\treturn result;\n}\n/*\n Return array of\
    \ all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string)\
    \ \n{\n", "{\n  string[] prefixes = prefixes_function(string);\n  int length =\
    \ 0;\n  foreach(string p in prefixes) \n    length = max(length,p.length()); //\
    \ find max length prefix", "{\n    string[] results = new string[string.Length];\n\
    \    for (int i = 0, k = 0; i < string.Length; ++i, ++k) \n    {\n        results[k]\
    \ = string[i];\n    }\n    sort(results, (x, y) => x.Length < y.Length ? 1 : -1);\n\
    \    return results;\n}\n/*\n Return array of all suffixes from shortest to longest\
    \ of the input string\n    >>> all_suffixes(\"abc\")\n    [\"abc\", \"bca\", \"\
    cab\", \"cba\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    string[]\
    \ results = new string[string.Length];\n    for (int i = 0, k = 0; i < string.Length;\
    \ ++i, ++k) \n    {\n        results[k] = string[i];\n    }\n    sort(results,\
    \ (x, y) => x.Length < y.Length ? 1 : -1);\n    return string[results.Length -\
    \ 1];\n}\n/*\n Given an array of strings, return a string formed by concatenating\
    \ them \n    in lexicographical order", "{\n    var ret = new Array<string>();\n\
    \    for (var i = string.Length - 1; i >= 0; i--)\n    {\n        var letter =\
    \ string[i];\n        ret.Insert(0, letter);\n    }\n    return ret;\n}", "{\n\
    \    int[] char_count = count_chars(string);\n    \n    int[] prefix_table = new\
    \ int[256];\n    prefix_table['\\0'] = 0;\n    \n    for (int i = 0; i < char_count.length;\
    \ i++) \n    {\n        int char_length = char_count[i];\n        for (int j =\
    \ 0; j < char_length; j++) \n        {\n            prefix_table[(string)(i +\
    \ '0' + j)] += 1;\n        }\n    }\n    \n    int prefix_count = 0;\n    for\
    \ (int i = 0; i < 256; i++) \n    {\n        prefix_count += prefix_table[i];\n\
    \    }\n    \n    string[] prefixes = new string[prefix_count];\n    for (int\
    \ i = 0; i < prefix_count; i++) \n    {\n        prefixes[i] = (string)(\"0\"\
    + i);\n    }\n    return prefixes;\n}", "{\n  \n  string[] prefix = new string[string.length];\n\
    \  int j = 0;\n  for (int i=0; i < string.length; i++) \n  {\n    if (string[i]\
    \ == 'a') \n    {\n      prefix[j++] = string.Substring(0,i);\n    }\n  }\n  return\
    \ prefix;\n}\n/*\n Return array of all suffixes from shortest to longest of the\
    \ input string\n    >>> all_suffixes(\"abc\")\n    [\"bc\", \"abc\"]\n    \n*/\n\
    string[] all_suffixes(string string) \n{\n  \n  string[] suffix = new string[string.length];\n\
    \  int j = 0;\n  for (int i=0; i < string.length; i++) \n  {\n    if (string[i]\
    \ == 'c') \n    {\n      suffix[j++] = string.Substring(i,string.length-1);\n\
    \    }\n  }\n  return suffix;\n}\n/*\n Return list of all substrings from shortest\
    \ to longest of the input string\n    >>> all_substrings(\"abc\")\n    [\"abc\"\
    ]\n    \n*/\nstring[] all_substrings(string string) \n{\n  \n  string[] result\
    \ = new string[string.length];\n  for (int i=0; i < string.length; i++) \n  {\n\
    \    for (int j=0; j < string.length-i; j++) \n    {\n      result[i] += string.Substring(j,i+1);\n\
    \    }\n  }\n  return result;\n}\n/*\n Return list of all permutations of items\
    \ in a string in lexicographical order\n    \n    \n    >>> all_permutations(\"\
    abc\")\n    [(\"a\", \"b\", \"c\"), (\"b\", \"c\", \"a\"), (\"c\", \"a\", \"b\"\
    )]\n    \n*/\nList<string[]> all_permutations(string string) \n{\n  \n  List<string[]>\
    \ result = new List<string[]>();\n  string[] prefix = all_prefixes(string);\n\
    \  for (int i=0; i < prefix.Length; i++) \n  {\n    List<string> suffix = all_suffixes(prefix[i]);\n\
    \    for (int j=0; j < suffix.Length; j++) \n    {\n      string[] newItem = new\
    \ string[2];\n      newItem[0] = prefix[i];\n      newItem[1] = suffix[j];\n \
    \     result.Add(newItem);\n    }\n  }\n  return result;\n}\n/*\n Return list\
    \ of all combinations of items in a string in lexicographical order\n    \n  \
    \  \n    >>> all_combinations(\"abc\")\n    [(\"a\", \"b\", \"c\"), (\"b\", \"\
    c\", \"a\"), (\"c\", \"a\"), (\"a\")]\n    \n*/\nList<string[]> all_combinations(string\
    \ string) \n{\n  \n  List<string[]> result = new List<string[]>();\n  string[]\
    \ suffix = all_suffixes(string", "{\n    int N = string.length();\n    \n    int[]\
    \ arr = new int[N];\n    \n    for (int i = 0; i < N; i++)\n    {\n        arr[i]\
    \ = i;\n    }\n    \n    // prefix starts from index 1\n    arr[1] = 1;\n    \n\
    \    // use 2 pointers\n    for (int i = 2; i <= N; i++)\n    {\n        // increment\
    \ i until it become less than N\n        while (i < N && string[i] != string[i\
    \ - 1])\n        {\n            i++;\n        }\n        \n        // check if\
    \ i equals N\n        if (i == N)\n        {\n            break;\n        }\n\
    \        \n        // set prefix to string\n        arr[i - 1] = string[i];\n\
    \    }\n    \n    string[] result = new string[N];\n    for (int i = 0; i < N;\
    \ i++)\n    {\n        result[i] = string.substring(arr[i], arr[i + 1]);\n   \
    \ }\n    \n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,algorithm,prefix-tree,c#,substring\
    \ |>\nThis is my approach:\n<code>\nstring s = \"abc\";\nDictionary<string, List<string>>\
    \ allPrefixes = new Dictionary<string, List<string>>();", "{\n    string[] result\
    \ = new string[string.length];\n    int n = string.length;\n    for(int i = 0;\
    \ i < n; ++i)\n    {\n        result[i] = string.Substring(0,i);\n    }\n    return\
    \ result;\n}", "{\n    string p = string;\n    var result: Array[String] = Array();\n\
    \    while( p.length() > 0){\n        p = p.substr(0,p.length()-1);\n        result.push(p);\n\
    \    }\n    \n    return result;\n}\n/*\n Return array of all suffixes from shortest\
    \ to longest of the input string\n    >>> all_suffixes(\"abc\")\n    [\"a\", \"\
    ab\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n    string p\
    \ = string;\n    var result: Array[String] = Array();\n    while( p.length() >\
    \ 0){\n        p = p.substr(0,p.length()+1);\n        result.push(p);\n    }\n\
    \    \n    return result;\n}\n/*\n Return list of prefixes of input string\n \
    \   >>> prefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] prefixes(string\
    \ string) \n{\n    string p = string;\n    var result: Array[String] = Array();\n\
    \    while( p.length() > 0){\n        p = p.substr(0,p.length()-1);\n        result.push(p);\n\
    \    }\n    \n    return result;\n}\n/*\n Return list of suffixes of input string\n\
    \    >>> suffixes(\"abc\")\n    [\"a\", \"ab\", \"c\"]\n    \n*/\nstring[] suffixes(string\
    \ string) \n{\n    string p = string;\n    var result: Array[String] = Array();\n\
    \    while( p.length() > 0){\n        p = p.substr(0,p.length()+1);\n        result.push(p);\n\
    \    }\n    \n    return result;\n}\n/*\n Return array of all substrings of input\
    \ string\n    >>> substrings(\"ab\")\n    [\"ab\", \"ba\"]\n    \n*/\nstring[]\
    \ substrings(string string) \n{\n    string p = string;\n    var result: Array[String]\
    \ = Array();\n    while( p.length() > 0){\n        p = p.substr(0,p.length()-1);\n\
    \        result.push(p);\n    }\n    \n    return result;\n}\n/*\n Return array\
    \ of common prefixes from shortest to longest of the input strings\n    >>> common_prefixes(\"\
    ab\", \"aba\")\n    [\"ab\"]\n    \n*/\nstring[] common_prefixes(string string1,\
    \ string string2) \n{\n    string[] result = Array();\n    string p = string1;\n\
    \    while( p.length() > 0){\n        if( p.length() < string2.length()){\n  \
    \          p= p + string2.substr(0,p.length());\n            result.push(p);\n\
    \        }\n        p= p.substr(0,p.length()-1);\n    }\n    \n    return result;",
  "{\n    string[] r = new string[string.Length];\n    int i = 0, j = string.Length\
    \ - 1;\n    while (i < j)\n    {\n        if (string[i] == \"-\")\n        {\n\
    \            r[i] = \"-\";\n            i++;\n        }\n        else if (string[i]\
    \ == \"*\")\n        {\n            r[i] = \"*\";\n            j--;\n        }\n\
    \        else if (string[i] == \"/\")\n        {\n            r[i] = \"/\";\n\
    \            j--;\n        }\n        else\n        {\n            r[i] = string[i];\n\
    \        }\n        i++;\n    }\n    return r;\n}", "{\n    if(string.Length <=\
    \ 1) \n    {\n        return Enumerable.Repeat(string.Substring(0, 1), string.Length);\n\
    \    } ", "{\n  string[] result = new string[string.Length];\n  int start = 0;\n\
    \  do\n  {\n    result[start] = string[start];\n    start += 1;\n  } while (start\
    \ < string.Length);\n  start = string.Length - 1;\n  while (start >= 0)\n  {\n\
    \    result[start] = string[start];\n    start -= 1;\n  }\n  return result;\n}",
  "{\n    string[] result = new string[string.lenght];\n    int i = 0;\n    int j\
    \ = 0;\n    while(i < string.lenght && j < string.lenght)\n    {\n        result[i]\
    \ = string[i];\n        i++;\n        j++;\n    }\n    while(i < string.lenght)\n\
    \    {\n        result[i] = string[i];\n        i++;\n    }\n    return result;\n\
    }", "{\n  int len = string.length();\n  string current = \"\";\n  string[] result\
    \ = new string[len];\n  for(int i = 0; i < len; i++)\n  {\n    string next = \"\
    \";\n    if(i < len - 1)\n      next = string.substring (i +1, len); // substring\n\
    \    result[i] = current+next;\n    current = next;\n  }\n  return result;\n}\n\
    /*\n Return array of all suffixes from shortest to longest of the input string\n\
    \    >>> all_suffixes(\"abc\")\n    [\"abc\", \"b\", \"ac\"]\n    \n*/\nstring[]\
    \ all_suffixes(string string) \n{\n  int len = string.length();\n  string current\
    \ = \"\";\n  string[] result = new string[len];\n  for(int i = 0; i < len; i++)\n\
    \  {\n    string next = \"\";\n    if(i < len - 1)\n      next = string.substring\
    \ (0, i); // substring\n    result[i] = current+next;\n    current = next;\n \
    \ }\n  return result;\n}\n/*\n Return array of all substrings containing the original\
    \ string\n    >>> all_substrings(\"abc\")\n    [\"abc\", \"bc\", \"c\"]\n    \n\
    */\nstring[] all_substrings(string string) \n{\n  int len = string.length();\n\
    \  string[] result = new string[len];\n  for(int i = 0; i < len; i++)\n  {\n \
    \   string next = \"\";\n    if(i < len - 1)\n      next = string.substring (i,\
    \ len); // substring\n    result[i] = next;\n  }\n  return result;\n}\n/*\n Return\
    \ array of all substrings containing the original string\n    >>> all_substrings(\"\
    abc\")\n    [\"abc\", \"bc\", \"c\"]\n    \n*/\nstring[] all_substrings(string\
    \ string, int limit) \n{\n  int len = string.length();\n  string[] result = new\
    \ string[len];\n  for(int i = 0; i < len; i++)\n  {\n    string next = \"\";\n\
    \    if(i < len - 1)\n      next = string.substring (i, len); // substring\n \
    \   result[i] = next;\n  }\n  return result;\n}\n/*\n Return array of all substrings\
    \ containing the original string\n    >>> all_substrings(\"abc\", 2)\n    [\"\
    abc\", \"bc\"]\n    \n*/\nstring[] all_substrings(string string, int start, int\
    \ end) \n{\n  int len = string.length();\n  string[] result = new string[len];\n\
    \  for(int i = start; i < end; i++)\n  {\n    string next = \"\";\n    if(i <\
    \ len - 1)\n      next = string.substring (i, len); // substring\n    result[i]\
    \ = next;\n  }\n  return result;\n}", "{\n\tStack<string> stack = new Stack<string>();\n\
    \tstack.Push(string);\n\t\n\twhile(!stack.Empty())\n\t{\n\t\tstring prefix = stack.Pop();\n\
    \t\t\n\t\tfor(int i = 0; i<prefix.length;i++)\n\t\t{\n\t\t\tstring currentPrefix\
    \ = prefix+prefix.Substring(i+1,1);\n\t\t\t\n\t\t\tif(!stringIsIn(currentPrefix,stack))\n\
    \t\t\t\tstack.Push(currentPrefix);\n\t\t}\n\t}\n\t\n\treturn stack.ToArray();\n\
    }", "{\n    int len = string.length, mid;\n    \n    for(int mid = 0; mid < len;\
    \ mid++)\n    {\n        if(string.charAt(mid) == '(')\n        {\n          \
    \  mid = string.lastIndexOf('(', mid - 1);\n        }\n        else\n        {\n\
    \            mid = string.lastIndexOf(')', mid - 1);\n        }\n        if(mid\
    \ < 0)\n        {\n            mid = len;\n        }\n        strings[mid] = string.substring(mid\
    \ + 1, len - 1);\n    }\n    return strings;\n}\n/*\n Return array of all prefixes\
    \ from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n\
    \    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string)\
    \ \n{\n    int len = string.length, mid;\n    \n    for(int mid = 0; mid < len;\
    \ mid++)\n    {\n        if(string.charAt(mid) == '(')\n        {\n          \
    \  mid = string.lastIndexOf('(', mid - 1);\n        }\n        else\n        {\n\
    \            mid = string.lastIndexOf(')', mid - 1);\n        }\n        if(mid\
    \ < 0)\n        {\n            mid = len;\n        }\n        strings[mid] = string.substring(mid\
    \ + 1, len - 1);\n    }\n    return strings;\n}\n/*\n Return array of all prefixes\
    \ from shortest to longest of the input string\n    >>> all_prefixes(\"abc\")\n\
    \    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string)\
    \ \n{\n    int len = string.length, mid;\n    \n    for(int mid = 0; mid < len;\
    \ mid++)\n    {\n        if(string.charAt(mid) == '(')\n        {\n          \
    \  mid = string.lastIndexOf('(', mid - 1);\n        }\n        else\n        {\n\
    \            mid = string.lastIndexOf(')', mid - 1);\n        }\n        if(mid\
    \ < 0)\n        {\n            mid = len;\n        }\n        strings[mid] = string.substring(mid\
    \ + 1, len - 1);\n    }\n    return strings;\n}\n/*\n Return array of all suffixes\
    \ from shortest to longest of the input string\n    >>> all_suffixes(\"abc\")\n\
    \    [\"c\", \"bc\", \"abc\"]\n    \n*/\nstring[] all_suffixes(string string)\
    \ \n{\n    int len = string.length, mid;\n    \n    for(int mid = 0; mid < len;\
    \ mid++)\n    {\n        if(string.charAt(mid) == ')')\n        {\n          \
    \  mid = string.lastIndexOf('(', mid - 1);\n        }\n        else\n        {\n\
    \            mid = ", "{\n    string[] result;\n    std.typecons.List<dynamic>\
    \ list = std.typecons.List<dynamic>[string];\n    std.typecons.Stack<dynamic>\
    \ stack = new std.typecons.Stack<dynamic>();\n    string prefix = \"\";\n    int\
    \ i = 0;\n    bool inside = false;\n    std.string.insertall(list, \"\", string);\n\
    \    while (inside == false)\n    {\n        if (list.count == 0) \n        {\n\
    \            result = new string[0];\n            break;\n        }\n        if\
    \ (i == list.count) \n        {\n            inside = true;\n        }\n     \
    \   else if (list[i].isspace())\n        {\n            i++;\n            prefix\
    \ = \"0\";\n        }\n        else\n        {\n            prefix = prefix +\
    \ \"0\";\n        }\n        if (prefix == \"0\") \n        {\n            prefix\
    \ = \"1\";\n        }\n        stack.push(prefix);\n        list.insertall(stack,\
    \ \"\");\n        i++;\n    }\n    \n    return result;\n}\n/*\n Return array\
    \ of all prefixes from shortest to longest of the input string\n    >>> all_prefixes(\"\
    abc\")\n    [\"a\", \"ab\", \"abc\"]\n    \n*/\nstring[] all_prefixes(string string,\
    \ int precision) \n{\n    string[] result;\n    std.typecons.List<dynamic> list\
    \ = std.typecons.List<dynamic>[string];\n    std.typecons.Stack<dynamic> stack\
    \ = new std.typecons.Stack<dynamic>();\n    string prefix = \"\";\n    int i =\
    \ 0;\n    bool inside = false;\n    std.string.insertall(list, \"\", string);\n\
    \    while (inside == false)\n    {\n        if (list.count == 0) \n        {\n\
    \            result = new string[0];\n            break;\n        }\n        if\
    \ (i == list.count) \n        {\n            inside = true;\n        }\n     \
    \   else if (list[i].isspace())\n        {\n            i++;\n            prefix\
    \ = \"0\";\n        }\n        else\n        {\n            prefix = prefix +\
    \ \"0\";\n        }\n        if (prefix == \"0\") \n        {\n            prefix\
    \ = \"1\";\n        }\n        stack.push(prefix);\n        list.insertall(stack,\
    \ \"\");\n        i++;\n    }\n    \n    if (precision > 0)\n    {\n        std.array.sort(result,\
    \ std.string.compare);\n    }\n    return result;\n}\n/*\n Return array of all\
    \ suffixes from shortest to longest of the input string\n    >>> all_suffixes(\"\
    abc\")\n    [\"bc\", \"ac\", \"ab\"]\n    \n*/\nstring[] all_suffixes(string string)\
    \ \n{\n    string[] result;\n    ", "{\n    int i=0;\n    int count=0;\n    int\
    \ length=string.length;\n    string[] r=new string[length];\n    for(i=0; i<length;\
    \ ++i)\n    {\n        r[i]=string.substr(0,i);\n        while(r[i].length()==i)\n\
    \        {\n            r[i]=string.substr(0,i+1);\n            count++;\n   \
    \     }\n    }\n    return r;\n}\n</code>\n<|/ a tags=algorithm,string,prefix\
    \ |>\n<| a |>\nIf you're dealing with very large strings, you may want to use\
    \ an implementation of Boyer-Moore's algorithm.  Wikipedia has a good description.\n\
    <|/ a tags=algorithm,string,prefix dscore=2 |>\n<| c |>\nThat link only provides\
    \ a description of the algorithm, and does not include the implementation that\
    \ would take an arbitrarily large string as an input.\n<|/ c |>\n<| a |>\nHere\
    \ is a solution in Python that computes the list of all prefixes for a string:\n\
    <code>\ndef all_prefixes(strng):\n    if strng == \"\":\n        return []\n \
    \   prefixes = all_prefixes(strng[:-1])\n    prefixes.append(strng[:-1])\n   \
    \ return prefixes\n</code>\nAnd here is a Java implementation, which takes only\
    \ O(n) time to do the task:\n<code>\npublic static List<String> all_prefixes(String\
    \ strng) {\n    if (strng.length() == 0) {\n        return new ArrayList<String>();\n\
    \    }\n    List<String> prefixes = all_prefixes(strng.substring(1));\n    prefixes.add(strng.substring(0,\
    \ 1));\n    return prefixes;\n}\n</code>\n<|/ a dscore=2 tags=algorithm,string,prefix\
    \ |>\n<| a dscore=2 |>\nI have implemented my own version of the all_prefixes\
    \ function in the JDK which takes O(n) time complexity and uses hashing:\n<code>\n\
    private static Set<String> prefixes;", "{\n    string prefixes;\n    if (string\
    \ == \"\") {\n        return prefixes;\n    }\n    \n    int n = string.length();\n\
    \    prefixes = string.substr(0, n-1);\n    for (int i = 1; i < n; ++i) {\n  \
    \      prefixes = prefixes + string.substr(0, i);\n    }\n    \n    string[] result\
    \ = new string[prefixes.length()];\n    for(int i = 0; i < prefixes.length();\
    \ ++i){\n        result[i] = prefixes.substr(i, prefixes.length() - i);\n    }\n\
    \    return result;\n}", "{\n    var result = new string[string.Length];\n   \
    \ foreach(var i, var x in enumerate(string))\n    {\n        result[i.index] +=\
    \ x.char;\n    }\n    return result;\n}\n/*\n Return array of all suffixes from\
    \ shortest to longest of the input string\n    >>> all_suffixes(\"abc\")\n   \
    \ [\"b\", \"bc\", \"c\"]\n    \n*/\nstring[] all_suffixes(string string) \n{\n\
    \    var result = new string[string.Length];\n    foreach(var i, var x in enumerate(string))\n\
    \    {\n        result[i.index] += x.char;\n    }\n    return result;\n}\n/*\n\
    \ Return true if given string is a palindrome\n    >>> is_palindrome(\"race a\
    \ car\")\n    True\n    >>> is_palindrome(\"racecar\")\n    False\n    \n*/",
  "{\n    int[] arr;\n    int i;\n    int length = string.length + 1;\n    arr = new\
    \ int[length];\n    i = 0;\n    while (i < length) {\n        arr[i] = i;\n  \
    \      i = i + 1;\n    }\n    arr[i] = length;\n    return arr;\n}", "{\n  list<string>\
    \ prefixes;\n  string temp;\n  \n  for(int i = 0, length = string.length; i <\
    \ length; i++) \n  {\n    temp = string(string, 0, i);\n    \n    if(temp.length()\
    \ > 0 && !prefixes.contains(temp)) \n    {\n      prefixes.push_back(temp);\n\
    \    }\n  }\n  return prefixes.toArray();\n}", "{\n  // your code here\n  int\
    \ i = 0;\n  int j = 0;\n  string stringPrefix = \"\";\n  string[] allPrefixes\
    \ = new string[string.Length];\n  allPrefixes[i] = stringPrefix;\n  for(int k=i;k<string.Length;k++)\n\
    \  {\n    stringPrefix = stringPrefix + string[k];\n    j = k;\n    while(j<string.Length\
    \ && string[j] == stringPrefix[j])\n    {\n      allPrefixes[j] = stringPrefix\
    \ + string[j];\n      j++;\n    }\n    i = j;\n  }\n  return allPrefixes;\n}",
  "{\n    int length = string.length;\n    string longest = \"\";\n    string shortest\
    \ = string;\n    for(int i=0;i<length;i++){\n        string tmp;\n        if(length==i){\n\
    \            tmp = string;\n        } else {\n            tmp = string.substring(i);\n\
    \        }\n        if (length<i+1){\n            shortest = shortest+tmp;\n \
    \       } else {\n            longest = longest+tmp;\n        }\n    }\n    \n\
    \    string[] array = new string[longest.length];\n    for (int i=0;i<longest.length();i++){\n\
    \        array[i] = longest.substring(i);\n    }\n    return array;\n}", "{\n\t\
    string[] arr;\n\tstring temp;\n\tint i;\n\t\n\tarr = new string[string.size()];\n\
    \t\n\tfor(i = 0; i < string.size(); i++) {\n\t\ttemp = \"\";\n\t\ttemp += string.substr(0,i);\n\
    \t\t\n\t\tarr[i] = temp;\n\t}\n\t\n\treturn arr;\n}", "{\n    int len = string.Length;\n\
    \    \n    // if string is empty returns empty array\n    if (len <= 0) \n   \
    \ {\n        return new string[0];\n    }\n    \n    // array of prefixes\n  \
    \  string[] prefixes = new string[len];\n    \n    // copy first character\n \
    \   prefixes[len - 1] = string[0];\n    \n    // recursive algorithm\n    for\
    \ (int i = 1; i < len; ++i)\n    {\n        prefixes[i] = prefixes[i - 1] + string[i];\n\
    \    }\n    \n    return prefixes;\n}", "{\n\tTuple _all_prefixes = std.tuple();\n\
    \t\n\tauto all_prefixes_lambda = [&](string s) mutable -> tuple<tuple<string>&,\
    \ tuple<string>&> {\n\t\tauto l = s.length;\n\t\tauto r = std.len(s);\n\t\tauto\
    \ result = std.make_tuple(std.make_tuple(s.substr(0,0), s.substr(0,l-1)), std.make_tuple(s.substr(0,r),\
    \ s.substr(0,l)));\n\t\treturn result;\n\t};\n\t\n\tauto all_prefixes_lambda_r\
    \ = [&](string s) mutable -> tuple<tuple<string>&, tuple<string>&> {\n\t\tauto\
    \ l = s.length;\n\t\tauto r = std.len(s);\n\t\tauto result = std.make_tuple(std.make_tuple(s.substr(0,0),\
    \ s.substr(0,l-1)), std.make_tuple(s.substr(0,r), s.substr(0,l)));\n\t\treturn\
    \ result;\n\t};\n\t\n\tauto all_prefixes_lambda_r_r = [&](string s) mutable ->\
    \ tuple<tuple<string>&, tuple<string>&> {\n\t\tauto l = s.length;\n\t\tauto r\
    \ = std.len(s);\n\t\tauto result = std.make_tuple(std.make_tuple(s.substr(0,0),\
    \ s.substr(0,l-1)), std.make_tuple(s.substr(0,r), s.substr(0,l)));\n\t\treturn\
    \ result;\n\t};\n\t\n\tauto all_prefixes_lambda_r_r_r = [&](string s) mutable\
    \ -> tuple<tuple<string>&, tuple<string>&> {\n\t\tauto l = s.length;\n\t\tauto\
    \ r = std.len(s);\n\t\tauto result = std.make_tuple(std.make_tuple(s.substr(0,0),\
    \ s.substr(0,l-1)), std.make_tuple(s.substr(0,r), s.substr(0,l)));\n\t\treturn\
    \ result;\n\t};\n\t\n\tauto all_prefixes_lambda_r_r_r_r = [&](string s) mutable\
    \ -> tuple<tuple<string>&, tuple<string>&> {\n\t\tauto l = s.length;\n\t\tauto\
    \ r = std.len(s);\n\t\tauto result = std.make_tuple(std.make_tuple(s.substr(0,0),\
    \ s.substr(0,l-1)), std.make_tuple(s.substr(0,r), s.substr(0,l)));\n\t\treturn\
    \ result;\n\t};\n\t\n\tauto all_prefixes_lambda_r_r_r_r_r = [&](string s) mutable\
    \ -> tuple<tuple<string>&, tuple<string>&> {\n\t\tauto l = s.length;\n\t\tauto\
    \ r = std.len(s);\n\t\tauto result = std.make_tuple(std.make_tuple(s.substr(0,0), "]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
