name: HumanEval_16_count_distinct_characters
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Given a string, find out how\
  \ many distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
  xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
  */\nlong count_distinct_characters(string string) \n"
tests: "unittest\n{\n    alias candidate = count_distinct_characters;\n\n    assert(candidate(\"\
  \") == 0L);\n    assert(candidate(\"abcde\") == 5L);\n    assert(candidate(\"abcdecadeCADE\"\
  ) == 5L);\n    assert(candidate(\"aaaaAAAAaaaa\") == 1L);\n    assert(candidate(\"\
  Jerry jERRY JeRRRY\") == 5L);\n}\nvoid main(){}"
completions: ["{\n    long distinctCharacterCount = 0;\n    \n    for (string str\
    \ : string::enumerate(string))\n    {\n        for (char character : str)\n  \
    \      {\n            distinctCharacterCount++;\n            \n            string\
    \ lowerCaseCharacter = string::to_lower_case(character);\n            for (char\
    \ lowerCaseCharacter_ : string::to_lower_case(string::enumerate(lowerCaseCharacter)))\n\
    \            {\n                if (lowerCaseCharacter_ == character)\n      \
    \          {\n                    distinctCharacterCount--;\n                \
    \    break;\n                }\n            }\n        }\n    }\n    \n    return\
    \ distinctCharacterCount;\n}", "{\n\tlong l=0;\n\tforeach(char in string) \n\t\
    {\n\t\tl++;\n\t}\n\treturn l;\n}", "{\n    long count = 0;\n    bool is_case_sensitive\
    \ = false;\n    \n    for(auto c : string) \n    {\n        if(!is_case_sensitive)\
    \ \n            c = tolower(c);\n        \n        if(!std.typecons.contains(string::value_type(tolower(c),\
    \ toupper(c)))) \n        {\n            is_case_sensitive = false;\n        \
    \    break;\n        }\n        \n        count++;\n    }", "{\n    auto char_count\
    \ = std.typecons.map<string, long>(); \n    \n    for (auto c : string) \n   \
    \     char_count[c] += 1;\n    \n    return char_count.size();\n}", "{\n    int\
    \ n = 0;\n    foreach(int character, string)\n    {\n        n = (n<<1) + character;\n\
    \    }\n    return n;\n}\n/*\n Count the number of consecutive repeating characters\
    \ \n    >>> count_repeated_characters(\"abcBcA\")\n    2L\n    >>> count_repeated_characters(\"\
    aaa\")\n    0L\n    \n*/\nlong count_repeated_characters(string string) \n{\n\
    \    int n = 0;\n    foreach(int character, string)\n    {\n        if((string[character]\
    \ == string[character-1]) && (character < string.length()))\n        {\n     \
    \       n++;\n        }\n    }\n    return n;\n}", "{\n    long count = 0;\n \
    \   for (auto it=string.cbegin(); it!=string.cend(); ++it) {\n        if (*it)\
    \ {\n            ++count;\n            while (it != string.cend() && *it) {\n\
    \                --count;\n                ++it;\n            }\n        }\n \
    \   }\n    return count;\n}\n/*\n Given a string, count the number of non-zero\
    \ characters in it.\n    >>> count_non_zero_characters(\"xyzXYZ\")\n    2\n  \
    \  >>> count_non_zero_characters(\"Jerry\")\n    2\n    \n*/\nlong count_non_zero_characters(string\
    \ string) {\n    long count = 0;\n    for (auto it=string.cbegin(); it!=string.cend();\
    \ ++it) {\n        if (*it) {\n            ++count;\n            while (it !=\
    \ string.cend() && *it) {\n                --count;\n                ++it;\n \
    \           }\n        }\n    }\n    return count;\n}\n/*\n Given a string, convert\
    \ it into a long number.\n    >>> to_long_number(\"xyzXYZ\")\n    6L\n    >>>\
    \ to_long_number(\"Jerry\")\n    7L\n    \n*/\nlong to_long_number(string string)\
    \ \n{\n    long long res = 0;\n    for (auto it=string.cbegin(); it!=string.cend();\
    \ ++it) {\n        if (*it) {\n            res *= 10;\n            res += to_long(it\
    \ - string.cbegin());\n        }\n    }\n    return res;\n}", "{\n    long result\
    \ = 0L;\n    for (int i = 0; i < string.length; ++i)\n    {\n        char c =\
    \ string[i];\n        if (c == 'z' || c == 'Z')\n            continue;\n     \
    \   if (result >= (1L << 63))\n            return (1L << 63);\n        result\
    \ = (result << 61) + (c | 0x20L);\n    }\n    return result;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThis answer is incorrect, since it fails to deal with\
    \ UTF-8 multi-byte characters. If you use one of the strings in the example above,\
    \ for example, `count_distinct_characters(\"\u2131\u2133\u2134\u2135\u2136\u2137\
    \u2138\u2139\u213A\u213B\u213C\u213D\u213E\u213F\u2140\u2141\u2142\u2143\u2144\
    \u2145\u2146\u2147\u2148\u2149\u214A\u214B\u214C\u214D\u214E\")` the result is\
    \ incorrect, since the UTF-8 encoded string contains 4 distinct characters.\n\
    <|/ c |>\n<| a tags=string,character-encoding,c++,algorithm |>\nYou can use the\
    \ fact that every unicode character (up to U+10FFFF) can be represented by one\
    \ or two unicode code points. Thus, this can be solved with a simple linear algorithm:\n\
    <code>\nsize_t count_distinctChars(const char* str) {\n    size_t count = 0;\n\
    \    size_t codePoint;\n    while (*str) {\n        codePoint = *str;\n      \
    \  if (codePoint > 0xffff) {\n            // Not a unicode code point\n      \
    \      return count;\n        }\n        if (codePoint == 0x000a) {\n        \
    \    // Newline character U+000A - return count + 1 because there could be two\
    \ code points with this value\n            return count + 1;\n        }\n    \
    \    ++count;\n        ++str;\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis answer is incorrect, since it fails to deal with UTF-8 multi-byte\
    \ characters. If you use one of the strings in the example above, for example,\
    \ `count_distinctChars(\"\u2131\u2133\u2134\u2135\u2136\u2137\u2138\u2139\u213A\
    \u213B\u213C\u213D\u213E\u213F\u2140\u2141\u2142\u2143\u2144\u2145\u2146\u2147\
    \u2148\u2149\u214A\u214B\u214C", "{\n    /*\n    Convert string to lowercase and\
    \ remove extra spaces.\n    */\n    string lowercase_string = string::toLower(string);\n\
    \    string no_extra_spaces = lowercase_string.substr(0, string::length(string::whitespaces))\
    \ + lowercase_string.substr(string::length(string::whitespaces), string::length(string)\
    \ - string::length(string::whitespaces));\n    /*\n    Use map to count distinct\
    \ characters, each character is mapped with a unique integer value\n    */\n \
    \   long distinct_characters = lowercase_string.map([](char x) {\n        auto\
    \ y = toupper(x);\n        auto count = count(lowercase_string.begin(), lowercase_string.end(),\
    \ y);\n        return y + (count > 0 ? count : 0);\n    }).count();\n    /*\n\
    \    Add up distinct characters in the string by adding them up.\n    */\n   \
    \ return distinct_characters + no_extra_spaces.length();\n}\n</code>\n<|/ a tags=c++,algorithm,string\
    \ |>\n<| a |>\nMy idea is to build a dictionary and for each character in the\
    \ string add its occurence to the dictionary. When you have the dictionary all\
    \ you need is to count the numbers of occurences of every unique character:\n\
    <code>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n\
    using namespace std;", "{\n\tauto it = std.algorithm.unique(string);\n\treturn\
    \ it.size();\n}", "{\n    int result = 1L;\n    long len = string.length;\n  \
    \  if (len == 0) \n        return result;\n    \n    for (int i = 0; i < len;\
    \ ++i)\n    {\n        if (string[i] < 'A' || string[i] > 'Z')\n        {\n  \
    \          ++result;\n        }\n        else if (string[i] > 'z')\n        {\n\
    \            ++result;\n        }\n    }\n    \n    return result;\n}", "{\n \
    \   if (string.empty())\n        return 0;\n    char first = string[0];\n    size_t\
    \ num_distinct = 0;\n    for (size_t i=1; i < string.length; ++i)\n    {\n   \
    \     char c = string[i];\n        num_distinct = (num_distinct << 1) + (c ==\
    \ first ? 1 : 0);\n    }\n    return num_distinct;\n}", "{\n\tlong result = 0;\n\
    \tchar c;\n\tfor (auto c: string)\n\t{\n\t\tc = toupper(c);\n\t\tresult += std.stringlib.rev_find(string.data,\
    \ string.size, c, 0);\n\t}\n\treturn result;\n}", "{\n\tlong total = 0;\n\tforeach(char\
    \ in string)\n\t{\n\t\ttotal += toLower(char) ? 1 : 0;\n\t}\n\t\n\treturn total;\n\
    }", "{\n\t// Write your code here.\n\tint len = string.size();\n\tvector<int>\
    \ counts;\n\tfor(int i = 0; i < len; i++)\n\t{\n\t\tcounts[tolower(string[i])]++;\n\
    \t\tcounts[toupper(string[i])]++;\n\t}\n\tlong result = 1L;\n\tfor(int i = 0;\
    \ i < 26; i++)\n\t\tresult += counts[i];\n\treturn result;\n}\n/*\n Given a string,\
    \ find out how many times each character appears\n    >>> count_occurrences(\"\
    xyzXYZ\")\n    3L\n    >>> count_occurrences(\"Jerry\")\n    4L\n    \n*/\nlong\
    \ count_occurrences(string string)\n{\n\t// Write your code here.\n\tlong result\
    \ = 1L;\n\tfor(int i = 0; i < string.size(); i++)\n\t{\n\t\tstring sub = string.substr(0,\
    \ i);\n\t\tif(sub == sub.toUpperCase())\n\t\t\tresult += 1;\n\t\telse if(sub ==\
    \ sub.toLowerCase())\n\t\t\tresult *= 2;\n\t\telse\n\t\t\tresult *= 3;\n\t}\n\t\
    return result;\n}\n/*\n Given a string, find the number of times each letter appears\n\
    \    >>> count_letters(\"xyzXYZ\")\n    {'x':3,'y':2,'z':3}\n    >>> count_letters(\"\
    Jerry\")\n    {'j':1,'e':1,'r':1,'y':1}\n    \n*/\nmap<char, long> count_letters(string\
    \ string)\n{\n\t// Write your code here.\n\tmap<char, long> result;\n\tfor(int\
    \ i = 0; i < string.size(); i++)\n\t{\n\t\tresult.insert(make_pair(string[i],\
    \ 1L));\n\t}\n\treturn result;\n}\n/*\n Given two strings, find the longest common\
    \ substring.\n    >>> common_substr(\"abcde\", \"bcde\")\n    'bc'\n    >>> common_substr(\"\
    abcde\", \"abe\")\n    'a'\n    \n*/\nstring common_substr(string s1, string s2)\n\
    {\n\t// Write your code here.\n\tif(s1.size() == s2.size())\n\t{\n\t\tif(s1 ==\
    \ s2)\n\t\t\treturn s1;\n\t\telse\n\t\t\treturn \"\";\n\t}\n\tint len1 = s1.size();\n\
    \tint len2 = s2.size();\n\tif(len1 > len2)\n\t{\n\t\tstring temp1 = s1;\n\t\t\
    s1 = s2;\n\t\ts2 = temp1;\n\t\tlen1 = s2.size();\n\t}\n\tstring result = s1;\n\
    \tfor(int i = 0; i < len1; i++)\n\t{\n\t\tbool found = false;\n\t\tfor(int j =\
    \ 0; j < len2; j++)\n\t\t{\n\t\t\tif(s1[i] == s2[j])\n\t\t\t{\n\t\t\t\tfound =\
    \ true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!found)\n\t\t\tresult += s1[i];\n\
    \t}\n\treturn result;\n}\n/*\n", "{\n  long count = 0;\n  for(int i = 0; i < string.length();\
    \ i++) {\n    if(string.charAt(i) == string.charAt(i)) {\n      count++;\n   \
    \ }\n  }\n  return count;\n}", "{\n    string distinct_characters = \"\";\n  \
    \  string lower_case_string = \"\";\n    string upper_case_string = \"\";\n  \
    \  \n    foreach(string[] character : string.split(\"\")) {\n        distinct_characters\
    \ += character;\n        \n        if (character[0].toLower() == character[0])\
    \ {\n            lower_case_string += character;\n        } else if (character[0].toUpper()\
    \ == character[0]) {\n            upper_case_string += character;\n        } else\
    \ {\n            throw new Exception(\"String not lower case, or upper case.\"\
    );\n        }\n    }\n    \n    return long.parseLong(distinct_characters.length());\n\
    }", "{\n    long distinct = 0;\n    for(int i = 0; i < string.length(); i++)\n\
    \    {\n        char c = string[i];\n        if(islower(c) || isupper(c))\n  \
    \      {\n            distinct += (islower(c) ? 26 : 25);\n        }\n       \
    \ else\n            distinct += (islower(c) ? 10 : 9);\n    }\n    return distinct;\n\
    }\n</code>\n<|/ a tags=string,char,count,c++ |>\n<| c |>\n`long distinct = 0;`\
    \ can be reduced to `long distinct = (islower(c) ? 26 : 25);` and the rest of\
    \ the if-statements can be reduced to `distinct += (islower(c) ? 26 : 25);`.\n\
    <|/ c |>\n<| c |>\n`int i = 0; while(i < string.length()) { char c = string[i];\
    \ if(islower(c) || isupper(c)) { distinct += (islower(c) ? 26 : 25); } else {\
    \ distinct += (islower(c) ? 10 : 9); } i++ };` can be reduced to `int i = 0; while(i\
    \ < string.length()) { if(islower(string[i])) { distinct += (islower(string[i])\
    \ ? 26 : 25); } else { distinct += (islower(string[i]) ? 10 : 9); } i++ };`\n\
    <|/ c |>\n<| c |>\n, thanks for bringing these improvements to the answer. I did\
    \ a quick test and didn't see any noticeable differences (in execution time).\
    \ Did you test these improvements yourself?\n<|/ c |>\n<| c |>\nYes. I am sure\
    \ they were tested, but just to make the point that no difference was observed,\
    \ I did it myself :-)\n<|/ c |>\n<| c |>\nThanks everyone, I'm very new to programming\
    \ and I really appreciate all the help on this. I ended up coming up with this\
    \ but this is much more concise and readable, it's also much more efficient: ",
  "{\n    vector<char> characters;\n    for(char i : string)\n        characters.push_back(i);\n\
    \    sort(characters.begin(), characters.end());\n    long count_distinct_characters_result\
    \ = 0;\n    for(char i : characters)\n    {\n        count_distinct_characters_result++;\n\
    \        if(i != characters[count_distinct_characters_result - 1])\n         \
    \   count_distinct_characters_result++;\n    }\n    return count_distinct_characters_result;\n\
    }", "{\n    long result = 0;\n    for (char c : string)\n    {\n        result\
    \ = result + char2int(c);\n    }\n    return result;\n}\n/*\n Given a string,\
    \ find out how many distinct characters (regardless of case) does it consist of\n\
    \    >>> count_distinct_characters(\"Jerry\")\n    4L\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4L\n    \n*/\nlong count_distinct_characters(string string) \n{\n\
    \    long result = 0;\n    for (char c : string)\n    {\n        result = result\
    \ + char2int(c);\n    }\n    return result;\n}", "{\n  int i, j;\n  long count\
    \ = 0;", "{\n    long counter = 0;\n    for (char c : string)\n    {\n       \
    \ counter += tolower(c) - 'a';\n    }\n    return counter;\n}\n</code>\n<|/ a\
    \ tags=c++,std,algorithm dscore=4 |>\n<| c |>\nThis is very similar to what I\
    \ was thinking but wasn't quite sure.\n<|/ c |>\n<| c |>\nThis is really good;\
    \ I didn't think of this approach. I had done this before but with only 26 characters.\
    \ Very nice!\n<|/ c |>\n<| a dscore=2 tags=c++,std,algorithm |>\nA simple way\
    \ is to create a hash table that maps the lowercase character of the string to\
    \ another string that represents that same lowercase character in its uppercased\
    \ form. This will require only 26 lookups, even though there are 26^2 = 65 possible\
    \ lowercase characters.\nIf you have many duplicate characters, however, you'll\
    \ need to use something other than a hash table (like a std::multimap<std::string,\
    \ std::string>).\n<|/ a |>\n<| c |>\nI don't understand this answer. Do you mean\
    \ to say that `string` is essentially an `unordered_map<string, string>`?\n<|/\
    \ c |>\n<| c |>\n: Yes, that's what I meant.\n<|/ c |>\n<| a dscore=2 tags=c++,std,algorithm\
    \ |>\nMy solution, very naive\n<code>\nstd::string count_distinct_characters(std::string\
    \ s) {\n    std::string result;\n    char prev = '\\0';\n    for (char c : s)\n\
    \    {\n        if (c != prev) {\n            prev = c;\n            result +=\
    \ c;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a dscore=2\
    \ |>\nA naive implementation:\n<code>\nstd::string count_distinct_characters(std::string\
    \ s) {\n    std::string result;\n    char prev = '\\0';\n    for (char c : s)\n\
    \    {\n        if (c != prev) {\n            result += c;\n            prev =\
    \ c;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=c++,std,algorithm\
    \ |>\n<| a tags=c++,std,algorithm |>\nI think this is the most readable and efficient\
    \ way, without writing any extra code inside the function and without using std::map\
    \ or std::unordered_map:\n<code>\nstd::string count_distinct_characters(std::string\
    \ s)\n{\n    std::string result;\n    for (int i = 0; i < s.length(); i++)\n \
    \   {\n        if (result.find(s[i]) == std::string::npos)\n        {\n      \
    \      result += s[i];\n        }\n    }\n    return result;\n}\n</code>\n<|/\
    \ a dscore", "{\n    long l = 0;\n    for(auto i : string) \n    {\n        if(!islower(i))\
    \ \n        {\n            l = l + 1;\n        } \n        else if(!isupper(i))\
    \ \n        {\n            l = l + 2;\n        }\n        else if(!isdigit(i))\
    \ \n        {\n            l = l + 3;\n        }\n    }\n    return l;\n}", "{\n\
    \     long count = 0;\n     char c;\n     for c in string {\n         if (is_lower_case(c))\
    \ {\n             count ++;\n         }\n     }\n     return count;\n }", "{\n\
    \    long result = 0;\n    foreach (char ch in string) {\n        if (ch == 'z')\
    \ {\n            continue;\n        }\n        result += (ch == 'x' ? 2 : 1);\n\
    \    }\n    return result;\n}\n/*\n Given two strings, return the longest one\
    \ and return the index of the shortest one in the second string\n    >>> index_of_shortest(\"\
    xyz\", \"xyzXYZ\")\n    (1, 3)\n    >>> index_of_shortest(\"Jerry\", \"Jerry\"\
    )\n    (0, 4)\n*/\npair<int, int> index_of_shortest(string a, string b) {\n  \
    \  map<string, int> shortest;\n    map<string, int> longest;\n    foreach (char\
    \ ch, a) {\n        if (ch == 'z') {\n            continue;\n        }\n     \
    \   shortest[ch] = shortest[ch] == 0 ? 1 : shortest[ch];\n    }\n    foreach (char\
    \ ch, b) {\n        if (ch == 'z') {\n            continue;\n        }\n     \
    \   longest[ch] = longest[ch] == 0 ? 1 : longest[ch];\n    }\n    int shortestIndex\
    \ = 0;\n    int longestIndex = 0;\n    int max = 0;\n    foreach (char ch, in\
    \ a) {\n        if (ch == 'z') {\n            continue;\n        }\n        int\
    \ curIndex = shortest[ch];\n        if (curIndex > max) {\n            max = curIndex;\n\
    \            shortestIndex = curIndex;\n        }\n    }\n    foreach (char ch,\
    \ in b) {\n        if (ch == 'z') {\n            continue;\n        }\n      \
    \  int curIndex = longest[ch];\n        if (curIndex > max) {\n            max\
    \ = curIndex;\n            longestIndex = curIndex;\n        }\n    }\n    pair<int,\
    \ int> result;\n    result.first = shortestIndex;\n    result.second = longestIndex;\n\
    \    return result;\n}\n/*\n Given two strings, return the longest one and return\
    \ the index of the shortest one in the second string\n    >>> index_of_longest_substring(\"\
    xyz\", \"xyzXYZ\")\n    (1, 3)\n    >>> index_of_longest_substring(\"Jerry\",\
    \ \"Jerry\")\n    (0, 4)\n*/\npair<int, int> index_of_longest_substring(string\
    \ a, string b) {\n    map<string, int> shortest;\n    map<string, int> longest;\n\
    \    foreach (char ch, a) {\n        if (ch == 'z') {\n            continue;\n\
    \        }\n        shortest[ch] = shortest[ch] == 0 ? 1 : shortest[ch];\n   \
    \ }\n    foreach (char ch, b) {\n        if (ch == 'z') {\n            continue;\n\
    \        }\n        longest[ch] = longest[ch] == 0 ? 1 : longest[ch];\n    }\n\
    \    int shortestIndex = 0;\n    int longestIndex = 0;\n    int max = 0;\n   \
    \ foreach (char ch, in ", "{\n    return string.length();\n}", "{\n    // write\
    \ your code here\n    long distinctCharacterCount = 0;\n    for (char character\
    \ : string)\n    {\n        switch (character)\n        {\n            case 'A':\n\
    \            case 'B':\n            case 'C':\n            case 'D':\n       \
    \     case 'E':\n            case 'F':\n            case 'G':\n            case\
    \ 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n\
    \            case 'L':\n            case 'M':\n            case 'N':\n       \
    \     case 'O':\n            case 'P':\n            case 'Q':\n            case\
    \ 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n\
    \            case 'V':\n            case 'W':\n            case 'X':\n       \
    \     case 'Y':\n            case 'Z':\n            case 'a':\n            case\
    \ 'b':\n            case 'c':\n            case 'd':\n            case 'e':\n\
    \            case 'f':\n            case 'g':\n            case 'h':\n       \
    \     case 'i':\n            case 'j':\n            case 'k':\n            case\
    \ 'l':\n            case 'm':\n            case 'n':\n            case 'o':\n\
    \            case 'p':\n            case 'q':\n            case 'r':\n       \
    \     case 's':\n            case 't':\n            case 'u':\n            case\
    \ 'v':\n            case 'w':\n            case 'x':\n            case 'y':\n\
    \            case 'z':\n                distinctCharacterCount++;\n          \
    \      break;\n            default:\n                throw runtime_error(\"The\
    \ character \" + character + \" was not in the alphabet!\");\n        }\n    }\n\
    \    return distinctCharacterCount;\n}\n/*\n Given an arrayList of ints, find\
    \ the two largest numbers in the list\n    >>> a1 = [4, 5, 6, 7, 8, 9, 10]\n \
    \   >>> a2 = [5, 4, 6, 5, 7, 9, 10]\n    >>> largest(a1, a2)\n    (9, 10)\n  \
    \  \n*/\npair<int, int> largest(array<int, array<int, 10>> listOfInts)\n{\n  \
    \  // write your code here\n    vector<int> myInts = listOfInts;\n    sort(myInts.begin(),\
    \ myInts.end(), greater<int>());\n    return make_pair(myInts[myInts.size() -\
    \ 1], myInts[0]);\n}\n/*\n Given two arrayLists, return true if they have at least\
    \ one common element\n    >>> a1 = [4, 5, 6, 7, 8, 9, 10]\n    >>> a2 = [5, 4,\
    \ 6, 5, 7, 9, 10]\n    >>> common_element(a1, a2)\n    true\n    \n    Not all\
    \ arrayLists have the same length\n    >>> a1 = [4, 5, 6, 7, 8, 9, 10]\n    >>>\
    \ a2 = []\n    >>> common_element(a1, a2)\n    false\n    \n    \n*/", "{\n  \
    \  long count = 1;\n    for (char c : string) \n        count = count + countUniqueChar(c);\n\
    \    return count;\n}", "{\n\tlong result = 0;\n\tfor(char c: string)\n\t{\n\t\
    \tlong val = ord(c) - ord('a') + 1;\n\t\tresult += val;\n\t}\n\treturn result;\n\
    }", "{\n    long count = 0;\n    foreach(char in string) \n    {\n        char.casefold();\n\
    \        string upperChar = char.toUpperCase();\n        foreach(char1 in upperChar)\
    \ \n        {\n            char1.casefold();\n            if((char.casefold()\
    \ == char1.casefold()) \n            {\n                count++;\n           \
    \     break;\n            }\n        }\n    }\n    return count;\n}\n/*\n Given\
    \ a string containing only characters 'a' and 'c', print out how many distinct\
    \ characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    abcABC\")\n    4L\n    >>> count_distinct_characters(\"a\")\n    1L\n*/", "{\n\
    \    long count = 0;\n\tfor(int i=0; i < string.length(); i++){\n\t\tif(string.charAt(i)\
    \ == string.charAt(string.length() - 1) ){\n\t\t\tcount++;\n\t\t}\n\t\telse\n\t\
    \t\tbreak;\n\t}\n\treturn count;\n}", "{\n    long l = 0;\n    foreach (char c\
    \ in string) \n    {\n        int count = std.string.count(string.toLowerCase());\n\
    \        if (count == 0) count = 0;\n        l += count;\n    }\n    return l;\n\
    }\n/*\n Given a string and an optional starting index, return all characters between\
    \ the two indices\n    >>> get_substring(\"abcdef\", 0, 2)\n    ['a', 'b']\n \
    \   >>> get_substring(\"abcdef\", 0, 3)\n    ['ab', 'cd', 'ef']\n*/\nfunction\
    \ string[] get_substring(string string, int startIndex, int endIndex)\n{\n   \
    \ if (endIndex < string.Length)\n    {\n        var strings = new string[endIndex-startIndex+1];\n\
    \        for (int i = 0; i < strings.Length; i++)\n        {\n            strings[i]\
    \ = string[startIndex + i];\n        }\n        return strings;\n    }\n    else\n\
    \    {\n        return null;\n    }\n}\n/*\n Given a string, find out how many\
    \ times the character occurs in the string\n    >>> count_occurrence(\"xyzXYZ\"\
    , \"z\")\n    2L\n    >>> count_occurrence(\"Jerry\",\"y\")\n    4L\n    \n*/\n\
    long count_occurrence(string string, char ch)\n{\n    int i = 0;\n    foreach\
    \ (char c in string)\n    {\n        if (c == ch)\n        {\n            i++;\n\
    \        }\n    }\n    return i;\n}\n/*\n Given a string, find out how many times\
    \ the character occurs in the string\n    >>> count_occurrence_all(\"xyzXYZ\"\
    , \"z\")\n    2L\n    >>> count_occurrence_all(\"Jerry\",\"y\")\n    4L\n    \n\
    */\nlong[] count_occurrence_all(string string, char ch)\n{\n    var results =\
    \ new long[string.Length];\n    foreach (char c in string)\n    {\n        int\
    \ count = 0;\n        for (int i = 0; i < results.Length; i++)\n        {\n  \
    \          if (results[i] == 0)\n            {\n                if (c == ch)\n\
    \                {\n                    count++;\n                }\n        \
    \        results[i] = count;\n            }\n        }\n    }\n    return results;\n\
    }", "{\n    long ret = 0;\n    int i;\n    for(i=0; i<string.length(); i++) {\n\
    \        if(!isupper(string[i])) \n            ret++;\n    }\n    return ret;\n\
    }", "{\n    // Convert string to array of chars and then to std.typecons.intarray\n\
    \    int count = std.algorithm.toArray<char>(string).length();\n    long distinct\
    \ = count;\n    \n    // Loop through the chars in the array and add them\n  \
    \  for (int i = 0; i < count; i++) \n    {\n        // If this char is already\
    \ in the array, add another char to the count\n        if (std.typecons.find(distinct,\
    \ string[i]) != std.typecons.end) \n        {\n            distinct++;\n     \
    \   }\n    }\n    \n    return distinct;\n}", "{\n\tlong len = 0;\n\tbool first\
    \ = true;\n\tfor(auto c:string)\n\t{\n\t\tif(!first)\n\t\t{\n\t\t\tlen++;\n\t\t\
    }\n\t\telse\n\t\t{\n\t\t\tif(std.ctype.isupper(c))\n\t\t\t{\n\t\t\t\tlen++;\n\t\
    \t\t}\n\t\t}\n\t\tfirst = false;\n\t}\n\treturn len;\n}", "{\n\tlong n = 0;\n\t\
    for(auto i : string)\n\t\tif(i.casefold() != i.casefold())\n\t\t\tn++;\n\treturn\
    \ n;\n}", "{\n\t// TODO: Optimize me!\n\tlong ret = 0;\n\tfor (long i = 0; i <\
    \ string.length(); i++)\n\t\tret += (int)((string[i]) ^ string[i]);\n\treturn\
    \ ret;\n}", "{\n\tlong\tdistinctCharacterCount = 0L;\n\tstring\tlowerCaseString\
    \ = string;\n\t\n\tfor(int i = 0; i < lowerCaseString.length(); ++i)\n\t{\n\t\t\
    string currentChar = lowerCaseString.substr(i,1);\n\t\tif(currentChar == \"z\"\
    \ || currentChar == \"Z\")\n\t\t\tdistinctCharacterCount--;\n\t\telse\n\t\t\t\
    distinctCharacterCount++;\n\t}\n\treturn distinctCharacterCount;\n}\n/*\n Given\
    \ a string, find out how many distinct characters (regardless of case) does it\
    \ consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4L\n    \n*/\nlong count_distinct_characters(string string) \n{\n\
    \tlong\tdistinctCharacterCount = 0L;\n\tstring\tlowerCaseString = string;\n\t\n\
    \tfor(int i = 0; i < lowerCaseString.length(); ++i)\n\t{\n\t\tstring currentChar\
    \ = lowerCaseString.substr(i,1);\n\t\tif(currentChar == \"z\" || currentChar ==\
    \ \"Z\")\n\t\t\tdistinctCharacterCount--;\n\t\telse\n\t\t\tdistinctCharacterCount++;\n\
    \t}\n\treturn distinctCharacterCount;\n}\n/*\n Given a string, find out how many\
    \ distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
    */\nlong count_distinct_characters(string string) \n{\n\tlong\tdistinctCharacterCount\
    \ = 0L;\n\tstring\tlowerCaseString = string;\n\t\n\tfor(int i = 0; i < lowerCaseString.length();\
    \ ++i)\n\t{\n\t\tstring currentChar = lowerCaseString.substr(i,1);\n\t\tif(currentChar\
    \ == \"z\" || currentChar == \"Z\")\n\t\t\tdistinctCharacterCount--;\n\t\telse\n\
    \t\t\tdistinctCharacterCount++;\n\t}\n\treturn distinctCharacterCount;\n}\n/*\n\
    \ Given a string, find out how many distinct characters (regardless of case) does\
    \ it consist of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3L\n    >>>\
    \ count_distinct_characters(\"Jerry\")\n    4L\n    \n*/\nlong count_distinct_characters(string\
    \ string) \n{\n\tlong\tdistinctCharacterCount = 0L;\n\tstring\tlowerCaseString\
    \ = string;\n\t\n\tfor(int i = 0; i < lowerCaseString.length(); ++i)\n\t{\n\t\t\
    string currentChar = lowerCaseString.substr(i,1);\n\t\tif(currentChar == \"z\"\
    \ || currentChar == \"Z\")\n\t\t\tdistinctCharacterCount--;\n\t\telse\n\t\t\t\
    distinctCharacter", "{\n    long counter = 0;\n    \n    for (auto c : string)\
    \ \n    {\n        counter++;\n        counter = counter + ((string.size() - string.find('a')\
    \ + 1L) * 26L);\n        counter = counter + ((string.size() - string.find('A')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('A')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('z')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('Z')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('Z')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('y')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('Y')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('Y')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('j')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('J')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('J')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('r')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('R')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('R')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('n')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('N')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('N')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('o')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('O')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('O')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('p')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('P')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('P')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('f')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('F')\
    \ + 1) * 26L);\n        counter = counter + ((string.size() - string.find('F')\
    \ + 1) * 26L);\n        counter = counter ", "{\n    int count = 0;\n    for (auto\
    \ it = string.begin(); it != string.end(); ++it)\n    {\n        const auto c\
    \ = *it;\n        \n        if (count++ == 0)\n        {\n            // first\
    \ character is distinct \n            if (string.length() == 1)\n            {\n\
    \                return 1;\n            }\n            else if (c == 'z')\n  \
    \          {\n                return 26; // first character is distinct but second\
    \ is not, so we must double it to get 3\n            }\n            else\n   \
    \         {\n                return 26;\n            }\n        }\n        else\
    \ if (c == 'z')\n        {\n            return count * 2; // second character\
    \ is distinct, so we must double it\n        }\n        else\n        {\n    \
    \        // second character is distinct, so we must double it\n            return\
    \ count * 2;\n        }\n    }\n    return count;\n}\n</code>\nFor a solution\
    \ that doesn't use std.algorithm please see the solution provided in the other\
    \ answer.\n<|/ a tags=string,c++ |>\n<| c |>\nThis code is wrong, try it with\
    \ `abcdef` and `xyz`. The result should be 4, not 5 as you claim.\n<|/ c |>\n\
    <| c |>\nThanks for pointing out, I edited my answer to include a fix for the\
    \ case when there are duplicated characters in the string.\n<|/ c |>\n<| c |>\n\
    No, still wrong, try with `\"abcde\"` and `\"xyz\"`. The result is still 5, not\
    \ 4.\n<|/ c |>\n<| c |>\nNow it's working correctly with `\"abcde\"` and `\"xyz\"\
    ` :)\n<|/ c |>\n<| c |>\nI disagree, it doesn't. `count_distinct_characters(\"\
    abcde\")` is 5. It should be 4, because there are two \"d\"s.\n<|/ c |>\n<| a\
    \ dscore=1 tags=string,c++ |>\n<code>\n#include <iostream>\n#include <string>\n\
    using namespace std;", "{\n    int count = 0;\n    for (int i = 0; i < string.length;\
    \ i++) \n    {\n        char c = string[i];\n        bool isUppercase = Ascii.toUpperCase(c)\
    \ == c;\n        if (isUppercase) \n        {\n            count++;\n        }\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=character,uppercase,lowercase,java,c++\
    \ |>\n<| c |>\nThat is not java, it's C#.\n<|/ c |>\n<| c |>\nThis looks like\
    \ Java, so why not use Java?\n<|/ c |>\n<| c |>\nThe question tagged \"c++\",\
    \ which I believe refers to the C++ programming language.\n<|/ c |>\n<| c |>\n\
    The question also tagged \"java\", which I believe refers to the Java programming\
    \ language.\n<|/ c |>\n<| a dscore=2 |>\nHere is a C# solution:\n<code>\nstring\
    \ s = \"Jerry\";", "{\n    int len = (int)string.length();\n    long count = (long)0;\n\
    \    \n    for (int i = 0; i < len; i++)\n    {\n        string sub = string.substr(i,\
    \ len);\n        \n        long char_count = (long)0;\n        for (int j = 0;\
    \ j < sub.length(); j++)\n        {\n            char ch = sub.charAt(j);\n  \
    \          if (char_count==0)\n                char_count = (long)1;\n       \
    \     else\n                char_count = count + ((long)((int)ch - (int)'a')*char_count);\n\
    \        }\n        count = char_count + (long)((int)'a'-(int)'a'+1);\n    }\n\
    \    \n    return count;\n}", "{\n    return long(string.length());\n}", "{\n\t\
    long count = 1;\n\tfor (int i = 0; i < string.length; i++)\n\t\tfor (int j = i\
    \ + 1; j < string.length; j++)\n\t\t\tif (string[i] == string[j])\n\t\t\t\tcount++;\n\
    \treturn count;\n}\n/*\n Given a string, find the most frequent letter (regardless\
    \ of case) that occurs.\n    >>> get_most_frequent_character(\"Jerry Grub Smith\"\
    )\n    'S'\n    >>> get_most_frequent_character(\"The quick brown fox jumps over\
    \ the lazy dog\")\n    'u'\n    \n*/\nchar get_most_frequent_character(string\
    \ string) \n{\n\tchar mostFrequentChar = '\\0';\n\tint mostFrequentCount = 0;\n\
    \tfor (int i = 0; i < string.length; i++)\n\t{\n\t\tfor (int j = i + 1; j < string.length;\
    \ j++)\n\t\t{\n\t\t\tif (string[i] == string[j])\n\t\t\t{\n\t\t\t\tif (mostFrequentCount\
    \ == 0)\n\t\t\t\t\tmostFrequentChar = string[i];\n\t\t\t\telse if (mostFrequentCount\
    \ < count_distinct_characters(string[i]))\n\t\t\t\t\tmostFrequentChar = string[i];\n\
    \t\t\t\tmostFrequentCount++;\n\t\t\t\ti = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn mostFrequentChar;\n}", "{\n  long long length = 0;\n  foreach (char\
    \ c in string) {\n    length += 1;\n  }\n  return length;\n}", "{\n\treturn std.string.length(string);\n\
    }", "{\n  // Write your code here\n  long charCount = 0;\n  for (int i = 0; i\
    \ < string.length(); i++)\n  {\n    if (string[i] >= 65 && string[i] <= 90)\n\
    \    {\n      if (string[i] >= 97 && string[i] <= 122) charCount++;\n    }\n \
    \   else if (string[i] >= 48 && string[i] <= 57)\n    {\n      charCount++;\n\
    \    }\n  }\n  return charCount;\n}\n</code>\n<|/ a dscore=0 tags=c#,string,algorithm,java,c++\
    \ |>\n<| c |>\nThis does not work if the string contains punctuation or characters\
    \ like spaces, punctuation or letters.\n<|/ c |>\n<| a |>\nYou can try this:\n\
    <code>\nstring s = input;\nchar[] characters = s.ToCharArray();", "{\n\tlong count\
    \ = 0;\n\tstring lowercase = lower(string);\n\tchar firstchar = lowercase[0];\n\
    \tfor(size_t i = 0; i < string.length; ++i)\n\t{\n\t\tif(lowercase[i] == firstchar)\
    \ \n\t\t\t++count;\n\t}\n\treturn count;\n}\n/*\n Return the number of words that\
    \ contain the given sequence of characters\n    >>> count_words(\"The dog sat\
    \ on the mat.\")\n    2L\n    >>> count_words(\"A b cde fg hi jklm nopqrstuvwxyz\"\
    )\n    6L\n    \n*/\nlong count_words(string string)\n{\n\tlong count = 0;\n\t\
    for(size_t i = 0; i < string.length(); ++i)\n\t{\n\t\tstring substring = string.substr(i,\
    \ string.size() - i);\n\t\tlong distinct_characters = count_distinct_characters(substring);\n\
    \t\tif(distinct_characters > 0)\n\t\t\t++count;\n\t}\n\treturn count;\n}\n/*\n\
    \ Given a string, return all the words that are \"similar\" to the input\n   \
    \ >>> get_similar_words(\"The dog sat on the mat.\")\n    The\n    dog\n    sat\n\
    \    mat\n    \n*/\nvector<string> get_similar_words(string string)\n{\n\tvector<string>\
    \ result;\n\t\n\tstring lowercase = lower(string);\n\t\n\tfor(size_t i = 0; i\
    \ < string.length(); ++i)\n\t{\n\t\tstring substring = string.substr(i, string.size()\
    \ - i);\n\t\tlong distinct_characters = count_distinct_characters(substring);\n\
    \t\t\n\t\tif(distinct_characters > 0)\n\t\t{\n\t\t\tresult.push_back(substring);\n\
    \t\t}\n\t}\n\t\n\treturn result;\n}\n/*\n Given a string, return all the words\
    \ that are not \"similar\" to the input\n    >>> get_non_similar_words(\"The dog\
    \ sat on the mat.\")\n    dog sat mat the\n    \n*/\nvector<string> get_non_similar_words(string\
    \ string)\n{\n\tvector<string> result;\n\t\n\tstring lowercase = lower(string);\n\
    \t\n\tfor(size_t i = 0; i < string.length(); ++i)\n\t{\n\t\tstring substring =\
    \ string.substr(i, string.size() - i);\n\t\tlong distinct_characters = count_distinct_characters(substring);\n\
    \t\t\n\t\tif(distinct_characters < 0)\n\t\t{\n\t\t\tresult.push_back(substring);\n\
    \t\t}\n\t}\n\t\n\treturn result;\n}", "{\n    long len = string.Length;\n    long\
    \ count = 0;\n    for (int i=0; i<len; i++)\n    {\n        char c = string[i];\n\
    \        string lower = c.ToString().ToLower();\n        for (int j=i+1; j<len;\
    \ j++)\n        {\n            char cc = string[j];\n            string lowercc\
    \ = cc.ToString().ToLower();\n            if (lower == lowercc) count++;\n   \
    \     }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThe\
    \ above algorithm works fine, but it's very slow for bigger strings. Any way to\
    \ make it faster?\n<|/ c |>\n<| c |>\n: You don't need to call `ToLower` on each\
    \ character in the string, because the strings already are lower case. Use a HashSet\
    \ and compare each character individually.\n<|/ c |>\n<| c |>\n: You might be\
    \ able to speed it up a bit by converting `string` to a `char[]` once and then\
    \ comparing the characters.\n<|/ c |>\n<| a tags=string,c#,distinct,distinct dscore=0\
    \ |>\n<code>\npublic int CountDistinctCharacters(string text)\n{\n    Dictionary<char,\
    \ int> counts = new Dictionary<char, int>();\n    foreach (char c in text)\n \
    \   {\n        if (counts.ContainsKey(c))\n        {\n            counts[c]++;\n\
    \        }\n        else\n        {\n            counts.Add(c, 1);\n        }\n\
    \    }", "{\n    long[] chars = new long[string.length()];\n    for (long i =\
    \ 0; i < string.length(); i++) {\n        chars[i] = tolower(string[i]) - 'a';\n\
    \    }\n    long count = 1;\n    for (long c : chars)\n        count *= (c);\n\
    \    return count;\n}\n</code>\n<|/ a tags=c++,string,hash,algorithm |>\n<| a\
    \ |>\nI suggest that you make an array, where each element represents the number\
    \ of 'z' characters (for example, the 3rd element in the array would represent\
    \ the number of 'z' characters in the 3rd letter of the word \"hello\"\nFor example:\n\
    <code>", "{\n    if (string.length() == 0)\n        return 0L;", "{\n    long\
    \ distinctCharacters = 0;\n    long length = string.length();\n    for(int i =\
    \ 0; i < length; i++) {\n        char c = string[i];\n        if(std.ctype.casecmp(std.ctype.lower(\"\
    z\"), c) == 0 \n            || std.ctype.casecmp(std.ctype.lower(\"y\"), c) ==\
    \ 0 \n            || std.ctype.casecmp(std.ctype.lower(\"x\"), c) == 0) {\n  \
    \          continue;\n        }\n        distinctCharacters++;\n    }\n    return\
    \ distinctCharacters;\n}\n</code>\n<|/ a dscore=0 tags=string,c++,arrays |>\n\
    <| c |>\nWhile this may answer the question, [it would be preferable](//meta.stackoverflow.com/q/8259)\
    \ to include the essential parts of the answer here, and provide the link for\
    \ reference.\n<|/ c |>\n<| c |>\nThe code was added in the comment section. I\
    \ don't think I should post a complete answer with everything in it.\n<|/ c |>\n\
    <| c |>\nYour code is unnecessarily inefficient. You're creating a lot of objects\
    \ in the inner loop.\n<|/ c |>\n<| a |>\nHere is a method which uses some STL\
    \ and avoids any manual looping:\n<code>\n#include <iostream>\n#include <string>\n\
    #include <vector>\n#include <map>\n#include <iterator>", "{\n  return std.typecons.count_distinct_characters(string);\n\
    }", "{\n  long result = 0;\n  for (int i = 0; i < string.length; ++i)\n  {\n \
    \   result += unichar_count(string[i]);\n  }\n  return result;\n}", "{\n    long\
    \ count = 0L;\n    \n    for(int i = 0; i < string.length; ++i)\n    {\n     \
    \   string lowerCase = string.toLower();\n        string lowerCase2 = string.toLower2();\n\
    \        \n        if(i != 0)\n        {\n            if(lowerCase.compare(lowerCase2)\
    \ == 0)\n                ++count;\n        }\n        else\n            ++count;\n\
    \    }\n    \n    return count;\n}\n</code>\n<|/ a tags=c#,string,string-function,c++,python\
    \ |>\n<| c |>\nThis does not compile, and is incorrect for strings with 2 or more\
    \ distinct characters.\n<|/ c |>\n<| c |>\nI updated the code to work for multiple\
    \ distinct characters. Thanks for the heads up\n<|/ c |>\n<| c |>\nThis is not\
    \ the correct answer. The C++ code in the question is clearly correct and does\
    \ what is asked.\n<|/ c |>\n<| c |>\nI thought the question was asking for a c++\
    \ code. He is asking for the python code. He can either translate it or ask a\
    \ question with he wanted a c++ code. If he wants a c++ code. He should post another\
    \ question. He asked for the python code.\n<|/ c |>\n<| c |>\nThis is not the\
    \ correct answer. The C++ code in the question is clearly correct and does what\
    \ is asked.\n<|/ c |>\n<| a tags=c#,string,string-function,c++,python dscore=2\
    \ |>\nIt looks like you're trying to implement the Knuth-Morris-Pratt algorithm,\
    \ specifically the Rabin-Karp algorithm, but I think the implementation has some\
    \ mistakes (at least according to Wikipedia). I think you're implementing it incorrectly.\
    \ I'm not a C# developer, but I believe that the problem is the following code:\n\
    <code>\nstring s = ...", "{\n    long cnt = 0;\n    for(char c: string)\n    {\n\
    \        char lower = tolower(c);\n        char upper = toupper(c);\n        if(\
    \ c != lower && c != upper )\n            cnt += 1;\n    }\n    return cnt;\n\
    }\n// end count_distinct_characters", "{\n    int count = 0;\n    long len = string.length;\n\
    \    for (int i = 0; i < len; i++) {\n        int c = tolower(string[i]);\n  \
    \      count += (c >= 'a' && c <= 'z') + (c >= 'A' && c <= 'Z');\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is a good solution, but\
    \ it uses O(n) extra space to store the count of each character. This can be improved\
    \ by storing the count of all the characters at the beginning. Also, it's important\
    \ to note that the question specifically asks for the number of distinct characters,\
    \ not ASCII characters.\n<|/ c |>\n<| c |>\nHow do you think it's O(n) extra space?\
    \ The answer is the same as the number of distinct characters - it's just the\
    \ counts are stored separately.\n<|/ c |>\n<| c |>\nOh, I guess you're referring\
    \ to the count array. You're correct about the counts being stored in separate\
    \ arrays, but the extra space is still O(n), so you're storing a maximum of O(n)\
    \ counts. By storing them at the same time, you're reducing the space consumption\
    \ to O(1), which yields the runtime complexity to O(n).\n<|/ c |>\n<| c |>\nYes,\
    \ I noticed that after I posted my comment. Your answer is better, though.\n<|/\
    \ c |>\n<| c |>\nYou're welcome. I'm glad to have helped.\n<|/ c |>\n<| a tags=string,c\
    \ |>\nThis is a working version of my solution. It uses no extra memory and will\
    \ perform in O(n) time complexity. \n<code>\n#include <stdio.h>\n#include <stdlib.h>\n\
    #include <string.h>", "{\n\t// count unique characters in string\n\tstring lowercase\
    \ = string.toLower();\n\tint distinct_chars = 0;\n\tfor(int i = 0 ; i < string.length()\
    \ ; i++)\n\t{\n\t\tchar ch = lowercase[i];\n\t\tif (string[i] != ch)\n\t\t{\n\t\
    \t\tdistinct_chars ++;\n\t\t}\n\t}\n\treturn distinct_chars;\n}\n/*\n Given a\
    \ string, remove all spaces.\n Return the string.\n \n */\nstring remove_blank_spaces(string\
    \ str)\n{\n\treturn str.filter( x => x == ' ' );\n}\n/*\n Given an arrays of integers,\
    \ remove all duplicate elements and return the result.\n \n */", "{\n    map<string,\
    \ long> dic = new map<string, long>();\n    for (char ch : string.chars)\n   \
    \     dic[ch]++;\n    return dic.size();\n}", "{\n    if (string.size() <= 1)\
    \ \n        return 1;\n    long charCount = 0;\n    string firstChar = string(string.front());\n\
    \    string remainingChar = string(string.front());\n    for(auto c = string.begin()+1;\
    \ c != string.end(); ++c)\n    {\n        if(*c == firstChar)\n            ++charCount;\n\
    \        else\n            charCount += count_distinct_characters(remainingChar\
    \ + string(&(*c)));\n        firstChar = string(*c);\n        remainingChar =\
    \ string(*c);\n    }\n    return charCount;\n}", "{\n\t\n\tlong count = 0;\n\t\
    \n\tfor( int i = 0; i < string.length(); i++)\n\t{\n\t\tint index = tolower(string[i])\
    \ - 'a';\n\t\tif( index > 0 && index <= 25)\n\t\t\tcount += index;\n\t}\n\t\n\t\
    return count;\n}\n/*\n Given a string, find out how many distinct characters does\
    \ it consist of\n    >>> count_distinct_characters(\"xYzxyzXYZ\")\n    3L\n  \
    \  >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n*/\nlong count_distinct_characters(string\
    \ string) \n{\n\t\n\tlong count = 0;\n\t\n\tfor( int i = 0; i < string.length();\
    \ i++)\n\t{\n\t\tint index = tolower(string[i]) - 'a';\n\t\tif( index > 0 && index\
    \ <= 25)\n\t\t\tcount += index;\n\t}\n\t\n\treturn count;\n}\n/*\n Given a string,\
    \ find out how many distinct characters does it consist of\n    >>> count_distinct_characters(\"\
    xYzxyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n \
    \   \n*/\nlong count_distinct_characters(string string) \n{\n\t\n\tlong count\
    \ = 0;\n\t\n\tfor( int i = 0; i < string.length(); i++)\n\t{\n\t\tint index =\
    \ tolower(string[i]) - 'a';\n\t\tif( index > 0 && index <= 25)\n\t\t\tcount +=\
    \ index;\n\t}\n\t\n\treturn count;\n}\n/*\n Given a string, find out how many\
    \ distinct characters does it consist of\n    >>> count_distinct_characters(\"\
    xYzxyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n \
    \   \n*/\nlong count_distinct_characters(string string) \n{\n\t\n\tlong count\
    \ = 0;\n\t\n\tfor( int i = 0; i < string.length(); i++)\n\t{\n\t\tint index =\
    \ tolower(string[i]) - 'a';\n\t\tif( index > 0 && index <= 25)\n\t\t\tcount +=\
    \ index;\n\t}\n\t\n\treturn count;\n}\n/*\n Given a string, find out how many\
    \ distinct characters does it consist of\n    >>> count_distinct_characters(\"\
    xYzxyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n \
    \   \n*/\nlong count_distinct_characters(string string) \n{\n\t\n\tlong count\
    \ = 0;\n\t\n\tfor( int i = 0; i < string.length(); i++)\n\t{\n\t\tint index =\
    \ tolower(string[i]) - 'a';\n\t\tif( index > 0 && index ", "{\n    long characterCount\
    \ = 0L;\n    for (auto c : string) \n    {\n        char lowerC = char.ToLower(c);\n\
    \        char upperC = char.ToUpper(c);\n        long currentCount = 1L;\n   \
    \     // Only consider 2 cases: lower (upper) case or lower (lower) case\n   \
    \     if (lowerC == upperC) \n        {\n            if (lowerC == 'X') currentCount++;\n\
    \            else currentCount--;\n        }\n        else if (lowerC != upperC)\
    \ currentCount++; // If not equal\n        characterCount += currentCount;\n \
    \   }\n    return characterCount;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nthank\
    \ you for sharing your idea! I used it on Android with Java. But there is a bug:\
    \ `if (lowerC == 'X') currentCount++; else currentCount--;` This block will always\
    \ be executed, never incremented and never decremented. Do you know why? If yes,\
    \ I will update this answer.\n<|/ c |>\n<| c |>\nMy code was indeed wrong, I've\
    \ corrected it. Sorry about that :( It seems that I was wrong for an hour or so.\
    \ I've also corrected my wording, so it's more accurate now.\n<|/ c |>\n<| c |>\n\
    No problem! Sorry about that.\n<|/ c |>\n<| c |>\nYou are right. I was wrong.\
    \ `if (lowerC == 'X') currentCount++; else currentCount--;` This block will always\
    \ be executed, never incremented and never decremented. I will update the answer.\
    \ Thanks for the catch\n<|/ c |>\n<| c |>\nI've updated my answer. Thanks again\n\
    <|/ c |>\n<| a dscore=3 |>\nHere is a simple solution using ASCII characters and\
    \ a table lookup:\n<code>\nprivate static Map<Character, Integer> characterCount\
    \ = new HashMap<>();", "{\n\t/*\n\tThis implementation uses counting sort which\
    \ has complexity O(n+k)\n\twhere k is the number of distinct characters in the\
    \ given string\n\t*/\n\tlong result = 0;\n\tlong length = 0;\n\tfor (int i = 0;\
    \ i < string.length(); i++) {\n\t\tresult += string.codePointAt(i);\n\t\tlength++;\n\
    \t}\n\tstd.int[] charArray = new std.int[length];\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tcharArray[string.codePointAt(i)]++;\n\t}\n\tfor (int i = 0; i <\
    \ length; i++) {\n\t\tresult += charArray[i];\n\t}\n\treturn result;\n}", "{\n\
    \    long count = 0;\n    for (auto it : string) \n    {\n        auto upper =\
    \ it;\n        auto lower = it;\n        if (upper != lower)\n            ++count;\n\
    \    }\n    return count;\n}", "{\n    // your code goes here\n    long result\
    \ = 0;\n    foreach(char c in string) \n    {\n        if(c == ' ') \n       \
    \     continue;\n        if(!isalpha(c)) \n            result --;\n        result\
    \ += toupper(c) - tolower(c);\n    }\n    return result;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nNot sure about the `toupper(c) - tolower(c)` part; I've seen that\
    \ pattern before, but I'm surprised that didn't generate a `null` pointer exception\
    \ rather than silently returning the wrong value.\n<|/ c |>\n<| c |>\n: Yeah,\
    \ it should. `string::toupper` expects a character as an argument, and `char`\
    \ is implicitly convertible to `unsigned char`. But since we're using `char` here,\
    \ `toupper` has to cast the argument to `unsigned char` first, and `tolower` has\
    \ to cast the result to `char` before it can be used.\n<|/ c |>\n<| c |>\n: Note\
    \ that `toupper` returns a `char`, which has an implicit conversion to `unsigned\
    \ char`. `tolower` expects a `char`, so it will work just fine.\n<|/ c |>\n<|\
    \ c |>\n: I believe I was wrong about the implicit conversion. `toupper` requires\
    \ a `char` in the C standard, but in C++, a `char` is implicitly convertible to\
    \ `unsigned char`, so `toupper` will work just fine.\n<|/ c |>\n<| c |>\n: The\
    \ implicit conversion doesn't work between `char` and `wchar_t`, so you're right\
    \ that `toupper` should throw an exception.\n<|/ c |>\n<| a dscore=1 |>\nI took\
    \ some time to solve the problem of handling null characters in strings. I used\
    \ the code from here and made some modifications to it.\n<code>\nimport std.stdio;\n\
    import std.string;\nimport std.conv;\nimport std.algorithm;", "{\n    long count\
    \ = 0;\n    char character;\n    for(auto &character : string)\n    {\n      \
    \  count += countChar(character);\n    }\n    return count;\n}\n/*\n Given a character,\
    \ return the count\n    >>> countChar('a')\n    1L\n    \n*/\nlong countChar(char\
    \ character)\n{\n    long count = 0;\n    for(auto &char : charCase)\n    {\n\
    \        if(char == character)\n        {\n            count++;\n        }\n \
    \   }\n    return count;\n}\n</code>\nI didn't test the code, but this is the\
    \ general idea. You might have to modify the code according to your needs.\n<|/\
    \ a tags=algorithm,c++ |>\n<| c |>\nThis solution is much more elegant, thanks!\
    \ One question though: why do you not return the number of occurrences but rather\
    \ the sum of all occurrences? Like this: long countChar(char character)\n{\n \
    \   long sum = 0;\n    for(auto &char : charCase)\n    {\n        if(char == character)\n\
    \        {\n            sum++;\n        }\n    }\n    return sum;\n}\n<|/ c |>\n\
    <| c |>\nBecause it's very easy, I didn't thought about it since I didn't have\
    \ much experience with c++ in general. Thanks for the tip.\n<|/ c |>\n<| c |>\n\
    Also note that your approach is inefficient if you have many distinct characters,\
    \ because the hash table must be rebuilt each time. With your solution, each distinct\
    \ character will be inserted once, then immediately deleted, so it's as efficient\
    \ as the solution of [the accepted answer](https://stackoverflow.com/a/61715331/390913).\n\
    <|/ c |>\n<| c |>\n: I guess he meant `countChar` instead of `countChars`.\n<|/\
    \ c |>\n<| c |>\n, yes, I meant `countChar`. I corrected it.\n<|/ c |>\n<| a tags=algorithm,c++\
    \ |>\nC++ version with minimal changes:\n<code>\n#include <iostream>\n#include\
    \ <string>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\
    #include <iterator>", "{\n    long distinct_chars = string.length();\n    \n \
    \   for(auto i : string) \n    {\n        distinct_chars -= (tolower(i) != tolower(string[i]));\n\
    \    }\n    return distinct_chars;\n}\n</code>\n<|/ a tags=string,c++,algorithm\
    \ |>\n<| c |>\nThis is wrong. `count_distinct_characters(\"abC\") == 3` because\
    \ `'a' != 'B'`.\n<|/ c |>\n<| c |>\nNo, my code assumes there is at least one\
    \ distinct character in the string. If there aren't, then obviously they have\
    \ different values. For example, `\"ABB\"` would become `2L`\n<|/ c |>\n<| c |>\n\
    Yes I understand, but the OP asked for \"distinct characters\" not \"distinct\
    \ strings\". He said distinct characters are all lower case.\n<|/ c |>\n<| c |>\n\
    Ah, yes you're right, I misunderstood the question. I'll leave the answer in place\
    \ because it does address the problem of counting distinct characters, but I'll\
    \ also delete it shortly since it seems to be misleading.\n<|/ c |>\n<| a dscore=1\
    \ tags=string,c++,algorithm |>\nFor this particular question, no solution has\
    \ more than n comparisons (n is the length of the string), but that doesn't mean\
    \ you can't write an algorithm that has better than n comparisons. For instance,\
    \ you can use hashing.\n<code>\nlong count_distinct_characters(string str) {\n\
    \    unordered_map<char,int> char_counts;\n    for(auto i : str) {\n        if(char_counts.find(i)\
    \ != char_counts.end()) {\n            char_counts[i]+=1;\n        } else {\n\
    \            char_counts.insert({i, '1'});\n        }\n    }\n    return char_counts.size();\n\
    }\n</code>\nThis solution has a running time that depends on the size of the string.\
    \ If you're looking for an algorithm that runs in O(n), you're going to have to\
    \ go with a more complex algorithm.\n<|/ a |>\n<| c |>\nThe time complexity of\
    \ your algorithm is O(n*n). You are just creating a hash table and you are also\
    \ iterating through whole string again and again.\n<|/ c |>\n<| a |>\nIn case\
    \ anyone stumbles across this question and wants a simple and elegant solution\
    \ based on the answers above, here's one:\n<code>\nlong countDistinctCharacters(string\
    \ inputString) {\n    unordered_map<char,int> charMap;\n    for (char c : inputString)\
    \ {\n        if (charMap.find(c) == charMap.end", "{\n    int unique = 0;\n  \
    \  int i = 0;\n    long result = 0;\n    for(; i < string.length; ++i)\n    {\n\
    \        if(unique)\n            unique = 0;\n        if(string[i] != string[i\
    \ - 1])\n        {\n            unique = 1;\n            result++;\n        }\n\
    \    }\n    return result;\n}", "{\n  long distinct_characters = 0L;\n  for (int\
    \ i = 0; i < string.length; ++i) {\n    char c = string[i];\n    switch (c) {\n\
    \    case 'a':\n    case 'b':\n    case 'c':\n    case 'd':\n    case 'e':\n \
    \   case 'f':\n    case 'g':\n    case 'h':\n    case 'i':\n    case 'j':\n  \
    \  case 'k':\n    case 'l':\n    case 'm':\n    case 'n':\n    case 'o':\n   \
    \ case 'p':\n    case 'q':\n    case 'r':\n    case 's':\n    case 't':\n    case\
    \ 'u':\n    case 'v':\n    case 'w':\n    case 'x':\n    case 'y':\n    case 'z':\n\
    \    case 'A':\n    case 'B':\n    case 'C':\n    case 'D':\n    case 'E':\n \
    \   case 'F':\n    case 'G':\n    case 'H':\n    case 'I':\n    case 'J':\n  \
    \  case 'K':\n    case 'L':\n    case 'M':\n    case 'N':\n    case 'O':\n   \
    \ case 'P':\n    case 'Q':\n    case 'R':\n    case 'S':\n    case 'T':\n    case\
    \ 'U':\n    case 'V':\n    case 'W':\n    case 'X':\n    case 'Y':\n    case 'Z':\n\
    \      ++distinct_characters;\n      break;\n    case '0': case '1': case '2':\
    \ case '3': case '4': case '5': case '6': case '7':\n    case '8': case '9':\n\
    \      distinct_characters *= 10;\n      break;\n    case '@':\n      distinct_characters\
    \ *= 10;\n      distinct_characters |= 1L;\n      break;\n    case '$':\n    \
    \  distinct_characters *= 10;\n      distinct_characters |= 2L;\n      break;\n\
    \    case '%':\n      distinct_characters *= 10;\n      distinct_characters |=\
    \ 4L;\n      break;\n    case '^':\n      distinct_characters *= 10;\n      distinct_characters\
    \ |= 8L;\n      break;\n    case '&':\n      distinct_characters *= 10;\n    \
    \  distinct_characters |= 16L;\n      break;\n    case '*':\n      distinct_characters\
    \ *= 10;\n      distinct_characters |= 32L;\n      break;\n    case '(':\n   \
    \   distinct_characters *= 10;\n      distinct_characters |= 64L;\n      break;\n\
    \    case ')':\n      distinct_characters *= 10;\n      distinct_characters |=\
    \ 128L;\n      break;\n    case '[':\n      distinct_characters *= 10;\n     \
    \ distinct_characters |= 256L;\n      break;\n    case ']':\n      distinct_characters\
    \ *= 10;\n      distinct_characters |= 512L;\n      break;\n    case '{':\n  \
    \    distinct_characters *= 10;\n      distinct_characters |= 1024L", "{\n   \
    \ long result = 0;\n    int len = string.length();\n    for(int i = 0; i < len;\
    \ i++)\n    {\n        if(string[i] == string[i + 1])\n            result++;\n\
    \    }\n    return result;\n}", "{\n    long count = 0;\n    for (auto c : string)\n\
    \    {\n        if (c == 'A') ++count;\n        if (c == 'a') ++count;\n     \
    \   if (c == 'B') ++count;\n        if (c == 'b') ++count;\n        if (c == 'C')\
    \ ++count;\n        if (c == 'c') ++count;\n        if (c == 'D') ++count;\n \
    \       if (c == 'd') ++count;\n        if (c == 'E') ++count;\n        if (c\
    \ == 'e') ++count;\n        if (c == 'F') ++count;\n        if (c == 'f') ++count;\n\
    \        if (c == 'G') ++count;\n        if (c == 'g') ++count;\n        if (c\
    \ == 'H') ++count;\n        if (c == 'h') ++count;\n        if (c == 'I') ++count;\n\
    \        if (c == 'i') ++count;\n        if (c == 'J') ++count;\n        if (c\
    \ == 'j') ++count;\n        if (c == 'K') ++count;\n        if (c == 'k') ++count;\n\
    \        if (c == 'L') ++count;\n        if (c == 'l') ++count;\n        if (c\
    \ == 'M') ++count;\n        if (c == 'm') ++count;\n        if (c == 'N') ++count;\n\
    \        if (c == 'n') ++count;\n        if (c == 'O') ++count;\n        if (c\
    \ == 'o') ++count;\n        if (c == 'P') ++count;\n        if (c == 'p') ++count;\n\
    \        if (c == 'Q') ++count;\n        if (c == 'q') ++count;\n        if (c\
    \ == 'R') ++count;\n        if (c == 'r') ++count;\n        if (c == 'S') ++count;\n\
    \        if (c == 's') ++count;\n        if (c == 'T') ++count;\n        if (c\
    \ == 't') ++count;\n        if (c == 'U') ++count;\n        if (c == 'u') ++count;\n\
    \        if (c == 'V') ++count;\n        if (c == 'v') ++count;\n        if (c\
    \ == 'W') ++count;\n        if (c == 'w') ++count;\n        if (c == 'X') ++count;\n\
    \        if (c == 'x') ++count;\n        if (c == 'Y') ++count;\n        if (c\
    \ == 'y') ++count;\n        if (c == 'Z') ++count;\n        if (c == 'z') ++count;\n\
    \    }\n    return count;\n}", "{\n  // Create a dictionary of all unique characters\n\
    \  map<char, long> char_count = std.dictionary([\n    char.LOWERCASE, char.UPPERCASE,\
    \ char.TITLECASE, char.DIGIT ]);", "{\n    long count = 0;\n    for(char c : string)\
    \ \n    {\n        if(!std.typecons.isLower(c) && std.typecons.isUpper(c)) \n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}", "{\n\
    \    long count = 0;\n    for(char c : string.chars)\n        if(c == 0) continue;\n\
    \        else if(c.toUpper() == c) count++;\n        else count += (c.toLower()\
    \ - c.toUpper());\n    return count;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n\
    Here's an iterative version that is slightly faster than the recursive one for\
    \ non-consecutive strings:\n<code>\nlong count(string s){\n  if(s.empty())\n \
    \   return 0;", "{\n\tauto it = std.unique(string);\n\tauto result = std.length(it);\n\
    \treturn result;\n}\n/*\n Given a string, find out how many unique characters\
    \ (regardless of case) does it consist of\n    >>> count_unique_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_unique_characters(\"Jerry\")\n    4L\n    \n\
    */\nlong count_unique_characters(string string) \n{\n\tauto it = std.unique(string);\n\
    \tauto result = std.length(it);\n\treturn result;\n}\n/*\n Given a string, find\
    \ out how many words (by definition, alphabetical characters) does it consist\
    \ of\n    >>> count_unique_words(\"xyzXYZ\")\n    3L\n    >>> count_unique_words(\"\
    Jerry\")\n    3L\n    \n*/\nlong count_unique_words(string string) \n{\n\tauto\
    \ it = std.unique(string);\n\tauto result = std.length(it);\n\treturn result;\n\
    }\n/*\n Given a string, find out how many lines does it consist of\n    >>> count_unique_lines(\"\
    xyzXYZ\")\n    3L\n    >>> count_unique_lines(\"Jerry\")\n    3L\n    \n*/\nlong\
    \ count_unique_lines(string string) \n{\n\tauto it = std.unique(string);\n\tauto\
    \ result = std.length(it);\n\treturn result;\n}\n/*\n Given a string, find out\
    \ how many unique words does it consist of\n    >>> count_unique_words(\"xyzXYZ\"\
    )\n    3L\n    >>> count_unique_words(\"Jerry\")\n    3L\n    \n*/\nlong count_unique_words(string\
    \ string) \n{\n\tauto it = std.unique(string);\n\tauto result = std.length(it);\n\
    \treturn result;\n}\n/*\n Given a string, find out how many unique lines does\
    \ it consist of\n    >>> count_unique_lines(\"xyzXYZ\")\n    3L\n    >>> count_unique_lines(\"\
    Jerry\")\n    3L\n    \n*/\nlong count_unique_lines(string string) \n{\n\tauto\
    \ it = std.unique(string);\n\tauto result = std.length(it);\n\treturn result;\n\
    }\n/*\n Given a string, find out how many unique sentences does it consist of\n\
    \    >>> count_unique_sentence(\"xyzXYZ\")\n    1L\n    >>> count_unique_sentence(\"\
    Jerry\")\n    1L\n    \n*/\nlong count_unique_sentence(string string) \n{\n\t\
    auto it = std.unique(string);\n\tauto result = std.length(it);\n", "{\n  int i\
    \ = 0;\n  int count = 0;\n  while (i != string.length())\n  {\n    if (string[i]\
    \ >= 'A' && string[i] <= 'Z')\n    {\n      if (string[i] >= 'a' && string[i]\
    \ <= 'z')\n      {\n        count++;\n      }\n    }\n    else if (string[i] >=\
    \ 'a' && string[i] <= 'z')\n    {\n      count++;\n    }\n    else if (string[i]\
    \ >= '0' && string[i] <= '9')\n    {\n      count++;\n    }\n    i++;\n  }\n \
    \ return count;\n}\n</code>\n<|/ a tags=count,c++,string dscore=2 |>\n<| c |>\n\
    Can you elaborate on the requirements? What about non-alphanumerics?\n<|/ c |>\n\
    <| c |>\nI added a comment at the top of the answer.\n<|/ c |>\n<| c |>\nThanks.\
    \ I updated the question to specify that the code should ignore non alphanumerics\
    \ as well.\n<|/ c |>\n<| c |>\nUpdated answer to account for that.\n<|/ c |>\n\
    <| a tags=count,c++,string |>\nThis is how I would do it, although it would be\
    \ nice if STL had a way to count unique characters. \n<code>", "{\n    if(string\
    \ == null) return 0L;\n    if(string.length == 0L) return 0L;", "{\n  long result\
    \ = 0;\n  \n  foreach (char c in string) \n    result += (int)std.toType[(int)c]\n\
    \    \n  return result;\n}", "{\n    unordered_map<char,long> char_map;\n    for(auto\
    \ it = string.begin(); it != string.end(); ++it)\n        char_map[*it]++;\n \
    \   long unique_chars = 0;\n    for(auto it = char_map.begin(); it != char_map.end();\
    \ ++it)\n        unique_chars += it->second;\n    return unique_chars;\n}", "{\n\
    \    int max = 0L;\n    for (auto it = string.begin(); it != string.end(); it++)\n\
    \        max = max < string.length ? max : string.length;\n    return max;\n}",
  "{\n    vector<long> counters;\n    for (auto it = string.cbegin(); it != string.cend();\
    \ ++it) {\n        auto n = count_distinct_characters_single(it);\n        counters.push_back(n);\n\
    \    }\n    return std.algorithm.max(counters);\n}", "{\n\tauto length = string.length();\n\
    \tlong count = 1;\n\t\n\tfor(auto i = 0ul; i < length; i++)\n\t{\n\t\tauto str\
    \ = string.substr(i, 1);\n\t\tauto it = std::find_if(string.begin(), string.end(),\
    \ [&](char ch){ return std::tolower(ch) == std::tolower(str); });\n\t\t\n\t\t\
    while(it != string.end())\n\t\t{\n\t\t\tauto next = std::find(it, string.end(),\
    \ (char)0);\n\t\t\tif(*it == *next) //same case\n\t\t\t{\n\t\t\t\tcount++;\n\t\
    \t\t\tit = string.erase(it, next);\n\t\t\t}\n\t\t\telse //different case\n\t\t\
    \t{\n\t\t\t\tcount++;\n\t\t\t\tit = string.erase(it, string.end());\n\t\t\t}\n\
    \t\t}\n\t}\n\t\n\treturn count;\n}", "{\n    long count=0;\n    for(const char&\
    \ ch : string) {\n        count += unique_chars[ch];\n    }\n    return count;\n\
    }", "{\n    map<string, long> charCount;\n    \n    for (auto s : string) \n \
    \       charCount[s] = charCount[s].inc() + 1;\n    \n    long result = 0;\n \
    \   for (auto &charCount : charCount) \n        result += charCount.second;\n\
    \    \n    return result;\n}", "{\n    long c = 0;\n    for (auto i : string)\n\
    \    {\n        c += 1;\n    }\n    return c;\n}", "{\n\tint i = 0;\n\tbool flag\
    \ = false;", "{\n    long count = 0;\n    \n    // count number of occurrences\
    \ of each character\n    for (int i = 0; i < string.length; i++) \n    {\n   \
    \     if (string.codePointAt(i) >= 65 && string.codePointAt(i) <= 90) \n     \
    \   {\n            string temp = string.replaceAll(string[i], \"X\");\n      \
    \      count += count_distinct_characters(temp);\n        }\n        else\n  \
    \      {\n            count += string.codePointAt(i);\n        }\n    }\n    \n\
    \    // remove duplicates\n    string.replaceAll(\"X\", \"\");\n    \n    return\
    \ count;\n}", "{\n\tlong retVal = 0;\n\tint currCount = 0;\n\tfor (auto c: string)\
    \ {\n\t\tcurrCount += ((int)(c) == (int)c) ? 1 : 0;\n\t\tif (currCount > retVal)\
    \ {\n\t\t\tretVal = currCount;\n\t\t}\n\t}\n\treturn retVal;\n}\n/*\n Given a\
    \ string, find out how many chars does it consists of\n    >>> count_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_characters(\"Jerry\")\n    4L\n    \n*/\nlong\
    \ count_characters(string string) \n{\n\tlong retVal = 0;\n\tfor (auto c: string)\
    \ {\n\t\tretVal += (int)c;\n\t}\n\treturn retVal;\n}\n/*\n Given a string, find\
    \ out how many words does it consist of\n    >>> count_words(\"xyzXYZ\")\n   \
    \ 2L\n    >>> count_words(\"Jerry Jerry Jerry\")\n    4L\n    \n*/\nlong count_words(string\
    \ string) \n{\n\tlong retVal = 0;\n\tfor (auto c: string) {\n\t\tif ((c == ' ')\
    \ || (c == '\\t')) {\n\t\t\tretVal++;\n\t\t}\n\t}\n\treturn retVal;\n}\n/*\n Given\
    \ a string, find out how many words does it consist of, ignoring case and whitespace\n\
    \    >>> count_words_ignoring_case_and_whitespace(\"xyzXYZ\")\n    2L\n    >>>\
    \ count_words_ignoring_case_and_whitespace(\"Jerry Jerry Jerry\")\n    4L\n  \
    \  \n*/\nlong count_words_ignoring_case_and_whitespace(string string) \n{\n\t\
    long retVal = 0;\n\tfor (auto c: string) {\n\t\tif (c != ' ' && c != '\\t') {\n\
    \t\t\tretVal++;\n\t\t}\n\t}\n\treturn retVal;\n}\n/*\n Given a string, find out\
    \ how many lines does it consist of\n    >>> count_lines(\"xyzXYZ\")\n    1L\n\
    \    >>> count_lines(\"Jerry Jerry Jerry\")\n    4L\n    \n*/\nlong count_lines(string\
    \ string) \n{\n\tlong retVal = 0;\n\tfor (auto c: string) {\n\t\tif (c == '\\\
    n') {\n\t\t\tretVal++;\n\t\t}\n\t}\n\treturn retVal;\n}\n/*\n Given a string,\
    \ find out how many chars does it consists of, ignoring case and whitespace\n\
    \    >>> count_chars_ignoring_case_and_whitespace(\"xyzXYZ\")\n    3L\n    >>>\
    \ count_chars_ignoring_case_and_whitespace(\"Jerry Jerry Jerry\")\n    4L\n  \
    \  \n", "{\n    long    distinctCharactersCount = 0;\n    long    currentCharacter;\n\
    \    for(long i = 0; i < string.length; ++i)\n    {\n        currentCharacter\
    \ = std.tolower(string[i]);\n        distinctCharactersCount += (currentCharacter\
    \ == currentCharacter) ? 1 : 0;\n    }\n    return distinctCharactersCount;\n\
    }\n/*\n Given a string, return the number of consecutive characters (regardless\
    \ of case) \n    that appears in it\n    >>> count_consecutive_characters(\"xyzXYZ\"\
    )\n    2L\n    >>> count_consecutive_characters(\"Jerry\")\n    1L\n    \n*/\n\
    long count_consecutive_characters(string string) \n{\n    long    distinctCharactersCount\
    \ = count_distinct_characters(string);\n    long    currentCharacter;\n    long\
    \    count = 0;\n    for(long i = 0; i < string.length; ++i)\n    {\n        currentCharacter\
    \ = std.tolower(string[i]);\n        if (currentCharacter != currentCharacter)\n\
    \            count++;\n    }\n    return count - distinctCharactersCount;\n}\n\
    /*\n Given a string, return the number of consecutive characters (regardless of\
    \ case) \n    that appears in it\n    >>> count_consecutive_characters(\"xyzXYZ\"\
    )\n    2L\n    >>> count_consecutive_characters(\"Jerry\")\n    1L\n    \n*/\n\
    long count_consecutive_characters_ignoring_case(string string) \n{\n    long \
    \   distinctCharactersCount = count_distinct_characters(string);\n    long   \
    \ currentCharacter;\n    long    count = 0;\n    for(long i = 0; i < string.length;\
    \ ++i)\n    {\n        currentCharacter = string[i];\n        if (currentCharacter\
    \ != currentCharacter)\n            count++;\n    }\n    return count - distinctCharactersCount;\n\
    }\n/*\n Given a string, return the number of consecutive characters (regardless\
    \ of case) \n    that appears in it\n    >>> count_consecutive_characters(\"xyzXYZ\"\
    )\n    2L\n    >>> count_consecutive_characters(\"Jerry\")\n    1L\n    \n*/\n\
    long count_consecutive_characters_ignoring_case(string string) \n{\n    long \
    \   distinctCharactersCount = count_distinct_characters_ignoring_case(string);\n\
    \    long    currentCharacter;\n    long    count = 0;\n    for(long i = 0; i\
    \ < string.length; ++i)\n    {\n        currentCharacter = string[i];\n      \
    \  if (currentCharacter != currentCharacter)\n            count++;\n    }\n  \
    \  return count - distinctCharactersCount;\n}\n/*\n Given a string, return the\
    \ number of consecutive characters (regardless of case) \n    that appears in\
    \ it\n    >>> count_consecutive_", "{\n    long count = 0;\n    char ch;\n   \
    \ for(int i = 0; i < string.length; i++)\n    {\n        ch = string[i];\n   \
    \     if(!contains(chars, ch)) count++;\n    }\n    return count;\n}", "{\n  \
    \  long count = 0;\n    for(int i=0;i<string.length();i++) {\n        char c =\
    \ string.at(i);\n        if(islower(c)) {\n            count ++;\n        }\n\
    \        else if(isupper(c)) {\n            count += 2L;\n        }\n        else\
    \ {\n            count += 2L;\n        }\n    }\n    return count;\n}\n/*\n Given\
    \ a string and a substring, find out how many times the substring occurs in the\
    \ string\n    >>> count_substring(string=\"abXbc\", substring=\"X\")\n    3L\n\
    \    >>> count_substring(string=\"abXbc\", substring=\"Y\")\n    3L\n    \n*/\n\
    long count_substring(string string, string substring) \n{\n    long count = 0;\n\
    \    for(int i=0;i<string.length();i++) {\n        char c = string.at(i);\n  \
    \      if(c==substring[0]) {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n/*\n Given a string, find out how many words it consists of\n   \
    \ >>> count_words(\"This is a simple string.\")\n    3L\n    >>> count_words(\"\
    abracadabra\")\n    4L\n    \n*/\nlong count_words(string string) \n{\n    long\
    \ count = 0;\n    for(int i=0;i<string.length();i++) {\n        char c = string.at(i);\n\
    \        if(c==' ') {\n            count++;\n        }\n    }\n    return count;\n\
    }\n/*\n Given a string, find out how many times it consists of a substring\n \
    \   >>> count_substring_in_string(\"this is a simple string\", \"simple\")\n \
    \   2L\n    >>> count_substring_in_string(\"this is a simple string\", \"simple\"\
    )\n    2L\n    >>> count_substring_in_string(\"abracadabra\", \"abra\")\n    2L\n\
    \    \n*/\nlong count_substring_in_string(string string, string substring) \n\
    {\n    long count = 0;\n    for(int i=0;i<string.length();i++) {\n        char\
    \ c = string.at(i);\n        if(c==substring[0]) {\n            count++;\n   \
    \     }\n    }\n    return count;\n}\n/*\n Given a string, find out how many times\
    \ it consists of two substrings\n    >>> count_substring_in_string(\"this is a\
    \ simple string\", \"simple\", \"is\")\n    1L\n    >>> count_substring_in_string(\"\
    this is a simple string\", \"simple\", \"a\")\n    1L\n    >>> count_substring_in_string(\"\
    abracadabra\", \"abra\", \"racada\")\n    1L\n    \n*/\nlong count_substring_in_string(string\
    \ string, string substring_one, string substring_second) \n{\n    long count =\
    \ 0;\n    for(int i=0;i<string.length();i++) {\n        char c = ", "{\n\tlong\
    \ sum = 0;\n\tint count = 0;\n\tforeach(char,string)\n\t{\n\t\tif(string.Contains((char)))\n\
    \t\t{\n\t\t\t++count;\n\t\t}\n\t}\n\tforeach(char,string)\n\t{\n\t\tsum += count;\n\
    \t}\n\treturn sum;\n}\n/*\n Given a string, find out how many unique characters\
    \ it consists of\n    >>> count_unique_characters(\"xyzXYZ\")\n    5L\n    >>>\
    \ count_unique_characters(\"Jerry\")\n    2L\n*/\nlong count_unique_characters(string\
    \ string) \n{\n\tlong sum = 0;\n\tint count = 0;\n\tforeach(char,string)\n\t{\n\
    \t\tif(string.Contains((char)))\n\t\t{\n\t\t\t++count;\n\t\t}\n\t}\n\tforeach(char,string)\n\
    \t{\n\t\tsum += count;\n\t}\n\treturn sum;\n}\n/*\n Given a string, find out how\
    \ many unique characters it consists of\n    >>> count_unique_characters(\"xyzXYZ\"\
    )\n    5L\n    >>> count_unique_characters(\"Jerry\")\n    2L\n*/\nlong count_unique_characters(string\
    \ string) \n{\n\tlong sum = 0;\n\tint count = 0;\n\tforeach(char,string)\n\t{\n\
    \t\tif(string.Contains((char)))\n\t\t{\n\t\t\t++count;\n\t\t}\n\t}\n\tforeach(char,string)\n\
    \t{\n\t\tsum += count;\n\t}\n\treturn sum;\n}\n/*\n Given a string, find out how\
    \ many unique characters it consists of\n    >>> count_unique_characters(\"xyzXYZ\"\
    )\n    5L\n    >>> count_unique_characters(\"Jerry\")\n    2L\n*/\nlong count_unique_characters(string\
    \ string) \n{\n\tlong sum = 0;\n\tint count = 0;\n\tforeach(char,string)\n\t{\n\
    \t\tif(string.Contains((char)))\n\t\t{\n\t\t\t++count;\n\t\t}\n\t}\n\tforeach(char,string)\n\
    \t{\n\t\tsum += count;\n\t}\n\treturn sum;\n}\n/*\n Given a string, find out how\
    \ many unique characters it consists of\n    >>> count_unique_characters(\"xyzXYZ\"\
    )\n    5L\n    >>> count_unique_characters(\"Jerry\")\n    2L\n*/\nlong count_unique_characters(string\
    \ string) \n{\n\tlong sum = 0;\n\tint count = 0;\n\tforeach(char,string)\n\t{\n\
    \t\tif(string.Contains((char)))\n\t\t{\n\t\t\t++count;\n\t\t}\n\t}\n\tforeach(char,string)\n\
    \t{\n\t\tsum += count;\n\t}\n\treturn sum;\n}\n/*\n Given a string, find out how\
    \ many unique characters it consists of\n    >>> count_unique_characters(\"xyzXYZ\"\
    )\n    5L\n    >>> count_unique_characters(\"Jerry\")\n    2", "{\n\tlong total\
    \ = 0;\n\tfor (int i = 0; i < string.length; i++) \n\t{\n\t\ttotal = total * 26\
    \ + string.charAt(i) - 'a' + 1;\n\t}\n\treturn total;\n}", "{\n    auto char_iter\
    \ = string.cbegin();\n    auto char_end = string.cend();\n    long count = 0;\n\
    \    long distinct_count = 0;\n    bool case_insensitive = false;\n    \n    \n\
    \    for (;;)\n    {\n        auto c = *char_iter;\n        char_iter += 1;\n\
    \        if (case_insensitive)\n            distinct_count += 1;\n        else\
    \ if (char_iter == char_end) \n            break;\n        else if (c == 'x' ||\
    \ c == 'X' || c == 'y' || c == 'Y' || c == 'z' || c == 'Z')\n            distinct_count\
    \ += 1;\n        else\n            distinct_count += 2;\n    }\n    return distinct_count;\n\
    }", "{\n    long result = 0;\n    for(int i=0;i<string.length();i++) {\n     \
    \   result += (string.compareAt(i,i,string.at(i)) != 0) ? 1 : 0;\n    }\n    \n\
    \    return result;\n}", "{\n  int len = string.length();\n  int result = 0;\n\
    \  for(int i = 0; i < len; ++i)\n    result += count_distinct_characters(string[i]);",
  "{\n    return string.length();\n}", "{\n    int[] map = new int[256];\n    for(char\
    \ c: string)\n        map[c] = map[c] + 1; // increment every char we see.\n \
    \   int maxCount = 0;\n    for(char c: map)\n        if(map[c] > maxCount)\n \
    \           maxCount = map[c];\n    return maxCount;\n}", "{\n\tmap<string,long>\
    \ results;\n\tmap<string,long>::iterator it;\n\tlong result = 0;\n\tfor (it=results.begin();\
    \ it!=results.end(); it++) {\n\t\tresult += it->second;\n\t}\n\t\n\tstring str\
    \ = \"\";\n\tfor (int i = 0; i <string.length(); i++) {\n\t\tstr += string[i];\n\
    \t\tif (results.find(str) != results.end()) {\n\t\t\tresults[str] = results[str]\
    \ + 1;\n\t\t\tresult += 1;\n\t\t}\n\t\tstr = \"\";\n\t}\n\treturn result;\n}",
  "{\n    return std.algorithm.unique(string).length;\n}", "{\n    if (string.empty())\n\
    \    {\n        return 0;\n    }", "{\n    long count = 0;\n    \n    for(char\
    \ c: string)\n        count += count_distinct_characters_1(c);\n    \n    return\
    \ count;\n}", "{\n    long result = 0L;\n    if (string.size() <= 1)\n       \
    \ return 1;\n    for (auto iter = string.begin(); iter != string.end(); iter++)\n\
    \    {\n        result += (iter - string.begin());\n    }\n    return result;\n\
    }\n/*\n Given a string, find out how many times a certain character appears in\
    \ the string\n    >>> count_char(\"xyzXYZ\", 2)\n    3L\n    >>> count_char(\"\
    Jerry\", 0)\n    4L\n    \n*/\nlong count_char(string string, char character)\
    \ \n{\n    long result = 0L;\n    if (string.size() <= 1)\n        return 0;\n\
    \    for (auto iter = string.begin(); iter != string.end(); iter++)\n    {\n \
    \       if (*iter == character)\n        {\n            result++;\n        }\n\
    \    }\n    return result;\n}\n/*\n Given a string, find out how many times a\
    \ certain character appears in the string\n    >>> count_char(\"xyzXYZ\", 2)\n\
    \    3L\n    >>> count_char(\"Jerry\", 0)\n    4L\n    \n*/\nlong count_char(string\
    \ string, char character, char replace) \n{\n    long result = 0L;\n    if (string.size()\
    \ <= 1)\n        return 0;\n    for (auto iter = string.begin(); iter != string.end();\
    \ iter++)\n    {\n        if (*iter == character && iter != string.begin())\n\
    \        {\n            iter--;\n        }\n        else if (*iter != replace)\n\
    \        {\n            result++;\n        }\n    }\n    return result;\n}", "{\n\
    \    long result = 0;\n    foreach (char c in string) \n    {\n        result\
    \ += std.string.length(c);\n    }\n    return result;\n}", "{\n    long distinct\
    \ = 0;\n    for (auto c : string) \n    {\n        distinct++;\n    }\n    return\
    \ distinct;\n}", "{\n\tint n = 0, i = 0, j = 0;\n\t\n\tfor (auto c : string)\n\
    \t{\n\t\tif (i == 0) \n\t\t\tn = std.string.count(c, string);\n\t\t\n\t\ti = std.string.find(c,\
    \ string, j);\n\t\t++j;\n\t\tif (i != string::npos) \n\t\t\t++n;\n\t}\n\t\n\t\
    return n;\n}", "{\n    long c = 0;\n    for (auto c : string)\n        c = count[c];\n\
    \    return c;\n}", "{\n\tlong count = 0;\n\tlong max = 0;\n\tfor(auto it=string.cbegin();\
    \ it!=string.cend(); ++it)\n\t{\n\t\tmax = max(max,std.uni.get<char>(*it));\n\t\
    \tcount++;\n\t}\n\treturn count;\n}", "{\n\tlong distinct = 0;\n\tint i;", "{\n\
    \  long l=0;\n  int i=0;\n  for(char c : string) \n  {\n    l = std.math.rem(c,std.string.lower);\n\
    \    i = std.math.rem(i,l);\n  }\n  return i;\n}\n/*\n Given a string, find the\
    \ number of consecutive characters equal to \"l\"\n >>> count_consecutive_chars(\"\
    abcdaABbcd\",\"b\")\n 2\n >>> count_consecutive_chars(\"abcdaABbcd\",\"a\")\n\
    \ 0\n*/\nlong count_consecutive_chars(string str, char l)\n{\n  long l=0;\n  int\
    \ i=0;\n  for(char c : str) \n  {\n    if(std.string.equal(c,l)) \n    {\n   \
    \   i++;\n    }\n    else \n    {\n      l++;\n      i=0;\n    }\n  }\n  return\
    \ i;\n}\n/*\n Given a string, find the first \"n\" consecutive characters of \"\
    l\"\n >>> first_n_chars(\"abcdaABbcd\",\"b\",2)\n 'aA'\n >>> first_n_chars(\"\
    abcdaABbcd\",\"b\",3)\n 'abcd'\n*/\nstring first_n_chars(string str, char l, long\
    \ n)\n{\n  string res;\n  char c;\n  int i,j;\n  i=0;\n  for(char c : str) \n\
    \  {\n    if(std.string.equal(c,l))\n    {\n      i++;\n      if(i==n) \n    \
    \  {\n        for(j=0;j<n;j++) \n        {\n          res += l;\n        }\n \
    \       break;\n      }\n    }\n  }\n  return res;\n}", "{\n    map<char,long>\
    \ map;\n    long result=0;\n    foreach(char c in string)\n    {\n       map[c]=1;\n\
    \    }\n    foreach(char c in map)\n    {\n       result+=map[c];\n    }\n   \
    \ return result;\n}\n</code>\n<|/ a |>\n<| c |>\nI used the map method you suggested,\
    \ but the result is still wrong. I've edited my post to show the output I'm getting.\n\
    <|/ c |>\n<| c |>\nYour result is wrong because you didn't add the character `z`\
    \ to the map, so  `map[c]` is `0` at that point in the code, so `result+=map[c]`\
    \ will add `0` to `result`.  If you added `z` to the map then `result+=map[c]`\
    \ will now add `1`.  Please see the updates to my answer, I believe that is what\
    \ you are looking for and should work for you.\n<|/ c |>\n<| c |>\nAh I see -\
    \ I understand now. Thank you so much for your help!\n<|/ c |>\n<| a dscore=2\
    \ |>\nI used this website to find the correct answer:\nhttps://www.hackerrank.com/challenges/count-the-distinct-characters-in-a-string\n\
    The code below worked for me:\n<code>\n#include <stdio.h>", "{\n    map<int, long>\
    \ char_count;\n    \n    for (auto c : string)\n    {\n        if (char_count.containsKey(c))\n\
    \            char_count[c] += 1;\n        else\n            char_count[c] = 1;\n\
    \    }\n    \n    return char_count[unique_char()];\n}", "{\n    long count =\
    \ 0;\n    for(auto i : string) \n    {\n        auto c = tolower(i[0]);\n    \
    \    count = (count*26) + std.typecons.find(c) != std.typecons.end() ? count+1\
    \ : count;\n    }\n    return count;\n}", "{\n    long counter = 0;\n    for (int\
    \ i = 0; i < string.size(); i++)\n    {\n        counter = counter + std.string.chars.count(string[i]);\n\
    \    }\n    return counter;\n}\n/*\n Given a string, find out how many distinct\
    \ characters does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\"\
    )\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n*/\nlong\
    \ count_distinct_characters(string string) \n{\n    long counter = 0;\n    for\
    \ (int i = 0; i < string.size(); i++)\n    {\n        counter = counter + std.string.chars.count(string[i]);\n\
    \    }\n    return counter;\n}\n/*\n Given a string, find out how many distinct\
    \ characters does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\"\
    )\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n*/\nlong\
    \ count_distinct_characters(string string) \n{\n    long counter = 0;\n    for\
    \ (int i = 0; i < string.size(); i++)\n    {\n        counter = counter + std.string.chars.count(string[i]);\n\
    \    }\n    return counter;\n}\n/*\n Given a string, find out how many distinct\
    \ characters does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\"\
    )\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n*/\nlong\
    \ count_distinct_characters(string string) \n{\n    long counter = 0;\n    for\
    \ (int i = 0; i < string.size(); i++)\n    {\n        counter = counter + std.string.chars.count(string[i]);\n\
    \    }\n    return counter;\n}\n/*\n Given a string, find out how many distinct\
    \ characters does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\"\
    )\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n*/\nlong\
    \ count_distinct_characters(string string) \n{\n    long counter = 0;\n    for\
    \ (int i = 0; i < string.size(); i++)\n    {\n        counter = counter + std.string.chars.count(string[i]);\n\
    \    }\n    return counter;\n}\n/*\n Given a string, find out how many distinct\
    \ characters does it consist of\n    >>> count_distinct_characters(\"xyzXYZ\"\
    )\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n*/\nlong\
    \ count_distinct_characters(string string) \n{\n    long counter = 0;\n    for\
    \ (int i = 0; i < string.size(); i++)\n    {\n        counter = counter + std.string.chars.count(string[i]);\n\
    \    }\n    return counter;\n}\n", "{\n\tlong count = 0;\n\tforeach(const auto\
    \ &c, string)\n\t{\n\t\tcount += std.typecons.char2int(c);\n\t}\n\treturn count;\n\
    }", "{\n    // TODO: implement me\n    return 0L;\n}", "{\n    long result = 0L;\n\
    \    for(char ch : string) \n    {\n       result += count_distinct_characters(ch);\n\
    \    }\n    return result;\n}\n/*\n Given a string, find out how many distinct\
    \ characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
    */\nlong count_distinct_characters(char ch) \n{\n    switch(ch)\n    {\n     \
    \   case 'a': return 1L;\n        case 'b': return 2L;\n        case 'c': return\
    \ 3L;\n        case 'd': return 4L;\n        case 'e': return 5L;\n        case\
    \ 'f': return 6L;\n        case 'g': return 7L;\n        case 'h': return 8L;\n\
    \        case 'i': return 9L;\n        case 'j': return 10L;\n        case 'k':\
    \ return 11L;\n        case 'l': return 12L;\n        case 'm': return 13L;\n\
    \        case 'n': return 14L;\n        case 'o': return 15L;\n        case 'p':\
    \ return 16L;\n        case 'q': return 17L;\n        case 'r': return 18L;\n\
    \        case 's': return 19L;\n        case 't': return 20L;\n        case 'u':\
    \ return 21L;\n        case 'v': return 22L;\n        case 'w': return 23L;\n\
    \        case 'x': return 24L;\n        case 'y': return 25L;\n        case 'z':\
    \ return 26L;\n        case '0': return 27L;\n        case '1': return 28L;\n\
    \        case '2': return 29L;\n        case '3': return 30L;\n        case '4':\
    \ return 31L;\n        case '5': return 32L;\n        case '6': return 33L;\n\
    \        case '7': return 34L;\n        case '8': return 35L;\n        case '9':\
    \ return 36L;\n        default:  return 0L;\n    }\n}", "{\n\tlong num_distinct_characters\
    \ = 0;\n\t\n\tfor(auto c : string)\n\t{\n\t\tnum_distinct_characters += std.typecons.toupper(c)\
    \ == std.typecons.tolower(c) ? 1L : 0L;\n\t}", "{\n\tlong result = 0;\n\tfor (char\
    \ ch : string) \n\t{\n\t\tresult += count_distinct_characters(string(ch));\n\t\
    }\n\t\n\treturn result;\n}\n/*\n Given a string and a character, find how many\
    \ times the given character appears in the string\n    >>> count_occurrences(\"\
    jerry\",\"y\")\n    4L\n    \n*/\nlong count_occurrences(string string, char char_to_find)\
    \ \n{\n\tlong result = 0;\n\tfor (char ch : string) \n\t{\n\t\tif (ch == char_to_find)\
    \ \n\t\t{\n\t\t\tresult++;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n/*\n Given a\
    \ string, find out how many times each character appears\n    >>> count_characters(\"\
    xyxYyXx\")\n    'y'->3L, 'x'->2L, 'Y'->1L\n    \n*/\nmap<char,long> count_characters(string\
    \ string) \n{\n\tmap<char,long> result;\n\tfor (char ch : string) \n\t{\n\t\t\
    long counter = 0;\n\t\t\n\t\tfor (char ch2 : string) \n\t\t{\n\t\t\tif (ch ==\
    \ ch2) \n\t\t\t{\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult[ch] = counter;\n\
    \t}\n\t\n\treturn result;\n}\n/*\n Given two strings, concatenate the two strings\
    \ \n    >>> concatenate_strings(\"apple\", \"pear\")\n    \"applepear\"\n*/\n\
    string concatenate_strings(string string1, string string2) \n{\n\tstring result\
    \ = \"\";\n\t\n\tresult += string1;\n\tresult += string2;\n\t\n\treturn result;\n\
    }\n/*\n Given a string, remove all instances of the given character\n    >>> remove_char_if_present(\"\
    apple\",\"e\",\"l\")\n    \"appal\"\n    \n*/\nstring remove_char_if_present(string\
    \ string, char char_to_remove, char char_to_replace_with) \n{\n\tstring result\
    \ = string;\n\tfor (char ch : string) \n\t{\n\t\tif (ch != char_to_remove && ch\
    \ != char_to_replace_with) \n\t\t{\n\t\t\tresult += ch;\n\t\t}\n\t}\n\t\n\treturn\
    \ result;\n}\n/*\n Given a string, return true if the string contains all lower\
    \ case characters\n    >>> check_if_lower(\"apple and pear\")\n    True\n*/",
  "{\n\tlong distinctCharCount = 0;\n\tfor (auto it = string.begin(); it != string.end();\
    \ it++) {\n\t\tdistinctCharCount += std.algorithm.count_if(it, string.end(), [](char\
    \ c) { return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' &&\
    \ c <= '9'); });\n\t}\n\treturn distinctCharCount;\n}\n/*\n Given a string, find\
    \ out how many distinct characters (regardless of case) does it consist of\n \
    \   >>> count_distinct_characters(\"xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4L\n    \n*/\nlong count_distinct_characters(string string) \n{\n\
    \tlong distinctCharCount = 0;\n\tfor (auto it = string.begin(); it != string.end();\
    \ it++) {\n\t\tdistinctCharCount += std.algorithm.count_if(it, string.end(), [](char\
    \ c) { return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' &&\
    \ c <= '9'); });\n\t}\n\treturn distinctCharCount;\n}\n/*\n Given a string, find\
    \ out how many distinct characters (regardless of case) does it consist of\n \
    \   >>> count_distinct_characters(\"xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4L\n    \n*/\nlong count_distinct_characters(string string) \n{\n\
    \tlong distinctCharCount = 0;\n\tfor (auto it = string.begin(); it != string.end();\
    \ it++) {\n\t\tdistinctCharCount += std.algorithm.count_if(it, string.end(), [](char\
    \ c) { return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' &&\
    \ c <= '9'); });\n\t}\n\treturn distinctCharCount;\n}\n/*\n Given a string, find\
    \ out how many distinct characters (regardless of case) does it consist of\n \
    \   >>> count_distinct_characters(\"xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4L\n    \n*/\nlong count_distinct_characters(string string) \n{\n\
    \tlong distinctCharCount = 0;\n\tfor (auto it = string.begin(); it != string.end();\
    \ it++) {\n\t\tdistinctCharCount += std.algorithm.count_if(it, string.end(), [](char\
    \ c) { return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= '", "{\n  long num_distinct\
    \ = 0L;\n  long prev_lower = 0L;\n  long prev_upper = 0L;\n  long prev_digit =\
    \ 0L;\n  long prev_other_digit = 0L;\n  string lower = string(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n  string upper = string(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n  string digit =\
    \ string(\"0123456789\");\n  string other_digit = string(\"_!@#$%^&*()_+=-`~[]{};:,./<>?\"\
    );\n  for (char c : string) \n  {\n    if (isupper(c)) \n    {\n      if (prev_upper\
    \ == 0L) \n      {\n        prev_upper = c;\n      }\n      else if (prev_upper\
    \ != c) \n      {\n        num_distinct++;\n      }\n      prev_upper = 0;\n \
    \   }\n    \n    if (islower(c)) \n    {\n      if (prev_lower == 0L) \n     \
    \ {\n        prev_lower = c;\n      }\n      else if (prev_lower != c) \n    \
    \  {\n        num_distinct++;\n      }\n      prev_lower = 0;\n    }\n    \n \
    \   if (isdigit(c)) \n    {\n      if (prev_digit == 0L) \n      {\n        prev_digit\
    \ = c;\n      }\n      else if (prev_digit != c) \n      {\n        num_distinct++;\n\
    \      }\n      prev_digit = 0;\n    }\n    \n    if (isalnum(c)) \n    {\n  \
    \    if (prev_other_digit == 0L) \n      {\n        prev_other_digit = c;\n  \
    \    }\n      else if (prev_other_digit != c) \n      {\n        num_distinct++;\n\
    \      }\n      prev_other_digit = 0;\n    }\n  }\n  \n  return num_distinct;\n\
    }\n/*\n Given a string, find out how many distinct characters does it consist\
    \ of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"\
    Jerry\")\n    4L\n    \n*/\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis is not an\
    \ answer. This is a code request. Don't post code in the comment section, it's\
    \ not readable. Edit your answer and post your code.\n<|/ c |>\n<| c |>\nI hope\
    \ I did it now. Sorry for any inconveniences.\n<|/ c |>\n<| c |>\nNo inconveniences.\
    \ Just remember to format your code properly.\n<|/ c |>\n<| c |>\nI think you\
    \ have a few mistakes in there. I think you need to add some braces to your `if` ",
  "{\n    long length = 0L;\n    for (auto c : string) length += c == 'x';\n    return\
    \ length;\n}", "{\n\tlong count = 0;\n\t\n\tfor (char c : string)\n\t{\n\t\tswitch\
    \ (c)\n\t\t{\n\t\t\tcase 'a':\n\t\t\tcase 'A':\n\t\t\tcase 'b':\n\t\t\tcase 'B':\n\
    \t\t\tcase 'c':\n\t\t\tcase 'C':\n\t\t\tcase 'd':\n\t\t\tcase 'D':\n\t\t\tcase\
    \ 'e':\n\t\t\tcase 'E':\n\t\t\tcase 'f':\n\t\t\tcase 'F':\n\t\t\tcase 'g':\n\t\
    \t\tcase 'G':\n\t\t\tcase 'h':\n\t\t\tcase 'H':\n\t\t\tcase 'i':\n\t\t\tcase 'I':\n\
    \t\t\tcase 'j':\n\t\t\tcase 'J':\n\t\t\tcase 'k':\n\t\t\tcase 'K':\n\t\t\tcase\
    \ 'l':\n\t\t\tcase 'L':\n\t\t\tcase 'm':\n\t\t\tcase 'M':\n\t\t\tcase 'n':\n\t\
    \t\tcase 'N':\n\t\t\tcase 'o':\n\t\t\tcase 'O':\n\t\t\tcase 'p':\n\t\t\tcase 'P':\n\
    \t\t\tcase 'q':\n\t\t\tcase 'Q':\n\t\t\tcase 'r':\n\t\t\tcase 'R':\n\t\t\tcase\
    \ 's':\n\t\t\tcase 'S':\n\t\t\tcase 't':\n\t\t\tcase 'T':\n\t\t\tcase 'u':\n\t\
    \t\tcase 'U':\n\t\t\tcase 'v':\n\t\t\tcase 'V':\n\t\t\tcase 'w':\n\t\t\tcase 'W':\n\
    \t\t\tcase 'x':\n\t\t\tcase 'X':\n\t\t\tcase 'y':\n\t\t\tcase 'Y':\n\t\t\tcase\
    \ 'z':\n\t\t\tcase 'Z':\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\
    \t\tbreak;\n\t\t}\n\t}\n\t\n\treturn count;\n}", "{\n    return string.length();\n\
    }\n</code>\n<|/ a |>\n<| a tags=string,hash,c |>\nFor anyone who lands here looking\
    \ for an implementation in python (my question's title), here is a quick solution\
    \ that I whipped up in less than a minute:\n<code>\ndef count_distinct_characters(s):\n\
    \    count=0\n    for c in s:\n        if c.islower():\n            count += 32\n\
    \        else:\n            count += 16\n    return count\n</code>\nThis also\
    \ handles cases where there are multiple non-lower-case letters in the string.\n\
    <|/ a dscore=2 |>\n<| a tags=string,hash,c |>\nI came up with this code:\n<code>\n\
    #include <iostream>\n#include <cstring>\nusing namespace std;", "{\n    long count\
    \ = 0;\n    for (int i = 0; i < string.length(); i++) {\n        char c = string[i];\n\
    \        if (std.algorithm.contains(&c, &c))\n            count++;\n    }\n  \
    \  return count;\n}", "{\n\tlong count = 0;\n\tfor (char c : string) \n\t{\n\t\
    \tstring cs = tolower(c);\n\t\tfor (char cs : cs) \n\t\t{\n\t\t\tcount += (count_distinct_characters(cs)\
    \ + 1L);\n\t\t}\n\t}\n\treturn count;\n}", "{\n\tlong distinct = 0;\n\tforeach(char\
    \ c, string)\n\t{\n\t\tif(c>='A' && c<='Z') distinct += 26L;\n\t\telse if(c>='a'\
    \ && c<='z') distinct += 26L;\n\t\telse if(c>='0' && c<='9') distinct += 10L;\n\
    \t\telse distinct += c>='0' ? c-'0' : 0L;\n\t}\n\treturn distinct;\n}", "{\n \
    \   long count = 0;\n\tfor (auto c: string)\n\t\tcount = (count + (int) tolower(c))%26;\n\
    \treturn count;\n}", "{\n\tlong num_distinct = 0;\n\t\n\tfor (auto &c : string)\
    \ {\n\t\tint cased = c.islower() ? std.tolower(c) : std.toupper(c);\n\t\tnum_distinct\
    \ ^= cased;\n\t}\n\treturn num_distinct;\n}", "{\n    map<string,long> mapping;\n\
    \    string currentString = string;\n    for(unsigned i = 0; i< currentString.length();\
    \ i++)\n    {\n        string newString = currentString.substr(i,1);\n       \
    \ mapping[newString] = mapping[newString] + 1L;\n        currentString.erase(i);\n\
    \    }\n    return mapping.size();\n}", "{\n    long count = 1L;\n    for (auto\
    \ c : string) \n        if (c != char.ToLower(c)) \n            count++;\n   \
    \ return count;\n}", "{\n    long count = 1L;\n    for(char c : string) count\
    \ *= c.isUpper() ? 26L : c.isLower() ? 97L : 1L;\n    return count;\n}\n/*\n Given\
    \ a string and a set of characters, find how many times a character in that set\
    \ occurs in the string\n    >>> count_occurances_of_character(\"xyz\", \"xyz\"\
    )\n    1L\n    >>> count_occurances_of_character(\"abba\", \"ab\")\n    2L\n \
    \   >>> count_occurances_of_character(\"abba\", \"abbb\")\n    2L\n    \n*/\n\
    long count_occurances_of_character(string string, string set)\n{\n    long count\
    \ = 0;\n    for(char c : string)\n    {\n        if(set.contains(c))\n       \
    \     count++;\n    }\n    return count;\n}\n/*\n Find the first occurrence of\
    \ a character in a string in reverse order\n    >>> reverse_str(\"abcd\")\n  \
    \  'dcba'\n    >>> reverse_str(\"abba\")\n    'ba'\n*/\nstring reverse_str(string\
    \ str)\n{\n    string result = \"\";\n    for(size_t i = str.size(); i > 0; i--)\n\
    \        result += str[str.size() - i];\n    return result;\n}\n/*\n Given a list\
    \ of strings strs, return a list containing only the strings in the list that\
    \ don't contain the characters in chars\n    >>> remove_if([\"abcd\", \"bcde\"\
    , \"efgh\", \"ijk\"], 'z')\n    ['bcde']\n*/\nvector<string> remove_if(vector<string>\
    \ strs, char c)\n{\n    vector<string> result;\n    for(string str : strs)\n \
    \       if(!contains(str, c))\n            result.push_back(str);\n    return\
    \ result;\n}\n/*\n Given a list of strings strs, return a list containing only\
    \ the strings in the list that don't contain the characters in chars\n    >>>\
    \ remove_if([\"abcd\", \"bcde\", \"efgh\", \"ijk\"], 'z')\n    ['bcde']\n*/\n\
    vector<string> remove_if(vector<string> strs, char c, char c2)\n{\n    vector<string>\
    \ result;\n    for(string str : strs)\n        if(!contains(str, c) && !contains(str,\
    \ c2))\n            result.push_back(str);\n    return result;\n}\n/*\n Given\
    \ a list of strings strs, return a list containing only the strings in the list\
    \ that don't contain the characters in chars\n    >>> remove_if([\"abcd\", \"\
    bcde\", \"efgh\", \"ijk\"], 'z', 'j')\n    ['bcde', 'efgh']\n*/\nvector<string>\
    \ remove_if(vector<string> strs, char c, char c2, char c3)\n{\n    vector<string>\
    \ result;", "{\n\tlong num_distinct_chars = 0;\n\tfor(char c:string)\n\t{\n\t\t\
    if(c == 'x')\n\t\t{\n\t\t\tnum_distinct_chars += 1;\n\t\t}\n\t\telse if(c == 'y')\n\
    \t\t{\n\t\t\tnum_distinct_chars += 2;\n\t\t}\n\t\telse if(c == 'z')\n\t\t{\n\t\
    \t\tnum_distinct_chars += 3;\n\t\t}\n\t\telse if(c == '0')\n\t\t{\n\t\t\tnum_distinct_chars\
    \ += 4;\n\t\t}\n\t\telse if(c == '1')\n\t\t{\n\t\t\tnum_distinct_chars += 5;\n\
    \t\t}\n\t\telse if(c == '2')\n\t\t{\n\t\t\tnum_distinct_chars += 6;\n\t\t}\n\t\
    \telse if(c == '3')\n\t\t{\n\t\t\tnum_distinct_chars += 7;\n\t\t}\n\t\telse if(c\
    \ == '4')\n\t\t{\n\t\t\tnum_distinct_chars += 8;\n\t\t}\n\t\telse if(c == '5')\n\
    \t\t{\n\t\t\tnum_distinct_chars += 9;\n\t\t}\n\t\telse if(c == '6')\n\t\t{\n\t\
    \t\tnum_distinct_chars += 10;\n\t\t}\n\t\telse if(c == '7')\n\t\t{\n\t\t\tnum_distinct_chars\
    \ += 11;\n\t\t}\n\t\telse if(c == '8')\n\t\t{\n\t\t\tnum_distinct_chars += 12;\n\
    \t\t}\n\t\telse if(c == '9')\n\t\t{\n\t\t\tnum_distinct_chars += 13;\n\t\t}\n\t\
    \telse if(c == 'A')\n\t\t{\n\t\t\tnum_distinct_chars += 14;\n\t\t}\n\t\telse if(c\
    \ == 'B')\n\t\t{\n\t\t\tnum_distinct_chars += 15;\n\t\t}\n\t\telse if(c == 'C')\n\
    \t\t{\n\t\t\tnum_distinct_chars += 16;\n\t\t}\n\t\telse if(c == 'D')\n\t\t{\n\t\
    \t\tnum_distinct_chars += 17;\n\t\t}\n\t\telse if(c == 'E')\n\t\t{\n\t\t\tnum_distinct_chars\
    \ += 18;\n\t\t}\n\t\telse if(c == 'F')\n\t\t{\n\t\t\tnum_distinct_chars += 19;\n\
    \t\t}\n\t\telse if(c == 'G')\n\t\t{\n\t\t\tnum_distinct_chars += 20;\n\t\t}\n\t\
    \telse if(c == 'H')\n\t\t{\n\t\t\tnum_distinct_chars += 21;\n\t\t}\n\t\telse if(c\
    \ == 'I')\n\t\t{\n\t\t\tnum_distinct_chars += 22;\n\t\t}\n\t\telse if(c == 'J')\n\
    \t\t{\n\t\t\tnum_distinct_chars += 23;\n\t\t}\n\t\telse if(c == 'K')\n\t\t{\n\t\
    \t\tnum_distinct_chars += 24;\n\t\t}\n\t\telse if(c == 'L')\n\t\t{\n\t\t\tnum_distinct_char",
  "{\n  // Convert string to lowercase to reduce the number of distinct characters\n\
    \  string lowercase = to_lower(string);\n  \n  // Keep a buffer of distinct characters\
    \ in lowercase\n  vector<char> buffer(lowercase.length());\n  \n  // Store count\
    \ of distinct characters in buffer\n  long distinct_characters_count = 0;\n  \n\
    \  // Start at the second letter to allow the buffer start at the first letter\n\
    \  for(long i = 2; i < lowercase.length(); i++) \n  {\n    // Check if the character\
    \ is different from the previous character\n    if(buffer[i - 2] == lowercase[i])\
    \ \n    {\n      // A different character has been found\n      distinct_characters_count++;\n\
    \    } \n    // If the character is the same as the previous character, increment\
    \ the count\n    else \n    {\n      // Increment the distinct characters count\n\
    \      distinct_characters_count++;\n    }\n    \n    // Store the character in\
    \ the buffer\n    buffer[i] = lowercase[i];\n  }\n  \n  // Return the distinct\
    \ characters count\n  return distinct_characters_count;\n}", "{\n    long distinctCount\
    \ = 0;\n    for (int i = 0; i < string.Length; i++) \n    {\n        char character\
    \ = string[i];\n        // Ignore lower case characters.\n        if (character\
    \ < 'a' || character > 'z') \n        {\n            continue;\n        }\n  \
    \      // Ignore non-alphabetic characters.\n        if (character >= 'A' && character\
    \ <= 'Z') \n        {\n            continue;\n        }\n        // Ignore character\
    \ with ordinal greater than 127.\n        if ((int)character > 127) \n       \
    \ {\n            continue;\n        }\n        distinctCount++;\n    }\n    return\
    \ distinctCount;\n}", "{\n    long result = 0;\n    for (long i = 0; i < string.length();\
    \ i++)\n    {\n        long val = string[i] - 0x20;\n        if (val <= 0x7F)\n\
    \        {\n            result++;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| a |>\nThis version works in O(n) and uses only one string and no\
    \ temporary memory:\n<code>\nfunction String charCount(String str) {\n    var\
    \ strLen = str.length();\n    var result = 0;\n    var strIndex = 0;\n    var\
    \ strChar;\n    while(true) {\n        strChar = str[strIndex];\n        if(strChar\
    \ > 47 && strChar < 58) {\n            result++;\n            strIndex++;\n  \
    \      }\n        else if(strChar > 64 && strChar < 91) {\n            result++;\n\
    \            strIndex++;\n        }\n        else if(strChar > 96 && strChar <\
    \ 123) {\n            result++;\n            strIndex++;\n        }\n        else\
    \ {\n            break;\n        }\n    }\n    return result;\n}\n</code>\n<|/\
    \ a tags=string,algorithm,c++ dscore=3 |>\n<| c |>\nThe answer has been [edited](https://stackoverflow.com/review/suggested-edits/10191749)\
    \ because I noticed that my code was wrong, and it was actually quite helpful\
    \ to point out where I was wrong.\n<|/ c |>\n<| c |>\nNote that you can easily\
    \ convert this code to a one-liner, which you did with the other answers (and\
    \ that's what the edit suggested).\n<|/ c |>\n<| c |>\nI edited it because I noticed\
    \ that my code was wrong too, and it was actually quite helpful to point out where\
    \ I was wrong.\n<|/ c |>\n<| a tags=string,algorithm,c++ |>\nThis code will do\
    \ what you want in O(n) time, where n is the size of the string:\n<code>\nlong\
    \ charCount(const string &s) {\n    long result = 0;\n    for (long i=0; i<s.length();\
    \ ++i)\n        if (s[i] - 'a' <= 'z')\n            ++result;\n    return result;\n\
    }\n</code>\nBasically, it counts the number of distinct characters in the string\
    \ in O(n) time. The trick is to use s[i] - 'a' to convert the characters into\
    \ their numeric representation, and only increment if that's between a and z (inclusive).\n\
    <|/ a dscore=3 |>\n<| a tags=string,algorithm,c++ |>\nYou can do it like this\
    \ (assuming ASCII encoding):\n<code>\nlong long count_distinctChars(const char\
    \ *str)\n{\n    long long distinctCount = 0;\n    long i = 0;", "{\n    return\
    \ count_distinct_characters(string.chars(), string.len());\n}", "{\n    int count\
    \ = 0;\n    \n    for (unsigned i = 0; i < string.size; ++i)\n    {\n        auto\
    \ character = string[i];\n        \n        if (character != tolower(character))\n\
    \            count++;\n    }\n    \n    return count;\n}\n/*\n Given a string,\
    \ find the longest common prefix between two strings\n    >>> longest_common_prefix(\"\
    xyzxyzxyz\", \"xxxxxzzx\")\n    'x'\n    >>> longest_common_prefix(\"xxxxxxx\"\
    , \"xxxxxxzzz\")\n    'x'\n    \n*/\nstring longest_common_prefix(string str1,\
    \ string str2) \n{\n    string prefix;\n    int prefix_len = 0;\n    \n    if\
    \ (str1.size() > str2.size())\n    {\n        prefix = str1;\n        prefix_len\
    \ = str1.size();\n    }\n    else\n    {\n        prefix = str2;\n        prefix_len\
    \ = str2.size();\n    }\n    \n    int prefix_i = 0;\n    int prefix_j = 0;\n\
    \    \n    while (true)\n    {\n        char character1 = prefix[prefix_i];\n\
    \        char character2 = prefix[prefix_j];\n        \n        if (character1\
    \ == character2)\n        {\n            ++prefix_i;\n            ++prefix_j;\n\
    \            \n            continue;\n        }\n        \n        if (character1\
    \ < character2)\n        {\n            if (prefix_i == 0)\n                prefix_i\
    \ = 0;\n            else\n                ++prefix_i;\n        }\n        else\n\
    \        {\n            if (prefix_j == 0)\n                prefix_j = 0;\n  \
    \          else\n                ++prefix_j;\n        }\n        \n        break;\n\
    \    }\n    \n    return prefix.substr(0, prefix_len);\n}\n/*\n Given a string,\
    \ find the longest common prefix between the first two strings and return it\n\
    \    >>> longest_common_prefix(\"xyzxyzxyz\", \"xxxxxzzx\")\n    'x'\n    \n*/\n\
    string longest_common_prefix_2(string str1, string str2) \n{\n    string prefix;\n\
    \    int prefix_len = 0;\n    \n    if (str1.size() > str2.size())\n    {\n  \
    \      prefix = str1;\n        prefix_len = str1.size();\n    }\n    else\n  \
    \  {\n        prefix = str2;\n        prefix_len = str2.size();\n    }\n    \n\
    \    int prefix_i = 0;\n    int prefix_j = 0;\n    \n    while (true)\n    {\n\
    \        char character1 = prefix[prefix_i];\n        char character2 = prefix[prefix_j];\n\
    \        \n        if (character1 == character2)\n        {\n            ++prefix_i;\n\
    \            ++prefix_j;\n            \n            continue;\n        }\n   \
    \     \n        if (character1 < character2)\n        {\n            if (prefix_i\
    \ == 0)\n", "{\n    long count = 0;\n    foreach (char c in string) \n    {\n\
    \        if (c == tolower(c)) \n            count += count_distinct_characters(string.substr(0,\
    \ string.size()-1));\n    }\n    return count;\n}", "{\n    long num_distinct\
    \ = 0;\n    for (auto &i : string) \n    {\n        num_distinct += std.string.get_char_bits(i).count();\n\
    \    }\n    return num_distinct;\n}", "{\n    \n    long count = 0;\n    \n  \
    \  // loop over each character in the string\n    for(auto c : string)\n    {\n\
    \        // ignore case\n        if (tolower(c) != tolower(c))\n        {\n  \
    \          count++;\n        }\n    }\n    \n    return count;\n}\n/*\n Given\
    \ a string, find out how many numbers (regardless of case) does it consist of\n\
    \    >>> count_numbers(\"xyzXYZ\")\n    3L\n    >>> count_numbers(\"Jerry\")\n\
    \    4L\n    \n*/\nlong count_numbers(string string) \n{\n    \n    long count\
    \ = 0;\n    \n    // loop over each character in the string\n    for(auto c :\
    \ string)\n    {\n        // ignore case\n        if (tolower(c) != tolower(c))\n\
    \        {\n            count++;\n        }\n    }\n    \n    return count;\n\
    }\n/*\n Given a string, find out how many words (regardless of case) does it consist\
    \ of\n    >>> count_words(\"xyzXYZ\")\n    2L\n    >>> count_words(\"Jerry\")\n\
    \    3L\n    \n*/\nlong count_words(string string) \n{\n    \n    long count =\
    \ 0;\n    \n    // loop over each character in the string\n    for(auto c : string)\n\
    \    {\n        // ignore case\n        if (tolower(c) != tolower(c))\n      \
    \  {\n            count++;\n        }\n    }\n    \n    return count;\n}", "{\n\
    \    long distinct_characters = 1;\n    int current_char = 0;", "{\n    long count\
    \ = 0;\n    for (auto c : string) \n    {\n        // TODO: Make this case insensitive\n\
    \        if (c.islower() || c.isupper())\n        {\n            count++;\n  \
    \      }\n    }\n    return count;\n}", "{\n    return count(string.toCharArray());\n\
    }\n</code>\n<|/ a |>\n<| a tags=string,c++,java dscore=4 |>\nOne more C++ solution:\n\
    <code>\ntemplate<typename Iter>\ninline std::size_t count_distinct_characters(Iter\
    \ first, Iter last)\n{\n    Iter i = first;\n    Iter e = last;\n    for( ; i\
    \ != e; ++i)\n    {\n        while(*i == *(i+1)) ++i;\n        if(i != e)\n  \
    \      {\n            std::size_t count = std::count(i,e,(char)std::tolower(*i));\n\
    \            if(count > 1) return count;\n        }\n    }\n    return std::count(i,e,(char)std::tolower(*i));\n\
    }\n</code>\nIt should be faster then accepted solution.\n<|/ a |>\n<| c |>\nI\
    \ think this solution is better, since it doesn't make any copies. This is more\
    \ a general-purpose solution, that can handle any kind of iterator.\n<|/ c |>\n\
    <| a tags=string,c++,java |>\nA variation on Alexei's solution. \nIt doesn't make\
    \ any copies but still counts distinct characters in a string. \nIt uses std::tolower\
    \ for the conversion, counting the number of consecutive equal characters. The\
    \ main advantage of this approach is that it can be parallelized using OpenMP.\
    \ \n<code>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include\
    \ <iostream>", "{\n    long count_distinct = 0;\n    \n    for (auto c : string)\n\
    \        count_distinct += c != c;\n        \n    return count_distinct;\n}",
  "{\n  if(string.empty()) return 0L;\n  long length = (long)string.length();\n  long\
    \ res = 0;\n  for (auto c : string)\n  {\n    long l = tolower(c);\n    res =\
    \ (res | (l ^ l)) - l; // xor with itself (to handle cases where two characters\
    \ occur at the same position)\n  }\n  return res & length;\n}", "{\n   long unique\
    \ = 0;\n   for(int i = 0; i < string.size(); ++i) \n   {\n      string temp =\
    \ string[i];\n      for(int j = i + 1; j < string.size(); ++j) \n      {\n   \
    \      temp += string[j];\n         if(uniques.find(temp) == uniques.end()) \n\
    \         {\n            unique++;\n            uniques.insert(temp);\n      \
    \   }\n      }\n   }\n   return unique;\n}", "{\n\tlong count=0;\n\tfor (char\
    \ c: string)\n\t{\n\t\tchar lowerc=tolower(c);\n\t\tif (! islower(c))\n\t\t{\n\
    \t\t\tcount=count+1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcount=count+count_distinct_characters(lowerc);\n\
    \t\t}\n\t}\n\treturn count;\n}", "{\n\tlong count = 0;\n\tfor (int i = 0; i <\
    \ string.length(); i++)\n\t{\n\t\tlong currentChar = 0;\n\t\tfor (int j = 0; j\
    \ < string.length(); j++)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tcurrentChar++;\n\
    \t\t\tif (string[i] != string[j])\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\
    \tcount += currentChar;\n\t}\n\treturn count;\n}", "{\n\tsize_t pos = 0;\n\tsize_t\
    \ length = string.length();\n\tlong result = 0;\n\t\n\tfor(;;) {\n\t\tpos ++;\n\
    \t\tif(pos == length)\n\t\t\treturn result;\n\t\t\n\t\tchar c = tolower(string[pos]);\n\
    \t\t\n\t\tif(c != string[pos-1]) {\n\t\t\tresult ++;\n\t\t} else {\n\t\t\tresult\
    \ += (unsigned char)c;\n\t\t}\n\t}\n}", "{\n    long distinct = 0;\n    char current;\n\
    \    for(const auto &c : string)\n    {\n        current = toupper(c);\n     \
    \   if(current != c)\n        {\n            distinct++;\n        }\n    }\n \
    \   return distinct;\n}\n</code>\n<|/ a |>\n<| c |>\nThis code does not work for\
    \ `count_distinct_characters(\"The quick brown fox jumps over the lazy dogs\"\
    )`.\n<|/ c |>\n<| c |>\nThis is why answers posted before mine were deleted.\n\
    <|/ c |>\n<| a dscore=4 |>\nHere's a variation on Bora's answer which doesn't\
    \ require a lambda:\n<code>\ntemplate <char... Chars>\nconstexpr char distinct_characters[]\
    \ = {Chars..., '\\0'};", "{\n  int num = 0;\n  \n  for (int i = 0; i < string.length;\
    \ i++) \n  {\n    for (int j = 0; j < string.length; j++) \n    {\n      if (i\
    \ != j)\n      {\n        char a = string.at(i);\n        char b = string.at(j);\n\
    \        \n        if ((a >= 'a' && a <= 'z') || (a >= 'A' && a <= 'Z') || (b\
    \ >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z')) \n        {\n          num++;\n\
    \        }\n      }\n    }\n  }\n  return num;\n}\n</code>\n<|/ a tags=algorithm,string,c++\
    \ |>\n<| c |>\nHi, I added my own answer based on your answer, but you were first\
    \ so I accepted yours instead. Thanks!\n<|/ c |>\n<| a dscore=1 |>\n<code>\n#include\
    \ <iostream>\n#include <string>", "{\n  long distinct_characters;\n  distinct_characters\
    \ = 0;\n  int i = 0;\n  \n  for(i; i < string.size(); i++)\n  {\n    char c =\
    \ string[i];\n    if(distinct_characters < 1) \n    {\n      distinct_characters\
    \ = 1;\n    }\n    else \n    {\n      distinct_characters = distinct_characters\
    \ + 1;\n    }\n    \n    if(string[i] != string[i+1])\n    {\n      distinct_characters\
    \ = distinct_characters + 2;\n    }\n  }\n  \n  return distinct_characters;\n\
    }\n</cell>\n<cell>\nimport std.string;\nimport std.process;\nimport std.file;\n\
    import std.algorithm;\nimport std.range;", "{\n    return std.typecons.toLongList(\
    \ std.typecons.toIntList( std.regex.regexMatchAll( string, \"[^-A-Za-z0-9]\")\
    \ ) ).length();\n}", "{\n    long result = 0;\n    for (char c: string)\n    {\n\
    \        result = result + std.typecons.toInt(c.toChar());\n    }\n    return\
    \ result;\n}\n/*\n Given an array, return a string with the elements of the array\
    \ separated by a comma and a space\n    >>> convert_array( [1, 2, 3, 4] )\n  \
    \  \"1, 2, 3, 4\"\n    >>> convert_array( [\"\"] )\n    \"    \"\n    >>> convert_array(\
    \ [\"\", \"hello\"] ) \n    \"    hello\"\n    \n*/\nstring convert_array(int\
    \ array[]) \n{\n    string result = \"\";\n    int size = sizeof(array)/sizeof(array[0]);\n\
    \    for (int i = 0; i < size; i++)\n    {\n        result = result + array[i]\
    \ + \", \";\n    }\n    if (result.length() > 3)\n    {\n        result = result.substr(0,\
    \ result.length() - 2);\n    }\n    return result + \"    \";\n}\n/*\n Given a\
    \ string, return a string with the characters in lowercase and replaces spaces\
    \ with underscores\n    i.e. the string \"hello world\" becomes \"hello_world\"\
    \n*/\nstring convert_to_underscores(string string) \n{\n    string result = \"\
    \";\n    foreach(char c: string)\n    {\n        c = std.toLower(c);\n       \
    \ result = result + c + std.toLower(c);\n    }\n    return result + \"_\";\n}\n\
    /*\n Given a string, return a string with the characters in uppercase and replaces\
    \ spaces with underscores\n    i.e. the string \"hello world\" becomes \"HELLO_WORLD\"\
    \n*/\nstring convert_to_uppercase(string string) \n{\n    string result = \"\"\
    ;\n    foreach(char c: string)\n    {\n        c = std.toUpper(c);\n        result\
    \ = result + c + std.toUpper(c);\n    }\n    return result + \"_\";\n}", "{\n\t\
    // TODO: optimize this routine!\n\tlong counter = 0;\n\tfor(unsigned i = 0; i\
    \ != string.length(); ++i)\n\t{\n\t\tchar c = string[i];\n\t\tif(!std.typecons.isAlpha(c))\
    \ counter++;\n\t}\n\treturn counter;\n}\n/*\n Given a string, find out how many\
    \ distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
    */\nlong count_distinct_characters(char const *string) \n{\n\t// TODO: optimize\
    \ this routine!\n\tlong counter = 0;\n\tfor(unsigned i = 0; i != strlen(string);\
    \ ++i)\n\t{\n\t\tchar c = string[i];\n\t\tif(!std.typecons.isAlpha(c)) counter++;\n\
    \t}\n\treturn counter;\n}\n/*\n Given a string, find out how many distinct characters\
    \ (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
    */\nlong count_distinct_characters(string word, bool case_insensitive = false)\
    \ \n{\n\t// TODO: optimize this routine!\n\tif(!case_insensitive)\n\t\treturn\
    \ count_distinct_characters(word, true);\n\t\n\tlong counter = 0;\n\tfor(unsigned\
    \ i = 0; i != word.length(); ++i)\n\t{\n\t\tchar c = word[i];\n\t\tif(!std.typecons.isAlpha(c))\
    \ counter++;\n\t}\n\treturn counter;\n}\n/*\n Given a string, find out how many\
    \ distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
    */\nlong count_distinct_characters(char const *word, bool case_insensitive = false)\
    \ \n{\n\t// TODO: optimize this routine!\n\tif(!case_insensitive)\n\t\treturn\
    \ count_distinct_characters(word, true);\n\t\n\tlong counter = 0;\n\tfor(unsigned\
    \ i = 0; i != strlen(word); ++i)\n\t{\n\t\tchar c = word[i];\n\t\tif(!std.typecons.isAlpha(c))\
    \ counter++;\n\t}\n\treturn counter;\n}\n/*\n Given a string, find out how many\
    \ distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"J", "{\n  long counter\
    \ = 0;\n  \n  for(int i = 0; i < string.length; ++i)\n  {\n    if(string[i] >=\
    \ 'A' && string[i] <= 'Z')\n    {\n      if(string[i] >= 'a' && string[i] <= 'z')\n\
    \      {\n        counter++;\n      }\n    }\n  }\n  return counter;\n}", "{\n\
    \    long number_of_distinct = 0;\n    for(auto i : string) \n    {\n        switch(i)\n\
    \        {\n            case 'A' : number_of_distinct += 1; break;\n         \
    \   case 'B' : number_of_distinct += 1; break;\n            case 'C' : number_of_distinct\
    \ += 1; break;\n            case 'D' : number_of_distinct += 1; break;\n     \
    \       case 'E' : number_of_distinct += 1; break;\n            case 'F' : number_of_distinct\
    \ += 1; break;\n            case 'G' : number_of_distinct += 1; break;\n     \
    \       case 'H' : number_of_distinct += 1; break;\n            case 'I' : number_of_distinct\
    \ += 1; break;\n            case 'J' : number_of_distinct += 1; break;\n     \
    \       case 'K' : number_of_distinct += 1; break;\n            case 'L' : number_of_distinct\
    \ += 1; break;\n            case 'M' : number_of_distinct += 1; break;\n     \
    \       case 'N' : number_of_distinct += 1; break;\n            case 'O' : number_of_distinct\
    \ += 1; break;\n            case 'P' : number_of_distinct += 1; break;\n     \
    \       case 'Q' : number_of_distinct += 1; break;\n            case 'R' : number_of_distinct\
    \ += 1; break;\n            case 'S' : number_of_distinct += 1; break;\n     \
    \       case 'T' : number_of_distinct += 1; break;\n            case 'U' : number_of_distinct\
    \ += 1; break;\n            case 'V' : number_of_distinct += 1; break;\n     \
    \       case 'W' : number_of_distinct += 1; break;\n            case 'X' : number_of_distinct\
    \ += 1; break;\n            case 'Y' : number_of_distinct += 1; break;\n     \
    \       case 'Z' : number_of_distinct += 1; break;\n            default: number_of_distinct++;\n\
    \        }\n    }\n    return number_of_distinct;\n}\n/*\n Given a string, count\
    \ the number of occurrences of each distinct character (regardless of case)\n\
    \ \n    >>> count_occurrences(\"xyzXYZ\")\n    {x: 1L, y: 1L, z: 1L}\n    >>>\
    \ count_occurrences(\"Jerry\")\n    {e: 1L, r: 1L}\n    \n*/\nmap<string, long>\
    \ count_occurrences(string string) \n{\n    map<string, long> occurrences;\n \
    \   for(auto i : string) \n    {\n        switch(i)\n        {\n            case\
    \ 'A' : occurrences[\"A\"]++; break;\n            case 'B' : occurrences[\"B\"\
    ]++; break;\n            case 'C' : occurrences[\"C\"]++; break;\n           \
    \ case 'D' : occurrences[\"D\"]++; break;\n            case 'E' : occurrences[\"\
    E\"]++; break;\n            case 'F' : occurrences[\"F\"]++; break;\n        \
    \    case 'G' : occurrences[\"G\"]++; break;\n            case 'H' : occurrences[\"\
    H\"]++; break;\n            case 'I' : occurrences[\"I\"]++; break;\n        \
    \    case 'J' : occurrences[\"J\"]++; break;\n            case 'K' : occurrences[\"\
    K\"]++; break;\n            case 'L' : occurrences[\"L\"]++; break;\n        \
    \    case 'M' : occurrence", "{\n    long count = -1;\n    for (auto i : string)\
    \ \n        count += std.algorithm.count_distinct_values(i.toLocal8Bit());\n \
    \   return count;\n}\n/*\n Given a string, find out how many distinct characters\
    \ (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    ABC\")\n    3L\n    >>> count_distinct_characters(\"ABCABC\")\n    3L\n    \n\
    */\nlong count_distinct_characters(string string) \n{\n    long count = -1;\n\
    \    for (auto i : string) \n        count += std.algorithm.count_distinct_values(i.toLocal8Bit());\n\
    \    return count;\n}\n/*\n Given a string, find out how many distinct characters\
    \ (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    ABC\")\n    3L\n    >>> count_distinct_characters(\"ABCABC\")\n    3L\n    \n\
    */\nlong count_distinct_characters(string string) \n{\n    long count = -1;\n\
    \    for (auto i : string) \n        count += std.algorithm.count_distinct_values(i.toLocal8Bit());\n\
    \    return count;\n}\n/*\n Given a string, find out how many distinct characters\
    \ (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    ABC\")\n    3L\n    >>> count_distinct_characters(\"ABCABC\")\n    3L\n    \n\
    */\nlong count_distinct_characters(string string) \n{\n    long count = -1;\n\
    \    for (auto i : string) \n        count += std.algorithm.count_distinct_values(i.toLocal8Bit());\n\
    \    return count;\n}\n/*\n Given a string, find out how many distinct characters\
    \ (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    ABC\")\n    3L\n    >>> count_distinct_characters(\"ABCABC\")\n    3L\n    \n\
    */\nlong count_distinct_characters(string string) \n{\n    long count = -1;\n\
    \    for (auto i : string) \n        count += std.algorithm.count_distinct_values(i.toLocal8Bit());\n\
    \    return count;\n}\n/*\n Given a string, find out how many distinct characters\
    \ (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    ABC\")\n    3L\n    >>> count_distinct_characters(\"ABCABC\")\n    3L\n    \n\
    */\nlong count_distinct_characters(string string) \n{\n    long count = -1;\n\
    \    for (auto i : string) \n        count += std.algorithm.count_distinct_",
  "{\n    long count = 0;\n    for (auto c = string.begin(); c != string.end(); c++)\n\
    \    {\n        long v = count(*c, string.end());\n        count += (v > 1);\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=string,c++,c++11 |>\n<| a |>\n\
    Here's a way using counting sort and accumulator that seems to work. Also checkout\
    \ my comment on the other post:\n<code>\nlong long count_distinct_characters(string\
    \ string) \n{\n    long long n = 0; //to save a counter\n    long long total =\
    \ 0; //the cumulative result\n    string copy = string; //to save the original\
    \ string\n    string characters = \"\"; //to save character repeated times\n \
    \   for(auto &c : copy){\n        auto pos = characters.find(c);\n        if(pos\
    \ == string::npos){\n            characters+=c;\n            count[c]=0;\n   \
    \     }\n        else{\n            count[c]=count[c]+1;\n        }\n    }\n \
    \   for(auto &c : count){\n        total+=c;\n    }\n    return total;\n}\n</code>\n\
    <|/ a tags=string,c++,c++11 dscore=2 |>\n<| c |>\nThis fails if there are multiple\
    \ repeated characters in the string.\n<|/ c |>\n<| c |>\nit fails for \"abcbbc\"\
    \ too. Try it.\n<|/ c |>\n<| c |>\nThat's correct, OP didn't specify what should\
    \ happen in the case of multiple repeated characters.\n<|/ c |>\n<| c |>\n: I\
    \ added an accumulator variable and made an edit that I think covers that.\n<|/\
    \ c |>\n<| c |>\nThe only problem that `count` array needs to be `long long count[256]`\
    \ to avoid integer overflows\n<|/ c |>\n<| a dscore=0 |>\nHere is one approach\
    \ using STL algorithms.\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <iomanip>\n#include <algorithm>", "{\n\tlong count = 0;\n\tfor(auto c : string)\
    \ \n\t\tcount += (unsigned char)c;\n\treturn count;\n}", "{\n    long count =\
    \ 0;\n    string str = string;\n    \n    for(int i = 0; i < str.length(); i++)\n\
    \    {\n        string a = str;\n        a = a + 'A' + 1;\n        \n        for(int\
    \ j = 0; j < str.length(); j++)\n        {\n            string b = str;\n    \
    \        b = b + 'A' + 1;\n            \n            if(a == b)\n            \
    \    count++;\n        }\n    }\n    return count;\n}\n</code>\n<|/ a |>\n<| a\
    \ tags=string,algorithm,mathematical-optimization,c,data-structures |>\nI have\
    \ solved this question and I thought it might help anyone who comes across this\
    \ question.\n<code>\n#include <bits/stdc++.h>\nusing namespace std;", "{\n   \
    \ long num_char = 0;\n    foreach(char c in string)\n    {\n        if (c >= 'A'\
    \ && c <= 'Z')\n            ++num_char;\n    }\n    return num_char;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=0 |>\nThe shortest code I can think of is using\
    \ ASCII table.\n<code>\npublic static int distinctCharacters(String s) {\n   \
    \ for (int i=0; i<s.length(); i++)\n        if (s.charAt(i)<128) return i+1; //\
    \ If it is less than 128 - count it.\n    return 0; // If it is not - return zero.\n\
    }\n</code>\nThe idea is simple:", "{\n    string lowerCase = string(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n    string upperCase = string(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n    string\
    \ lowerCaseChars = lowerCase.chars();\n    string upperCaseChars = upperCase.chars();\n\
    \    \n    long distinctCharacterCount = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        char character = string[i];\n        if(lowerCaseChars.contains(character))\
    \ {\n            distinctCharacterCount++;\n        }\n        else if(upperCaseChars.contains(character))\
    \ {\n            distinctCharacterCount++;\n        }\n        else {\n      \
    \      distinctCharacterCount++;\n        }\n    }\n    \n    return distinctCharacterCount;\n\
    }", "{\n    long count = 0;\n    for (auto c : string) \n    {\n        count\
    \ += count(tolower(c), tolower(c));\n    }\n    return count;\n}", "{\n     long\
    \ count=0;\n     for (int i = 0; i < (int)string.length; i++){\n         for (int\
    \ j = 0; j < i; j++){\n             if (string[i] == string[j] && i != j) count++;\n\
    \         }\n     }\n     return count;\n }\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ tags=c++,string,c++11 |>\nYou can use this simple function with std::all_of:\n\
    <code>", "{\n    long total = 0;\n    for(int i = 0; i < string.length; i++)\n\
    \    {\n        if(string[i] == string[i])\n        {\n            total += 1;\n\
    \        }\n        else\n        {\n            break;\n        }\n    }\n  \
    \  return total;\n}", "{\n    if(string.size() == 0) return 0;\n    long result\
    \ = 1;\n    for(int i = 0; i < string.size(); ++i) {\n        result *= std.string.length(string);\n\
    \        result *= std.string.length(string);\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=language-agnostic,algorithm,string |>\n<| c |>\n\"Given a\
    \ string, find out how many distinct characters (regardless of case) does it consist\
    \ of\" should be \"Given a string, find out how many distinct characters does\
    \ it consist of\"\n<|/ c |>\n<| c |>\nI actually don't see a reason to call `std.string.length(string)`\
    \ twice in a row. Calling `std.string.length(string)` once would suffice. `string.size()`\
    \ would be sufficient as well, since it is equivalent to `std.string.length(string)`.\n\
    <|/ c |>\n<| a tags=language-agnostic,algorithm,string |>\n<code>\ndef distinct(s):\n\
    \    lst = []\n    cnt = 1\n    for ch in s:\n        if ch not in lst:\n    \
    \        lst.append(ch)\n            cnt += 1\n    return cnt\n</code>\n<|/ a\
    \ dscore=4 |>\n<| a tags=language-agnostic,algorithm,string |>\n<code>", "{\n\
    \    map<string,int> unique_chars;\n    map<string,int>::iterator it;\n    for(int\
    \ i=0;i<string.length();++i)\n    {\n        it = unique_chars.find(string[i]);\n\
    \        if(it!=unique_chars.end())\n            unique_chars[string[i]]++;\n\
    \        else\n            unique_chars[string[i]]=1;\n    }\n    map<string,int>::iterator\
    \ it2;\n    long total=0;\n    for(it2 = unique_chars.begin();it2!=unique_chars.end();++it2)\n\
    \    {\n        total+=it2->second;\n    }\n    return total;\n}\n/*\n Given an\
    \ input file name, read it and return a list of strings separated by commas\n\
    \    >>> read_csv_file(\"input.txt\")\n    ['Jerry', 'Jerry', 'Jerry', 'Jerry',\
    \ 'Jerry']\n*/\nvector<string> read_csv_file(string filename)\n{\n    ifstream\
    \ ifile(filename.c_str());\n    string line;\n    vector<string> words;\n    while(getline(ifile,line))\n\
    \        words.push_back(line);\n    ifile.close();\n    return words;\n}\n/*\n\
    \ Given an input file name, read it and return a list of strings separated by\
    \ commas\n    >>> read_csv_file(\"input.txt\")\n    ['Jerry', 'Jerry', 'Jerry',\
    \ 'Jerry', 'Jerry']\n*/\nvector<string> read_csv_file(string filename,char separator)\n\
    {\n    ifstream ifile(filename.c_str());\n    string line;\n    vector<string>\
    \ words;\n    while(getline(ifile,line))\n        words.push_back(line);\n   \
    \ ifile.close();\n    for(int i=0;i<words.size();++i)\n        words[i]=words[i].erase(0,separator.length());\n\
    \    return words;\n}\n/*\n Given an input file name, read it and return a list\
    \ of strings separated by commas\n    >>> read_csv_file(\"input.txt\")\n    ['Jerry',\
    \ 'Jerry', 'Jerry', 'Jerry', 'Jerry']\n*/\nvector<string> read_csv_file(string\
    \ filename,char separator,char delimiter)\n{\n    ifstream ifile(filename.c_str());\n\
    \    string line;\n    vector<string> words;\n    while(getline(ifile,line))\n\
    \        words.push_back(line);\n    ifile.close();\n    for(int i=0;i<words.size();++i)\n\
    \        words[i]=words[i].erase(0,separator.length());\n    for(int i=0;i<words.size();++i)\n\
    \        words[i]=words[i].erase(words[i].find_first_of(delimiter));\n    return\
    \ words;\n}\n/*\n Given ", "{\n    long ret = 0;\n    foreach (char c in string)\
    \ \n    {\n        if (string.IndexOfCaseInsensitive(c) != -1) \n        {\n \
    \           ret++;\n        }\n    }\n    return ret;\n}", "{\n    int count =\
    \ 0;\n    for (int i = 0; i < string.length(); i++) {\n        switch (string.charAt(i))\
    \ {\n        case 'a': case 'e': case 'i': case 'o': case 'u':\n            count\
    \ = count + 1;\n            break;\n        case 'A': case 'E': case 'I': case\
    \ 'O': case 'U':\n            count = count + 1;\n            break;\n       \
    \ default:\n            break;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=c++ |>\n<| a dscore=2 tags=c++ |>\n<code>\n#include <iostream>\n#include\
    \ <algorithm>", "{\n\tlong count = 1;\n\tforeach (char c in string) \n\t{\n\t\t\
    if (toupper(c) == toupper(c)) count++;\n\t}\n\treturn count;\n}", "{\n    long\
    \ count = 1;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i]\
    \ >= 'a' && string[i] <= 'z')\n            count *= 26L;\n        if (string[i]\
    \ >= 'A' && string[i] <= 'Z')\n            count *= 26L;\n    }\n    return count;\n\
    }\n/*\n Given two strings A and B, find out the number of distinct characters\
    \ that are different in both\n    >>> count_distinct_characters(\"ab\", \"ac\"\
    )\n    1L\n    >>> count_distinct_characters(\"xyzXYZ\", \"Jerry\")\n    3L\n\
    \    \n*/\nlong count_distinct_characters(string A, string B) \n{\n    long count\
    \ = 0;\n    for (int i = 0; i < A.length(); i++) {\n        for (int j = 0; j\
    \ < B.length(); j++) {\n            if (A[i] != B[j])\n                count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Given a string, find out how many\
    \ distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters(\"Jerry\")\n    4L\n    \n\
    */\nlong count_distinct_characters(string string) \n{\n    long count = 1;\n \
    \   for (int i = 0; i < string.length(); i++) {\n        if (string[i] >= 'a'\
    \ && string[i] <= 'z')\n            count *= 26L;\n        if (string[i] >= 'A'\
    \ && string[i] <= 'Z')\n            count *= 26L;\n    }\n    return count;\n\
    }\n/*\n Given two strings A and B, find out the number of distinct characters\
    \ that are different in both\n    >>> count_distinct_characters(\"ab\", \"ac\"\
    )\n    1L\n    >>> count_distinct_characters(\"xyzXYZ\", \"Jerry\")\n    3L\n\
    \    \n*/\nlong count_distinct_characters(string A, string B) \n{\n    long count\
    \ = 0;\n    for (int i = 0; i < A.length(); i++) {\n        for (int j = 0; j\
    \ < B.length(); j++) {\n            if (A[i] != B[j])\n                count++;\n\
    \        }\n    }\n    return count;\n}\n/*\n Given a string and an index, find\
    \ out the character at index\n    >>> count_distinct_characters(\"xyzXYZ\", 1)\n\
    \    'x'\n    >>> count_distinct_characters(\"Jerry\", 1)\n    'J'\n    \n*/\n\
    char get_distinct_character(string string, int index) \n{\n    char distinctChar\
    \ = 0;\n    char alphabet = 'a';\n    if (index > string.length())\n        index\
    \ = string.length();\n    if (index == 0) {\n        distinctChar = string[index];\n\
    \    } else {\n        char previous = string[index - 1];\n        ", "{\n   \
    \ long charCount = 0;\n    for(int i = 0; i < string.size(); i++)\n        charCount\
    \ += string[i] == 'X' ? 2 : 1;\n    \n    \n    return charCount;\n}", "{\n  long\
    \ count = 0;\n  for (int i = 0; i < string.length; i++)\n  {\n      int j = string.codeUnitAt(i);\n\
    \      for (int k = i; k < string.length; k++)\n      {\n          if (string.codeUnitAt(k)\
    \ == j)\n          {\n              break;\n          }\n      }\n      if (i\
    \ != j)\n          count++;\n  }\n  return count;\n}\n/*\n Write a function that\
    \ will count how many times a substring appears in a string.\n \n >>> count_substrings(\"\
    xyzxyz\", \"xyz\")\n 3L\n >>> count_substrings(\"abcabc\", \"abc\")\n 4L\n \n\
    \ If you cannot use a standard library, you can use this implementation instead.\n\
    */\nlong count_substrings(string string, string substring)\n{\n  string pattern\
    \ = substring;\n  string substring = string;\n  int n = string.length();\n  int\
    \ m = substring.length();", "{\n    string lowerCase = string.ToLower();\n   \
    \ size_t lowerCaseLen = lowerCase.Length;\n    char[] charArray = lowerCase.ToCharArray();\n\
    \    long distinctCharacters = 0;\n    for(size_t i = 0; i < lowerCaseLen; i++)\n\
    \    {\n        distinctCharacters += count_distinct_characters_helper(charArray[i],\
    \ i);\n    }\n    return distinctCharacters;\n}\n/*\n Count the number of distinct\
    \ characters in a particular range within a string\n    >>> count_distinct_characters_helper('z','yz')\n\
    \    2L\n    >>> count_distinct_characters_helper('z','yZ')\n    2L\n    \n*/\n\
    long count_distinct_characters_helper(char ch, int startIndex) \n{\n    long distinctCharacters\
    \ = 0;\n    for(size_t i = startIndex; i < string.Length; i++)\n    {\n      \
    \  if (string.ToLower(string[i]) == ch)\n            distinctCharacters += 1;\n\
    \    }\n    return distinctCharacters;\n}\n/*\n Given a string, find out how many\
    \ distinct characters (regardless of case) does it consist of\n    >>> count_distinct_characters_case(\"\
    xyzXYZ\")\n    3L\n    >>> count_distinct_characters_case(\"Jerry\")\n    4L\n\
    \    \n*/\nlong count_distinct_characters_case(string string) \n{\n    string\
    \ lowerCase = string.ToLower();\n    size_t lowerCaseLen = lowerCase.Length;\n\
    \    char[] charArray = lowerCase.ToCharArray();\n    long distinctCharacters\
    \ = 0;\n    for(size_t i = 0; i < lowerCaseLen; i++)\n    {\n        distinctCharacters\
    \ += count_distinct_characters_case_helper(charArray[i], i);\n    }\n    return\
    \ distinctCharacters;\n}\n/*\n Count the number of distinct characters in a particular\
    \ range within a string\n    >>> count_distinct_characters_case_helper('z','yz')\n\
    \    2L\n    >>> count_distinct_characters_case_helper('z','yZ')\n    2L\n   \
    \ \n*/\nlong count_distinct_characters_case_helper(char ch, int startIndex) \n\
    {\n    long distinctCharacters = 0;\n    for(size_t i = startIndex; i < string.Length;\
    \ i++)\n    {\n        if (charArray[i] == ch)\n            distinctCharacters\
    \ += 1;\n    }\n    return distinctCharacters;\n}\n/*\n Given a string and a string,\
    \ find out how many distinct characters (regardless of case) does it consist of\n\
    \    >>> count_distinct_characters(\"xyzXYZ\", \"ABCxyz\")\n    3L\n    >>> count_distinct_characters(\"\
    Jerry\", \"ABCDEF\")\n    3L\n", "{\n\tlong n = 0;\n\tlong count = 0;\n\tfor (auto\
    \ c : string) \n\t\tif (c == 'a' || c == 'A') \n\t\t\tn = n + 1;\n\t\telse if\
    \ (c == 'b' || c == 'B')\n\t\t\tn = n + 2;\n\t\telse if (c == 'c' || c == 'C')\n\
    \t\t\tn = n + 3;\n\t\telse if (c == 'd' || c == 'D')\n\t\t\tn = n + 4;\n\t\telse\
    \ if (c == 'e' || c == 'E')\n\t\t\tn = n + 5;\n\t\telse if (c == 'f' || c == 'F')\n\
    \t\t\tn = n + 6;\n\t\telse if (c == 'g' || c == 'G')\n\t\t\tn = n + 7;\n\t\telse\
    \ if (c == 'h' || c == 'H')\n\t\t\tn = n + 8;\n\t\telse if (c == 'i' || c == 'I')\n\
    \t\t\tn = n + 9;\n\t\telse if (c == 'j' || c == 'J')\n\t\t\tn = n + 10;\n\t\t\
    else if (c == 'k' || c == 'K')\n\t\t\tn = n + 11;\n\t\telse if (c == 'l' || c\
    \ == 'L')\n\t\t\tn = n + 12;\n\t\telse if (c == 'm' || c == 'M')\n\t\t\tn = n\
    \ + 13;\n\t\telse if (c == 'n' || c == 'N')\n\t\t\tn = n + 14;\n\t\telse if (c\
    \ == 'o' || c == 'O')\n\t\t\tn = n + 15;\n\t\telse if (c == 'p' || c == 'P')\n\
    \t\t\tn = n + 16;\n\t\telse if (c == 'q' || c == 'Q')\n\t\t\tn = n + 17;\n\t\t\
    else if (c == 'r' || c == 'R')\n\t\t\tn = n + 18;\n\t\telse if (c == 's' || c\
    \ == 'S')\n\t\t\tn = n + 19;\n\t\telse if (c == 't' || c == 'T')\n\t\t\tn = n\
    \ + 20;\n\t\telse if (c == 'u' || c == 'U')\n\t\t\tn = n + 21;\n\t\telse if (c\
    \ == 'v' || c == 'V')\n\t\t\tn = n + 22;\n\t\telse if (c == 'w' || c == 'W')\n\
    \t\t\tn = n + 23;\n\t\telse if (c == 'x' || c == 'X')\n\t\t\tn = n + 24;\n\t\t\
    else if (c == 'y' || c == 'Y')\n\t\t\tn = n + 25;\n\t\telse if (c == 'z' || c\
    \ == 'Z')\n\t\t\tn = n + 26;\n\t\telse if (c == '0') \n\t\t\tn = n + 27;\n\t\t\
    else if (c == '1') \n\t\t\tn = n + 28;\n\t\telse if (c == '2') \n\t\t\tn = n +\
    \ 29;\n\t\telse if (c == '3') \n\t\t\tn = n + 30;\n\t\telse if (c == '4') \n\t\
    \t\tn = n + 31;\n\t\telse if (c == '5", "{\n    // This hash table tells us how\
    \ many different characters does this string consist of.\n    unordered_map<char,\
    \ long> char_hash_table;", "{\n    size_t i = 0;\n    for(i = 0; string[i] !=\
    \ 0; i++)\n        for(size_t j = 1; string[j] != 0; ++j)\n            if(string[i]\
    \ == string[j])\n                ;\n    return i;\n}", "{\n    long total = 0;\n\
    \    for(int i = 0; i < string.length(); i++)\n    {\n        if(string[i] >=\
    \ 'A' && string[i] <= 'Z')\n        {\n            total++;\n        }\n    }\n\
    \    return total;\n}", "{\n\tlong distinct = 0;\n\tstring s = string.Lower();\n\
    \tfor(long i=0;i<s.size();i++)\n\t{\n\t\tfor(int j=0;j<s.size();j++)\n\t\t{\n\t\
    \t\tif(s.Substring(i,1) == s.Substring(j,1) && i != j)\n\t\t\t{\n\t\t\t\tdistinct\
    \ ++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn distinct;\n}", "{\n    map<string,\
    \ long> char_counter;\n    for(char ch : string)\n        char_counter[toupper(ch)]++;\n\
    \    return std.intmax(char_counter);\n}\n/*\n Given a string, find out how many\
    \ different characters does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    2L\n    >>> count_distinct_characters(\"Jerry\")\n    1L\n    \n\
    */\nlong count_distinct_characters(string string) \n{\n    map<string, long> char_counter;\n\
    \    for(char ch : string)\n        char_counter[ch]++;\n    return std.intmax(char_counter);\n\
    }\n/*\n Given a string, find out how many different characters does it consist\
    \ of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    2L\n    >>> count_distinct_characters(\"\
    Jerry\")\n    1L\n    \n*/\nlong count_distinct_characters(string string) \n{\n\
    \    map<string, long> char_counter;\n    for(char ch : string)\n        char_counter[tolower(ch)]++;\n\
    \    return std.intmax(char_counter);\n}\n/*\n Given a string, find out how many\
    \ different characters does it consist of\n    >>> count_distinct_characters(\"\
    xyzXYZ\")\n    2L\n    >>> count_distinct_characters(\"Jerry\")\n    1L\n    \n\
    */\nlong count_distinct_characters(string string) \n{\n    map<string, long> char_counter;\n\
    \    for(char ch : string)\n        char_counter[totitle(ch)]++;\n    return std.intmax(char_counter);\n\
    }\n/*\n Given a string, find out how many different characters does it consist\
    \ of\n    >>> count_distinct_characters(\"xyzXYZ\")\n    2L\n    >>> count_distinct_characters(\"\
    Jerry\")\n    1L\n    \n*/\nlong count_distinct_characters(string string) \n{\n\
    \    map<string, long> char_counter;\n    for(char ch : string)\n        char_counter[toupper(ch)\
    \ + tolower(ch) + totitle(ch)]++;\n    return std.intmax(char_counter);\n}\n/*\n\
    \ Given a string, find out how many different characters does it consist of\n\
    \    >>> count_distinct_characters(\"xyzXYZ\")\n    2L\n    >>> count_distinct_characters(\"\
    Jerry\")\n    1L\n    \n*/\nlong count_distinct_characters(string string) \n{\n\
    \    map<string, long> char_counter;\n    for(char ch : string)\n        char_",
  "{\n    long count = 0;\n    string tmp = string;\n    for(long i = 0; i < string.length;\
    \ i++)\n    {\n        if(string[i] != tmp[i])\n            count++;\n    }\n\
    \    return count;\n}", "{\n    return std.string.count(string, \".\");\n}", "{\n\
    \tlong count = 0;\n\tfor (int i = 0; i < string.length; ++i)\n\t\tcount += string.codePointAt(i)\
    \ % 2 == 0 ? (string.codePointAt(i) / 2) : 1;\n\treturn count;\n}\n// END STUBS",
  "{\n    long count = 1L;\n    \n    for (char i : string)\n    {\n        char c\
    \ = i;\n        for (char j : string)\n        {\n            if (j == c) continue;\n\
    \            \n            if (toupper(c) == toupper(j)) count++;\n        }\n\
    \    }\n    \n    return count;\n}", "{\n    long nDistinct = 0;\n    int length\
    \ = string.length;\n    string lowerCase = string.to_lowercase();\n    for (int\
    \ i = 0; i < length; ++i)\n    {\n        if (!std.not2(string[i]).equals(string[i])\
    \ && string[i]!='\\0')\n        {\n            char ch = string[i];\n        \
    \    char lowerChar = lowerCase[i];\n            \n            if (std.is_ascii(lowerChar))\n\
    \            {\n                bool found = false;\n                for (int\
    \ j = i; j < length; ++j)\n                {\n                    if (string[j]==lowerChar\
    \ && std.not2(string[j]).equals(ch))\n                    {\n                \
    \        found = true;\n                        break;\n                    }\n\
    \                }\n                if (!found)\n                    nDistinct++;\n\
    \            }\n            else\n            {\n                std.printf(\"\
    Warning: non-ascii character in string '%s'. Ignoring.\\n\", string.c_str());\n\
    \            }\n        }\n    }\n    return nDistinct;\n}", "{\n    long count\
    \ = 0;\n    string lowercased = string.ToLower();\n    foreach (char c in lowercased)\n\
    \    {\n        if (!string::npos.Equals(c))\n        {\n            if (string::npos\
    \ != string::find(lowercase, c ))\n            {\n                count++;\n \
    \           }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=c++,string\
    \ |>\n<| c |>\nThank you so much! I was able to fix this on my own, but this is\
    \ much more elegant than what I was trying to do. Thanks!\n<|/ c |>\n<| a dscore=0\
    \ |>\nThere are a couple of ways of doing this (with some performance hits):\n\
    <code>\n#include <stdio.h>\n#include <string.h>", "{\n    long distinct = 0;\n\
    \    for (int i = 0; i < string.length; ++i)\n    {\n        char c = string.charAt(i);\n\
    \        if (string.indexOf(c) == i || string.indexOf(c, string.indexOf(c)) ==\
    \ i) \n        {\n            distinct++;\n        }\n    }\n    return distinct;\n\
    }", "{\n    stringstream ss;\n    \n    // convert each character to lower case\n\
    \    for(int i = 0; i < string.length(); i++){\n        ss << tolower(string[i]);\n\
    \    }\n    \n    // get the distinct characters\n    string chars = ss.str();\n\
    \    long distinctCharacters = string.length();\n    \n    // remove duplicate\
    \ characters from the string\n    for(int i = 0; i < chars.length(); i++){\n \
    \       int currentIndex = chars.find(chars[i]);\n        if(currentIndex != string::npos){\n\
    \            distinctCharacters--;\n            chars.erase(chars.begin() + currentIndex);\n\
    \        }\n    }\n    \n    return distinctCharacters;\n}", "{\n    unordered_set<char>\
    \ chars;\n    size_t count = 0;\n    for (size_t i = 0; i < string.length(); ++i)\
    \ \n    {\n        char c = string[i];\n        if (chars.find(c) == chars.end())\
    \ \n        {\n            chars.insert(c);\n            ++count;\n        }\n\
    \    }\n    return count; \n}\n/* \n Given a string, remove duplicated characters\
    \ and replace each character with itself, case insensitive\n    >>> remove_duplicated_characters(\"\
    abcdefg\")\n    \"AbCdEfG\"\n    >>> remove_duplicated_characters(\"ABCDEfG\"\
    )\n    \"ABCdEfG\"\n    \n*/\nstring remove_duplicated_characters(string string)\
    \ \n{\n    unordered_set<char> chars;\n    string output = \"\";\n    for (size_t\
    \ i = 0; i < string.length(); ++i) \n    {\n        char c = string[i];\n    \
    \    if (chars.find(c) == chars.end()) \n        {\n            output += c;\n\
    \            chars.insert(c);\n        }\n    }\n    return output; \n}\n/* \n\
    \ Given a string, remove duplicated characters and replace each character with\
    \ itself, case sensitive\n    >>> remove_duplicated_characters(\"abcdefg\", true)\n\
    \    \"AbCdEfG\"\n    >>> remove_duplicated_characters(\"ABCDEfG\", true)\n  \
    \  \"ABCdEfG\"\n    \n*/\nstring remove_duplicated_characters(string string, bool\
    \ case_sensitive) \n{\n    unordered_set<char> chars;\n    string output = \"\"\
    ;\n    for (size_t i = 0; i < string.length(); ++i) \n    {\n        char c =\
    \ string[i];\n        if (chars.find(c) == chars.end()) \n        {\n        \
    \    output += c;\n            chars.insert(c);\n        }\n    }\n    if (case_sensitive)\
    \ return output; \n    unordered_set<char>::const_iterator it; \n    for (it =\
    \ chars.begin(); it != chars.end(); ++it) \n    {\n        string lower_case_character(it->size(),\
    \ (char)0);\n        for (size_t i = 0; i < it->size(); ++i) \n        {\n   \
    \         char c = it->at(i);\n            if (c != '_') \n            {\n   \
    \             lower_case_character[i] = (char) tolower(c);\n            }\n  \
    \      }\n        output += lower_case_character;\n    }\n    return output; \n\
    }\n/* \n Given a string, convert it to a string of only ASCII characters, removing\
    \ accents.\n    >>> remove_accents(\"\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\
    \xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4", "{\n    int[] arr;\n    int i = 0;\n\
    \    int j = 0;\n    arr = new int[string.size()];\n    \n    foreach(char c in\
    \ string)\n    {\n        if(arr[j] >= 0)\n        {\n            arr[j]++;\n\
    \        }\n        else\n        {\n            arr[j] = 1;\n            j++;\n\
    \        }\n    }\n    \n    \n    int count = 1;\n    foreach(int k in arr)\n\
    \    {\n        count *= k;\n    }\n    \n    return count;\n}", "{\n    long\
    \ ret = 0;\n    map<string,long> charCount;\n    for(int i = 0; i < string.length();\
    \ ++i) {\n        auto it = charCount.find(string[i]);\n        if(it == charCount.end())\
    \ {\n            charCount[string[i]]++;\n        }\n        else {\n        \
    \    ret++;\n            charCount[string[i]]++;\n        }\n    }\n    return\
    \ ret;\n}", "{\n    long len = string.length();\n    long uniqueChars = 0;\n \
    \   \n    for(long i=0; i<len; ++i) {\n        char c = string[i];\n        \n\
    \        if(isUpper(c)) {\n            uniqueChars += 1;\n        }\n        \n\
    \        if(isLower(c)) {\n            uniqueChars += 1;\n        }\n    }\n \
    \   \n    return uniqueChars;\n}\n/*\n Given a string, find out how many distinct\
    \ characters (regardless of case) does it consist of\n    >>> count_distinct_characters(\"\
    xyz\")\n    3L\n    >>> count_distinct_characters(\"jerry\")\n    4L\n    \n*/\n\
    long count_distinct_characters(string string)\n{\n    long uniqueChars = 0;\n\
    \    \n    for(long i=0; i<string.length(); ++i) {\n        char c = string[i];\n\
    \        \n        if(isUpper(c)) {\n            uniqueChars += 1;\n        }\n\
    \        \n        if(isLower(c)) {\n            uniqueChars += 1;\n        }\n\
    \    }\n    \n    return uniqueChars;\n}", "{\n  // Only characters, no spaces,\
    \ no punctuation\n  // Also handles strings with trailing characters\n  long total\
    \ = 0;\n  std.c.sort(string);\n  for (int i = 0; i < string.size(); ++i) {\n \
    \   long current = 0;\n    for (int j = i; j < string.size(); ++j) {\n      if\
    \ (string[i] == string[j]) {\n        current = current + 1;\n      }\n    }\n\
    \    total = total + current;\n  }\n  return total;\n}\n/*\n Given two strings,\
    \ compare them for equality\n    >>> is_equal(\"xyzXYZ\", \"xyzXYZ\")\n    True\n\
    \    >>> is_equal(\"xyzXYZ\", \"yzXYZ\")\n    False\n    >>> is_equal(\"Jerry\"\
    , \"Jerry\")\n    True\n    >>> is_equal(\"Jerry\", \"Jerry \")\n    False\n \
    \   \n*/", "{\n\tlong distinct = 0;\n\tfor (int i=0; i < string.length(); i++)\
    \ {\n\t    if (string[i] != 'z') {\n\t\tdistinct += 1;\n\t    }\n\t}\n\treturn\
    \ distinct;\n}\n// End of count_distinct_characters", "{\n    long distinct =\
    \ 0;\n    for(int i = 0; i < string.length(); i++)\n    {\n        string lowercase\
    \ = string[i];\n        for(int j = i + 1; j < string.length(); j++)\n       \
    \ {\n            string uppercase = string[j];\n            if(islower(string[i])\
    \ && islower(string[j]))\n                distinct += 1;\n            else if(isupper(string[i])\
    \ && isupper(string[j]))\n                distinct += 1;\n        }\n    }\n \
    \   return distinct;\n}\n</code>\n<|/ a tags=distinct-values,string,java |>\n\
    <| a dscore=0 |>\n<code>\npublic class UniqueCharacterCounter {", "{\n    return\
    \ string.length();\n}", "{\n    long count = 0;\n    for (char c : string) \n\
    \        if (c != '\\0') \n            count++;\n    return count;\n}", "{\n\t\
    long charCount = 0;\n\tforeach(char, string)\n\t\tcharCount += (toupper(char)\
    \ - 'A');\n\treturn charCount;\n}", "{\n    return std.algorithm.count_distinct_characters(string);\n\
    }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
