language: d
name: HumanEval_58_common
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    // create two hash sets with hashes l1 and l2\n    // use set for O(1)\
    \ lookup and insertion\n    Set<Long> set1 = new Set<Long>(l1);\n    Set<Long>\
    \ set2 = new Set<Long>(l2);\n    \n    // find the common elements\n    long[]\
    \ common = new long[set1.size() + set2.size()];\n    int i = 0;\n    for (Long\
    \ e : set1) {\n        set2.remove(e);\n        if (set2.size() == 0) {\n    \
    \        common[i] = e;\n            ++i;\n        }\n    }\n    for (Long e :\
    \ set2) {\n        set1.remove(e);\n        if (set1.size() == 0) {\n        \
    \    common[i] = e;\n            ++i;\n        }\n    }\n    // sort them\n  \
    \  Arrays.sort(common);\n    return common;\n}\n</code>\n<|/ a dscore=0 tags=set,collections,java,arrays\
    \ |>\n<| a dscore=0 |>\nI know its been almost 2 years since this question was\
    \ posted, but I was looking for something like this and I implemented this using\
    \ HashSet. Since a HashSet contains only unique values, I first sort the ArrayList\
    \ and then call hashSet.contains to verify whether the value already exists in\
    \ my hashset. Since HashSet is unordered, I have to iterate through the ArrayList\
    \ again. Here is a full example. Hope this helps somebody out there.\n<code>\n\
    import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\n\
    import java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\n\
    import java.util.Set;\nimport java.util.stream.Collectors;\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_hcgmido.d(16): Error: found `>` when expecting `;` following statement

    /tmp/tmp_hcgmido.d(16): Error: found `>` when expecting `;` following statement

    /tmp/tmp_hcgmido.d(17): Error: found `>` when expecting `;` following statement

    /tmp/tmp_hcgmido.d(17): Error: found `>` when expecting `;` following statement

    /tmp/tmp_hcgmido.d(22): Error: found `e` when expecting `;` following statement

    /tmp/tmp_hcgmido.d(22): Error: expression expected, not `:`

    /tmp/tmp_hcgmido.d(22): Error: found `set1` when expecting `;` following `for`
    condition

    /tmp/tmp_hcgmido.d(29): Error: found `e` when expecting `;` following statement

    /tmp/tmp_hcgmido.d(29): Error: expression expected, not `:`

    /tmp/tmp_hcgmido.d(29): Error: found `set2` when expecting `;` following `for`
    condition

    /tmp/tmp_hcgmido.d(40): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hcgmido.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n     if (l1.length != l2.length) \n         throw new IndexOutOfBoundsException(\"\
    length of l1 must be same as length of l2\");\n     int[] a = new int[l1.length];\n\
    \     int i=0, j=0, n=0, min=0;\n     while (i < l1.length && j < l2.length)\n\
    \     {\n         if (l1[i] < l2[j])\n         {\n             a[n] = l1[i];\n\
    \             i++;\n             n++;\n         }\n         else if (l1[i] > l2[j])\n\
    \         {\n             a[n] = l2[j];\n             j++;\n             n++;\n\
    \         }\n         else\n         {\n             if (min == 0 || a[n-1] <\
    \ a[min-1]) \n                 min = n-1;\n             n++;\n         }\n   \
    \  }\n     if (n < a.length)\n         a[n] = l1[i];\n     return a;\n}\n</code>\n\
    <|/ a dscore=0 tags=java |>\n<| c |>\nPlease explain your solution\n<|/ c |>\n\
    <| a dscore=0 |>\nThis is an implementation that uses a HashMap instead of ArrayList\
    \ to store the results.\nThis solution will work in linear time with the size\
    \ of the lists (n log n), as opposed to quadratic with the size of the lists (n^2).\n\
    <code>\npublic static <E, T> List<E> intersection(List<T> l1, List<T> l2) {\n\
    \    HashMap<E, Boolean> map = new HashMap<>();\n    for (T t : l1) {\n      \
    \  if (map.containsKey(t)) {\n            map.put(t, map.get(t) && l2.contains(t));\n\
    \        } else {\n            map.put(t, true);\n        }\n    }\n    List<E>\
    \ results = new ArrayList<>();\n    for (E e : map.keySet()) {\n        if (map.get(e)\
    \ && map.get(e) == l2.contains(e)) {\n            results.add(e);\n        }\n\
    \    }\n    return results;\n}\n</code>\n<|/ a tags=java |>\n<| a tags=java |>\n\
    The idea is to use a HashMap to store the results. So the algorithm is:\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo_1rj40p.d(43): Error: declaration expected, not `<`

    /tmp/tmpo_1rj40p.d(54): Error: declaration expected, not `for`

    /tmp/tmpo_1rj40p.d(57): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo_1rj40p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    // sort array in ascending order\n    int i = 0, j = 0;\n    while(i<l1.length\
    \ && j<l2.length){\n        if(l1[i] < l2[j]){\n            ++i;\n        }\n\
    \        else{\n            ++j;\n        }\n    }\n    int arrLen = l1.length\
    \ > l2.length ? l1.length : l2.length;\n    \n    // sort smaller array if necessary\n\
    \    for(int k=0; k<arrLen; k++){\n        if(l1[k] < l2[k]){\n            int\
    \ tempId = l1[l1.length-k-1];\n            l1[l1.length-k-1] = l2[k];\n      \
    \      l2[k] = tempId;\n        }\n    }\n    \n    // return the common array\n\
    \    long[] common = new long[arrLen];\n    for(int k=0; k<arrLen; k++){\n   \
    \     common[k] = l1[k];\n    }\n    return common;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9_9bfcow.d(24): Error: cannot implicitly convert expression `l1.length
    > l2.length ? l1.length : l2.length` of type `ulong` to `int`

    /tmp/tmp9_9bfcow.d(29): Error: cannot implicitly convert expression `l1[l1.length
    - cast(ulong)k - 1LU]` of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9_9bfcow.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = {0L};\n    std.typecons.Reverse(l2);\n    for(int i\
    \ = 0; i < l1.length; i++) \n    {\n        long common = std.math.Min(l1[i],\
    \ l2[i]);\n        for(int j = result.length - 1; j >= 0; j--) \n            if(result[j]\
    \ == common) break;\n            else if(result[j] > common)\n               \
    \ result[j] = common;\n    }\n    return std.typecons.Array.toLongArray(result);\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThat code does not work if you have duplicate numbers\
    \ in your arrays. For example:\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph1ujuw0g.d(26): Error: declaration expected, not `<`

    /tmp/tmph1ujuw0g.d(34): Error: declaration expected, not `assert`

    /tmp/tmph1ujuw0g.d(35): Error: declaration expected, not `assert`

    /tmp/tmph1ujuw0g.d(36): Error: declaration expected, not `assert`

    /tmp/tmph1ujuw0g.d(37): Error: declaration expected, not `assert`

    /tmp/tmph1ujuw0g.d(38): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph1ujuw0g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3;\n    if (l1.length == 0 || l2.length == 0) return new long[0];\n\
    \    \n    l3 = new long[(int)l1.length + l2.length];\n    long max = l1.length\
    \ > l2.length ? l1 : l2;\n    for(int i=0; i<l3.length; i++){\n        l3[i] =\
    \ max[i];\n    }\n    \n    \n    for(int i=0; i<l2.length; i++){\n        long\
    \ curr = l2[i];\n        for(int j=0; j<l3.length; j++){\n            if (curr\
    \ == l3[j]){\n                Arrays.copyOf(l3, j, l3.length-j, l3.length-j+1);\n\
    \                l3[j+1] = l3[j];\n                \n                \n      \
    \          l3 = Arrays.copyOf(l3, l3.length-j, l3.length-j+1);\n             \
    \   Arrays.sort(l3);\n                return l3;\n            }\n        }\n \
    \   }\n    return l3;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0acz7yep.d(17): Error: C style cast illegal, use `cast(int)l1.length`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0acz7yep.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tvar result=new long[l1.length+l2.length];\n\tfor(int i=0;i<l1.length;i++)\n\
    \t\tfor(int j=0;j<l2.length;j++)\n\t\t\tif(i==j)\n\t\t\t\tresult[i]=l1[i];\n\t\
    \t\telse if(i<j){\n\t\t\t\tint cmp=l1[i]>l2[j] ? 1-l1[i]+l2[j] :l1[i]-l2[j];\n\
    \t\t\t\tresult[i]=cmp>0 ? cmp : -cmp;\n\t\t\t\tresult[j]=cmp;\n\t\t\t}\n\treturn\
    \ result;\n}\n\t\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8fvhlo3f.d(14): Error: undefined identifier `var`

    /tmp/tmp8fvhlo3f.d(20): Error: cannot implicitly convert expression `l1[cast(ulong)i]
    > l2[cast(ulong)j] ? 1L - l1[cast(ulong)i] + l2[cast(ulong)j] : l1[cast(ulong)i]
    - l2[cast(ulong)j]` of type `long` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8fvhlo3f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  long[] result = new long[Math.min(l1.length,l2.length)];\n  int i=0,\
    \ j=0;\n  \n  while(i < result.length && j < l1.length && j < l2.length){\n  \
    \  if (l1[i] < l2[j])\n      result[i] = l1[i++];\n    else if (l1[i] > l2[j])\n\
    \      result[i] = l2[j++];\n    else\n      result[i] = l1[i++];\n  }\n  while(i\
    \ < result.length){\n    result[i] = l1[i++];\n  }\n  while(j < l2.length){\n\
    \    result[i] = l2[j++];\n  }\n  \n  return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9hgkjisu.d(14): Error: undefined identifier `Math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9hgkjisu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int i;\n    long result = 0;\n    \n    for (int i = 0; i < l1.length;\
    \ ++i)\n    {\n        result = l1[i] ^ l2[l2.length - (i + 1)];\n        \n \
    \       if (result == 0)\n            break;\n    }\n    \n    long[] res = new\
    \ long[l1.length + l2.length - 1];\n    \n    for (i = 0; i < res.length; ++i)\n\
    \        res[i] = result;\n    \n    return res;\n}\n</code>\n<|/ a tags=algorithm,c#,bitarray,java\
    \ dscore=1 |>\n<| c |>\nThat seems reasonable, although the question was tagged\
    \ Java. Also, your code is O(n^2), so it doesn't answer the question. Also, it\
    \ doesn't actually sort the arrays, so it does return the same results given the\
    \ same inputs.\n<|/ c |>\n<| c |>\nI believe it does answer the question.  The\
    \ question was \"Find a algorithm to find sorted common elements in two arrays\"\
    .  The algorithm returns sorted unique common elements and it is O(NlogN).  It\
    \ does _not_ sort the arrays.  It just returns the sorted unique common elements.\n\
    <|/ c |>\n<| a tags=algorithm,c#,bitarray,java |>\nThe best answer I have found\
    \ is this:\n<code>\npublic static long[] Common(long[] a, long[] b)\n{\n    long[]\
    \ res = new long[Math.Max(a.Length, b.Length)];\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxm8riu5t.d(32): Error: declaration expected, not `<`

    /tmp/tmpxm8riu5t.d(35): Error: unterminated character constant

    /tmp/tmpxm8riu5t.d(35): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxm8riu5t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n   long[] c = new long[l1.length + l2.length];\n   long t;\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjn3qggbl.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjn3qggbl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    /*\n    Sort l2 first\n    \n    */\n    if (l2.length < 1) {\n   \
    \     l2 = l2;\n    }\n    long [] sorted2 = sort(l2);\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuqpql_nd.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuqpql_nd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tvar results = new long[l1.length];\n\tstd.array.sort(l1);\n\tstd.array.sort(l2);\n\
    \tstd.typecons.Arrays.sort(results);\n\tvar i = 0;\n\tfor (; i < l1.length; i++)\
    \ {\n\t\tif (results[i] == l1[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (results[i]\
    \ == l2[i]) {\n\t\t\tresults[i] = l2[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn results;\n\
    }\n/*\nReturn common elements for two arrays of arrays of doubles. \nThe inner\
    \ arrays are sorted first by sizes.\n    >>> common([[[1.1, 2.1], [1.2, 2.2]],\
    \ [[1.1, 2.1], [1.3, 2.3]]], [])\n    [[1.1, 2.1], [1.2, 2.2]]\n    >>> common([[[1.1,\
    \ 2.1], [1.2, 2.2]], [[1.1, 2.1], [1.3, 2.3]]], [[1.1, 2.1]])\n    [[1.1, 2.1],\
    \ [1.2, 2.2]]\n*/\ndouble[][] common(double[][] l1, double[][] l2) \n{\n\tvar\
    \ results = new double[l1.length];\n\tstd.array.sort(l1);\n\tstd.array.sort(l2);\n\
    \tstd.typecons.Arrays.sort(results);\n\tvar i = 0;\n\tfor (; i < l1.length; i++)\
    \ {\n\t\tif (results[i] == l1[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (results[i]\
    \ == l2[i]) {\n\t\t\tresults[i] = l2[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn results;\n\
    }\n/*\nReturn common elements for two arrays of arrays of longs. \nThe inner arrays\
    \ are sorted first by sizes.\n    >>> common([[[1L, 2L], [1L, 2L]], [[1L, 2L],\
    \ [1L, 2L]]], [])\n    [[1L, 2L], [1L, 2L]]\n    >>> common([[[1L, 2L], [1L, 2L]],\
    \ [[1L, 2L], [1L, 2L]]], [[1L, 2L]])\n    [[1L, 2L], [1L, 2L]]\n*/\nlong[][] common(long[][]\
    \ l1, long[][] l2) \n{\n\tvar results = new long[l1.length];\n\tstd.array.sort(l1);\n\
    \tstd.array.sort(l2);\n\tstd.typecons.Arrays.sort(results);\n\tvar i = 0;\n\t\
    for (; i < l1.length; i++) {\n\t\tif (results[i] == l1[i]) {\n\t\t\tcontinue;\n\
    \t\t}\n\t\tif (results[i] == l2[i]) {\n\t\t\tresults[i] = l2[i];\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn results;\n}\n/*\nReturn common element\nunittest\n{\n   \
    \ alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp08h91vop.d(82): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp08h91vop.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    if (l1.length == 0)\n        return l2;\n    if (l2.length == 0)\n\
    \        return l1;\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpztrmtps5.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztrmtps5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[math.combination(l1.length, l2.length)];\n  \
    \  \n    for(int i = 0; i < ret.length; i++)\n    {\n        int count = 0;\n\
    \        for(int j = 0; j < l1.length; j++)\n        {\n            if(l1[j] ==\
    \ l2[j])\n                count++;\n        }\n        ret[i] = count;\n    }\n\
    \    \n    return ret;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5w20nejl.d(14): Error: undefined identifier `math`, did you mean
    function `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5w20nejl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    Arrays.sort(l1);\n    Arrays.sort(l2);\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy43au1e9.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy43au1e9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[32];\n    long[] i1 = new long[l1.length];\n\
    \    long[] i2 = new long[l2.length];\n    int i = j = 0;\n    while (i<i1.length\
    \ && j<i2.length) \n    {\n        if (l1[i] == l2[j])\n        {\n          \
    \  res[i] = l1[i];\n            i++;\n            j++;\n        }\n        else\
    \ if (l1[i] > l2[j])\n        {\n            j++;\n        }\n        else\n \
    \       {\n            i++;\n        }\n    }\n    return res;\n}\n}\n</code>\n\
    <|/ a dscore=2 tags=performance,java,algorithm |>\n<| c |>\nThis is unnecessarily\
    \ complicated. Just use `Set`.\n<|/ c |>\n<| c |>\nThis answer is just plain wrong.\
    \ `Set` uses `equals()` method to compare objects, not `compareTo()`.\n<|/ c |>\n\
    <| c |>\n`Arrays.sort(...);` will also use a quicksort on `long[]`, unless you\
    \ disable the [`mergesort`](http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/util/Arrays.java#Arrays.mergesort%28long%5B%5D%2Clong%5B%5D%2Clong%5B%5D%2Clong%5B%5D%29)\
    \ optimization (see source code).\n<|/ c |>\n<| a |>\nUsing hashmap will give\
    \ an efficiency of O(n).\n<code>\npublic static void common(int[] nums, int[]\
    \ nums2){\n    Map<Integer, Integer> hashMap = new HashMap<>();\n    for(int i\
    \ = 0; i < nums.length; i++)\n    {\n        if(hashMap.containsKey(nums[i]))\n\
    \        {\n            hashMap.put(nums[i], hashMap.get(nums[i]) + 1);\n    \
    \    }\n        else\n        {\n            hashMap.put(nums[i], 1);\n      \
    \  }\n    }\n    for(int i = 0; i < nums2.length; i++)\n    {\n        if(hashMap.containsKey(nums2[i]))\n\
    \        {\n            if(hashMap.get(nums2[i]) == hashMap.get(nums[i]))\n  \
    \          {\n                System.out.print(nums2[i] + \" \");\n          \
    \  }\n        }\n    }\n}\n</code>\n<|/ a tags=performance,java,algorithm dscore=1\
    \ |>\n<| c |>\nThis answer is wrong. The OP wants to know if two arrays have any\
    \ common elements. Using a `HashMap` for counting would give a false negative.\n\
    <|/ c |>\n<| c |>\nI think \nunittest\n{\n    alias candidate = common;\n\n  \
    \  assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl2eckl6u.d(37): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl2eckl6u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] common = new long[1000];\n\tint i,j,k;\n\tint m1,m2,n1,n2;\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn4zls8z3.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn4zls8z3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length];\n    int i = 0;\n    int j = 0;\n\
    \    for(;i < l1.length;i++) {\n        for(;j < l2.length;j++) {\n          \
    \  if (l1[i] < l2[j]) {\n                result[i] = l1[i];\n                break;\n\
    \            }\n            if (l1[i] == l2[j]) {\n                result[i++]\
    \ = l1[i];\n            }\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nIt may not be the most efficient way, but it is short\
    \ and readable.  \n<code>\n List<Integer> nums = new ArrayList<Integer>();\n List<Integer>\
    \ nums2 = new ArrayList<Integer>();\n nums.add(1);\n nums.add(2);\n nums.add(3);\n\
    \ nums.add(4);\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkrzp019e.d(30): Error: declaration expected, not `<`

    /tmp/tmpkrzp019e.d(36): Error: no identifier for declarator `List`

    /tmp/tmpkrzp019e.d(36): Error: declaration expected, not `<`

    /tmp/tmpkrzp019e.d(37): Error: unexpected `(` in declarator

    /tmp/tmpkrzp019e.d(37): Error: basic type expected, not `1`

    /tmp/tmpkrzp019e.d(37): Error: found `1` when expecting `)`

    /tmp/tmpkrzp019e.d(37): Error: no identifier for declarator `nums.add(_error_)`

    /tmp/tmpkrzp019e.d(37): Error: semicolon expected following function declaration

    /tmp/tmpkrzp019e.d(37): Error: declaration expected, not `)`

    /tmp/tmpkrzp019e.d(38): Error: unexpected `(` in declarator

    /tmp/tmpkrzp019e.d(38): Error: basic type expected, not `2`

    /tmp/tmpkrzp019e.d(38): Error: found `2` when expecting `)`

    /tmp/tmpkrzp019e.d(38): Error: no identifier for declarator `nums.add(_error_)`

    /tmp/tmpkrzp019e.d(38): Error: semicolon expected following function declaration

    /tmp/tmpkrzp019e.d(38): Error: declaration expected, not `)`

    /tmp/tmpkrzp019e.d(39): Error: '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length];\n    int i = 0; // index of first\
    \ element in result\n    int j = 0;\n    for (int k = 0; k < l1.length; ++k)\n\
    \    {\n        while (j < l2.length && l1[k] == l2[j])\n        {\n         \
    \   ++j;\n        }\n        if (j == l2.length)\n        {\n            res[i]\
    \ = l1[k];\n            ++i;\n            j = 0;\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpfwpgwt3i.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285d5]

    ??:? void tmpfwpgwt3i.__unittest_L32_C1() [0x42805e]

    ??:? void tmpfwpgwt3i.__modtest() [0x428358]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c68f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b522]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307ad]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c5c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430739]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4f9]

    ??:? runModuleUnitTests [0x42c465]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a98]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length];\n    int i = 0, j = 0;\n    while(i\
    \ < l1.length && j < l2.length) \n    {\n        if(l1[i] == l2[j]) {\n      \
    \      res[j++] = l1[i++];\n        }\n        else if(l1[i] > l2[j]) {\n    \
    \        j++;\n        }\n        else {\n            i++;\n        }\n    }\n\
    \    while(i < l1.length) {\n        res[j++] = l1[i++];\n    }\n    while(j <\
    \ l2.length) {\n        res[i++] = l2[j++];\n    }\n    return res;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nYou can use the HashSet<T> class from Java's Collections\
    \ API.\n<code>\npackage example;\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb3v7t9c9.d(36): Error: declaration expected, not `<`

    /tmp/tmpb3v7t9c9.d(39): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb3v7t9c9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  if(l1 == null || l2 == null || l1.length == 0 || l2.length == 0) \n \
    \ {\n    return null;\n  }\nunittest\n{\n    alias candidate = common;\n\n   \
    \ assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuyhuf8o9.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuyhuf8o9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] result;\n\tint l1_count = l1.length;\n\tint l2_count = l2.length;\n\
    \tlong[] l1_array = l1;\n\tlong[] l2_array = l2;\n\tlong[] l1_sorted = new long[l1_count];\n\
    \tlong[] l2_sorted = new long[l2_count];\n\t\n\tfor(int i=0; i < l1_count; i++)\n\
    \t{\n\t\tl1_sorted[i] = l1_array[i];\n\t}\n\tfor(int i=0; i < l2_count; i++)\n\
    \t{\n\t\tl2_sorted[i] = l2_array[i];\n\t}\n\tArrays.sort(l1_sorted);\n\tArrays.sort(l2_sorted);\n\
    \t\n\tint i=0;\n\twhile(i<l1_count && i<l2_count)\n\t{\n\t\tif(l1_sorted[i]==l2_sorted[i])\n\
    \t\t{\n\t\t\tl1_sorted[i++]=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlong[] result =\
    \ new long[l1_count-l2_count+1];\n\t\t\tint j=0;\n\t\t\tfor(j=0; j < l1_count;\
    \ j++)\n\t\t\t{\n\t\t\t\tif(l1_sorted[j]==l2_sorted[j])\n\t\t\t\t{\n\t\t\t\t\t\
    result[j]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult[j]=l1_sorted[j];\n\
    \t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tArrays.sort(result);\n\t\t\tfor(int k=0; k\
    \ < l1_count; k++)\n\t\t\t{\n\t\t\t\tl1_array[k]=result[k];\n\t\t\t}\n\t\t\tl1_count\
    \ = l1.length;\n\t\t\ti=0;\n\t\t}\n\t}\n\t\n\tif(i==l1_count)\n\t{\n\t\tfor(j=0;\
    \ j < l2.length; j++)\n\t\t{\n\t\t\tl1_array[j]=l2[j];\n\t\t}\n\t}\n\telse if(i==l2_count)\n\
    \t{\n\t\tfor(j=0; j < l1.length; j++)\n\t\t{\n\t\t\tl2_array[j]=l1[j];\n\t\t}\n\
    \t}\n\telse\n\t{\n\t\tfor(j=0; j < l1.length; j++)\n\t\t{\n\t\t\tl2_array[j]=l1[j];\n\
    \t\t}\n\t\tfor(j=0; j < l2.length; j++)\n\t\t{\n\t\t\tl1_array[j]=l2[j];\n\t\t\
    }\n\t}\n\t\n\tresult = new long[l1_count-l2_count+1];\n\tfor(int j=0; j < l1.length;\
    \ j++)\n\t{\n\t\tresult[j]=l1_array[j];\n\t}\n\tfor(int j=0; j < l2.length; j++)\n\
    \t{\n\t\tresult[l1_count+j]=l2_array[j\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpni0eir0l.d(100): Error: found `unittest` when expecting `,`

    /tmp/tmpni0eir0l.d(109): Error: found `void` when expecting `,`

    /tmp/tmpni0eir0l.d(109): Error: found `{` when expecting `,`

    /tmp/tmpni0eir0l.d(109): Error: expression expected, not `}`

    /tmp/tmpni0eir0l.d(109): Error: found `End of File` when expecting `,`

    /tmp/tmpni0eir0l.d(109): Error: found `End of File` when expecting `]`

    /tmp/tmpni0eir0l.d(109): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpni0eir0l.d(109): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpni0eir0l.d(109): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni0eir0l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long common = l1[0];\n    for (long i : l1)\n    {\n        if (l2.contains(i))\n\
    \        {\n            l2.remove(i);\n            common = i;\n        }\n  \
    \  }\n    long[] result = new long[] {common};\n    if (l2.size() > 0)\n    {\n\
    \        long[] common2 = common(l1, l2);\n        for (long i : common2)\n  \
    \      {\n            long[] ix = new long[] {i};\n            result.addAll(common(ix));\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn unique elements from two\
    \ arrays.\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf35bc2bu.d(15): Error: semicolon expected, not `:`

    /tmp/tmpf35bc2bu.d(15): Error: expression expected, not `:`

    /tmp/tmpf35bc2bu.d(15): Error: found `l1` when expecting `;` following `for` condition

    /tmp/tmpf35bc2bu.d(23): Error: semicolon expected, not `{`

    /tmp/tmpf35bc2bu.d(23): Error: found `}` when expecting `;` following statement

    /tmp/tmpf35bc2bu.d(23): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpf35bc2bu.d(27): Error: semicolon expected, not `:`

    /tmp/tmpf35bc2bu.d(27): Error: expression expected, not `:`

    /tmp/tmpf35bc2bu.d(27): Error: found `common2` when expecting `;` following `for`
    condition

    /tmp/tmpf35bc2bu.d(29): Error: semicolon expected, not `{`

    /tmp/tmpf35bc2bu.d(29): Error: found `}` when expecting `;` following statement

    /tmp/tmpf35bc2bu.d(29): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpf35bc2bu.d(35): Error: unterminated /* */ comment

    /tmp/tmpf35bc2bu.d(46): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpf35bc2'
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] common = new long[l1.length];\n    int j = 0;\n    for (int\
    \ i = 0; i < l1.length; i++) \n    {\n        while ((j < l2.length) && (l1[i]\
    \ == l2[j]))\n        {\n            j++;\n        }\n        if (j >= l2.length)\n\
    \        {\n            common[i] = l1[i];\n        }\n    }\n    return common;\n\
    }\n/*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjd_iieyz.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjd_iieyz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ans = l1;\n    for( int i = 1; i < l1.length; i++ )\n      \
    \  ans[0] = std.algo.sort.min(ans[0], l1[i]);\n    for( int i = 1; i < l2.length;\
    \ i++ )\n        ans[0] = std.algo.sort.min(ans[0], l2[i]);\n    return ans;\n\
    }\n/*\nReturn the number of pairs (x,y) where x < y and y > 0.\n    >>> count_unique_pairs([2,3,4,4,5,5,7,8,8,9])\n\
    \    2\n    >>> count_unique_pairs([3,3])\n    1\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiej2vmy3.d(21): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiej2vmy3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int n = l1.length();\n    if (n==0) return l2;\n    if (n==1) return\
    \ l1;\n    long[] l3 = new long[n];\n    for(int i=0;i<n;i++) \n    {\n      \
    \  if (l1[i]!=l2[i]) \n        {\n            l3[i] = l1[i];\n            l1[i]\
    \ = l2[i]; \n            l2[i] = l3[i];\n        }\n    }\n    return l3;\n}\n\
    </code>\n<|/ a tags=java,arrays dscore=4 |>\n<| c |>\nthis does not work if a\
    \ duplicate is found, e.g. {5,5}, {5,5}\n<|/ c |>\n<| c |>\nIt doesn't work even\
    \ if duplicates are found.  Try this example: common([4,4], {4,4,4,4,4,4,4,4})\
    \ --> [4,4,4,4]\n<|/ c |>\n<| c |>\n: you're right, I misread the question. Sorry!\n\
    <|/ c |>\n<| c |>\nYes, it works. In case you need the answer in another language,\
    \ here is an example of it in Java: `public static int[] common(int[] a, int[]\
    \ b) {\n        int[] result = new int[a.length];\n        int index = 0;\n  \
    \      int current = 0;\n        \n        for(int i = 0; i < a.length; i++){\n\
    \            current = 0;\n            for(int j = 0; j < b.length; j++){\n  \
    \              if(a[i] == b[j]){\n                    current++;\n           \
    \     }\n            }\n            if(current > 1){\n                result[index]\
    \ = a[i];\n                index++;\n            }\n        }\n        return\
    \ result;\n    }`\n<|/ c |>\n<| a |>\nIn Java, you could use Collections.intersection\
    \ for that purpose:\n<code>\npublic static int[] common(int[] a, int[] b) {\n\
    \    return Arrays.stream(Collections.intersection(a, b)).toArray();\n}\n</code>\n\
    <|/ a dscore=4 tags=java,arrays |>\n<| c |>\nThis is not guaranteed to preserve\
    \ the relative ordering of elements.\n<|/ c |>\n<| c |>\nIn Java 8, you can also\
    \ use new streams API to achieve the same result:  `return Arrays.stream(a).filter(i\
    \ -> Arrays.stream(b).anyMatch(j -> i == j)).sorted().toArray();`\n<|/ c |>\n\
    <| c |>\nNote that this returns an empty array if they have no common elements.\n\
    <|/ c |>\n<| a tags=java,arrays dscore=4 |>\nA slight modification to the answer\
    \ by to make it work with a sorted input:\n<code>\npublic static int[] common(int[]\
    \ a, int[] \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppdo2k320.d(29): Error: declaration expected, not `<`

    /tmp/tmppdo2k320.d(35): Error: unterminated character constant

    /tmp/tmppdo2k320.d(38): Error: unterminated character constant

    /tmp/tmppdo2k320.d(66): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppdo2k320.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    if (l1.length != l2.length) \n        throw new IllegalArgumentException(\"\
    Arrays must be the same size.\");\n    long maxVal = l1[l1.length - 1];\n    long[]\
    \ result = new long[l1.length - 1];\n    for (int i = 0; i < l1.length - 1; i++)\
    \ {\n        if (l1[i] == l2[i]) \n            result[i] = l1[i]; \n        else\
    \ if (l1[i] > maxVal) {\n            maxVal = l1[i];\n            result[i] =\
    \ l2[i];\n        } else if (l2[i] > maxVal) {\n            maxVal = l2[i];\n\
    \            result[i] = l1[i];\n        } else {\n            System.arraycopy(l2,\
    \ 0, result, i + 1, l1.length - i - 1);\n            result[i] = l1[i];\n    \
    \    }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkqqah1sb.d(15): Error: undefined identifier `IllegalArgumentException`

    /tmp/tmpkqqah1sb.d(28): Error: undefined identifier `System`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkqqah1sb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tif (l1 == l2) \n\t{\n\t\treturn l1; // if they are equal then they share\
    \ no common elements\n\t}\n\t\n\tif (l1 == null) \n\t{\n\t\treturn l2; // l1 could\
    \ be null if l2 was null, or if l1 was just null\n\t}\n\t\n\tif (l2 == null) \n\
    \t{\n\t\treturn l1; // l2 could be null if l1 was null, or if l1 was just null\n\
    \t}\n\t\n\tint length = l1.length; // length of one of the arrays\n\tif (l2.length\
    \ != length) \n\t{\n\t\t// not same length: returning the smallest array since\
    \ we don't know which ones is smaller\n\t\treturn l1;\n\t}\n\t\n\tint result[]\
    \ = new int[length]; // will hold the indices of commons\n\tfor (int i = 0; i\
    \ < length; i++) \n\t{\n\t\tresult[i] = -1;\n\t}\n\t\n\tfor (int i = 0; i < length;\
    \ i++) \n\t{\n\t\tint commonIndex = -1;\n\t\tfor (int j = 0; j < length; j++)\
    \ \n\t\t{\n\t\t\tif (result[j] == -1) \n\t\t\t{\n\t\t\t\tif (l1[i] == l2[j]) \n\
    \t\t\t\t{\n\t\t\t\t\tresult[j] = i;\n\t\t\t\t\tcommonIndex = j;\n\t\t\t\t}\n\t\
    \t\t}\n\t\t}\n\t\t\n\t\tif (commonIndex == -1) \n\t\t{\n\t\t\tresult[i] = i; //\
    \ found no common elements\n\t\t}\n\t\telse \n\t\t{\n\t\t\t// remove this common\
    \ element from both arrays\n\t\t\tfor (int j = 0; j < length; j++) \n\t\t\t{\n\
    \t\t\t\tif (result[j] == i) \n\t\t\t\t{\n\t\t\t\t\tresult[j] = -1;\n\t\t\t\t}\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\tlong[] result = new long[result.length];\n\tfor (int\
    \ i = 0; i < result.length; i++) \n\t{\n\t\tif (result[i] != -1) \n\t\t{\n\t\t\
    \tresult[i] = l1[result[i]];\n\t\t}\n\t}\n\t\n\treturn result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgz7eilzq.d(36): Deprecation: instead of C-style syntax, use D-style
    syntax `int[] result`

    /tmp/tmpgz7eilzq.d(29): Error: cannot implicitly convert expression `l1.length`
    of type `ulong` to `int`

    /tmp/tmpgz7eilzq.d(74): Error: declaration `tmpgz7eilzq.common.result` is already
    defined

    /tmp/tmpgz7eilzq.d(79): Error: cannot implicitly convert expression `l1[cast(ulong)result[cast(ulong)i]]`
    of type `long` to `int`

    /tmp/tmpgz7eilzq.d(83): Error: cannot implicitly convert expression `result` of
    type `int[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz7eilzq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[64];\n    long c = 0;\n    int j = 0;\n    for\
    \ (long i = 0; i <= 32; i++) {\n        c |= l1[i];\n        c |= l2[i];\n   \
    \     l3[j++] = c;\n    }\n    for (int i = 64; i < l3.length; i++) {\n      \
    \  c &= l3[i - 32];\n        l3[i] = c;\n    }\n    Arrays.sort(l3);\n    return\
    \ l3;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpugi5rinf.d(26): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpugi5rinf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int i, j;\n    \n    int n = l1.length;\n    int m = l2.length;\n \
    \   long[] result = new long[Math.min(m, n)];\n    \n    // Compare each element\
    \ of l1 with each element of l2.\n    // Start comparing elements with the first\
    \ element of l1.\n    // Each comparison yields a sorted common subsequence for\
    \ l1 and l2.\n    // For example, comparing l1[0L] with l2[0] is equivalent to\
    \ comparing l1[0] and l2[0].\n    // To minimize the number of comparisons, sort\
    \ the subsequences.\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j\
    \ < m; j++)\n        {\n            if (l1[(i + j) % n] < l2[(i + j) % n])\n \
    \           {\n                swap(l1, i, j);\n                break;\n     \
    \       }\n        }\n    }\n    \n    \n    // Finally, return the unique subsequences.\n\
    \    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < m; j++)\n       \
    \ {\n            if (l1[(i + j) % n] == l2[(i + j) % n])\n            {\n    \
    \            result[(i + j) % n] = l1[(i + j) % n];\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy7njjglv.d(16): Error: cannot implicitly convert expression `l1.length`
    of type `ulong` to `int`

    /tmp/tmpy7njjglv.d(17): Error: cannot implicitly convert expression `l2.length`
    of type `ulong` to `int`

    /tmp/tmpy7njjglv.d(18): Error: undefined identifier `Math`

    /tmp/tmpy7njjglv.d(31): Error: undefined identifier `swap`, did you mean template
    `wrap(Targets...) if (Targets.length >= 1 && allSatisfy!(isMutable, Targets))`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy7njjglv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n        long common_num = 0;\n        long common_den = 0;\n        long\
    \ common = 0;\n        int num1 = 0,num2 = 0;\n        long l = 0;\n        for(long\
    \ i = 0; i < l1.length && i < l2.length; i ++){\n                if (l1[i] ==\
    \ l2[i]){\n                        common_num++;\n                        if (l1[i]\
    \ > 0)\n                                common_den++;\n                } else\
    \ {\n                        common_num--;\n                        if (l1[i]\
    \ < 0)\n                                common_den--;\n                }\n   \
    \     }\n        for (long i = 0; i < common_num; i ++){\n                for\
    \ (long j = 0; j < common_den; j++){\n                        if (common_num -\
    \ i > 0){\n                                common = common + l1[j] * l1[i] * common_den;\n\
    \                                num1 ++;\n                        }\n       \
    \                 if (common_den - j > 0){\n                                common\
    \ = common + common_num * common_den * l1[j] * l1[i];\n                      \
    \          num2 ++;\n                        }\n                }\n        }\n\
    \        l = num1 + num2;\n        long[] res = new long[l];\n        int count\
    \ = 1;\n        for (long i = 0; i < common_num; i ++){\n                for (long\
    \ j = 0; j < common_den; j++){\n                        res[count++] = common;\n\
    \                        common = common + l1[j] * l1[i] * common_den;\n     \
    \                   num1 ++;\n                        common = common + common_num\
    \ * common_den * l1[j] * l1[i];\n                        num2 ++;\n          \
    \      }\n        }\n        for (long i = 0; i < common_num; i ++){\n       \
    \         for (long j = 0; j < common_den; j++){\n                        res[count++]\
    \ = common;\n                        common = common + common_num * common_den\
    \ * l1[j] * l1[i];\n                        num1 ++;\n                       \
    \ common = common + common_num * common_den * l1[j] * l1[i];\n               \
    \         num2 ++;\n                }\n        }\n        res[0] = common;\n \
    \       return res;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpma3pl4g7.d(63): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428b1e]

    ??:? long[] tmpma3pl4g7.common(long[], long[]) [0x428399]

    ??:? void tmpma3pl4g7.__unittest_L66_C1() [0x428493]

    ??:? void tmpma3pl4g7.__modtest() [0x4287ec]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42cb27]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b9ba]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430c45]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x4310f4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430bd1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b991]

    ??:? runModuleUnitTests [0x42c8fd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functi'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] common = new long[std::min(l1.length, l2.length)];\n    \n \
    \   int j = 0;\n    for(int i = 0; i < l1.length; ++i)\n    {\n        for(int\
    \ k = 0; k < l2.length; ++k)\n        {\n            if(l1[i] == l2[k])\n    \
    \        {\n                common[j] = l1[i];\n                ++j;\n       \
    \         break;\n            }\n        }\n    }\n    \n    return common;\n\
    }\n</code>\n<|/ a tags=c#,algorithm,c++ |>\n<| c |>\nThis code doesn't work. Try\
    \ it with l1 = {1,1,1,2,2} and l2 = {1,1}, it should give {1}\n<|/ c |>\n<| c\
    \ |>\nThanks for your answer. I tried your code, but it doesn't work: it gives\
    \ me the common items only when the two arrays are sorted. It works in the example,\
    \ but for arrays such as {1, 2, 3, 4} and {1, 3, 4}, it does not work. Maybe there\
    \ is some bug in the code, but I can't find it.\n<|/ c |>\n<| c |>\n: This code\
    \ does not return `{1, 3, 4}` because it does not take that into account. My code\
    \ returns `{1, 2, 3}` because it takes this into account. Your code should work\
    \ fine with `{1, 2, 3, 4}` and `{1, 3, 4}` as well.\n<|/ c |>\n<| c |>\nYes, it\
    \ works fine, but in my example it only returns 1 item, and for {1, 2, 3, 4} and\
    \ {1, 3, 4} it returns 2 items.\n<|/ c |>\n<| c |>\n: I tested the code with `{1,\
    \ 2, 3, 4}` and `{1, 3, 4}` and it works fine. The code returns `{1, 3, 4}`. Are\
    \ you sure that you are not modifying the original arrays?\n<|/ c |>\n<| a tags=c#,algorithm,c++\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa7j54uih.d(14): Error: found `:` when expecting `]`

    /tmp/tmpa7j54uih.d(14): Error: semicolon expected, not `:`

    /tmp/tmpa7j54uih.d(14): Error: found `:` instead of statement

    /tmp/tmpa7j54uih.d(32): Error: declaration expected, not `<`

    /tmp/tmpa7j54uih.d(35): Error: unterminated character constant

    /tmp/tmpa7j54uih.d(38): Error: unterminated character constant

    /tmp/tmpa7j54uih.d(38): Error: unterminated character constant

    /tmp/tmpa7j54uih.d(52): Error: semicolon expected, not `.`

    /tmp/tmpa7j54uih.d(52): Error: no identifier for declarator `.Collections.Generic`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa7j54uih.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int n1 = l1.length;\n    int n2 = l2.length;\n    long[] c1 = new long[n1+n2\
    \ - 1];\n    long[] c2 = new long[n1+n2 - 1];\n    for (int i = 0; i < n1; i++)\
    \ {\n        c1[i] = l1[i];\n    }\n    for (int j = 0; j < n2; j++) {\n     \
    \   c2[j] = l2[j];\n    }\n    Arrays.sort(c1, 0, n1, CompareLong.LT);\n    Arrays.sort(c2,\
    \ 0, n2, CompareLong.LT);\n    return Arrays.copyOfRange(c1, n1, n1+n2);\n}\n\
    /**\n * Returns the lexicographical union of the two arrays.\n * See http://en.wikipedia.org/wiki/Lexicographic_order\
    \ for detail.\n */\nlong[] union(long[] l1, long[] l2) {\n    long[] c = common(l1,\
    \ l2);\n    long[] u = new long[l1.length+l2.length];\n    for (int i = 0; i <\
    \ l1.length; i++) {\n        u[i] = l1[i];\n    }\n    for (int i = 0; i < l2.length;\
    \ i++) {\n        u[i+l1.length] = l2[i];\n    }\n    return u;\n}\n/**\n * Returns\
    \ true if array a is equal to array b. \n */\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpng68_7zc.d(32): Error: no identifier for declarator `long[]`

    /tmp/tmpng68_7zc.d(32): Error: { } expected following `union` declaration

    /tmp/tmpng68_7zc.d(32): Error: declaration expected, not `(`

    /tmp/tmpng68_7zc.d(35): Error: declaration expected, not `for`

    /tmp/tmpng68_7zc.d(35): Error: no identifier for declarator `i`

    /tmp/tmpng68_7zc.d(35): Error: declaration expected, not `<`

    /tmp/tmpng68_7zc.d(35): Error: no identifier for declarator `i`

    /tmp/tmpng68_7zc.d(35): Error: declaration expected, not `++`

    /tmp/tmpng68_7zc.d(37): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpng68_7zc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    // Sorts both arrays so that they can be compared directly.\n    Arrays.sort(l1);\n\
    \    Arrays.sort(l2);\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx1fq9h6a.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx1fq9h6a.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  long l1c[l1.length];\n  int j = 0;\n  for (int i = 0; i < l1.length;\
    \ i++) \n    l1c[j++] = l1[i];\n  \n  long l2c[l2.length];\n  int j2 = 0;\n  for\
    \ (int i = 0; i < l2.length; i++) \n    l2c[j2] = l2[i];\n  \n  long result[l1c.length];\n\
    \  \n  int i, k;\n  \n  for (i = 0; i < l2.length; i++) \n  {\n     k = l2c[i];\n\
    \     while (j < l1.length && l1c[j] < k) \n         j++;\n     while (j2 < l1.length\
    \ && l1c[j2] <= k) \n         j2++;\n     if (j == l1.length) \n        result[i]\
    \ = k;\n     else if (j2 == l1.length) \n        result[i] = k;\n     else \n\
    \     {\n        if (l1c[j] <= k) \n           result[i] = l1c[j];\n        else\n\
    \           result[i] = l1c[j2];\n     }\n  }\n  return result;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| a tags=sorting,arrays,c |>\nA simple way to sort two arrays\
    \ in C using qsort function and strcmp function :\n<code>\n#include <stdio.h>\n\
    #include <stdlib.h>\n#include <string.h>\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpicu9ku0d.d(14): Deprecation: instead of C-style syntax, use D-style
    syntax `long[l1.length] l1c`

    /tmp/tmpicu9ku0d.d(19): Deprecation: instead of C-style syntax, use D-style syntax
    `long[l2.length] l2c`

    /tmp/tmpicu9ku0d.d(24): Deprecation: instead of C-style syntax, use D-style syntax
    `long[l1c.length] result`

    /tmp/tmpicu9ku0d.d(49): Error: declaration expected, not `<`

    /tmp/tmpicu9ku0d.d(61): Error: declaration expected, not `assert`

    /tmp/tmpicu9ku0d.d(62): Error: declaration expected, not `assert`

    /tmp/tmpicu9ku0d.d(63): Error: declaration expected, not `assert`

    /tmp/tmpicu9ku0d.d(64): Error: declaration expected, not `assert`

    /tmp/tmpicu9ku0d.d(65): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpicu9ku0d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    if (l1 == null)\n        return l2;\n    if (l2 == null)\n        return\
    \ l1;\n    long[] result = new long[26];\n    int j = 0;\n    for (int i = 0;\
    \ i <l1.length && i < l2.length; i++) \n    {\n        if (l1[i] < l2[i]) \n \
    \       {\n            result[j++] = l1[i]; \n        }\n        else if (l1[i]\
    \ > l2[i]) \n        {\n            result[j++] = l2[i];\n        }\n    } \n\
    \    for (int i = 0; i < result.length; i++) \n    {\n        bool find = false;\n\
    \        for (int j = 0; j < result.length; j++) \n        {\n            if (result[i]\
    \ == result[j]) \n            {\n                find = true;\n              \
    \  break;\n            }\n        }\n        if (!find) \n        {\n        \
    \    result[i] = -1L;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9mua303q.d(34): Error: variable `j` is shadowing variable `tmp9mua303q.common.j`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9mua303q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length];\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n\
    \    int j = 0;\n    for(int i = 0; i < l1.length; i++) \n    {\n        if(l1[i]\
    \ == l2[j])\n        {\n            result[j] = l1[i];\n            j++;\n   \
    \     }\n        else\n        {\n            int idx = j;\n            while(j\
    \ < result.length && result[j] == l1[i])\n            {\n                result[idx]\
    \ = result[j];\n                j++;\n            }\n            result[idx] =\
    \ l1[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy4tf5lix.d(15): Error: undefined identifier `Arrays`

    /tmp/tmpy4tf5lix.d(16): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy4tf5lix.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    // return l1.filter(x => !l2.contains(x));\n    long[] result = new\
    \ long[l1.length];\n    long[] copy = new long[l1.length];\n    for (int i = 0;\
    \ i < l1.length; i++) {\n        copy[i] = l1[i];\n    }\n    sort(copy);\n  \
    \  for (int i = 0; i < l2.length; i++) {\n        int j = 0;\n        while (l1[j]\
    \ == l2[j]) {\n            j++;\n            if (j >= l1.length) {\n         \
    \       j = 0;\n            }\n        }\n        result[i] = copy[j];\n    }\n\
    \    sort(result);\n    return result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nIf you have a huge set of data and you want to speed up the process, you\
    \ can use multiple threads.\n<code>\ndef isInCollection(coll: Collection[Int],\
    \ e: Int): Boolean =\n    coll.exists(e => e == e)\ndef isInCollection(coll: Iterable[Int],\
    \ e: Int): Boolean = coll.contains(e)\n</code>\n<|/ a tags=algorithm,scala |>\n\
    <| a tags=algorithm,scala dscore=2 |>\nIn Scala 2.10, there is also a library\
    \ function called \"intersect\" for finding common elements. \nFor your example\
    \ it would be like this:\n<code>\ncommon(Array(1, 3, 2, 2, 3, 2), Array(3, 5))\n\
    </code>\nThe result is: \n<code>\nArray(3, 2)\n</code>\n<|/ a |>\n<| a dscore=2\
    \ tags=algorithm,scala |>\nAs mentioned, in Scala 2.10, the intersect method of\
    \ Sets will give the unique set intersection of the input sets. For example Set(1,2,3).intersect(Set(3,4))\
    \ gives Set(3). \nFor your example case, I would create a Set and add the elements.\
    \ Then I would remove all elements from the source sets that also appear in the\
    \ result set. As soon as I find that an element from the source set is missing,\
    \ I know that there is still a unique intersection. Here's a Scala example for\
    \ this:\n<code>\nval source = Set(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"\
    G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"\
    R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \"a\")\nval result\
    \ = source.intersect(Set(\"A\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"\
    , \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\"\
    , \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"))\nval sourceWithoutDuplicates = source\
    \ -- result\n</code>\n<|/ a |>\n<|\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgryt80_k.d(34): Error: declaration expected, not `<`

    /tmp/tmpgryt80_k.d(57): Error: unterminated character constant

    /tmp/tmpgryt80_k.d(69): Error: declaration expected, not `assert`

    /tmp/tmpgryt80_k.d(70): Error: declaration expected, not `assert`

    /tmp/tmpgryt80_k.d(71): Error: declaration expected, not `assert`

    /tmp/tmpgryt80_k.d(72): Error: declaration expected, not `assert`

    /tmp/tmpgryt80_k.d(73): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgryt80_k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[32];\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n\
    \    for (int i = 0; i < result.length; i++)\n        result[i] = l1[i];\n   \
    \ for (int j = 0; j < result.length; j++)\n        result[j] = l2[j];\n    Arrays.sort(result);\n\
    \    return result;\n}\n/* \n Return an array of indexes in array A which are\
    \ not in array B.\n >>> arrayDiff([5L, 7L, 1L, 5L, 9L, 653L, 121L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L])\n [3, 7, 8, 0, 1, 5]\n >>> arrayDiff([5L, 3L, 2L, 8L],\
    \ [3L, 2L])\n [3, 8]\n*/\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn5ice0jc.d(15): Error: undefined identifier `Arrays`

    /tmp/tmpn5ice0jc.d(16): Error: undefined identifier `Arrays`

    /tmp/tmpn5ice0jc.d(21): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn5ice0jc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int i=0;\n    int j=0;\n    long[] c = new long[length(l1)+length(l2)];\n\
    \    while (i < length(l1) && j < length(l2)) {\n        if (l1[i]==l2[j])\n \
    \           c[i+j]=l1[i]; \n        i++;\n        j++;\n    }\n    while (i <\
    \ length(l1))\n        c[i+j]=l1[i];\n    while (j < length(l2))\n        c[i+j]=l2[j];\n\
    \    return c;\n}\n</code>\n<|/ a tags=c#,sorting,arrays |>\n<| c |>\nThe time\
    \ complexity of this is O(n\xB2), not O(n log n). O(n log n) is possible only\
    \ for sorted arrays.\n<|/ c |>\n<| c |>\nThanks, I updated the answer. Is this\
    \ better?\n<|/ c |>\n<| a tags=c#,sorting,arrays |>\nThe simplest solution is\
    \ to use LINQ extension methods like Intersect, Union, IntersectAll and so on,\
    \ but since they are LINQ methods, they have poor performance characteristics\
    \ when compared to plain arrays.\nTo be more efficient, you should use custom\
    \ algorithm that runs faster in some cases. For example, if you need to find unique\
    \ elements among N arrays of size M (N > M), you can try the following algorithm:\n\
    <code>\n// Pre-allocate result\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfx3ummmc.d(29): Error: declaration expected, not `<`

    /tmp/tmpfx3ummmc.d(32): Error: char 0x00b2 not allowed in identifier

    /tmp/tmpfx3ummmc.d(32): Error: character 0xb2 is not a valid token

    /tmp/tmpfx3ummmc.d(46): Error: declaration expected, not `assert`

    /tmp/tmpfx3ummmc.d(47): Error: declaration expected, not `assert`

    /tmp/tmpfx3ummmc.d(48): Error: declaration expected, not `assert`

    /tmp/tmpfx3ummmc.d(49): Error: declaration expected, not `assert`

    /tmp/tmpfx3ummmc.d(50): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfx3ummmc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong i,j,temp;\n\tlong[] a;\n\tlong t;\n\ta = new long[l1.length];\n\t\
    for(i=0; i<l1.length; i++) a[i]=l1[i];\n\tfor(i=0; i<l2.length; i++) a[i]=l2[i];\n\
    \tsort(a);\n\tl1=a;\n\ta = new long[l2.length];\n\tfor(i=0; i<l2.length; i++)\
    \ a[i]=l2[i];\n\tsort(a);\n\tl2=a;\n\tfor(i=0; i<l1.length; i++) \n\tfor(j=0;\
    \ j<l2.length; j++) \n\tif(a[i]==l2[j]) \n\t\tbreak;\n\tif(i==l1.length) return\
    \ null;\n\telse if(i==l2.length) return l1[i];\n\telse return l1[i];\n}\n/*\n\
    Return the common elements in two arrays if they have the same size.\n    >>>\
    \ common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [3L, 2L]\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbzbqpr_i.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbzbqpr_i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tint count = 0;\n\tlong[] res = new long[l1.length];\nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuba5nqby.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuba5nqby.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length];\n    int i = 0;\n    int j = 0;\n\
    \    for (; i<l1.length; ++i)\n    {\n        for (; j<l2.length; ++j)\n     \
    \   {\n            if (l1[i]==l2[j])\n                break;\n        }\n    \
    \    if (j==l2.length)\n            res[i]=l1[i];\n    }\n    return res;\n}\n\
    </code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work as stated in the question.\
    \ Try it with the two arrays `[1, 2, 3]` and `[3, 2]` - it will return `[1, 3]`.\
    \ This would result in the incorrect output `[3, 2]`.\n<|/ c |>\n<| c |>\nThanks\
    \ for spotting that. I've updated the code as per your feedback.\n<|/ c |>\n<|\
    \ a dscore=3 tags=c#,arrays |>\nI know this is an old thread, but just in case\
    \ people stumble upon it, this is a C# extension method to sort the array. This\
    \ method works on any number of arrays.\n<code>\npublic static IEnumerable<T>\
    \ Sort<T>(this T[] source) where T : IComparable<T>\n{\n    if (source == null)\n\
    \        throw new ArgumentNullException(nameof(source));\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxpgrvvng.d(29): Error: declaration expected, not `<`

    /tmp/tmpxpgrvvng.d(32): Error: unterminated character constant

    /tmp/tmpxpgrvvng.d(35): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxpgrvvng.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] result = new long[l1.length+l2.length];\n\tfor(int i=0;i<result.length;i++)\n\
    \t{\n\t\tresult[i] = l1[i];\n\t}\n\tfor(int i=0;i<l1.length;i++)\n\t{\n\t\tfor(int\
    \ j=0;j<l2.length;j++)\n\t\t{\n\t\t\tif(i==j)\n\t\t\t\tcontinue;\n\t\t\telse if(l1[i]==l2[j])\n\
    \t\t\t{\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t\tresult[i] = l2[j];\n\t\t\t\tresult[j]++;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpb9tl_mws.d(17): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428726]

    ??:? long[] tmpb9tl_mws.common(long[], long[]) [0x427e84]

    ??:? void tmpb9tl_mws.__unittest_L36_C1() [0x42809f]

    ??:? void tmpb9tl_mws.__modtest() [0x4283f8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c72f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5c2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43084d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cfc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4307d9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b599]

    ??:? runModuleUnitTests [0x42c505]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functi'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int[] a1 = sort(l1);\n    int[] a2 = sort(l2);\n    int[] a3 = new\
    \ int[max(a1.length, a2.length)];\n    int[] b3 = new int[max(a1.length, a2.length)];\n\
    \    int j = 0;\n    int i = 0;\n    for(int m = 0; m <= a1.length && m <= a2.length;\
    \ m++)\n    {\n        if(a1[m] == a2[m])\n        {\n            a3[j] = a1[m];\n\
    \            j++;\n        }\n        else\n        {\n            b3[i] = a1[m];\n\
    \            i++;\n        }\n    }\n    int k = 0;\n    for(int n = 0; n < a1.length\
    \ && n < a2.length; n++)\n    {\n        if(a1[n] == a2[n])\n        {\n     \
    \       a3[k] = a1[n];\n            k++;\n        }\n    }\n    return sort(a3);\n\
    }\n/*\nReturn sum of two arrays elements.\n    >>> sum([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    10\n    >>> sum([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    13\n    \n    \n*/\nlong sum(long[] l1, long[] l2) \n{\n\
    \    int m = l1.length;\n    int n = l2.length;\n    long c = 0;\n    for(int\
    \ i = 0; i < m && i < n; i++)\n    {\n        if(l1[i] == l2[i])\n        {\n\
    \            c += l1[i];\n        }\n    }\n    return c;\n}\n/*\nReturn difference\
    \ of two arrays.\n    >>> sum([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
    \ 9L, 653L, 121L])\n    10\n    >>> sum([5L, 3L, 2L, 8L], [3L, 2L])\n    13\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdpo0jwt6.d(67): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdpo0jwt6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int n = l1.length;\n    if (l2.length != n) throw new RuntimeException(\"\
    Arrays have incompatible lengths.\");\n    long[] l3 = new long[n];\n    long[]\
    \ l4 = new long[n];\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n     \
    \   if (l1[i] == l2[i]) continue;\n        if (l1[i] > l2[i]) l3[j] = l1[i];\n\
    \        else l4[j] = l2[i];\n        j++;\n    }\n    return l3.length > l4.length\
    \ ? l3 : l4;\n}\n// END of FUNCTION common\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Yes, I know. I just can't think of a better way to explain what I was talking\
    \ about...\n<|/ c |>\n<| a |>\n<code>\nimport java.util.HashSet;\nimport java.util.Set;\n\
    public class CommonElements{\n    public static void main(String[] args){\n  \
    \      Set set1 = new HashSet();\n        Set set2 = new HashSet();\n        set1.add(\"\
    1\");\n        set1.add(\"2\");\n        set1.add(\"3\");\n        set1.add(\"\
    4\");\n        set1.add(\"5\");\n        set1.add(\"6\");\n        set1.add(\"\
    7\");\n        set1.add(\"8\");\n        set1.add(\"9\");\n        set1.add(\"\
    10\");\n        set1.add(\"11\");\n        set1.add(\"12\");\n        set1.add(\"\
    13\");\n        set1.add(\"14\");\n        set1.add(\"15\");\n        set1.add(\"\
    16\");\n        set1.add(\"17\");\n        set1.add(\"18\");\n        set1.add(\"\
    19\");\n        set1.add(\"20\");\n        set1.add(\"21\");\n        set1.add(\"\
    22\");\n        set1.add(\"23\");\n        set1.add(\"24\");\n        set1.add(\"\
    25\");\n        set1.add(\"26\");\n        set1.add(\"27\");\n        set1.add(\"\
    28\");\n        set1.add(\"29\");\n        set1.add(\"30\");\n        set1.add(\"\
    31\");\n        set1.add(\"32\");\n        set1.add(\"33\");\n        set1.add(\"\
    34\");\n        set1.add(\"35\");\n        set1.add(\"36\");\n        set1.add(\"\
    37\");\n        set1.add(\"38\");\n        set1.add(\"39\");\n        set1.add(\"\
    40\");\n        set1.add(\"41\");\n        set1.add(\"42\");\n        set1.add(\"\
    43\");\n        set1.add(\"44\");\n        set1.add(\"45\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcv1piytr.d(28): Error: declaration expected, not `<`

    /tmp/tmpcv1piytr.d(31): Error: unterminated character constant

    /tmp/tmpcv1piytr.d(85): Error: unterminated string constant starting at /tmp/tmpcv1piytr.d(85)

    /tmp/tmpcv1piytr.d(95): Error: found `End of File` when expecting `,`

    /tmp/tmpcv1piytr.d(95): Error: found `End of File` when expecting `)`

    /tmp/tmpcv1piytr.d(95): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpcv1piytr.d(95): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpcv1piytr.d(95): Error: `}` expected following members in `class` declaration
    at /tmp/tmpcv1piytr.d(37)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcv1piytr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    if (l1.length != l2.length) {\n        throw new IllegalArgumentException();\n\
    \    }\n    final long[] l3 = new long[l1.length];\n    final long[] l4 = new\
    \ long[l1.length];\n    final long[] l5 = new long[l1.length];\n    for (int i\
    \ = 0; i < l1.length; i++) {\n        l3[i] = l1[i];\n        l4[i] = l2[i];\n\
    \    }\n    for (int i = 0; i < l1.length; ++i) {\n        for (int j = i + 1;\
    \ j < l1.length; ++j) {\n            if (l3[i] == l3[j]) {\n                l4[i]\
    \ = l4[i];\n                l4[j] = l4[j];\n            }\n        }\n    }\n\
    \    for (int i = 0; i < l1.length; ++i) {\n        for (int j = 0; j < l1.length;\
    \ ++j) {\n            if (l3[i] == l3[j]) {\n                l5[i] = l5[i];\n\
    \                l5[j] = l5[j];\n            }\n        }\n    }\n    int j =\
    \ 0;\n    for (int i = 0; i < l1.length; ++i) {\n        for (int k = 0; k < l1.length;\
    \ ++k) {\n            if (l3[i] > l3[k]) {\n                while (l4[k] > l4[i])\
    \ {\n                    ++j;\n                }\n            }\n        }\n \
    \   }\n    long[] ret = new long[Math.min(j, l1.length)];\n    for (int i = 0;\
    \ i < ret.length; ++i) {\n        ret[i] = l5[i];\n    }\n    return ret;\n}\n\
    /*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf_lqz8xy.d(56): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf_lqz8xy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] result = new long[64];\n\tfor (int i = 0; i < result.length; i++)\
    \ result[i] = 0;\n\tint i0 = 0;\n\tint i1 = 0;\n\tint i2 = 0;\n\tint i3 = 0;\n\
    \tint i4 = 0;\n\tint i5 = 0;\n\tint i6 = 0;\n\tint i7 = 0;\n\tint i8 = 0;\n\t\
    while (i1 < l1.length && i2 < l2.length) {\n\t\tint k = 0;\n\t\tif (l1[i0] <=\
    \ l2[i0]) {\n\t\t\tresult[i0] += 1;\n\t\t\ti1++;\n\t\t} else if (l1[i0] > l2[i0])\
    \ {\n\t\t\ti0++;\n\t\t\tresult[i0] = 1;\n\t\t}\n\t\tk = 1;\n\t\tif (i1 < l1.length)\
    \ {\n\t\t\tif (l1[i1] <= l2[i1]) {\n\t\t\t\tresult[k] += 1;\n\t\t\t\tk1++;\n\t\
    \t\t} else if (l1[i1] > l2[i1]) {\n\t\t\t\ti1++;\n\t\t\t\tresult[k] += 1;\n\t\t\
    \t}\n\t\t}\n\t\tif (i2 < l2.length) {\n\t\t\tif (l2[i2] <= l1[i2]) {\n\t\t\t\t\
    result[k] += 1;\n\t\t\t\tk2++;\n\t\t\t} else if (l2[i2] > l1[i2]) {\n\t\t\t\t\
    i2++;\n\t\t\t\tresult[k] += 1;\n\t\t\t}\n\t\t}\n\t}\n\twhile (i1 < l1.length)\
    \ {\n\t\tresult[i0] += 1;\n\t\ti1++;\n\t\ti0++;\n\t}\n\twhile (i2 < l2.length)\
    \ {\n\t\tresult[i0] += 1;\n\t\ti2++;\n\t\ti0++;\n\t}\n\twhile (i3 < result.length)\
    \ {\n\t\ti4 = i3;\n\t\twhile (k1 <= i4) {\n\t\t\ti5 = i4;\n\t\t\twhile (k2 <=\
    \ i5) {\n\t\t\t\tk = 0;\n\t\t\t\tif (result[i4] <= result[i5]) {\n\t\t\t\t\tresult[k]\
    \ += 1;\n\t\t\t\t\tk1++;\n\t\t\t\t} else if (result[i4] > result[i5]) {\n\t\t\t\
    \t\tresult[k] += 1;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\ti4++;\n\t\t\t\ti5++;\n\
    \t\t\t}\n\t\t\ti4++;\n\t\t}\n\t\ti3++;\n\t}\n\treturn result;\n}\n'''\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps09mbxc7.d(86): Error: unterminated character constant

    /tmp/tmps09mbxc7.d(86): Error: declaration expected, not `63U`

    /tmp/tmps09mbxc7.d(86): Error: unterminated character constant

    /tmp/tmps09mbxc7.d(91): Error: declaration expected, not `assert`

    /tmp/tmps09mbxc7.d(92): Error: declaration expected, not `assert`

    /tmp/tmps09mbxc7.d(93): Error: declaration expected, not `assert`

    /tmp/tmps09mbxc7.d(94): Error: declaration expected, not `assert`

    /tmp/tmps09mbxc7.d(95): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps09mbxc7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] res=new long[((l1.length==l2.length)&&(l1.length>=2)?l1.length:(l2.length>l1.length?l2.length:l1.length))];\n\
    \tstd.collections.sort(l1);\n\tstd.collections.sort(l2);\n\tint i=0;\n\tfor(int\
    \ j=0;j<l1.length;j++)\n\t{\n\t\tres[i++]=l1[j];\n\t}\n\tfor(int j=0;j<l2.length;j++)\n\
    \t{\n\t\tres[i++]=l2[j];\n\t}\n\t\n\treturn res;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp18fx8p7x.d(15): Error: undefined identifier `collections` in package
    `std`

    /tmp/tmp18fx8p7x.d(16): Error: undefined identifier `collections` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp18fx8p7x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\t/*\n\t\n\t\n\t\n\t*/\n\tint i = 0, j = 0;\n\tlong[] result = new long[l1.length];\n\
    \twhile (i < l1.length && j < l2.length) \n\t{\n\t\tif (l1[i] < l2[j]) \n\t\t\t\
    result[i] = l1[i++];\n\t\telse\n\t\t\tresult[j] = l2[j++];\n\t}\n\treturn result;\n\
    }\n/*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n    >>> common([],\
    \ [])\n    []\n    >>> common([], [1])\n    [1]\n*/\nlong[] common(long[] l1,\
    \ long[] l2, int length) \n{\n\t/*\n\t\n\t\n\t\n\t*/\n\tlong[] result = new long[length];\n\
    \tfor (int i = 0; i < (l1.length < l2.length ? l1.length : l2.length); i++) {\n\
    \t\tif (l1[i] < l2[i])\n\t\t\tresult[i] = l1[i];\n\t\telse\n\t\t\tresult[i] =\
    \ l2[i];\n\t}\n\treturn result;\n}\n/*\nReturn sorted unique common elements for\
    \ two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L,\
    \ 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L,\
    \ 2L])\n    [2L, 3L]\n    >>> common([], [])\n    []\n    >>> common([], [1])\n\
    \    [1]\n*/\nlong[] common(long[] l1, long[] l2, int length, int start) \n{\n\
    \t/*\n\t\n\t\n\t\n\t*/\n\tlong[] result = new long[length];\n\tfor (int i = 0;\
    \ i < (l1.length < l2.length ? l1.length : l2.length); i++) {\n\t\tif (l1[i] <\
    \ l2[i])\n\t\t\tresult[i] = l1[i];\n\t\telse\n\t\t\tresult[i] = l2[i];\n\t}\n\t\
    return result;\n}\n/*\nReturn sorted unique common elements for two arrays.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, \n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph3e2wvc8.d(84): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph3e2wvc8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] a = new long[l1.length];\n    for(int i = 0; i < l1.length;\
    \ i++) \n        a[i] = l1[i];\n    for(int i = 0; i < l2.length; i++) \n    \
    \    a[l1.length + i] = l2[i];\n    Arrays.sort(a);\n    return a;\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis is not the best answer.\n<|/ c |>\n<| c |>\n\
    : What makes you say that?\n<|/ c |>\n<| c |>\nThis is not the best answer as\
    \ it's not efficient. You're sorting all elements of the array. This can lead\
    \ to a very large amount of memory being used\n<|/ c |>\n<| a tags=algorithm,java,sorting\
    \ |>\nHere is a simple implementation in Python:\n<code>\ndef common(list1, list2):\n\
    \    s = set(list1) & set(list2)\n    return sorted(s)\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis is not the best answer. This will make a copy of the list\
    \ `list1` n times. This can lead to a very large amount of memory being used.\n\
    <|/ c |>\n<| c |>\nIf memory is concerned, you could write your own version which\
    \ is more efficient than others and will avoid making a copy, but of course it\
    \ would be better if someone did it for you!\n<|/ c |>\n<| c |>\nThe first line\
    \ is not necessary, you already have a set from the input lists. Also, list intersection\
    \ can be done with set subtraction\n<|/ c |>\n<| c |>\nNope. `set(list1) & set(list2)`\
    \ will return a set object containing the elements that are common to both lists.\
    \ You can't subtract a set from a set object. It does not work. Try it out in\
    \ python: `print set(['a'])-set(['a'])`. Try it out in ruby: `puts ['a']-['a']`\n\
    <|/ c |>\n<| c |>\nNo you can, it is called set subtraction: http://docs.python.org/library/stdtypes.html#set-types-set-frozenset\n\
    <|/ c |>\n<| a dscore=5 tags=algorithm,java,sorting |>\nFor anyone that uses Scala\
    \ or Kotlin, the other answers here have some good ideas that I'll point out here.\n\
    The Scala way:\n<code>\nval set1: Set[Int] = Set(1, 2, 3, 4, 5)\nval set2: Set[Int]\
    \ = Set(2, 3, 4)\nset1.intersect(set2)  // Set(2, 3)\n</code>\nIf you want a sorted\
    \ List, use:\n<code>\n\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm_a_2n0v.d(22): Error: declaration expected, not `<`

    /tmp/tmpm_a_2n0v.d(31): Error: unterminated character constant

    /tmp/tmpm_a_2n0v.d(31): Error: unterminated character constant

    /tmp/tmpm_a_2n0v.d(51): Error: unterminated character constant

    /tmp/tmpm_a_2n0v.d(57): Error: unterminated character constant

    /tmp/tmpm_a_2n0v.d(71): Error: declaration expected, not `assert`

    /tmp/tmpm_a_2n0v.d(72): Error: declaration expected, not `assert`

    /tmp/tmpm_a_2n0v.d(73): Error: declaration expected, not `assert`

    /tmp/tmpm_a_2n0v.d(74): Error: declaration expected, not `assert`

    /tmp/tmpm_a_2n0v.d(75): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm_a_2n0v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    System.arraycopy(l1, 0, l3, 0,\
    \ l1.length);\n    System.arraycopy(l2, 0, l3, l1.length, l2.length);\n    Arrays.sort(l3);\n\
    \    return l3;\n}\n/*\nReturn sorted unique common elements for two arrays.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb1beruj1.d(20): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb1beruj1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tint i, j;\n\tlong[] result = new long[l1.length + l2.length];\n\t\n\t\
    for (i = 0; i < result.length; ++i)\n\t{\n\t\tresult[i] = 0;\n\t}\n\t\n\tfor (i\
    \ = 0; i < l1.length; ++i)\n\t{\n\t\tfor (j = 0; j < l2.length; ++j)\n\t\t{\n\t\
    \t\tif (l1[i] == l2[j])\n\t\t\t{\n\t\t\t\tresult[i + j + 1]++;\n\t\t\t}\n\t\t\
    }\n\t}\n\t\n\tArrays.sort(result);\n\t\n\treturn result;\n}\n/*\n    \n*/\nclass\
    \ Set\n{\n\tpublic Set(int maxSize)\n\t{\n\t\tif (maxSize < 0)\n\t\t\tthrow new\
    \ IllegalArgumentException();\n\t\tthis.maxSize = maxSize;\n\t\tthis.data = new\
    \ long[maxSize];\n\t}\n\tpublic boolean add(long val)\n\t{\n\t\tif (val > maxSize\
    \ || val < 0)\n\t\t\tthrow new IllegalArgumentException();\n\t\t\n\t\tfor (int\
    \ i = 0; i < data.length; ++i)\n\t\t{\n\t\t\tif (data[i] == val)\n\t\t\t\treturn\
    \ false;\n\t\t}\n\t\t\n\t\tdata[data.length] = val;\n\t\t\n\t\treturn true;\n\t\
    }\n\tpublic boolean remove(long val)\n\t{\n\t\tif (val > maxSize || val < 0)\n\
    \t\t\tthrow new IllegalArgumentException();\n\t\t\n\t\tboolean removed = false;\n\
    \t\t\n\t\tfor (int i = 0; i < data.length; ++i)\n\t\t{\n\t\t\tif (data[i] == val)\n\
    \t\t\t{\n\t\t\t\tlong k = data[data.length - 1];\n\t\t\t\tdata[data.length - 1]\
    \ = 0;\n\t\t\t\tdata[data.length] = k;\n\t\t\t\t\n\t\t\t\t--data.length;\n\t\t\
    \t\t\n\t\t\t\tremoved = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn removed;\n\t}\n\
    \tpublic long getSize()\n\t{\n\t\treturn data.length;\n\t}\n\tpublic long[] getData()\n\
    \t{\n\t\treturn data;\n\t}\n\tprivate int maxSize;\n\tprivate long[] data;\n}\n\
    /*\n    \n*/\nclass Range\n{\n\tpublic int start;\n\tpublic int end;\n\tpublic\
    \ Range(int start, int end)\n\t{\n\t\tif (start < 0 || start > 1000)\n\t\t\tthrow\
    \ new IllegalArgumentException();\n\t\tif (end < start || end > 1000)\n\t\t\t\
    throw new IllegalArgumentException();\n\t\t\n\t\tthis.start = start;\n\t\tthis.end\
    \ = end;\n\t}\n\tpublic boolean intersects(Range r)\n\t{\n\t\tif (r.start > end\
    \ || r.end < start)\n\t\t\treturn false;\n\t\t\n\t\treturn (r.start <= end &&\
    \ r.end >= start);\n\t}\n\tpublic boolean contains(Range r)\n\t{\n\t\tif (r.start\
    \ > end || r.end < start)\n\t\t\treturn false;\n\t\t\n\t\treturn (r.start < end\
    \ && r.end > start);\n\t}\n\tpublic boolean contains(Range r, \nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9tjn44g0.d(42): Error: function declaration without return type.
    (Note that constructors are always named `this`)

    /tmp/tmp9tjn44g0.d(43): Error: no identifier for declarator `Set(int maxSize)`

    /tmp/tmp9tjn44g0.d(105): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp9tjn44g0.d(106): Error: no identifier for declarator `Range(int start,
    int end)`

    /tmp/tmp9tjn44g0.d(130): Error: basic type expected, not `unittest`

    /tmp/tmp9tjn44g0.d(130): Error: found `unittest` when expecting `)`

    /tmp/tmp9tjn44g0.d(139): Error: `}` expected following members in `class` declaration
    at /tmp/tmp9tjn44g0.d(101)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9tjn44g0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int i1=0;\n    int i2=0;\n    int i1t=0;\n    int i2t=0;\n    int i1r=0;\n\
    \    int i2r=0;\n    int i1l=0;\n    int i2l=0;\n    long[] a = new long[l1.length\
    \ + l2.length];\n    \n    while (i1<l1.length && i2<l2.length) \n    {\n    \
    \    if (l1[i1++]==l2[i2++]) \n        {\n            a[i1t++] = l1[i1r++];\n\
    \            a[i2t++] = l2[i2r++];\n        }\n        else if (l1[i1++]<l2[i2++])\n\
    \        {\n            a[i1l++] = l1[i1r++];\n        }\n        else\n     \
    \   {\n            a[i2l++] = l2[i2r++];\n        }\n    }\n    while (i1<l1.length)\
    \ \n    {\n        a[i1t++] = l1[i1r++];\n    }\n    while (i2<l2.length) \n \
    \   {\n        a[i2t++] = l2[i2r++];\n    }\n    while (i1r < l1.length) \n  \
    \  {\n        a[i1r++] = l1[i1l++];\n    }\n    while (i2r < l2.length) \n   \
    \ {\n        a[i2r++] = l2[i2l++];\n    }\n    while (i1l < l1.length) \n    {\n\
    \        a[i1l++] = l1[i1l++];\n    }\n    while (i2l < l2.length) \n    {\n \
    \       a[i2l++] = l2[i2l++];\n    }\n    \n    return a;\n}\n/*\nReturn sorted\
    \ unique common elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphchbnv7w.d(67): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphchbnv7w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    \n    long[] v = new long[64];\n    int i,j;\n    long common = 0;\n\
    \    \n    for(i=0;i<64;i++)\n    {\n        v[i] = 0;\n    }\n    \n    for(i=0;i<64;i++)\n\
    \    {\n        if(l1[i] != l2[i])\n        {\n            for(j=0;j<64;j++)\n\
    \            {\n                if((v1[j]&(1L<<i))==0)\n                {\n  \
    \                  v1[j]|=1L<<i;\n                    common++;\n            \
    \    }\n            }\n        }\n    }\n    return v;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbvyfxeb8.d(30): Error: undefined identifier `v1`, did you mean
    variable `v`?

    /tmp/tmpbvyfxeb8.d(32): Error: undefined identifier `v1`, did you mean variable
    `v`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbvyfxeb8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  int i1 = 0;\n  int i2 = 0;\n  int i1_len = l1.length;\n  int i2_len =\
    \ l2.length;\n  int i = 0;\n  long temp = 0;\n  long[] result;\n  \n  result =\
    \ new long[i1_len+i2_len];\n  \n  while (i1 < i1_len && i2 < i2_len) {\n    if\
    \ (l1[i1] == l2[i2]) {\n      result[i] = l1[i1];\n      i++;\n      i1++;\n \
    \     i2++;\n    } else if (l1[i1] < l2[i2]) {\n      i++;\n      i1++;\n    }\
    \ else {\n      result[i] = l2[i2];\n      i2++;\n    }\n  }\n  \n  if (i1 < i1_len)\
    \ {\n    System.arraycopy(l1,0,result, i, i1_len - i);\n  }\n  if (i2 < i2_len)\
    \ {\n    System.arraycopy(l2,0,result, i1_len + i, i2_len - i);\n  }\n  return\
    \ result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9x0bo2_7.d(16): Error: cannot implicitly convert expression `l1.length`
    of type `ulong` to `int`

    /tmp/tmp9x0bo2_7.d(17): Error: cannot implicitly convert expression `l2.length`
    of type `ulong` to `int`

    /tmp/tmp9x0bo2_7.d(40): Error: undefined identifier `System`

    /tmp/tmp9x0bo2_7.d(43): Error: undefined identifier `System`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9x0bo2_7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tif (l1.length == 0 || l2.length == 0) \n\t\treturn new long[0];\n\tif\
    \ (l1.length < l2.length)\n\t\tswap(l1, l2);\n\tlong[] l3 = new long[l1.length\
    \ + l2.length];\n\tl3.fill(0);\n\tfor (int i = 0; i < l1.length; i++) \n\t\tfor\
    \ (int j = 0; j < l2.length; j++) \n\t\t\tif (l1[i] == l2[j]) \n\t\t\t\tl3[i +\
    \ j + 1] = 1;\n\t\n\tlong[] result1 = new long[l1.length];\n\tfor (int i = 0;\
    \ i < l1.length; i++) \n\t\tif (l3[i] != 0) \n\t\t\tresult1[i] = l1[i];\n\tlong[]\
    \ result2 = new long[l2.length];\n\tfor (int i = 0; i < l2.length; i++) \n\t\t\
    if (l3[i + l1.length] != 0) \n\t\t\tresult2[i] = l2[i];\n\t\n\treturn result1.concat(result2);\n\
    }\n\"\"\"\n</cell>\n<text>\nThe above code assumes that you have the std package\
    \ installed.\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpphqixz9t.d(36): Error: declaration expected, not `""`

    /tmp/tmpphqixz9t.d(36): Error: unterminated string constant starting at /tmp/tmpphqixz9t.d(36)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpphqixz9t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tvar lc = new long[max(l1.length, l2.length)];\n\tint i = 0;\n\tint j\
    \ = 0;\n\t\n\tfor (; i < l1.length; i++)\n\t\tif (l1.get(i) == l2.get(j))\n\t\t\
    \tlc[i] = l1.get(i);\n\t\telse\n\t\t\tlc[i] = l1.get(i);\n\t\t\n\tfor (; j < l2.length;\
    \ j++)\n\t\tif (l2.get(j) == l1.get(i))\n\t\t\tlc[i] = l1.get(i);\n\t\telse\n\t\
    \t\tlc[i] = l1.get(i);\n\t\t\n\treturn lc;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7rftao5z.d(14): Error: undefined identifier `var`

    /tmp/tmp7rftao5z.d(14): Error: undefined identifier `max`, did you mean function
    `fmax`?

    /tmp/tmp7rftao5z.d(19): Error: template `object.get` cannot deduce function from
    argument types `!()(long[], int)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import/object.d(3094):        `object.get(K,
    V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/druntime/import/object.d(3100):        `object.get(K,
    V)(inout(V[K])* aa, K key, lazy inout(V) defaultValue)`

    /tmp/tmp7rftao5z.d(19): Error: template `object.get` cannot deduce function from
    argument types `!()(long[], int)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/..'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int[] in1 = sort(l1);\n    int[] in2 = sort(l2);\n    Arrays.sort(in1);\n\
    \    Arrays.sort(in2);\n    int i = 0;\n    int j = 0;\n    long[] result = new\
    \ long[in1.length];\n    while (i < in1.length && j < in2.length)\n    {\n   \
    \     if (in1[i] != in2[j])\n        {\n            result[result.length] = in1[i];\n\
    \            i++;\n        }\n        else\n        {\n            j++;\n    \
    \    }\n    }\n    while (i < in1.length)\n    {\n        result[result.length]\
    \ = in1[i];\n        i++;\n    }\n    while (j < in2.length)\n    {\n        result[result.length]\
    \ = in2[j];\n        j++;\n    }\n    return result;\n}\n</code>\n<|/ a tags=algorithm,performance,arrays,c#\
    \ dscore=3 |>\n<| c |>\n: I believe this is just as fast as the original O(n*log(n))\
    \ version. Both sort algorithms are O(n*log(n)).\n<|/ c |>\n<| c |>\nAren't you\
    \ still doing a O(n*log(n)) on both the sort function calls? I don't think you're\
    \ doing the same amount of work in each one.\n<|/ c |>\n<| c |>\nYes, you're right.\
    \  I meant to say that this version is still not O(n*log(n)).  Sorry.\n<|/ c |>\n\
    <| c |>\nI believe this is O(n), because you do no sorting after you know that\
    \ your two arrays intersect.\n<|/ c |>\n<| c |>\nIt's not O(n*log(n)) if you call\
    \ `sort()` twice on either array. You're doing O(nlogn) sorting for each array.\
    \ I've edited my answer to show you how to do this in one pass.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nI believe you can do it in O(n) if you use a single loop and\
    \ break when you find a match. This can be done in O(n) if you use two pointers,\
    \ one to go from one array and one to go from the other. The trick is to make\
    \ sure to only increment the second pointer if you haven't found a match yet.\
    \ Here's a little C# program to demonstrate:\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp72ohcj1j.d(45): Error: declaration expected, not `<`

    /tmp/tmp72ohcj1j.d(51): Error: unterminated character constant

    /tmp/tmp72ohcj1j.d(51): Error: unterminated character constant

    /tmp/tmp72ohcj1j.d(51): Error: unterminated character constant

    /tmp/tmp72ohcj1j.d(54): Error: unterminated character constant

    /tmp/tmp72ohcj1j.d(60): Error: unterminated character constant

    /tmp/tmp72ohcj1j.d(60): Error: unterminated character constant

    /tmp/tmp72ohcj1j.d(60): Error: unterminated character constant

    /tmp/tmp72ohcj1j.d(63): Error: unterminated character constant

    /tmp/tmp72ohcj1j.d(63): Error: unterminated character constant

    /tmp/tmp72ohcj1j.d(66): Error: semicolon expected, not `.`

    /tmp/tmp72ohcj1j.d(66): Error: no identifier for declarator `.Collections.Generic`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp72ohcj1j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] r = new long[l1.length];\n    int j = 0;\n    for (int i = 0;\
    \ i < l1.length; ++i) \n    {\n        while (l1[i] != l2[j] && (l1[i] < l2[j]))\n\
    \            j++;\n        if (l2[j] == l1[i]) \n        {\n            r[i] =\
    \ l2[j];\n            j++;\n        } \n        else \n            r[i] = l1[i];\n\
    \    }\n    return r;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmppdeaeusa.d(18): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428766]

    ??:? long[] tmppdeaeusa.common(long[], long[]) [0x427e8a]

    ??:? void tmppdeaeusa.__unittest_L30_C1() [0x4280db]

    ??:? void tmppdeaeusa.__modtest() [0x428434]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c76f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b602]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43088d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d3c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430819]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5d9]

    ??:? runModuleUnitTests [0x42c545]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functi'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tint[] id = new int[l1.length];\n\tsort(l1);\n\tsort(l2);\n\tint i = 0,\
    \ j = 0;\n\twhile (i < l1.length && j < l2.length) {\n\t\tif (l1[i] < l2[j]) {\n\
    \t\t\tid[i] = l1[i];\n\t\t\ti++;\n\t\t} else {\n\t\t\tid[j] = l2[j];\n\t\t\tj++;\n\
    \t\t}\n\t}\n\tif (i == l1.length) id[l1.length] = l2[j];\n\tif (j == l2.length)\
    \ id[l1.length] = l1[i];\n\tlong[] result = new long[id.length];\n\tfor (int k\
    \ = 0; k < id.length; k++) {\n\t\tresult[k] = id[k];\n\t}\n\treturn result;\n\
    }\n/*\nReturn the unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2lq8mg4l.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2lq8mg4l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  int m1 = l1.length;\n  int m2 = l2.length;\n  if (m1 == 0) \n    return\
    \ l2;\n  if (m2 == 0) \n    return l1;\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvpejgqor.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvpejgqor.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\nlong[] result = long[100];\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp10ovn54r.d(14): Error: found `[` when expecting `.` following long

    /tmp/tmp10ovn54r.d(14): Error: found `100` when expecting identifier following
    `long`.

    /tmp/tmp10ovn54r.d(14): Error: semicolon expected, not `]`

    /tmp/tmp10ovn54r.d(14): Error: found `]` instead of statement

    /tmp/tmp10ovn54r.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp10ovn54r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long common = 0, i = 0;\n    for (; i < l1.length && i < l2.length;\
    \ i++)\n        if (l1[i] == l2[i])\n            common++;\n    long [] l3 = new\
    \ long[common];\n    common = 0;\n    for (i = 0; i < l1.length && i < l2.length;\
    \ i++)\n        if (l1[i] == l2[i])\n            l3[common++] = l1[i];\n    return\
    \ l3;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmps764oq8h.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x42862d]

    ??:? void tmps764oq8h.__unittest_L25_C1() [0x4280b6]

    ??:? void tmps764oq8h.__modtest() [0x4283b0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6e7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b57a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430805]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cb4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430791]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b551]

    ??:? runModuleUnitTests [0x42c4bd]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428af0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int i = 0, j = 0;\n    int len1 = l1.length;\n    int len2 = l2.length;\n\
    \    int n = Math.min(len1, len2);\n    long[] a = new long[n];\n    while (i\
    \ < n && j < n) {\n        if (l1[i] == l2[j]) {\n            a[i] = l1[i];\n\
    \            i++;\n            j++;\n        } else if (l1[i] > l2[j]) {\n   \
    \         a[i] = l1[i];\n            i++;\n        } else {\n            a[j]\
    \ = l2[j];\n            j++;\n        }\n    }\n    return a;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppsj096km.d(15): Error: cannot implicitly convert expression `l1.length`
    of type `ulong` to `int`

    /tmp/tmppsj096km.d(16): Error: cannot implicitly convert expression `l2.length`
    of type `ulong` to `int`

    /tmp/tmppsj096km.d(17): Error: undefined identifier `Math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppsj096km.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    var result = new long[l1.Length];\n    var i=0;\n    while(i<l1.Length\
    \ && i<l2.Length)\n    {\n        if(l1[i] == l2[i])\n        {\n            result[i]\
    \ = l1[i];\n            i++;\n        }\n        else if(l1[i] > l2[i])\n    \
    \    {\n            i++;\n        }\n        else\n        {\n            i--;\n\
    \        }\n    }\n    while(i < l1.Length)\n    {\n        result[i] = l1[i];\n\
    \        i++;\n    }\n    while(i < l2.Length)\n    {\n        result[l1.Length]\
    \ = l2[i];\n        i++;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0\
    \ tags=algorithm,arrays,c# |>\n<| a dscore=0 |>\nOk, I think I found the solution,\
    \ which is to create two new arrays, one to hold all the common elements and then\
    \ another to hold the index of the unique elements. Here's the code:\n<code>\n\
    public static int[] common(int[] arr1, int[] arr2)\n{\n    int max1 = arr1.Length;\n\
    \    int max2 = arr2.Length;\n    int n = max1 + max2;\n    int [] i = new int[n];\n\
    \    int [] j = new int[n];\n    for (int i = 0; i < max1; i++)\n    {\n     \
    \   for (int j = 0; j < max2; j++)\n        {\n            if (arr1[i] == arr2[j])\n\
    \            {\n                i[n] = arr1[i];\n                j[n] = arr2[j];\n\
    \                n++;\n            }\n        }\n    }\n    Array.Sort(j);\n \
    \   Array.Sort(i);\n    return i;\n}\n</code>\n<|/ a tags=algorithm,arrays,c#\
    \ |>\n<| a dscore=0 |>\nFor large arrays, you may also want to avoid sorting.\
    \  Instead just use hashes.\n<code>\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6jvnpcfr.d(44): Error: declaration expected, not `<`

    /tmp/tmp6jvnpcfr.d(47): Error: unterminated character constant

    /tmp/tmp6jvnpcfr.d(56): Error: declaration expected, not `for`

    /tmp/tmp6jvnpcfr.d(56): Error: no identifier for declarator `i`

    /tmp/tmp6jvnpcfr.d(56): Error: declaration expected, not `<`

    /tmp/tmp6jvnpcfr.d(56): Error: no identifier for declarator `i`

    /tmp/tmp6jvnpcfr.d(56): Error: declaration expected, not `++`

    /tmp/tmp6jvnpcfr.d(58): Error: no identifier for declarator `j`

    /tmp/tmp6jvnpcfr.d(58): Error: declaration expected, not `<`

    /tmp/tmp6jvnpcfr.d(58): Error: no identifier for declarator `j`

    /tmp/tmp6jvnpcfr.d(58): Error: declaration expected, not `++`

    /tmp/tmp6jvnpcfr.d(63): Error: no identifier for declarator `j[n]`

    /tmp/tmp6jvnpcfr.d(63): Error: declaration expected, not `=`

    /tmp/tmp6jvnpcfr.d(64): Error: no identifier for declarator `n`

    /tmp/tmp6jvnpcfr.d(64): Error: declaration expected, not `++`

    /tmp/tmp6jvnpcfr.d(65): Error: unrecognized declaration

    Failed: ["dmd", "-unittes'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length];\n    int index = 0;\n    for(int\
    \ i=0; i<l1.length; i++)\n    {\n        if(l1[i] == l2[i]) continue;\n      \
    \  else \n        {\n            result[index++] = l1[i];\n        }\n    }\n\
    \    return std.Array.toList(result);\n}\n/*\nReturn a sorted unique common elements\
    \ between two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm1i4c7n1.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm1i4c7n1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long result = 0;\n    std.typecons.LongList l3 = std.typecons.LongList.new();\n\
    \    std.typecons.LongList l4 = std.typecons.LongList.new();\n    std.typecons.LongList\
    \ l5 = std.typecons.LongList.new();\n    for(int i = 0; i < l1.length; i++)\n\
    \    {\n        l3.add(l1[i]);\n        l4.add(l2[i]);\n        if(l3.exists(l4[l4.getLength()\
    \ - 1]))\n        {\n            l5.add(l1[i]);\n        }\n    }\n    for(int\
    \ i = 0; i < l2.length; i++)\n    {\n        if(!l5.exists(l2[i]))\n        {\n\
    \            l5.add(l2[i]);\n        }\n    }\n    for(int i = 0; i < l4.getLength();\
    \ i++)\n    {\n        result |= l5[i];\n    }\n    return std.array.subarray(l4.getLength()\
    \ - 1, l4.getLength()).getArray();\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx64lms6f.d(15): Error: basic type expected, not `;`

    /tmp/tmpx64lms6f.d(16): Error: basic type expected, not `;`

    /tmp/tmpx64lms6f.d(17): Error: basic type expected, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx64lms6f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length + l2.length];\nunittest\n{\n   \
    \ alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp984n74co.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp984n74co.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length + l2.length];\nunittest\n{\n   \
    \ alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp984n74co.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp984n74co.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length];\n    int[] ind1 = new int[l1.length];\n\
    \    int[] ind2 = new int[l2.length];\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg__oj6xo.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg__oj6xo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164045
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length + l2.length];\n    int i, j, k;\n  \
    \  long common_element = 0;\n    bool found_common_element = false;\n    int j1\
    \ = 0;\n    int j2 = 0;\n    \n    for (int i = 0; i < l1.length; ++i)\n    {\n\
    \        if (!found_common_element)\n        {\n            for (int j = 0; j\
    \ < l2.length; ++j)\n            {\n                if (l1[i] == l2[j])\n    \
    \            {\n                    common_element = l1[i];\n                \
    \    found_common_element = true;\n                    break;\n              \
    \  }\n            }\n        }\n        else\n        {\n            for (int\
    \ j = 0; j < l2.length; ++j)\n            {\n                if (l1[i] != l2[j]\
    \ && !found_common_element)\n                {\n                    common_element\
    \ = l1[i];\n                    found_common_element = true;\n               \
    \     break;\n                }\n            }\n        }\n        l3[i] = common_element;\n\
    \    }\n    \n    for (int i = 0; i < l2.length; ++i)\n    {\n        if (!found_common_element)\n\
    \        {\n            for (int j = 0; j < l1.length; ++j)\n            {\n \
    \               if (l2[i] == l1[j])\n                {\n                    common_element\
    \ = l2[i];\n                    found_common_element = true;\n               \
    \     break;\n                }\n            }\n        }\n        else\n    \
    \    {\n            for (int j = 0; j < l1.length; ++j)\n            {\n     \
    \           if (l2[i] != l1[j] && !found_common_element)\n                {\n\
    \                    common_element = l2[i];\n                    found_common_element\
    \ = true;\n                    break;\n                }\n            }\n    \
    \    }\n        l3[i + l1.length] = common_element;\n    }\n    \n    if (!found_common_element)\n\
    \    {\n        return l3;\n    }\n    \n    \n    for (int i = 0; i < l3.length;\
    \ i++)\n    {\n        if (l3[i] != 0)\n        {\n            for (int j = 0;\
    \ j < l3.length; j++)\n            {\n                if (j == i)\n          \
    \          l3[j] = 0;\n                else\n                    l3[j] = l3[j]\
    \ + l3[i];\n            }\n        }\n    }\n    return l3;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6wwuf16v.d(21): Error: variable `i` is shadowing variable `tmp6wwuf16v.common.i`

    /tmp/tmp6wwuf16v.d(25): Error: variable `j` is shadowing variable `tmp6wwuf16v.common.j`

    /tmp/tmp6wwuf16v.d(37): Error: variable `j` is shadowing variable `tmp6wwuf16v.common.j`

    /tmp/tmp6wwuf16v.d(50): Error: variable `i` is shadowing variable `tmp6wwuf16v.common.i`

    /tmp/tmp6wwuf16v.d(54): Error: variable `j` is shadowing variable `tmp6wwuf16v.common.j`

    /tmp/tmp6wwuf16v.d(66): Error: variable `j` is shadowing variable `tmp6wwuf16v.common.j`

    /tmp/tmp6wwuf16v.d(85): Error: variable `i` is shadowing variable `tmp6wwuf16v.common.i`

    /tmp/tmp6wwuf16v.d(89): Error: variable `j` is shadowing variable `tmp6wwuf16v.common.j`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6wwuf16v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long l=min(l1.length,l2.length);\n    long d=0;\n    long s=0;\n  \
    \  long[] r=new long[l];\n    for(int i=0; i<l; i++) \n    {\n        d=l1[i]-l2[i]+d;\n\
    \        s=l1[i]+s-l2[i]+s;\n        r[i]=s;\n    }\n    Arrays.sort(r);\n   \
    \ return r;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks so much for this.\
    \ It made my day :)\n<|/ c |>\n<| c |>\nI'm a big fan of sorting and using Arrays.binarySearch\
    \ to speed things up. Sorting is great for small numbers, but for big numbers\
    \ like yours it's unnecessarily slow.\n<|/ c |>\n<| c |>\nFor `l1 < l2 <= 1000000`\
    \ sorting is really fast and very efficient - `Arrays.sort` is really fast. With\
    \ `l1 < l2 <= 1000000` this solution takes 1.6 seconds whereas the `Arrays.binarySearch`\
    \ solution takes 1.7 seconds.\n<|/ c |>\n<| c |>\nAh yes, for very large sets,\
    \ you're right. I was going about it in a very roundabout way. You're right, if\
    \ you need to sort many items, binarySearch will help a lot.\n<|/ c |>\n<| a dscore=2\
    \ |>\nIf you don't have to worry about sorting and just have to find out common\
    \ elements between any two arrays, then you can simply use the following java\
    \ code.\n<code>\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0h9pxux9.d(27): Error: declaration expected, not `<`

    /tmp/tmp0h9pxux9.d(33): Error: unterminated character constant

    /tmp/tmp0h9pxux9.d(33): Error: unterminated character constant

    /tmp/tmp0h9pxux9.d(39): Error: unterminated character constant

    /tmp/tmp0h9pxux9.d(39): Error: unterminated character constant

    /tmp/tmp0h9pxux9.d(42): Error: unterminated character constant

    /tmp/tmp0h9pxux9.d(45): Error: identifier expected following `package`

    /tmp/tmp0h9pxux9.d(45): Error: `;` expected

    /tmp/tmp0h9pxux9.d(46): Error: identifier expected following `package`

    /tmp/tmp0h9pxux9.d(46): Error: `;` expected

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0h9pxux9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = (long[])null;\n    int n1 = l1.length;\n    int n2 = l2.length;\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_4r3k05f.d(14): Error: C style cast illegal, use `cast(long[])null`

    /tmp/tmp_4r3k05f.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_4r3k05f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long l=0, n=0;\n    int i;\n    for(i=0;i<l1.length;i++)\n    {\n \
    \       if(l1[i] == l2[i])\n        {\n            l++;\n        }\n        else\n\
    \        {\n            break;\n        }\n    }\n    if(l==l1.length)\n    {\n\
    \        n = 1;\n    }\n    long[] result = new long[l];\n    for(i=0;i<l;i++)\n\
    \    {\n        if(l1[i] == l2[i])\n        {\n            result[i] = l1[i];\n\
    \            n++;\n        }\n    }\n    while(n>0)\n    {\n        for(i=0;i<l;i++)\n\
    \        {\n            if(result[i] == l1[i])\n            {\n              \
    \  l--;\n                result.splice(i,1);\n                n--;\n         \
    \   }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqmrvsir1.d(54): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqmrvsir1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = null;\n    int l1 = l1.length;\n    int l2 = l2.length;\n\
    \    \n    if (l1 < l2) \n    {\n        result = l1;\n        \n    } \n    else\
    \ \n    {\n        result = l2;\n    }\n    \n    Arrays.sort(result);\n    \n\
    \    return result;\n}\n</code>\n<|/ a tags=arrays,java |>\n<| c |>\nThis is O(NlogN),\
    \ why don't you use the built-in `sort` method?\n<|/ c |>\n<| c |>\n, you are\
    \ right. I forgot the sort method. I edited the post.\n<|/ c |>\n<| c |>\n, why\
    \ not use the built-in sort method? Because I'm just doing it to show how it is\
    \ implemented in java. Of course you can implement your own sort algorithm if\
    \ you want.\n<|/ c |>\n<| c |>\nBut still, you have not implemented your own `sort`\
    \ method, so why do you keep suggesting it?\n<|/ c |>\n<| c |>\n, my bad. I read\
    \ too quickly the question. I edited the post to show how I would implement my\
    \ own sort algorithm.\n<|/ c |>\n<| a tags=arrays,java |>\n<code>\npublic long[]\
    \ common(long [] l1, long [] l2) \n{\n    long[] result = new long[l1.length];\n\
    \    int j=0;\n    for(int i=0;i<l1.length;i++) \n    {\n        for(int k=0;k<l2.length;k++)\
    \ \n        {\n            if(l1[i]==l2[k]) \n            {\n                result[j]=l1[i];\n\
    \                j++;\n            }\n        }\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThe accepted answer isn't very efficient.\
    \ Here's a solution that is O(N+M).\n<code>\npublic long[] common(long[] l1, long[]\
    \ l2)\n{\n    long[] result = new long[l1.length];\n    int resultIndex = 0;\n\
    \    int minCount = Math.max(l1.length, l2.length);\n    for (int i = 0; i < minCount;\
    \ i++) {\n        if (l1.length == l2.length) {\n            if (l1[i] == l2[i])\
    \ {\n                result[resultIndex++] = l1[i];\n            } else {\n  \
    \              result[resultIndex++] = l2[i];\n            }\n        } else if\
    \ (l1[i] > l2[i]) {\n            result[resultIndex++] = l1[i];\n        } else\
    \ {\n            result[resultIndex++] = l2[i];\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=arrays,java |>\n<| a |>\nA simple solution would\
    \ be something like this (though I \nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8a4exejq.d(32): Error: declaration expected, not `<`

    /tmp/tmp8a4exejq.d(35): Error: unterminated character constant

    /tmp/tmp8a4exejq.d(41): Error: unterminated character constant

    /tmp/tmp8a4exejq.d(55): Error: declaration expected, not `for`

    /tmp/tmp8a4exejq.d(55): Error: no identifier for declarator `i`

    /tmp/tmp8a4exejq.d(55): Error: declaration expected, not `<`

    /tmp/tmp8a4exejq.d(55): Error: no identifier for declarator `i`

    /tmp/tmp8a4exejq.d(55): Error: declaration expected, not `++`

    /tmp/tmp8a4exejq.d(57): Error: no identifier for declarator `k`

    /tmp/tmp8a4exejq.d(57): Error: declaration expected, not `<`

    /tmp/tmp8a4exejq.d(57): Error: no identifier for declarator `k`

    /tmp/tmp8a4exejq.d(57): Error: declaration expected, not `++`

    /tmp/tmp8a4exejq.d(62): Error: no identifier for declarator `j`

    /tmp/tmp8a4exejq.d(62): Error: declaration expected, not `++`

    /tmp/tmp8a4exejq.d(63): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8a4exejq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  long i=0, j=0;\n  while ((j<l2.length) && (i<l1.length)) \n  {\n    if\
    \ (l1[i]<l2[j])\n      j++;\n    else if (l1[i]>l2[j])\n      i++;\n    else \n\
    \      i++; j++;\n  }\n  if (j==l2.length)\n    return l1;\n  else if (i==l1.length)\n\
    \    return l2;\n  else {\n    long[] ret = new long[l2.length];\n    System.arraycopy(l2,\
    \ 0, ret, 0, j);\n    System.arraycopy(l1, i, ret, j, l2.length-i);\n    return\
    \ ret;\n  }\n}\n</code>\n<|/ a tags=c,c++,arrays,algorithm |>\n<| c |>\nNice one\
    \ thanks for the great answer! I ran it and it turns out that the common method\
    \ you wrote is slightly faster! I wonder why this is the case. Maybe the overhead\
    \ of the virtual function calls and method calls. I'll keep looking.\n<|/ c |>\n\
    <| c |>\nAm I correct that the sorting method can not be faster than the intersect\
    \ method because the sort method is sorting the array while the intersect method\
    \ is just intersecting arrays?\n<|/ c |>\n<| a tags=c,c++,arrays,algorithm |>\n\
    The question is tagged as C/C++ and I'm assuming you are looking for efficiency\
    \ in terms of speed, and not space as you say, so I'd go for a solution in O(nlogn)\
    \ time complexity.\nWhat I did was sort the array in O(nlogn) time and then use\
    \ binary search to find the index of the first element that is equal to each element\
    \ in the second array. \nIn C# code, I sort the arrays in O(nlogn) time and then\
    \ use binary search to find the index of the first element that is equal to each\
    \ element in the second array:\n<code>\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuf0edc1k.d(35): Error: declaration expected, not `<`

    /tmp/tmpuf0edc1k.d(38): Error: unterminated character constant

    /tmp/tmpuf0edc1k.d(44): Error: unterminated character constant

    /tmp/tmpuf0edc1k.d(44): Error: unterminated character constant

    /tmp/tmpuf0edc1k.d(52): Error: declaration expected, not `assert`

    /tmp/tmpuf0edc1k.d(53): Error: declaration expected, not `assert`

    /tmp/tmpuf0edc1k.d(54): Error: declaration expected, not `assert`

    /tmp/tmpuf0edc1k.d(55): Error: declaration expected, not `assert`

    /tmp/tmpuf0edc1k.d(56): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuf0edc1k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] a = new long[64];\n    long[] b = new long[64];\n    int n =\
    \ 0;\n    \n    int n1 = a1.length;\n    int n2 = a2.length;\n    \n    for(int\
    \ i = 0; i < n1 && i < n2;i++)\n    {\n        a[i] = a1[i];\n        b[i] = a2[i];\n\
    \        n++;\n    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprbnrxtip.d(27): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprbnrxtip.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length + l2.length];\n    int j = 0;\n   \
    \ for (int i = 0; i < l1.length; i++) {\n        boolean in = false;\n       \
    \ for (int k = 0; k < l2.length; k++) {\n            if (l1[i] == l2[k]) {\n \
    \               in = true;\n                break;\n            }\n        }\n\
    \        if (!in) {\n            res[j++] = l1[i];\n        }\n    }\n    Arrays.sort(res);\n\
    \    return res;\n}\n</code>\nThe above algorithm runs in O(n+m).\n<|/ a dscore=0\
    \ tags=sorting,arrays,algorithm |>\n<| a dscore=0 |>\n<code>\nimport java.util.Arrays;\n\
    import java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\
    import java.util.TreeSet;\nimport java.util.concurrent.ConcurrentSkipListSet;\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8siwx3jm.d(17): Error: expression expected, not `=`

    /tmp/tmp8siwx3jm.d(17): Error: found `false` when expecting `;` following statement

    /tmp/tmp8siwx3jm.d(17): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp8siwx3jm.d(20): Error: found `in` instead of statement

    /tmp/tmp8siwx3jm.d(24): Error: expression expected, not `in`

    /tmp/tmp8siwx3jm.d(31): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8siwx3jm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int l1=0;\n    int l2=0;\n    int len1=l1.length;\n    int len2=l2.length;\n\
    \    int[] t1=new int[len1];\n    int[] t2=new int[len2];\n    int i;\n    while(l1<len1\
    \ && l2<len2)\n    {\n        if(l1[l1]==l2[l2])\n        {\n            t1[l1]++;\n\
    \            t2[l2]++;\n        }\n        else\n        {\n            if((l1[l1]<l2[l2])\
    \ || (l1[l1]==l2[l2] && t1[l1]>t2[l2]))\n            {\n                t1[l1]=1;\n\
    \                t2[l2]=1;\n            }\n        }\n        l1++;\n        l2++;\n\
    \    }\n    int k=0;\n    while(len1!=0) \n    {\n        if(t1[0]==len2)\n  \
    \      {\n            k++;\n        }\n        else\n        {\n            len1--;\n\
    \        }\n    }\n    if(k>0)\n    {\n        long[] ret = new long[k];\n   \
    \     int i1;\n        int i2;\n        int j;\n        for(i1=0; i1<k; i1++)\n\
    \        {\n            ret[i1]=l1[i1];\n        }\n        for(i1=0; i1<k; i1++)\n\
    \        {\n            for(j=0; j<len2; j++)\n            {\n               \
    \ if(t2[j]==0) continue;\n                else\n                {\n          \
    \          i2=0;\n                    while(j<t2[j])\n                    {\n\
    \                        i2+=t1[i2];\n                        if(t2[len2-t2[j]]==0)\n\
    \                        {\n                            break;\n             \
    \           }\n                        i2++;\n                    }\n        \
    \            ret[i1]=ret[i1]+t2[len2-t2[j]];\n                    t2[len2-t2[j]]--;\n\
    \                }\n            }\n            if(i2==len2)\n            {\n \
    \               k--;\n            }\n        }\n        for(i1=0; i1<k; i1++)\n\
    \        {\n            ret[i1]/=len2;\n        }\n        return ret;\n    }\n\
    \    return null;\n}\n/*\nReturn sorted unique common elements for two arrays.\n\
    \    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n\
    \    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi53ofdps.d(95): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi53ofdps.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] unique = new long[l1.length + l2.length]; \n    \n    int l\
    \ = 0;\n    for (int i = 0; i < l1.length; ++i)\n    {\n        int j = 0;\n \
    \       for (; j < l2.length && l2[j] == l1[i]; ++j);\n        if (j == l2.length)\n\
    \        {\n            unique[l++] = l1[i];\n        }\n    }\n    for (int i\
    \ = 0; i < l2.length; ++i)\n    {\n        int j = 0;\n        for (; j < l1.length\
    \ && l1[j] == l2[i]; ++j);\n        if (j == l1.length)\n        {\n         \
    \   unique[l++] = l2[i];\n        }\n    }\n    unique = unique(unique);\n   \
    \ return unique;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaa7jgbf6.d(20): Error: use `{ }` for an empty statement, not `;`

    /tmp/tmpaa7jgbf6.d(29): Error: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaa7jgbf6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] common = new long[Math.max(l1.length, l2.length)];\n\t\n\tfor\
    \ (int i=0; i<Math.min(l1.length, l2.length); i++) {\n\t\tif (l1[i] == l2[i])\
    \ \n\t\t\tcommon[i] = l1[i];\n\t}\n\t\n\tint j1 = 0, j2 = 0, found = 0, k = 0;\n\
    \twhile (j < common.length) {\n\t\twhile (j1 < l1.length && j2 < l2.length &&\
    \ common[j1] == l1[j1] && common[j2] == l2[j2]) {\n\t\t\tj1++;\n\t\t\tj2++;\n\t\
    \t\tfound++;\n\t\t}\n\t\tif (j1 == l1.length) {\n\t\t\tbreak;\n\t\t}\n\t\tif (j2\
    \ == l2.length) {\n\t\t\tbreak;\n\t\t}\n\t\tif (found == l1.length) {\n\t\t\t\
    common[k] = l2[j2];\n\t\t\tk++;\n\t\t\tj2++;\n\t\t\tfound++;\n\t\t} else if (found\
    \ == l2.length) {\n\t\t\tcommon[k] = l1[j1];\n\t\t\tk++;\n\t\t\tj1++;\n\t\t\t\
    found++;\n\t\t} else {\n\t\t\tcommon[k] = Math.max(common[k-1], l1[j1]);\n\t\t\
    \tk++;\n\t\t}\n\t}\n\t\n\treturn common;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgvx9za9s.d(14): Error: undefined identifier `Math`

    /tmp/tmpgvx9za9s.d(16): Error: undefined identifier `Math`

    /tmp/tmpgvx9za9s.d(22): Error: undefined identifier `j`

    /tmp/tmpgvx9za9s.d(45): Error: undefined identifier `Math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgvx9za9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    List<long> l3= new List<long>();\n    for (long l : l1)\n    {\n  \
    \      for (long l2 : l2)\n        {\n            if (l==l2)\n            {\n\
    \                l3.add(l);\n                break;\n            }\n        }\n\
    \    }\n    return l3.toArray(new long[l3.size()]);\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nPlease note that \"common\" is not unique in general, it just happens\
    \ to be the most common solution in languages that do support it.\n<|/ c |>\n\
    <| a dscore=1 |>\nI came up with the following solution:\n<code>\npublic class\
    \ ArrayUtils {\n    public static <T> void intersect(T[] a, T[] b, T[] c) {\n\
    \        Arrays.sort(a);\n        Arrays.sort(b);\n        Arrays.sort(c);\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw6tybh5z.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmpw6tybh5z.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmpw6tybh5z.d(14): Error: found `(` when expecting identifier following `long`.

    /tmp/tmpw6tybh5z.d(14): Error: found `)` when expecting `;` following statement

    /tmp/tmpw6tybh5z.d(14): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpw6tybh5z.d(15): Error: semicolon expected, not `:`

    /tmp/tmpw6tybh5z.d(15): Error: expression expected, not `:`

    /tmp/tmpw6tybh5z.d(15): Error: found `l1` when expecting `;` following `for` condition

    /tmp/tmpw6tybh5z.d(17): Error: semicolon expected, not `:`

    /tmp/tmpw6tybh5z.d(17): Error: expression expected, not `:`

    /tmp/tmpw6tybh5z.d(17): Error: found `l2` when expecting `;` following `for` condition

    /tmp/tmpw6tybh5z.d(28): Error: declaration expected, not `<`

    /tmp/tmpw6tybh5z.d(39): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpw6tybh5z.d(39): Error: no i'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[l1.length];\n    int j = 0;\n    for(int i =\
    \ 0; i < l1.length; i++) {\n        long a = l1[i];\n        for(int j = 0; j\
    \ < l2.length; j++) {\n            long b = l2[j];\n            if(a == b) break;\n\
    \            if(a < b)\n                break;\n        }\n        if(j == l2.length)\
    \ ret[j++] = a;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbx_i97tq.d(18): Error: variable `j` is shadowing variable `tmpbx_i97tq.common.j`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbx_i97tq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  if (l1 == null && l2 == null)\n    return null;\n  if (l1 == null)\n\
    \    return l2;\n  if (l2 == null)\n    return l1;\n  long[] result = null;\n\
    \  long[] l3 = new long[l1.length + l2.length];\n  System.arraycopy(l1, 0, l3,\
    \ 0, l1.length);\n  System.arraycopy(l2, 0, l3, l1.length, l2.length);\n  l3[l3.length\
    \ - 1] = 0;\n  result = new long[l3.length];\n  long[] l4 = new long[l3.length];\n\
    \  Arrays.sort(l3);\n  Arrays.sort(l4);\n  int i = 0;\n  int j = 0;\n  while (i\
    \ < l3.length && j < l4.length) {\n    if (l3[i] != l4[j]) {\n      result[j]\
    \ = l3[i];\n      j++;\n    } else {\n      i++;\n    }\n  }\n  result[j] = l3[i];\n\
    \  Arrays.sort(result);\n  return result;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5d12jhvu.d(22): Error: undefined identifier `System`

    /tmp/tmp5d12jhvu.d(23): Error: undefined identifier `System`

    /tmp/tmp5d12jhvu.d(27): Error: undefined identifier `Arrays`

    /tmp/tmp5d12jhvu.d(28): Error: undefined identifier `Arrays`

    /tmp/tmp5d12jhvu.d(40): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5d12jhvu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    if(l1.length != l2.length) throw new Exception(\"Array lengths must\
    \ match\");\n    long maxLength = 0;\n    int maxLen = 0;\n    for(int i = 0;\
    \ i < l1.length; i++) \n    {\n        if(l1[i] > maxLength) \n        {\n   \
    \         maxLength = l1[i];\n            maxLen = i;\n        }\n    }\n    for(int\
    \ i = 0; i < l2.length; i++) \n    {\n        if(l2[i] > maxLength) \n       \
    \ {\n            maxLength = l2[i];\n            maxLen = i;\n        }\n    }\n\
    \    long[] common = new long[maxLen + 1];\n    int commonCount = 0;\n    for(int\
    \ i = 0; i < l1.length; i++) \n    {\n        for(int j = 0; j < l2.length; j++)\
    \ \n        {\n            if(l1[i] == l2[j] && i != j) \n            {\n    \
    \            common[commonCount] = l1[i];\n                commonCount++;\n  \
    \          }\n        }\n    }\n    Arrays.sort(common);\n    return common;\n\
    }\n/*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5bsmcq9w.d(49): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5bsmcq9w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tvar i1 = 0, i2 = 0;\n\tlong[] common = new long[l1.length];\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppc53izt8.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppc53izt8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int i,j;\n    long[] a = new long[l1.length + l2.length];\n    System.arraycopy(l1,\
    \ 0, a, 0, l1.length);\n    System.arraycopy(l2, 0, a, l1.length, l2.length);\n\
    \    i=j=0;\n    while (i<a.length && j<a.length) {\n        if (a[i] < a[j])\n\
    \        {\n            a[i] = a[j];\n            i++;\n            j++;\n   \
    \     }\n        else if (a[i] > a[j])\n        {\n            a[j] = a[i];\n\
    \            j++;\n        }\n        else j++;\n    }\n    return a;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa54ftpjz.d(16): Error: undefined identifier `System`

    /tmp/tmpa54ftpjz.d(17): Error: undefined identifier `System`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa54ftpjz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long i, i1, i2, j;\n    long[] result = new long[l1.length];\n    i1\
    \ = 0;\n    i2 = l1.length - 1;\n    while(i1 <= i2)\n    {\n        i = (i1 +\
    \ i2)/2;\n        if(l1[i] < l2[i])\n        {\n            j = i1;\n        \
    \    i1 = i + 1;\n        }\n        else\n        {\n            j = i2;\n  \
    \          i2 = i - 1;\n        }\n        if(l1[i] == l2[j])\n        {\n   \
    \         result[i] = l1[i - 1];\n            i++;\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=3 tags=java,algorithm |>\n<| a tags=java,algorithm\
    \ |>\nThe solution by Jon Skeet is correct, but it's O(n2) so I suggest using\
    \ Collections.sort with the comparator provided by:\n<code>\nstatic class CompareByFirst\n\
    {\n    public int compare(Object o1, Object o2)\n    {\n        if (o1 == null\
    \ && o2 == null)\n            return 0;\n        if (o1 == null)\n           \
    \ return -1;\n        if (o2 == null)\n            return 1;\n        return ((Comparable)o1).compareTo(o2);\n\
    \    }\n}\n</code>\nThis way you can get a O(n) solution.\n<|/ a dscore=3 |>\n\
    <| c |>\nThanks, that's much nicer solution.\n<|/ c |>\n<| c |>\nI agree, this\
    \ solution seems cleaner.\n<|/ c |>\n<| a tags=java,algorithm |>\nThe answer by\
    \ Jon Skeet is correct, but it's O(n2) so I suggest using Collections.sort with\
    \ the comparator provided by:\n<code>\nstatic class CompareByFirst\n{\n    public\
    \ int compare(Object o1, Object o2)\n    {\n        if (o1 == null && o2 == null)\n\
    \            return 0;\n        if (o1 == null)\n            return -1;\n    \
    \    if (o2 == null)\n            return 1;\n        return ((Comparable)o1).compareTo(o2);\n\
    \    }\n}\n</code>\nThis way you can get a O(n) solution.\n<|/ a dscore=3 |>\n\
    <| a |>\nThe complexity of the most popular answer (Jon Skeet) is O(n2), which\
    \ can be improved to O(n), by using a sort with a custom comparator.\n<code>\n\
    public static void main(String... args) {\n    List<Integer> list1 = new ArrayList<>();\n\
    \    List<Integer> list2 = new ArrayList<>();\n    for (int i = 0; i < 10000;\
    \ i++) {\n        list1.add(i % 5);\n        list2.add(i % 7);\n    }\n    Collections.sort(list1,\
    \ new Comparator<Integer>() {\n        public int compare(Integer o1, \nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmec64ok_.d(39): Error: declaration expected, not `<`

    /tmp/tmpmec64ok_.d(42): Error: unterminated character constant

    /tmp/tmpmec64ok_.d(50): Error: declaration expected, not `if`

    /tmp/tmpmec64ok_.d(52): Error: declaration expected, not `if`

    /tmp/tmpmec64ok_.d(54): Error: declaration expected, not `return`

    /tmp/tmpmec64ok_.d(55): Error: unrecognized declaration

    /tmp/tmpmec64ok_.d(61): Error: unterminated character constant

    /tmp/tmpmec64ok_.d(67): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmec64ok_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    var a = l1;\n    var b = l2;\n    var len = Math.min(a.length, b.length);\n\
    \    var ans = new long[len];\n    \n    for(int i = 0; i < len; ++i)\n      \
    \  ans[i] = a[i] == b[i] ? a[i] : 0;\n    \n    Arrays.sort(ans);\n    return\
    \ ans;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphsil404p.d(14): Error: undefined identifier `var`

    /tmp/tmphsil404p.d(15): Error: undefined identifier `var`

    /tmp/tmphsil404p.d(16): Error: undefined identifier `var`

    /tmp/tmphsil404p.d(16): Error: undefined identifier `Math`

    /tmp/tmphsil404p.d(17): Error: undefined identifier `var`

    /tmp/tmphsil404p.d(22): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphsil404p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] result = new long[l1.length + l2.length];\n\tint i = 0;\n\tfor(int\
    \ i1 = 0, i2 = 0; i1 < l1.length; i1++, i2++)\n\t{\n\t\tif(i2 < l2.length)\n\t\
    \t{\n\t\t\tif(i1 < l2.length)\n\t\t\t{\n\t\t\t\tif(l1[i1] == l2[i2])\n\t\t\t\t\
    \tresult[i] = l1[i1];\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tresult[i]\
    \ = l1[i1];\n\t\t\t\t\tresult[i+1] = l2[i2];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\
    \t\t\t\tresult[i] = l1[i1];\n\t\t}\n\t\telse\n\t\t\tresult[i] = l1[i1];\n\t}\n\
    \treturn result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpergeicwp.d(43): unittest failure

    ----------------

    ??:? _d_unittestp [0x42871d]

    ??:? void tmpergeicwp.__unittest_L39_C1() [0x4281a6]

    ??:? void tmpergeicwp.__modtest() [0x4284a0]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7d7]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b66a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308f5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430da4]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430881]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b641]

    ??:? runModuleUnitTests [0x42c5ad]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tint i = 0;\n\tint j = 0;\n\tlong[] result = null;\n\tlong v = 0;\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6bp5od_4.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6bp5od_4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] a1 = sort(l1);\n\tlong[] a2 = sort(l2);\n\tint i = 0;\n\tint j\
    \ = 0;\n\twhile (i<(a1.length) && j<(a2.length))\n\t{\n\t\tif (a1[i] == a2[j])\n\
    \t\t{\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\telse if (a1[i] < a2[j])\n\t\t{\n\t\t\
    \ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tj++;\n\t\t}\n\t}\n\treturn new long[j];\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9v7gho7g.d(14): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp9v7gho7g.d(15): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9v7gho7g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] r = new long[l1.length + l2.length];\n    sort(l1, l2);\n  \
    \  merge(mergeSort(l1), mergeSort(l2), r);\n    return r;\n}\n/*\n    Merge sort\
    \ a sorted array\n    http://www.hackerearth.com/practice/algorithms/sorting/merge-sort/\n\
    */\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1q2ec8m_.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp1q2ec8m_.d(16): Error: undefined identifier `merge`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1q2ec8m_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    final int n = l1.length + l2.length;\n    long[] u1 = new long[n];\n\
    \    long[] u2 = new long[n];\n    System.arraycopy(l1, 0, u1, 0, l1.length);\n\
    \    System.arraycopy(l2, 0, u2, l1.length, l2.length);\n    Arrays.sort(u1);\n\
    \    Arrays.sort(u2);\n    long[] u = new long[l1.length + l2.length];\n    System.arraycopy(u1,\
    \ 0, u, 0, l1.length);\n    System.arraycopy(u2, 0, u, l1.length, l2.length);\n\
    \    return u;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2lwktu3g.d(14): Error: variable `tmp2lwktu3g.common.n` cannot be
    `final`, perhaps you meant `const`?

    /tmp/tmp2lwktu3g.d(14): Error: cannot implicitly convert expression `l1.length
    + l2.length` of type `ulong` to `int`

    /tmp/tmp2lwktu3g.d(17): Error: undefined identifier `System`

    /tmp/tmp2lwktu3g.d(18): Error: undefined identifier `System`

    /tmp/tmp2lwktu3g.d(19): Error: undefined identifier `Arrays`

    /tmp/tmp2lwktu3g.d(20): Error: undefined identifier `Arrays`

    /tmp/tmp2lwktu3g.d(22): Error: undefined identifier `System`

    /tmp/tmp2lwktu3g.d(23): Error: undefined identifier `System`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2lwktu3g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] c = new long[l1.length];\n    for (int i = 0; i < l1.length;\
    \ i++) {\n        if ((l1[c.length - 1 - i] == l1[i]) && (l2[c.length - 1 - i]\
    \ == l2[i])) {\n            c[c.length - 1 - i]++;\n        }\n    }\n    \n \
    \   for (int i = 0; i < l1.length; i++) {\n        if ((l1[c.length - 1 - i] ==\
    \ l1[i]) && (l2[c.length - 1 - i] == l2[i])) {\n            c[c.length - 1 - i]++;\n\
    \        }\n    }\n    \n    for (int i = 0; i < l1.length; i++) {\n        if\
    \ ((l1[c.length - 1 - i] == l1[i]) && (l2[c.length - 1 - i] == l2[i])) {\n   \
    \         c[c.length - 1 - i]++;\n        }\n    }\n    return c;\n}\n/*\nReturn\
    \ sorted unique common elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L,\
    \ 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>>\
    \ common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_jzlifhx.d(34): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_jzlifhx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] c = new long[l1.length + l2.length];\n    for(int i = 0; i <\
    \ l1.length; ++i)\n        c[i] = l1[i];\n    for(int i = 0; i < l2.length; ++i)\n\
    \        c[i + l1.length] = l2[i];\n    sort(c);\n    for(int i = 0; i < l1.length\
    \ + l2.length; ++i) {\n        if(c[i] == c[i + l1.length])\n            delete(c[i]);\n\
    \    }\n    return c;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm68acpt4.d(19): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpm68acpt4.d(22): Deprecation: The `delete` keyword has been deprecated.  Use
    `object.destroy()` (and `core.memory.GC.free()` if applicable) instead.

    /tmp/tmpm68acpt4.d(22): Error: cannot delete type `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm68acpt4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\t// TODO: replace with sorting and then unique\n\tlong[] sorted1 = sortOn(l1);\n\
    \tlong[] sorted2 = sortOn(l2);\n\t\n\tlong[] result1 = new long[sorted1.length];\n\
    \tlong[] result2 = new long[sorted2.length];\n\tint i = 0;\n\tint j = 0;\n\t\n\
    \twhile (i < sorted1.length && j < sorted2.length) {\n\t\tif (sorted1[i] == sorted2[j])\n\
    \t\t\tresult1[i] = sorted1[i];\n\t\ti++;\n\t\tj++;\n\t}\n\t\n\twhile (i < sorted1.length)\n\
    \t\tresult1[i] = sorted1[i];\n\t\n\twhile (j < sorted2.length)\n\t\tresult2[j]\
    \ = sorted2[j];\n\t\n\treturn result1;\n}\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7zw5fh0n.d(15): Error: undefined identifier `sortOn`

    /tmp/tmp7zw5fh0n.d(16): Error: undefined identifier `sortOn`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7zw5fh0n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] r1 = new long[l1.length];\n    long[] r2 = new long[l2.length];\n\
    \    long[] r3 = new long[l1.length];\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgmwn7ecx.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgmwn7ecx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long common=0;\n    for(int i=0;i<l1.length;i++)\n    {\n        for(int\
    \ j=0;j<l2.length;j++)\n        {\n            if(l1[i]==l2[j])\n            {\n\
    \                common++;\n                break;\n            }\n        }\n\
    \    }\n    long[] result=new long[common];\n    for(int i=0;i<common;i++)\n \
    \   {\n        result[i]=l1[i];\n    }\n    return result;\n}\n/*\nReturn sorted\
    \ unique common elements for two arrays of strings\n    >>> common({\"a\",\"b\"\
    ,\"c\",\"d\",\"e\",\"f\",\"g\"}, {\"a\",\"f\",\"c\",\"e\",\"b\",\"g\"})\n    [\"\
    a\", \"f\", \"c\", \"b\", \"e\"]\n    >>> common({\"a\",\"b\",\"c\",\"d\",\"e\"\
    ,\"f\",\"g\"}, {\"a\",\"f\",\"c\",\"e\",\"b\",\"g\",\"x\"})\n    [\"a\", \"f\"\
    , \"c\", \"b\", \"e\"]\n    \n    \n    \n*/\nString common(String l1, String\
    \ l2) \n{\n    String common=\"\";\n    for(int i=0;i<l1.length();i++)\n    {\n\
    \        for(int j=0;j<l2.length();j++)\n        {\n            if(l1.charAt(i)==l2.charAt(j))\n\
    \            {\n                common+=l1.charAt(i);\n                break;\n\
    \            }\n        }\n    }\n    return common;\n}\n/*\nReturn sorted unique\
    \ common elements for two arrays of strings\n    >>> common([\"a\",\"b\",\"c\"\
    ,\"d\",\"e\",\"f\",\"g\"], [\"a\",\"f\",\"c\",\"e\",\"b\",\"g\"])\n    [\"a\"\
    , \"f\", \"c\", \"b\", \"e\"]\n    >>> common([\"a\",\"b\",\"c\",\"d\",\"e\",\"\
    f\",\"g\"], [\"a\",\"f\",\"c\",\"e\",\"b\",\"g\",\"x\"])\n    [\"a\", \"f\", \"\
    c\", \"b\", \"e\"]\n    \n    \n    \n*/\nString common(String[]l1, String[]l2)\
    \ \n{\n    String common=\"\";\n    for(int i=0;i<l1.length;i++)\n    {\n    \
    \    for(int j=0;j<l2.length;j++)\n        {\n            if(l1[i]==l2[j])\n \
    \           {\n                common+=l1[i];\n                break;\n      \
    \      }\n        }\n    }\n    return common;\n}\n/*\nReturn sorted unique common\
    \ elements for two arrays of strings\n    >>> common([[\"x\",\"a\"],[\"y\",\"\
    c\"],[\"z\",\"e\"]], [[\"x\",\"a\"],[\"y\",\"c\"],[\"z\",\"e\"]])\n    [[\"x\"\
    , \"a\"], [\"y\", \"c\"], [\"z\", \"\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpckztxmar.d(85): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpckztxmar.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int minLen = min.length(l1, l2);\n    long[] c = new long[minLen];\n\
    \    int i = 0;\n    for (; i < minLen; ++i)\n        c[i] = 0;\n    for (; i\
    \ < minLen && l1[i] != l2[i]; ++i)\n        c[i] = l1[i];\n    for (; i < minLen;\
    \ ++i)\n        c[i] = 0;\n    return c;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1nantrg8.d(14): Error: undefined identifier `min`, did you mean
    function `main`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1nantrg8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    if(l1 == null)\n        return l2;\n    if(l2 == null)\n        return\
    \ l1;\n    int l1 = l1.length;\n    int l2 = l2.length;\n    long l3 = 0, l4 =\
    \ 0;\n    for(int i=0;i<l1;i++)\n    {\n        long l5 = l1[i];\n        for(int\
    \ j=0;j<l2;j++)\n        {\n            l4 = l2[j];\n            if(l5 == l4)\n\
    \            {\n                l3++;\n                l2[j] = 0;\n          \
    \      break;\n            }\n        }\n    }\n    return l1==0?l3:l3;\n}\n</code>\n\
    <|/ a |>\n<| c |>\n`l3 = l1 - l2;\nreturn l3 == l1 ? l1 : l3;`\n<|/ c |>\n<| a\
    \ |>\nI know this is an old question but here is my solution, that does not use\
    \ recursion.\n<code>\nimport std.conv;\nimport std.array;\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ozoozag.d(37): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ozoozag.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] d = new long[l1.length];\n    for (int i = 0; i < l1.length;\
    \ i++)\n        d[i] = l1[i];\n    for (int i = 0; i < l2.length; i++)\n     \
    \   if (d[i] == l2[i]) return d;\n    long[] ret = new long[l1.length + l2.length];\n\
    \    int j = 0;\n    int k = 0;\n    for (int i = 0; i < l1.length; i++)\n   \
    \ {\n        while (k < l2.length && l2[l2.length - k] == d1[i])\n           \
    \ k++;\n        if (k > j)\n        {\n            ret[j] = d1[i];\n         \
    \   j++;\n        }\n    }\n    k = j;\n    for (int i = l1.length; i < l1.length\
    \ + l2.length; i++)\n    {\n        while (k < l2.length && l2[l2.length - k]\
    \ == d1[i])\n            k++;\n        if (k > j)\n            ret[j] = d1[i];\n\
    \        else\n            ret[j++] = d1[i];\n    }\n    return ret;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nWow, thanks for that! I've been trying to work this out for\
    \ quite some time now.\n<|/ c |>\n<| c |>\nI tried to implement the function but\
    \ I'm having trouble understanding the algorithm for getting the unique elements\
    \ from the first array. What does this line mean? *return d1[i]*\n<|/ c |>\n<|\
    \ a dscore=1 |>\nYou can use the merge sort algorithm for this.  It will give\
    \ you O(nlg(n)) performance in comparison.\n<|/ a tags=arrays,sorting,java,algorithm\
    \ |>\n<| a tags=arrays,sorting,java,algorithm |>\nTry this:\n<code>\npublic static\
    \ boolean isPalindrome(long x)\n    {\n        int i = 0;\n        int j = x.length()-1;\n\
    \        while (i < j)\n        {\n            if (x.charAt(i) != x.charAt(j))\n\
    \            {\n                return false;\n            }\n            i++;\n\
    \            j--;\n        }\n        return true;\n    }\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6uv9z820.d(44): Error: declaration expected, not `<`

    /tmp/tmp6uv9z820.d(47): Error: unterminated character constant

    /tmp/tmp6uv9z820.d(50): Error: unterminated character constant

    /tmp/tmp6uv9z820.d(62): Error: declaration expected, not `while`

    /tmp/tmp6uv9z820.d(67): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6uv9z820.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = {0L};\n    if (l1.length < l2.length) l1.reverse();\n\
    \    for (int i = 0; i < l1.length; i++) \n    {\n        int j = 0;\n       \
    \ for (; j < l2.length; j++) \n        {\n            if (l1[i] == l2[j]) \n \
    \           {\n                result[0] = l1[i];\n                break;\n  \
    \          }\n        }\n    }\n    std.sort(result);\n    return result;\n}\n\
    </code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\npackage main;\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiucmnr9n.d(31): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiucmnr9n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length];\n    long i, j, k;\n    for(i=0;\
    \ i<l1.length; i++)\n        for(j=0; j<l2.length; j++)\n            if(l1[i]\
    \ != l2[j])\n                for(k=i+1; k<l1.length; k++)\n                  \
    \  if(l1[k] != l2[j])\n                        break;\n            else\n    \
    \            res[i] = l1[i];\n    return res;\n}\n</code>\n<|/ a tags=java |>\n\
    <| c |>\nthank you so much!!! It helped me a lot to understand how things work.\n\
    <|/ c |>\n<| a |>\nThe correct answer to this question can be found here: http://rosettacode.org/wiki/Fast_least_common_multiple\n\
    <code>\nstatic int gcd(int a, int b) {\n        while (b > 0) {\n            int\
    \ t = b;\n            b = a % b;\n            a = t;\n        }\n        return\
    \ a;\n    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps2bjgjol.d(26): Error: declaration expected, not `<`

    /tmp/tmps2bjgjol.d(37): Error: no identifier for declarator `b`

    /tmp/tmps2bjgjol.d(37): Error: declaration expected, not `=`

    /tmp/tmps2bjgjol.d(38): Error: no identifier for declarator `a`

    /tmp/tmps2bjgjol.d(38): Error: declaration expected, not `=`

    /tmp/tmps2bjgjol.d(39): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps2bjgjol.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    if (l1.length != l2.length)\n        throw new IllegalArgumentException(\"\
    Lengths must be the same.\");\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi5rs5z4b.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi5rs5z4b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    return l1\n            .toSet()\n            .intersect(l2.toSet())\n\
    \            .sorted()\n            .map(i => l1[i])\n            .toArray();\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgpnvcr_6.d(15): Error: no property `toSet` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgpnvcr_6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  long[] a = new long[l1.length];\n  int j = 0;\n  int k = 0;\n  for(int\
    \ i = 0; i < l1.length; i++) {\n    a[i] = l1[i];\n  }\n  for(int j = 0; j < l2.length;\
    \ j++) {\n    a[k++] = l2[j];\n  }\n  \n  Arrays.sort(a);\n  return a;\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nWhy are you creating new arrays when you can sort\
    \ the existing array in place?\n<|/ c |>\n<| c |>\nThe new array is for returning\
    \ the sorted unique elements. Since arrays are pass-by-reference in Java so you\
    \ can pass your sorted unique arrays from your function. This is the best way\
    \ I think.\n<|/ c |>\n<| c |>\nI don't see how this is different than what I've\
    \ written in terms of efficiency. I don't think you were talking about efficiency\
    \ but rather about readability.\n<|/ c |>\n<| c |>\nI do think that efficiency\
    \ is a key feature here and I provided some code showing how to make it as fast\
    \ as possible (although your solution is probably better than this as it uses\
    \ less memory). I think this is more of a readability issue which I believe is\
    \ what the original poster is trying to achieve.\n<|/ c |>\n<| c |>\nYour solution\
    \ does not use `Arrays.sort`.\n<|/ c |>\n<| a tags=performance,arrays,sorting,algorithm,java\
    \ |>\nYou can use the Arrays class to sort your array in place using the sort()\
    \ method, like so:\n<code>\nArrays.sort(yourArray);\n</code>\n<|/ a dscore=3 |>\n\
    <| c |>\n`Arrays.sort` mutates the array, so this will only work once.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nIf you don't want to use Arrays.sort, you can try with\
    \ Arrays.binarySearch(), which returns an index at which a given element can be\
    \ found, or, if it's not found, it returns the first index greater than the given\
    \ element. \nIf it returns -1, then the element is not present in the array.\n\
    <code>\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplmejn5fx.d(27): Error: declaration expected, not `<`

    /tmp/tmplmejn5fx.d(36): Error: unterminated character constant

    /tmp/tmplmejn5fx.d(36): Error: unterminated character constant

    /tmp/tmplmejn5fx.d(36): Error: unterminated character constant

    /tmp/tmplmejn5fx.d(48): Error: declaration expected, not `<`

    /tmp/tmplmejn5fx.d(54): Error: unterminated character constant

    /tmp/tmplmejn5fx.d(54): Error: unterminated character constant

    /tmp/tmplmejn5fx.d(61): Error: declaration expected, not `assert`

    /tmp/tmplmejn5fx.d(62): Error: declaration expected, not `assert`

    /tmp/tmplmejn5fx.d(63): Error: declaration expected, not `assert`

    /tmp/tmplmejn5fx.d(64): Error: declaration expected, not `assert`

    /tmp/tmplmejn5fx.d(65): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplmejn5fx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ans = new long[l1.length];\n    for (int i = 0; i < ans.length;\
    \ i++) \n        ans[i] = l1[i];\n    Arrays.sort(ans);\n    int j;\n    for (int\
    \ i = 0; i < l2.length; i++) {\n        j = Arrays.binarySearch(ans, l2[i]);\n\
    \        if (j >= 0) \n            ans[j] = l2[i];\n    }\n    return ans;\n}\n\
    </code>\n<|/ a dscore=0 tags=c#,java,algorithm |>\n<| c |>\nThis is a brute force\
    \ approach.\n<|/ c |>\n<| c |>\n: It's a very simple approach. There are also\
    \ a lot of optimizations to this, and a lot of room for optimization.\n<|/ c |>\n\
    <| c |>\nYou cannot use Arrays.sort. You also don't need to find the index of\
    \ all elements in first array then search it again in second array. Just search\
    \ first array from first index.\n<|/ c |>\n<| c |>\n: I didn't say anything about\
    \ `Arrays.sort`. I'm just commenting on the fact that this approach is going to\
    \ be O(n^2) where n is the number of elements in l1 and l2, which is the worst\
    \ case for binary search. I don't see any optimizations here.\n<|/ c |>\n<| c\
    \ |>\nSure, but the complexity of your answer is O(n^2). Just replace it with\
    \ the code from my answer.\n<|/ c |>\n<| a tags=c#,java,algorithm |>\n<code>\n\
    using System;\nusing System.Collections.Generic;\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwc3iik8r.d(26): Error: declaration expected, not `<`

    /tmp/tmpwc3iik8r.d(32): Error: unterminated character constant

    /tmp/tmpwc3iik8r.d(35): Error: unterminated character constant

    /tmp/tmpwc3iik8r.d(38): Error: unterminated character constant

    /tmp/tmpwc3iik8r.d(38): Error: unterminated character constant

    /tmp/tmpwc3iik8r.d(38): Error: unterminated character constant

    /tmp/tmpwc3iik8r.d(46): Error: semicolon expected, not `.`

    /tmp/tmpwc3iik8r.d(46): Error: no identifier for declarator `.Collections.Generic`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwc3iik8r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[l1.length];\n    bool flag = false;\n    for(int\
    \ i = 0; i < l1.length; i++)\n    {\n        for(int j = 0; j < l2.length; j++)\n\
    \        {\n            if(l1[i] == l2[j])\n            {\n                flag\
    \ = true;\n                break;\n            }\n        }\n        if(!flag)\n\
    \        {\n            ret[i] = l1[i];\n        }\n        else\n        {\n\
    \            flag = false;\n        }\n    }\n    return ret;\n}\n</code>\n<|/\
    \ a dscore=1 tags=c++,stl |>\n<| a dscore=1 tags=c++,stl |>\nUse std::sort with\
    \ the std::less comparator functor. std::sort requires a sorted range and as long\
    \ as the input is sorted, it will not need to reorder elements in the input container.\
    \ Here is a simple example which sorts 5 random integers using a custom comparator:\n\
    <code>\n#include <vector>\n#include <algorithm>\n#include <iostream>\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk0_xfpfy.d(37): Error: declaration expected, not `<`

    /tmp/tmpk0_xfpfy.d(49): Error: declaration expected, not `assert`

    /tmp/tmpk0_xfpfy.d(50): Error: declaration expected, not `assert`

    /tmp/tmpk0_xfpfy.d(51): Error: declaration expected, not `assert`

    /tmp/tmpk0_xfpfy.d(52): Error: declaration expected, not `assert`

    /tmp/tmpk0_xfpfy.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk0_xfpfy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l = new long[l1.length+l2.length];\n    int j = 0;\n    int\
    \ k = 0;\n    for (int i=0; i<l1.length; i++) {\n        if (l2.length > k) {\n\
    \            if (l1[i] == l2[k]) {\n                l[j++] = l1[i];\n        \
    \        k++;\n            }\n            else {\n                while (k < l2.length)\
    \ {\n                    l[j++] = l2[k++];\n                }\n            }\n\
    \        }\n        else {\n            l[j++] = l1[i];\n        }\n    }\n  \
    \  return l;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpwxz75gde.d(39): unittest failure

    ----------------

    ??:? _d_unittestp [0x42867d]

    ??:? void tmpwxz75gde.__unittest_L35_C1() [0x428106]

    ??:? void tmpwxz75gde.__modtest() [0x428400]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c737]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ca]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430855]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d04]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4307e1]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5a1]

    ??:? runModuleUnitTests [0x42c50d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b40]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    if (l1.length != l2.length) throw new IllegalArgumentException(\"Array\
    \ length mismatch!\");\n    long[] res = new long[l1.length];\n    int len = l1.length;\n\
    \    int i = 0;\n    while (i < len && l1.get(i) == l2.get(i)) \n    {\n     \
    \   res[i] = l1.get(i);\n        i++;\n    }\n    while (i < len) {\n        res[i]\
    \ = l1.get(i);\n        i++;\n    }\n    sort(res);\n    return res;\n}\n</code>\n\
    <|/ a |>\n<| a tags=java,arrays,algorithm |>\nYou can use a HashSet to track visited\
    \ elements. The following code snippet does this.\n<code>\npublic static long[]\
    \ common(long [] l1, long [] l2) {\n    long[] result = new long[l1.length];\n\
    \    Set<Long> set = new HashSet<>();\n    for(long l: l1)\n        set.add(l);\n\
    \    for(long l: l2)\n        if(!set.add(l))\n            result[l%l1.length]\
    \ = l;\n    for(long l: result) \n        result[l%l1.length] = l;\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis looks more elegant and\
    \ efficient, but I'm not a Java programmer, so I'm having trouble figuring out\
    \ what the `%` does in the `result[l%l1.length] = l;` line.\n<|/ c |>\n<| c |>\n\
    `l%l1.length` will give you the remainder when `l` divides into the length of\
    \ `l1`, which means the index of `l1` in which the element resides.\n<|/ c |>\n\
    <| c |>\nI guess you could just do `result[l % l1.length] = l` instead, since\
    \ the `%` has higher precedence than `[]`.\n<|/ c |>\n<| a tags=java,arrays,algorithm\
    \ dscore=2 |>\n<code>\npublic static long[] common(long [] l1, long [] l2)\n \
    \   {\n        if (l1.length != l2.length) throw new IllegalArgumentException(\"\
    Array length mismatch!\");\n        long[] result = new long[l1.length];\n   \
    \     for(int i = 0; i < l1.length; i++)\n        {\n            boolean found\
    \ = false;\n            for(int j = 0; j < l2.length; j++)\n            {\n  \
    \              if(l1[i] == l2[j])\n                {\n                    found\
    \ = true;\n                    break;\n                }\n            }\n    \
    \        if(found)\n                result[i] = l1[i];\n        }\n        return\
    \ result;\n    }\n</code>\n<|/ a |>\n<| c |>\n\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvvh0ich2.d(30): Error: declaration expected, not `<`

    /tmp/tmpvvh0ich2.d(37): Error: no identifier for declarator `Set`

    /tmp/tmpvvh0ich2.d(37): Error: declaration expected, not `<`

    /tmp/tmpvvh0ich2.d(38): Error: declaration expected, not `for`

    /tmp/tmpvvh0ich2.d(40): Error: declaration expected, not `for`

    /tmp/tmpvvh0ich2.d(43): Error: declaration expected, not `for`

    /tmp/tmpvvh0ich2.d(45): Error: declaration expected, not `return`

    /tmp/tmpvvh0ich2.d(46): Error: unrecognized declaration

    /tmp/tmpvvh0ich2.d(50): Error: unterminated character constant

    /tmp/tmpvvh0ich2.d(50): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvvh0ich2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length];\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n\
    \    int i, j;\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1l9ptjhn.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1l9ptjhn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res =new long[l1.length];\n    long count=0;\n    for (int i=0\
    \ ; i<l1.length ; i++) {\n        for (int j=0 ; j<l2.length ; j++) {\n      \
    \      if (l1[i]==l2[j]) res[count++]=l1[i];\n        }\n    }\n    return res;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis code is very fast.\n<|/ c |>\n<| a tags=arrays,algorithm,c#\
    \ |>\nYou can make use of array sort function of c#. It sorts the array in ascending\
    \ order.\n<code>\n  static void Main(string[] args)\n    {\n        int[] num\
    \ = new int[5];\n        num[0] = 3;\n        num[1] = 1;\n        num[2] = 2;\n\
    \        num[3] = 5;\n        num[4] = 4;\n        Array.Sort(num);\n        foreach\
    \ (var item in num)\n        {\n            Console.WriteLine(item);\n       \
    \ }\n        Console.ReadLine();\n    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    I believe this code is O(N^2). It sorts the whole array, not just two numbers.\n\
    <|/ c |>\n<| a dscore=3 |>\nAn alternative approach could be using a Set<T> and\
    \ it's IntersectWith method which returns a new set containing elements present\
    \ in both sets. You can then convert this set to a new int[] array and use it:\n\
    <code>\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long l[] = new long[std.math.max(l1.length, l2.length)];\n    int j\
    \ = 0;\n    for (long x : l1) {\n        if (l2.length < l1.length) l[j] = l2[l2.length];\n\
    \        else if(x < l2[l2.length]) l[j] = l2[l2.length];\n        else if(l1.length\
    \ < l2.length) l[j] = l1[l1.length];\n        else if(x < l1[l1.length]) l[j]\
    \ = l1[l1.length];\n        else j++;\n        j++;\n    }\n    return std.sort(l);\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph2ungsfw.d(14): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] l`

    /tmp/tmph2ungsfw.d(16): Error: semicolon expected, not `:`

    /tmp/tmph2ungsfw.d(16): Error: expression expected, not `:`

    /tmp/tmph2ungsfw.d(16): Error: found `l1` when expecting `;` following `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph2ungsfw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int n1 = l1.length;\n    int n2 = l2.length;\n    long[] ans = new\
    \ long[n1 + n2];\n    for(int i = 0; i < n1; i++){\n        for(int j = 0; j <\
    \ n2; j++){\n            if((l1[i] == l2[j]) ){\n                ans[i + j] =\
    \ l1[i];\n            }\n        }\n    }\n    return ans;\n}\n</code>\n<|/ a\
    \ tags=java,arrays |>\n<| a dscore=1 tags=java,arrays |>\nUsing java-8, using\
    \ stream() & collect() :\n<code>\npublic static long[] common(long[] arr1, long[]\
    \ arr2){\n    long[] result = Arrays.stream(arr1).filter(x -> Arrays.stream(arr2).anyMatch(y\
    \ -> x == y)).distinct().toArray(long[]::new);\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis would return `[1, 3]` in this case, instead of `[1, 5]`.\n\
    <|/ c |>\n<| a tags=java,arrays |>\n<code>\nimport java.util.*;\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp56hdztgv.d(26): Error: declaration expected, not `<`

    /tmp/tmp56hdztgv.d(33): Error: declaration expected, not `return`

    /tmp/tmp56hdztgv.d(34): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp56hdztgv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int len1 = l1.length;\n    int len2 = l2.length;\n    if (len1 > len2)\
    \ \n    {\n        int temp = len2;\n        len2 = len1;\n        len1 = temp;\n\
    \    }\n    if (len1 == 0) return new long[0];\n    long[] res = new long[len1];\n\
    \    \n    long[] l3 = new long[len2];\n    int i = 0, j = 0;\n    while (i<len1\
    \ && j<len2)\n    {\n        if (l1[i] == l2[j]) \n        {\n            res[i]\
    \ = l1[i];\n            i++;\n            j++;\n        }\n        else if (l1[i]\
    \ < l2[j]) \n        {\n            l3[j++] = l1[i++];\n        }\n        else\
    \ \n        {\n            l3[j++] = l2[j++];\n        }\n    }\n    while (i\
    \ < len1) \n    {\n        l3[j++] = l1[i++];\n    }\n    while (j < len2) \n\
    \    {\n        l3[j++] = l2[j++];\n    }\n    return res;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a dscore=1 tags=arrays,algorithm,sorting |>\nUsing Map, HashMap\
    \ and HashSet all will be done in linear time.\n<code>\nstatic SortedSet<Integer>\
    \ intersection(Integer[] arr1, Integer[] arr2) {\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_2ax__bp.d(54): Error: declaration expected, not `<`

    /tmp/tmp_2ax__bp.d(64): Error: declaration expected, not `assert`

    /tmp/tmp_2ax__bp.d(65): Error: declaration expected, not `assert`

    /tmp/tmp_2ax__bp.d(66): Error: declaration expected, not `assert`

    /tmp/tmp_2ax__bp.d(67): Error: declaration expected, not `assert`

    /tmp/tmp_2ax__bp.d(68): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_2ax__bp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[long.max(l1.length, l2.length)];\n    int\
    \ i = 0, j = 0;\n    \n    // first check how many unique items are in both arrays\n\
    \    for(long x : l1) \n        if (l2.indexOf(x + 1) == -1) result[i++] = x;\n\
    \    for(long x : l2)\n        if (l1.indexOf(x + 1) == -1) result[j++] = x;\n\
    \    \n    // then add remaining unique items in one array to the other array\
    \ (result has unique elements)\n    for(long x : l1) \n        if (l2.indexOf(x\
    \ + 1) == -1) result[i++] = x;\n    for(long x : l2)\n        if (l1.indexOf(x\
    \ + 1) == -1) result[j++] = x;\n    \n    return result.subarray(0, i);\n}\n</code>\n\
    And here is the test that shows the performance is pretty good:\n<code>\npublic\
    \ static void testCommon()\n{\n    List<long[]> data = new ArrayList<>();\n  \
    \  for (int i = 0; i < 100; i++)\n    {\n        data.add(new long[200]);\n  \
    \      for (int j = 0; j < data.size(); j++)\n        {\n            long[] a\
    \ = new long[200];\n            long[] b = new long[200];\n            for (int\
    \ k = 0; k < a.length; k++)\n            {\n                a[k] = i;\n      \
    \          b[k] = j;\n            }\n            data.get(j) = a;\n        }\n\
    \    }\n    \n    long start = System.currentTimeMillis();\n    for (long[] array:\
    \ data)\n    {\n        long[] common = common(array);\n    }\n    long end =\
    \ System.currentTimeMillis();\n    \n    System.out.println(\"Time elapsed: \"\
    \ + (end - start));\n    \n}\n</code>\n<|/ a dscore=1 tags=java,arrays |>\n<|\
    \ c |>\nthanks for you answer, but i think this algorithm is not optimal. Because\
    \ it takes O(n^2) time (as i think). I am looking for an algorithm that takes\
    \ O(n) time.\n<|/ c |>\n<| c |>\nI've added a test that proves my algorithm is\
    \ fast enough.\n<|/ c |>\n<| c |>\nI got this solution and it's working fine,\
    \ but I am not satisfied with complexity and i think this solution is not optimal.\
    \ Can you suggest me any more optimised solution with O(n) complexity ?\n<|/ c\
    \ |>\n<| c |>\nI've added a test that proves my algorithm is fast enough.\n<|/\
    \ c |>\n<| c |>\nYou are right about this complexity. But can you suggest me another\
    \ solution with O(n) complexity?\n<|/ c |>\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmponkw8eim.d(18): Error: semicolon expected, not `:`

    /tmp/tmponkw8eim.d(18): Error: expression expected, not `:`

    /tmp/tmponkw8eim.d(18): Error: found `l1` when expecting `;` following `for` condition

    /tmp/tmponkw8eim.d(20): Error: semicolon expected, not `:`

    /tmp/tmponkw8eim.d(20): Error: expression expected, not `:`

    /tmp/tmponkw8eim.d(20): Error: found `l2` when expecting `;` following `for` condition

    /tmp/tmponkw8eim.d(24): Error: semicolon expected, not `:`

    /tmp/tmponkw8eim.d(24): Error: expression expected, not `:`

    /tmp/tmponkw8eim.d(24): Error: found `l1` when expecting `;` following `for` condition

    /tmp/tmponkw8eim.d(26): Error: semicolon expected, not `:`

    /tmp/tmponkw8eim.d(26): Error: expression expected, not `:`

    /tmp/tmponkw8eim.d(26): Error: found `l2` when expecting `;` following `for` condition

    /tmp/tmponkw8eim.d(31): Error: declaration expected, not `<`

    /tmp/tmponkw8eim.d(37): Error: declaration expected, not `for`

    /tmp/tmponkw8eim.d(37): Error: no identifier for declarator `i`

    /tmp/tmponkw'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    // This function doesn't actually use l1 and l2 but \n    // it is\
    \ an example of how to get two arrays into the same \n    // data structure while\
    \ not wasting too much space. \n    //\n    // The same algorithm can be implemented\
    \ in O(n) by using a \n    // hash table. \n    long [] table = new long [l1.length];\n\
    \    for(long e : table) e = l1[i];\n    for(long e : l2) table[i++] = e;\n  \
    \  \n    long[] result = new long[table.length];\n    int j = 0;\n    for(long\
    \ e : table) result[j++] = e;\n    return result;\n}\n</code>\nAnd here is the\
    \ same algorithm in O(n^2) using a hash map.\n<code>\nimport std.array;\nimport\
    \ std.arrayfns;\nimport std.map;\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpph2t9cxt.d(21): Error: semicolon expected, not `:`

    /tmp/tmpph2t9cxt.d(21): Error: expression expected, not `:`

    /tmp/tmpph2t9cxt.d(21): Error: found `table` when expecting `;` following `for`
    condition

    /tmp/tmpph2t9cxt.d(22): Error: semicolon expected, not `:`

    /tmp/tmpph2t9cxt.d(22): Error: expression expected, not `:`

    /tmp/tmpph2t9cxt.d(22): Error: found `l2` when expecting `;` following `for` condition

    /tmp/tmpph2t9cxt.d(26): Error: semicolon expected, not `:`

    /tmp/tmpph2t9cxt.d(26): Error: expression expected, not `:`

    /tmp/tmpph2t9cxt.d(26): Error: found `table` when expecting `;` following `for`
    condition

    /tmp/tmpph2t9cxt.d(29): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpph2t9cxt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long x = 0, y = 0, z = 0;\n    \n    // if l1 is longer than l2 return\
    \ it first\n    if(l1.length > l2.length) {\n        z = l1;\n        l1 = l2;\n\
    \        l2 = z;\n    }\n    \n    for(int i = 0; i < l1.length; i++) {\n    \
    \    if(l1[i] == l2[i]) \n            x += 1; \n        else\n            y +=\
    \ 1;\n    }\n    \n    long[] result = new long[l1.length];\n    \n    for(int\
    \ i = 0; i < l1.length; i++)\n        result[i] = l1[i];\n    \n    // now remove\
    \ common elements from l1 to l1\n    for(int i = 0; i < l2.length; i++) {\n  \
    \      if(result[i] == l2[i]) {\n            l1[i] = 0;\n            x -= 1;\n\
    \        } else\n            y -= 1;\n    }\n    \n    // now remove common elements\
    \ from l2 to l2\n    for(int i = 0; i < l2.length; i++) {\n        if(result[i]\
    \ == l2[i]) {\n            l2[i] = 0;\n            y -= 1;\n        } else\n \
    \           x -= 1;\n    }\n    \n    // now merge the remaining l1 to l1\n  \
    \  while(x > y) {\n        if(l1[l1.length - 1] != 0)\n            l1[l1.length\
    \ - 1] = l1[l1.length - 1] + 1;\n        else\n            l1.pop();\n    }\n\
    \    \n    // now merge the remaining l2 to l2\n    while(y > x) {\n        if(l2[l2.length\
    \ - 1] != 0)\n            l2[l2.length - 1] = l2[l2.length - 1] + 1;\n       \
    \ else\n            l2.pop();\n    }\n    \n    // now merge the remaining l1\
    \ to l2\n    while(x > y) {\n        if(l1[l1.length - 1] != 0)\n            l2[l2.length\
    \ - 1] = l2[l2.length - 1] + 1;\n        else\n            l1.pop();\n    }\n\
    \    \n    return result;\n}\n// ---------------------------------------------------------------------------------------------------------\n\
    /*\nReturn true if the array is sorted in descending order.\n    >>> descending([4,\
    \ 2, 2, 3, 2])\n    True\n    >>> descending([2, 2, 3, 2, 4])\n    False\n*/\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmejaqooq.d(18): Error: cannot implicitly convert expression `l1`
    of type `long[]` to `long`

    /tmp/tmpmejaqooq.d(20): Error: cannot implicitly convert expression `z` of type
    `long` to `long[]`

    /tmp/tmpmejaqooq.d(58): Error: no property `pop` for type `long[]`

    /tmp/tmpmejaqooq.d(66): Error: no property `pop` for type `long[]`

    /tmp/tmpmejaqooq.d(74): Error: no property `pop` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmejaqooq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int i = 0, j = 0; \n    int len1 = 0, len2 = 0;\n    long common =\
    \ 0;\n    while (i < l1.length && j < l2.length) {\n        if (l1[i] < l2[j])\
    \ {\n            i++;\n        } else if (l1[i] > l2[j]) {\n            j++;\n\
    \        } else if (l1[i] == l2[j]) {\n            common++;\n            len1++;\n\
    \            len2++;\n            i++; j++;\n        }\n    }\n    long[] result\
    \ = new long[len1 + len2 - common];\n    while (i < l1.length) {\n        result[len1]\
    \ = l1[i];\n        i++;\n        len1++;\n    }\n    while (j < l2.length) {\n\
    \        result[len2] = l2[j];\n        j++;\n        len2++;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a tags=optimization,java,c++,algorithm,c |>\n<| c |>\n\
    That's a great implementation. I'd like to add a comment that for integers this\
    \ is the best algorithm: http://stackoverflow.com/a/16547396/714007\n<|/ c |>\n\
    <| c |>\nThat's a great implementation. I'd like to add a comment that for integers\
    \ this is the best algorithm: http://stackoverflow.com/a/16547396/714007\n<|/\
    \ c |>\n<| c |>\nYour implementation is not correct (unless I'm missing something).\
    \ `common` should return `l1` if `l1[i] == l2[j]` and then `common` should be\
    \ incremented by 1.\n<|/ c |>\n<| c |>\n: I corrected the code and added some\
    \ comments. Also I have added a link to an alternative implementation that returns\
    \ an array of integers for common elements. Thanks!\n<|/ c |>\n<| a tags=optimization,java,c++,algorithm,c\
    \ dscore=2 |>\nJust use java.util.Arrays.asList(Arrays.asList(array1)) - Arrays.asList(array2)\
    \ will return a List<List<Integer>>, where each inner list is the same as the\
    \ input arrays. And then you can use the stream API to get all the common elements\
    \ like this:\n<code>\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8551odjl.d(42): Error: declaration expected, not `<`

    /tmp/tmp8551odjl.d(45): Error: unterminated character constant

    /tmp/tmp8551odjl.d(45): Error: unterminated character constant

    /tmp/tmp8551odjl.d(48): Error: unterminated character constant

    /tmp/tmp8551odjl.d(48): Error: unterminated character constant

    /tmp/tmp8551odjl.d(51): Error: unterminated character constant

    /tmp/tmp8551odjl.d(63): Error: declaration expected, not `assert`

    /tmp/tmp8551odjl.d(64): Error: declaration expected, not `assert`

    /tmp/tmp8551odjl.d(65): Error: declaration expected, not `assert`

    /tmp/tmp8551odjl.d(66): Error: declaration expected, not `assert`

    /tmp/tmp8551odjl.d(67): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8551odjl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[((l1.length == l2.length) ? l1.length : (l1.length\
    \ < l2.length ? l1.length : l2.length))];\n    int i, j;\n    for(i = 0; i < ret.length;\
    \ i++)\n    {\n        for(j = 0; j < i; j++)\n        {\n            if(l1[i]\
    \ == l2[j])\n            {\n                ret[i] = l1[i];\n                break;\n\
    \            }\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmphz047w7l.d(33): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285dd]

    ??:? void tmphz047w7l.__unittest_L29_C1() [0x428062]

    ??:? void tmphz047w7l.__modtest() [0x42835c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c697]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b52a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307b5]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c64]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430741]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b501]

    ??:? runModuleUnitTests [0x42c46d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428aa0]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int n = Math.min(l1.length, l2.length);\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        long common = l1.length > i ?\
    \ l1[i] : l1[0];\n        for(int j = 1; j < n; j++)\n        {\n            if(common\
    \ < l2[j] && common < res[j-1])\n            {\n                res[j] = common;\n\
    \            }\n        }\n    }\n    Arrays.sort(res);\n    return res;\n}\n\
    /*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\n    \n    \n\
    */\ndouble[] common(double[] l1, double[] l2) \n{\n    int n = Math.min(l1.length,\
    \ l2.length);\n    double[] res = new double[n];\n    for(int i = 0; i < n; i++)\n\
    \    {\n        double common = l1.length > i ? l1[i] : l1[0];\n        for(int\
    \ j = 1; j < n; j++)\n        {\n            if(common < l2[j] && common < res[j-1])\n\
    \            {\n                res[j] = common;\n            }\n        }\n \
    \   }\n    Arrays.sort(res);\n    return res;\n}\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n    \n    \n*/\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfssp4zuc.d(14): Error: undefined identifier `Math`

    /tmp/tmpfssp4zuc.d(27): Error: undefined identifier `Arrays`

    /tmp/tmpfssp4zuc.d(41): Error: undefined identifier `Math`

    /tmp/tmpfssp4zuc.d(54): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfssp4zuc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tHashSet<long> h = new HashSet<long>(l1);\n\th.retainAll(l2);\n\treturn\
    \ h.toArray();\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyf_0hn6c.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmpyf_0hn6c.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmpyf_0hn6c.d(14): Error: found `(` when expecting identifier following `long`.

    /tmp/tmpyf_0hn6c.d(14): Error: found `l1` when expecting `;` following statement

    /tmp/tmpyf_0hn6c.d(14): Error: found `)` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyf_0hn6c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l = new long[l1.length + l2.length];\n    int j = 0;\n    for\
    \ (int i = 0; i < l1.length; i++) \n\t{\n\t    if (i < l2.length) \n\t    {\n\t\
    \tl[j++] = l1[i];\n\t    }\n\t    else\n\t    {\n\t\tl[j++] = l2[i];\n\t    }\n\
    \t}\n\t\n\twhile (j < l.length) \n\t{\n\tl[j++] = 0L;\n\t}\n\t\n\tsort(l);\n\t\
    \n\tlong[] result = new long[l1.length + l2.length];\n\tint k = 0;\n\t\n\tint\
    \ i = 0;\n\t\n\twhile (i < l1.length && j < l2.length) \n\t{\n\t    if (l[i] <=\
    \ l[j]) {\n\t\tresult[k++] = l[i++];\n\t    } \n\t    else {\n\t\tresult[k++]\
    \ = l[j++];\n\t    }\n\t}\n\t\n\twhile (i < l1.length) \n\t{\n\t    result[k++]\
    \ = l[i++];\n\t}\n\t\n\twhile (j < l2.length) \n\t{\n\t    result[k++] = l[j++];\n\
    \t}\n\t\n\treturn result;\n}\n/*\n  std.typecons.map2[T](T f, T s) => (f(s), f(s))\n\
    */\nmap2<long, long> map2(f, s) {\n\tmap2<long, long> r = map();\n\tmap2<long,\
    \ long> f = map(f);\n\tmap2<long, long> s = map(s);\n\t\n\tfor (map2<long, long>\
    \ i = f; i.l != null; i = i.f) \n\t{\n\t\tfor (map2<long, long> j = s; j.l !=\
    \ null; j = j.f) \n\t\t{\n\t\t\tr[i.l] = j.l;\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\
    /*\n  std.typecons.map2[T](T f, T s) => (f(s), f(s))\n*/\nmap2<long, long> map2(f,\
    \ s) {\n\tmap2<long, long> r = map();\n\tmap2<long, long> f = map(f);\n\tmap2<long,\
    \ long> s = map(s);\n\t\n\tfor (map2<long, long> i = f; i.l != null; i = i.f)\
    \ \n\t{\n\t\tfor (map2<long, long> j = s; j.l != null; j = j.f) \n\t\t{\n\t\t\t\
    r[i.l] = j.l;\n\t\t}\n\t}\n\t\n\treturn r;\n}\n/*\n  std.typecons.map2[T](T f,\
    \ T s) \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8z8n93g3.d(65): Error: no identifier for declarator `map2`

    /tmp/tmp8z8n93g3.d(65): Error: declaration expected, not `<`

    /tmp/tmp8z8n93g3.d(67): Error: no identifier for declarator `map2`

    /tmp/tmp8z8n93g3.d(67): Error: declaration expected, not `<`

    /tmp/tmp8z8n93g3.d(68): Error: no identifier for declarator `map2`

    /tmp/tmp8z8n93g3.d(68): Error: declaration expected, not `<`

    /tmp/tmp8z8n93g3.d(70): Error: declaration expected, not `for`

    /tmp/tmp8z8n93g3.d(70): Error: no identifier for declarator `i.l`

    /tmp/tmp8z8n93g3.d(70): Error: declaration expected, not `!=`

    /tmp/tmp8z8n93g3.d(70): Error: no identifier for declarator `i`

    /tmp/tmp8z8n93g3.d(70): Error: declaration expected, not `=`

    /tmp/tmp8z8n93g3.d(72): Error: no identifier for declarator `j.l`

    /tmp/tmp8z8n93g3.d(72): Error: declaration expected, not `!=`

    /tmp/tmp8z8n93g3.d(72): Error: no identifier for declarator `j`

    /tmp/tmp8z8n93g3.d(72): Error: declaration expected, not `=`

    /tmp/tmp8z8n93g3.d(75): Error: unrecognized declaration

    Failed: ["dmd",'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    if (l1.length != l2.length) \n        throw new RuntimeException(\"\
    Error: L2 length != L1\");\n    long[] temp = new long[l1.length];\n    for (int\
    \ i=0; i<l1.length; i++) {\n        if (l2[i]!=null && l1[i]!=null) {\n      \
    \      if (l2[i] > l1[i]) {\n                temp[i] = l2[i];\n            }\n\
    \            else {\n                temp[i] = l1[i];\n            }\n       \
    \ }\n        else {\n            if (l2[i] != null) {\n                temp[i]\
    \ = l2[i];\n            }\n            else {\n                temp[i] = l1[i];\n\
    \            }\n        }\n    }\n    Arrays.sort(temp);\n    return temp;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl90id6js.d(15): Error: undefined identifier `RuntimeException`

    /tmp/tmpl90id6js.d(18): Error: incompatible types for `(l2[cast(ulong)i]) != (null)`:
    `long` and `typeof(null)`

    /tmp/tmpl90id6js.d(18): Error: incompatible types for `(l1[cast(ulong)i]) != (null)`:
    `long` and `typeof(null)`

    /tmp/tmpl90id6js.d(27): Error: incompatible types for `(l2[cast(ulong)i]) != (null)`:
    `long` and `typeof(null)`

    /tmp/tmpl90id6js.d(35): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl90id6js.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int i = 0;\n    int j = 0;\n    int n1 = l1.length;\n    int n2 = l2.length;\n\
    \    long[] result = new long[n1+n2];\n    while (i<n1)\n    {\n        while\
    \ (j<n2 && (l1[i] == l2[j])) j++;\n        result[i++] = l1[i++];\n    }\n   \
    \ while (i<n1)\n    {\n        result[i++] = l1[i++];\n    }\n    while (j<n2)\n\
    \    {\n        result[i++] = l2[j++];\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=arrays,java,sorting,compare |>\n<| a dscore=4 tags=arrays,java,sorting,compare\
    \ |>\nAnother way to do this is using Arrays.sort() method as follows:\n<code>\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8zpfofby.d(34): Error: declaration expected, not `<`

    /tmp/tmp8zpfofby.d(43): Error: declaration expected, not `assert`

    /tmp/tmp8zpfofby.d(44): Error: declaration expected, not `assert`

    /tmp/tmp8zpfofby.d(45): Error: declaration expected, not `assert`

    /tmp/tmp8zpfofby.d(46): Error: declaration expected, not `assert`

    /tmp/tmp8zpfofby.d(47): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8zpfofby.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n        long[] a = new long[l1.length];\n        for (int i = 0; i < l1.length;\
    \ i++) \n        {\n                a[i] = l1[i];\n        }\n        long[] b\
    \ = new long[l2.length];\n        for (int i = 0; i < l2.length; i++) \n     \
    \   {\n                b[i] = l2[i];\n        }\n        int i = 0;\n        int\
    \ j = 0;\n        while (i<a.length && j<b.length) \n        {\n             \
    \   if (a[i]<b[j])\n                {\n                        i++;\n        \
    \        }\n                else\n                {\n                        j++;\n\
    \                }\n        }\n        long[] result = new long[i];\n        if\
    \ (i<a.length)\n        {\n                result = Arrays.copyOf(a, i);\n   \
    \     }\n        else\n        {\n                result = Arrays.copyOf(b, j);\n\
    \        }\n        return result;\n}\n</code>\n<|/ a tags=sorting,collections,java,arrays\
    \ |>\n<| a tags=sorting,collections,java,arrays dscore=2 |>\n<code>\n public int[]\
    \ sort(int[] ints)\n {\n     Arrays.sort(ints);\n     return ints;\n }\n</code>\n\
    <|/ a |>\n<| a tags=sorting,collections,java,arrays |>\n<code>\nimport java.util.Arrays;\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk3s90bxw.d(48): Error: declaration expected, not `<`

    /tmp/tmpk3s90bxw.d(55): Error: declaration expected, not `return`

    /tmp/tmpk3s90bxw.d(56): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk3s90bxw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    int i = 0;\n    \n    while (i<l1.length)\n\
    \    {\n        if (l1[i] != l2[i])\n        {\n            l3[i] = l1[i];\n \
    \           i++;\n        }\n        else\n        {\n            i++;\n     \
    \   }\n    }\n    \n    return l3;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp09pbaujs.d(36): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285b5]

    ??:? void tmp09pbaujs.__unittest_L32_C1() [0x42803e]

    ??:? void tmp09pbaujs.__modtest() [0x428338]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c66f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b502]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43078d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c3c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430719]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4d9]

    ??:? runModuleUnitTests [0x42c445]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a78]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long i,j, k, m;\n    int[] u1 = new int[l1.length];\n    int[] u2 =\
    \ new int[l2.length];\n    long[] u = new long[l1.length];\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1c5qfp7q.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1c5qfp7q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long result = 0, i1 = 0, i2 = 0, n = 0, m = 0;\n    \n    while (true)\
    \ {\n        n = (i1 < l1.length && i2 < l2.length) ? l1[i1] < l2[i2] : l1[i1]\
    \ == l2[i2];\n        m = i1 < l1.length;\n        \n        if (n == false) {\n\
    \            i1++;\n        } else if (m == false) {\n            i2++;\n    \
    \    } else {\n            break;\n        }\n    }\n    \n    while (i1 < l1.length)\
    \ {\n        result = result ^ l1[i1++];\n    }\n    \n    while (i2 < l2.length)\
    \ {\n        result = result ^ l2[i2++];\n    }\n    \n    return result == 0\
    \ ? [] : [result];\n}\n/* \n    Use a prefix tree for quick lookup.\n*/\nclass\
    \ PrefixTree {\n    long prefix;\n    \n    bool isLeaf;\n    \n    long height;\n\
    \    \n    List<List<long>> nodes;\n    \n    long value;\n    \n    public PrefixTree(long\
    \ prefix, bool isLeaf, long height, List<List<long>> nodes, long value) {\n  \
    \      this.prefix = prefix;\n        this.isLeaf = isLeaf;\n        this.height\
    \ = height;\n        this.nodes = nodes;\n        this.value = value;\n    }\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmputtj7n88.d(49): Error: no identifier for declarator `List`

    /tmp/tmputtj7n88.d(49): Error: declaration expected, not `<`

    /tmp/tmputtj7n88.d(53): Error: unexpected `(` in declarator

    /tmp/tmputtj7n88.d(53): Error: found `<` when expecting `)`

    /tmp/tmputtj7n88.d(53): Error: no identifier for declarator `PrefixTree(long prefix,
    bool isLeaf, long height, List)`

    /tmp/tmputtj7n88.d(53): Error: semicolon expected following function declaration

    /tmp/tmputtj7n88.d(53): Error: no identifier for declarator `List`

    /tmp/tmputtj7n88.d(53): Error: declaration expected, not `<`

    /tmp/tmputtj7n88.d(55): Error: declaration expected, not `=`

    /tmp/tmputtj7n88.d(56): Error: declaration expected, not `=`

    /tmp/tmputtj7n88.d(57): Error: declaration expected, not `=`

    /tmp/tmputtj7n88.d(58): Error: declaration expected, not `=`

    /tmp/tmputtj7n88.d(60): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmputtj7n88.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong min;\n\tlong temp;\n\tint[] i1 = intArray(l1);\n\tint[] i2 = intArray(l2);\n\
    \t\n\tfor(int i = 0; i < i1.length; i++){\n\t\tmin = i1[i];\n\t\tfor(int j = 0;\
    \ j < i2.length; j++){\n\t\t\tif(i2[j] < min){\n\t\t\t\tmin = i2[j];\n\t\t\t}\n\
    \t\t}\n\t\tint index = i;\n\t\twhile(index > 0 && i1[index-1] >= min){\n\t\t\t\
    i1[index] = i1[index-1];\n\t\t\tindex--;\n\t\t}\n\t\ti1[index] = min;\n\t}\n\t\
    \n\treturn intArray(i1);\n}\nunittest\n{\n    alias candidate = common;\n\n  \
    \  assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpveblefw0.d(16): Error: undefined identifier `intArray`

    /tmp/tmpveblefw0.d(17): Error: undefined identifier `intArray`

    /tmp/tmpveblefw0.d(31): Error: cannot implicitly convert expression `min` of type
    `long` to `int`

    /tmp/tmpveblefw0.d(34): Error: undefined identifier `intArray`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpveblefw0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n    long[] result = new long[l1.length\
    \ + l2.length];\n    long[] r1 = l1, r2 = l2;\n    long common = -1, common2 =\
    \ 0;\n    \n    for(int i = 0; i<l1.length && i<l2.length; i++){\n        if(l1[i]==l2[i]){\n\
    \            result[i] = l1[i];\n        }else if(l1[i]<l2[i]){\n            result[i]\
    \ = r1[i];\n            common = l1[i];\n        }else{\n            result[i]\
    \ = r2[i];\n            common2 = l2[i];\n        }\n    }\n    \n    for(int\
    \ i = 0; i<l1.length; i++){\n        if(l1[i]!=l2[i]){\n            result[i]\
    \ = l1[i];\n        }\n    }\n    \n    if(r1.length>l2.length){\n        for(int\
    \ i = 0; i<l2.length; i++){\n            result[l2.length+i] = r2[i];\n      \
    \  }\n    }else{\n        for(int i = 0; i<r2.length; i++){\n            result[l1.length+i]\
    \ = r2[i];\n        }\n    }\n    \n    Arrays.sort(result);\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprymgbslr.d(14): Error: undefined identifier `Arrays`

    /tmp/tmprymgbslr.d(15): Error: undefined identifier `Arrays`

    /tmp/tmprymgbslr.d(48): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprymgbslr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l3 = new long[l1.length];\n    for(int i = 0; i < l1.length;\
    \ i++) \n    {\n        int j;\n        for (j = 0; j < l2.length; j++) \n   \
    \         if (l1[i] == l2[j]) \n                break;\n        if (j == l2.length)\
    \ \n            l3[i] = l1[i]; \n        else \n            l3[i] = l1[i]; \n\
    \    }\n    return l3;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg915l04a.d(32): unittest failure

    ----------------

    ??:? _d_unittestp [0x428625]

    ??:? void tmpg915l04a.__unittest_L28_C1() [0x4280aa]

    ??:? void tmpg915l04a.__modtest() [0x4283a4]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6df]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b572]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307fd]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cac]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430789]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b549]

    ??:? runModuleUnitTests [0x42c4b5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ae8]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = null;\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n\
    \    int j = 0;\n    int i = 0;\n    while (i < l1.length && j < l2.length)\n\
    \    {\n        if (l1[i] == l2[j])\n        {\n            j++;\n        }\n\
    \        else if (l1[i] < l2[j])\n        {\n            if (result == null)\n\
    \            {\n                result = new long[l1.length];\n            }\n\
    \            result[i++] = l1[i];\n        }\n        else\n        {\n      \
    \      if (result == null)\n            {\n                result = new long[l2.length];\n\
    \            }\n            result[j++] = l2[j];\n        }\n    }\n    if (i\
    \ == l1.length)\n    {\n        Arrays.sort(result);\n    }\n    if (j == l2.length)\n\
    \    {\n        Arrays.sort(result);\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThat's a good start, though you might want to do some profiling\
    \ to find out what sorts of optimizations it makes.\n<|/ c |>\n<| c |>\nIf you\
    \ use Arrays.sort like that (for large arrays), it's worth it to add some checks\
    \ in your loop that you're not overflowing the arrays. You can end up overwriting\
    \ one array and corrupting another. Since Java 8 you can use `IntStream.range(startInclusive,\
    \ stopInclusive).boxed().collect(toList())` to get an IntStream from an array\
    \ of ints.\n<|/ c |>\n<| c |>\nI suspect a lot of people have noticed that `Arrays.sort()`\
    \ runs in O(nlogn) time, which could be slow for large arrays. I thought it would\
    \ be nice to see a solution that is O(n) time for small arrays, but I've also\
    \ started a discussion about that: http://stackoverflow.com/questions/15209435/how-to-get-the-unique-elements-from-an-array-using-a-complex-time-algorithm\n\
    <|/ c |>\n<| c |>\nOops, I misread your comment.  I thought you meant to say `O(n\
    \ + mlogn)` instead of `O(nlogn)`. I deleted my comment and upvoted yours.\n<|/\
    \ c |>\n<| c |>\nOh that is right, I mean O(n + mlogn). I just got confused because\
    \ you wrote a O(nlogn) solution and posted an O(n) solution at the same time.\
    \ I should probably delete the comment and upvote yours.\n<|/ c |>\n<| a tags=java,arrays,algorithm,c++\
    \ dscore=3 |>\n<code>\nimport java.util.Arrays;\npublic class array{\n    public\
    \ \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxutkeknd.d(52): Error: declaration expected, not `<`

    /tmp/tmpxutkeknd.d(55): Error: unterminated character constant

    /tmp/tmpxutkeknd.d(58): Error: unterminated character constant

    /tmp/tmpxutkeknd.d(58): Error: unterminated character constant

    /tmp/tmpxutkeknd.d(61): Error: unterminated character constant

    /tmp/tmpxutkeknd.d(83): Error: `}` expected following members in `class` declaration
    at /tmp/tmpxutkeknd.d(72)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxutkeknd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length];\n    sort(l1, l2);\n    for(int\
    \ i = 0; i < (l1.length-l2.length+1); i++) {\n        result[i] = l1[i];\n   \
    \ }\n    sort(result, result);\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo8fri8ke.d(15): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpo8fri8ke.d(19): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo8fri8ke.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong t = 0;\n\tint i = 0;\n\tlong temp = 0;\n\tint k;\n\t\n\twhile((i\
    \ < l1.length) && (i < l2.length)) {\n\t\ttemp = (l1[i]) ^ (l2[i]);\n\t\tt = ((t\
    \ ^ temp) & 0x5555555555555555LL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t ^ (t >> 1)) & 0xaaaaaaaaaaaaaaaaLL);\n\t\tk = ((k + 1) & 0x5555555555555555LL);\n\
    \t\tt = ((t \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm2d46h5x.d(21): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(22): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(23): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(24): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(25): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(26): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(27): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(28): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(29): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(30): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(31): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(32): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(33): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(34): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(35): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(36): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(37): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(38): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(39): Error: unrecognized token

    /tmp/tmpm2d46h5x.d(40): Error: unrecognized token

    Failed: ["dmd", "-unitte'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[l1.length+l2.length];\n    for (int i = 0; i<l1.length;\
    \ i++) {\n        for (int j = 0; j<l2.length; j++) {\n            if (l1[i] ==\
    \ l2[j]) {\n                ret[i] = l1[i];\n            }\n        }\n    }\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmptbzlzqkl.d(28): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285c5]

    ??:? void tmptbzlzqkl.__unittest_L24_C1() [0x42804e]

    ??:? void tmptbzlzqkl.__modtest() [0x428348]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c67f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b512]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43079d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c4c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4e9]

    ??:? runModuleUnitTests [0x42c455]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a88]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int n1 = l1.length;\n    int n2 = l2.length;\n    long[] res = new\
    \ long[n1];\n    for(int i=0; i<n1; i++) {\n        for(int j=0; j<n2; j++) {\n\
    \            if(l1[i]==l2[j]) {\n                res[i] = l1[i];\n           \
    \     break;\n            }\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ a list of elements common to both lists.\n    >>> common([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk26y8apx.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk26y8apx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] n1, n2;\n    int n;\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptyrz0pz5.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptyrz0pz5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[std.array.max(l1.length, l2.length)];\n    long[]\
    \ x = l1, y = l2;\n    int i;\n    long x;\n    long y;\n    while (i = std.array.argmax(x.length,\
    \ y.length)) \n    {\n        x = std.array.min(x.length, y.length);\n       \
    \ y = std.array.min(x.length, y.length);\n        if (std.array.getIndex(i) <\
    \ x.length)\n        {\n            ret[i] = std.array.get(i, x);\n        }\n\
    \        else if (std.array.getIndex(i) < y.length)\n        {\n            ret[i]\
    \ = std.array.get(i, y);\n        }\n        else\n        {\n            ret[i]\
    \ = std.array.get(i, x.length);\n        }\n    }\n    return ret;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptt6x3op_.d(14): Error: undefined identifier `array` in package
    `std`

    /tmp/tmptt6x3op_.d(17): Error: declaration `tmptt6x3op_.common.x` is already defined

    /tmp/tmptt6x3op_.d(18): Error: declaration `tmptt6x3op_.common.y` is already defined

    /tmp/tmptt6x3op_.d(19): Error: assignment cannot be used as a condition, perhaps
    `==` was meant?

    /tmp/tmptt6x3op_.d(21): Error: undefined identifier `array` in package `std`

    /tmp/tmptt6x3op_.d(22): Error: undefined identifier `array` in package `std`

    /tmp/tmptt6x3op_.d(23): Error: undefined identifier `array` in package `std`

    /tmp/tmptt6x3op_.d(25): Error: undefined identifier `array` in package `std`

    /tmp/tmptt6x3op_.d(27): Error: undefined identifier `array` in package `std`

    /tmp/tmptt6x3op_.d(29): Error: undefined identifier `array` in package `std`

    /tmp/tmptt6x3op_.d(33): Error: undefined identifier `array` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptt6x3op_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    var n1 = l1.length;\n    var n2 = l2.length;\n    long[] result; \n\
    \    long[] v1;\n    long[] v2;\n    long i=0,j=0,k=0,v=0;\n    long common_length=0;\n\
    \    int k=0;\n    if(n1<n2){\n        common_length = n1;\n        result = v1\
    \ = l1;\n        v2 = l2;\n    }else{\n        common_length = n2;\n        result\
    \ = v2 = l2;\n        v1 = l1;\n    }\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3yowx1bg.d(31): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3yowx1bg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] h1 = new long[20]; \n\tlong[] h2 = new long[20];\n\tfor (int i\
    \ = 0; i < 20; i++) { \n\t\th1[i] = 0;\n\t\th2[i] = 0;\n\t}\n\tint l = 0;\n\t\
    int c = 0;\n\tint len1 = 0, len2 = 0;\n\tfor (int i = 0; i < l1.length && i <\
    \ l2.length; i++) {\n\t\tif (l1[l] == l2[c]) {\n\t\t\th1[l] = l1[l]; \n\t\t\t\
    len1++;\n\t\t\tc++;\n\t\t\tif (len1 == 20) {\n\t\t\t\tl++;\n\t\t\t\tlen1 = 0;\n\
    \t\t\t}\n\t\t} else {\n\t\t\tif (len1 > len2) {\n\t\t\t\th2[c] = h1[c]; \n\t\t\
    \t\tlen2++;\n\t\t\t\tc = 0;\n\t\t\t\tif (len2 == 20) {\n\t\t\t\t\tl++;\n\t\t\t\
    \t\tlen2 = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\th1[c] = h2[c]; \n\t\t\t\tlen1++;\n\
    \t\t\t\tc = 0;\n\t\t\t\tif (len1 == 20) {\n\t\t\t\t\tl++;\n\t\t\t\t\tlen1 = 0;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (len1 > len2) { \n\t\tfor (int i = len1;\
    \ i < len2; i++) {\n\t\t\th2[c] = h1[c]; \n\t\t\tc++;\n\t\t}\n\t} else if (len2\
    \ > len1) {\n\t\tfor (int i = len2; i < len1; i++) {\n\t\t\th1[c] = h2[c]; \n\t\
    \t\tc++;\n\t\t}\n\t}\n\treturn h1;\n}\n</code>\n<|/ a tags=algorithm,arrays,sorting\
    \ |>\n<| c |>\nThis implementation was very helpful, even though its complexity\
    \ is O(n^2). Thanks\n<|/ c |>\n<| a dscore=1 |>\nIf you can use external libraries,\
    \ you can use std::sort with custom comparators. For example, using lambda and\
    \ std::sort with custom comparators:\n<code>\n#include <iostream>\n#include <algorithm>\n\
    #include <vector>\n#include <functional>\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpixxaafxr.d(65): Error: declaration expected, not `<`

    /tmp/tmpixxaafxr.d(81): Error: declaration expected, not `assert`

    /tmp/tmpixxaafxr.d(82): Error: declaration expected, not `assert`

    /tmp/tmpixxaafxr.d(83): Error: declaration expected, not `assert`

    /tmp/tmpixxaafxr.d(84): Error: declaration expected, not `assert`

    /tmp/tmpixxaafxr.d(85): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpixxaafxr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] n1 = new long[l1.length];\n    long[] n2 = new long[l2.length];\n\
    \    for (int i = 0; i<l1.length; i++)\n    {\n        n1[i] = l1[i];\n    }\n\
    \    for (int i = 0; i<l2.length; i++)\n    {\n        n2[i] = l2[i];\n    }\n\
    \    n1.Sort();\n    n2.Sort();\n    long[] res = new long[l1.length];\n    for\
    \ (int i = 0; i<l1.length; i++)\n    {\n        for (int j = 0; j<l2.length; j++)\n\
    \        {\n            if (n1[i] == n2[j])\n            {\n                res[i]\
    \ = n1[i];\n                break;\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzy2l2srr.d(24): Error: no property `Sort` for type `long[]`

    /tmp/tmpzy2l2srr.d(25): Error: no property `Sort` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzy2l2srr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] a = new long[20];\n\tint i, j, k;\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqrm_oq0_.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqrm_oq0_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] result = new long[l1.length];\n\tfor (int i = 0; i < result.length;\
    \ ++i)\n\t{\n\t\tfor (int j = 0; j < l2.length; ++j)\n\t\t{\n\t\t\tif (l1[i] ==\
    \ l2[j])\n\t\t\t{\n\t\t\t\tresult[i] = l1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\
    \t}\n\tArrays.sort(result);\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwro6jafi.d(26): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwro6jafi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long n1 = length(l1);\n    long n2 = length(l2);\n    if (n1 == 0)\n\
    \        return l1;\n    if (n2 == 0)\n        return l2;\n    if (n1 > n2)\n\
    \        l2 = l2;\n    long[] ans = l1;\n    if (l1 == l2) {\n        ans.length\
    \ = 0;\n        return ans;\n    }\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplpqfyo6o.d(27): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplpqfyo6o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length + l2.length];\n    for (int i = 0;\
    \ i < l1.length; ++i)\n    {\n        for (int j = 0; j < l2.length; ++j)\n  \
    \      {\n            if (l1[i] == l2[j])\n            {\n                res[i\
    \ + j] = l1[i];\n                res[i + j + 1] = l1[i + 1];\n               \
    \ res[i + j + 2] = l1[i + 2];\n                res[i + j + 3] = l1[i + 3];\n \
    \           }\n        }\n    }\n    return res;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Thank you for your answer. My problem is more complex than I asked it. I am looking\
    \ for a way to get the intersection of two arrays of different sizes (not just\
    \ different in size, but not evenly divisible). For example: [[1,2],[3,4]] & [[1,3],[5,7]].\
    \ Because these two arrays are not divisible, their intersection is not common.\
    \ I need to compare their intersection and output those common elements.\n<|/\
    \ c |>\n<| c |>\n: My answer does not only output common elements; it outputs\
    \ common elements, and it also outputs elements from both arrays. Please test\
    \ it before downvoting.\n<|/ c |>\n<| c |>\nMy answer does not output common elements,\
    \ but it outputs common elements from both arrays. I edited the answer so you\
    \ can see it. I don't know where you got downvoted, but I gave my answer a +1\
    \ anyway.\n<|/ c |>\n<| c |>\n: I edited the question to clarify the requirements\
    \ you have.\n<|/ c |>\n<| c |>\n: Ok, I edited the answer to address this requirement.\
    \ I am still not sure you really need to output only common elements. It's not\
    \ clear how your problem is different from the problem of finding the common elements\
    \ in two arrays; you just need to know how to find the common elements between\
    \ two arrays. I'll keep thinking and will let you know if I find an answer that\
    \ solves your problem.\n<|/ c |>\n<| a tags=java,arrays,c#,algorithm |>\nThe most\
    \ straightforward way is to sort the array and keep track of the number of elements\
    \ that have already been counted.\n<code>\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi9hz889v.d(30): Error: declaration expected, not `<`

    /tmp/tmpi9hz889v.d(36): Error: semicolon expected, not `common`

    /tmp/tmpi9hz889v.d(36): Error: semicolon expected, not `it`

    /tmp/tmpi9hz889v.d(36): Error: semicolon expected, not `outputs`

    /tmp/tmpi9hz889v.d(36): Error: semicolon expected, not `from`

    /tmp/tmpi9hz889v.d(36): Error: semicolon expected, not `arrays`

    /tmp/tmpi9hz889v.d(36): Error: semicolon expected, not `it`

    /tmp/tmpi9hz889v.d(36): Error: semicolon expected, not `downvoting`

    /tmp/tmpi9hz889v.d(37): Error: identifier expected following `.` instead of `<`

    /tmp/tmpi9hz889v.d(37): Error: no identifier for declarator `downvoting`

    /tmp/tmpi9hz889v.d(37): Error: declaration expected, not `<`

    /tmp/tmpi9hz889v.d(39): Error: unterminated character constant

    /tmp/tmpi9hz889v.d(45): Error: unterminated character constant

    /tmp/tmpi9hz889v.d(45): Error: semicolon expected, not `need`

    /tmp/tmpi9hz889v.d(45): Error: semicolon expected, not `know`

    /tmp/tmpi9hz889v.d(45): Error: semicolon expected, not `'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tint[] l=std.intarray;\n\tint i;\n\t\n\tint n=l1.length;\n\tint m=l2.length;\n\
    \t\n\tlong[] r=new long[n+m];\n\t\n\tfor(i=0;i<=n; r.push(n), i++);\n\tfor(i=0;i<=m;\
    \ r.push(m), i++);\n\t\n\tfor(i=n+1;i<=m; r.push(i), i++);\n\t\n\tfor(i=1;i<=n;i++)\n\
    \t{\n\t\tint h=l1[i-1];\n\t\tint j=i+1;\n\t\twhile(j<=m && l[j-1]!=h) j++;\n\t\
    \tr[i-1]=std.math.max(l[i-1],l[j-1]);\n\t}\n\t\n\treturn r;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyhvqde2i.d(22): Error: use `{ }` for an empty statement, not `;`

    /tmp/tmpyhvqde2i.d(23): Error: use `{ }` for an empty statement, not `;`

    /tmp/tmpyhvqde2i.d(25): Error: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyhvqde2i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] ret = new long[l1.length];\n    int i = 0;\n    for (int n =\
    \ 0; n < l1.length; n++) {\n        for (int m = 0; m < l2.length; m++) {\n  \
    \          if (l1[n] == l2[m]) {\n                ret[i++] = l1[n];\n        \
    \        break;\n            }\n        }\n    }\n    Arrays.sort(ret);\n    return\
    \ ret;\n}\n</code>\n<|/ a tags=sorting,java |>\n<| c |>\nIf someone is still looking\
    \ for a more efficient solution, it is much faster to do this in C++ using unordered_map\
    \ and unordered_set. Here is an example in C++ of the same: http://stackoverflow.com/questions/11594553/find-unique-elements-in-two-unordered-vectors-by-using-hashset\n\
    <|/ c |>\n<| a dscore=0 |>\nTo find the unique elements in a set, first sort the\
    \ set using any sort mechanism you prefer. After that use a \"HashSet\" data structure\
    \ to store the unique elements and then print the unique elements from the hash-set\
    \ data structure\n<code>\nimport java.io.*;\nimport java.util.*;\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6kdwvnvt.d(27): Error: declaration expected, not `<`

    /tmp/tmp6kdwvnvt.d(36): Error: identifier expected following `package`

    /tmp/tmp6kdwvnvt.d(36): Error: `;` expected

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6kdwvnvt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tif (l1.length != l2.length) \n\t{\n\t\tthrow new IndexOutOfBoundsException();\n\
    \t}\n\tlong[] a = new long[l1.length];\n\tint j = 0;\n\tfor (int i = 0; i < l1.length;\
    \ ++i)\n\t{\n\t\tif (l1[i] > l2[i]) \n\t\t{\n\t\t\ta[j] = l2[i];\n\t\t\tj++;\n\
    \t\t}\n\t\telse if (l1[i] < l2[i]) \n\t\t{\n\t\t\ta[j] = l1[i];\n\t\t\tj++;\n\t\
    \t}\n\t}\n\tlong[] result = a;\n\tArrays.sort(result);\n\treturn result;\n}\n\
    /*\nReturn sorted unique elements for two arrays.\n    >>> unique([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [5L, 2L, 653L, 121L]\n\
    \    >>> unique([5L, 3L, 2L, 8L], [3L, 2L])\n    [8L, 2L, 3L]\nunittest\n{\n \
    \   alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6szaj21k.d(37): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6szaj21k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] result = new long[l1.length];\n\tfor (int i = 0; i < result.length;\
    \ ++i)\n\t\tresult[i] = l1[i];\n\tfor (int i = 0; i < result.length; ++i)\n\t\t\
    for (int j = i + 1; j < result.length; ++j)\n\t\t\tif (result[i] == l2[j])\n\t\
    \t\t{\n\t\t\t\tresult = sortSet(result);\n\t\t\t\tbreak;\n\t\t\t}\n\treturn result;\n\
    }\n/*\nReturn sorted unique common elements for two arrays.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ek2n_4w.d(26): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ek2n_4w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int len1 = l1.length;\n    int len2 = l2.length;\n    if (len1<len2)\n\
    \        throw new RuntimeException(\"Length mismatch\");\n    long l1[len1],\
    \ l2[len2];\n    l1 = copyOf(l1, len1);\n    l2 = copyOf(l2, len2);\n    Arrays.sort(l1,\
    \ len1);\n    Arrays.sort(l2, len2);\n    int i=0, j=0;\n    while(i<len1 && j<len2)\n\
    \    {\n        if (l1[i]==l2[j])\n        {\n            i++;\n            j++;\n\
    \        }\n        else if (l1[i]<l2[j])\n        {\n            i++;\n     \
    \   }\n        else\n        {\n            j++;\n        }\n    }\n    long ans[len1];\n\
    \    ans = copyOf(ans, len1);\n    if (i<len1)\n    {\n        ans = Arrays.copyOf(ans,\
    \ i);\n    }\n    else if (j<len2)\n    {\n        ans = Arrays.copyOf(ans, len2);\n\
    \        System.arraycopy(l2, j, ans, 0, len2-1);\n    }\n    return ans;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprepdib9h.d(18): Deprecation: instead of C-style syntax, use D-style
    syntax `long[len1] l1`

    /tmp/tmprepdib9h.d(18): Error: multiple declarations must have the same type,
    not `long[len1]` and `long[len2]`

    /tmp/tmprepdib9h.d(18): Deprecation: instead of C-style syntax, use D-style syntax
    `long[len2] l2`

    /tmp/tmprepdib9h.d(40): Deprecation: instead of C-style syntax, use D-style syntax
    `long[len1] ans`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprepdib9h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int l=l1.length;\n    int m=l2.length;\n    long[] common = new long[l];\n\
    \    \n    // sort arrays before finding common elements\n    for (int i=0;i<l;i++)\
    \ \n        if (l1[i]>l2[m])\n            swap(l1[i],l2[m]);\n    \n    // find\
    \ common elements with binary search\n    long start = 0;\n    long end = m-1;\n\
    \    int mIndex = 0;\n    while (mIndex<end) \n    {\n        int i = (start+end)/2;\n\
    \        if (l1[mIndex] == l2[m]) \n        {\n            common[mIndex] = l1[mIndex];\n\
    \            mIndex = mIndex + 1;\n        }\n        else if (l1[mIndex]<l2[m])\
    \ \n        {\n            end = i;\n        }\n        else \n        {\n   \
    \         start = i;\n        }\n    }\n    \n    // sort array again if necessary\n\
    \    if (l1.length > m) \n        sort(common);\n    \n    return common;\n}\n\
    </code>\n<|/ a dscore=2 tags=arrays,java,mergesort |>\n<| c |>\nthanks. i did\
    \ try to run this code but it says java.lang.ArrayIndexOutOfBoundsException. I\
    \ know this is because of the array lengths. Could you please help me fix it?\n\
    <|/ c |>\n<| c |>\nArrayIndexOutOfBoundsException probably occurred because your\
    \ arrays are of different sizes. Try to debug your code to see how it works. If\
    \ you still have issues, please post your code in your question.\n<|/ c |>\n<|\
    \ c |>\nI added some comments to your code. Please check if it is clear enough\
    \ now.\n<|/ c |>\n<| a dscore=2 tags=arrays,java,mergesort |>\n<code>\npackage\
    \ com.khan.khan.util;\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxaej6z1w.d(51): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxaej6z1w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long n = length(l1);\n    long[] l3 = new long[n];\n    for (int i\
    \ = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n  \
    \          if (l1[i] == l2[j])\n                l3[i] = l1[i];\n        }\n  \
    \  }\n    sort(l3);\n    return l3;\n}\n/*\nReturn unique elements in one array\
    \ which are not in the other array.\n    >>> unique([5L, 3L, 2L, 8L, 5L, 4L, 9L,\
    \ 653L, 121L])\n    [8L, 5L, 653L]\n    >>> unique([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L, 7L, 5L, 9L, 653L, 121L])\n    [1L, 2L, 3L, 5L, 7L, 8L, 9L, 121L]\n    \n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplhbbvrp7.d(27): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplhbbvrp7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n   var d = l1.length - l2.length;\n   long[] c = new long[d]; \n   for\
    \ (int i = 0; i <= l1.length - l2.length; i++) \n   {\n      c[i] = l1[i];\n \
    \  }\n   int j = 0;\n   for (int i = l1.length - l2.length; i > 0; i--) \n   {\n\
    \      c[j] = l2[i];\n      j++;\n   }\n   return c;\n}\n</code>\n<|/ a tags=algorithm,c#\
    \ |>\n<| c |>\nCan you please explain what you are doing here? It's hard to read\
    \ this kind of code\n<|/ c |>\n<| c |>\nIt's a modified version of [this](https://stackoverflow.com/questions/16706429/find-common-elements-in-two-arrays-in-c)\
    \ question for two arrays. It works for me, and it seems to be a lot simpler than\
    \ the more generic answers.\n<|/ c |>\n<| c |>\nOh, I see how you added a loop\
    \ from length 0 to l1.length - l2.length. It is a nice solution, though. I'm sure\
    \ it would still be faster though.\n<|/ c |>\n<| c |>\nI did not know about this\
    \ question and it's answers, they look like a real gem. I'm currently using your\
    \ solution but it is not very efficient with big arrays (more than 1000 elements).\
    \ I'm still looking for a better solution, though.\n<|/ c |>\n<| c |>\nIt's not\
    \ clear to me why you're choosing the solution that uses `HashSet` rather than\
    \ `Array.Sort`. It seems unlikely that they would be any more efficient, but perhaps\
    \ I'm missing something about how they're implemented. The documentation for both\
    \ mentions sorting first, which seems counterintuitive to me.\n<|/ c |>\n<| a\
    \ |>\nMy solution is really fast. It uses HashSet<T> which is an efficient implementation\
    \ of Set in .NET.\nIt first sorts both arrays and then finds the common elements\
    \ between them in a single loop.\nIt uses Array.Copy() to copy the sorted arrays.\
    \ So you only need to allocate one more array that is the size of the other array.\n\
    <code>\npublic static void FindCommon<T>(IList<T> a, IList<T> b, IList<T> c)\n\
    {\n    var aSort = a.ToArray();\n    var bSort = b.ToArray();\n    Array.Copy(aSort,\
    \ 0, bSort, 0, aSort.Length);\n    Array.Sort(bSort);\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpaq_15h34.d(28): Error: declaration expected, not `<`

    /tmp/tmpaq_15h34.d(31): Error: unterminated character constant

    /tmp/tmpaq_15h34.d(34): Error: unterminated character constant

    /tmp/tmpaq_15h34.d(37): Error: unterminated character constant

    /tmp/tmpaq_15h34.d(40): Error: unterminated character constant

    /tmp/tmpaq_15h34.d(40): Error: unterminated character constant

    /tmp/tmpaq_15h34.d(40): Error: unterminated character constant

    /tmp/tmpaq_15h34.d(43): Error: unterminated character constant

    /tmp/tmpaq_15h34.d(43): Error: unterminated character constant

    /tmp/tmpaq_15h34.d(43): Error: unterminated character constant

    /tmp/tmpaq_15h34.d(43): Error: unterminated character constant

    /tmp/tmpaq_15h34.d(54): Error: unexpected `(` in declarator

    /tmp/tmpaq_15h34.d(54): Error: basic type expected, not `0`

    /tmp/tmpaq_15h34.d(54): Error: found `0` when expecting `)`

    /tmp/tmpaq_15h34.d(54): Error: no identifier for declarator `Array.Copy(aSort,
    _error_)`

    /tmp/tmpaq_15h34.d(54): Error: semicolon expected following func'
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  long[] result = new long[l1.length];\n  for(long i = 0; i<l1.length;\
    \ ++i) {\n    long j=0;\n    for(; j < l2.length; ++j) {\n      if(l1[i] == l2[j])\n\
    \        break;\n    }\n    result[i] = l1[i];\n  }\n  return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpdayouuqd.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285c5]

    ??:? void tmpdayouuqd.__unittest_L25_C1() [0x42804a]

    ??:? void tmpdayouuqd.__modtest() [0x428344]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c67f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b512]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43079d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c4c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4e9]

    ??:? runModuleUnitTests [0x42c455]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a88]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong m1=0;\n\tlong m2=0;\n\t\n\tfor(int i = 0; i< l1.length;i++) {\n\t\
    \tif (m1==0) {\n\t\t\tm1 = l1[i];\n\t\t\tm2 = l2[i];\n\t\t\tcontinue;\n\t\t}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyam_xszi.d(23): Error: found `unittest` instead of statement

    /tmp/tmpyam_xszi.d(32): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyam_xszi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int size = l1.length;\n\
    \    long[] result = new long[size];\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkkqu47w2.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkkqu47w2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  if (l1 == l2) \n    return l1;\n  long[] result = new long[l1.length+l2.length];\n\
    \  int i = 0, j = 0;\n  while (i < l1.length || j < l2.length) \n  {\n    if (i\
    \ < l1.length && j < l2.length) \n    {\n      if (l1.elementAt(i) == l2.elementAt(j))\
    \ \n        { \n          result[j++] = l1.elementAt(i++); \n        } \n    \
    \  else if (l1.elementAt(i) < l2.elementAt(j)) \n        { \n          i++; \n\
    \        } \n      else \n        { \n          j++; \n        } \n    } \n  \
    \  else if (i < l1.length) \n    {\n      result[j++] = l1.elementAt(i++); \n\
    \    } \n    else if (j < l2.length) \n    {\n      result[j++] = l2.elementAt(j++);\
    \ \n    } \n    else \n    {\n      int k = i;\n      while (k<l1.length && l1.elementAt(k)\
    \ == l2.elementAt(k))\n        k++;\n      result[j++] = l1.elementAt(k);\n  \
    \    i++;\n    }\n  }\n  return result;\n}\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb0w9iuc5.d(22): Error: no property `elementAt` for type `long[]`

    /tmp/tmpb0w9iuc5.d(22): Error: no property `elementAt` for type `long[]`

    /tmp/tmpb0w9iuc5.d(24): Error: no property `elementAt` for type `long[]`

    /tmp/tmpb0w9iuc5.d(26): Error: no property `elementAt` for type `long[]`

    /tmp/tmpb0w9iuc5.d(26): Error: no property `elementAt` for type `long[]`

    /tmp/tmpb0w9iuc5.d(37): Error: no property `elementAt` for type `long[]`

    /tmp/tmpb0w9iuc5.d(41): Error: no property `elementAt` for type `long[]`

    /tmp/tmpb0w9iuc5.d(46): Error: no property `elementAt` for type `long[]`

    /tmp/tmpb0w9iuc5.d(46): Error: no property `elementAt` for type `long[]`

    /tmp/tmpb0w9iuc5.d(48): Error: no property `elementAt` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb0w9iuc5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    sort(l1);\n    sort(l2);\n    long[] l = new long[l1.length + l2.length];\n\
    \    long curr = l1.length;\n    int i, j;\n    while (curr < l.length) \n   \
    \ {\n        if (l1[curr] != l2[0]) \n        {\n            l[curr++] = l2[0];\n\
    \        }\n        else \n        {\n            for (j = 1; j < l1.length &&\
    \ l1[curr] == l2[j]; j++) \n            {\n                l[curr++] = l1[curr];\n\
    \            }\n        }\n    }\n    return l;\n}\n/*\nReturn sorted unique common\
    \ elements for two arrays of strings.\n    >>> common([\"Apple\", \"Banana\",\
    \ \"Cherry\", \"Durian\"], [ \"Banana\", \"Carrot\", \"Durian\", \"Eggplant\"\
    ])\n    [ \"Durian\", \"Eggplant\", \"Apple\", \"Cherry\" ]\n    >>> common([\"\
    Banana\", \"Carrot\", \"Durian\", \"Eggplant\"], [\"Banana\", \"Durian\", \"Apple\"\
    , \"Cherry\"])\n    [ \"Durian\", \"Apple\", \"Eggplant\" ]\nunittest\n{\n   \
    \ alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpld6nzxwx.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpld6nzxwx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long common = 0;\n    for (long i : l1) {\n        long j = 0;\n  \
    \      for (long k : l2) {\n            if (i == k) \n                j++;\n \
    \       }\n        if (j == 1) \n            common++;\n    }\n    if (common\
    \ == l1.length) \n        return l1;\n    if (common == l2.length)\n        return\
    \ l2;\n    long[] result = new long[common];\n    System.arraycopy(l1, 0, result,\
    \ 0, common);\n    System.arraycopy(l2, 0, result, common, l2.length);\n    return\
    \ result;\n}\n</code>\n<|/ a tags=java,arrays |>\n<| c |>\nWhat is the time complexity\
    \ of this solution?\n<|/ c |>\n<| c |>\nThis solution is O(n^2) but it can be\
    \ modified to be O(n * log(n)), I'll edit it later.\n<|/ c |>\n<| c |>\n: Time\
    \ complexity is O(N)\n<|/ c |>\n<| a tags=java,arrays |>\n<code>\nimport java.util.Arrays;\n\
    import java.util.List;\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp25dyi70q.d(15): Error: semicolon expected, not `:`

    /tmp/tmp25dyi70q.d(15): Error: expression expected, not `:`

    /tmp/tmp25dyi70q.d(15): Error: found `l1` when expecting `;` following `for` condition

    /tmp/tmp25dyi70q.d(17): Error: semicolon expected, not `:`

    /tmp/tmp25dyi70q.d(17): Error: expression expected, not `:`

    /tmp/tmp25dyi70q.d(17): Error: found `l2` when expecting `;` following `for` condition

    /tmp/tmp25dyi70q.d(33): Error: declaration expected, not `<`

    /tmp/tmp25dyi70q.d(39): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp25dyi70q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164046
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  int count = 0;\n  int i = 0;\n  int j = 0;\n  long[] results = new long[l1.length];\n\
    \  for (; i < l1.length && j < l2.length; i++, j++) {\n    if (l1[i] == l2[j])\
    \ {\n      count++;\n    }\n  }\n  while (i++ < l1.length) {\n    results[count++]\
    \ = l1[i];\n  }\n  while ((j += 2) > l2.length) {\n    results[count++] = l2[j];\n\
    \  }\n  return results;\n}\nunittest\n{\n    alias candidate = common;\n\n   \
    \ assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmpwvsq4zoi.d(27): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x4286f6]

    ??:? long[] tmpwvsq4zoi.common(long[], long[]) [0x427f73]

    ??:? void tmpwvsq4zoi.__unittest_L31_C1() [0x42806f]

    ??:? void tmpwvsq4zoi.__modtest() [0x4283c8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c6ff]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b592]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43081d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430ccc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4307a9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b569]

    ??:? runModuleUnitTests [0x42c4d5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functi'
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int i = 0, j = 0;\n    int l11 = 0, l22 = 0;\n    int l1 = l1.length,\
    \ l2 = l2.length;\n    long[] v = new long[l1 + l2];\n    long x = 0;\n    long\
    \ y = 0;\n    while( i < l1 ) \n    {\n        while( j < l2 ) \n        {\n \
    \           if( l1[i] == l2[j] )\n            {\n                i++; \n     \
    \           j++;\n                if( l1 == l2 )\n                    return v;\
    \ // trivial solution\n            }\n            else\n            {\n      \
    \          // not equal\n                l11++;\n                l22++;\n    \
    \        }\n        }\n        \n        // next element from l1 that is not equal\
    \ to current element of l2\n        x = (x + l1[i]) % l1;\n        v[++i] = x;\n\
    \        x = x * (l1 + l11 + l22) % l1;\n    }\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiwrdemgb.d(44): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiwrdemgb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    final long[] common = new long[64];\n    int i = 0;\n    int j = 0;\n\
    \    int l = 0;\n    for(int k = 0; k < 64; k++) \n    {\n        if(l1[i] < l2[j])\
    \ \n        {\n            common[l++] = l1[i++];\n        } \n        else \n\
    \        {\n            common[l++] = l2[j++];\n        }\n    }\n    for(int\
    \ k = 0; k < l; k++) \n    {\n        common[k] = 0;\n    }\n    l = 64;\n   \
    \ for(i = 0; i < 64; i++) \n    {\n        if(common[i]) \n        {\n       \
    \     j++;\n            common[j] = 1;\n            while(common[j] && j < 64)\
    \ \n            {\n                common[j] = 0;\n                j++;\n    \
    \        }\n        }\n    }\n    long[] result = new long[64];\n    for(i = 0;\
    \ i < 64; i++) \n    {\n        if(common[i]) \n        {\n            result[l++]\
    \ = i;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I doubt your algorithm would run in under a second for any pair of arrays of length\
    \ 64. `common` has length 64, which is about 3 million. My code has only a handful\
    \ of loops, and only three array accesses, which is about three orders of magnitude\
    \ faster.\n<|/ c |>\n<| c |>\n`common` has length 64 in both versions, in the\
    \ second version it starts at `i = 64` and ends at `l`, in the first version it\
    \ starts at `i = 26` and `l = 0`. It's not that common elements cannot be found\
    \ this way, it's that their order is significantly different from what you'd expect.\
    \ Your algorithm will return sorted unique common elements for arrays [1, 4, 3,\
    \ 34, 653, 2] and [1, 5, 3, 34, 653, 121], but it will not return [34, 653, 2].\
    \ You just happened to find a case where it's working correctly, so I didn't bother\
    \ with it.\n<|/ c |>\n<| c |>\nThe common algorithm should return the common elements\
    \ of two arrays, not their sorted order. The example you give doesn't match the\
    \ algorithm, and if you compare the code (which doesn't seem to work) with the\
    \ example code (which seems to work), you see that the second example is not working\
    \ correctly. Your algorithm will return the sorted order, but it will not return\
    \ the unique elements. A common algorithm would return the common elements (in\
    \ sorted order), without duplicates. A sample that would be returned by the algorithm\
    \ would be [1, 5, 3, 34, 653, 121], the unique elements of the second example\
    \ would be [34, 653, 2]\n<|/ c |>\n<| c |>\nI have added a modified version of\
    \ your algorith\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptea05w9d.d(57): Error: declaration expected, not `<`

    /tmp/tmptea05w9d.d(63): Error: unterminated character constant

    /tmp/tmptea05w9d.d(63): Error: unterminated character constant

    /tmp/tmptea05w9d.d(63): Error: unterminated character constant

    /tmp/tmptea05w9d.d(63): Error: unterminated character constant

    /tmp/tmptea05w9d.d(63): Error: unterminated character constant

    /tmp/tmptea05w9d.d(66): Error: unterminated character constant

    /tmp/tmptea05w9d.d(66): Error: unterminated character constant

    /tmp/tmptea05w9d.d(74): Error: declaration expected, not `assert`

    /tmp/tmptea05w9d.d(75): Error: declaration expected, not `assert`

    /tmp/tmptea05w9d.d(76): Error: declaration expected, not `assert`

    /tmp/tmptea05w9d.d(77): Error: declaration expected, not `assert`

    /tmp/tmptea05w9d.d(78): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptea05w9d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int n1 = l1.length;\n    int n2 = l2.length;\n    long[] result = new\
    \ long[n1 + n2];\n    long[] a1 = new long[n1];\n    long[] a2 = new long[n2];\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqkqvxfow.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqkqvxfow.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] l3 = new long[l1.length];\n\tint j = 0;\n\tfor (int i = 0; i <\
    \ l1.length; i++) {\n\t\tif (l2[j] == l1[i])\n\t\t\tl3[i] = l2[j];\n\t\telse\n\
    \t\t\tl3[i] = l1[i];\n\t\tj++;\n\t}\n\treturn l3;\n}\n// TODO: Optimize for speed\
    \ - use hashmap?\n/*\n Return array containing the most frequent elements of an\
    \ array that differ by no more than one element.\n Returns null if the array contains\
    \ no unique elements.\n */\nlong[] mostFrequent(long[] l)\n{\n\tlong[] result\
    \ = null;\n\tif (l.length == 0)\n\t\treturn result;\n\tArrays.sort(l);\n\tresult\
    \ = new long[l.length];\n\tint j = 0;\n\tfor (int i = 0; i < l.length; i++) {\n\
    \t\tif (j == 0)\n\t\t\tresult[i] = l[i];\n\t\telse\n\t\t\tif (l[i] == result[j])\
    \ {\n\t\t\t\tj++;\n\t\t\t\tif (j >= result.length)\n\t\t\t\t\tresult[j] = 0;\n\
    \t\t\t}\n\t\t\telse\n\t\t\t\tresult[j++] = l[i];\n\t}\n\treturn result;\n}\n/*\n\
    \ Return array containing the least frequent elements of an array that differ\
    \ by no more than one element.\n Returns null if the array contains no unique\
    \ elements.\n */\nlong[] leastFrequent(long[] l)\n{\n\tlong[] result = null;\n\
    \tif (l.length == 0)\n\t\treturn result;\n\tArrays.sort(l);\n\tresult = new long[l.length];\n\
    \tresult[0] = l[0];\n\tj = 1;\n\tfor (int i = 0; i < l.length; i++) {\n\t\tif\
    \ (l[i] == result[j]) {\n\t\t\tj++;\n\t\t\tif (j >= result.length)\n\t\t\t\tresult[j]\
    \ = 0;\n\t\t}\n\t\telse\n\t\t\tresult[j++] = l[i];\n\t}\n\treturn result;\n}\n\
    /*\n Return array containing the most frequent elements of an array that differ\
    \ by more than one element.\n Returns null if the array contains no unique elements.\n\
    \ */\nlong[] mostFrequentDiff(long[] l)\n{\n\tlong[] result = null;\n\tif (l.length\
    \ == 0)\n\t\treturn result;\n\tArrays.sort(l);\n\tresult = new long[l.length];\n\
    \tresult[0] = l[0];\n\tj = 1;\n\tfor (int i = 0; i < l.length; i++) {\n\t\tif\
    \ (j == 0)\n\t\t\tresult[i] = l[i];\n\t\telse\n\t\t\tif (l[i] != result[j - 1])\
    \ {\n\t\t\t\tj = 0;\n\t\t\t\tresult[j++] = l[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\t\
    if (l[i] == result[j]) {\n\t\t\t\t\tj++;\n\t\t\t\t\tif (j >= result.length)\n\t\
    \t\t\t\t\tresult[j] = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tresult[j++] = l[i];\n\
    \t}\n\treturn result;\n}\n/*\n Return array containing the least \nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmdhki5c0.d(108): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmdhki5c0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong len = length(l1);\n\tlong len2 = length(l2);\n\tlong[] res = new\
    \ long[len+len2];\n\tint i = 0;\n\tfor (int a=0; a<len; a++)\n\t{\n\t\tfor (int\
    \ b=0; b<len2; b++)\n\t\t{\n\t\t\tif (l1[a] == l2[b])\n\t\t\t{\n\t\t\t\tres[i]\
    \ = l1[a];\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgnav3owt.d(14): Error: undefined identifier `length`

    /tmp/tmpgnav3owt.d(15): Error: undefined identifier `length`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgnav3owt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = {0L};\n    for(int i=0; i<l1.length; i++) \n    {\n  \
    \      for(int j=0; j<l2.length; j++) \n        {\n            if(l1[i] == l2[j])\
    \ \n            {\n                res[res.length] = l1[i];\n                i\
    \ = l1.length - 1;\n                j = 0;\n            }\n            else\n\
    \            {\n                j = 0;\n            }\n        }\n    }\n    return\
    \ res;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not the optimal solution.\
    \ O(n\xB2 log n) complexity is quite an overestimation of n\xB2, especially on\
    \ large datasets. You only need one pass on both arrays, as long as there is an\
    \ element common in both arrays. This is still O(n\xB2).\n<|/ c |>\n<| c |>\n\
    You're right, although I believe it's possible to improve it further - but this\
    \ would require some more analysis. I guess that in some cases, this solution\
    \ could perform better - or maybe it could even be as fast as it can be.\n<|/\
    \ c |>\n<| c |>\nI updated my answer. I've tried to implement a slightly better\
    \ solution (though still not optimal). I believe it to be O(n).\n<|/ c |>\n<|\
    \ c |>\nI updated my answer as well. I've implemented a slightly better solution\
    \ (though still not optimal). I believe it to be O(n).\n<|/ c |>\n<| a |>\nI implemented\
    \ the algorithm you described. My code is below - though I believe there are more\
    \ efficient ways to implement it - perhaps using SIMD (since I used the C# libraries\
    \ instead of the native c++ libraries). My code is also below - but it does not\
    \ use any additional libraries.\nThe algorithm works like this:\nYou have an integer\
    \ array a. There is an integer array b where every element in b is also in a.\
    \ These arrays can be of any size.\nYou want the algorithm to return an array\
    \ c where every element of c is in b. But the order in c does not matter. If the\
    \ order is important, then you need a different algorithm.\nThe algorithm first\
    \ sorts both arrays by using mergesort. At first the algorithm will merge the\
    \ arrays and leave behind all the common elements. After that, it does a binary\
    \ search in b to find every element in c that should be there. If an element is\
    \ not in b, then it means that there is not an element that should be there. \n\
    The algorithm is as follows:\n<code>\n    public static int[] findCommon(int[]\
    \ a, int[] b) {\n        Array.Sort(a);\n        Array.Sort(b);\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxnz5s9gt.d(33): Error: declaration expected, not `<`

    /tmp/tmpxnz5s9gt.d(36): Error: char 0x00b2 not allowed in identifier

    /tmp/tmpxnz5s9gt.d(36): Error: character 0xb2 is not a valid token

    /tmp/tmpxnz5s9gt.d(36): Error: char 0x00b2 not allowed in identifier

    /tmp/tmpxnz5s9gt.d(36): Error: character 0xb2 is not a valid token

    /tmp/tmpxnz5s9gt.d(36): Error: char 0x00b2 not allowed in identifier

    /tmp/tmpxnz5s9gt.d(36): Error: character 0xb2 is not a valid token

    /tmp/tmpxnz5s9gt.d(39): Error: unterminated character constant

    /tmp/tmpxnz5s9gt.d(39): Error: unterminated character constant

    /tmp/tmpxnz5s9gt.d(42): Error: unterminated character constant

    /tmp/tmpxnz5s9gt.d(45): Error: unterminated character constant

    /tmp/tmpxnz5s9gt.d(57): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmpxnz5s9gt.d(57): Error: no identifier for declarator `Array.Sort(b)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxnz5s9gt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    var ls = new long[mathMax(std.maxint(l1.length), std.maxint(l2.length))];\n\
    \    var l3 = new long[ls.length];\n    var j = 0;\n    for(var i=0; i<l1.length;\
    \ i++) \n    {\n        if(l3[i]!=-1) continue;\n        l3[j] = l3[i]=l1[i];\
    \ \n        j++;\n    }\n    for(int i=0; i<l2.length; i++) \n    {\n        if(l3[i]!=-1)\
    \ continue;\n        l3[j] = l3[i]=l2[i]; \n        j++;\n    }\n    for(var i=0;\
    \ i<l3.length; i++) \n    {\n        if(l3[i]!=-1) continue;\n        l3[j]=l3[i]=l1[i];\
    \ \n        j++;\n    }\n    l3 = l3.slice(1, ls.length);\n    return l3;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp50mvppt6.d(14): Error: undefined identifier `var`

    /tmp/tmp50mvppt6.d(14): Error: undefined identifier `mathMax`

    /tmp/tmp50mvppt6.d(15): Error: undefined identifier `var`

    /tmp/tmp50mvppt6.d(16): Error: undefined identifier `var`

    /tmp/tmp50mvppt6.d(17): Error: undefined identifier `var`

    /tmp/tmp50mvppt6.d(29): Error: undefined identifier `var`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp50mvppt6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] l=new long[l1.length+l2.length];\n\tint i=0;\n\tint j=0;\n\twhile(i\
    \ < l.length && j<l2.length) {\n\t\tif (l1[i] == l2[j])\n\t\t\tl[i]=l1[i];\n\t\
    \telse j++;\n\t\ti++;\n\t}\n\treturn l;\n}\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpqolbhsgw.d(29): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285bd]

    ??:? void tmpqolbhsgw.__unittest_L25_C1() [0x428046]

    ??:? void tmpqolbhsgw.__modtest() [0x428340]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c677]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b50a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430795]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c44]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430721]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4e1]

    ??:? runModuleUnitTests [0x42c44d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a80]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] a = l1;\n    long[] b = l2;\n    int i = 0, j = 0;\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp24na6973.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp24na6973.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int[] i1 = sort(l1); // sort i1 using mergesort algorithm (O(nlogn),\
    \ n : lenght of i1, n : lenght of i2)\n    int[] i2 = sort(l2); // sort i2 using\
    \ mergesort algorithm (O(nlogn), n : lenght of i1, n : lenght of i2)\n    long[]\
    \ u = new long[i1.length]; // sorted unique elements of i1 and i2 \n    int i1Length,\
    \ i2Length;\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm68k9vs7.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm68k9vs7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length];\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n\
    \    for (int i = 0; i < result.length; ++i)\n    {\n        if(l1[i] == l2[i])\n\
    \            result[i] = l1[i];\n        else\n        {\n            int j;\n\
    \            for(j=i; j < result.length && l1[j] == l2[j]; j++)\n            {\n\
    \            }\n            result[i] = l1[j];\n        }\n    }\n    return result;\n\
    }\n/* \nReturn set of numbers from 0 to n-1 which have two distinct prime factors,\
    \ \nand each of the factors occurs once in both the lists given.\n    >>> find_unique_prime_factors([2,3,5,7,11],\
    \ [2,3,5,11], [2,3,11], [2,11], [3,11], [7,11])\n    [2, 3, 5, 7, 11]\n    >>>\
    \ find_unique_prime_factors([2,3,5,7,11], [2,11], [2,11], [3,11], [7,11])\n  \
    \  [2, 7, 11]\n    >>> find_unique_prime_factors([], [2,3,5,7,11], [2,3,11], [2,11],\
    \ [3,11], [7,11])\n    [2, 3, 5, 7, 11]\n    >>> find_unique_prime_factors([],\
    \ [2,3,5,7,11], [2,11], [2,11], [3,11], [7,11])\n    [2, 7, 11]\n    >>> find_unique_prime_factors([],\
    \ [2,3,5,7,11], [2,11], [2,11], [3,11], [7,11])\n    [2, 7, 11]\n    >>> find_unique_prime_factors([2,3,5,7,11],\
    \ [2,3,11], [2,11], [3,11], [7,11])\n    [2, 3, 5, 7, 11]\n    >>> find_unique_prime_factors([2,3,5,7,11],\
    \ [2,11], [2,11], [3,11], [7,11])\n    [2, 7, 11]\n    >>> find_unique_prime_factors([2,3,5,7,11],\
    \ [2,11], [2,11], [3,11], [7,11])\n    [2, 7, 11]\n    >>> find_unique_prime_factors([2,3,5,7,11],\
    \ [2,11], [2,11], [3,11], [7,11])\n    [2, 7, 11]\n*/\nlong[] find_unique_prime_factors(long[]\
    \ l1, long[] l2, long[] l3, long[] l4, long[] l5)\n{\n    long[] common;\n   \
    \ long[] common2;\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n    Arrays.sort(l3);\n\
    \    Arrays.sort(l4);\n    Arrays.sort(l5);\n    if(l1.length != l2.length ||\
    \ l1.length != l3.length || l1.length != \nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2qvrvrhe.d(64): Error: expression expected, not `unittest`

    /tmp/tmp2qvrvrhe.d(65): Error: found `{` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2qvrvrhe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    var n1 = l1.length;\n    var n2 = l2.length;\n    if (n1 == 0 || n2\
    \ == 0)\n        return null;\n    var maxLength = Math.min(n1, n2);\n    var\
    \ hashmap = new LongHashMap<long>(maxLength);\n    // iterate over the first array\n\
    \    for (var i = 0; i < n1; i++) {\n        hashmap.put(l1[i], l1[i]);\n    }\n\
    \    // iterate over the second array\n    for (var j = 0; j < n2; j++) {\n  \
    \      var exists = hashmap.get(l2[j]);\n        if (exists != null) {\n     \
    \       return exists;\n        }\n        hashmap.put(l2[j], l2[j]);\n    }\n\
    \    return null;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb5pnc6pw.d(19): Error: found `>` when expecting `.` following long

    /tmp/tmpb5pnc6pw.d(19): Error: found `(` when expecting identifier following `long`.

    /tmp/tmpb5pnc6pw.d(19): Error: semicolon expected, not `maxLength`

    /tmp/tmpb5pnc6pw.d(19): Error: found `)` when expecting `;` following statement

    /tmp/tmpb5pnc6pw.d(19): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb5pnc6pw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    var ans = new long[32]; // maximum size 32\n    var i1 = 0;\n    var\
    \ i2 = 0;\n    var j1 = 0; // i1[j1] is first common element with i2[j2]\n   \
    \ var j2 = 0; // j1[j2] is first common element with i2[j1]\n    while (j1 < 32\
    \ && i2 < 32) {\n        ans[j1++] = l1[i1++];\n        ans[j2++] = l2[i2++];\n\
    \    }\n    while (j1 < 32) {\n        ans[j1++] = l1[i1++];\n    }\n    while\
    \ (j2 < 32) {\n        ans[j2++] = l2[i2++];\n    }\n    return ans;\n}\n</code>\n\
    <|/ a tags=sorting,algorithm,performance dscore=1 |>\n<| c |>\nThis is a very\
    \ nice solution. Thank you! However, it has the same complexity as my original\
    \ algorithm, which is O(n*log(n)), and not O(n), which I would have expected to\
    \ be at least O(n).\n<|/ c |>\n<| c |>\nThe inner while loop can be simplified\
    \ to \"while(j1 < j2)\"\n<|/ c |>\n<| a tags=sorting,algorithm,performance dscore=1\
    \ |>\nI would have thought this would be a problem that has been solved before\
    \ in linear time. Maybe it would be worthwhile to try to research how to solve\
    \ this problem efficiently.\n<|/ a |>\n<| a |>\nI have an algorithm that is essentially\
    \ O(n). Just for fun, I have written it using recursion, and it is O(n), too.\n\
    <code>\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptottcmb7.d(31): Error: declaration expected, not `<`

    /tmp/tmptottcmb7.d(49): Error: declaration expected, not `assert`

    /tmp/tmptottcmb7.d(50): Error: declaration expected, not `assert`

    /tmp/tmptottcmb7.d(51): Error: declaration expected, not `assert`

    /tmp/tmptottcmb7.d(52): Error: declaration expected, not `assert`

    /tmp/tmptottcmb7.d(53): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptottcmb7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long count = 0;\n    for(int i = 0; i < l1.length; i++){\n        if(l1[l1[i]]\
    \ == l2[l2[i]]) count++;\n    }\n    long[] result = new long[count];\n    for(int\
    \ i = 0; i < result.length; i++){\n        if(l1[l1[i]] == l2[l2[i]]) result[i]\
    \ = l1[i];\n    }\n    Arrays.sort(result);\n    return result;\n}\n/*\nReturn\
    \ sorted unique common elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L,\
    \ 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>>\
    \ common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6yle1_xu.d(25): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6yle1_xu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length];\n    int j = 0;\n    for (int i =\
    \ 0; i < l1.length; i++) {\n        while (j < l2.length && l1[i] == l2[j]) j++;\n\
    \        if (j == l2.length)\n            res[i] = l1[i];\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1szskxra.d(27): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285bd]

    ??:? void tmp1szskxra.__unittest_L23_C1() [0x428042]

    ??:? void tmp1szskxra.__modtest() [0x42833c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c677]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b50a]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430795]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c44]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430721]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4e1]

    ??:? runModuleUnitTests [0x42c44d]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a80]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long common = 0;\n    for(int i = 0; i < l1.length; i++){\n       \
    \ int comp = l1.compareAt(i, l2, 0);\n        if(comp == 0){\n            common++;\n\
    \            l1 = l1.removeAt(i);\n            l2 = l2.removeAt(i);\n        }\n\
    \    }\n    long sum = 0;\n    for(int i = 0; i < l1.length; i++){\n        if(l1.getAt(i)\
    \ == l2.getAt(i)){\n            sum++;\n        }\n    }\n    long[] resArr =\
    \ new long[common];\n    int index = 0;\n    for(int i = 0; i < l1.length; i++){\n\
    \        if(l1.getAt(i) == l2.getAt(i)){\n            resArr[index++] = l1.getAt(i);\n\
    \        }\n    }\n    return resArr;\n}\n</code>\n<|/ a tags=arrays,algorithm,sorting\
    \ |>\n<| a dscore=1 tags=arrays,algorithm,sorting |>\nThis python code works,\
    \ provided no two elements have the same value:\n<code>\ndef common(l1,l2):\n\
    \    common = []\n    for i in l1:\n        if i not in l2 and i not in common:\n\
    \            common.append(i)\n    for j in l2:\n        if j not in l1 and j\
    \ not in common:\n            common.append(j)\n    return common\n</code>\n<|/\
    \ a |>\n<| c |>\nThis won't work with the example given in the question where\
    \ `common([1,3,5],[1,5])`\n<|/ c |>\n<| c |>\nThis answer is wrong. It does not\
    \ return the right answer for this example.\n<|/ c |>\n<| c |>\nThe question is\
    \ asking for unique elements not common elements.\n<|/ c |>\n<| c |>\nThe example\
    \ in the question was a mistake by OP who corrected it after I wrote the answer,\
    \ the code in this answer doesn't work anymore. `common([1,3,5],[1,5])` returns\
    \ `[1,3,5]` but OP wants `[5,3]` instead\n<|/ c |>\n<| c |>\nYour code will return\
    \ `[]` in that case, but OP wants `[1]` instead.\n<|/ c |>\n<| a tags=arrays,algorithm,sorting\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\
    import java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjh9_figw.d(38): Error: declaration expected, not `<`

    /tmp/tmpjh9_figw.d(55): Error: unterminated character constant

    /tmp/tmpjh9_figw.d(64): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjh9_figw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long common = l1[0];\n    for(int i = 1; i < l1.length; i++){\n   \
    \     if(l1[i] == common){\n            for(int j = 0; j < l2.length; j++){\n\
    \                if(l2[j] == common)\n                    return new long[] {common};\n\
    \            }\n        }\n    }\n    return new long[0];\n}\n</code>\n<|/ a tags=c#,arrays\
    \ |>\n<| c |>\nI don't understand what you mean. Do you mean I should sort the\
    \ list before I find the common ones? Or what do you mean?\n<|/ c |>\n<| c |>\n\
    , I have no idea what do you mean\n<|/ c |>\n<| c |>\nI mean the example I gave\
    \ in my question has some mistakes so if you take a closer look you will see that\
    \ it will return one element instead of two. I want to fix that so I can get correct\
    \ answer\n<|/ c |>\n<| c |>\n- I edited my answer, does it work for you now? I\
    \ have tested this with your example.\n<|/ c |>\n<| c |>\nI tested your solution\
    \ with the example and got correct results but when I test it with the code I\
    \ posted in my question, it gives me wrong results. I did some research and found\
    \ that in your solution, you do not care about the first element. What I mean\
    \ is that the first element is not important for my solution. I will appreciate\
    \ if you could help me with that as well\n<|/ c |>\n<| a dscore=0 |>\nA very simple\
    \ solution I came up with:\n<code>\npublic static void Main()\n{\n    string[]\
    \ input = {\n        \"foo\",\n        \"bar\",\n        \"foo\",\n        \"\
    baz\",\n        \"bar\"\n    };\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdmhmw43j.d(19): Error: found `{` when expecting `;` following `return`
    statement

    /tmp/tmpdmhmw43j.d(19): Error: found `}` when expecting `;` following statement

    /tmp/tmpdmhmw43j.d(19): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpdmhmw43j.d(25): Error: declaration expected, not `<`

    /tmp/tmpdmhmw43j.d(28): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdmhmw43j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length];\n    for(int i=0; i<l1.length; i++)\
    \ \n    {\n        for(int j=0; j<l2.length; j++) \n        {\n            if(l1[i]\
    \ == l2[j]) \n            {\n                res[res.length-1] = l1[i];\n    \
    \        }\n        }\n    }\n    return res;\n}\n</code>\n<|/ a tags=c# dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static IEnumerable<T> Intersect<T>(this\
    \ IEnumerable<T> first, IEnumerable<T> second)\n    {\n        List<T> firstList\
    \ = first.ToList();\n        List<T> secondList = second.ToList();\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3fj9xom_.d(27): Error: declaration expected, not `<`

    /tmp/tmp3fj9xom_.d(34): Error: no identifier for declarator `List`

    /tmp/tmp3fj9xom_.d(34): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3fj9xom_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  while (i<l1.length && j<l2.length)\
    \ {\n    if (l1[i] == l2[j]) {\n      i++;\n      j++;\n    } else if (l1[i] <\
    \ l2[j]) {\n      k++;\n      i++;\n    } else {\n      k++;\n      j++;\n   \
    \ }\n  }\n  while (i<l1.length) {\n    k++;\n    i++;\n  }\n  while (j<l2.length)\
    \ {\n    k++;\n    j++;\n  }\n  return Arrays.copyOf(new long[k], k);\n}\n</code>\n\
    <|/ a tags=arrays,java,sorting dscore=0 |>\n<| a |>\n<code>\nfunction common(arr1,\
    \ arr2) {\n  let map1 = arr1.reduce((obj, el) => { obj[el] = 1; return obj },\
    \ {});\n  let map2 = arr2.reduce((obj, el) => { obj[el] = 1; return obj }, {});\n\
    \  return [...new Set([...map1, ...map2]).values()];\n}\n</code>\n<|/ a tags=arrays,java,sorting\
    \ dscore=0 |>\n<| a tags=arrays,java,sorting |>\nI have written a method using\
    \ Java 8 streams which is almost in line with what I think the algorithm describes.\n\
    <code>\nimport java.util.Arrays;\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphnv7ueit.d(39): Error: declaration expected, not `<`

    /tmp/tmphnv7ueit.d(44): Error: declaration expected, not `return`

    /tmp/tmphnv7ueit.d(45): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmphnv7ueit.d(45): Error: found `,` instead of statement

    /tmp/tmphnv7ueit.d(46): Error: declaration expected, not `return`

    /tmp/tmphnv7ueit.d(47): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphnv7ueit.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length + l2.length];\n    for(int i=0;\
    \ i<l1.length; i++) {\n        if(l2[i] > l1[i]) \n            result[i] = l2[i];\n\
    \        else\n            result[i] = l1[i];\n    }\n    for(int j=0; j<l2.length;\
    \ j++) {\n        if(l2[j] > l1[j]) {\n            for(int k=j+1; k<l2.length\
    \ && l2[k] == l1[k]; k++) {\n                result[k] = result[k-1];\n      \
    \      }\n        }\n    }\n    return result.slice(0,result.length-1);\n}\n</code>\n\
    <|/ a tags=java,algorithm,arrays,c++,sorting |>\n<| c |>\nThanks for the code.\
    \ Is there any way to achieve complexity of O(logn) for this approach?\n<|/ c\
    \ |>\n<| c |>\nNope, since the algorithm is `O(n)`. Even with O(log n) additional\
    \ space, O(n log n) is still O(n).\n<|/ c |>\n<| c |>\nThe sort can be done in\
    \ O(n log n) time, but not the search, which can be done in O(n) time.  Since\
    \ each element of the array is less than the previous element, at most n comparisons\
    \ will be made.  So the total is O(n log n).\n<|/ c |>\n<| c |>\nIt doesn't seem\
    \ to work, at least for me. Try with input `[1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L]`. I get `[34L, 4L, 653L, 2L, 5L, 7L, 9L, 1L, 5L,\
    \ 653L, 121L]`, which is not correct as `653` should appear before `1`.\n<|/ c\
    \ |>\n<| c |>\nAh, I think I see what you mean.  I added a solution which does\
    \ work in O(n log n) time.\n<|/ c |>\n<| a tags=java,algorithm,arrays,c++,sorting\
    \ dscore=1 |>\nJava code (tested with your example):\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Collections;\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplssjvb9u.d(30): Error: declaration expected, not `<`

    /tmp/tmplssjvb9u.d(42): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplssjvb9u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n   long[] ans = new long[l1.length];\n   int i = 0, j = 0;\n   while (\
    \ i < l1.length &&  j < l2.length)\n   {\n      if (l1[i] < l2[j])\n      {\n\
    \         ans[j++] = l1[i++];\n      }\n      else\n      {\n         ans[j++]\
    \ = l2[j++];\n      }\n   }\n   return ans;\n}\n/*\nReturn unique common elements\
    \ for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2sbck0we.d(29): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2sbck0we.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] res = new long[l1.length+l2.length];\n    for(int i = 0; i <\
    \ res.length; ++i)\n        res[i] = -1;\n    Arrays.sort(l1);\n    Arrays.sort(l2);\n\
    \    for(int i = 0; i < (l1.length+l2.length); ++i)\n    {\n        if (l1[i]\
    \ == l2[i])\n        {\n            if (l1[i] == 0)\n                res[i] =\
    \ 0;\n            else\n                res[i] = l1[i];\n        }\n        else\n\
    \        {\n            if (l1[i] > l2[i])\n            {\n                res[i]\
    \ = l2[i];\n                res[l1.length+i] = l1[i];\n            }\n       \
    \     else\n            {\n                res[i] = l1[i];\n                res[l1.length+i]\
    \ = l2[i];\n            }\n        }\n    }\n    return res;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis code produces wrong result. See the comment I added on the\
    \ question for details.\n<|/ c |>\n<| a dscore=1 |>\nThis is my attempt at doing\
    \ this in O(n) time and O(1) space. As others have said, there are some problems\
    \ with the code, but I think this one does what you're looking for. I've used\
    \ the std.algorithms library as I've found it very useful, and haven't written\
    \ a line of code in OCaml for a while now so I'm not really sure how idiomatic\
    \ OCaml code is.\nBasically, you just sort the two arrays and then perform a binary\
    \ search on each array. I've left my code commented for anyone who wants to understand\
    \ the details. I'm sure you can easily translate it into OCaml syntax if you need.\n\
    <code>\nlet rec common_elements [] = \n    []\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn_nntocn.d(44): Error: declaration expected, not `<`

    /tmp/tmpn_nntocn.d(50): Error: unterminated character constant

    /tmp/tmpn_nntocn.d(50): Error: unterminated character constant

    /tmp/tmpn_nntocn.d(50): Error: unterminated character constant

    /tmp/tmpn_nntocn.d(50): Error: unterminated character constant

    /tmp/tmpn_nntocn.d(50): Error: unterminated character constant

    /tmp/tmpn_nntocn.d(51): Error: unterminated character constant

    /tmp/tmpn_nntocn.d(51): Error: unterminated character constant

    /tmp/tmpn_nntocn.d(59): Error: declaration expected, not `assert`

    /tmp/tmpn_nntocn.d(60): Error: declaration expected, not `assert`

    /tmp/tmpn_nntocn.d(61): Error: declaration expected, not `assert`

    /tmp/tmpn_nntocn.d(62): Error: declaration expected, not `assert`

    /tmp/tmpn_nntocn.d(63): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn_nntocn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tl1 = sort(l1);\n\tl2 = sort(l2);\n\tint i,j;\n\tlong[] l = new long[l1.length+l2.length];\n\
    \tfor (i=0; i<l1.length;i++)\n\t\tl[i]=l1[i];\n\tfor (i=0; i<l2.length;i++)\n\t\
    \tl[i+l1.length]=l2[i];\n\tsort(l);\n\treturn l;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpniixe1wz.d(14): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmpniixe1wz.d(15): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpniixe1wz.d(22): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpniixe1wz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] result = new long[l1.length];\n    for(int i = 0; i < l1.length;\
    \ i++) {\n        for(int j = 0; j < l2.length; j++) {\n            if(l1[i] ==\
    \ l2[j]) {\n                result[i] = l1[i];\n                break;\n     \
    \       }\n        }\n    }\n    return std.sort(result);\n}\n</code>\n<|/ a tags=java,arrays,algorithm\
    \ dscore=1 |>\n<| c |>\nYour solution is more efficient than mine but still it\
    \ is worst case time complexity\n<|/ c |>\n<| c |>\nThis solution is definitely\
    \ worst case complexity, but it's better than the most voted answer when compared\
    \ to the other solutions.\n<|/ c |>\n<| c |>\nIt has more efficient in memory\
    \ consumption, though it is still linear and worst case time complexity - O(n^2)\n\
    <|/ c |>\n<| a |>\nThis is how I solved my problem:\n<code>\npublic static long\
    \ common(Object[] a, Object[] b)\n{\n    long c = 0, d = 0;\n    for (Object x\
    \ : a)\n        for (Object y : b)\n            if (x.equals(y))\n           \
    \     c += 1;\n            for (Object z : b)\n                if (x.equals(z))\n\
    \                    d += 1;\n    return c + d;\n}\n</code>\n<|/ a dscore=1 tags=java,arrays,algorithm\
    \ |>\n<| c |>\nIt should be noted that the performance of this is not better than\
    \ the other answers, and it's still linear and worst case time complexity - O(n^2)\n\
    <|/ c |>\n<| a tags=java,arrays,algorithm |>\nMy code has one for loop which iterates\
    \ through first array and one for loop which iterates through second array.\n\
    <code>\npublic static void main(String[] args) {\n    int [] first = new int[10];\n\
    \    int [] second = new int[10];\n    for(int i = 0; i < 10; i++)\n        first[i]\
    \ = i;\n    for(int j = 1; j < 10; j++)\n        second[j] = j;\n    \n    for(int\
    \ i = 0; i < first.length; i++)\n    {\n        for(int j = 0; j < second.length;\
    \ j++)\n        {\n            if(first[i] == second[j])\n                System.out.println(first[i]);\n\
    \        }\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nYou can sort\
    \ the arrays and then compare.\n<|/ a tags=java,arrays,algorithm |>\n<| c |>\n\
    But that would take O(nlogn) time\n<|/ c |>\n<| c |>\nYes, it would take O(nlogn).\
    \ But the sort method will take O(n*log(n))\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo5gwfc_x.d(25): Error: declaration expected, not `<`

    /tmp/tmpo5gwfc_x.d(31): Error: unterminated character constant

    /tmp/tmpo5gwfc_x.d(42): Error: declaration expected, not `for`

    /tmp/tmpo5gwfc_x.d(46): Error: declaration expected, not `for`

    /tmp/tmpo5gwfc_x.d(49): Error: declaration expected, not `return`

    /tmp/tmpo5gwfc_x.d(50): Error: unrecognized declaration

    /tmp/tmpo5gwfc_x.d(54): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo5gwfc_x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tint i, j = 0;\n\tlong[] res = new long[l1.length];\n\tfor(i = 0, j =\
    \ 0; i < l1.length; i++)\n\t{\n\t\tif(l1[i] == l2[j]) {\n\t\t\tres[i] = l1[i];\n\
    \t\t\tj++;\n\t\t} else\n\t\t{\n\t\t\tif(j == 0)\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t\
    \tres[i] = l1[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tj--;\n\t\t\t\tres[i]\
    \ = l2[j];\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\t\n/*\nReturn unique common\
    \ elements for two arrays.\n    >>> uniqueCommon([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> uniqueCommon([5L,\
    \ 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpohtzix10.d(38): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpohtzix10.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int i = 0, j = 0;\n    long[] out = new long[l1.length+l2.length];\n\
    \    while (i < l1.length && j < l2.length) {\n        if (l1[i] < l2[j]) {\n\
    \            out[i++] = l1[i++];\n        } else if (l1[i] == l2[j]) {\n     \
    \       out[i++] = l1[i++];\n            out[j++] = l2[j++];\n        } else {\n\
    \            out[i++] = l2[j++];\n        }\n    }\n    while (i < l1.length)\
    \ {\n        out[i++] = l1[i++];\n    }\n    while (j < l2.length) {\n       \
    \ out[j++] = l2[j++];\n    }\n    return out;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=collections,java dscore=2 |>\nThis code will return the common elements\
    \ between two arrays and store the result in the third array.\n<code>\npublic\
    \ class CommonElements\n{\n   public static void main(String[] args)\n   {\n \
    \     int[] a = {1,2,3,4,5,6};\n      int[] b = {4,5,6,7,8,9,0};\n      \n   \
    \   int[] c = new int[a.length];\n      \n      int i,j;\n      \n      for(i=0;i<a.length;i++)\n\
    \      {\n         for(j=0;j<b.length;j++)\n         {\n            if(a[i]==b[j])\n\
    \            {\n               c[i]=b[j];\n               break;\n           \
    \ }\n         }\n      }\n      \n      for(int k=0;k<c.length;k++)\n      {\n\
    \         System.out.println(c[k]);\n      }\n   }\n}\n</code>\n<|/ a |>\n<| a\
    \ dscore=2 |>\n<code>\npublic static int[] common(int[] a, int[] b) {\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] l = new long[256];\n    int i = 0;\n    int j = 0;\n    while(i\
    \ < l1.length && j < l2.length) \n    {\n        if(l1[i] < l2[j]) {\n       \
    \     l[i++] = l1[i];\n        }\n        else {\n            l[i++] = l2[j];\n\
    \        }\n        j++;\n    }\n    while(i < l1.length) \n    {\n        l[i++]\
    \ = l1[i];\n    }\n    while(j < l2.length) \n    {\n        l[i++] = l2[j];\n\
    \    }\n    std.arraysort(l);\n    return l;\n}\n</code>\n<|/ a dscore=5 |>\n\
    <| c |>\n`common` and `sorted` aren't in the standard library.\n<|/ c |>\n<| c\
    \ |>\nThe `common` function is just a translation of the `unique` function from\
    \ the `std` library.\n<|/ c |>\n<| c |>\nHmm. Good point. I thought this was supposed\
    \ to be a self-answered question. Sorry about that.\n<|/ c |>\n<| c |>\nI'm sorry.\
    \ I was looking at the answer to [this question](http://stackoverflow.com/questions/9193262/c-code-to-find-the-largest-common-element-array-not-sorting-it)\
    \ and thought that it was just a translation from some `std.typecons` function,\
    \ rather than the actual `common` function. I was wrong. Thanks for making me\
    \ aware.\n<|/ c |>\n<| c |>\n`l2.length` should be `l1.length`\n<|/ c |>\n<| a\
    \ |>\nI wrote an example for comparing two arrays with the following results:\n\
    <code>\n[6, 4, 7, 2]  --> [6, 7, 4, 2]\n[1, 2, 2, 3]  --> [1, 2, 3]\n[2, 4, 5,\
    \ 3]  --> [4, 5]\n</code>\nHere's the code for it:\n<code>\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6po6561i.d(38): Error: declaration expected, not `<`

    /tmp/tmp6po6561i.d(41): Error: unterminated character constant

    /tmp/tmp6po6561i.d(50): Error: unterminated character constant

    /tmp/tmp6po6561i.d(62): Error: unterminated character constant

    /tmp/tmp6po6561i.d(68): Error: declaration expected, not `assert`

    /tmp/tmp6po6561i.d(69): Error: declaration expected, not `assert`

    /tmp/tmp6po6561i.d(70): Error: declaration expected, not `assert`

    /tmp/tmp6po6561i.d(71): Error: declaration expected, not `assert`

    /tmp/tmp6po6561i.d(72): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6po6561i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong temp;\n\tfor (int i = 0; i < l1.length; i++) {\n\t\tfor (int j =\
    \ 0; j < l2.length; j++) {\n\t\t\tif (l1[i] != l2[j]) {\n\t\t\t\tif (l1[i] < l2[j])\
    \ temp = l1[i];\n\t\t\t\telse temp = l2[j];\n\t\t\t\tif (temp > 0) {\n\t\t\t\t\
    \tl1[l1.length - 1]++;\n\t\t\t\t\tl2[l2.length - 1]++;\n\t\t\t\t\tl1[i]++;\n\t\
    \t\t\t\tl2[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn l1;\n}\n/*\nReturn\
    \ sorted unique common elements for two arrays in sorted order.\n    >>> common([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L,\
    \ 653L]\n    >>> common([5L, 3L, 2L, 8L], [3L, 2L])\n    [2L, 3L]\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpslo42bbg.d(31): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpslo42bbg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong [] c1 = new long[10000], c2 = new long[10000], i, j, k, l;\n\tbool\
    \ found;\n\t\n\tk = 0;\n\tfor (i = 0; i < l1.length && k < c1.length; i++) \n\t\
    {\n\t\tif (l1[i] > c2[k]) \n\t\t{\n\t\t\tc1.length = k;\n\t\t\tc2 = new long[k];\n\
    \t\t\tk = 0;\n\t\t}\n\t\tfound = false;\n\t\tfor (j = 0; j < l2.length && k <\
    \ c2.length; j++) \n\t\t{\n\t\t\tif (l2[j] == c1[k]) \n\t\t\t{\n\t\t\t\tfound\
    \ = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) \n\t\t{\n\t\t\tc1.length\
    \ = k;\n\t\t\tc2 = new long[k];\n\t\t\tk = 0;\n\t\t}\n\t\t\n\t\tc2[k] = l1[i];\n\
    \t\tk++;\n\t}\n\tif (k < c1.length) \n\t{\n\t\tc1.length = k;\n\t}\n\t\n\tk =\
    \ 0;\n\tfor (i = 0; i < l2.length && k < c2.length; i++) \n\t{\n\t\tif (l2[i]\
    \ > c1[k]) \n\t\t{\n\t\t\tc2.length = k;\n\t\t\tc1 = new long[k];\n\t\t\tk = 0;\n\
    \t\t}\n\t\tfound = false;\n\t\tfor (j = 0; j < l1.length && k < c1.length; j++)\
    \ \n\t\t{\n\t\t\tif (l2[j] == c1[k]) \n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\t\
    break;\n\t\t\t}\n\t\t}\n\t\tif (!found) \n\t\t{\n\t\t\tc2.length = k;\n\t\t\t\
    c1 = new long[k];\n\t\t\tk = 0;\n\t\t}\n\t\t\n\t\tc1[k] = l2[i];\n\t\tk++;\n\t\
    }\n\tif (k < c2.length) \n\t{\n\t\tc2.length = k;\n\t}\n\t\n\treturn c1;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcmnzxc87.d(17): Error: cannot implicitly convert expression `0`
    of type `int` to `long[]`

    /tmp/tmpcmnzxc87.d(18): Error: cannot implicitly convert expression `0` of type
    `int` to `long[]`

    /tmp/tmpcmnzxc87.d(18): Error: incompatible types for `(i) < (l1.length)`: `long[]`
    and `ulong`

    /tmp/tmpcmnzxc87.d(18): Error: incompatible types for `(k) < (c1.length)`: `long[]`
    and `ulong`

    /tmp/tmpcmnzxc87.d(18): Error: `i` is not a scalar, it is a `long[]`

    /tmp/tmpcmnzxc87.d(20): Error: cannot implicitly convert expression `i` of type
    `long[]` to `ulong`

    /tmp/tmpcmnzxc87.d(20): Error: cannot implicitly convert expression `k` of type
    `long[]` to `ulong`

    /tmp/tmpcmnzxc87.d(22): Error: cannot implicitly convert expression `k` of type
    `long[]` to `ulong`

    /tmp/tmpcmnzxc87.d(23): Error: cannot implicitly convert expression `k` of type
    `long[]` to `ulong`

    /tmp/tmpcmnzxc87.d(24): Error: cannot implicitly convert expression `0` of type
    `int` to `long[]`

    /tmp/tmpcmnzxc87.d(27): Error: cannot implicitly convert expression `'
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long common = 0;\n    int n = l1.length;\n    int m = l2.length;\n\
    \    for(int i = 0; i < m; i++){\n        for(int j = 0; j < n; j++){\n      \
    \      if(l1[i] < l2[j] && (l1[i] != 0 || (l2[j] != 0 && l1[j] == l2[j]))){\n\
    \                common = l1[i];\n                break;\n            }\n    \
    \    }\n    }\n    long[] ns = new long[m];\n    ns[0] = common;\n    for (int\
    \ i = 0; i < n; i++){\n        for(int j = 0; j < m; j++){\n            if(l1[i]\
    \ == l2[j]){\n                ns[i+1] = l1[i];\n                break;\n     \
    \       }\n        }\n    }\n    return ns;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw2c2_4kv.d(15): Error: cannot implicitly convert expression `l1.length`
    of type `ulong` to `int`

    /tmp/tmpw2c2_4kv.d(16): Error: cannot implicitly convert expression `l2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw2c2_4kv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tvar l1 = l1 || l1;\n\tvar l2 = l2 || l2;\n\tvar l3 = new long[l1.length+l2.length];\n\
    \tvar j = 0;\n\t\n\twhile (j < l1.length && j < l2.length) \n\t{\n\t\tif (l1[j]\
    \ == l2[j]) \n\t\t{\n\t\t\tl3[j++] = l1[j];\n\t\t} \n\t\telse \n\t\t{\n\t\t\t\
    break;\n\t\t}\n\t}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_e25v8s3.d(30): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_e25v8s3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    long[] cL1 = l1;\n    long[] cL2 = l2;\n    long[] cResult = new long[l1.length];\n\
    \    long current;\n    for (int i = 0; i < l1.length; i++) {\n        if (l1.length\
    \ > 1) {\n            current = cL1[i];\n            cL1[i] = cL2[i];\n      \
    \      cL2[i] = current;\n        }\n        if (l2.length > 1) {\n          \
    \  current = cL2[i];\n            cL2[i] = cL1[i];\n            cL1[i] = current;\n\
    \        }\n    }\n    Arrays.sort(cL1);\n    Arrays.sort(cL2);\n    for (int\
    \ i = 0; i < l1.length; i++) {\n        cResult[i] = cL1[i];\n    }\n    for (int\
    \ i = 0; i < l2.length; i++) {\n        cResult[l1.length+i] = cL2[i];\n    }\n\
    \    return cResult;\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=arrays,algorithm,java,sorting\
    \ |>\n<code>\npublic static int[] common(int[] a, int[] b) {\n    HashMap<Integer,\
    \ Integer> map = new HashMap<Integer, Integer>();\n    int[] result = new int[a.length];\n\
    \    int counter = 0;\n    for (int i = 0; i < a.length; i++) {\n        if (!map.containsKey(a[i]))\
    \ {\n            map.put(a[i], 0);\n        }\n        int j = map.get(a[i]);\n\
    \        if (b[j] == a[i]) {\n            counter++;\n        }\n    }\n    for\
    \ (int i = 0; i < b.length; i++) {\n        if (!map.containsKey(b[i])) {\n  \
    \          map.put(b[i], 0);\n        }\n        int j = map.get(b[i]);\n    \
    \    if (counter == j && map.get(a[i]) == j) {\n            result[counter] =\
    \ a[i];\n            counter++;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI think this is wrong. `common([1], [2])` should be `common([1,\
    \ 2], [2])`, but your code returns `[2]` instead of `[1, 2]`\n<|/ c |>\n<| c |>\n\
    It works correctly, if input arrays are sorted.\n<|/ c |>\n<| c |>\nBut `common([1,2],[1,2])`\
    \ should be `common([1,2],[2])`, but your code returns `[2]` instead of `[1,2]`\n\
    <|/ c |>\n<| c |>\nYou're right, i missed that one. Thanks for pointing it out.\n\
    <|/ c |>\n<| a tags=arrays,algorithm,java,sorting dscore=0 |>\n<code>\npublic\
    \ static void main(String args[])\n{\n        int[] a = {1, 3, 6};\n        int[]\
    \ b = {2, 5, 6};\n        System.out.println(\"Common elements:\"+common(a,b));\n\
    \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps4efmpry.d(40): Error: declaration expected, not `<`

    /tmp/tmps4efmpry.d(48): Error: declaration expected, not `for`

    /tmp/tmps4efmpry.d(48): Error: no identifier for declarator `i`

    /tmp/tmps4efmpry.d(48): Error: declaration expected, not `<`

    /tmp/tmps4efmpry.d(48): Error: no identifier for declarator `i`

    /tmp/tmps4efmpry.d(48): Error: declaration expected, not `++`

    /tmp/tmps4efmpry.d(51): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps4efmpry.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] result = new long[l1.length];\n\tfor (int i = 0; i < l1.length;\
    \ i++) \n\t{\n\t\tfor (int j = 0; j < l2.length; j++)\n\t\t{\n\t\t\tif (l1[i]\
    \ == l2[j])\n\t\t\t{\n\t\t\t\tresult[i] = l1[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn result;\n}\n/*\nReturns true if the two arrays are equal.\n \
    \   >>> compare([4L, 3L, 4L, 2L], [4L, 3L, 2L, 4L])\n    True\n*/\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp24b_gxc2.d(37): unittest failure

    ----------------

    ??:? _d_unittestp [0x4285c5]

    ??:? void tmp24b_gxc2.__unittest_L33_C1() [0x42804e]

    ??:? void tmp24b_gxc2.__modtest() [0x428348]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c67f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b512]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43079d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430c4c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430729]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4e9]

    ??:? runModuleUnitTests [0x42c455]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428a88]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n    int n = l1.length;\n    int m = l2.length;\n    long[] result = new\
    \ long[n];\n    int j = 0;\n    int i;\n    for (int k = 0; k < m; k++)\n    {\n\
    \        for (i=0; i < n; i++)\n        {\n            if (l1[i] == l2[k])\n \
    \           {\n                result[j++] = l1[i];\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwrsyh3iy.d(14): Error: cannot implicitly convert expression `l1.length`
    of type `ulong` to `int`

    /tmp/tmpwrsyh3iy.d(15): Error: cannot implicitly convert expression `l2.length`
    of type `ulong` to `int`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwrsyh3iy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n  var l3 = new long[l1.length];\n  for(int i = 0; i < l1.length; i++) \n\
    \  {\n    for(int j = 0; j < l2.length; j++)\n    {\n      if(l1[i] == l2[j])\n\
    \        l3[i] = l1[i];\n    }\n  }\n  return l3;\n}\n</code>\n<|/ a tags=algorithm,arrays\
    \ dscore=4 |>\n<| c |>\nNice answer. Especially the part where you explain how\
    \ this works, it makes it easier to understand for newbies like me. Thanks!\n\
    <|/ c |>\n<| c |>\nI find it strange that you use `l1.length` in the inner loop\
    \ when that array can change size since you just copy the length of `l1`.\n<|/\
    \ c |>\n<| c |>\nIn fact, my code can be replaced by this one line: \nvar l3=\
    \ l1.Intersect(l2).ToArray();\n<|/ c |>\n<| c |>\nNot sure what you are talking\
    \ about. `l3` isn't changing in my code, so I don't really see how it could change.\
    \ Are you referring to the `var`? The `ToArray` method returns a new array, so\
    \ that line is just converting a sequence of intersected `long`s to a sequence\
    \ of their `ToString` equivalents.\n<|/ c |>\n<| c |>\nYes, the var l3. Apologies\
    \ for my unclear explanation!\n<|/ c |>\n<| a dscore=4 |>\nYou can use the merge\
    \ function from System.Linq:\n<code>\nvar myArray = new[] {1, 4, 3, 1, 3, 6, 3};\n\
    var myArray2 = new[] {5, 7, 1, 5, 9, 653};\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppnft56nt.d(25): Error: declaration expected, not `<`

    /tmp/tmppnft56nt.d(36): Error: declaration expected, not `<`

    /tmp/tmppnft56nt.d(38): Error: unterminated character constant

    /tmp/tmppnft56nt.d(38): Error: unterminated character constant

    /tmp/tmppnft56nt.d(47): Error: basic type expected, not `[`

    /tmp/tmppnft56nt.d(47): Error: semicolon expected, not `{`

    /tmp/tmppnft56nt.d(47): Error: declaration expected, not `{`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppnft56nt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] l3 = new long[l1.length];\n\tint i;\n\tfor(i = 0; i < l1.length;\
    \ i++) \n\t{\n\t\tint j;\n\t\tfor(j = 0; j < l2.length; j++) \n\t\t{\n\t\t\tif(l1[i]\
    \ == l2[j] && l1[i] != 0) \n\t\t\t{\n\t\t\t\tl3[i] = l1[i];\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t}\n\t\tif(j == l2.length) \n\t\t{\n\t\t\tl3[i] = l1[i];\n\t\t}\n\t\
    }\n\treturn l3;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp7qcmzzbt.d(38): unittest failure

    ----------------

    ??:? _d_unittestp [0x428655]

    ??:? void tmp7qcmzzbt.__unittest_L34_C1() [0x4280de]

    ??:? void tmp7qcmzzbt.__modtest() [0x4283d8]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c70f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5a2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43082d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430cdc]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x4307b9]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b579]

    ??:? runModuleUnitTests [0x42c4e5]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b18]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] ret = new long[l1.length];\n\tint i = 0, j = 0;\n\twhile (i <\
    \ l1.length && j < l2.length) \n\t{\n\t\tif (l1[i] == l2[j]) \n\t\t{\n\t\t\tret[j]\
    \ = l1[i]; \n\t\t\t++j;\n\t\t} \n\t\telse \n\t\t{\n\t\t\t++i;\n\t\t}\n\t}\n\t\n\
    \twhile (i < l1.length)\n\t{\n\t\tret[j++] = l1[i];\n\t\t++i;\n\t}\n\twhile (j\
    \ < l2.length)\n\t{\n\t\tret[i++] = l2[j];\n\t\t++j;\n\t}\n\treturn ret;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.RangeError@/tmp/tmp2boeyzpt.d(36): Range violation

    ----------------

    ??:? _d_arrayboundsp [0x428756]

    ??:? long[] tmp2boeyzpt.common(long[], long[]) [0x427fa3]

    ??:? void tmp2boeyzpt.__unittest_L41_C1() [0x4280cf]

    ??:? void tmp2boeyzpt.__modtest() [0x428428]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c75f]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5f2]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43087d]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430d2c]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430809]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b5c9]

    ??:? runModuleUnitTests [0x42c535]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functi'
  stdout: ''
  timestamp: 1660164047
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two arrays.\n    >>> common([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L,\
    \ 7L, 1L, 5L, 9L, 653L, 121L])\n    [1L, 5L, 653L]\n    >>> common([5L, 3L, 2L,\
    \ 8L], [3L, 2L])\n    [2L, 3L]\n\n    \n*/\nlong[] common(long[] l1, long[] l2)\
    \ \n{\n\tlong[] res = new long[1000];\n\tint i = 0;\n\twhile (l1.length > 0 &&\
    \ l2.length > 0) {\n\t\tif (l1.length > l2.length) {\n\t\t\tres[i] = l1[l1.length\
    \ - 1];\n\t\t\ti++;\n\t\t\tl1.pop();\n\t\t} else {\n\t\t\tres[i] = l2[l2.length\
    \ - 1];\n\t\t\ti++;\n\t\t\tl2.pop();\n\t\t}\n\t}\n\twhile (l1.length > 0) res[i++]\
    \ = l1[l1.length - 1];\n\twhile (l2.length > 0) res[i++] = l2[l2.length - 1];\n\
    \treturn res;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp27msh1fz.d(20): Error: no property `pop` for type `long[]`

    /tmp/tmp27msh1fz.d(24): Error: no property `pop` for type `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp27msh1fz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164047
