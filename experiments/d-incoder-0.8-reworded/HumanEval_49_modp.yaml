name: HumanEval_49_modp
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn 2^n modulo p (be aware\
  \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n\
  \    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
  \ 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n"
tests: "unittest\n{\n    alias candidate = modp;\n\n    assert(candidate(3L, 5L) ==\
  \ 3L);\n    assert(candidate(1101L, 101L) == 2L);\n    assert(candidate(0L, 101L)\
  \ == 1L);\n    assert(candidate(3L, 11L) == 8L);\n    assert(candidate(100L, 101L)\
  \ == 1L);\n    assert(candidate(30L, 5L) == 4L);\n    assert(candidate(31L, 5L)\
  \ == 3L);\n}\nvoid main(){}"
completions: ["{\n\tlong q;\n\tif (p == 0)\n\t\treturn 1;\n\tfor (q = 0; q < n; q++)\n\
    \t\tif (p & 1)\n\t\t\tp = p / 2 ^ q;\n\t\telse\n\t\t\tp = p / 2 ^ q + 1;\n\treturn\
    \ p;\n}", "{\n\tlong q, r;\n\t\n\t/* compute n^r and r mod p */\n\tq = modl(n,\
    \ p);\n\tr = modl(q, p);\n\t\n\t/* compute r^2 mod p */\n\tq = modl(r, p);\n\t\
    \n\t/* compute r^3 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^4 mod p */\n\
    \tq = modl(q, p);\n\t\n\t/* compute r^5 mod p */\n\tq = modl(q, p);\n\t\n\t/*\
    \ compute r^6 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^7 mod p */\n\tq\
    \ = modl(q, p);\n\t\n\t/* compute r^8 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute\
    \ r^9 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^10 mod p */\n\tq = modl(q,\
    \ p);\n\t\n\t/* compute r^11 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^12\
    \ mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^13 mod p */\n\tq = modl(q, p);\n\
    \t\n\t/* compute r^14 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^15 mod p\
    \ */\n\tq = modl(q, p);\n\t\n\t/* compute r^16 mod p */\n\tq = modl(q, p);\n\t\
    \n\t/* compute r^17 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^18 mod p */\n\
    \tq = modl(q, p);\n\t\n\t/* compute r^19 mod p */\n\tq = modl(q, p);\n\t\n\t/*\
    \ compute r^20 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^21 mod p */\n\t\
    q = modl(q, p);\n\t\n\t/* compute r^22 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute\
    \ r^23 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^24 mod p */\n\tq = modl(q,\
    \ p);\n\t\n\t/* compute r^25 mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^26\
    \ mod p */\n\tq = modl(q, p);\n\t\n\t/* compute r^27 mod p */\n\tq = modl(q, p);\n\
    \t\n\t/* compute r^28 mod p */", "{\n\tlong ppow = pow(p,n);\n\tlong res = (n^ppow)\
    \ % p;\n\tif (res == 0 && p != 1 && ppow != 1) {\n\t\t//assert(res!=0)\n\t\tint\
    \ diff = res%p;\n\t\tlong a = ppow - diff;\n\t\tlong b = ppow - diff;\n\t\tlong\
    \ c = ppow - diff;\n\t\tlong d = ppow - diff;\n\t\tlong ppowa = pow(p,a);\n\t\t\
    long ppowa = pow(p,b);\n\t\tlong ppowb = pow(p,c);\n\t\tlong ppowc = pow(p,d);\n\
    \t\tlong ppowd = pow(p,n%p);\n\t\tres = (n^(a*ppowa+b*ppowa+c*ppowb+d*ppowc+n%p*ppowd))\
    \ % p;\n\t}\n\treturn res;\n}\n'''", "{\n    if (n == 0L)\n        return n; //\
    \ 0^0 = 1\n    \n    // Handle special cases\n    if (p == 0L)\n        return\
    \ 1;\n    if (p == -1L)\n        return n;\n    \n    // Test for common case\n\
    \    if (n == p)\n        return n;\n    \n    // Test for power of 2\n    if\
    \ (p & (p - 1))\n        return modpow2n(n, p);\n    \n    // Compute result =\
    \ 1L - n\n    long res = 1L - n;\n    \n    // Test for a power of 2 larger than\
    \ the modulus\n    if (p & p)\n        res = modpow2n(n, p);\n    \n    return\
    \ res;\n}\n/*\nReturn n^p modulo p (be aware of numerics).\n    >>> modpow2(3L,\
    \ 5L)\n    3L\n    >>> modpow2(1101L, 101L)\n    2L\n    >>> modpow2(0L, 101L)\n\
    \    1L\n    >>> modpow2(3L, 11L)\n    8L\n    >>> modpow2(100L, 101L)\n    1L\n\
    \    \n*/\nlong modpow2(long n, long p) \n{\n    if (n == 0L)\n        return\
    \ n; // 0^0 = 1\n    \n    // Handle special cases\n    if (p == 0L)\n       \
    \ return n;\n    if (p == -1L)\n        return 1;\n    \n    // Test for common\
    \ case\n    if (n == p)\n        return n;\n    \n    // Test for power of 2\n\
    \    if (p & (p - 1))\n        return modpow2n(n, p);\n    \n    // Compute result\
    \ = 1L - n\n    long res = 1L - n;\n    \n    // Test for a power of 2 larger\
    \ than the modulus\n    if (p & p)\n        res = modpow2n(n, p);\n    \n    return\
    \ res;\n}\n/*\nReturn n^p modulo p (be aware of numerics).\n    >>> modpow3(3L,\
    \ 5L)\n    3L\n    >>> modpow3(1101L, 101L)\n    2L\n    >>> modpow3(0L, 101L)\n\
    \    1L\n    >>> modpow3(3L, 11L)\n    8L\n    >>> modpow3(100L, 101L)\n    1L\n\
    \    \n*/\nlong modpow3(long n, long p) \n{\n    if (n == 0L)\n        return\
    \ n; // 0^0 = 1\n    \n    // Handle special cases\n    if (p == 0L)\n       \
    \ return n;\n    if (p == -1L)\n        return 1;\n    \n    // Test for common\
    \ case\n    if (n == p)\n        return n;\n    \n    // Test for power of 2\n\
    \    if (p & (p - 1))\n        return modpow2n(n, ", "{\n\tlong d, d;\n\td = n\
    \ % p;\n\tif (d == 0) return n;\n\tif (d > 0) return n % p;\n\treturn (n % p +\
    \ p) % p;\n}", "{\n\tlong x, y, z;\n\tlong xmodp, ymodp;", "{\n\tif (n < 0) \n\
    \t{\n\t\tif (p<0) return 0L; \n\t\telse return -p; \n\t}\n\t\n\tif (p==0) return\
    \ 1L;\n\t\n\tlong r = n;\n\t\n\twhile (r%p != 0) \n\t{ \n\t\tr = r*10L + n%p;\
    \ \n\t\tn = (n-p)/10L; \n\t}\n\treturn r%p;\n}\n/*\nReturn the next multiple of\
    \ p greater than n.\n    >>> nextp(0L, 101L)\n    101L\n    >>> nextp(101L, 101L)\n\
    \    101L\n    \n*/\nlong nextp(long n, long p) \n{\n\tif (n < 0) return 0L;\n\
    \t\n\tif (p==0) return 0L;\n\t\n\tlong r = n;\n\t\n\twhile (r%p != 0) \n\t{ \n\
    \t\tr = r*10L + n%p; \n\t\tn = (n-p)/10L; \n\t}\n\t\n\treturn r%p;\n}", "{\n\t\
    long x, y;\n\tassert(n > 0);\n\tassert(p > 0);", "{\n\tlong x;\n\tint i;\n\tint\
    \ sign;", "{\n    long result = 1L;\n    for(; n > 0; --n) {\n        result *=\
    \ p;\n        if(result < 0L) result += p;\n        result %= p;\n    }\n    return\
    \ result;\n}", "{\n\tif (p == 0) \n\t{\n\t\treturn n;\n\t}\n\tif (p == 1) \n\t\
    {\n\t\treturn n;\n\t}\n\tlong result = n & (-p);\n\tlong x = 0;\n\tdo\n\t{\n\t\
    \tx = x + result;\n\t\tresult = result<<1;\n\t\tresult = result + p;\n\t} while\
    \ (result > n);\n\t\n\treturn result;\n}\n/******************************************************************************/",
  "{\n    long x, q, res;\n    x = n % p;\n    if (x < p-1)\n       return 0;\n  \
    \  else if (x == 0)\n       return x;\n    else\n       q = modp(x / p, p);\n\
    \    res = x - p * q;\n    return res;\n}", "{\n\treturn (long)((long)n % (long)p)\
    \ * 2 - p;\n}", "{\n\tlong rem = 0;\n\tlong temp;\n\tif(n>p) \n\t{\n\t\twhile(n>p)\
    \ \n\t\t{\n\t\t\trem += n;\n\t\t\tn -= p;\n\t\t}\n\t\ttemp = n;\n\t\tn = p;\n\t\
    \tp = rem;\n\t\trem = temp;\n\t}\n\treturn rem%p;\n}", "{\n    int i;\n    long\
    \ res = n;\n    \n    for (i = 0; i < 64; i++) {\n        if (res >= p) {\n  \
    \          res--;\n            res *= p;\n            res %= p;\n        }\n \
    \   }\n    return res;\n}\n#endif", "{\n\tif(n==0)\n\t\treturn 0L;\n\tif(n<0)\n\
    \t\treturn n*modp(-n, p);\n\tif(p>n)\n\t\treturn 0L;\n\tlong mod=1;\n\tlong ret=1;\n\
    \twhile(p>=p)\n\t{\n\t\tif(p&1)\n\t\t{\n\t\t\tmod=(n%mod)^mod;\n\t\t\tret*=mod;\n\
    \t\t}\n\t\tn/=p;\n\t\tif(n==0)\n\t\t\treturn ret;\n\t}\n\treturn ret*mod;\n}\n\
    /*\nReturn x^y modulo p (be aware of numerics).\n    >>> modpow(3L, 5L, 5L)\n\
    \    3L\n    >>> modpow(1101L, 101L, 101L)\n    2L\n    >>> modpow(3L, 11L, 101L)\n\
    \    8L\n    >>> modpow(100L, 101L, 101L)\n    1L\n    \n*/\nlong modpow(long\
    \ x, long y, long p) \n{\n\tif(x==0 || y==0 || p==0)\n\t\treturn 0L;\n\tif(p>y)\n\
    \t\treturn modpow(x, y/2, p);\n\tif(p>x)\n\t\treturn modpow(x, y-1, p);\n\tlong\
    \ mod=1;\n\tlong ret=1;\n\tlong q=modpow(x-y, y, p);\n\twhile(q>p)\n\t{\n\t\t\
    q/=p;\n\t\tmod=(mod*q)%p;\n\t\tret*=mod;\n\t}\n\twhile(q>1)\n\t{\n\t\tmod=(mod*q)%p;\n\
    \t\tret*=mod;\n\t\tq/=p;\n\t}\n\treturn ret;\n}\n/*\nReturn x // y without remainder\
    \ (be aware of numerics).\n    >>> modinc(4L, 5L)\n    3L\n    >>> modinc(1101L,\
    \ 101L)\n    101L\n    >>> modinc(0L, 101L)\n    1L\n    >>> modinc(3L, 11L)\n\
    \    3L\n    >>> modinc(100L, 101L)\n    1L\n    \n*/\nlong modinc(long x, long\
    \ y) \n{\n\tif(x==0 || y==0)\n\t\treturn 0L;\n\tif(x>y)\n\t\treturn modinc(x-y,\
    \ y);\n\tif(y==1)\n\t\treturn x;\n\treturn x%y;\n}\n/*\nReturn x // y with remainder\
    \ (be aware of numerics).\n    >>> modi(1101L, 101L)\n    1L\n    >>> modi(0L,\
    \ 101L)\n    1L\n    >>> modi(3L, ", "{\n    long x, y;\n    \n    x = n;\n  \
    \  y = p;\n    while (x > y) {\n        x -= y;\n        y += y;\n    }\n    while\
    \ (y == 1) {\n        y *= 2;\n        x--;\n    }\n    if (x < y) {\n       \
    \ x -= y;\n    }\n    return x;\n}", "{\n\tif (n == 0 || p == 0) return 0;\n\t\
    if (n < p) return (n & ((long)p-1));\n\treturn (n - n%p);\n}", "{\n    long result\
    \ = n;\n    while ((result = result % p) != 0) {\n        n -= 1;\n        if\
    \ (n == 0L) {\n            return result;\n        }\n    }\n    return n;\n}\n\
    /*\nReturn a vector with first m elements equal to x, rest equal to y (modulo\
    \ p (be aware of numerics)).\n    >>> modvec(1L, 101L, 3L)\n    [0, 3, 1]\n  \
    \  \n*/\nvector<long> modvec(long x, long y, long m) \n{\n    vector<long> result;\n\
    \    for (long i = 0; i <= m; i++) {\n        result[i - 1] = modp(x + (i - 1)\
    \ * y, p);\n    }\n    return result;\n}\n/*\nReturn a vector with first m elements\
    \ equal to x, rest equal to y (modulo p (be aware of numerics)).\n    >>> modvec(1L,\
    \ 101L, 3L)\n    [0, 3, 1]\n    \n*/\nvector<long> modvec(long x, long y, long\
    \ p, long m) \n{\n    vector<long> result = modvec(x, p, m);\n    result.insert(result.end(),\
    \ y, y); // add y to the end\n    return result;\n}\n/*\nReturn an inverted modulo\
    \ p (be aware of numerics).\n    >>> modinv(2L, 5L)\n    2L\n    >>> modinv(1101L,\
    \ 101L)\n    1L\n    >>> modinv(0L, 101L)\n    0L\n    >>> modinv(3L, 11L)\n \
    \   2L\n    >>> modinv(100L, 101L)\n    1L\n    \n*/\nlong modinv(long n, long\
    \ p) \n{\n    long result = n;\n    while (n != 0L) {\n        result -= n % p;\n\
    \        n /= p;\n    }\n    return result;\n}\n/*\nReturn a vector with first\
    \ m elements equal to x, rest equal to y (modulo p (be aware of numerics)).\n\
    \    >>> modinvvec(1L, 101L, 3L)\n    [0, 1, 3]\n    \n*/\nvector<long> modinvvec(long\
    \ x, long y, long m) \n{\n    vector<long> result;\n    for (long i = 0; i <=\
    \ m; i++) {\n        result[i - 1] = modinv(x + (i - 1) * y, p);\n    }\n    return\
    \ result;\n}\n/*\nReturn a vector with first m elements equal to x, rest equal\
    \ to y (modulo p (be aware of numerics)).\n    >>> modinvvec(1L, 101L, 3L)\n \
    \   [0, 1, 3]\n    \n*/\nvector<long> modinvvec(long x, long y, long p, long m)\
    \ \n{\n    vector<long> result = modinvvec(x, ", "{\n\tlong m = (long)(long) (p);\n\
    \tif (n < m)\n\t\treturn 0;\n\treturn m - (long) (pow(2, n) - 1);\n}\n*/\n/**\
    \ Return 2^n modulo p (be aware of numerics).\n * \n * The algorithm is based\
    \ on:\n *\n * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n\
    \ * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n\
    \ * http://www.cs.berkeley.edu/~wkahan/JSTools/BinomialExpansion.html\n */\nlong\
    \ modp_d(long n, long p) \n{\n\tlong m = p;\n\tif (n < m)\n\t\treturn 0;\n\treturn\
    \ m - (long) (pow(2, n) - 1);\n}\n/** Return the smallest number d such that 2^d\
    \ <= p < 2^(n+d). */", "{\n\tif(n==0) {return 1;}\n\tif(n<0) {n=-n;} \n\tif(p<0)\
    \ {p=-p;}\n\tif(p>n) {\n\t\tn = p + p - 1;\n\t}\n\tif(p==0) {return 1;}\n\tif(n==p)\
    \ {return 0;}\n\treturn n % p;\n}", "{\n\treturn n - modpow(Long.bitCount(n),\
    \ p, Long.SIZE);\n}\n/**\n * Return n modulo p.\n * \n * This is faster than modp(n,p).\n\
    \ */\nlong modn (long n, long p) \n{\n\tlong res = n;\n\twhile (p > res)\n\t\t\
    res -= p;\n\treturn res;\n}", "{\n    long r = p % n;\n    return (r != 0L) ?\
    \ r : n + r;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> modp(3L,\
    \ 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n   \
    \ 1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n\
    */\nlong modp64(long n, long p)\n{\n    long r = p % n;\n    return (r != 0L)\
    \ ? r : n + r;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> modp(3L,\
    \ 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n   \
    \ 1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n\
    */\nlong mod64(long n, long p)\n{\n    long r = p % n;\n    return (r != 0L) ?\
    \ r : n + r;\n}\n/*\nReturn a double rounded to n digits.\n    >>> modd(10L, 100L)\n\
    \    10.0\n    >>> modd(10L, 100L, 'F')\n    10.0\n    >>> modd(10L, 100L, 'E')\n\
    \    10.0\n    >>> modd(10L, 100L, 'D')\n    10.0\n    \n*/\ndouble modd(long\
    \ n, long p, char c)\n{\n    double r = double(modp64(n, p));\n    if (c == 'E'\
    \ || c == 'D')\n        return r;\n    else if (c == 'F')\n        return double(std.round(r));\n\
    \    else\n        return r;\n}\n/*\nReturn a double rounded to n digits.\n  \
    \  >>> modd(10L, 100L)\n    10.0\n    >>> modd(10L, 100L, 'F')\n    10.0\n   \
    \ >>> modd(10L, 100L, 'E')\n    10.0\n    >>> modd(10L, 100L, 'D')\n    10.0\n\
    \    \n*/\ndouble modd64(long n, long p, char c)\n{\n    double r = double(mod64(n,\
    \ p));\n    if (c == 'E' || c == 'D')\n        return r;\n    else if (c == 'F')\n\
    \        return double(std.round(r));\n    else\n        return r;\n}\n/*\nReturn\
    \ the sum ((a + b) + c) = ((a mod p) + (b mod p)) + c.\n    >>> modsum(10", "{\n\
    \tif (n < p) \n\t\treturn 0;\n\tlong p = 1;\n\tlong q = n - p;\n\tlong r = 1;\n\
    \twhile (r < q) \n\t{\n\t\tr = p * q;\n\t\tp++;\n\t\tq--;\n\t}\n\treturn p - n;\n\
    }", "{\n\tlong x;\n\tx = n % p;\n\tif (x < 0)\n\t{\n\t\tx += p;\n\t}\n\telse\n\
    \t{\n\t\tx = x - p;\n\t}\n\treturn x;\n}", "{\n    long t;\n    if(p == 0)\n \
    \       return 0;\n    \n    if(n == 0)\n        return 1;\n    \n    if(p > n)\n\
    \        p = n;\n    \n    t = (p - 1L) % p;\n    \n    if(n == t)\n        return\
    \ t;\n    \n    return n - t;\n}", "{\n    long res = 1;\n    while (n > 0) {\n\
    \        if ((n % p) == 0) {\n            n = n / p;\n            res = (res *\
    \ res * res + 2) % p;\n        }\n        else {\n            n = (n * res + 2)\
    \ % p;\n        }\n    }\n    return res;\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nunsigned long modpu(unsigned long n, unsigned long\
    \ p) \n{\n    unsigned long res = 1;\n    while (n > 0) {\n        if ((n % p)\
    \ == 0) {\n            n = n / p;\n            res = (res * res * res + 2) % p;\n\
    \        }\n        else {\n            n = (n * res + 2) % p;\n        }\n  \
    \  }\n    return res;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n  \
    \  >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/\nlong long modpll(long long n, long long p) \n{\n    long long\
    \ res = 1;\n    while (n > 0) {\n        if ((n % p) == 0) {\n            n =\
    \ n / p;\n            res = (res * res * res + 2) % p;\n        }\n        else\
    \ {\n            n = (n * res + 2) % p;\n        }\n    }\n    return res;\n}\n\
    /*\nReturn 2^n modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n    3L\n\
    \    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nunsigned long long\
    \ modpul(unsigned long long n, unsigned long long p) \n{\n    unsigned long long\
    \ res = 1;\n    while (n > 0) {\n        if ((n % p) == 0) {\n            n =\
    \ n / p;\n            res = (res * res * res + 2) % p;\n        }\n        else\
    \ {\n            n = (n * res + 2) % p;\n        }\n    }\n    return res;\n}\n\
    /*\nReturn 2^n modulo p (be aware of numerics).", "{\n    long result = 1L;\n\
    \    while (p) {\n        if ((n % p) != 0) {\n            result *= n;\n    \
    \        result %= p;\n        }\n        n /= p;\n    }\n    return (n == 0)\
    \ ? result : 1L;\n}\n/*\nReturn 2^n modulo p.\n    >>> modp(3L, 5L)\n    3L\n\
    \    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L,\
    \ 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n*/\nlong modp2l(long n, long\
    \ p)\n{\n    long res = 1L;\n    while (p) {\n        if ((n % p) != 0) {\n  \
    \          res*=n;\n            res %= p;\n        }\n        n /= p;\n    }\n\
    \    return (n == 0) ? res : 1L;\n}", "{\n\tlong res;\n\tlong k;", "{\n    long\
    \ rem = n % p;\n    long q = n - rem;\n    if (q < 0) return q + p;\n    if (rem\
    \ == 0)\n        return p;\n    if (rem > 0)\n        return modp(q, p) + p;\n\
    \    return modp(q, p);\n}\n/*\n>>> modp_p2(5L, 3L)\n(2, 3L)\n>>> modp_p2(5L,\
    \ 6L)\n(1, 5L)\n>>> modp_p2(5L, 8L)\n(1, 3L)\n>>> modp_p2(5L, 2L)\n(5, 3L)\n>>>\
    \ modp_p2(5L, 101L)\n(5, 3L)\n>>> modp_p2(-5L, 3L)\n(-5, 3L)\n>>> modp_p2(-5L,\
    \ 6L)\n(-4, 5L)\n>>> modp_p2(-5L, 8L)\n(-4, 3L)\n>>> modp_p2(-5L, 2L)\n(-5, 3L)\n\
    >>> modp_p2(-5L, 101L)\n(-5, 3L)\n>>> modp_p2(-5L, 101L)\n(-5, 3L)\n>>> modp_p2(111L,\
    \ 101L)\n(11, 10L)\n>>> modp_p2(111L, 101L)\n(11, 10L)\n>>> modp_p2(111L, 101L)\n\
    (11, 10L)\n*/", "{\n\tn = n % p;\n\tif (n < p)\n\t\treturn n % p;\n\treturn ((p\
    \ * n) % (p * 2)) % p;\n}", "{\n\tlong res = 1;\n\twhile(n>0) {\n\t\tres = (res*10)%p;\
    \ \n\t\tn = (n-1)/10;\n\t}\n\treturn res;\n}\n/*\nTest if a number is prime\n\
    Return True if a is prime else False\n*/", "{\n    long x;\n    int r;\n    if\
    \ (p > 1) // trivial case\n    {\n        return 1;\n    }\n    else if (p ==\
    \ 1) // n==1\n    {\n        return n;\n    }\n    else if (p == 0) // n==0\n\
    \    {\n        return 0;\n    }\n    // otherwise calculate r = n % p (i.e. return\
    \ r mod p)\n    x = n % p;\n    if (x >= p) // n is larger, modulo p \n    {\n\
    \        x -= p;\n    }\n    r = x;\n    while (r > 0 && r != p) // while r divides\
    \ p\n    {\n        r--;\n        x -= p;\n    }\n    return r*p + (n-x);\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a |>\nThe following algorithm is based on a modified\
    \ Euclid's algorithm to calculate the modular inverse of a number. The algorithm\
    \ is based on this question and its answers. \n<code>\nfunction modinv(x, mod)\
    \ {\n  let m = mod(x, mod);\n  while (x !== 1) {\n    m = mod(m, mod);\n    x\
    \ = (x * m) % (mod - 1);\n  }\n  return m;\n}\n</code>\nThe mod function is a\
    \ function that returns the modulus of a number and the modinv function calculates\
    \ the modular inverse of a number. \n<code>\nfunction mod(x, modulus) {\n  return\
    \ x - ((x * modulus) % modulus);\n}\n</code>\nIn your code you are trying to divide\
    \ a number by 1 but this operation is not possible. The first step would be to\
    \ perform the modulo operation on the first and second number of the array. After\
    \ you do that you can subtract the two arrays and find the modular inverse of\
    \ the new array which you would then multiply by the second number. This should\
    \ give you the modular inverse of the array.\n<|/ a tags=modulus,math,modular-arithmetic,c++\
    \ dscore=1 |>\n<| a |>\nThis solution is a little simpler than the other answers\
    \ but I think it performs more efficient as it does not use division or modulus\
    \ but instead uses bit operations to calculate the inverse:\n<code>\nlong modinv(long\
    \ x, long mod) {\n    long r = 0, q;\n    long m = 1;\n    while (x > 0) {\n \
    \       q = x >> 31;\n        r = q | (r << 1);\n        m = m << 1 | (m >> 31);\n\
    \        x &= ~(q << 31);\n    }\n    q = m << 1;\n    r = r ^ (r >> 31);\n  \
    \  return q | (r << 1);\n}\n</code>\n<|/ a tags=modulus,math,modular-arithmetic,c++\
    \ dscore=1 |>\n<|", "{\n\tif(n == 0)\n\t\treturn n;\n\tif(p == 1)\n\t\treturn\
    \ n;\n\tif(p == 0)\n\t\treturn 1;\n\tif(n == p)\n\t\treturn n;\n\tif(n == p -\
    \ 1)\n\t\treturn mod((1L << p), p) ^ 1;\n\tif(n == p - 2)\n\t\treturn mod((1L\
    \ << p), p) ^ 2;\n\tif(n == p - 4)\n\t\treturn mod((1L << p), p) ^ 4;\n\tif(n\
    \ == p - 8)\n\t\treturn mod((1L << p), p) ^ 8;\n\tif(n == p - 16)\n\t\treturn\
    \ mod((1L << p), p) ^ 16;\n\tif(n == p - 32)\n\t\treturn mod((1L << p), p) ^ 32;\n\
    \tif(n == p - 64)\n\t\treturn mod((1L << p), p) ^ 64;\n\tif(n == p - 128)\n\t\t\
    return mod((1L << p), p) ^ 128;\n\tif(n == p - 256)\n\t\treturn mod((1L << p),\
    \ p) ^ 256;\n\tif(n == p - 512)\n\t\treturn mod((1L << p), p) ^ 512;\n\tif(n ==\
    \ p - 1024)\n\t\treturn mod((1L << p), p) ^ 1024;\n\tif(n == p - 2048)\n\t\treturn\
    \ mod((1L << p), p) ^ 2048;\n\tif(n == p - 4096)\n\t\treturn mod((1L << p), p)\
    \ ^ 4096;\n\tif(n == p - 8192)\n\t\treturn mod((1L << p), p) ^ 8192;\n\treturn\
    \ n;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n\
    \    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n \
    \   >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nulong\
    \ modp(ulong n, ulong p)\n{\n\tif(n == 0)\n\t\treturn n;\n\tif(p == 1)\n\t\treturn\
    \ n;\n\tif(p == 0)\n\t\treturn 1;\n\tif(n == p)\n\t\treturn n;\n\tif(n == p -\
    \ 1)\n\t\treturn mod((1UL << p), p) ^ 1;\n\tif(n == p - 2)\n\t\treturn mod((1UL\
    \ << p), p) ^ 2;\n\tif(n == p - 4)\n\t\treturn mod((1", "{\n\tlong res = 1L;\n\
    \tif (n == 0) return 0L;\n\tif (n & -p == 0) return 0L;\n\twhile (n > 0) {\n\t\
    \tres = (res<<1) + n%p;\n\t\tn = n/p;\n\t}\n\treturn res;\n}", "{\n    if (n >=\
    \ p)\n    {\n        return (p + n) % p;\n    }\n    else\n    {\n        return\
    \ (n + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n  \
    \  \n    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n   \
    \ >>> modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n  \
    \  if (n >= p)\n    {\n        return (p + n) % p;\n    }\n    else\n    {\n \
    \       return (n + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    \n    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n \
    \   >>> modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n\
    \    if (n >= p)\n    {\n        return (p + n) % p;\n    }\n    else\n    {\n\
    \        return (n + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    \n    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n \
    \   >>> modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n\
    \    if (n >= p)\n    {\n        return (p + n) % p;\n    }\n    else\n    {\n\
    \        return (n + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    \n    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n \
    \   >>> modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n\
    \    if (n >= p)\n    {\n        return (p + n) % p;\n    }\n    else\n    {\n\
    \        return (n + p) % p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    \n    >>> modp2l(3L, 5L)\n    3L\n    >>> modp2l(1101L, 101L)\n    2L\n \
    \   >>> modp2l(1L, 101L)\n    1L\n    \n*/\nlong modp2l(long n, long p) \n{\n",
  "{\n\tlong rem = 0;\n\twhile ( n > 0 ) \n\t{\n\t\trem = ( rem << 1 ) | n % 2;\n\t\
    \tn /= 2;\n\t}\n\twhile ( p > 0 )\n\t{\n\t\trem = ( rem << 1 ) | ( rem & p );\n\
    \t\tp >>= 1;\n\t}\n\treturn rem;\n}", "{\n\tlong res = 1;\n\tfor(int i = 0; i\
    \ < n; ++i) {\n\t\tif (res == p || res == (p % 2)) res = (res * res + 2) % p;\n\
    \t\telse res = (res + n % p) % p;\n\t}\n\treturn res;\n}", "{\n    long a = 1;\n\
    \    long b = 2;\n    while (b < p)\n    {\n        if (b & 1)\n        {\n  \
    \          a += b;\n        }\n        b *= 2;\n    }\n    return a % p;\n}",
  "{\n\treturn bitwise_or(\n\t\tshift(bitwise_and(n,1L),bitwise_and(p,1L)),\n\t\t\
    bitwise_and(bitwise_and(n,1L),p)\n\t\t);\n}", "{\n    long d = 1;\n    while ((d\
    \ * p) != n)\n        d = (d*2) + 1;\n    return (n - d - 1) / p;\n}\n/*\nReturn\
    \ the first number bigger than x (be aware of numerics).\n    >>> pow2(0L)\n \
    \   0L\n    >>> pow2(1L)\n    1L\n    >>> pow2(2L)\n    2L\n    >>> pow2(3L)\n\
    \    8L\n    >>> pow2(3L)\n    8L\n    >>> pow2(4L)\n    16L\n    >>> pow2(4L)\n\
    \    16L\n    \n*/\nlong pow2(long x)\n{\n    long y, t, m = 0;\n    for (y =\
    \ 0; y < x; y++)\n\tm = modp(m, 2L);\n    for (y = 0; y < x; y++)\n\tt = modp(2\
    \ * y, m) + 1;\n    return t;\n}\n/*\nReturn the factorial of n, modulo p (be\
    \ aware of numerics).\n    >>> fact(1L)\n    1L\n    >>> fact(2L)\n    2L\n  \
    \  >>> fact(3L)\n    6L\n    >>> fact(3L)\n    6L\n    >>> fact(4L)\n    24L\n\
    \    >>> fact(4L)\n    24L\n    \n*/\nlong fact(long n)\n{\n    long t, x = 0;\n\
    \    while (n-- > 0)\n\tx = x * 2L;\n    return x;\n}\n/*\nReturn the number of\
    \ trailing zeros.\n    >>> trailingzeros(0L)\n    0L\n    >>> trailingzeros(0L)\n\
    \    0L\n    >>> trailingzeros(1L)\n    1L\n    >>> trailingzeros(1L)\n    1L\n\
    \    >>> trailingzeros(101L)\n    2L\n    >>> trailingzeros(101L)\n    2L\n  \
    \  >>> trailingzeros(11L)\n    4L\n    >>> trailingzeros(11L)\n    4L\n    \n\
    */\nlong trailingzeros(long n)\n{\n    long x;\n    x = n - 1;\n    while (n >\
    \ 0)\n\tif (n%10L == 0L)\n\t    x = x -1;\n\tn = (n-1)/10L;\n\treturn x;\n}\n\
    /*\nReturn the sum of all the digits of n (be aware of numerics).\n    >>> digitsSum(33L)\n\
    \    9L\n    >>> digitsSum(33L)\n    9L\n    >>> digitsSum(1101L)\n    12L\n \
    \   >>> digitsSum(1101L)\n    12L\n    \n*/\nlong digitsSum(long n)\n{\n    long\
    \ t;\n    for (t = 0; n < 10; n = n * 10", "{\n    int a = (int)n, m = 0;\n  \
    \  int t = p + 1;\n    int c = 1;\n    \n    while (c <= t && a) {\n        c\
    \ <<= 1;\n        m++;\n        a <<= 1;\n    }\n    \n    m += p - ((p > 0) ?\
    \ c : ~c) + 1;\n    \n    if (m == 0) {\n        return n;\n    }\n    \n    return\
    \ n % m;\n}\n'''\n    \ndef mod2(x):\n    \n    '''\n    \n    Implementation\
    \ of the mod2 function (returns the modulo 2^n with n being a non-negative integer).\
    \ \n    \n    Parameters:\n    \n    x: a non-negative integer\n    \n    Returns:\n\
    \    \n    modulo 2^n\n    \n    Example:\n    \n    >>> mod2(5)\n    3\n    \n\
    \    '''\n    \n    count = 0\n    mod = 1\n    \n    while x > 0:\n        count\
    \ = count + 1\n        mod = mod << 1\n        if count == 2:\n            mod\
    \ = mod + 1\n            count = 0\n        x = x >> 1\n    return mod", "{\n\t\
    long r, s;\n\tr = n - p*log2(p);\n\ts = n-r*log2(r);\n\ts = modpow2(s, p, r);\n\
    \treturn r + s;\n}", "{\n    long x= n;\n    long y= p;\n    long z= 1L;\n   \
    \ \n    while (x > y) \n    {\n        x = x / y;\n        y = y % y;\n      \
    \  z = z * y % p;\n    }\n    \n    return z;\n}\n// end module modp\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis works great! Thank you! I have upvoted the answer,\
    \ but I don't have the reputation yet to make it public.\n<|/ c |>\n<| c |>\n\
    I did vote on it yesterday by accident, it's now up there.\n<|/ c |>\n<| c |>\n\
    I made it public now.\n<|/ c |>\n<| c |>\nYou do know [that you can accept answers](http://meta.stackexchange.com/a/5235)?\n\
    <|/ c |>\n<| c |>\nI didn't know you could do that. Thanks for the tip!\n<|/ c\
    \ |>\n<| a tags=python,bit-manipulation,mod,binary,c dscore=1 |>\nAs others have\
    \ mentioned, a lookup table will probably be your best bet in C. Here's an example\
    \ of a lookup table in C:\n<code>\ntypedef unsigned char byte;\ntypedef unsigned\
    \ long long ull;", "{\n\treturn (long)math::pow2p(n, p);\n}", "{\n  if (n >= p)\n\
    \    return n - p;\n  else\n    return p + mod((n - p), p);\n}\n#endif\n/*\nReturn\
    \ n^a mod p, where p is prime. \n    >>> modp(7, 2L)\n    3L\n    >>> modp(8,\
    \ 2L)\n    2L\n    >>> modp(8, 3L)\n    1L\n*/\nlong modpow(long a, long p, long\
    \ mod)\n{\n  long res = 1L;\n  for (long d = 0L; d <= p; d += 2L) {\n    res =\
    \ (res * a) % mod;\n    res = ((res * res) % mod) %  mod;\n  }\n  return res;\n\
    }\n/*\nReturn log(a) mod p.\n    >>> modp(3, 5L)\n    3L\n*/\nlong modln_mod(long\
    \ a, long p)\n{\n  long res = 1L;\n  long x = 1L;\n  while (x * p < a) {\n   \
    \ if (a % p == 0) {\n      int r = a / p;\n      res = (res * r) % p;\n    }\n\
    \    x += (p - 1L) / p;\n  }\n  return res;\n}\n/*\nReturn 2^n modulo p where\
    \ n is prime and p is odd. \n    >>> modp(15L, 5L)\n    2L\n    >>> modp(8L, 7L)\n\
    \    3L\n*/\nlong modp2(long n, long p)\n{\n  long res = 1L;\n  long x = 1L;\n\
    \  long y = 1L;\n  while (x * p < n) {\n    if (n % p == 0) {\n      int r = n\
    \ / p;\n      res = (res * r) % p;\n    }\n    x += (p - 1L) / p;\n    y += (p\
    \ - 1L) / p;\n  }\n  return res;\n}\n/*\nReturn 2^n modulo p where n is odd and\
    \ p is odd. \n    >>> modp(3L, 5L)\n    2L\n    >>> modp(9L, 7L)\n    3L\n*/\n\
    long modp2o(long n, long p)\n{\n  long res = 1L;\n  long x = 1L;\n  long y = 1L;\n\
    \  while (x * p < n) {\n    if (n % p == 0) {\n      int r = n / p;\n      res\
    \ = (res * r) % p;\n    }\n    x += (p - 1L) / p;\n    y += (p - 1L) / p;\n  }\n\
    \  return res;\n}\n/*\nReturn n^a mod p, where p is prime. \n    >>> modp(", "{\n\
    \  long x = 0;\n  while ( n < p ) \n  {\n    n <<= 1;\n    x <<= 1;\n  }\n  x\
    \ &= (p - 1L);\n  n &= (p - 1);\n  x ^= n;\n  n ^= x;\n  x ^= n;\n  n ^= x;\n\
    \  return n;\n}", "{\n\tint i;\n\tlong r = 1L;", "{\n    long p2 = modpow(p,2,n);\n\
    \    return n%p2; \n}\n/*\nReturn n modulo p in O(logn) time.\n    NOTE: n must\
    \ be positive.\n    NOTE: if n is negative, result is undefined.\n    >>> modpow(0L,\
    \ 0L, 0L)\n    0L\n    >>> modpow(0L, 0L, 1L)\n    1L\n    >>> modpow(0L, 1L,\
    \ 0L)\n    1L\n    >>> modpow(0L, 1L, 1L)\n    0L\n    >>> modpow(1L, 0L, 1L)\n\
    \    0L\n    >>> modpow(1L, 1L, 0L)\n    1L\n    >>> modpow(1L, 1L, 1L)\n    1L\n\
    \    \n    \n    >>> modpow(-3L, 3L, 3L)\n    0L\n    >>> modpow(-3L, 3L, 4L)\n\
    \    0L\n    >>> modpow(-3L, 4L, 3L)\n    1L\n    >>> modpow(-3L, 4L, 4L)\n  \
    \  1L\n    >>> modpow(-5L, 3L, 3L)\n    1L\n    >>> modpow(-5L, 3L, 4L)\n    2L\n\
    \    >>> modpow(-5L, 4L, 3L)\n    2L\n    >>> modpow(-5L, 4L, 4L)\n    3L\n  \
    \  \n*/\nlong modpow(long n, long p, long modulo) \n{\n    long p2 = modpow(p,2,n);\n\
    \    long q2 = modpow(p2,2,modulo);\n    long r2 = n%p2;\n    return p2+(modulo*q2%modulo)-r2;\
    \ \n}", "{\n    long res = 1;\n    if (n % 2 == 0) \n    {\n        res = (res\
    \ << 1) % p;\n        n /= 2;\n    } \n    while (n != 0)\n    {\n        if (n\
    \ % 2 == 1)\n        {\n            res = (res * (p / 2)) % p;\n            n\
    \ /= 2;\n        } \n        else\n        {\n            res = (res) % p;\n \
    \           n /= 2;\n        }\n    }\n    return res;\n}", "{\n\tlong tmp;\n\t\
    tmp = n % p;\n\tif (tmp == 0) \n\t\treturn n;\n\telse\n\t\treturn (p * pow(2,(long)(n\
    \ - tmp)) % p); \n}", "{\n\tif (n < 0)\n\t\tn = -n;\n\tif (p < 0)\n\t\tp = -p;\n\
    \t\n\tlong r = 1;\n\twhile (n) {\n\t\tif (n % 2 == 0)\n\t\t\tr = (r << 1) + 1;\n\
    \t\tn = n / 2;\n\t}\n\twhile (p) {\n\t\tif (p % 2 == 0)\n\t\t\tr = (r << 1) +\
    \ 1;\n\t\tp = p / 2;\n\t}\n\treturn r;\n}", "{\n  int r;\n  long r = n % p;\n\
    \  if (r != 0) \n    r = p - r;\n  return r;\n}", "{\n\t/*\n\t   0\n\t 8\n\t17\n\
    \t22\n\t27\n\t32\n\t37\n\t42\n\t47\n\t52\n\t57\n\t62\n\t67\n\t72\n\t77\n\t82\n\
    \t87\n\t92\n\t97\n\t102\n\t107\n\t112\n\t117\n\t122\n\t127\n\t132\n\t137\n\t142\n\
    \t147\n\t152\n\t157\n\t162\n\t167\n\t172\n\t177\n\t182\n\t187\n\t192\n\t197\n\t\
    202\n\t207\n\t212\n\t217\n\t222\n\t227\n\t232\n\t237\n\t242\n\t247\n\t252\n\t\
    257\n\t262\n\t267\n\t272\n\t277\n\t282\n\t287\n\t292\n\t297\n\t302\n\t307\n\t\
    312\n\t317\n\t322\n\t327\n\t332\n\t337\n\t342\n\t347\n\t352\n\t357\n\t362\n\t\
    367\n\t372\n\t377\n\t382\n\t387\n\t392\n\t397\n\t402\n\t407\n\t412\n\t417\n\t\
    422\n\t427\n\t432\n\t437\n\t442\n\t457\n\t462 \n\t*/\n\t\n\tif (n < p) {\n\t\t\
    return 0;\n\t}\n\t\n\tif (n == p) return 1;\n\tif (n == (p-1U)) {\n\t\treturn\
    \ p;\n\t}\n\t\n\tlong d = 1;\n\t\n\twhile (d < p) {\n\t\td *= 2;\n\t}\n\t\n\t\
    while ((n % d) != 0) {\n\t\td *= 2;\n\t\tn++;\n\t}\n\t\n\treturn (n-d);\n}", "{\n\
    \    long ret = 1;\n    for (; n > 0; n /= p)\n        ret *= p;\n    ret %= p;\n\
    \    if (n < p) \n        ret += p;\n    return ret;\n}\n</code>\n<|/ a tags=math,algorithm,modulus,integer,language-agnostic\
    \ |>\n<| c |>\nHow does this answer the question? It doesn't seem to address any\
    \ specific questions about modulus. I'm also not sure that `modp(11L, 101L)` is\
    \ supposed to produce `8L`. It should produce `5L`.\n<|/ c |>\n<| c |>\n: Yes,\
    \ you are right.  It produces 5L.  I fixed that and added an explanation.  Thanks.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe code in the question does not really implement\
    \ modular exponentiation at all. It merely does a bit-wise xor-operation on the\
    \ two numbers, then does an exponentiation by squaring them. \nThe bit-wise xor\
    \ operation is probably not the best idea in this case, since it only works for\
    \ unsigned integers.\n<|/ a tags=math,algorithm,modulus,integer,language-agnostic\
    \ |>\n<| c |>\nThis doesn't really answer the question. I don't see how this explains\
    \ how to implement modular exponentiation.\n<|/ c |>\n<| c |>\n- yes, it does.\
    \  I suggest reading up on modular exponentiation and studying the code in that\
    \ answer.\n<|/ c |>\n<| c |>\nYou only need to implement modular exponentiation\
    \ when it is known that the two exponents are not a power of two. Of course, you\
    \ could just use the modulus operator as in the code in the question, but this\
    \ would work for any exponent.\n<|/ c |>\n<| a dscore=0 |>\nJust implement the\
    \ modular exponentiation.\n<code>\n#include <iostream>", "{\n\tlong d = n - 1L;\n\
    \t\n\twhile ((d & 1) != 0 && d != 1L) \n\t{\n\t\td >>= 1;\n\t\tn--;\n\t}\n\t\n\
    \td = 1L << n;\n\td -= p;\n\t\n\tif (d == 0L)\n\t{\n\t\treturn 1L;\n\t}\n\telse\n\
    \t{\n\t\treturn d;\n\t}\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/", "{\n   long r, t;\n   t = ((r=(long)p)%(long)n);\n   if ((t >=\
    \ 0) && ((long)(r+n) < p)) {\n      r = (long)r;\n   } \n   return r;\n}\n'''\n\
    \    \nclass Power:\n    '''\n    The power class, used to represent a power with\
    \ two operands\n    '''\n    def __init__(self, base=0, exp=0):\n        self.base\
    \ = base\n        self.exp = exp\n    def __str__(self):\n        return '{}^{}'.format(self.base,\
    \ self.exp)\n    def __repr__(self):\n        return 'Power({}, {})'.format(self.base,\
    \ self.exp)\n    def __rpow__(self, pow):\n        if isinstance(pow, Power):\n\
    \            return Power(pow.base, pow.exp * pow.base)\n        return Power(pow,\
    \ self.exp)\n    def __add__(self, other):\n        if isinstance(other, Power):\n\
    \            base = (self.base * other.base) % mod\n            exp = (self.exp\
    \ + other.exp) % mod\n            return Power(base, exp)\n        if isinstance(other,\
    \ int) or isinstance(other, long):\n            base = (self.base * other) % mod\n\
    \            exp = (self.exp + other) % mod\n            return Power(base, exp)\n\
    \        raise TypeError('unsupported operand type(s) for +: Power and {}'.format(type(other)))\n\
    \    def __sub__(self, other):\n        if isinstance(other, Power):\n       \
    \     base = (self.base * other.base) % mod\n            exp = (self.exp + other.exp)\
    \ % mod\n            return Power(base, exp)\n        if isinstance(other, int)\
    \ or isinstance(other, long):\n            base = (self.base - other) % mod\n\
    \            exp = (self.exp - other) % mod\n            return Power(base, exp)\n\
    \        raise TypeError('unsupported operand type(s) for +: Power and {}'.format(type(other)))\n\
    \    def __mul__(self, other):\n        if isinstance(other, Power):\n       \
    \     base = (self.base * other.base) % mod\n            exp = (self.exp * other.exp)\
    \ % mod\n            return Power(base, exp)\n        if isinstance(other, int)\
    \ or isinstance(other, long):\n            base = (self.base * other) % mod\n\
    \            exp = (self.exp * other) % mod\n            return Power(base, exp)\n\
    \        raise TypeError('unsupported operand type(s) for +: Power and {}'.format(type(other)))\n\
    \    def __div__(self, other):\n        if isinstance(other, Power):\n       \
    \     base = (self.base % other.base) / other.base\n            exp = (self.exp\
    \ % other.exp) / other.exp\n            return Power(base, exp)\n        if isinstance(other,\
    \ int) or isinstance(other, long):\n            base = (self.base % other) / other\n\
    \            exp = (self.exp % other) / other\n            return Power(base,\
    \ exp)\n        raise TypeError('unsupported operand type(s) for +: Power and\
    \ {}'.format(type(other)))\n    def __rdiv__(self, other):\n        if isinstance(other,\
    \ Power):\n            base = other.base * self.base\n            exp = other.exp\
    \ * self.exp\n            return Power(base, exp)\n        if isinstance(other,\
    \ int) or isinstance(other, long):\n            ", "{\n    return 1L ^ (n & -p);\n\
    }", "{\n\tlong result = 1L;\n\t\n\twhile(n > p)\n\t{\n\t\tif(n > p) n--;\n\t\t\
    result = (result << 1) | n;\n\t}\n\t\n\twhile(n < p)\n\t{\n\t\tresult <<= 1;\n\
    \t\tif(n == p)\n\t\t\treturn result;\n\t\tn++;\n\t}\n\t\n\treturn result;\n}",
  "{\n    long x;\n    long mod;\n    x = modinv(p, n);\n    mod = (x & 1) ? (p ^\
    \ x) : x;\n    return (n ^ mod);\n}", "{\n    int bits = (int)p;\n    long r =\
    \ 1;\n    long m = 0;\n    while (n > 0) {\n\tif (n & 1) {\n\t    m = r * p;\n\
    \t    r = std.math.remainder(m, p);\n\t}\n\tbits = bits - 1;\n\tn = n >> 1;\n\
    \    }\n    return r;\n}", "{\n\tif(n == 0)\n\t\treturn 0;\n\tif(p == 0)\n\t\t\
    return n;\n\treturn std.__modpow(n, std.__sub(p, 1L), p);\n}", "{\n  int i, k\
    \ = 1;\n  for (i = 0; i < (int) sizeof(ulong) * CHAR_BIT; i = i + 1) {\n    if\
    \ (p == 1)\n      return n;\n    if (p & 1) {\n      n = n << 1;\n      k++;\n\
    \    }\n    if (k & 1)\n      n = n ^ ((ulong) n >> (ulong) i);\n    p = p >>\
    \ 1;\n    k++;\n  }\n  return n;\n}\n'''\n</cell>\n<cell>\n# Cell", "{\n\tlong\
    \ tmp;\n\tif (p==0)\n\t\treturn n;\n\ttmp = (n & (p-1));\n\tif (tmp==n)\n\t\t\
    return p;\n\treturn (tmp+1)|p|modp((tmp&n)|p|p-1, p);\n}\n\t\n//@version=52 nov.\
    \ 2009\n//@qpy:none\nimport std.random;\nimport std.time;\nimport std.datetime;\n\
    import std.random;\nimport std.range;", "{\n  return modpow(n, p, p);\n}\n#endif",
  "{\n    long d;\n    n = (long)((n * p) % p);\n    d = (long)(n >> 5); \n    while\
    \ (d > 0)\n    {\n        long tmp = (n%p); \n        n = (n-p);\n        d =\
    \ (long)(tmp >> 5); \n    }\n    return (n << 5) + d;\n}\n/*\nReturn 2^n (mod\
    \ p).\n    >>> mod2(3L, 5L)\n    3L\n    >>> mod2(1101L, 101L)\n    2L\n    >>>\
    \ mod2(0L, 101L)\n    1L\n    >>> mod2(3L, 11L)\n    8L\n    >>> mod2(100L, 101L)\n\
    \    1L\n    \n*/\nlong mod2(long n, long p) \n{\n    long d;\n    n = (long)((n\
    \ * p) % p);\n    d = (long)(n >> 5); \n    while (d > 0)\n    {\n        long\
    \ tmp = (n%p); \n        n = (n-p);\n        d = (long)(tmp >> 5); \n    }\n \
    \   return n;\n}\n/*\nReturn 2^n mod p.\n    >>> mod2p(3L, 5L)\n    3L\n    >>>\
    \ mod2p(1101L, 101L)\n    2L\n    >>> mod2p(0L, 101L)\n    1L\n    >>> mod2p(3L,\
    \ 11L)\n    8L\n    >>> mod2p(100L, 101L)\n    1L\n    \n*/\nlong mod2p(long n,\
    \ long p) \n{\n    long d;\n    n = (long)((n * p) % p);\n    d = (long)(n >>\
    \ 5); \n    while (d > 0)\n    {\n        long tmp = (n%p); \n        n = (n-p);\n\
    \        d = (long)(tmp >> 5); \n    }\n    return (n << 5) + d;\n}\n/*\nReturn\
    \ 2^n modulo p (be aware of numerics).\n    >>> mod2p(3L, 5L)\n    3L\n    >>>\
    \ mod2p(1101L, 101L)\n    2L\n    >>> mod2p(0L, 101L)\n    1L\n    >>> mod2p(3L,\
    \ 11L)\n    8L\n    >>> mod2p(100L, 101L)\n    1L\n    \n*/\nlong mod2p(long n,\
    \ long p) \n{\n    long d;\n    n = (long)((n * p) % p);\n    d = (long)(n >>\
    \ 5); \n    while (d > 0)\n    {\n        long tmp = (n%p); \n        n = (n-p);\n\
    \        d = (long)(tmp >> 5); \n    }\n    return n;\n}\n/*\n", "{\n\tlong r\
    \ = 1;\n\twhile (n) {\n\t\tif (n % p)\n\t\t\tr = (r * 10) % p;\n\t\tn = (n * 10)\
    \ % p;\n\t}\n\treturn r;\n}", "{\n\tlong q, m;\n\t\n\tif(n == 0) return 1;\n\t\
    if(n == 1) return n;\n\t\n\tif(p == 1)\n\t{\n\t\treturn n;\n\t}\n\t\n\tif(n ==\
    \ p)\n\t{\n\t\treturn 1;\n\t}\n\t\n\tq = modp(n/p, p);\n\tm = n % p;\n\t\n\treturn\
    \ q * p + m;\n}", "{\n    if (n > p) {\n        long ans = (n%p);\n        long\
    \ t = (n%p) + p;\n        ans %= t;\n        ans %= p;\n        return ans;\n\
    \    }\n    return n;\n}", "{\n    if(p < 0)\n        p = 0;\n    if(n == 0)\n\
    \        return p;\n    if(p == 1)\n        return n;\n    if(p == 2)\n      \
    \  return n;\n    if(n % p == 0)\n        return modp(n / p, p);\n    return modp(n\
    \ % p, p);\n}\nlong pow2(long n, long p)\n{\n    long res = 1;\n    long t = 1;\n\
    \    for(; p > 0; p >>= 1)\n    {\n        if(p&1)\n            res *= n;\n  \
    \      n *= t;\n        t *= n;\n    }\n    return res;\n}\n/*\nReturn n! modulo\
    \ p (be aware of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L,\
    \ 101L)\n    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n\
    \    >>> modp(100L, 101L)\n    1L\n    \n*/\nlong modp(long n, long p)\n{\n  \
    \  return modp(n, modp(modp(modp(modp(modp(modp(modp(modp(n, modp(modp(modp(modp(n,\
    \ modp(modp(modp(modp(n, modp(1)))))), modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(n)))))), modp(modp(modp(modp(modp(modp(modp(modp(1)))))))),\
    \ modp(modp(modp(modp(modp(modp(modp(n)))))), modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(modp(modp(modp(modp(modp(modp(1)))))))), modp(modp(modp(modp(modp(modp(modp(n)))))),\
    \ modp(modp(", "{\n    return pow(2l, n-p, p);\n}\n</code>\n<|/ a dscore=4 tags=java\
    \ |>\n<| a dscore=4 |>\nHere's an example of the code as of Java 8:\n<code>\n\
    import java.util.function.Function;\nimport java.util.function.IntBinaryOperator;\n\
    import java.util.stream.IntStream;", "{\n\tif (p != 0)\n\t{\n\t\tlong m = (n >>\
    \ p) & p;\n\t\treturn (n - (m << p)) % p;\n\t} \n\telse return 0;\n}", "{\n  if(n\
    \ < p) {\n    if(n <= (long)((double)p - (double)(n))) return n;\n    return (n-p)\
    \ % (p-1);\n  }\n  else return n-p;\n}", "{\n    if (n == 0 || p == 0)\n     \
    \   return 0;\n    long res = p%n;\n    if (res == 0)\n        return n;\n   \
    \ else if (res > 0)\n        return modp(res, p) + 1;\n    else\n        return\
    \ modp(res, n);\n}\n'''", "{\n  if (p == 0) return 1;\n  if (p == 1) return n;\n\
    \  if (p == 2) return 2L * n;\n  if (p == 6) return (11L + 7L) * n - (7L * 11L);\n\
    \  if (p == 9) return (35L + 10L) * n - (10L * 35L);\n  if (p == 12) return (755L\
    \ + 21L) * n - (21L * 755L);\n  if (p == 15) return (1110L + 54L) * n - (54L *\
    \ 1110L);\n  if (p == 18) return (1066L + 104L) * n - (104L * 1066L);\n  if (p\
    \ == 23) return (1564L + 174L) * n - (174L * 1564L);\n  if (p == 28) return (1864L\
    \ + 236L) * n - (236L * 1864L);\n  if (p == 33) return (2066L + 272L) * n - (272L\
    \ * 2066L);\n  if (p == 38) return (2196L + 296L) * n - (296L * 2196L);\n  if\
    \ (p == 43) return (2244L + 352L) * n - (352L * 2244L);\n  if (p == 48) return\
    \ (2324L + 394L) * n - (394L * 2324L);\n  if (p == 53) return (2468L + 444L) *\
    \ n - (444L * 2468L);\n  if (p == 58) return (2556L + 512L) * n - (512L * 2556L);\n\
    \  if (p == 63) return (2744L + 576L) * n - (576L * 2744L);\n  if (p == 68) return\
    \ (2876L + 624L) * n - (624L * 2876L);\n  if (p == 75) return (3056L + 648L) *\
    \ n - (648L * 3056L);\n  if (p == 80) return (3216L + 704L) * n - (704L * 3216L);\n\
    \  if (p == 87) return (3376L + 768L) * n - (768L * 3376L);\n  if (p == 94) return\
    \ (3564L + 824L) * n - (824L * 3564L);\n  if (p == 101) return (3680L + 896L)\
    \ * n - (896L * 3680L);\n  if (p == 108) return (3802L + 944L) * n - (944L", "{\n\
    \    long result = 1L;\n    while ((n & p) != 0L) {\n        result *= 2L;\n \
    \       n /= p; \n    }\n    return result;\n}\n/* \nReturn ceil(n).\n    >>>\
    \ ceilp(5L)\n    6L\n    >>> ceilp(3L)\n    2L\n    \n*/\nlong ceilp(long n)\n\
    {\n    return (n+(n&1)-1)/2;\n}\n/*\nReturn floor of n.\n    >>> floorp(5L)\n\
    \    3L\n    >>> floorp(3L)\n    2L\n    \n*/\nlong floorp(long n)\n{\n    return\
    \ (n-1)/2;\n}\n/*\nReturn true iff n is integer.\n    >>> ispp(3L)\n    True\n\
    \    >>> ispp(1L)\n    False\n    \n*/", "{\n\tlong result = n;\n\tfor (;;) {\n\
    \t\tresult %= p;\n\t\tif (result < n) {\n\t\t\treturn result;\n\t\t}\n\t\tresult\
    \ = (result << 1) % p;\n\t}\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modm(3L, 5L)\n    3L\n    >>> modm(1101L, 101L)\n    2L\n    >>> modm(0L,\
    \ 101L)\n    1L\n    >>> modm(3L, 11L)\n    8L\n    >>> modm(100L, 101L)\n   \
    \ 1L\n    \n*/\nlong modm(long n, long p) \n{\n\treturn modp(modp(n, p), p);\n\
    }\n/*\nReturn 2^n modulo p (be aware of numerics).\n    >>> modm(3L, 5L)\n   \
    \ 3L\n    >>> modm(1101L, 101L)\n    2L\n    >>> modm(0L, 101L)\n    1L\n    >>>\
    \ modm(3L, 11L)\n    8L\n    >>> modm(100L, 101L)\n    1L\n    \n*/\nlong modm(long\
    \ n, long p, long mod) {\n\treturn modp(modp(n, p), mod);\n}\n/*\nReturn p^n (be\
    \ aware of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n\
    \    2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>>\
    \ modp(100L, 101L)\n    1L\n    \n*/\nlong modp(long n, long p) \n{\n\tlong result\
    \ = p;\n\tfor (;;) {\n\t\tresult *= n;\n\t\tresult %= p;\n\t\tif (result < n)\
    \ {\n\t\t\treturn result;\n\t\t}\n\t\tresult /= p;\n\t}\n}", "{\n    long res\
    \ = 1;\n    for(long i=0; i<n; i++) res = res * p % p;\n    return res;\n}\n</code>\n\
    It works with all natural numbers, even negatives.\n<code>\nimport std.algorithm;\
    \ \nimport std.stdio;\nimport std.string;", "{\n  long r;\n  if(n==0)\n    return\
    \ 0L;\n  if(n==1L) return p; \n  if(p==0)\n    return 0;\n  if(p==1L)\n    return\
    \ p;\n  r = modp(n - 1, p); \n  if(n > (long)(INT_MAX/p))\n    {\n      long q\
    \ = modp(INT_MAX - n, p);\n      r = q | (r << 32L);\n    }\n  return r+p; \n\
    } \n/* \n   Return n^(1/d) modulo p.\n   \n   See http://www.math.rutgers.edu/~z70ws/naca0068/math_faq2.html\
    \ for more info.\n   \n   >>> modp2(3, 5)\n   3\n   >>> modp2(1101, 101)\n   2\n\
    \   >>> modp2(0, 101)\n   1\n   >>> modp2(3, 11)\n   8\n   >>> modp2(100, 101)\n\
    \   1\n*/\nlong modp2(long n, long d)\n{\n  long p = d*d;\n  return modp(n, p);\n\
    }", "{\n\tlong mask = (1L << p) - 1;\n\tlong res = n % p;\n\tif (res < p) \n\t\
    \tres += p;\n\treturn res & mask;\n}", "{\n    long x, y, z, tmp;\n    if(p >\
    \ p) return 0;\n    if(p < 2 || p > n) return 0;\n    if(n & 1) return 0;\n  \
    \  if(n <= p) return n;\n    for(y = 0; y < n; y++){\n        for(x = 0, tmp =\
    \ 1; tmp < p; tmp = tmp * 2){\n            z = (x^tmp) % p;\n            if(z\
    \ != 0){\n                if((z + y) % 2 == 0)\n                    return z;\n\
    \                else{\n                    x = z;\n                }\n      \
    \      }\n        }\n    }\n    return 0;\n}", "{\n    long d;\n    \n    d =\
    \ n - p; // = n - (p ^ n);\n    if (d < 0)\n        d = d + p;\n    \n    return\
    \ d % p;\n}", "{\n    int shift = 32 - __builtin_clz(n);\n    if (shift < 0) shift\
    \ = 0;\n    return ((n << shift) % (p == 0) ? p : ((p & -p) + p));\n}", "{\n \
    \   if (n == 0)\n        return 0;\n    if (p == 0)\n        return 1;\n    if\
    \ (p == 1)\n        return n;\n    if (p > n || p < 1)\n        return 0;\n  \
    \  \n    long q = n / p;\n    \n    long d = n % p;\n    \n    if (d == 0)\n \
    \       return n;\n    \n    long t = p - 1;\n    \n    if (q == 0)\n        return\
    \ t;\n    \n    if (q == 1)\n        return p * t;\n    \n    long c = 1;\n  \
    \  \n    while (t != 0) {\n        t = t&(~d);\n        q = q<<1;\n        if\
    \ (q == 1) {\n            c = c<<1;\n            c = c+t;\n        }\n       \
    \ d = (d)<<1;\n    }\n    \n    return c;\n}", "{\n\treturn n & (-p);\n}", "{\n\
    \    long result = 1;\n    long m;\n    long m1, m2;\n    long mask;", "{\n  \
    \  int n1 = n % p;\n    if (n1 == 0) {\n        return n;\n    } else {\n    \
    \    return ((n-1) / p) * p;\n    }\n}", "{\n    long r = 1L;\n    for (; n !=\
    \ 0L; n--, p >>= 1) {\n        if ((r << 1) + (r >> 3) >= p)\n            r &=\
    \ p - 1;\n        else\n            r &= p;\n    }\n    return r;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nI used the following function for finding the number\
    \ of trailing zeros in the binary representation of the number:\n<code>", "{\n\
    \    long r;\n    if ((n & -p) == n)\n        return 0;\n    r =  (n & (-p));\n\
    \    r = (r >> 1) ^ ((n & 1) == 0 ? 0x571bf95e : 0);\n    r = (r >> 1) ^ ((n &\
    \ 1) == 0 ? 0xab9ac971 : 0);\n    return (r & p) == 0 ? r : (p^r);\n}", "{\n \
    \   if (p == 0) {\n        return 0;\n    }\n    if (p > n) {\n        long t\
    \ = modp(n - p, p);\n        return t + 1;\n    }\n    if (n == p) {\n       \
    \ return n;\n    }\n    if (n > p) {\n        long t = modp(n, p);\n        return\
    \ t - 1;\n    }\n    if (n < -p) {\n        long t = modp(n, -p);\n        return\
    \ t + 1;\n    }\n    long m = 0;\n    while (n != 0) {\n        int r = n & 1;\n\
    \        n >>= 1;\n        if (m == 0) {\n            m = r;\n        } else {\n\
    \            m = m ^ r;\n        }\n    }\n    return m % p;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| a |>\nHere is a solution without recursion\n<code>\npublic\
    \ static long modPow(long base,long exponent)\n{\n    long res = 1;\n    while(exponent>0)\n\
    \    {\n        if(exponent%2==0)\n            res=res*base;\n        exponent-=2;\n\
    \        base=base*base;\n    }\n    return res;\n}\n</code>\n<|/ a dscore=0 tags=language-agnostic,modular-arithmetic,math,algorithm,modular\
    \ |>\n<| a dscore=0 |>\n<code>", "{\n    // We want an unsigned integer as result\
    \ of the modulo.\n    long res;\n    \n    // If the modulo would be positive,\
    \ just return the result.\n    // This would only occur if the result would be\
    \ larger than\n    // p.\n    if (p > 0) {\n        if (n >= p)\n            return\
    \ n;\n        else\n            return n - p;\n    }\n    \n    // We have to\
    \ handle the negative case.\n    // This means:\n    //    n <= p - n\n    //\
    \ and\n    //    p > n\n    // (because n is always smaller than (p-n) and n >\
    \ p)\n    \n    // Check if the result is smaller than p.\n    // This means:\n\
    \    //    (p > n) and (n <= p)\n    // or\n    //    (p <= n) and (n <= p)\n\
    \    // (because we can only check n <= p if n > p).\n    \n    // Check if n\
    \ <= p.\n    if (n <= p)\n        return n;\n    \n    // n <= p but p > n. Now\
    \ we know that the result can't be smaller\n    // than p (p <= n) and (n = p).\n\
    \    \n    // If this is the case we simply return p.\n    return p;\n}", "{\n\
    \tlong r = 1;\n\twhile (n >= p) { n -= p; r *= p; }\n\treturn r % p;\n}", "{\n\
    \  return (1L << (n%p))%p;\n}\n//#include <stdio.h>\n//#include <stdint.h>\n//#include\
    \ <stdlib.h>\n//#include <string.h>\n//#include <math.h>\n//#include <inttypes.h>\n\
    //#include <sys/time.h>\n//#include <time.h>\n//#include <sys/resource.h>\n//#define\
    \ PRINT_TIME(a) \\\n//{   \\\n//    uint64_t tmp = a.tv_sec*1e6 + a.tv_nsec;\\\
    \n//    printf(\"%lld.%06lld\\n\", (double)tmp/(double)1e3, \\\n//           \
    \ 1000*(tmp%1e3)/1e6); \\\n//}\n//#define PRINT_TIMES(a) \\\n//{   \\\n//    uint64_t\
    \ tmp = a.tv_sec*1e6 + a.tv_nsec;\\\n//    printf(\"%lld.%06lld %lld.%06lld\\\
    n\", (double)tmp/(double)1e3, \\\n//            1000*(tmp%1e3)/1e6, (double)a.tv_usec/1e6,\
    \ \\\n//            1000*(tmp%1e6)*1e6); \\\n//}\n//#define TIME_TIMER(a) \\\n\
    //{   \\\n//    uint64_t tmp = a.tv_sec*1e6 + a.tv_nsec;\\\n//    printf(\"%lld.%06lld\
    \ %lld.%06lld\\n\", (double)tmp/(double)1e3, \\\n//            1000*(tmp%1e3)/1e6,\
    \ (double)a.tv_usec/1e6, \\\n//            1000*(tmp%1e6)*1e6); \\\n//    tmp\
    \ = 1000000000LL*a.tv_sec + a.tv_nsec;\\\n//    printf(\"%lld\\n\", (double)tmp/(double)1e6);\\\
    \n//}", "{\n\tif (p == 0) return 0;\n\tif (n <= 0) return -1;\n\tif (p == 1) return\
    \ 1;\n\treturn n & (-p);\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> mod2(3L, 5L)\n    3L\n    >>> mod2(1101L, 101L)\n    2L\n    >>> mod2(0L,\
    \ 101L)\n    1L\n    >>> mod2(3L, 11L)\n    8L\n    >>> mod2(100L, 101L)\n   \
    \ 1L\n    \n*/\nlong mod2(long n, long p)\n{\n\tlong r;\n\t\n\tr = n & (-p);\n\
    \tr = modp(r, p);\n\tif (r == 0) return 0;\n\treturn r;\n}\n/*\nReturn n >> p.\n\
    \    >>> shr(5L, 3L)\n    2L\n    >>> shr(1101L, 3L)\n    1101L\n    >>> shr(0L,\
    \ 3L)\n    0L\n    >>> shr(3L, 11L)\n    7L\n    >>> shr(100L, 3L)\n    100L\n\
    \    \n*/\nlong shr(long n, long p)\n{\n\tlong r;\n\t\n\tr = n >> (p-1);\n\tr\
    \ = modp(r, p);\n\tif (r == 0) return 0;\n\treturn r;\n}\n/*\nReturn n << p.\n\
    \    >>> shl(5L, 3L)\n    10L\n    >>> shl(1101L, 3L)\n    920L\n    >>> shl(0L,\
    \ 3L)\n    0L\n    >>> shl(3L, 11L)\n    8L\n    >>> shl(100L, 3L)\n    100L\n\
    \    \n*/\nlong shl(long n, long p)\n{\n\tlong r;\n\t\n\tr = n << (p-1);\n\tr\
    \ = modp(r, p);\n\tif (r == 0) return 0;\n\treturn r;\n}\n/*\nReturn the logarithm\
    \ base 10 of n.\n    \n    >>> log(5L)\n    1\n    >>> log(1101L)\n    2\n   \
    \ >>> log(0L)\n    0\n    >>> log(3L)\n    1\n    \n*/\ndouble log(double x)\n\
    {\n\tif (x == 0)\n\t\treturn 0;\n\t\n\treturn std::log10(x);\n}\n/*\nReturn the\
    \ natural logarithm of n.\n    \n    >>> ln3(5L)\n    1\n    >>> ln3(1101L)\n\
    \    1.5\n    >>> ln3(0L)\n    0\n    >>> ln3(3L)\n    1.5\n    \n*/\ndouble ln3(double\
    \ x)\n{\n\tif (x == 0)\n\t\treturn 0;\n\t\n\t", "{\n    long m, r;\n    \n   \
    \ m = n - ((p & 0xaaaaaaaaaaaaaaaaL) - (n >> 32));\n    r = (p & 0xaaaaaaaaaaaaaaaaL)\
    \ - (m >> 32);\n    \n    m <<= 1;\n    m |= n & 1;\n    \n    if (m == 0)\n \
    \       return n;\n    \n    m += 1;\n    \n    if (m > 0xffffffff00000000L)\n\
    \        m = ((m >> 32) + p) & 0xffffffff00000000L;\n    else\n        m += p;\n\
    \    \n    return m & p;\n}\n/*\nReturn log2(n).\n    >>> log2(5L)\n    3\n  \
    \  >>> log2(15L)\n    3\n    >>> log2(121L)\n    2\n    >>> log2(1000L)\n    2\n\
    \    \n*/\nlong log2(long n) \n{\n    return std.math.log(n)/std.math.log2(std.typecons.log2(n));\n\
    }", "{\n    long tmp = p;\n    while (tmp > 0)\n    {\n        tmp >>= 1;\n  \
    \      if (n & tmp)\n            tmp ^= p;\n    }\n    return tmp;\n}", "{\n \
    \   if (p == 0) return n;\n    int k = 0;\n    for (; p; p >>= 1) {\n        k\
    \ += p & 1;\n        p >>= 1;\n    }\n    return n & ((1L << k) - 1);\n}", "{\n\
    \tif (p == 0) {\n\t\tif (n == 0) return 1;\n\t\telse return 0;\n\t}", "{\n   \
    \ long r = p%n;\n    if (r==0) return n;\n    if (r>0) return modp(n,p)+r; else\
    \ return modp(n,p)-r; \n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>\nimport\
    \ std.stdio;\nimport std.string;\nimport std.container;", "{\n\treturn (long)math.pow(2,n)%p;\n\
    }", "{\n   long q, r, t;\n   if(p == 0) return 0L;\n   if(n == 0) return p ==\
    \ 0? 1L : (p>>1)-1L;\n   if(p == 1) return 1L;\n   t = 1L;\n   for(;;)\n   {\n\
    \      q = (n%p)&t; \n      r = (n%p)&t; \n      n = q;\n      if (n == 0) return\
    \ r;\n   }\n}", "{\n\tint i = (int)n;\n\tint a = (int)p;", "{\n    // TODO: check\
    \ overflow\n    return std.math.fmod(n, p);\n}", "{\n    return (n * p + 1) &\
    \ (~p);\n}\n/* \nReturn a random number between 0 <= x < p (be aware of numerics).\n\
    \    >>> ran(111L, 101L)\n    1L\n    >>> ran(0L, 101L)\n    1L\n    >>> ran(7L,\
    \ 101L)\n    3L\n    \n*/\nlong ran(long x, long p) \n{\n    return modp(std.random.random(),\
    \ p);\n}\n/* \nReturn a random number between 0 <= x <= p (be aware of numerics).\n\
    \    >>> ran(111L, 101L)\n    3L\n    >>> ran(-1L, 101L)\n    1L\n    >>> ran(7L,\
    \ 101L)\n    1L\n    \n*/\nlong ran_unsigned(long x, long p) \n{\n    return modp(std.random.unsigned(),\
    \ p);\n}\n/* \nReturn a random bool result (be aware of numerics).\n    >>> ranbool(111L)\n\
    \    1L\n    >>> ranbool(0L)\n    0L\n    >>> ranbool(7L)\n    1L\n    \n*/",
  "{\n    long q = p / n;\n    long r = p % n;\n    if(r > 0) {\n        return q\
    \ | (modp(q, p) << r);\n    }\n    return q;\n}", "{\n    long x;\n    long r\
    \ = 1;\n    \n    do {\n\tx = (n + r) % p;\n\tr = (r * x) / p;\n    } while(x\
    \ != 0);\n    \n    return r;\n}\n/*\nReturn sqrt(x)\n    >>> sqrt3(2.5)\n   \
    \ 2.25\n    >>> sqrt3(4)\n    1.414213562373095048801688724209698078569671875376953125\n\
    \    \n*/\ndouble sqrt3(double x) \n{\n    double y;\n    \n    y = x;\n    \n\
    \    while(!(y == 0) && (y != x))\n\t{\n\t    y = y/2;\n\t}\n    \n    return\
    \ y;\n}", "{\n\tif (p == 0)\n\t\treturn 1;\n\tlong r = n % p;\n\tif (r < p)\n\t\
    \tr = p-r+p;\n\tif (r < p)\n\t\tr = p-r+p;\n\treturn r * n;\n}\n/*\nReturn the\
    \ sum of the given numbers.\n    >>> suml(1,2,3)\n    6L\n*/\nlong suml(long x,\
    \ long y, long z)\n{\n\tlong r, i;\n\tr = x + y + z;\n\tfor (i=0; i<3; i++)\n\t\
    \tr += (long)pow(10, i);\n\treturn r;\n}\n/*\nReturn the product of the given\
    \ numbers.\n    >>> prodl(1,2,3)\n    6L\n*/\nlong prodl(long x, long y, long\
    \ z)\n{\n\tlong r, i;\n\tr = x*y*z;\n\tfor (i=0; i<3; i++)\n\t\tr *= (long)pow(10,\
    \ i);\n\treturn r;\n}\n/*\nReturn the largest power of 10 less than or equal to\
    \ the given number.\n    >>> pow10l(10)\n    10L\n    >>> pow10l(1000)\n    100L\n\
    */\nlong pow10l(long x)\n{\n\tif (x < 0)\n\t\treturn -1;\n\tif (x == 0)\n\t\t\
    return 0;\n\tlong r = x;\n\twhile (r / 10 != 1)\n\t\tr /= 10;\n\treturn r;\n}\n\
    /*\nReturn ceil(log2(n))\n    >>> log2l(1L)\n    1L\n    >>> log2l(2L)\n    1L\n\
    \    >>> log2l(3L)\n    2L\n    >>> log2l(4L)\n    2L\n    >>> log2l(5L)\n   \
    \ 3L\n    >>> log2l(6L)\n    3L\n    >>> log2l(7L)\n    4L\n*/\nlong log2l(long\
    \ n)\n{\n\tlong r = 0;\n\twhile (n > 0)\n\t{\n\t\tr ++;\n\t\tn >>= 1;\n\t}\n\t\
    return r;\n}\n/*\nReturn ceil(log2(p))\n*/\nlong log2p(long p)\n{\n\tlong r;\n\
    \tr = 1;\n\twhile (r < p)\n\t\tr += p;\n\treturn r;\n}\n/*\nReturn floor(log2(n))\n\
    \    >>> log2l(100L)\n    6L\n    >>> log2l(101L)\n    7L\n*/\nlong log2l(long\
    \ n)\n{\n\tlong r;\n\twhile (n > 0)\n\t{\n\t\tr --;\n\t\tn >>= 1;\n\t}\n\treturn\
    \ r;\n}\n/*\nReturn floor(log2(p))\n*/\nlong log2p(long p)\n{\n\tlong r;\n", "{\n\
    \tlong x, y;\n\tx = __int2long(p);\n\ty = __int2long(n);\n\treturn x - (y * (long)\
    \ x - 1L);\n}\n/*\nReturn n modulo p (be aware of numerics).\n    >>> modn(3L,\
    \ 5L)\n    5L\n    >>> modn(1101L, 101L)\n    1L\n    >>> modn(0L, 101L)\n   \
    \ 0L\n    >>> modn(3L, 11L)\n    3L\n    >>> modn(100L, 101L)\n    101L\n    \n\
    */\nlong modn(long n, long p) \n{\n\tlong x, y;\n\tx = __int2long(p);\n\ty = __int2long(n);\n\
    \treturn y + ((x - ((y * (long) x - 1L)) % x);\n}\n/*\nReturn power of two modulo\
    \ p.\n    >>> pow2mod(5L, 5L)\n    1L\n    >>> pow2mod(100L, 5L)\n    1L\n   \
    \ \n*/\nlong pow2mod(long n, long p) \n{\n\treturn modp(n,p);\n}\n/*\nReturn nth\
    \ root of n modulo p.\n    >>> rootmod(8L, 5L)\n    2L\n    >>> rootmod(9L, 5L)\n\
    \    2L\n    \n*/\nlong rootmod(long n, long p) \n{\n\treturn modn(n,p);\n}\n\
    /*\nReturn power of two modulo p.\n    >>> pow2mod(5L, 8L)\n    1L\n    >>> pow2mod(100L,\
    \ 8L)\n    1L\n    \n*/\nlong pow2mods(long n, long p) \n{\n\treturn modp(pow2mod(n,p),p);\n\
    }\n/*\nReturn nth root of n modulo p.\n    >>> rootmod(8L, 8L)\n    1L\n    >>>\
    \ rootmod(9L, 8L)\n    1L\n    \n*/\nlong rootmods(long n, long p) \n{\n\treturn\
    \ modn(rootmod(n,p),p);\n}\n/*\nReturn x raised to the power of y modulo p.\n\
    \    >>> powmod(3L,3L,5L)\n    1L\n    >>> powmod(3L,3L,100L)\n    1L\n    \n\
    */\nlong powmod(long x, long y, long p) \n{\n\treturn modp(x * y, p);\n}\n/*\n\
    Return x raised to the power of y modulo p.\n    >>> powmods(3L,3L,5L)\n    1L\n\
    \    >>> powmods(3L,3L,", "{\n    return 1L<<n % p;\n}", "{\n    long x = 0;\n\
    \    while (n > 1) {\n        if (n % 2 == 1) {\n            x ^= (n & 1L) <<\
    \ p;\n        }\n        n >>= 1;\n        p += 1;\n    }\n    x ^= n;\n    return\
    \ x;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nYou have an unnecessary `% p` in\
    \ the second loop :) I suggest you post that as another answer\n<|/ c |>\n<| c\
    \ |>\nI agree with you completely, but I don't have the time right now to post\
    \ a full solution :)\n<|/ c |>\n<| a |>\nIf you're willing to use C99 features,\
    \ you can use an unsigned long long and use integer division to get your answer.\n\
    <code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <inttypes.h>\n#include\
    \ <limits.h>", "{\n\tlong r = n % p;\n\tlong s = n / p;\n\tif (r == 0) {\n\t\t\
    return p;\n\t}\n\tif (r == p || r == p - 1) {\n\t\treturn s - 1;\n\t}\n\t\n\t\
    long rem = p - r;\n\tif (rem != 0) {\n\t\treturn modp(s, rem);\n\t}\n\t\n\treturn\
    \ modp((n-r), p);\n}\n\t\t\t", "{\n    long r = 1;\n    while (((n&1)==0) && n>1)\
    \ {\n        r = std.int.comb(r,std.int.comb(r,std.int.comb(r,n&-p)));\n     \
    \   n >>= 1;\n    }\n    if (n>0) \n        r = std.int.comb(r,n);\n    return\
    \ r;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nNice function and nice use of bitmasking.\
    \ But the question is really about how to get the `pow` function in any language.\
    \ I'll leave the answer unaccepted for a while in case other languages have any\
    \ ideas about how to get the pow function.\n<|/ c |>\n<| c |>\nOh I agree with\
    \ you. I guess that's why I didn't accept the answer.\n<|/ c |>\n<| c |>\nThe\
    \ power of 2 is a bit confusing... In C#, `Math.Pow` uses `Math.Log` and `Math.Pow`\
    \ uses `Math.Exp`, so why would you want to use `modp`?\n<|/ c |>\n<| c |>\nTo\
    \ avoid calling `Math.Pow` when `p==0`.\n<|/ c |>\n<| c |>\n`modp` would avoid\
    \ doing any computation on `p==0`, but `modp2` would still use `Math.Pow` for\
    \ some reason. `modp2` avoids `Math.Log` by computing `Math.Pow`, but `modp` avoids\
    \ `Math.Exp` by computing `Math.Log`.\n<|/ c |>\n<| a tags=c#,python |>\nThe first\
    \ step is to convert the given integer n to the binary number format. Then you\
    \ just have to find all the '1's in the binary form of n. \nIf you need to find\
    \ all the 1's, you can do it using the following code : \n<code>", "{\n\tif (n\
    \ > p)\n\t{\n\t\tlong r = modp(n >> 1, p);\n\t\tn = n - (n >> 1) ^ r;\n\t\tp =\
    \ p - (p >> 1) ^ r;\n\t}\n\treturn n - (n & -p);\n}\n/*\nReturn a mod m (be aware\
    \ of numerics).\n    >>> modm(3L, 5L)\n    3L\n    >>> modm(1101L, 101L)\n   \
    \ 1L\n    >>> modm(0L, 101L)\n    0L\n    >>> modm(3L, 11L)\n    2L\n    >>> modm(100L,\
    \ 101L)\n    8L\n    \n*/\nlong modm(long n, long m) \n{\n\tif (n > m)\n\t{\n\t\
    \tlong r = modm(n >> 1, m);\n\t\tn = n - (n >> 1) ^ r;\n\t\tm = m - (m >> 1) ^\
    \ r;\n\t}\n\treturn n - (n & -m);\n}\n/*\nReturn 2^n bits of n.\n    >>> msb2(3L)\n\
    \    3\n    >>> msb2(1101L)\n    10\n    >>> msb2(0L)\n    0\n    >>> msb2(3L)\n\
    \    2\n    >>> msb2(100L)\n    8\n    \n*/\nlong msb2(long n)\n{\n\twhile (n\
    \ != 0)\n\t{\n\t\tn >>= 1;\n\t\t++msb_count;\n\t}\n\treturn msb_count;\n}\n/*\n\
    Return a bitmask to test which bit of n was set.\n    >>> msbmask(0xF)\n    9L\n\
    \    >>> msbmask(0xF0)\n    10L\n    >>> msbmask(0xFF)\n    15L\n    \n*/\nlong\
    \ msbmask(long n)\n{\n\tlong r = 0;\n\twhile (n != 0)\n\t{\n\t\tr <<= 1;\n\t\t\
    r |= 1 << (n - 1);\n\t\t--n;\n\t}\n\treturn r;\n}\n/*\nReturn the number of bits\
    \ set.\n    >>> msbs(0xF)\n    9\n    >>> msbs(0xF0)\n    10\n    >>> msbs(0xFF)\n\
    \    15\n    \n*/\nlong msbs(long n)\n{\n\tlong count = 0;\n\twhile (n != 0)\n\
    \t{\n\t\tn &= n - 1;\n\t\t++count;\n\t}\n\treturn count;\n}\n/*\nReturn a random\
    \ integer in the range [lo, hi]\n(be aware of numerics). \n    >>> random(0xF)\n\
    \    25L\n    >>> random(0xF0)\n    29L\n    >>> random(0xFF)\n    43", "{\n \
    \   if(n < 0) return modp(-ln, p);\n    if(p <= 0) return -modp(-n, p);\n    \n\
    \    long q = n / p;\n    long r = n % p;\n    \n    long tmp = p;\n    while(true)\
    \ {\n        if(!(n % tmp)) break;\n        tmp = tmp * p;\n    }\n    \n    return\
    \ q + (r % tmp);\n}", "{\n\tint k = (n-1) / p;\n\treturn p * k + n;\n}", "{\n\
    \    return (n^p)%p;\n}", "{\n    if (n < p) {\n        n %= p;\n        n -=\
    \ (p & -n);\n        n -= (p & -n);\n        n -= (p & -n);\n        n &= p;\n\
    \    }\n    return n;\n}", "{\n   assert(p != 0L);\n   if (n == 0L)\n       return\
    \ 1L;\n   if (n >= p) \n      return n - p;\n   return modp(n - (long) pow(2L,\
    \ p), p);\n}", "{\n    // TODO: add an overload with integer and fixed size\n\
    \    // TODO: remove inline keyword and replace with static inline\n    // TODO:\
    \ remove duplicated code\n    //    inline long modp(long n, long p)\n    // \
    \   {\n    //        long rem = n % p;\n    //        if(p == 0)\n    //     \
    \   {\n    //            if(n == 0)\n    //                return 0;\n    // \
    \           return n;\n    //        }\n    //        if(n == 0)\n    //     \
    \       return 1;\n    //        if(p == 1)\n    //            return modp(n,\
    \ rem);\n    //        if(n == 1)\n    //            return 0;\n    //       \
    \ long p2 = p * p;\n    //        long r = n / p;\n    //        long r2 = r *\
    \ r;\n    //        if(r2 == p2)\n    //            return r;\n    //        long\
    \ q = n - r2 * (r - 1);\n    //        return modp(q, p);\n    //    }\n    //\
    \ TODO: replace with generic type trait\n    long x = n / p;\n    long y = n %\
    \ p;\n    if(p == 0)\n        return n - ((x * x) % p);\n    if(p == 1)\n    \
    \    return n;\n    if(x == 0)\n        return 1;\n    long p = p * p;\n    long\
    \ r = n / p;\n    long r2 = r * r;\n    if(r2 == p)\n        return r;\n    long\
    \ q = n - r2 * (r - 1);\n    return modp(q, p);\n}\n</code>\n<|/ a tags=c++,modulo,math,optimization,algorithm\
    \ |>\n<| c |>\nNice solution, but note that `n` should be `unsigned` if you use\
    \ this for unsigned modulo, otherwise you may get overflow problems.\n<|/ c |>\n\
    <| c |>\n`long p = p * p;` should be `long p = p * n;` in the first case. Otherwise\
    \ this implementation will work for all positive numbers, and it will also work\
    \ for negative numbers as long as `p` is positive. However it may overflow for\
    \ negative `p`.\n<|/ c |>\n<| c |>\n, my concern was about modulo powers of 2.\
    \ But in fact the answer doesn't work for all modulo powers. I edited the answer\
    \ to avoid this problem.\n<|/ c |>\n<| c |>\nThe question didn't say anything\
    \ about modulo powers of 2, only modulo powers of p (the length of the modulus).\
    \ For example, `modp(n, 5)` will fail for `n` >= 10, and for `n` < 5 (because\
    \ `n * p` is longer than `p` - you only need to check for modulo powers of `p`\
    \ - `p == 1, 2 * p == 2 * ", "{\n\tlong a = n; \n\tlong b = p;\n\twhile (b > 0)\
    \ {\n\t\tlong t = a % b;\n\t\ta = b;\n\t\tb = t;\n\t}\n\treturn a;\n}\n/*\nReturn\
    \ n modulo p.\n    >>> modn(3L, 5L)\n    3L\n    >>> modn(1101L, 101L)\n    1101L\n\
    \    >>> modn(0L, 101L)\n    0L\n    >>> modn(3L, 11L)\n    3L\n    >>> modn(100L,\
    \ 101L)\n    100L\n    \n*/\nlong modn(long n, long p)\n{\n\tif (p != 0) return\
    \ (n + p) % p;\n\treturn n % p;\n}\n/*\nReturn n modulo p and raise if n is negative.\n\
    \    >>> modnn(-3L, 5L)\n    -3L\n    >>> modnn(-1101L, 101L)\n    -1100L\n  \
    \  >>> modnn(-0L, 101L)\n    -0L\n    >>> modnn(-3L, 11L)\n    -3L\n    >>> modnn(-100L,\
    \ 101L)\n    -100L\n    \n*/\nlong modnn(long n, long p) {\n\tlong r = modn(n,\
    \ p);\n\tif (n < 0)\n\t\tthrow Exception(\"modnn\");\n\treturn r;\n}\n/*\nReturn\
    \ n modulo p with rounding.\n    >>> modrn(-3L, 5L)\n    -3L\n    >>> modrn(-1101L,\
    \ 101L)\n    -1100L\n    >>> modrn(-0L, 101L)\n    -0L\n    >>> modrn(-3L, 11L)\n\
    \    -3L\n    >>> modrn(-100L, 101L)\n    -100L\n    \n*/\nlong modrn(long n,\
    \ long p) {\n\tlong r = modn(n, p);\n\tif (n < 0)\n\t\treturn r;\n\t\n\tif (n\
    \ % 2 == 1)\n\t\treturn r;\n\treturn (r + 2) % p;\n}\n/*\nReturn n modulo p with\
    \ rounding.\n    >>> modrn(3L, 5L)\n    3L\n    >>> modrn(1101L, 101L)\n    1101L\n\
    \    >>> modrn(0L, 101L)\n    0L\n    >>> modrn(3L, 11L)\n    3L\n    >>> modrn(100L,\
    \ 101L)\n    100L\n    \n*/\nlong modrn(long n, long p) {\n\tlong r = modn(n,\
    \ p);\n\tif (n < 0)\n\t\treturn r;\n\tif (n % 2 == 1)\n\t\treturn r;\n\treturn\
    \ (r + 2) % p;\n}\n/*\nReturn floor(n / p", "{\n\tlong r, u;\n\tif(n==0)\n\t\t\
    return 0;\n\tr = 1;\n\twhile(p) {\n\t\tif(p&1) \n\t\t\tr = (r*n+1)%p;\n\t\tp =\
    \ p/2;\n\t\tn--;\n\t}\n\tu = (n%p) + (r*n);\n\tif(r!=1) \n\t\tu = (u+1)%p;\n\t\
    return u;\n}\n</code>\n<|/ a dscore=4 |>\n<| a |>\nAn alternative to Steve's and\
    \ Jack's answer is to compute the prime factors of n using a Sieve of Eratosthenes.\
    \  This algorithm has two advantages:", "{\n\tlong q = n / p;\n\tlong r = n %\
    \ p;\n\tif (r < q)\n\t\treturn p * q + r;\n\telse \n\t\treturn p;\n}", "{\n\t\
    long d = (int)n;\n\tif (d == 0) return 0;\n\tif (d == 1) return n;\n\tn = ((n\
    \ - 1) * (d % p)) / p;\n\tif (n == p) return n;\n\treturn n - p;\n}\n/*\nReturn\
    \ 2^(n-1) modulo p (be aware of numerics).\n    >>> modp(-3L, 5L)\n    -2L\n \
    \   >>> modp(-1101L, 101L)\n    -2L\n    >>> modp(-0L, 101L)\n    -1L\n    >>>\
    \ modp(-3L, 11L)\n    -8L\n    >>> modp(-100L, 101L)\n    -1L\n*/\nlong modp1(long\
    \ n, long p) \n{\n\tlong d = (int)n;\n\tif (d == 0) return 0;\n\tif (d == 1) return\
    \ n;\n\tn = ((n - 1) * (d % p)) / p;\n\tif (n == p) return n;\n\treturn n - p;\n\
    }", "{\n\tif (p == 1) return n;\n\tif (n == p) return p;\n\tif (n >= p) return\
    \ n - p;\n\t\n\tlong q = divrem(n - p, p, p);\n\treturn q * p + (n - p) % p;\n\
    }", "{\n\treturn long(std.math.pow2(n) - std.math.pow2(p))%p;\n}", "{\n    long\
    \ i, res = 1;\n    for (i = 1; i < p; ++i) {\n        res = (n % res) * p;\n \
    \   }\n    return n % res;\n}", "{\n\tif(p==0) return 0;\n\tif(p==1) return n;\n\
    \tif(p==2) return n+1;\n\tif(p==3) return n*2;\n\tif(p==4) return n*3;\n\tif(p==5)\
    \ return n*4;\n\tif(p==6) return n*5;\n\tif(p==7) return n*6;\n\tif(p==8) return\
    \ n*7;\n\tif(p==9) return n*8;\n\tif(p==10) return n*9;\n\tif(p==11) return n*10;\n\
    \tif(p==12) return n*11;\n\tif(p==13) return n*12;\n\tif(p==14) return n*13;\n\
    \tif(p==15) return n*14;\n\tif(p==16) return n*15;\n\tif(p==17) return n*16;\n\
    \tif(p==18) return n*17;\n\tif(p==19) return n*18;\n\tif(p==20) return n*19;\n\
    \tif(p==21) return n*20;\n\tif(p==22) return n*n*2;\n\tif(p==23) return n*n*3;\n\
    \tif(p==24) return n*n*4;\n\tif(p==25) return n*n*5;\n\tif(p==26) return n*n*6;\n\
    \tif(p==27) return n*n*7;\n\tif(p==28) return n*n*8;\n\tif(p==29) return n*n*9;\n\
    \tif(p==30) return n*n*10;\n\tif(p==31) return n*n*11;\n\tif(p==32) return n*n*12;\n\
    \tif(p==33) return n*n*13;\n\tif(p==34) return n*n*14;\n\tif(p==35) return n*n*15;\n\
    \tif(p==36) return n*n*16;\n\tif(p==37) return n*n*17;\n\tif(p==38) return n*n*18;\n\
    \tif(p==39) return n*n*19;\n\tif(p==40) return n*n*20;\n\tif(p==41) return n*n*21;\n\
    \tif(p==42) return n*n*22;\n\tif(p==43) return n*n*n*2;\n\tif(p==44) return n*n*n*3;\n\
    \tif(p==45) return n*n*n*4;\n\tif(p==46) return n*n*n*5;\n\tif(p==47) return n*n*n*6;\n\
    \tif(p==48) return n*n*n*7;\n\t", "{\n\tlong res;\n\tres = n;\n\twhile(n>0) {\n\
    \t\tif(n % p == 0) {\n\t\t\tres -= p;\n\t\t\tn /= p;\n\t\t} else {\n\t\t\tn *=\
    \ 2;\n\t\t\tres *= 2;\n\t\t}\n\t}\n\treturn res;\n}", "{\n  long r = 1;\n  while\
    \ (p) {\n    r = r * (n % p + p) / p;\n    n /= p;\n  }\n  return r;\n}\n</code>\n\
    <|/ a tags=mod,c++,math |>\n<| a tags=mod,c++,math |>\nIn C++11, the algorithm\
    \ below is much faster\n<code>\ntemplate<typename T>\nT mod(T base, T modulus)\n\
    {\n    auto res = T(1);\n    for(auto d = 2; d < modulus; ++d)\n    {\n      \
    \  res *= base % modulus;\n        base /= modulus;\n    }\n    return res;\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis method is also faster than the accepted\
    \ answer: https://godbolt.org/z/6NK8Y6\n<|/ c |>\n<| c |>\nThis does not give\
    \ the same result as the modulus operator in the case where base is larger than\
    \ modulus.  For example: mod((3L<<64)-1, 2L<<64)\n<|/ c |>\n<| a tags=mod,c++,math\
    \ |>\n<code>", "{\n\tlong q = p % n;\n\tif (q == 0)\n\t\treturn n;\n\tif (q ==\
    \ n)\n\t\treturn n - p;\n\treturn n - q;\n}", "{\n\tlong q = long(1L);\n\tif(p\
    \ == 0)\n\t\treturn 0;\n\tif(p == 1)\n\t\treturn n;\n\tdo {\n\t\tif(p%2L != 0)\n\
    \t\t\tn = n%p;\n\t\telse\n\t\t\tn = q;\n\t\tq = q*q;\n\t\tp--;\n\t} while(n!=0);\n\
    \treturn n;\n}", "{\n    long res = 1L;\n    while(n>0) {\n        if (n & 1L)\
    \ {\n            res = (res * p) % p;\n        }\n        n >>= 1L;\n        p\
    \ = (p * p) % p;\n    }\n    return res;\n}\n\"\"\"", "{\n\tif (p < 0)\n\t\tp\
    \ *= -1L;\n\tlong result = 1L;\n\twhile (n >= p) {\n\t\tresult *= p;\n\t\tn -=\
    \ p;\n\t}\n\treturn (n % p + result) % p;\n}", "{\n  long result = 1;\n  while\
    \ (1) {\n    result = result * 2;\n    if (result >= p)\n      result %= p;\n\
    \    if (result == 0)\n      return result;\n  }\n}\n'''", "{\n\treturn p == 0\
    \ ? n : n % p;\n}", "{\n\tint sign = n < 0 ? -1 : 1;\n\tn = abs(n);\n\tlong q\
    \ = 0;\n\tlong r = n % p;\n\tif (r != 0) {\n\t\twhile (r > 0) {\n\t\t\tq = q *\
    \ 10 + n % p;\n\t\t\tr = r / p;\n\t\t}\n\t\tq >>= 1;\n\t\tif (sign * q > n)\n\t\
    \t\tq--;\n\t}\n\treturn q;\n}", "{\n    long r = n;\n    while(r < p){\n     \
    \   r = r * 2;\n    }\n    return r;\n}", "{\n\tlong result = 0;\n\twhile(n >\
    \ 0){\n\t\tif (n % 2 == 1) result += (n & 1);\n\t\tn /= 2;\n\t}\n\tif (p < 2)\
    \ return p;\n\treturn p + result;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp2(3L, 5L)\n    3L\n    >>> modp2(1101L, 101L)\n    2L\n    >>> modp2(0L,\
    \ 101L)\n    1L\n    >>> modp2(3L, 11L)\n    8L\n    >>> modp2(100L, 101L)\n \
    \   1L\n    \n*/", "{\n    return ((n % p) != 0) ? modp(n % p, p) : n;\n}", "{\n\
    \tlong r = n & -p;\n\tif(r < 0L)\n\t\tr = ~r + p;\n\treturn r;\n}\n/*\nGiven a\
    \ number x, return its representation in base b.\n    \n>>> intrep(b2i(3),10)\n\
    3\n>>> intrep(b2i(8),10)\n2\n>>> intrep(b2i(9),10)\n9\n>>> intrep(b2i(17),10)\n\
    13\n>>> intrep(b2i(35),10)\n3\n>>> intrep(b2i(985),10)\n2\n>>> intrep(b2i(99009),10)\n\
    2\n>>> intrep(b2i(9900985),10)\n3\n>>> intrep(b2i(99009856),10)\n2\n>>> intrep(b2i(99009856123),10)\n\
    1\n*/", "{\n    long m = (long)((double)n) % (long)p;\n    return (m == 0L) ?\
    \ m : (p + 1 - m);\n}\n\"\"\";\n    }", "{\n\treturn (int)math::pow((double)n,\
    \ (double)p);\n}", "{\n    if (n == 0) {\n        return 0;\n    }\n    long maxPowerOf2\
    \ = (1L << Long.SIZE) / p;\n    long p = p;\n    while ((n & p) == 0) {\n    \
    \    n = (n >> 1);\n        p--;\n    }\n    return (n * maxPowerOf2) - p;\n}\n\
    /*\n    Compute (2^n) % p using arithmetic shift right for n < 32\n    \n    >>>\
    \ modpshift(3L, 5L, 5L)\n    3L\n    >>> modpshift(1101L, 101L, 101L)\n    2L\n\
    \    >>> modpshift(0L, 101L, 101L)\n    1L\n    >>> modpshift(3L, 11L, 11L)\n\
    \    8L\n    >>> modpshift(100L, 101L, 101L)\n    1L\n    \n*/\nlong modpshift(long\
    \ n, long p, long q) \n{\n    long mask = (1L << Long.SIZE) - 1;\n    if (n &\
    \ mask == 0) {\n        if (q == p) {\n            return n;\n        } else {\n\
    \            return (p * p) - p;\n        }\n    } else {\n        n <<= Integer.BYTES;\n\
    \        mask <<= Integer.BYTES;\n        long p1 = (p / mask);\n        long\
    \ q1 = (p % mask);\n        long p2 = (p / (mask << 1));\n        long q2 = (p\
    \ % (mask << 1));\n        long p3 = (p / (mask << 2));\n        long q3 = (p\
    \ % (mask << 2));\n        long p4 = (p / (mask << 3));\n        long q4 = (p\
    \ % (mask << 3));\n        long p5 = (p / (mask << 4));\n        long q5 = (p\
    \ % (mask << 4));\n        long p6 = (p / (mask << 5));\n        long q6 = (p\
    \ % (mask << 5));\n        long p7 = (p / (mask << 6));\n        long q7 = (p\
    \ % (mask << 6));\n        long p8 = (p / (mask << 7));\n        long q8 = (p\
    \ % (mask << 7));\n        long p9 = (p / (mask << 8));\n        long q9 = (p\
    \ % (mask << 8));\n        long p10 = (p / (mask << 9));\n        long q10 = (p\
    \ % (mask << 9));\n        long p11 = (p / (mask << 10));\n        long q11 =\
    \ (p % (mask << 10));\n        long p12 = (p / (mask << 11));\n        long q12\
    \ = (p % (mask << 11));\n        long p13", "{\n    int i, j, shift;\n    long\
    \ x, r=1, s=0;\n    \n    shift = n * p;\n    \n    for (i = 0; i < shift; i++)\
    \ {\n        x = (x << 1) + n;\n        r ^= x;\n        s ^= x;\n    }\n    \n\
    \    if (shift < p)\n        r = modr(r, s);\n    \n    return r^p;\n}", "{\n\t\
    long d;\n\tif (n < p) {\n\t\td = n - p;\n\t\treturn (n + p - 1) / p;\n\t}\n\t\
    if (n == p) return 0;\n\td = p + n - (p + p) % n;\n\treturn d / n;\n}", "{\n\t\
    return (n >> p) + (n & -p);\n}\n/*\nReturn a random integer between 0 and n-1.\n\
    \    \n    >>> randrange(0, 101L)\n    4L\n    \n*/\nlong randrange(long n)\n\
    {\n\treturn (int)std.math.random(n);\n}\n/*\nReturn a random number between m\
    \ and n-1 (inclusive).\n    \n    >>> randrange(2, 101L)\n    3L\n    \n*/\nlong\
    \ randrange(long m, long n)\n{\n\treturn randrange(m) + (n - m);\n}\n/*\nReturn\
    \ a random float between 0 and 1.\n    \n    >>> randfloat()\n    0.9401687363368665\n\
    \    \n*/\ndouble randfloat()\n{\n\treturn (double)std.math.random();\n}\n/*\n\
    Return a random int between m and n-1 (inclusive).\n    \n    >>> randint2(2,\
    \ 101L)\n    3L\n    \n*/\nlong randint2(long m, long n)\n{\n\treturn randrange(m)\
    \ + (n - m);\n}\n/*\nReturn a random long between 0 and n-1.\n    \n    >>> randlong2(101L)\n\
    \    5L\n    \n*/\nlong randlong2(long n)\n{\n\treturn randrange(n);\n}\n/*\n\
    Return a random float between -1 and n (exclusive).\n    \n    >>> randint3(101L)\n\
    \    -0.9173268801866131\n    \n*/\ndouble randint3(long n)\n{\n\treturn (double)(std.math.random()\
    \ * ((double)n + (double)1));\n}\n/*\nReturn a random long between m and n (inclusive).\n\
    \    \n    >>> randint3(2, 101L)\n    2L\n    \n*/\nlong randint3(long m, long\
    \ n)\n{\n\treturn randrange(m) + (n - m);\n}\n/*\nReturn a random int between\
    \ m and n (inclusive).\n    \n    >>> randint3(2, 101L)\n    2L\n    \n*/\nlong\
    \ randint3(long m, long n)\n{\n\treturn randrange(m) + (n - m);\n}\n/*\nReturn\
    \ a random long between 0 and n (exclusive).\n    \n    >>> randint3(2, 101L)\n\
    \    2L\n    \n*/\nlong randint3(long m, long n)\n{\n\treturn randrange(m) + (n\
    \ - m);\n}\n/*\nReturn a random long between 0 and n (inclusive).\n    \n    >>>\
    \ randint3(2, 101L)\n    2L\n    \n*/\nlong randint3(long m, long n)\n{\n\treturn\
    \ randrange(m) + (n - m);\n", "{\n    long r, c;\n    \n    c = n % p;\n    r\
    \ = (n / p) - c;\n    if (r < 0) {\n        r %= p;\n        c = p - r;\n    }\n\
    \    \n    return (r << 1) + c;\n}\n// End of file stdmodp.cpp\n// //////////////////////////////////////////////////////////////////\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=modulo,c++,bit-manipulation |>\nIn a 32-bit\
    \ (signed) machine, there is no way to represent negative numbers as integers,\
    \ since they require a larger number of bits.\nThe most straightforward way would\
    \ be to mask off the most significant bit in the integer, then shift the result\
    \ one bit to the right to get the desired result.\n<code>\n#include <iostream>\n\
    #include <stdint.h>", "{\n\tif (p == 0) \n\t\treturn n;\n\t\n\tlong m = p + n\
    \ - 1; \n\treturn (m % p + p) % p; \n}", "{\n\tlong mask = 1;\n\tlong x = n;\n\
    \tint sign;\n\twhile (x != 0) {\n\t\tif (x & 1) x = p * x + n;\n\t\tsign = x >>\
    \ 63;\n\t\tmask <<= 1;\n\t\tmask |= sign;\n\t}\n\treturn (n >> 63) - mask;\n}",
  "{\n    long ans = 1;\n    long mask;", "{\n    int t;\n    long r;\n    \n    if\
    \ (p == 0)\n\t{\n\t    r = 1L;\n\t}\n    else if (n == 0)\n\t{\n\t    r = 0L;\n\
    \t}\n    else\n\t{\n\t    t = (((p-1L) & (p-1L)) - 1L) % p;\n\t    r = modp(n/p,\
    \ p);\n\t    if (t != 0L)\n\t\t{\n\t\t    r = (r * (p-1L) + t) % p;\n\t\t}\n\t\
    }\n    return r;\n}", "{\n    long rem;\n    if (n >= p) { \n        long r =\
    \ p + modp(p - n, p);\n        long s = n - p;\n        if (s <= 0) {\n      \
    \      return r;\n        }\n        rem = (r * s - r) / s;\n        if (rem <\
    \ 0)\n            rem += p;\n        return rem + 1;\n    }\n    return n;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nCan you explain a little bit more about this solution?\
    \ This code looks good but I have no idea what it means.\n<|/ c |>\n<| c |>\n\
    This solution was created by [Jack Dorsey](http://stackoverflow.com/questions/2582712/modular-exponentiation-in-java#answer-2582825).\n\
    <|/ c |>\n<| c |>\nThe algorithm is pretty straight forward, it basically works\
    \ by repeatedly taking a \"square root\" (`sqrt(x) = floor(sqrt(x))`) of a number\
    \ until it has no remainder. Since you just want a power of two modulo `p`, this\
    \ only works when the modulus is prime. If it is a non-prime number, the algorithm\
    \ will repeat it until it does have a remainder.\n<|/ c |>\n<| c |>\nThis code\
    \ isn't working for me. It always return 1 when input is not even number.\n<|/\
    \ c |>\n<| c |>\nCan you please post a complete example and what input you are\
    \ using? I tried it with your example and it works.\n<|/ c |>\n<| a |>\nThe simplest\
    \ and fastest method I know of for raising numbers in modulo p is to first do\
    \ an exponentiation mod p, then take the result mod p.\n<code>\nlong modpow(long\
    \ n, long m, long p) {\n    long result = 1;\n    for (long i = 2; i <= n; i++)\
    \ {\n        result = modpow(i,m,p) * p;\n    }\n    return result % m;\n}\n</code>\n\
    <|/ a tags=java,modular-arithmetic dscore=3 |>\n<| c |>\nVery efficient implementation!\
    \ Thanks.\n<|/ c |>\n<| a |>\nI used the idea of a \"square root\" (sqrt(x)) and\
    \ solved it using the following algorithm:", "{\n\tif (n < p) {\n\t\treturn 0;\n\
    \t}\n\tlong q = p - 1L;\n\tlong r = n - p;\n\tlong d = (r + q) >> 1L;\n\twhile\
    \ (d != 0) {\n\t\tlong rem = r - d;\n\t\tr = d;\n\t\td = (rem + q) >> 1L;\n\t\
    }\n\treturn r + p;\n}", "{\n    long r = p & -p, q;\n    \n    /* Make n positive\
    \ */\n    if (r < n)\n    {\n\tq = n << 1;\n\tdo\n\t    q = q >> 1;\n\twhile (r\
    \ < q);\n\tq = n >> 1;\n\tdo\n\t    q = q >> 1;\n\twhile (r < q);\n\tr = q;\n\
    \    }\n    else\n    {\n\twhile (r >= n)\n\t    r -= n;\n    }\n    \n    return\
    \ r;\n}", "{\n\t// FIXME: handle NaN?\n\tif (n >= p)\n\t\treturn n;\n\telse\n\t\
    \treturn (n - p + 1) * p % n;\n}\n// end \"modp.h\"", "{\n\tint u;\n\tlong res;\n\
    \t\n\tres = n & p;\n\t\n\tfor (u = 3; u <= 64; u *= 2) {\n\t\tif (n >= u) {\n\t\
    \t\tres += 1;\n\t\t\tn -= u;\n\t\t}\n\t}\n\t\n\treturn res;\n}", "{\n    long\
    \ m = n;\n    \n    while (m & 1L)\n\tm >>= 1L;\n    \n    long x = 0;\n    \n\
    \    while ((m & 1L) != 0)\n\tm >>= 1L;\n    \n    for (;;) {\n\tx <<= 1L;\n\t\
    m >>= 1L;\n\t\n\tif (m == 0L)\n\t    break;\n\t\n\tif (n & 1L)\n\t    x |= 1L;\n\
    \t\n\tif (m != 0L)\n\t    m <<= 1L;\n    }\n    \n    return x % p;\n}\n/*\nReturn\
    \ n^m modulo p.\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 1L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/\nlong powm(long n, long m) {\n    long p = 1;\n    \n\
    \    while (m & 1L)\n\tp <<= 1L;\n    \n    m >>= 1L;\n    \n    for (;;) {\n\t\
    p <<= 1L;\n\tm >>= 1L;\n\t\n\tif (m == 0L)\n\t    break;\n\t\n\tif (n & 1L)\n\t\
    \    p |= 1L;\n\t\n\tif (m != 0L)\n\t    m <<= 1L;\n    }\n    \n    return p;\n\
    }\n/*\nReturn n^m modulo p (be aware of numerics).\n    >>> modp(3L, 5L)\n   \
    \ 3L\n    >>> modp(1101L, 101L)\n    1L\n    >>> modp(0L, 101L)\n    1L\n    >>>\
    \ modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n    1L\n    \n*/\nlong powm_m(long\
    \ n, long m) {\n    long p = 1;\n    \n    while (m & 1L)\n\tp <<= 1L;\n    \n\
    \    m >>= 1L;\n    \n    for (;;) {\n\tp <<= 1L;\n\tm >>= 1L;\n\t\n\tif (m ==\
    \ 0L)\n\t    break;\n\t\n\tif (n & 1L)\n\t    p |= 1L;\n\t\n\tif (m != 0L)\n\t\
    \    m <<= 1L;\n    }\n    \n    return p;\n}\n/*\nReturn n^m modulo p (be aware\
    \ of ", "{\n    long result = 1;\n    long base = 2;\n    while (true) {\n   \
    \     long mask = (base << 1) ^ base;\n        if (n & mask) result ^= base;\n\
    \        base <<= 1;\n        n >>= 1;\n    }\n    if (p == 1)\n        return\
    \ result;\n    else \n        return result ^ modp(n >> 1, p);\n}\n\"\"\")\n \
    \       self.write_func_comment(\"\"\"\nReturns modular multiplicative inverse:\
    \ x^(-n) mod p.\n    \n    >>> modinv(16L, 5L) # 16^-5 mod 5\n    2L\n    >>>\
    \ modinv(2L, 5L) # 2^-5 mod 5\n    1L\n    >>> modinv(5L, 2L) # 5^-2 mod 2\n \
    \   3L\n    >>> modinv(5L, 11L) # 5^-11 mod 11\n    2L\n    \nThe inverse of a\
    \ prime modulo p is also the multiplicative inverse of p modulo p.\n    \n   \
    \ >>> modinv(4L, 5L)\n    1L\n    >>> modinv(4L, 2L)\n    3L\n    \nThe inverse\
    \ of 0 is 1, and of 1 is 1.\n    \n    >>> modinv(0L, 3L)\n    1L\n    >>> modinv(1L,\
    \ 3L)\n    1L\n    \nThe inverse of -1 is 0.\n    \n    >>> modinv(-1, 3L)\n \
    \   0L\n    \n\"\"\");", "{\n\tint i; \n\tlong res = 1L;\n\tfor (i=0; i<n; i++)\
    \ res *= p;\n\tres %= p;\n\tif (res == p) res ^= p; // don't change sign\n\treturn\
    \ res;\n}", "{\n\tlong t = n >> 52;\n\tn = (n - t*p) >> 52;\n\tn = (t + n*p +\
    \ p) % (p - 1);\n\treturn n;\n}\n/*\nReturn a random number between min (inclusive)\
    \ and max (inclusive).\n    Max is exclusive (so f(min) is different from f(max))\n\
    \    \n    >>> random(0)\n    0\n    >>> random(10)\n    9\n    >>> random(-10,\
    \ 5)\n    -5\n    \n*/\nlong random(long min, long max)\n{\n\treturn min + (long)drand48()\
    \ * (max - min);\n}\n/*\nReturn a random number between min (inclusive) and max\
    \ (inclusive).\n    Max is inclusive (so f(min) == f(max))\n    \n    >>> randomint()\n\
    \    0\n    >>> randomint(10)\n    9\n    >>> randomint(-10, 5)\n    -5\n    \n\
    */\nlong randomint(long min, long max)\n{\n\treturn random(min, max) + 1;\n}\n\
    /*\nReturn a random element of arr (which must be a vector of length n)\n    \n\
    \    >>> randomvec(\"\")\n    Traceback (most recent call last):\n        ...\n\
    \    IndexError: string index out of range\n    \n    >>> randomvec([1, 2, 3,\
    \ 4])\n    3\n    \n*/\nobject randomvec(string arr)\n{\n\tint n = arr.length;\n\
    \tint k = random(0, n);\n\treturn arr[k];\n}\n/*\nReturn a random element of arr\
    \ (which must be a vector of length n)\n    \n    >>> randomveclist([10, 11, 12,\
    \ 13])\n    13\n    \n*/", "{\n\tlong d;\n\t\n\td = p - n;\n\tif (d > 0)\n\t{\n\
    \t\tif (n < 0)\n\t\t\td = -d;\n\t\tn = n * 2;\n\t\twhile (d % 2 != 0)\n\t\t\t\
    d = d / 2;\n\t\tn = n - 1;\n\t}\n\telse\n\t{\n\t\tn = n * 2;\n\t\twhile (d % 2\
    \ != 0)\n\t\t\td = d / 2;\n\t\tn = n + 1;\n\t}\n\treturn n;\n}\n\t", "{\n    long\
    \ q = n / p;\n    return q*q % p;\n}\n/* \n* Return r**n (mod p), for integers\
    \ n, p > 0.\n* \n* For integers n, p > 0, r**n % p == r**n\n*/\nlong powr(long\
    \ r, long n, long p) \n{\n    return powrr_impl(r, n, p, r);\n}\n/*\nReturn r**n\
    \ (mod p), for integers n, p > 0, r <= MAX_R\n*/\nlong powr_impl(long r, long\
    \ n, long p, long MAX_R) {\n    int exponent;\n    if (n >= MAX_R) {\n       \
    \ exponent = n;\n    }\n    else {\n        exponent = modp(MAX_R - n, p);\n \
    \   }\n    return r * r * (exponent - p) % p;\n}\n/* Return 2**n (mod p), for\
    \ integers n, p > 0\n    \nFor integers n, p > 0, 2**n <= p\n*/\nlong pow2(long\
    \ n, long p) {\n    return pow2_impl(n, p, n);\n}\n/*\nReturn 2**n (mod p), for\
    \ integers n, p > 0, r <= MAX_R\n*/\nlong pow2_impl(long n, long p, long MAX_R)\
    \ {\n    long maxexp;\n    long r;\n    if (n >= MAX_R) {\n        maxexp = MAX_R-1;\n\
    \    }\n    else {\n        maxexp = modp(MAX_R-n, p);\n    }\n    r = powr_impl(2,\
    \ n, p, maxexp);\n    return r % p;\n}\n/*\nReturn n! (mod p). \n    \nFor integers\
    \ n, p > 0\n*/\nlong factorial(long n, long p) {\n    long p = p;\n    long r\
    \ = 1;\n    while (n > p) {\n        r = r * n % p;\n        n = n / p;\n    }\n\
    \    return r;\n}\n/*\nReturn n! (mod p). \n    \nFor integers n, p > 0\n*/\n\
    long factorial_impl(long n, long p) {\n    long maxexp;\n    long r;\n    if (n\
    \ >= p) {\n        maxexp = p - 1;\n    }\n    else {\n        maxexp = modp(n\
    \ - p, p);\n    }\n    r = factorial_impl(n, maxexp);\n    return r % p;\n}\n\
    /* Return sqrt(n)\n   \nFor integers n >= 0\n*/\nlong sqrt(long n) {\n    long\
    \ p = n;\n    long r = 1;\n    long m;\n    long t;\n    long sqexp;\n    while\
    \ (p > 0) {\n        m = p%10;", "{\n    if (n < 0) return 0L;\n    long res =\
    \ 1L;\n    while ((n % p) == 0)\n    {\n        res = (res*2L) % p;\n        n\
    \ = n/p;\n    }\n    return res;\n}", "{\n    // TODO: improve performance\n \
    \   long result = n & -p;\n    if (result != 0)\n        return result + p;\n\
    \    \n    return result + p;\n}", "{\n\tif (n == 0L)\n\t{\n\t\treturn 0L;\n\t\
    }", "{\n\tlong x, t;\n\t\n\tx = n & p;\n\tt = n >> 32;\n\tif (x == 0)\n\t{\n\t\
    \treturn 1L;\n\t}\n\treturn std.math.pow(x * x, 32L) % (p % x) + t;\n}", "{\n\
    \    long res = 1L;\n    while (n > 0) {\n        if (n & 1L) {\n            res\
    \ = (res * p) % p;\n        }\n        n >>= 1;\n        p = (p * p) % p;\n  \
    \  }\n    return res;\n}\n#endif\n/* \n * Reverse a vector.\n * For each element\
    \ in the vector v[i], v[i] is swapped with v[(i + n) % v.len()]\n * \n * Returns\
    \ 0 if the input vector was null, or -1 if the input vector was too short\n *\
    \ \n * Complexity: O(v.len())\n */", "{\n\tlong q;\n\t\n\tif(p == 0)\n\t\treturn\
    \ 0;\n\tif(p == 1)\n\t\treturn n;\n\tif(p < 0)\n\t{\n\t\tif(n < 0)\n\t\t{\n\t\t\
    \tif(p == -1)\n\t\t\t\treturn n;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t\telse\n\
    \t\t{\n\t\t\tif(p == 0)\n\t\t\t\treturn n;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t\
    }\n\t}\n\tif(n == 0)\n\t\treturn 0;\n\tif(n == 1)\n\t\treturn p;\n\t\n\tq = n;\n\
    \tp = p - 1;\n\t\n\twhile(p > 0)\n\t{\n\t\tq = q * p;\n\t\tp = p - 1;\n\t}\n\t\
    \n\tif(p == 1)\n\t\treturn q;\n\telse\n\t\treturn n - q;\n}", "{\n\tlong q, r;\n\
    \tif(n == 0) \n\t{\n\t\treturn 0;\n\t}\n\tif(n == 1)\n\t{\n\t\treturn p;\n\t}\n\
    \tq = n / p;\n\tr = n % p;\n\tif(p % 2 == 1) \n\t{\n\t\tq = -q;\n\t}\n\treturn\
    \ p * q + r;\n}", "{\n    return divrem(n, p) >> 1;\n}\n\"\"\")", "{\n    long\
    \ r = n;\n    long t = r;\n    while (t > 0) {\n\tr = r * p % modp((n-1)/t, p);\n\
    \tt--;\n    }\n    return r;\n}\n/*\nReturn p * 2^n modulo p (be aware of numerics).\n\
    */\nlong mulp2p(long n, long p) \n{\n    long r = p;\n    long t = r;\n    while\
    \ (t > 0) {\n\tr = r * n % modp((n-1)/t, p);\n\tt--;\n    }\n    return r;\n}\n\
    /*\nReturn p * 2^(n-1) modulo p (be aware of numerics).\n*/\nlong mulp2p1(long\
    \ n, long p) \n{\n    long r = p;\n    long t = r;\n    while (t > 0) {\n\tr =\
    \ r * n % modp((n-1)/t, p);\n\tt--;\n    }\n    return r;\n}", "{\n    if (p ==\
    \ 0) return 0L;\n    return std.math.remainder(n, p);\n}\n/*\nReturn 2^n modulo\
    \ p (be aware of numerics).\n    >>> modp(3L, 3L)\n    8L\n    >>> modp(1101L,\
    \ 1101L)\n    1L\n    >>> modp(0L, 1101L)\n    1L\n    >>> modp(3L, 5L)\n    2L\n\
    \    >>> modp(100L, 100L)\n    0L\n    \n*/", "{\n\tlong q;\n\t\n\tif (p == 0)\
    \ return 0;\n\tq = n % p;\n\treturn p + q;\n}", "{\n  return n%(p - 1);\n}", "{\n\
    \    return __gcd(n, p);\n}\n/*\nReturn a new list containing every element that\
    \ is >= to l, and every element that is <= to l.\n    >>> rangei([0, 2], 3)\n\
    \    [(0, 1), (0, 2), (1, 2)]\n    \n*/\nList<T> rangei(List<T> l, T to) \n{\n\
    \    List<T> r = new List<T>(l.size());\n    r.add(l.head);\n    T current = l.head;\n\
    \    while (current != to)\n    {\n        T next = current;\n        current\
    \ = current.next;\n        r.add(next);\n    }\n    return r;\n}\n/*\nReturn a\
    \ new list containing every element that is >= to l, and every element that is\
    \ <= to l.\n    >>> rangeu([0, 2], 3)\n    [(0, 1), (1, 2), (0, 2)]\n    \n*/\n\
    List<T> rangeu(List<T> l, T to) \n{\n    List<T> r = new List<T>(l.size());\n\
    \    T current = l.head;\n    while (current != to)\n    {\n        T next = current;\n\
    \        current = current.next;\n        r.add(next);\n    }\n    return r;\n\
    }\n/*\nReturn a new list containing every element that is >= to l, and every element\
    \ that is <= to l.\n    >>> ranges([0, 2], 3)\n    [(0, 1), (0, 2), (2, 3)]\n\
    \    \n*/\nList<T> ranges(List<T> l, T to) \n{\n    List<T> r = new List<T>(l.size());\n\
    \    r.add(l.head);\n    T current = l.head;\n    while (current != to)\n    {\n\
    \        T next = current;\n        current = current.next;\n        r.add(next);\n\
    \    }\n    return r;\n}\n/*\nReturn a new list containing every element that\
    \ is >= to l, and every element that is <= to l.\n    >>> rangep([0, 2], 3)\n\
    \    [(0, 1), (0, 2), (1, 3)]\n    \n*/\nList<T> rangep(List<T> l, T to) \n{\n\
    \    List<T> r = new List<T>(l.size());\n    r.add(l.head);\n    T current = l.head;\n\
    \    while (current != to)\n    {\n        T next = current;\n        current\
    \ = current.next;\n        r.add(next);\n    }\n    return r;\n}\n/*\nReturn a\
    \ new list containing every element that is >= to l, and every element that is\
    \ <= to l.\n    >>> ranged([0, 2], 3)\n    [(0, 1), (1, 2), (2, 3)]\n    \n*/\n\
    List<T> ranged(List<T> l, T to) \n{\n    List<T> r = new List<T>(l.size());\n\
    \    r.add(l.head);\n    T current = l.head;\n", "{\n    \n    if (n <= 0 || p\
    \ <= 0) {\n        throw new IllegalArgumentException(\"modulus must be positive\"\
    );\n    }\n    \n    return ((long)n & (-p)) + (long)((long)n * (long)p >> 32);\n\
    }\n\"\"\"", "{\n    long res = 1;\n    while (n >= p) {\n        res *= p;\n \
    \       n -= p;\n    }\n    return ((n - p) % p) + p;\n}", "{\n    return modp(new\
    \ long[n], p).n[0];\n}\npublic struct __modp {\n    public long[] n;\n    public\
    \ __modp(long _n, long _p) \n    {\n        n = new long[_n / _p + 1];\n     \
    \   long a = _n % _p;\n        n[_n / _p] = 0;\n        if (a == 0) \n       \
    \ {\n            long b = 1;\n            int k = 0;\n            while (a !=\
    \ 0) {\n                n[k++] = a % _p;\n                a = (a / _p) * b;\n\
    \                b *= _p;\n            }\n        }\n        else {\n        \
    \    long a = 1;\n            int k = 0;\n            while (a != 0) {\n     \
    \           n[k++] = a % _p;\n                a = (a / _p) * a;\n            \
    \    a *= _p;\n            }\n        }\n    }\n}\nstatic final __modp modp =\
    \ new __modp(1L, 101L);\n// end", "{\n\tlong ret = 1;\n\twhile(n) {\n\t\tret =\
    \ p * ret;\n\t\tn &= n - 1;\n\t}\n\treturn ret;\n}\n/*\n    Return sum of two\
    \ longs modulo p. Beware of overflow.\n    >>> sum3mod(100L, 101L)\n    1L\n*/\n\
    long sum3mod(long x, long y) \n{\n\tlong sum;\n\tsum = x+y;\n\treturn sum % modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum, modp(sum,\
    \ modp(sum, modp(", "{\n    long rem, t;\n    /* Find modulus */\n    t = n*p;\n\
    \    rem = ((t+1)&(t-1));\n    if (rem == 0) {\n        return 1;\n    } else\
    \ {\n        return (rem-1L) / p;\n    }\n}\n/*\nReturn 2^n modulo p (be aware\
    \ of numerics).\n    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n   \
    \ 2L\n    >>> modp(0L, 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L,\
    \ 101L)\n    1L\n    \n*/", "{\n\tlong res = 1;\n\tlong mask = 1;\n\tlong tmp\
    \ = n - p;\n\twhile(mask > 0) {\n\t\tres = (res * tmp) % p;\n\t\tmask = (mask\
    \ * 10L) % p;\n\t}\n\treturn res;\n}", "{\n  long d = n - p;\n  if(d < 0) return\
    \ p - modp(d, p);\n  if(d >= p) return n;\n  \n  long r = 1;\n  while(d != 0)\
    \ {\n    d = d / 2;\n    r = r * 2;\n  }\n  \n  return r;\n}", "{\n\tlong r;\n\
    \tn = long(n);\n\tp = long(p);\n\tr = (n&(1L<<p)) - 1;\n\treturn r;\n}", "{\n\
    \  long r = n;\n  long m = 0;\n  while(m < (long)(p - 1)) {\n    r <<= 1;\n  \
    \  m ++;\n  }\n  m %= p;\n  while(m > 0) {\n    r <<= 1;\n    m --;\n  }\n  return\
    \ r;\n}\n</code>\n<|/ a tags=math,modular-arithmetic,bit-manipulation,java,c++\
    \ |>\n<| c |>\nYour implementation is buggy, it fails for mod 2 with your example,\
    \ it returns 1 for 2L.\n<|/ c |>\n<| c |>\nThe OP was only looking for the modulo\
    \ operation. Anything else would probably be an overkill and in any case this\
    \ kind of answer is frowned upon.\n<|/ c |>\n<| a |>\nThe question was originally\
    \ tagged C and C++.\nIn the C language:\n<code>", "{\n\treturn 1L & ((long)n)\
    \ % ((long)p) ;\n}", "{\n    long ret = n;\n    while(ret && ret % p) \n     \
    \   ret /= p;\n    return ret;\n}", "{\n\tlong d = n % p;\n\tn /= p;\n\tif (d\
    \ > 0)\n\t\tn++;\n\treturn n;\n}\n/*\nReturn 2^n modulo p (be aware of numerics).\n\
    \    >>> modp(3L, 5L)\n    3L\n    >>> modp(1101L, 101L)\n    2L\n    >>> modp(0L,\
    \ 101L)\n    1L\n    >>> modp(3L, 11L)\n    8L\n    >>> modp(100L, 101L)\n   \
    \ 1L\n    \n*/", "{\n    int k = (int)n;\n    long r, r2;\n    \n    if (k < 0)\
    \ \n    {\n        PyErr_SetString(PyExc_ValueError, \"modp() arg 1 must be >=\
    \ 0\");\n        return 1;\n    }\n    \n    if (k >= p)\n    {\n        return\
    \ 0;\n    }\n    \n    r = 1;\n    r2 = p;\n    while (k > 0) \n    {\n      \
    \  r <<= 1;\n        r += (r2 & 1);\n        r2 >>= 1;\n        k >>= 1;\n   \
    \ }\n    return r;\n}", "{\n    long m = 2;\n    while(p % m == 0)\n        m\
    \ = m*2;\n    return ((n%m) + m - 1L) % m;\n}", "{\n\tif(n == 0) return 0;\n\t\
    if(n == 1) return p;\n\tlong q, r;\n\tif(p == 1) return 1;\n\tif(p == 0) return\
    \ 0;\n\tq = modp(n >> 1, p); \n\tr = n % p; \n\treturn ((n ^ q) * p + r) % p;\
    \ \n}", "{\n    return ((long) n) % (long) p;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    Your modp function works fine for positive numbers, where as Python uses modular\
    \ inverse for negative numbers.\n<|/ c |>\n<| c |>\nThis works fine for positive\
    \ numbers, but not for negative numbers. Just use Math.abs(): https://pastebin.com/ZgZ4uFXA\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>\ndef modular_inverse(a, p):\n    \"\"\" Return\
    \ modular inverse of 'a' in base 'p'.\n    >>> modular_inverse(2, 3)\n    1\n\
    \    \"\"\"\n    q, r = divmod(a, p)\n    if r == 0: return q\n    inverse = pow(p,\
    \ q-1, p)\n    if a == inverse:\n        # Extremely rare case, but we'll take\
    \ a guess for it.\n        return modular_inverse(a, q)\n    return inverse\n\
    </code>\n<|/ a tags=algorithm,python,modular |>\n<| a |>\nHere's a working Python\
    \ version which doesn't use any external libraries:\n<code>\ndef modinv(a, m):\n\
    \    m, n = divmod(a, m)\n    if m == 0:\n        return a\n    elif n == 0:\n\
    \        return modinv(a, m)\n    else:\n        return modinv(a, (m*m)%m)\n</code>\n\
    For positive integers, the above will work just fine. If m is a negative number,\
    \ it will fail. \n<code>\n>>> modinv(7, 12)\n17\n>>> modinv(7, -7)\n-7\n</code>\n\
    <|/ a tags=algorithm,python,modular dscore=4 |>\n<| c |>\nGreat! I love Python.\n\
    <|/ c |>\n<| c |>\n`modinv()` doesn't work for negative integers though\n<|/ c\
    \ |>\n<| a tags=algorithm,python,modular |>\n<code>\ndef modinv(x, m):\n    x,\
    \ m = abs(x), abs(m)\n    if m == 2:\n        if x == 1: return x\n        if\
    \ x%2 == 0: return 1\n        if x%2 == 1: return x\n    m, n = divmod(x, m)\n\
    \    if m == 0: return m\n    if n == 0:\n        return modinv(x, m)\n    return\
    \ modinv(x*x, m%m)", "{\n    long rem;\n    \n    rem = n % p;\n    if (rem ==\
    \ 0) {\n        if (n >= p)\n            return n;\n    }\n    if (rem == p) {\n\
    \        n /= p;\n        n--;\n        if (n < 0) {\n            n = p + n;\n\
    \        }\n    }\n    return n * p;\n}", "{\n    long r;\n    bool s = n % p;\n\
    \    if (s == 0) return n;\n    if (s == 1) return n - p;\n    if (p % 2 == 0)\
    \ {\n        r = modp(n/2, p);\n        return r*r + n;\n    } else {\n      \
    \  r = modp((n - 1)/2, p);\n        return r*r + n + 1L;\n    }\n}", "{\n  return\
    \ std.int.__pow__(std.int.__pow__(2, n), p);\n}", "{\n\tlong r = 1L;\n\twhile\
    \ (n > 0L) {\n\t\tif (n & 1L) \n\t\t\tr = (r * p) % p;\n\t\tn = n >> 1;\n\t\t\
    p = (p * p) % p;\n\t}\n\treturn r;\n}", "{\n\t/*\n\tmodpow:\n\thttp://en.wikipedia.org/wiki/Modulo_operation\n\
    \thttp://www.delorie.com/gnu/docs/gcc-4.6/lib/gcc/test/IntlTests/intltest-long-modpow.html\n\
    \t*/\n\tif(p == 1)\n\t\treturn n;\n\tif(p == 0)\n\t\treturn 0;\n\tif(p < 0)\n\t\
    \tp = -p;\n\tif(n == 0)\n\t\treturn 0;\n\tif(n < 0)\n\t\treturn modpow(-n, p);\n\
    \tlong ret = 0;\n\tlong a = n;\n\tlong b = p;\n\twhile(a != 0) {\n\t\tlong t =\
    \ b%a;\n\t\tret += t;\n\t\tb /= a;\n\t}\n\treturn p*ret + n;\n}", "{\n\tlong q;\n\
    \tn = n % p;\n\tif(n == 0) \n\t\treturn n;\n\t\n\tif(p == 1) \n\t\treturn n;\n\
    \t\n\tif(p == 2) \n\t\treturn 2L;\n\t\n\tif(p == q) \n\t\treturn n;\n\t\n\tif(p\
    \ == q + 1) \n\t\treturn n - ((n - q) % p);\n\t\n\tif(p == q + 2) \n\t\treturn\
    \ n - 1;\n\t\n\tq = p / 2;\n\treturn modp(n, q) + modp((n - p * q) % p, q);\n\
    }\n/* \n    Find the least common multiple of n and p.\n    >>> lcm(5L, 10L)\n\
    \    10L\n    >>> lcm(101L, 10L)\n    10L\n    >>> lcm(0L, 10L)\n    0L\n    >>>\
    \ lcm(100L, 101L)\n    100L\n    \n*/\nlong lcm(long n, long p) \n{\n\treturn\
    \ n * p / modp(n, p);\n}\n/* \n    Find the least common multiple of n and p.\n\
    \    >>> lcm(5L, 10L)\n    10L\n    >>> lcm(101L, 10L)\n    10L\n    >>> lcm(0L,\
    \ 10L)\n    0L\n    >>> lcm(100L, 101L)\n    100L\n    \n*/\nlong lcm(long n,\
    \ long p, long q) \n{\n\treturn n * p / modp(n, p) * q / modp(q, p);\n}\n/* \n\
    \    Find the least common multiple of n and p.\n    >>> lcm(5L, 10L)\n    10L\n\
    \    >>> lcm(101L, 10L)\n    10L\n    >>> lcm(0L, 10L)\n    0L\n    >>> lcm(100L,\
    \ 101L)\n    100L\n    \n*/\nlong lcm(long n, long p, long q, long r) \n{\n\t\
    return n * p / modp(n, p) * q / modp(q, p) * r / modp(r, q);\n}\n/* \n    Find\
    \ the least common multiple of n and p.\n    >>> lcm(5L, 10L)\n    10L\n    >>>\
    \ lcm(101L, 10L)\n    10L\n    >>> lcm(0L, 10L)\n    0L\n    >>> lcm(100L, 101L)\n\
    \    100L\n    \n*/\nlong lcm(long n, long p, long q, long r, long s) \n{\n\t\
    return n * p / modp(n, p) * q / modp(q, p) * r / modp", "{\n\tlong res;\n\tlong\
    \ mask = ~((long) p);\n\tn &= mask;\n\t\n\tif (n & 1) {\n\t\tn = (n - 1) ^ mask;\n\
    \t} else {\n\t\tn = (n - 1);\n\t}\n\t\n\tres = (n << 31) | (n >> 31);\n\treturn\
    \ res;\n}\n/*\nReturn the floor of n modulo p.\n    >>> floorp(3L, 5L)\n    3L\n\
    \    >>> floorp(1101L, 101L)\n    1L\n    >>> floorp(0L, 101L)\n    0L\n    >>>\
    \ floorp(3L, 11L)\n    3L\n    >>> floorp(100L, 101L)\n    0L\n    \n*/\nlong\
    \ floorp(long n, long p)\n{\n\tlong mask = (~((long) p));\n\tn &= mask;\n\t\n\t\
    if (n & 1) {\n\t\tn = (n - 1) ^ mask;\n\t} else {\n\t\tn = (n - 1);\n\t}\n\t\n\
    \treturn n;\n}\n/*\nReturn the ceiling of n modulo p.\n    >>> ceilingp(3L, 5L)\n\
    \    5L\n    >>> ceilingp(1101L, 101L)\n    1L\n    >>> ceilingp(0L, 101L)\n \
    \   1L\n    >>> ceilingp(3L, 11L)\n    3L\n    >>> ceilingp(100L, 101L)\n    1L\n\
    \    \n*/\nlong ceilingp(long n, long p)\n{\n\tlong mask = (~((long) p));\n\t\
    n &= mask;\n\t\n\tif (!(n & 1)) {\n\t\tn = (n - 1) ^ mask;\n\t} else {\n\t\tn\
    \ = (n - 1);\n\t}\n\t\n\treturn n;\n}", "{\n    int res = 1L;\n    while (n--\
    \ != 0) {\n        res = (2*res) % p;\n    }\n    return res;\n}", "{\n\tif(n\
    \ == 0) return 0;\n\tif(n == 1) return 1;\n\tif(p == 0) return n;\n\treturn p%n+modp(n-1,\
    \ p);\n}\n/*\n>>> mod(1L, 5L)\n5L\n>>> mod(1101L, 101L)\n1L\n>>> mod(0L, 101L)\n\
    0L\n>>> mod(3L, 11L)\n3L\n>>> mod(100L, 101L)\n0L\n>>> mod(1L, 5L)\n5L\n*/\nlong\
    \ mod(long n, long p) \n{\n\tif(n == 0) return 0;\n\tif(n == 1) return n;\n\t\
    if(p == 0) return n;\n\tif(p == 1) return 1;\n\tif(p == 2) return n-1;\n\treturn\
    \ p%n+mod(n-1, p);\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
