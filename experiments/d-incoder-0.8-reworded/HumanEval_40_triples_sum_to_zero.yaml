name: HumanEval_40_triples_sum_to_zero
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    triples_sum_to_zero takes\
  \ an array of integers as an input.\n    it returns true if there are three distinct\
  \ elements in the array that\n    sum to zero, and false otherwise.\n\n    >>> triples_sum_to_zero([1L,\
  \ 3L, 5L, 0L])\n    false\n    >>> triples_sum_to_zero([1L, 3L, -2L, 1L])\n    true\n\
  \    >>> triples_sum_to_zero([1L, 2L, 3L, 7L])\n    false\n    >>> triples_sum_to_zero([2L,\
  \ 4L, -5L, 3L, 9L, 7L])\n    true\n    >>> triples_sum_to_zero([1L])\n    false\n\
  \    \n*/\nbool triples_sum_to_zero(long[] l) \n"
tests: "unittest\n{\n    alias candidate = triples_sum_to_zero;\n\n    assert(candidate([1L,\
  \ 3L, 5L, 0L]) == false);\n    assert(candidate([1L, 3L, 5L, -1L]) == false);\n\
  \    assert(candidate([1L, 3L, -2L, 1L]) == true);\n    assert(candidate([1L, 2L,\
  \ 3L, 7L]) == false);\n    assert(candidate([1L, 2L, 5L, 7L]) == false);\n    assert(candidate([2L,\
  \ 4L, -5L, 3L, 9L, 7L]) == true);\n    assert(candidate([1L]) == false);\n    assert(candidate([1L,\
  \ 3L, 5L, -100L]) == false);\n    assert(candidate([100L, 3L, 5L, -100L]) == false);\n\
  }\nvoid main(){}"
completions: ["{\n    if (l[0] != 0L) return false;\n    \n    for(int i = 1; i <\
    \ l.length; i++) \n    {\n        if (l[i] != 0L) \n        {\n            int\
    \ sum = 0;\n            for(int j = 0; j < i; j++) \n            {\n         \
    \       sum += l[j];\n            }\n            if (sum != 0L) \n           \
    \ {\n                return false;\n            }\n        }\n    }\n    return\
    \ true;\n}", "{\n    long sum = 0;\n    long count = 0;\n    for (int i = 0; i\
    \ < l.length; ++i) \n    {\n        sum += l[i];\n        count += 1;\n      \
    \  if (sum == 0) \n        {\n            return count >= 3;\n        }\n    }\n\
    \    return false;\n}\n</code>\n<|/ a dscore=4 tags=algorithm,arrays,language-agnostic,python\
    \ |>\n<| c |>\nThis code returns true for an empty list. I.e. it returns true\
    \ if there is 3 or more distinct elements in the list, and false if not.\n<|/\
    \ c |>\n<| a tags=algorithm,arrays,language-agnostic,python |>\n<code>\ndef triples_sum_to_zero(arr):\n\
    \  n = len(arr)\n  return n * (n-1) / 2\n</code>\n<|/ a dscore=3 |>\n<| c |>\n\
    It's a good idea. Unfortunately it takes longer to execute.\n<|/ c |>\n<| c |>\n\
    It would seem that this is O(n^2)\n<|/ c |>\n<| c |>\n, yes, I believe that `O(n^2)`\
    \ solution is also the most efficient one. But it's O(1), and thus faster than\
    \ any O(n^2) algorithm, so I would prefer that one over other (even if this one\
    \ looks cleaner). Also, it's less code.\n<|/ c |>\n<| c |>\nIt might be faster\
    \ to calculate `n * (n-1) / 2` in steps, but I'm pretty sure that it's also O(n).\
    \ If anyone knows how to do it in better time complexity, please post it here!\n\
    <|/ c |>\n<| a |>\nThe other answers given so far don't seem to include a straightforward\
    \ solution to the question: \"How many distinct integers exist in the array such\
    \ that their sum is 0?\" Here's my solution, using O(n) space and O(1) time:\n\
    <code>\ndef num_distinct( n ):\n    result = 0\n    sum = 0\n    for i in range(\
    \ 0, n ):\n        sum += i\n        if sum == 0:\n            result += 1\n \
    \       sum = 0\n    return result\n</code>\n<|/ a dscore=3 tags=algorithm,arrays,language-agnostic,python\
    \ |>\n<| a tags=algorithm,arrays,language-agnostic,python |>\nHere's a solution\
    \ in O(n) time and O(1) space.\n<code>\ndef triangle_sum_to_zero(array):\n   \
    \ triangle_sum = 0\n    for i in range(len(array) - 1):\n        for j in range(i\
    \ + 1, len(array)):\n            triangle_sum += array[i] + array[j]\n       \
    \     if triangle_sum == 0: return True\n    return False\n</code>\n<|/ a dscore=3\
    \ |>", "{\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long sum = 0;\n\
    \    bool flag = false;", "{\n\tint sum = 0;\n\tint count = 0;\n\tfor (int i =\
    \ 0; i < l.length; i++) \n\t{\n\t\tint x = l[i];\n\t\tif (x != 0) \n\t\t{\n\t\t\
    \tcount++;\n\t\t\tsum += x;\n\t\t}\n\t}\n\tif (count == 3) \n\t{\n\t\treturn true;\n\
    \t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}", "{\n    return triples_sum_to_zero_rec(l,\
    \ 0, l[0]);\n}", "{\n    auto t0 = l[0];\n    auto t1 = l[1];\n    auto t2 = l[2];\n\
    \    return t0 == t1 + t2 && t0 + t1 + t2 == 0;\n}", "{\n  long a1=l[0];\n  long\
    \ a2=l[1];\n  long a3=l[2];\n  bool answer=false;\n  if (a1!=a2 && a1!=a3)\n \
    \ {\n    if (a1<0)\n    {\n      a1=std.min(a1,a2);\n      a2=std.min(a1,a3);\n\
    \    }\n    else a1=std.max(a1,a2);\n    else a2=std.max(a1,a3);\n    long sum=a1+a2+a3;\n\
    \    answer = (sum==0);\n  }\n  return answer;\n}", "{\n    /*\n        Algorithm\
    \ for finding if there are three distinct integers\n        in the array that\
    \ sum to zero. \n        \n        l: array of integers\n        \n        returns:\
    \ true if three distinct integers in the array sum to\n                 zero,\
    \ false otherwise\n    */\n    \n    bool isTriple = false;\n    \n    int sum\
    \ = 0;\n    int i = 1;\n    int j = 1;\n    int k = 1;\n    \n    while (i <=\
    \ l.length) \n    {\n        sum += l[i];\n        if (sum == 0) \n        {\n\
    \            isTriple = true;\n            \n            while (j <= l.length\
    \ && l[j] == 0) j++;\n            \n            while (k <= l.length && l[k] ==\
    \ 0) k++;\n        }\n        else if (sum < 0) \n        {\n            i++;\n\
    \            \n            while (j <= l.length && l[j] == 0) j++;\n         \
    \   \n            while (k <= l.length && l[k] == 0) k++;\n        }\n       \
    \ else \n        {\n            j++;\n            \n            while (k <= l.length\
    \ && l[k] == 0) k++;\n        }\n    }\n    \n    return isTriple;\n}", "{\n \
    \   // O(n^2) \n    int i, j, k;\n    long sum = 0;\n    \n    for(i=0; i < l.length;\
    \ i++) \n    {\n        for(j=i+1; j < l.length; j++) \n        {\n          \
    \  for(k=j+1; k < l.length; k++) \n            {\n                sum += l[i];\n\
    \                sum += l[j];\n                sum += l[k];\n                \n\
    \                if((l[i] + l[j] + l[k]) == 0) \n                {\n         \
    \           return true;\n                }\n            }\n        }\n    }\n\
    \    \n    return false;\n}\n</cell>\n<cell>\n%%python\nimport stdio\nimport sys\n\
    import std.io\nimport std.file;\nimport std.algorithm; \nimport std.num;\nimport\
    \ std.stdio;\nimport std.string; \nimport std.conv;\nimport std.random;\nimport\
    \ std.string;\nimport std.algorithm;\nimport std.math;\nimport std.typecons;\n\
    import std.math;", "{\n    // TODO: implement me", "{\n    long long sum = 0;\n\
    \    for (int i=0; i<l.length; i++) {\n        sum += l[i];\n        if (sum <\
    \ 0) {\n            sum = 0;\n        }\n    }\n    return (l.length>0 && sum\
    \ == 0);\n}", "{\n    int i, j, k, triple_sum;\n    triple_sum = 0;\n    for(i=j=k=0;\
    \ i< l.length; i++) \n    {\n        if (l[i] + l[j] + l[k] == 0) triple_sum++;\n\
    \        else if (l[i] > l[j] && l[j] > l[k]) triple_sum++;\n        else if (l[i]\
    \ > l[j] && l[j] < l[k]) triple_sum++;\n        else if (l[i] < l[j] && l[j] >\
    \ l[k]) triple_sum++;\n        else if (l[i] < l[j] && l[j] < l[k]) triple_sum++;\n\
    \        \n        if(triple_sum == 3 ) return false;\n        else if(triple_sum\
    \ == 2) j++;\n        else if(triple_sum == 1) i++;\n        else if(triple_sum\
    \ == 0) k++;\n    }\n    return true;\n}\n</code>\n<|/ a tags=c++,algorithm dscore=0\
    \ |>\n<| a tags=c++,algorithm |>\n<code>\n#include <bits/stdc++.h>\nusing namespace\
    \ std;", "{\n    int[] sum = {0,0,0};\n    bool allZero = true;\n    for(int i\
    \ = 0; i < l.length; i++) \n    {\n        sum[0] += l[i];\n        sum[1] +=\
    \ l[i];\n        sum[2] += l[i];\n        if(sum[0]+sum[1]+sum[2] != 0)\n    \
    \    {\n            allZero = false;\n            return false;\n        }\n \
    \   }\n    return allZero;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis approach\
    \ is more elegant and works fine. But you should use long[] instead of int[].\n\
    <|/ c |>\n<| a dscore=2 |>\nSince this is a competitive programming question I\
    \ presume that the constraints on execution time and memory are acceptable. \n\
    If that's the case I would probably do something like this: ", "{\n    if( l.length\
    \ < 3) return false;\n    long sum = 0;\n    int count = 0;\n    for( int i =\
    \ 0; i < l.length - 1; ++i)\n    {\n        sum += l[i];\n        count ++;\n\
    \    }\n    if (sum > 0) return true;\n    for( int i = l.length - 2; i >= 0;\
    \ --i)\n    {\n        sum += l[i];\n        count ++;\n        if (sum < 0)\n\
    \        {\n            if (count == 3) \n                return true;\n     \
    \       sum = 0;\n            count = 0;\n        }\n    }\n    return false;\n\
    }\n</code>\n<|/ a dscore=1 tags=algorithm,c#,arrays |>\n<| c |>\nYou don't need\
    \ to use `foreach` for this task. Just two `for` loops will suffice.\n<|/ c |>\n\
    <| c |>\n, thanks for pointing it out, you're right, but it is much easier to\
    \ understand and read this way :)\n<|/ c |>\n<| a |>\nThis seems a little more\
    \ straightforward to me.  I didn't really understand the other answers, as I feel\
    \ like they should work as well.\n<code>\n    public static bool IsSumToZero(long[]\
    \ nums)\n    {\n        int sum = 0;\n        int count = 0;\n        foreach\
    \ (var num in nums)\n        {\n            sum += num;\n            count++;\n\
    \        }\n        return sum == 0;\n    }\n</code>\n<|/ a tags=algorithm,c#,arrays\
    \ dscore=1 |>\n<| c |>\nWhat about `nums.Length < 3`?\n<|/ c |>\n<| c |>\nGood\
    \ catch, fixed the code snippet.  Thanks for noticing!\n<|/ c |>\n<| a tags=algorithm,c#,arrays\
    \ |>\n<code>\npublic static bool IsSumToZero(long[] nums)\n{\n   var sum = nums.Sum();\n\
    \   return sum == 0;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work\
    \ for `{1,-2,3,-5}`, it returns false.\n<|/ c |>\n<| c |>\n, I've added a note\
    \ to my answer.\n<|/ c |>\n<| a tags=algorithm,c#,arrays dscore=1 |>\n<code>",
  "{\n    // write your solution here\n    long n = l.length();\n    bool is_triple\
    \ = false;\n    long a = l[0];\n    long b = l[1];\n    long c = l[2];\n    long\
    \ sum = 0;\n    for (int i = 0; i < 3; i++) {\n        sum += l[i];\n        if\
    \ (sum == 0 && i != 2) {\n            is_triple = true;\n            break;\n\
    \        }\n    }\n    return is_triple;\n}\n</code>\n<|/ a tags=c++,c++11 |>\n\
    <| c |>\nYou shouldn't compare floating point numbers for equality. http://stackoverflow.com/questions/17333/most-effective-way-for-float-and-double-comparison\n\
    <|/ c |>\n<| c |>\nI don't think the linked question is the same problem. The\
    \ OP is asking about how to detect if a number equals three elements in a list.\
    \ One could do that by finding the index of the first three elements that sum\
    \ to zero. This requires looking at every element in the list. Finding the first\
    \ three elements that sum to zero requires looking at at most three elements and\
    \ that takes O(n) time. Finding the index of the first three elements that sum\
    \ to zero requires looking at O(n) elements and that takes O(n) time. So, finding\
    \ the first three elements that sum to zero is O(n^2).\n<|/ c |>\n<| c |>\nIn\
    \ other words, you can do better than O(n^2) if you use some clever data structures\
    \ to find the index of the three elements that sum to zero. This requires looking\
    \ at more than three elements and that takes O(n) time. Finding the index of the\
    \ three elements that sum to zero is O(n).\n<|/ c |>\n<| c |>\n, thanks for your\
    \ comment. I've fixed the code.\n<|/ c |>\n<| a |>\n<code>\n#include <iostream>\n\
    #include <algorithm>\n#include <vector>", "{\n  long sum = 0;\n  long sum2 = 0;\
    \ \n  long sum3 = 0; \n  long i;", "{\n    bool isTriplet;\n    int sum = 0;\n\
    \    for(int i=0; i<l.length(); i++) {\n        sum += l[i];\n        if (sum\
    \ == 0)\n            isTriplet = true;\n        else if (sum > 0)\n          \
    \  sum -= l[i];\n        else\n            sum += l[i];\n    }\n    return isTriplet;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis solution doesn't work if the array contains\
    \ negative integers and is empty.\n<|/ c |>\n<| c |>\nOh, my bad. Fixed it. I\
    \ had been thinking of an array of strings and forgot to change that to long.\n\
    <|/ c |>\n<| c |>\nNo, it doesn't work anymore when the array contains negative\
    \ integers and is empty. Your code returns true when the array contains exactly\
    \ three zeros, which is wrong.\n<|/ c |>\n<| c |>\nIt works perfectly fine for\
    \ me. I tested it with my other answer as well as with my example array.\n<|/\
    \ c |>\n<| c |>\nIt doesn't work when array is empty: it returns true.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nI think this is what you're trying to do:\n<code>\npublic\
    \ static bool TripleSumZero(long[] l)\n{\n    var sum = 0;\n    foreach(var i\
    \ in l)\n    {\n        sum += i;\n        if (sum > 0)\n            return true;\n\
    \    }\n    return false;\n}\n</code>\n<|/ a tags=c#,.net,arrays |>\n<| a dscore=2\
    \ |>\nThis should do what you need:\n<code>", "{\n\tint count = 1;\n\tfor (int\
    \ i = 0; i < l.length; ++i)\n\t{\n\t\tcount += l[i];\n\t\tif (count == 0)\n\t\t\
    {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\"\"\"", "{\n    int n\
    \ = l.length;\n    long a1 = l[0];\n    long a2 = l[1];\n    long a3 = l[2];\n\
    \    long sum = a1 + a2 + a3;\n    if (sum == 0) {\n        return true;\n   \
    \ }\n    long sum2 = a1 + a3;\n    if (sum2 == 0) {\n        return true;\n  \
    \  }\n    long sum3 = a2 + a3;\n    if (sum3 == 0) {\n        return true;\n \
    \   }\n    long sum4 = a2;\n    if (sum4 == 0) {\n        return true;\n    }\n\
    \    long sum5 = a3;\n    if (sum5 == 0) {\n        return true;\n    }\n    return\
    \ false;\n}\n</code>\n<|/ a |>\n<| a tags=java |>\nThis was my solution to the\
    \ problem using recursion:\n<code>\npublic boolean tripleSum(int arr[]) {\n  \
    \  if(arr == null || arr.length < 3){\n        return false;\n    }\n    int sum\
    \ = arr[0] + arr[1] + arr[2];\n    return sum == 0;\n}", "{\n    long triple =\
    \ 0;\n    long sum = 0;\n    for(int i = 0; i<l.length; i++)\n    {\n        sum\
    \ = sum + l[i];\n        if(sum == 0)\n        {\n            triple++;\n    \
    \        sum++;\n        }\n        if(sum != 0)\n            return false;\n\
    \    }\n    if(triple == 3)\n        return true;\n    else \n        return false;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI think it's good to test the solutions\
    \ before posting.\n<|/ c |>\n<| a tags=algorithm,java,arrays |>\nThe best solution\
    \ I could come up with was using HashMap:\n<code>\npublic class TripleSumToZero\
    \ {", "{\n    long a, b, c, d, e; \n    bool f; \n    for (int i = 0; i < l.length;\
    \ i++)\n    {\n        a = l[i]; \n        b = 0; \n        c = 0; \n        d\
    \ = 0; \n        for (int j = i + 1; j < l.length; j++)\n        {\n         \
    \   e = l[j]; \n            if (Math.abs(a - e) < 10 && (Math.abs(b) + Math.abs(e)\
    \ + Math.abs(d)) < 10)\n            {\n                c = c * 10 + e; \n    \
    \            d = d * 10 + 0; \n            }\n            else\n            {\n\
    \                b = b * 10 + a; \n                d = d * 10 + e; \n        \
    \    }\n        } \n        if ((Math.abs(b) + Math.abs(c) + Math.abs(d)) < 10)\n\
    \        {\n            f = true; \n            break;\n        }\n    } \n  \
    \  return f;\n}", "{\n    long sum = 0;\n    long cur;\n    for(size_t i = 0;\
    \ i < l.length; i++){\n        sum += l[i];\n        if(sum < 0){\n          \
    \  return false;\n        }\n    }\n    return true;\n}\n</code>\n<|/ a dscore=0\
    \ tags=arrays,c++,algorithm,c |>\n<| c |>\nYour solution is wrong. Try with array\
    \ [10, 20, 10, 10, 10, 10, 10, 5] it returns true instead of false.\n<|/ c |>\n\
    <| a |>\n<code>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\
    using namespace std;", "{\n    long sum = 0;\n    for (long i = 0; i < l.Length;\
    \ i++)\n    {\n        sum += l[i];\n    }\n    if (sum > 0) return false;\n \
    \   for (long i = 1; i < l.Length; i++)\n    {\n        sum += l[i];\n       \
    \ if (sum != 0)\n            return false;\n    }\n    return true;\n}", "{\n\
    \    long s = sum(l);\n    return s == 0;\n}", "{\n    long long int sum = 0;\n\
    \    for(int i = 0; i < l.size(); i++) \n    {\n        sum += l[i];\n       \
    \ if(sum < 0) \n        {\n            sum = 0;\n        }\n    }\n    return\
    \ (l.size() > 3 && sum == 0);\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n\
    import java.util.*;\nclass TriplesSumToZero\n{\n    boolean isTriples(int[] arr,\
    \ int sum)\n    {\n        int count = 3;\n        for(int i = 1; i < arr.length;\
    \ i++)\n        {\n            if(arr[i] + arr[i - 1] != sum)\n            {\n\
    \                count--;\n                if(count == 0)\n                {\n\
    \                    return true;\n                }\n            }\n        }\n\
    \        return false;\n    }", "{\n    long long t = 0;\n    long long x = 0;\n\
    \    long long y = 0;\n    long long z = 0;\n    \n    for (int i = 0; i < l.length;\
    \ ++i)\n    {\n        x += (long long) l[i];\n        y += (long long) l[i -\
    \ 2];\n        z += (long long) l[i - 3];\n    }", "{\n    long sum = 0;\n   \
    \ for (int i = 0; i < l.length; i ++)\n        sum += l[i];\n    if (sum < 0)\n\
    \        return false;\n    if (sum == 0)\n        return true;\n    for (int\
    \ i = 0; i < l.length; i ++)\n    {\n        int next = l[i] + 1;\n        if\
    \ (next > sum)\n            return false;\n        sum = next;\n    }\n    return\
    \ true;\n}\n/*", "{\n    bool hasTriple = false;\n    long sum = 0;\n    int len\
    \ = l.length;\n    for(int i = 0; i < len; i = i + 2) {\n        sum += l[i];\n\
    \        if (sum > 0) {\n            hasTriple = true;\n            break;\n \
    \       }\n    }\n    return hasTriple;\n}\n/*", "{\n    bool result = true;\n\
    \    long sum = 0;\n    for (int i = 0; i < l.length; i++)\n    {\n        sum\
    \ += l[i];\n        if (!(sum))\n        {\n            result = false;\n    \
    \        break;\n        }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n\
    <| a dscore=0 tags=big-o,asymptotic-complexity,algorithm,time-complexity |>\n\
    <code>\npublic boolean isPalindrome(String str) {\n        // reverse the string\n\
    \        int len = str.length();\n        char c;\n        String reverse = new\
    \ StringBuilder(len).reverse().toString();\n        for (int i = 0; i < len; i++)\
    \ {\n            c = str.charAt(i);\n            if (!reverse.contains(String.valueOf(c)))\
    \ {\n                return false;\n            }\n        }\n        return true;\n\
    \    }\n</code>\n<|/ a |>\n<| c |>\nThe string reverse method requires time O(n)\
    \ which is greater for comparing 2 strings which is not the case here. It would\
    \ require O(n^2) time if the strings are of same length.\n<|/ c |>\n<| a tags=big-o,asymptotic-complexity,algorithm,time-complexity\
    \ |>\n<code>\npublic class Palindrome {", "{\n    return l != null && \n\tl.reduce((i1,\
    \ i2, i3) => i1 + i2 + i3 == 0) &&\n\tl.length == 3;\n}", "{\n    long sum = 0;\n\
    \    for (long i : l) {\n        sum += i;\n    }\n    long x = 0;\n    for (long\
    \ i : l) {\n        if (i >= 0) {\n            x += i;\n        }\n        else\
    \ {\n            x -= i;\n        }\n    }\n    if (x == sum) {\n        return\
    \ true;\n    }\n    return false;\n}", "{\n    long first = l[0];\n    long second\
    \ = l[1];\n    long third = l[2];\n    bool res = false;\n    \n    if (first\
    \ == 0 || second == 0 || third == 0) return true;\n    \n    if (first + second\
    \ == 0 && third + first == 0 && third + second == 0) {\n        res = true;\n\
    \    }\n    \n    return res;\n}", "{\n    int cnt = 0;\n    int s = -3;\n   \
    \ int e = 3;\n    while (cnt < l.length && e - s > 1) {\n        if (l[cnt] +\
    \ l[cnt+1] + l[cnt+2] == s)\n            return true;\n        else if (l[cnt]\
    \ + l[cnt+1] + l[cnt+2] == e)\n            cnt++;\n        else if (l[cnt] + l[cnt+1]\
    \ + l[cnt+2] < s)\n            s = l[cnt] + l[cnt+1] + l[cnt+2];\n        else\n\
    \            e = l[cnt] + l[cnt+1] + l[cnt+2];\n    }\n    return false;\n}\n\
    </code>\n<|/ a tags=c++,arrays |>\n<| c |>\nThanks for the solution, what is the\
    \ complexity of this solution? This seems more complex than my naive solution.\n\
    <|/ c |>\n<| c |>\nOh no, I didn't see your solution. Looks good! I'll give it\
    \ a try and compare my solution and yours.\n<|/ c |>\n<| c |>\nI really don't\
    \ know what complexity is, it is very likely that there is none. However, I compared\
    \ both solutions, and my solution seems to have worse complexity than yours. I\
    \ am still thinking if my solution is actually not that bad. Maybe there are more\
    \ simple solution which can be used?\n<|/ c |>\n<| a tags=c++,arrays |>\nHere\
    \ is another solution, using std::set and std::find_if to find the three non-negative\
    \ numbers whose sum is zero.\n<code>\n#include <iostream>\n#include <set>", "{\n\
    \    if(l == null)\n        return false;\n    long sum = 0;\n    for(int i=0;\
    \ i < l.length; i++) \n    {\n        if(i != 0)\n        {\n            if(l[i]\
    \ - l[i-1] != 0)\n            {\n                if(sum != 0)\n              \
    \      return false;\n                sum = l[i];\n            }\n        }\n\
    \        else\n        {\n            sum = l[i];\n        }\n    }\n    return\
    \ true;\n}\n</code>\n<|/ a tags=c#,algorithm,arrays |>\n<| c |>\nThis algorithm\
    \ can be improved by using a `HashSet` instead of a `List` of numbers, since it\
    \ only needs to compare each number once.\n<|/ c |>\n<| a |>\nI think you can\
    \ use this :\n<code>\npublic bool CheckTripleSumToZero(long[] array)\n{\n    var\
    \ dic = new Dictionary<long, long>();\n    for (int i = 0; i < array.Length; i++)\n\
    \    {\n        if (i == 0)\n        {\n            if (array[i] != 0)\n     \
    \       {\n                dic[array[i]] = array[i];\n            }\n        }\n\
    \        else if (i == 1)\n        {\n            if (array[i] != 0 && array[i]\
    \ - dic[array[i]] > 0)\n            {\n                return false;\n       \
    \     }\n        }\n        else if (i == 2)\n        {\n            if (array[i]\
    \ != 0 && array[i] - dic[array[i]] == 0)\n            {\n                return\
    \ false;\n            }\n        }\n    }\n    return true;\n}\n</code>\n<|/ a\
    \ tags=c#,algorithm,arrays dscore=2 |>\n<| c |>\nIf you use [HashSet](http://msdn.microsoft.com/en-us/library/bb359438(v=vs.110).aspx)\
    \ instead of Dictionary and use ContainsKey() instead of Contains(), the code\
    \ becomes even shorter. Also, you can drop the if i == 0 block as you start with\
    \ the else block. Simplification is always welcome.\n<|/ c |>\n<| c |>\nSure,\
    \ thank you for your comment, I will change the code.\n<|/ c |>\n<| a |>\nHere\
    \ is a LINQ solution:\n<code>\nvar intArray = new int[] { 1, 2, 3, 4 };\nvar result\
    \ = (from n in intArray\n             group n by n into g\n             let sum\
    \ = g.Sum()\n             where sum == 0\n             select g).Count() == 3;\n\
    </code>\n<|/ a tags=c#,algorithm,arrays dscore=2 |>\n<| a |>\n<code>\n//here you\
    \ are", "{\n    for(int i = 0; i < l.length; i++){\n        if((l[i] - l[i+1])\
    \ < 0){\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a tags=arrays,algorithm |>\n<| c |>\nThis doesn't take into account the fact\
    \ that the array elements are in descending order, whereas the original question\
    \ does. It also only tests each element once, as you mentioned in your first sentence.\n\
    <|/ c |>\n<| c |>\nI apologize, I didn't read your comment properly.\n<|/ c |>\n\
    <| c |>\nI updated the code to take care of descending order\n<|/ c |>\n<| c |>\n\
    Thanks for your answer. I will try implementing it on my code and see if it works.\n\
    <|/ c |>\n<| c |>\n: please accept this answer, if your original code is working.\n\
    <|/ c |>\n<| a tags=arrays,algorithm |>\nYou can create a triangular array and\
    \ check if every element of the triangle is negative.\nIf the triangular array\
    \ is N*N+N, where N is the length of the array. \nHere is an example: \n<code>\n\
    public boolean Triangle(boolean arr[][]) {\n        boolean check = true;\n  \
    \      int triangular[][] = new int[arr.length][arr.length];\n        for(int\
    \ i = 0; i < arr.length; i++) {\n            for(int j = i; j < arr.length; j++)\
    \ {\n                triangular[i][j] = arr[i][j];\n            }\n        }\n\
    \        for(int i = 0; i < arr.length; i++) {\n            for(int j = 0; j <\
    \ arr.length; j++) {\n                if(triangular[i][j] > 0) {\n           \
    \         check = false;\n                }\n            }\n        }\n      \
    \  return check;\n    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis also doesn't\
    \ take into account the fact that the array elements are in descending order,\
    \ whereas the original question does. It also only tests each element once, as\
    \ you mentioned in your first sentence.\n<|/ c |>\n<| c |>\nI edited my answer\
    \ to take care of descending order.\n<|/ c |>\n<| a tags=arrays,algorithm |>\n\
    <code>", "{\n    int x1,x2,x3;\n    for(x1=0;x1<l.length/3;x1++)\n    {\n    \
    \    for(x2=x1+1;x2<l.length/3;x2++)\n        {\n            for(x3=x2+1;x3<l.length/3;x3++)\n\
    \            {\n                if(l[(x1*3)+0]+l[(x1*3)+1]+l[(x1*3)+2]+l[(x2*3)+0]+l[(x2*3)+1]+l[(x2*3)+2]+l[(x3*3)+0]+l[(x3*3)+1]+l[(x3*3)+2]==0)\n\
    \                {\n                    return true;\n                }\n    \
    \        }\n        }\n    }\n    return false;\n}", "{\n    int sum = 0;\n  \
    \  int count = 0; // the number of distinct values encountered\n    \n    for\
    \ (int i=0; i< l.length; i++) \n    {\n        sum += l[i];\n        if (sum ==\
    \ 0) \n        {\n            if (count == 3) \n            {\n              \
    \  return true;\n            }\n            else\n            {\n            \
    \    count++;\n            }\n            sum = 0;\n        }\n    }\n    return\
    \ false;\n}\n</code>\n<|/ a dscore=0 tags=optimization,loops,java,performance\
    \ |>\n<| a |>\nThe other answers here are more efficient than a HashSet solution;\
    \ however, since you also asked for a simple solution, I thought I'd give a solution\
    \ using a HashSet.  This solution will take O(N) time for the number of integers\
    \ and O(N) space for the input array.\n<code>", "{\n    long sum = 0;\n    int\
    \ len = 0;\n    for(int i = 0; i < l.length; i++)\n        sum += l[i];\n    len\
    \ = l.length;", "{\n    /*\n        I didn't feel like making a hashset here\n\
    \        so I went ahead and did it this way\n    */\n    bool result = false;\n\
    \    int cur = 0, sum = 0;", "{\n    bool ret = false;\n    int n = l.Length;\n\
    \    for (int i = 0; i < n; i++)\n    {\n        int count = 0;\n        int j\
    \ = i;\n        for (int k = i; k < n; k++)\n        {\n            count += j\
    \ == k ? 1 : 0;\n            j = k;\n        }\n        if (count == 3)\n    \
    \    {\n            ret = true;\n        }\n    }\n    return ret;\n}\n</code>\n\
    I wanted to be thorough, so I wrote a test program, which compared the speed of\
    \ the above algorithm and my own. \n<code>", "{\n    \n    for (int i=0;i<l.length();i++)\n\
    \        if (l[i]==0)\n        {\n            bool b=false;\n            if (l[i]+l[i+1]==l[i+2])\n\
    \            {\n                for (int j=i;j<l.length();j++)\n             \
    \   {\n                    if (l[j]==0)\n                        b=true;\n   \
    \             }\n            }\n            return b;\n        }\n    return true;\n\
    }", "{\n    long total = 0;\n    \n    for (int i = 0; i < l.length; i++)\n  \
    \  {\n        total += l[i];\n        if (total > 0)\n        {\n            total\
    \ -= l[i];\n            if (total < 0)\n            {\n                return\
    \ false;\n            }\n        }\n    }\n    return true;\n}", "{\n    int n\
    \ = l.length;\n    int count = 0;\n    int zeros = 0;\n    for(int i =0; i < n;\
    \ ++i)\n    {\n        count += l[i];\n        if (count < 0)\n        {\n   \
    \         count = 3*count;\n            ++zeros;\n            if (zeros == 3)\n\
    \            {\n                return true;\n            }\n        }\n     \
    \   else if (count > 0)\n        {\n            zeros = 0;\n        }\n    }\n\
    \    return false;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nYou can create\
    \ an array of 3 numbers with the sum of the array as 0. So your array would look\
    \ like", "{\n    if (l.length < 3)\n        return false;\n    long sum = 0;\n\
    \    long count = 0;\n    for (int i = 0; i < l.length - 1; ++i)\n    {\n    \
    \    sum += l[i];\n        count += 1;\n        if (sum < 0)\n            return\
    \ false;\n    }\n    return count == 3;\n}", "{\n    for (int i = 0; i < l.length\
    \ - 1; ++i)\n    {\n        int a = l[i];\n        int b = l[i+1];\n        int\
    \ c = l[i+2];\n        if ((b - a + 1 < 2) || (c - b - 1 < 2))\n            continue;\n\
    \        if (b - a + 1 == 2 || c - b == 2)\n            return true;\n    }\n\
    \    return false;\n}", "{\n    long sum = 0;\n    long temp;\n    for(int i=0;\
    \ i<l.length; i++){\n        temp = l[i];\n        while(temp > 0){\n        \
    \    sum += temp % 10;\n            temp = temp / 10;\n        }\n        if (sum\
    \ == 0)\n            return true;\n    }\n    return false;\n}\n'''\n</cell>\n\
    <cell>\n%%writefile sum_to_zero.py\nimport std.array;\nimport std.range;\nimport\
    \ std.stdio;\nimport std.math;\nimport std.random;\nimport std.typecons;\nimport\
    \ std.math;\n/*", "{\n    long long ll = 0;\n    long long count = 0;\n    for(int\
    \ i = 0; i < l.length; ++i)\n    {\n        ll += l[i];\n        if(ll < 0) //\
    \ check for negative\n        {\n            ll = -l;\n            count += 2;\n\
    \        }\n        else // check for positive\n        {\n            ll += l;\n\
    \            count += 1;\n        }\n    }", "{\n    int i, j, k;\n    long a=0,\
    \ b=0, c=0;", "{\n    long sum = 0;\n    for (int i = 0; i < l.length; ++i)\n\
    \    {\n        if (l[i] > 0)\n        {\n            sum += l[i];\n        }\n\
    \    }\n    \n    return (sum == 0);\n}\n</code>\n<|/ a tags=python,arrays,java,algorithm\
    \ |>\n<| c |>\nThank you for taking the time to read through my code. I am currently\
    \ reading your answer and working on it.  I will let you know if I make any progress.\n\
    <|/ c |>\n<| c |>\nI did try your code and the following error is being thrown:\
    \ `TypeError: '<=' not supported between instances of 'int' and 'long'`.  It looks\
    \ like the 'if l[i]>0' line is causing trouble.  It also seems like it only checks\
    \ the first element in the list.\n<|/ c |>\n<| c |>\nOops, I made a mistake. Change\
    \ 'if' to 'while' in `for i`\n<|/ c |>\n<| c |>\nThis solution does not work for\
    \ the problem \"all integers can be represented as a product of three integers:\
    \ one less than a prime number, one less than two less than a prime number, and\
    \ one less than three less than a prime number.\"\n<|/ c |>\n<| c |>\nThis solution\
    \ does not work for the problem \"all integers can be represented as a product\
    \ of three integers: one less than a prime number, one less than two less than\
    \ a prime number, and one less than three less than a prime number.\"\n<|/ c |>\n\
    <| a dscore=1 |>\nHere is a very basic solution. Hope it helps!\n<code>\ndef isTriples(arr):\n\
    \    for i in range(1,arr.length-1): # loop through all elements in arr\n    \
    \    for j in range(i-1,arr.length-i,-1): # loop through all elements except the\
    \ last one\n            if arr[i]*arr[j]==arr[j]*arr[i]: # if the product of current\
    \ and previous elements is equal to the previous element then return true\n  \
    \              return True\n    return False\n</code>\n<|/ a tags=python,arrays,java,algorithm\
    \ |>\n<| c |>\nThis is actually the solution I started using but as you can see\
    \ from the comments above, I'm having issues solving this one.\n<|/ c |>\n<| c\
    \ |>\nWhat kind of issues are you having? Can you please explain more?\n<|/ c\
    \ |>\n<| c |>\nThis algorithm will always return true. It will never return false\n\
    <|/ c |>\n<| a tags=python,arrays,java,algorithm |>\nWe can use itertools.permutations\
    \ to solve this problem:\n<code>\nfrom itertools import permutations\ndef triples(number",
  "{\n    long sum = 0;\n    for(int i = 0; i < l.length; i++){\n        sum += l[i];\n\
    \    }\n    for(int i = 0; i < l.length; i++){\n        for(int j = i + 1; j <\
    \ l.length; j++){\n            if(l[i] + l[j] == 0){\n                return false;\n\
    \            }\n        }\n    }\n    return true;\n}", "{\n    long long sum\
    \ = 0;\n    int count = 1;\n    for (int i = 0; i < l.length(); i++)\n    {\n\
    \        sum += l[i];\n        if (sum != 0 && sum == l[i])\n        {\n     \
    \       count++;\n        }\n        if (count == 3)\n        {\n            return\
    \ true;\n        }\n        sum -= l[i];\n    }\n    return false;\n}\n/*", "{\n\
    \    int i,j,k,sum;", "{\n    int n = l.Length;\n    \n    for (int i = 0; i <\
    \ n; i = i + 2)\n    {\n        long k = l[i];\n        long j = l[i + 1];\n \
    \       long m = k + j;\n        if (m > 0)\n        {\n            if (m % 2\
    \ == 0)\n            {\n                if (k + j == 0)\n                {\n \
    \                   return true;\n                }\n                else\n  \
    \              {\n                    return false;\n                }\n     \
    \       }\n        }\n    }\n    return true;\n}\n</code>\n<|/ a tags=c#,algorithm,arrays\
    \ |>\n<| c |>\nI believe this only finds a solution if the sum is divisible by\
    \ three. Maybe I didn't understand this correctly. Could you please help me understand\
    \ if this is correct or not? For example [1, 1, 1] sums to 0, but [1, 1, 2] does\
    \ not. Also, [1, 2, 3] sums to 0, but [1, 2, 3] does not. Thanks for your help!\n\
    <|/ c |>\n<| a |>\nTo solve this I created some recursive methods. I hope I did\
    \ not miss anything.\n<code>\nstatic bool IsZero(long l) \n{\n    if (l == 0)\n\
    \    {\n        return true;\n    }\n    \n    if (l % 3 == 0)\n    {\n      \
    \  return true;\n    }\n    \n    if (l % 3 == 1)\n    {\n        return false;\n\
    \    }\n    \n    if (l % 3 == 2)\n    {\n        return true;\n    }\n    \n\
    \    if (l % 3 == 3)\n    {\n        return true;\n    }\n    \n    if (l % 3\
    \ == 4)\n    {\n        return false;\n    }\n    \n    if (l % 3 == 5)\n    {\n\
    \        return true;\n    }\n    \n    if (l % 3 == 6)\n    {\n        return\
    \ false;\n    }\n    \n    if (l % 3 == 7)\n    {\n        return true;\n    }\n\
    \    \n    if (l % 3 == 9)\n    {\n        return false;\n    }\n    \n    if\
    \ (l % 3 == 11)\n    {\n        return true;\n    }\n    \n    return false;\n\
    }", "{\n    int a = 0;\n    int b = 1;\n    int c = 2;\n    bool triples_sum_to_zero_result\
    \ = false;", "{\n    int count = 0; \n    \n    long sum = 0; \n    \n    for\
    \ (int i = 0; i < l.length; i++) \n    { \n        sum += l[i]; \n        if (sum\
    \ == 0) \n            count++; \n    } ", "{\n    long totalSum = 0;\n    for\
    \ (int i = 0; i < l.length - 1; i++) {\n        totalSum += l[i];\n        if\
    \ (totalSum != 0) return false;\n    }\n    return true;\n}", "{\n    int i; \n\
    \    int j;\n    int k;\n    long sum;\n    long total = 0;\n    bool found =\
    \ false;", "{\n    if (l.length < 3) return true;\n    int sum = 0;\n    for (long\
    \ i : l) {\n        if (i != 0) {\n            sum += i;\n            if (sum\
    \ == 3) return true;\n        }\n    }\n    return false;\n}\n</code>\n<|/ a tags=arrays,c++,sum\
    \ |>\n<| c |>\nThe idea of making my own function is good, but it would be good\
    \ to have another example of this in the book. Thanks\n<|/ c |>\n<| c |>\n: I've\
    \ added one more example in the answer, which uses this technique.\n<|/ c |>\n\
    <| a dscore=1 |>\nThis is a good problem for Dynamic Programming. \nWe need to\
    \ store the sum of the elements in each row of the array in a separate array.\
    \ \nThe function should return true if the sum is 3, else it should return false.\n\
    We can also store another array which is an addition operation on corresponding\
    \ elements of two rows of the previous array. \nWe can do this as \n<code>", "{\n\
    \    long long sum = 0;\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  sum += l[i];\n        /*\n            if(sum < 0) sum = 0;\n            if(sum\
    \ > 0) sum = 1;\n        */\n        if(sum > 0)\n        {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\n</code>\nTriple Sum to Zero\n\
    <code>\nimport std.algorithm;\nimport std.array;\nimport std.conv;\nimport std.typecons;\n\
    import std.math;\n/*", "{\n    int i, j;\n    int sum = 0;", "{\n    long firstZero,secondZero,thirdZero;\n\
    \    long first,second,third;\n    long i,j,k;\n    bool res = false;\n    firstZero\
    \ = secondZero = thirdZero = l[0];\n    first = second = third = l[1];\n    for(i\
    \ = 2; i< l.length; i++){\n        firstZero += l[i];\n        second += l[i];\n\
    \        third += l[i];\n        if (firstZero != 0 && second != 0 && third !=\
    \ 0 && firstZero - second - third == 0){\n            res = true;\n          \
    \  break;\n        }\n    }\n    return res;\n}\n</code>\n<|/ a tags=c#,arrays\
    \ |>\n<| c |>\nThis takes O(n^3) time, where n is the number of elements in the\
    \ array (including duplicates). I.e. O(n^2.8) if there are no duplicates.\n<|/\
    \ c |>\n<| c |>\nYour algorithm is O(n^2.8) but you are summing up to O(n^3).\n\
    <|/ c |>\n<| c |>\nYou need only one extra check to make sure there are no duplicate\
    \ numbers in your array and your algorithm is O(n^3).\n<|/ c |>\n<| c |>\nI'm\
    \ pretty sure that \"no duplicates\" does not mean no repetitions. You either\
    \ have 3 identical numbers, 3 non-identical numbers or no numbers.\n<|/ c |>\n\
    <| c |>\nAh, I missed that one. Yes, that's true. It would require 3 loops rather\
    \ than 2.\n<|/ c |>\n<| a tags=c#,arrays dscore=3 |>\nThis is my solution, for\
    \ both O(n) and O(n\xB2) time complexity:\n<code>\n    public bool IsTripleSumToZero(long[]\
    \ numbers)\n    {\n        var set = new HashSet<long>();\n        for (int i\
    \ = 0; i < numbers.Length; i++)\n        {\n            if (!set.Contains(numbers[i]))\n\
    \            {\n                set[numbers[i]] = numbers[i];\n            }\n\
    \            else\n            {\n                set.Remove(numbers[i]);\n  \
    \          }\n        }\n        return set.Count == 0;\n    }\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis takes O(n^2.8) for me but I am sure that the answer is O(n^3)\
    \ if we have no duplicates.\n<|/ c |>\n<| c |>\nOh, yes, you're right. I didn't\
    \ realize about duplicates. I'll fix my answer.\n<|/ c |>\n<| c |>\nOk, I repaired\
    \ my answer. Your algorithm is O(n^2.", "{\n    long zero = 0;\n    long two =\
    \ 0;\n    long three = 0;\n    long zero_count = 0;", "{\n    long long l3 = l\
    \ [l.length-1];\n    for(long i=0; i<l.length-2; i++)\n    {\n        l3 += l\
    \ [i];\n        if(l3 == 0) return true;\n    }\n    return false;\n}\n</code>\n\
    <|/ a tags=python dscore=0 |>\n<| a |>\nHere is my version of the same algorithm:\n\
    <code>\ndef all_triplets(arr):\n    arr = [1, 3, 5]\n    ans = True\n    i = 0\n\
    \    while i < len(arr) - 1:\n        if i == len(arr) - 3:\n            break\n\
    \        if i + 1 == len(arr) - 1:\n            ans = False\n            break\n\
    \        if arr[i] + arr[i + 1] + arr[i + 2] != 0:\n            ans = False\n\
    \            break\n        i += 1\n    return ans", "{\n    // write your code\
    \ in C# here\n}\n</code>\n<|/ q tags=c#,c++,algorithm |>\n<| c |>\nWhat does \"\
    the sum of the numbers\" mean?  How does it relate to the problem as stated?\n\
    <|/ c |>\n<| c |>\nsum of the numbers means sum of all numbers that are not zero\n\
    <|/ c |>\n<| c |>\nI think you mean to find the triplets that sum to a specific\
    \ value, such as `0`, `1`, and `2`?\n<|/ c |>\n<| c |>\nyes, that is exactly what\
    \ i meant\n<|/ c |>\n<| c |>\nSo you mean that the triplets can be {0, 3, 5} or\
    \ {0, -2, 1}?\n<|/ c |>\n<| a |>\nThe algorithm is relatively straight-forward:\n\
    <code>\nfor each triple:\n    if its sum is 0, return false\nreturn true\n</code>\n\
    This runs in O(n^3) time, where n is the number of elements.  You can get an additional\
    \ O(n) space to store a bitmask of the triplet values, and then you can do an\
    \ early return if the sum of the triplet elements is 0.\n<|/ a tags=c#,c++,algorithm\
    \ dscore=4 |>\n<| c |>\nIt would be O(n^2) for worst case and O(n) average case\
    \ since the sum of the array elements can be zero only once and the maximum triplet\
    \ is at most two.\n<|/ c |>\n<| c |>\nI believe your proof is wrong. As you noted,\
    \ O(n^2) is more appropriate here than O(n), but you are not guaranteed that O(n^2)\
    \ is better than O(n).\n<|/ c |>\n<| c |>\n:  You are correct, but I was thinking\
    \ of the worst-case scenario where every triplet is equally likely to occur. \
    \ Since there are (n-1) choices here, an O(n^2) algorithm is possible.  Also,\
    \ given that the input array will always be sorted before being passed in, the\
    \ best case is O(n), so an O(n) algorithm is possible also.\n<|/ c |>\n<| c |>\n\
    I am not sure I understand your \"bitmask\" comment. How are you storing a bitmask\
    \ of the triplet values?\n<|/ c |>\n<| c |>\n:  If you have a triplet {0, 3, 5}\
    \ as input, then the bitmask of the triplet will be `{1, 0, 0}`.  So, if the sum\
    \ of the triplet elements is 0, you can immediately return false because that ",
  "{\n\tif (l.length < 3)\n\t{\n\t\treturn false;\n\t}\n\t\n\tlong sum = 0;\n\tfor\
    \ (int i = 0; i < l.length; ++i)\n\t{\n\t\tsum += l[i];\n\t}\n\t\n\tfor (int i\
    \ = 0; i < l.length; ++i)\n\t{\n\t\tfor (int j = 0; j < l.length; ++j)\n\t\t{\n\
    \t\t\tif (i != j)\n\t\t\t{\n\t\t\t\tif (l[i] + l[j] == 0)\n\t\t\t\t{\n\t\t\t\t\
    \treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}", "{\n\
    \  \n    for (int i = 0; i < l.length; i++){\n        long temp=l[i];\n      \
    \  for (int j = i + 1; j < l.length; j++){\n            long sum=0;\n        \
    \    for(int k = j + 1; k < l.length; k++){\n                sum+=l[k];\n    \
    \        }\n            if(sum==0){\n                return true;\n          \
    \  }\n        }\n    }\n    return false;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\n\
    public boolean hasSumToZero(long[] array) {\n    long sum = 0;\n    for(int i=0;\
    \ i < array.length; i++){\n        sum = sum + array[i];\n        for(int j =\
    \ i+1; j < array.length; j++){\n            if(sum == 0){\n                return\
    \ true;\n            }\n            sum = sum - array[j];\n        }\n    }\n\
    \    return false;\n}\n</code>\n<|/ a tags=arrays,sum,java dscore=1 |>\n<| a |>\n\
    Just for fun. This is a solution that makes use of streams. I used java8 streams\
    \ and a little bit of mathematics.\n<code>\npublic static boolean hasSumToZero(long[]\
    \ arr) {\n    return Arrays.stream(arr)\n            .filter(x -> Arrays.stream(arr).filter(y\
    \ -> y == x).count() == 3)\n            .count() == 3;\n}\n</code>\n<|/ a dscore=1\
    \ tags=arrays,sum,java |>\n<| c |>\nThank you for your effort! I really appreciate\
    \ it\n<|/ c |>\n<| a dscore=0 tags=arrays,sum,java |>\n<code>\npublic class ThreeNumbersWithSum\
    \ \n{\n    public static void main(String[] args) \n    {\n        int[] ar =\
    \ new int[4];", "{\n  long sum = 0;\n  for (int i = 0; i < l.length; ++i) {\n\
    \    sum += l[i];\n    if (sum > 0)\n      return true;\n    else if (sum < 0)\n\
    \      return false;\n  }\n  return false;\n}\n'''", "{\n  if(l.length==0) return\
    \ false;\n  int count = 0;\n  int sum = 0;\n  for(int i=0; i<l.length; i++)\n\
    \  {\n    if(l[i]==0) return false;\n    sum += l[i];\n    count += 1;\n  }\n\
    \  if(count==3) return true;\n  return false;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\nJust for fun. Not as efficient as other solutions, but pretty\
    \ simple:\n<code>", "{\n\t// O(n^3) naive approach to this\n    int c = 0;\n \
    \   for(int i = 0; i < l.length-1; i++){\n        c += l[i];\n        if(c > 0){\n\
    \            for(int j = i+1; j < l.length; j++){\n                c -= l[j];\n\
    \                if(c <= 0){\n                    return true;\n             \
    \   }\n            }\n        }\n    }\n    return false;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nIt would be nice if the person who downvoted could specify why.\n<|/\
    \ c |>\n<| c |>\nI didn't downvote you, since I didn't see your answer until after\
    \ I edited my question to add my solution. Sorry about that.\n<|/ c |>\n<| a dscore=3\
    \ tags=language-agnostic,arrays |>\nI wanted to test the time complexity of the\
    \ solutions posted here. I made a benchmark based on the results of Tim's solution\
    \ (O(n^2) in terms of Big O) and my solution (O(n^3) in terms of Big O). \nThe\
    \ results showed that my solution is faster than Tim's solution (not surprisingly,\
    \ since my solution is faster than the best solutions posted here). I decided\
    \ to post the results, since I wanted to share them.\nResults:", "{\n    if (l.Length\
    \ <= 3) return false;\n    long s = 0;\n    foreach (long x in l) s += x;\n  \
    \  if (s == 0) return false;\n    for (int i = 0; i < 3; i++) \n        if (s[i]\
    \ != 0) \n            return false;\n    return true;\n}", "{\n    long sum =\
    \ 0;\n    long current;\n    for(long i = 0; i < l.length; ++i) {\n        current\
    \ = l[i];\n        if(current > 0) sum += current;\n        else if(sum > 0) {\n\
    \            sum = sum - current;\n            if(sum == 0) return true;\n   \
    \     }\n    }\n    return false;\n}\n</code>\n<|/ a |>\n<| a tags=arrays,c# dscore=1\
    \ |>\n<code>\nclass Program\n{\n    static void Main(string[] args)\n    {\n \
    \       int[] a = new int[] { 1, 3, 5 };\n        bool areAllEqual = areAllEqual(a);\n\
    \        Console.WriteLine(areAllEqual);\n        Console.ReadKey();\n    }",
  "{\n    int t=0;\n    for(size_t i=0;i<l.length();++i) {\n        int sum = l[i];\n\
    \        t += sum;\n        if (t == 0)\n            return false;\n        if\
    \ (sum > 0)\n            t -= sum;\n    }\n    return true;\n}", "{\n    long\
    \ sum = 0;\n    \n    // We use two pointers to traverse the array, one for odd\
    \ indices\n    // and another for even indices. \n    long i, j, k;\n    \n  \
    \  for (i = 0, j = 0; i < l.length; i++, j++) {\n        k = l[i] + l[j];\n  \
    \      if (k > 0) sum += k;\n    }\n    \n    // We need to check if any two elements\
    \ sum to zero\n    if (sum != 0)\n        return false;\n    \n    sum = 0;\n\
    \    \n    for (i = 0, j = 1, k = 0; i < l.length; i++, j++, k++) {\n        k\
    \ = l[i] + l[j] + l[k];\n        if (k > 0) sum += k;\n    }\n    \n    if (sum\
    \ != 0)\n        return false;\n    \n    sum = 0;\n    \n    for (i = 0, j =\
    \ 1, k = 1; i < l.length; i++, j++, k++) {\n        k = l[i] + l[j] + l[k];\n\
    \        if (k > 0) sum += k;\n    }\n    \n    if (sum != 0)\n        return\
    \ false;\n    \n    return true;\n}", "{\n\tsize_t i = 0;\n\tsize_t j = 0;\n\t\
    bool ret = false;\n\tlong   sum = 0;\n\t\n\tfor (size_t k = 0; k < l.length; ++k)\n\
    \t{\n\t\tsum = l[k] + sum;\n\t\tif (sum == 0) \n\t\t{\n\t\t\tif (i > j)\n\t\t\t\
    {\n\t\t\t\tret = true; \n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn ret;\n}", "{\n\
    \    long t = 0;\n    long k = 0;\n    long t1 = 0;\n    long t2 = 0;\n    long\
    \ t3 = 0;\n    int i;\n    for (i = 1; i < l.length; ++i) {\n        t1 = l[i\
    \ - 1];\n        t2 = l[i];\n        t3 = l[i + 1];\n        t += t1 + t2 + t3;\n\
    \        k = t % 10;\n        if (k == 3) {\n            if (t1 != t2 && t1 !=\
    \ t3 && t2 != t3) {\n                return true;\n            }\n        }\n\
    \    }\n    return false;\n}", "{\n    if( l == null || l.length < 3 )\n     \
    \   return true;\n    int sum = 0;\n    for( int i = 0; i < l.length; i++ )\n\
    \        sum += l[i];\n    if( sum == 0 )\n        return false;\n    int count\
    \ = 1;\n    for( int i = 0; i < l.length - 1; i++ )\n    {\n        if( l[i] ==\
    \ 0 )\n        {\n            count++;\n            if( count == 3 )\n       \
    \         return true;\n        }\n    }\n    return false;\n}\n// returns true\
    \ if the vector is sorted in ascending order", "{\n    int len = (int)(l.length());\n\
    \    for(int i = 0; i < len-1; i++)\n    {\n        for(int j = 1; j < len-i;\
    \ j++)\n        {\n            long s = 0;\n            for(int k = 0; k < j;\
    \ k++)\n                s += l[k];\n            long d = l[j];\n            if(s\
    \ > 0)\n            {\n                if(s == d)\n                    return\
    \ true;\n                else if(s - d == d)\n                    if(j < len-2)\n\
    \                        return true;\n            }\n        }\n    }\n    return\
    \ false;\n}", "{\n    int counter = 0; //number of times we found the third number\
    \ that sums to zero\n    long threeSum = 0;\n    long sum = 0;\n    int threeCount\
    \ = 0;\n    long sumOfEvenIndex = 0;", "{\n    ulong tmpSum = 0, lSum = 0;\n \
    \   for(int i = 0; i < l.length; ++i)\n        tmpSum += l[i];\n    lSum = 0;\n\
    \    for(int i = 0; i < l.length; ++i)\n        lSum += l[i];\n    return (lSum\
    \ == 0 && tmpSum == 0);\n}", "{\n\tint[] ans = new int[l.length];\n\t\n\tfor(int\
    \ i =0; i < l.length; i++)\n\t{\n\t\tans[i] = (l[i] + l[i+1] + l[i+2]) / 3;\n\t\
    }\n\t\n\tfor(int i =0; i < ans.length; i++)\n\t{\n\t\tif(ans[i] != 0)\n\t\t\t\
    return true;\n\t}\n\t\n\treturn false;\n}", "{\n    long ans = 0, ans2 = 0;\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        ans = ans + l[i];\n   \
    \     ans2 = ans + l[i];\n        if(ans == 0)\n        {\n            ans = ans2;\
    \ \n        }\n    }\n    return ans == 0;\n}", "{\n    int i;\n    int sum =\
    \ 0;\n    int threeSums = 0;\n    for(i = 0; i < l.length; ++i)\n    {\n     \
    \   sum = sum + l[i];\n        if(sum > 0)\n        {\n            threeSums =\
    \ threeSums + 1;\n            sum = 0;\n        }\n        else if(sum < 0)\n\
    \        {\n            if(threeSums == 3)\n            {\n                return\
    \ true;\n            }\n            else\n            {\n                sum =\
    \ 0;\n            }\n        }\n    }\n    return threeSums == 3;\n}", "{\n  \
    \  int sum = 0;\n    foreach(long l in l) \n    {\n        sum += l;\n       \
    \ if (sum > 0)\n        {\n            return false;\n        }\n    }\n    return\
    \ true;\n}", "{\n    long s = 0;\n    for (long i : l) s += i;\n    return l ==\
    \ null || 3 == l && l[0] == 0 && l[1] == l[2] && 0 == s;\n}\n// returns true if\
    \ l1 is sorted after l2", "{\n    \n    int i;\n    int n = 0;\n    \n    for(int\
    \ i = 0; i < l.length; i++){\n        if (l[i] == 0){\n            n++;\n    \
    \    }\n        if(i != l.length - 1 && l[i] == l[i + 1]){\n            if(n ==\
    \ 3){\n                return true;\n            }\n            n++;\n       \
    \ }\n    }\n    return false;\n}\n</code>\nThis has runtime complexity O(N^2),\
    \ but I believe the time complexity is O(N). Am I wrong? If not, what could be\
    \ the runtime complexity of this implementation?\n<|/ q tags=arrays,algorithm,sorting,java,big-o\
    \ |>\n<| c |>\nDo you have any requirements about the data being sorted or is\
    \ it just any arbitrary sequence in the input?\n<|/ c |>\n<| c |>\nIf it can be\
    \ done in linear time, then yes. But it depends on the type of input.\n<|/ c |>\n\
    <| c |>\nYou can't do that in linear time. How big is your input?\n<|/ c |>\n\
    <| c |>\nHow do you determine whether two adjacent values are equal without iterating\
    \ through the whole list?\n<|/ c |>\n<| c |>\n, you are right, it's linear if\
    \ you do it right\n<|/ c |>\n<| a dscore=1 |>\nThe algorithm is linear with the\
    \ number of distinct elements. As an additional preprocessing step, it might be\
    \ interesting to store the indices of the distinct elements, which would make\
    \ the algorithm linear in that dimension.\nThe naive approach would be to keep\
    \ two arrays: one with the distinct elements and one with the indices. Then you\
    \ would have to iterate through the entire array once to determine the distinct\
    \ elements and once again to determine the indices of the elements. To find distinct\
    \ elements you might use an array/set that preserves insertion order (HashSet).\
    \ To find the indices you can just use an array as backing storage.\nThis should\
    \ be linear complexity because you only iterate over the original array once and\
    \ only once to find the distinct elements.\n<|/ a tags=arrays,algorithm,sorting,java,big-o\
    \ |>\n<| c |>\nYour analysis is correct but doesn't seem to be the correct solution.\
    \ The question explicitly asked for runtime complexity in Big-Oh, and yours seems\
    \ unjustified in practice. Those are two very different things.\n<|/ c |>\n<|\
    \ c |>\nI agree with you that your analysis is not necessarily correct. The algorithm\
    \ I described is a simple linear algorithm that doesn't depend on order. It can\
    \ be implemented as `O(n)` time and `O(n)` space. My analysis is a good approximation\
    \ of the complex", "{\n  int sum = 0;\n  int count = 0;\n  for (int i = 0; i <\
    \ l.length; i++)\n  {\n    sum += l[i];\n    if (sum == 0)\n    {\n      count++;\n\
    \    }\n  }\n  if (count == 3)\n  {\n    return true;\n  }\n  else\n  {\n    return\
    \ false;\n  }\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't answer the question.\
    \ The OP asks if there is a faster way to determine if the array has 3 distinct\
    \ values that sum to zero. This method doesn't address that.\n<|/ c |>\n<| c |>\n\
    It answers the question. The OP asked if there is a faster way to determine if\
    \ there are 3 distinct values that sum to zero, not if there is a faster way to\
    \ determine if there are 3 distinct numbers that sum to zero. He didn't ask about\
    \ all possible combinations. He asked if there could be a faster way than brute-force.\
    \ That's what I answered. Why do you say this doesn't answer the question? I'm\
    \ confused.\n<|/ c |>\n<| c |>\nI wasn't implying that your answer doesn't answer\
    \ the question. Your answer is still the fastest possible way to determine if\
    \ there are three distinct numbers that sum to zero.\n<|/ c |>\n<| c |>\nSorry,\
    \ I misunderstood the question.\n<|/ c |>\n<| a tags=arrays,algorithm,performance,c,c++\
    \ |>\nTo check if there are 3 distinct values that sum to zero, you can just check\
    \ the number of unique integers that sum to zero. Assuming that numbers are represented\
    \ as integers, this can be done quickly using counting sort.\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\nFor a small array, you can check all the numbers against their\
    \ sum until you get a non-zero sum.  At that point, you can assume the sum was\
    \ zero.\nIt would be a bit more efficient to run this test on a larger array and\
    \ see how many numbers don't sum to zero in fewer steps.\n<|/ a tags=arrays,algorithm,performance,c,c++\
    \ |>\n<| c |>\nThis doesn't answer the question. The OP asked if there is a faster\
    \ way to determine if there are 3 distinct values that sum to zero. This method\
    \ doesn't address that.\n<|/ c |>\n<| c |>\n:  What do you mean \"faster\"?  It\
    \ should find the answer very quickly.\n<|/ c |>\n<| c |>\nI was referring to\
    \ \"faster\" as in \"faster than my brute force method of checking all possible\
    \ combinations.\"\n<|/ c |>\n<| c |>\n: In that case, I think you'll ", "{\n \
    \   int[] cnts_array = new int[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \        cnts_array[i]++;\n    int min_cnt = cnts_array[0];\n    for(int i = 1;\
    \ i < l.length; i++)\n    {\n        int current_cnt = cnts_array[i];\n      \
    \  if(current_cnt < min_cnt)\n            min_cnt = current_cnt;\n    }\n    for(int\
    \ i = 0; i < l.length; i++)\n    {\n        int current_cnt = cnts_array[i];\n\
    \        if(current_cnt == min_cnt)\n            continue;\n        int cnt =\
    \ (l[i] + l[i - 1] + l[i + 1]) / 3;\n        int curr_sum = l[i] + l[i - 1] +\
    \ l[i + 1];\n        if(cnt < 3)\n            return false;\n        cnts_array[i]\
    \ = cnt;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c++,algorithm\
    \ dscore=1 |>\n<code>", "{\n    for (int i = 0; i < l.length; i += 3) {\n    \
    \    int three = 0;\n        int sum = 0;\n        for(int j = 0; j < 3; ++j)\
    \ {\n            sum += l[i + j];\n            if(sum < 0) {\n               \
    \ sum = 0;\n            }\n            three += 1;\n        }\n        if (three\
    \ == 3) {\n            return true;\n        }\n    }\n    return false;\n}",
  "{\n\tint count = 0;\n\tfor (int i=0; i<l.size(); ++i) \n\t{\n\t\tcount += l[i];\n\
    \t\tif (count < 0) count = -count;\n\t\telse if (count != 0) \n\t\t{\n\t\t\treturn\
    \ true;\n\t\t}\n\t}\n\treturn false;\n}", "{\n\tbool result = false;\n\tfor (int\
    \ i = 0; i < l.length - 1; i++) {\n\t\tfor (int j = i + 1; j < l.length; j++)\
    \ {\n\t\t\tfor (int k = j + 1; k < l.length; k++) {\n\t\t\t\tlong x = l[i] + l[j]\
    \ + l[k];\n\t\t\t\tif (x != 0) {\n\t\t\t\t\tresult = true;\n\t\t\t\t\tbreak;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n/*", "{\n    int i,j;\n \
    \   for (i=0;i<l.length-1;i++){\n        j = i + 1;\n        for(j<l.length;j++){\n\
    \            if(l[i]+l[j] == 0){\n                return true;\n            }\n\
    \        }\n    }\n    return false;\n}", "{\n\tint i = 0;\n\tlong sum = 0, sumOfLastTwo\
    \ = 0, sumOfLastThree = 0;", "{\n    //int count = 0;\n    int i;\n    int j;\n\
    \    for(i=0;i<l.length;i++) \n    {\n        for(j=i+1;j<l.length;j++) \n   \
    \     {\n            if (l[i] + l[j] > 0) \n            {\n                if\
    \ (l[i]+l[j] == l[j]) \n                {\n                    return false;\n\
    \                }\n            }\n        }\n    }\n    return true;\n}\n</code>\n\
    <|/ a dscore=3 tags=arrays,algorithm,c++ |>\n<| c |>\nThanks for the answer. I\
    \ was able to adapt this to my situation. It works, though it is very slow for\
    \ my purposes. I'm going to have to work on optimizing it more.\n<|/ c |>\n<|\
    \ a |>\n<code>", "{\n\tauto zeros = std.set(std.reduce.map(l, std.int_add, std.int_mul));\n\
    \tif (zeros.size() == 3) return true;\n\treturn false;\n}", "{\n    int i,j,k,l,m,n;\n\
    \    int arrsize = l.length;\n    for(i = 0; i < arrsize; i++) {\n        for(j\
    \ = 0; j < arrsize; j++) {\n            for(k = 0; k < arrsize; k++) {\n     \
    \           m = arrsize*arrsize*arrsize;\n                n = arrsize*arrsize*arrsize*arrsize;\n\
    \                if( triples_sum_to_zero[m, n, k, j, i]) {\n                 \
    \   l = i;\n                    return true;\n                }\n            }\n\
    \        }\n    }\n    return false;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    This is a very efficient solution if you need the sum to be zero, however I think\
    \ this is still quite inefficient as it computes the `triples_sum_to_zero` array\
    \ multiple times.\n<|/ c |>\n<| c |>\nYou are right! Thanks for the tip! I've\
    \ edited my answer to avoid this redundant computation. Sorry for my carelessness.\n\
    <|/ c |>\n<| c |>\nNo worries. I see you've added the memoization technique. That's\
    \ a great solution but I'd like to see a solution which doesn't rely on the triple\
    \ product. I'd like to see a solution which requires only a single pass through\
    \ the array.\n<|/ c |>\n<| c |>\nHi, I believe that the solution you propose in\
    \ the second edit is much faster than the one suggested in the first edit. That's\
    \ because the memory for the array is preallocated and not re-allocated in each\
    \ step. However, as you say, the solution using two passes seems better than the\
    \ one using the triple product. I will post the solution that uses the triple\
    \ product in the next edit. Thanks for the tip :)\n<|/ c |>\n<| c |>\nI realized\
    \ that the solution you propose in the second edit is actually more efficient\
    \ than my previous solution. Sorry for the misunderstanding.\n<|/ c |>\n<| a tags=arrays,algorithm\
    \ |>\nThis can actually be done in O(N log N) time complexity by using a Segment\
    \ Tree.\nIn essence you build a tree that represents the possible sums of values\
    \ from 0 to N - 1.  If you add a new value to the tree, you either update an existing\
    \ value, or you insert a new one.  When you update an existing value, the left\
    \ child of any node containing the new value is the sum of the left values on\
    \ the existing values and the new value.  In the case where the new value is greater\
    \ than the old value, the new value is added to the right child of the node. \
    \ The right child is then calculated from the sum of the left and right values.\n\
    The complexity of building the tree is O(N log N).  The complexity of updat",
  "{\n    long long int sum = 0;\n    int i;\n    for(i = 0; i < l.length; ++i) {\n\
    \        sum += l[i];\n        if (sum < 0) {\n            sum = 0;\n        }\n\
    \    }\n    return l.length == 3 && sum == 0;\n}", "{\n    long long sum = 0;\n\
    \    for (long i : l)\n        sum += i;\n    if (sum != 0) return true;\n   \
    \ \n    for (long i : l)\n    {\n        sum += i;\n        long tempSum = sum;\n\
    \        while (tempSum != 0)\n        {\n            sum += tempSum;\n      \
    \      tempSum -= sum;\n        }\n        if (sum == 0) return true;\n    }\n\
    \    \n    return false;\n}", "{\n    long sum = 0;\n    int i = 0;\n    int j\
    \ = 0;\n    int k = 0;", "{\n    long i, j, sum;\n    bool result = 0;\n    for(i\
    \ = 0; i < l.length; ++i) {\n        sum = 0;\n        for(j = 0; j < l.length;\
    \ ++j) {\n            if(i != j) {\n                sum += l[j];\n           \
    \ }\n        }\n        if(sum == 0 && i < 3) result = true;\n        else if(sum\
    \ == 0 && i == 3) result = true;\n        else break;\n    }\n    return result;\n\
    }\n/*", "{\n    int i;\n    int j;\n    int k;", "{\n    int n = l.Length;\n \
    \   long sum = 0;\n    for (int i = 0; i < n; i++) \n    {\n        sum += l[i];\n\
    \        if (sum < 0) return false;\n    }\n    if (sum == 0) return true;\n \
    \   return false;\n}", "{\n    var len = l.Length;\n    \n    for(var i=0; i <\
    \ len; i++)\n    {\n        var m = std.math.min(i, len - 1);\n        if(l[m]\
    \ + l[m+1] + l[m+2] == 0)\n            return true;\n    }\n    \n    return false;\n\
    }\n</code>\n<|/ a tags=algorithm,.net,c# |>\n<| a dscore=2 |>\nThis is an old\
    \ question, but I'd like to add an updated answer for the latest version of C#\
    \ (as of October 2017).\nThe .NET Core library now includes some built-in algorithms\
    \ that can handle this problem and be efficiently implemented. Specifically, I\
    \ recommend using the CountDownLatch class. From the docs:", "{\n    long a =\
    \ l[0];\n    long b = l[1];\n    long c = l[2];\n    bool b = false;\n    \n \
    \   if (b == 0)\n    {\n        return true;\n    }\n    \n    if (a == 0)\n \
    \   {\n        return true;\n    }\n    \n    if (c == 0)\n    {\n        return\
    \ true;\n    }\n    \n    if (a * b * c == 0)\n    {\n        return true;\n \
    \   }\n    \n    b = a % b;\n    c = a % c;\n    \n    if (b == 0 && c == 0)\n\
    \    {\n        b = a / b;\n        c = a / c;\n        if (b * b == c * c)\n\
    \        {\n            return true;\n        }\n    }\n    \n    return false;\n\
    }", "{\n    int n=l.length;\n    if(n<3)return false;\n    long[] a=new long[3];\n\
    \    for(int i=0;i<3;i++) a[i]=0;\n    int sum=0;\n    for(int i=0;i<n;i++){\n\
    \        sum+=l[i];\n        if(sum>0) a[sum]++;\n        else if(sum<0){\n  \
    \          if(sum>=0)a[sum+1]++;\n            else{\n                a[sum-1]++;\n\
    \                sum=0;\n            }\n        }\n    }\n    for(int i=0;i<3;i++){\n\
    \        if(a[i]>0) return false;\n    }\n    return true;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nWhy don't you try your function in `std.typecons.double1`?\
    \  You do realize that your function isn't the only possible solution to checking\
    \ that there are three distinct elements in the array that sum to zero?  It can\
    \ have *any* number of elements that sum to zero.\n<|/ c |>\n<| c |>\nI edited\
    \ my answer to include your remark about `std.typecons.double1`; thanks\n<|/ c\
    \ |>\n<| a |>\nA simple recursive function could do it!\n<code>", "{\n\tif((l.length\
    \ == 0) || (l.length % 3 != 0))\n\t\treturn false;\n\tlong first = l[0];\n\tlong\
    \ second = 0;\n\tlong third = 0;\n\tfor(long i = 0; i < l.length; i++)\n\t{\n\t\
    \tif((i + 1) < l.length)\n\t\t{\n\t\t\tsecond = l[i];\n\t\t\tif((i + 2) > l.length)\n\
    \t\t\t\tthird = l[i+2];\n\t\t\telse\n\t\t\t\tthird = l[i+1];\n\t\t\tif(first +\
    \ second + third == 0)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\
    /*", "{\n    long long count = 0;\n    for (int i = 0; i < l.length; i++){\n \
    \       count += l[i];\n    }\n    return count >= 3;\n}\n</code>\n<|/ a tags=algorithm,java\
    \ |>\n<| c |>\nIt is not an O(n) algorithm, it uses O(logn) memory and the array\
    \ has to be sorted\n<|/ c |>\n<| c |>\nIt is O(n) algorithm because it just looks\
    \ at each number in the array. Since each number will be at most one more than\
    \ the previous, this runs in O(n).\n<|/ c |>\n<| a |>\nI believe that this is\
    \ what you are looking for:\n<code>\npublic static boolean triples(int[] array)\
    \ {\n        boolean hasTriples = false;", "{\n    long long sum;\n    int cnt;",
  "{\n    int sum;\n    bool equal;\n    int temp1;\n    int temp2;\n    int temp3;\n\
    \    for(int i = 0; i < l.length / 3; i++) \n    {\n        equal = true;\n  \
    \      sum = 0;\n        for(int j = 0; j < l.length; j++) \n        {\n     \
    \       if(i == j) \n            {\n                continue;\n            }\n\
    \            sum += l[j] * l[j];\n            if(sum > 0) \n            {\n  \
    \              equal = false;\n                break;\n            }\n       \
    \ }\n        if(equal) \n        {\n            temp1 = l[i];\n            temp2\
    \ = l[i * 3 + 1];\n            temp3 = l[i * 3 + 2];\n            if(temp1 ==\
    \ temp2 && temp2 == temp3) \n            {\n                return true;\n   \
    \         }\n        }\n    }\n    return false;\n}", "{\n    long a = l[0];\n\
    \    long b = l[1];\n    long c = l[2];\n    \n    if(a <= -64*1024*1024 && b\
    \ <= -64*1024*1024 && c <= -64*1024*1024) {\n        return false;\n    }\n  \
    \  long p = a + b + c;\n    \n    if(a > -64*1024*1024 && b > -64*1024*1024 &&\
    \ c > -64*1024*1024) {\n        long q = a * 64*1024*1024;\n        long r = b\
    \ * 64*1024*1024;\n        long s = c * 64*1024*1024;\n        long v = std.math._signed_add(q,\
    \ r);\n        long w = std.math._signed_add(s, v);\n        return w == 0;\n\
    \    }\n    \n    return p < 0;\n}\n// vim:et:sts=4:sw=4:ai\n// %feature(\"short-circuit\"\
    , bool)", "{\n    long total = 0;\n    long cur = l[0];\n    int count = 0;\n\
    \    foreach ( long i, l )\n    {\n        total += i;\n        if (total >= cur)\n\
    \        {\n            count++;\n            total -= cur;\n        }\n     \
    \   cur = i;\n    }\n    return (count == 3);\n}\n</code>\n<|/ a |>\n<| c |>\n\
    This is not correct. Consider the input `[]`.\n<|/ c |>\n<| c |>\nPlease provide\
    \ some explanation about why this works. As it stands, it would be beneficial\
    \ to the site to learn from your post.\n<|/ c |>\n<| c |>\nThe algorithm is incorrect.\
    \ it returns true when the input array is of size 1, and false when the input\
    \ array has size > 3.\n<|/ c |>\n<| c |>\nThis algorithm will return false if\
    \ there are 3 or more elements in the array that sum to 0\n<|/ c |>\n<| c |>\n\
    This algorithm returns true when the input array is of size 1. This is because\
    \ when we are counting the number of triples that sum to 0, we only want one number\
    \ in the sum. So when the input array is of size 1, only 1 triple sum to 0 and\
    \ so count becomes 0. But when the input array is of size 3, 3 triplets sum to\
    \ 0 and so count becomes 3. \nI hope this helps\n<|/ c |>\n<| a dscore=2 |>\n\
    A more efficient solution is to use a hash map to keep track of the numbers we've\
    \ seen so far. Once we have three of them we return true.\n<code>\npublic boolean\
    \ tripleSumToZero(long[] array) {\n    int count = 1;\n    Map<Integer, Integer>\
    \ map = new HashMap<>();\n    for( int i = 0; i < array.length; i++ ) {\n    \
    \    Integer key = array[i] + array[i];\n        if( map.containsKey( key ) )\
    \ {\n            map.put( key, map.get( key ) + 1 );\n            if( map.get(\
    \ key ) == 3 )\n                return true;\n        } else {\n            map.put(\
    \ key, 1 );\n        }\n    }\n    return false;\n}\n</code>\n<|/ a tags=java,algorithm,performance\
    \ |>\n<| a tags=java,algorithm,performance |>\nThe below solution works for all\
    \ the test cases.\n<code>\n /**\n * Triples Sum To Zero\n * \n * nums\n * {@code\
    \ true} if the array has exactly three distinct elements that sum\n *        \
    \     to zero.\n */\npublic static boolean tripleSumToZero(long[] nums) {\n  \
    \  // Find distinct elements in nums\n    List<Integer> distinct = new ArrayList<Integer>();\n\
    \    for (long num", "{\n    int n = l.lenth;\n    for(int i = 0; i < n; i +=\
    \ 2)\n    {\n        int s = l[i] + l[i+1];\n        if(s == 0)\n        {\n \
    \           return false;\n        }\n    }\n    return true;\n}\n</code>\nThe\
    \ main difference here is that we are using std.typecons instead of std.algorithm.\n\
    <|/ a dscore=2 tags=stl,algorithm,c++ |>\n<| a dscore=2 |>\nHere's a solution\
    \ using std::remove_if from the algorithms header:\n<code>", "{\n    int i = 0;\n\
    \    while(i < l.length) \n    {\n        int j = i + 1;\n        while(j < l.length\
    \ && l[j] == 0) j++;\n        int k = j + 1;\n        while(k <l.length && l[k]\
    \ == 0) k++;\n        if(k - j >= 3)\n            return false;\n        i +=\
    \ k - j + 1;\n    }\n    return true;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    The solution is working just fine, but it's slow. Can you please tell me how to\
    \ optimize the solution?\n<|/ c |>\n<| c |>\nIn order to find if there are three\
    \ distinct elements that sum to zero you will have to loop over the whole list.\
    \ Ideally you would like to keep it low-level and use SIMD instructions. But if\
    \ you really want to go low-level, you could keep track of the number of distinct\
    \ elements that you see so far, and when it becomes three you know that there\
    \ are no triples to sum zero.\n<|/ c |>\n<| c |>\nI have edited my answer to include\
    \ a low-level solution that I believe to be faster than the accepted answer.\n\
    <|/ c |>\n<| a |>\nThe most straightforward way to solve this problem is to keep\
    \ track of the cumulative sum of each element that you have seen so far. For each\
    \ element that you have seen, check if the cumulative sum is greater than zero.\n\
    Here is a sample Python 3 implementation of the algorithm:\n<code>\ndef triples_sum_to_zero(l):\n\
    \    curr_sum = 0\n    cum_sums = []\n    for x in l:\n        curr_sum += x\n\
    \        cum_sums.append(curr_sum)", "{\n  // Your code goes here\n  int counter\
    \ = 0;\n  for (int i = 0; i < l.Length-1; i++)\n  {\n    for (int j = i+1; j <\
    \ l.Length; j++)\n    {\n      for (int k = j+1; k < l.Length; k++)\n      {\n\
    \        if (l[i] + l[j] + l[k] == 0)\n        {\n          counter++;\n     \
    \   }\n      }\n    }\n  }\n  if (counter > 2)\n  {\n    return false;\n  }\n\
    \  return true;\n}\n</code>\n<|/ a tags=c#,math,arrays,algorithm |>\n<| a dscore=0\
    \ |>\nI got this working for me:\n<code>\nprivate bool TripleSumZero(int[] ints)\n\
    {\n    int[] counts = new int[3];\n    foreach (int x in ints)\n    {\n      \
    \  ints.Remove(x);\n        foreach (int i in ints)\n        {\n            ints.Remove(i);\n\
    \            foreach (int j in ints)\n            {\n                ints.Remove(j);\n\
    \                if (x + i + j == 0)\n                {\n                    counts[0]++;\n\
    \                    counts[1]++;\n                    counts[2]++;\n        \
    \        }\n            }\n        }\n    }\n    return counts[0] == counts[1]\
    \ && counts[0] == counts[2];\n}\n</code>\n<|/ a tags=c#,math,arrays,algorithm\
    \ |>\n<| a tags=c#,math,arrays,algorithm dscore=0 |>\nI know it's been awhile\
    \ but this could help someone else looking for an easier way to accomplish this\
    \ in C#.\n<code>\npublic static bool TripleSumZero(int[] ints)\n{\n    int[] counts\
    \ = new int[3];\n    foreach (int x in ints)\n    {\n        ints.Remove(x);\n\
    \        foreach (int i in ints)\n        {\n            ints.Remove(i);\n   \
    \         foreach (int j in ints)\n            {\n                ints.Remove(j);\n\
    \                if (x + i + j == 0)\n                {\n                    counts[0]++;\n\
    \                    counts[1]++;\n                    counts[2]++;\n        \
    \        }\n            }\n        }\n    }\n    return counts[0] == counts[1]\
    \ && counts[0] == counts[2];\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n\
    public class Solution\n    {\n        public static bool TripleSumZero(int[] ints)\n\
    \        {\n            HashSet<int> set = new HashSet<int>();\n            foreach\
    \ (int x in ints)\n            {\n                foreach (int i in ints)\n  \
    \              {\n                    foreach (int j in ints)\n              \
    \      {\n                        if (x+i+j==0)\n                        {\n \
    \                           set.Add(x);\n                            set.Add(i);",
  "{\n    int len = (int) l.Length;\n    int sum = 0;\n    int index = 0;\n    bool\
    \ found = false;", "{\n    long l0, l1, l2;\n    long sum = 0;", "{\n\tif (l.length\
    \ <= 3) return false;\n\tlong sum = 0;\n\tfor (int i = 0; i < l.length; ++i) \n\
    \t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\tsum += l[i];\n\t\t}\n\t}\n\treturn (sum\
    \ == 0);\n}", "{\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    int i\
    \ = 0;\n    for (i = 0; i < l.length; i++) {\n        if (x == 0) \n         \
    \   x = l[i];\n        if (x == l[i])\n            y++;\n        if (x == l[i]\
    \ + l[i])\n            z++;\n    }\n    if (y == 3) && (z == 0)\n        return\
    \ true;\n    return false;\n}\n\"\"\"\n    \n    def triples_sum_to_zero(self,\
    \ l):\n        return self.ccall('triples_sum_to_zero', \n            'bool',\
    \ ['long', '[c_long]'], l).cast(self.ctx.ptr_type(1))", "{\n\tint i;\n\tfor(i\
    \ = 0; i < l.length; i++){\n\t\tif (l[i] == 0 || l[i] == l[i+1] || l[i] == l[i+2])\n\
    \t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "{\n    int nElements\
    \ = 3;\n    long sum = 0;\n    bool bSumtoZero = false;\n    for (int i=0; i <\
    \ nElements; ++i)\n    {\n        sum += l[i];\n        if (sum == 0) \n     \
    \   {\n            bSumtoZero = true;\n            break;\n        }\n    }\n\
    \    return bSumtoZero;\n}", "{\n    for(long i=0;i<3;i++)\n        if(l[i] +\
    \ l[i+1] + l[i+2] != 0)\n            return false;\n    return true;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nI think you can also do `bool triples_sum_to_zero(long[] l)\
    \ { return l != null && l.Distinct().Count() == 3 && l.Select(x => x+x).ToArray().Sum()\
    \ == 0; }`\n<|/ c |>\n<| c |>\nYou don't need the `!= null` part, but then it's\
    \ not really an extension method anymore.\n<|/ c |>\n<| c |>\nI think it's worth\
    \ noting that this is O(n^2), but it's still very fast for small inputs.\n<|/\
    \ c |>\n<| a dscore=4 |>\n<code>", "{\n    int count = 0;\n    \n    for (int\
    \ i = 0; i < l.length; i++)\n    {\n        if (l[i] == 0)\n        {\n      \
    \      count++;\n        }\n        else if (l[i] == l[i-1] + l[i-2])\n      \
    \  {\n            count++;\n            if (count > 2)\n            {\n      \
    \          return true;\n            }\n        }\n    }\n    return false;\n}",
  "{\n    int i, j, k;\n    // find smallest element\n    long smallest = l[0];\n\
    \    for (i = 1; i < l.length; i++) {\n        if (l[i] < smallest) {\n      \
    \      smallest = l[i];\n        }\n    }\n    // find middle element\n    long\
    \ middle = l[l.length / 2];\n    long sum = 0;\n    for (i = 1; i < l.length;\
    \ i++) {\n        if (l[i] == middle) {\n            sum = sum + middle; // add\
    \ middle element\n        }\n    }\n    // find largest element\n    for (k =\
    \ l.length; k > 0; k--) {\n        middle = l[k / 2];\n        sum = 0;\n    \
    \    for (i = k - 1; i >= 0; i--) {\n            if (l[i] == middle) {\n     \
    \           sum = sum + middle; // add middle element\n            }\n       \
    \ }\n        if (sum == 0)\n            return true;\n    }\n    return false;\n\
    }\n</code>\n<|/ a tags=c#,c++ |>\n<| c |>\nIt's not the best solution (it would\
    \ be much simpler if you just sum the array, and then compare). But thanks for\
    \ sharing.\n<|/ c |>\n<| c |>\nIt is the simplest solution that I found and works\
    \ fine for my test cases.\n<|/ c |>\n<| a tags=c#,c++ |>\nIf this question is\
    \ still interesting for you, here is a solution in c++:\n<code>", "{\n    long\
    \ d1, d2, d3;\n    bool has_triple = false;\n    bool has_sum_of_two = false;\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] == 0)\n       \
    \ {\n            if(!has_sum_of_two)\n            {\n                has_sum_of_two\
    \ = true;\n                d2 = i;\n            }\n            if(!has_triple)\n\
    \            {\n                has_triple = true;\n                d3 = i;\n\
    \            }\n        }\n        else if(l[i] > 0)\n        {\n            if(d3\
    \ > 0)\n            {\n                if(l[d3] + l[d2] + l[i] == 0)\n       \
    \         {\n                    has_sum_of_two = false;\n                   \
    \ d3 = d2;\n                }\n            }\n            d2 = i;\n        }\n\
    \    }\n    return has_triple && has_sum_of_two;\n}", "{\n    if (l.length<3){\n\
    \        return false;\n    }\n    \n    long long sum=0;\n    for(int i=0;i<l.length-1;++i){\n\
    \        sum+=l[i];\n    }\n    if (sum<=0){\n        return false;\n    }\n \
    \   \n    for(int i=0;i<l.length-1;++i){\n        if (l[i]+l[i+1]+l[i+2]==0){\n\
    \            return true;\n        }\n    }\n    \n    return false;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=java,c#,arrays |>\nIn Python, the following solution:\n\
    <code>\ndef tripleSumsZero(arr):\n    return len(set(map(sum, arr))) == 3\n</code>\n\
    For larger lists, this may be an important speed-up on some implementations.\n\
    This solution works because in Python sets are unordered collections of unique\
    \ items.  Since sum is commutative, the same elements will appear in the same\
    \ order in each set.  Hence the list can be constructed from just those unique\
    \ elements.\nThis can be seen as a generalization of the solution by Thomas Wouters\
    \ which only needs to consider three elements.  But I personally find the solution\
    \ by Thomas Wouters's more readable and thus I often prefer that approach.\n<|/\
    \ a dscore=0 |>\n<| a |>\n<code>\n public static boolean tripleSumToZero(long[]\
    \ arr){\n        long sum=0;\n        for(long i : arr){\n            sum+=i;\n\
    \        }\n        return (sum==0);\n    }\n</code>\n<|/ a dscore=0 tags=java,c#,arrays\
    \ |>\n<| c |>\nPlease add a description to your answer.\n<|/ c |>\n<| c |>\nWhile\
    \ this code may solve the question, [including an explanation](//meta.stackexchange.com/q/114762)\
    \ of how and why this solves the problem would really help to improve the quality\
    \ of your post, and probably result in more up-votes. Remember that you are answering\
    \ the question for readers in the future, not just the person asking now. Please\
    \ [edit] your answer to add explanations and give an indication of what limitations\
    \ and assumptions apply.\n<|/ c |>\n<| a |>\n<code>\npublic static boolean triple_sum_to_zero(long[]\
    \ a) {\n   for (int i = 0; i < a.length - 1; i++) {\n      long sum = 0;\n   \
    \   for (int j = i; j < a.length; j++) {\n         sum += a[j];\n      }\n   \
    \   if (sum == 0) {\n         return true;\n      }\n   }\n   return false;\n\
    }\n</code>\n<|/ a tags=java,", "{\n    if( l.length==0 ) return true;\n    long\
    \ long sum = 0;\n    for(int i=0; i<l.length; ++i)\n    {\n        if( l[i]>0\
    \ ) sum += l[i];\n        if( sum==3 ) \n            return true;\n        sum\
    \ -= l[i];\n    }\n    return false;\n}\n</code>\n<|/ a tags=c++,algorithm |>\n\
    <| a tags=c++,algorithm |>\nThis is a classic task for Dynamic Programming. \n\
    <code>", "{\n    int n = (int)l.length;", "{\n    int a = 0, b = 0; // a and b\
    \ are the indexes of the elements that make up an array that sums to zero\n  \
    \  for (int i = 0; i < l.length; ++i)\n    {\n        if (l[i] == 0)\n       \
    \ {\n            // if this element sums to zero, set the index to the current\
    \ index\n            if (a != i)\n                a = i;\n            \n     \
    \       // if this element also sums to zero, set the index to the current index\n\
    \            if (b != i)\n                b = i;\n        }\n    }", "{\n\tlong[]\
    \ h=new long[3];\n\tfor (int i=0;i<3;++i)\n\t\th[i]=0;\n\tfor (int i=0;i<l.length;++i)\
    \ {\n\t\tfor (int j=0;j<3;++j) {\n\t\t\th[j]+=l[i];\n\t\t\tif (h[j]==0)\n\t\t\t\
    \treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n/*", "{\n    if (l.length < 3)\n\
    \        return false;\n    \n    long sum = 0;\n    long curr = l[0];\n    int\
    \ count = 1;\n    \n    for (int i = 1; i < l.length; i++) \n    {\n        curr\
    \ = curr + l[i];\n        if (curr == 0) \n        {\n            count++;\n \
    \           if (count == 3)\n                return true;\n        }\n    }\n\
    \    return false;\n}", "{\n    int N=l.length;\n    int sum=0;\n    \n    for(int\
    \ i=0;i<N;i++)\n    {\n        if(l[i]>0)\n        {\n            sum+=l[i];\n\
    \        }\n    }\n    if(sum<0)\n        return false;\n    \n    for(int i=0;i<N;i++)\n\
    \    {\n        if(l[i]>0)\n        {\n            int diff=l[i]-sum;\n      \
    \      if(diff!=l[i] && diff!=l[i]-sum)\n                return false;\n     \
    \   }\n    }\n    return true;\n}", "{\n    long t0, t1, t2;\n    t0 = l[0];\n\
    \    t1 = l[1];\n    t2 = l[2];\n    return (t0 + t1 + t2) ==0;\n}", "{\n    if\
    \ (l.length < 3) return true;\n    if (l[0] + l[1] + l[2] == 0) return true;\n\
    \    return triples_sum_to_zero(l);\n}", "{\n    int n = l.length;\n    if (n\
    \ < 3) return false;\n    sort(l);\n    long mid = l[n/3];\n    int i= 0;\n  \
    \  for (int j=0; j < n; j++)\n    {\n        if (l[j] + l[n-1-j] + mid == 0)\n\
    \            return true;\n        if (l[j] < mid)\n        {\n            while\
    \ (j+1 < n && l[j+1] < mid)\n                j++;\n            if (j+1 < n &&\
    \ l[j] == mid)\n            {\n                i = j;\n                break;\n\
    \            }\n        }\n    }\n    return false;\n}\n</code>\n<|/ a dscore=2\
    \ tags=c++,algorithm |>\n<| a tags=c++,algorithm |>\nJust to show a proposition\
    \ I made. I wrote this program to show a very simple approach to this.\nI used\
    \ the algorithm to find triple numbers between two given integers.\nI tested the\
    \ program using various inputs and it works fine.\n<code>\n#include <iostream>\n\
    #include <algorithm>\nusing namespace std;", "{\n    int sum = 0;\n    for (int\
    \ i = 0; i < l.length; i++) \n    {\n        sum += l[i];\n        if (sum > 0)\n\
    \        {\n            return false;\n        }\n    }\n    return true;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\n// Triples Sum To Zero\n\
    #include<stdio.h>", "{\n\tlong long int s = 0, t = 0;\n\tfor(int i = 0; i < l.length;\
    \ i++){\n\t\ts += l[i];\n\t}\n\t\n\tfor(int i = 0; i < l.length; i++){\n\t\tt\
    \ += l[i];\n\t}\n\t\n\treturn (s == t);\n}", "{\n    long a = l[0];\n    long\
    \ b = l[1];\n    long c = l[2];\n    long sum = 0;\n    long n = 0;\n    for(n\
    \ = 0; n < l.length; n++){\n        sum += l[n];\n        if (sum < 0) sum = 0;\
    \ \n        long tmp = a;\n        a = b;\n        b = c;\n        c = tmp;\n\
    \    }\n    if((a + b + c) == 0){\n        return true;\n    }else{\n        return\
    \ false;\n    }\n}", "{\n    long sum = 0;\n    for(int i = 0; i < l.length; i++){\n\
    \        sum += l[i];\n        if(sum == 0) return true;\n        if(sum > 0)\
    \ return false;\n    }\n    return false;\n}", "{\n    long sum = 0;\n    for\
    \ (long k : l)\n        sum += k;\n    bool flag = false;\n    for (long k : l)\n\
    \        if (k + k + k == sum) {\n            flag = true;\n            break;\n\
    \        }\n    return flag;\n}", "{\n    long sum = 0;\n    long max = l[0];\n\
    \    for (long i : l)\n    {\n        sum += i;\n        if (sum > max)\n    \
    \        max = sum;\n    }\n    return max > 0;\n}\n/*", "{\n  int i=0,j=0,k=0;\n\
    \  while(i<l.length){\n    if(l[i]==l[j]){\n      j++;\n      if(j==l.length){\n\
    \        return true;\n      }\n    }else if(l[i]+l[j]==0){\n      if(j==l.length){\n\
    \        return true;\n      }\n      k=1;\n      while(k<l.length&&l[k]==0){\n\
    \        k++;\n      }\n      if(k==l.length){\n        return true;\n      }\n\
    \    }else{\n      return false;\n    }\n    i++;\n  }\n  return false;\n}\n</code>\n\
    <|/ a tags=time-complexity,algorithm,c++ dscore=2 |>\n<| a tags=time-complexity,algorithm,c++\
    \ |>\nI know it has been a while but I am still answering this question. I recently\
    \ came across this problem and I found a solution which is very elegant, so I\
    \ am posting it. \n<code>\n/**\n * Given an array of integers arr[] of length\
    \ N, \n * which has elements arr[0], arr[1], ..., arr[N-1], \n * and an integer\
    \ S that is the sum of these elements, \n * find the number of triplets such that\n\
    \ * each triplet is of the form\n * arr[i] + arr[j] + arr[k]\n * where i \u2265\
    \ j and j\u2265 k \n * and S = 0\n * \n * Time complexity - O(N)\n * Space complexity\
    \ - O(1)\n */", "{\n    /*\n        this function takes an array of integers and\
    \ returns true if there are 3 distinct integers\n        in the array that sum\
    \ to zero, and false otherwise.", "{\n    int n = l.length();\n    \n    long[]\
    \ p = {0L};\n    int q = 0;\n    for(int i = 0; i < n; i++) {\n        p[q++]\
    \ = l[i];\n    }\n    for(int i = 0; i < n; i++) {\n        if(l[i] == 0L) {\n\
    \            while(p != null && p[q] == 0L) {\n                p--;\n        \
    \        q--;\n            }\n            if(q == -1 || p[q] == 0L) {\n      \
    \          return false;\n            }\n        }\n    }\n    return true;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>\n/*\n * A function that returns\
    \ true if there are three distinct elements in the array that sum to zero.\n */",
  "{\n    long long sum = 0;\n    long long max = l[0];\n    for (int i = 0; i < l.length;\
    \ i++)\n    {\n        sum += l[i];\n        if (max < sum)\n        {\n     \
    \       max = sum;\n        }\n    }\n    if (sum == 0)\n    {\n        return\
    \ true;\n    }\n    else\n    {\n        return false;\n    }\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nWhat if the input list is [1L, 3L, 5L, 0L], shouldn't\
    \ it return false since the list contains three zeroes that sum to zero i.e. 10L?\n\
    <|/ c |>\n<| c |>\nIt would return true, since it contains three distinct integers\
    \ that sum to zero.\n<|/ c |>\n<| c |>\nI believe this returns false for all lists\
    \ except for the one you provided because you are iterating through the entire\
    \ list and then returning the first sum == 0. Hence I believe the list you provided\
    \ is a special case. I believe it should return true for [1L, 2L, 3L, 7L]\n<|/\
    \ c |>\n<| a |>\nThe algorithm you are looking for is called \"Counting Spikes\
    \ in an Array\"", "{\n    return l.length == 3 && l[0] + l[1] + l[2] == 0;\n}",
  "{\n    int i = 0;\n    long sum = 0;\n    long sum2 = 0; \n    bool ok = true;",
  "{\n    long long total = 0;\n    long long count = 0;", "{\n    int a = l[0];\n\
    \    int b = l[1];\n    int c = l[2];\n    long d = a+b+c;\n    long e = (int)d;\n\
    \    int f = e;\n    if (d==0)\n        return false;\n    if (e==0)\n       \
    \ return true;\n    if (e<0)\n        f = -f;\n    d = e+b;\n    e = d+c;\n  \
    \  if (e<0)\n        e = -e;\n    long g = e+a;\n    if (g<0)\n        g = -g;\n\
    \    if (g!=f) {\n        std.typecons.int gint = (std.typecons.int)g;\n     \
    \   std.typecons.int fint = (std.typecons.int)f;\n        if (gint>fint)\n   \
    \         return false;\n        if (gint<fint)\n            return true;\n  \
    \  } else {\n        if (std.math.abs(e)==std.math.abs(a))\n            return\
    \ false;\n        else\n            return true;\n    }\n}", "{\n    if(l.length\
    \ < 3)\n        return false;\n    int first_nonzero_index = 0;\n    for(int i\
    \ = 1; i < l.length; ++i)\n    {\n        if(l[i] + l[first_nonzero_index] + l[first_nonzero_index+1]\
    \ == 0)\n        {\n            ++first_nonzero_index;\n        }\n        else\n\
    \            break;\n    }\n    return first_nonzero_index == 0;\n}\n</code>\n\
    <|/ a tags=c#,algorithm,arrays |>\n<| c |>\nAwesome solution, even though this\
    \ is in C++, not C#.\n<|/ c |>\n<| a dscore=1 |>\nIf you can assume that your\
    \ list contains positive integers, you could use the modulo (%) operator:\n<code>",
  "{\n    int k = (int) l[0];\n    for (int i = 1; i < l.length; i++) {\n        k\
    \ = (k * (int) l[i]) % (m * n);\n    }\n    if (k == 0)\n        return true;\n\
    \    else\n        return false;\n}\n</code>\n<|/ a tags=c++,performance,sieve-of-eratosthenes,algorithm,primes\
    \ dscore=2 |>\n<| a tags=c++,performance,sieve-of-eratosthenes,algorithm,primes\
    \ |>\nThe answer is no.\nWhen you perform the division to check for sieving, you\
    \ end up with something like\n<code>\nif (l[i] % 2 == 0) \n{ \n    l[i] /= 2;\n\
    \    continue;\n}\n</code>\nIn order for the first division to work, you must\
    \ know the value of l[i]. But since you did not initialize it, it could be anything.\
    \ So you need to check whether l[i] is even first. Of course, this requires that\
    \ l[i] be at least 2. So this requires performing the division at least once.\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\nWell, actually you are asking about how to\
    \ write efficient prime-number generator in C++. \nIt's not a difficult problem\
    \ to solve. Here is a simple implementation. \n<code>\n#include <iostream>\n#include\
    \ <vector>", "{\n    int i, sum = 0;\n    for (i = 0; i < l.length; i++)\n   \
    \ {\n        sum += l[i];\n        if (sum < 0)\n            sum = 0;\n      \
    \  if (sum > 0)\n            return false;\n    }\n    return true;\n}\n</code>\n\
    And here is the recursive version.\n<code>", "{\n    int n = l.length;\n    int\
    \ sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += l[i];\n        if\
    \ (sum < 0) {\n            return false;\n        }\n    }\n    if (n == 3 &&\
    \ sum == 0) {\n        return true;\n    }\n    return false;\n}\n</code>\n<|/\
    \ a tags=language-agnostic,arrays,algorithm |>\n<| c |>\nThis solution will fail\
    \ for the input [-1, -1, -1, -1]. I am not saying it is the right answer, just\
    \ saying it is a solution.\n<|/ c |>\n<| a dscore=2 |>\nYou can use a hash set\
    \ or another data structure to keep track of your array elements. A hash set will\
    \ let you quickly find which elements are the same. Once you find 3 elements,\
    \ return true.\nThis has O(n) time complexity. \n<code>", "{\n    int n = l.length;",
  "{\n    int sum = 0;\n    for(int i =0; i < l.length; i++){\n        sum += l[i];\n\
    \    }\n    \n    for(int i = 0; i < l.length; i++){\n        int a = l[i];\n\
    \        for(int j = i+1; j < l.length; j++){\n            int b = l[j];\n   \
    \         for(int k = j+1; k < l.length; k++){\n                int c = l[k];\n\
    \                if(a + b + c <= 0){\n                    return false;\n    \
    \            }\n            }\n        }\n    }\n    \n    return true;\n}", "{\n\
    \  int sum = 0;\n  foreach (long i in l)\n  {\n    sum += i;\n  }\n  return (l[0]\
    \ == 0) && (l[1] == 0) && (l[2] == 0);\n}", "{\n    if(l[0] == 0L)\n        return\
    \ true;\n    \n    if(l[0] == 1L)\n        return triples_sum_to_zero(l);\n  \
    \  \n    long sum = 0;\n    for(auto x: l)\n    {\n        if(x < 0L)\n      \
    \      sum += x;\n        else if(sum > 0L)\n            sum += x;\n        else\n\
    \            return false;\n    }\n    return true;\n}\n\"\"\"", "{\n    int i=0,\n\
    \        j=0,\n        sum1=0,\n        sum2=0;\n    for(int k=0;k<l.length;k++)\n\
    \    {\n        if(l[k] == 0)\n            sum1 += l[i];\n        if(l[k] == 0)\n\
    \            sum2 += l[i];\n        i++;\n        \n    }\n    return sum1+sum2\
    \ == 0;\n}\n/*", "{\n    int sum = 0;\n    for (int i = 0; i < l.Length; ++i)\n\
    \    {\n        sum += l[i];\n        if (sum == 0)\n        {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nthis solution is not fast enough.\n<|/ c |>\n<| c |>\nThat's true but\
    \ I guess the OP is looking for a solution that only works for relatively small\
    \ arrays.\n<|/ c |>\n<| a dscore=0 tags=c#,arrays |>\nI solved a similar question\
    \ using the following approach of checking if the sum of the digits is zero:\n\
    <code>\nprivate static bool IsSumZero(int[] arr)\n{\n    int sum = 0;", "{\n \
    \   long long int num = 0;\n    int i = 0;\n    int j = 0;\n    long long int\
    \ sum = 0;\n    long long int sum2 = 0;\n    int count = 0;\n    int count2 =\
    \ 0;\n    bool ret = false;\n    bool ret2 = false;\n    bool ret3 = false;\n\
    \    int count = 0;\n    int count2 = 0;\n    bool ret = false;\n    bool ret2\
    \ = false;\n    bool ret3 = false;\n    int i = 0;\n    int j = 0;\n    int k\
    \ = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int m = 0;\n    int\
    \ n = 0;\n    bool flag = false;\n    int count = 0;\n    for(i=0;i<l.length;i++)\n\
    \    {\n        sum = 0;\n        for(j=0;j<i;j++)\n        {\n            sum\
    \ += l[j];\n        }\n        if(sum == 0)\n        {\n            count++;\n\
    \            sum2 = 0;\n            for(j=0;j<i;j++)\n            {\n        \
    \        sum2 += l[j];\n            }\n            if(sum2 == 0)\n           \
    \ {\n                count++;\n                flag = true;\n            }\n \
    \           else\n            {\n                count++;\n            }\n   \
    \     }\n        if(count == 3)\n        {\n            ret = true;\n        \
    \    break;\n        }\n    }\n    if(!ret)\n    {\n        return false;\n  \
    \  }\n    else\n    {\n        flag = false;\n        for(i=0;i<l.length;i++)\n\
    \        {\n            sum = 0;\n            for(j=0;j<i;j++)\n            {\n\
    \                sum += l[j];\n            }\n            if(sum == 0)\n     \
    \       {\n                count++;\n                sum2 = 0;\n             \
    \   for(j=0;j<i;j++)\n                {\n                    sum2 += l[j];\n \
    \               }\n                if(sum2 == 0)\n                {\n        \
    \            count++;\n                    flag = true;\n                }\n \
    \               else\n                {\n                    count++;\n      \
    \          }\n            }\n            if(count == 3)\n            {\n     \
    \           ret2 = true;\n                break;\n            }\n        }\n \
    \       if(!ret2)\n        {\n            return false;\n        }\n        else\n\
    \        {\n            flag = false;\n            for(i=0;i<l.length;i++)\n \
    \           {\n                sum = 0;\n                for(j=0;j<i;j++)\n  \
    \              {\n                    sum += l[j];\n                }\n      \
    \          if(sum == 0)\n                {\n                    count++;\n   \
    \                 sum2 = 0;\n                    for(j=0;j<i;j++)\n          \
    \          {\n                        sum2 += l[j];\n                    }\n \
    \                   if(sum2 == 0)\n                    {\n                   \
    \     count++;\n                        flag = true;\n                    }\n\
    \                    else\n                    {\n                        count++;\n\
    \                    }\n                }\n                if(count == 3)\n  \
    \              {\n                    ret3 = true;\n                    break;\n\
    \                }\n            }\n            if(!ret3)\n            {", "{\n\
    \    int len = l.Length;\n    int[] count = new int[3];\n    \n    for(int i =\
    \ 0; i < len; ++i)\n    {\n        int curr = l[i];\n        \n        // if current\
    \ value is the same as last value\n        if(curr == l[i - 1])\n        {\n \
    \           count[0]++;\n        }\n        \n        // if current value is smaller\
    \ than last value\n        else\n        {\n            int prev_count = count[0];\n\
    \            int current_count = count[1];\n            \n            // if previous\
    \ element is a different element\n            if(prev_count != 0)\n          \
    \  {\n                // if current element is a different element\n         \
    \       if(count[0] != 0)\n                {\n                    // if current\
    \ element is the same as last element\n                    if(curr != l[i - 1])\n\
    \                    {\n                        count[1]++;\n                \
    \    }\n                }\n                else\n                {\n         \
    \           count[0]++;\n                }\n            }\n            else\n\
    \            {\n                if(count[0] != 0)\n                {\n       \
    \             count[1]++;\n                }\n                else\n         \
    \       {\n                    count[0]++;\n                }\n            }\n\
    \        }\n    }\n    \n    bool hasTriple = false;\n    if(count[0] != 0)\n\
    \    {\n        hasTriple = true;\n    }\n    \n    return hasTriple;\n}\n</code>\n\
    <|/ a tags=algorithm,c#,time-complexity |>\n<| c |>\nYour code doesn't work correctly\
    \ for `int[]` as `curr <= l[i - 1]`, therefore it always returns false.\n<|/ c\
    \ |>\n<| c |>\nThanks for pointing out my mistake. It should be `curr >= l[i -\
    \ 1]`.\n<|/ c |>\n<| a dscore=2 |>\nI believe that this is in O(n).", "{\n   \
    \ return std.typecons.all(function\n        {\n            if(l[i] == 0L && l[i\
    \ + 1] == 0L && l[i + 2] == 0L)\n            {\n                i = i + 3;\n \
    \               return true;\n            }\n            else\n            {\n\
    \                return false;\n            }\n        });\n}\n/*", "{\n    for\
    \ (int i = 0; i < l.length; ++i)\n        if (l[i] * l[i] * l[i] != 0)\n     \
    \       return false;\n    return true;\n}", "{\n    bool b = false;\n    int\
    \ c = 0;\n    for (int i = 0; i < l.length; i++) {\n        c = 0;\n        while\
    \ (c < 3) {\n            if (l[i] == 0) {\n                b = true;\n       \
    \         break;\n            } else {\n                c = c + 1;\n         \
    \   }\n        }\n    }\n    return b;\n}\n</code>\n<|/ a tags=c#,algorithm,math\
    \ |>\n<| c |>\nOh nice! I like this answer! I always forget about bitwise operators.\
    \ Thank you for showing me how to do it.\n<|/ c |>\n<| a |>\nYou can get an O(n)\
    \ solution in O(1) space using bitwise operations (assuming you cannot change\
    \ the input).\n<code>\npublic bool IsTripleSumToZero(long[] list)\n{\n    int\
    \ sum = 0;\n    long temp = 0;\n    foreach (long item in list)\n    {\n     \
    \   temp = item;\n        if (temp > 0)\n        {\n            while (temp >\
    \ 0)\n            {\n                temp = temp >> 1;\n                sum +=\
    \ temp;\n            }\n        }\n        else\n        {\n            sum =\
    \ -sum;\n        }\n        if (sum == 0)\n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\n</code>\n<|/ a dscore=1 tags=c#,algorithm,math\
    \ |>\n<| a |>\nUsing a bit array\n<code>", "{\n    int a = 0;\n    int b = 0;\n\
    \    int c = 0;\n    int d = 0;\n    for(int i = 0; i < l.length; i ++){\n   \
    \     a += l[i];\n        b += i;\n        c += l[i];\n        d += l[i];\n  \
    \  }\n    return (a % 3 == 0) && (b % 3 == 0) && (c % 3 == 0) && (d % 3 == 0);\n\
    }", "{\n    int zeroSum = 0, otherSum = 0, totalSum = 0;", "{\n    int i,j,k,p,t;\n\
    \    for(i=0;i<l.length;i++){\n        for(j=i+1;j<l.length;j++){\n          \
    \  for(k=j+1;k<l.length;k++){\n                if(l[i] + l[j] + l[k] == 0){\n\
    \                    p = i;\n                    t = j;\n                    while(p<j){\n\
    \                        t++;\n                        if(t==k) t++;\n       \
    \                 if(l[p] + l[t] == 0){\n                            p++;\n  \
    \                          t++;\n                        }\n                 \
    \       else break;\n                    }\n                    if(t>k) break;\n\
    \                    return true;\n                }\n            }\n        }\n\
    \    }\n    return false;\n}", "{\n    int  i = 0;\n    int  j = 0;\n    int \
    \ k = 0;\n    int  n = 0;\n    long total = 0;\n    \n    for (i = 0; i < l[i]\
    \ && j < l[i] && k < 3; i++, j++, k++) {\n        n = l[i] - (j - k);\n      \
    \  total = total + n;\n        if (total > 0)\n            return true;\n    }\n\
    \    \n    return false;\n}", "{\n\tint[] a = new int[3];\n\tfor (int i = 0; i\
    \ < 3; i++)\n\t\ta[i] = 0;\n\tbool ret = false;\n\tfor (int i = 0; i < 3; i++)\n\
    \t{\n\t\tint c = 0;\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tif (l[j] > 0) \n\t\
    \t\t{\n\t\t\t\tc++;\n\t\t\t\tif (c == 3) {\n\t\t\t\t\ta[i] = l[j];\n\t\t\t\t\t\
    ret = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn ret;\n}", "{\n\
    \    long sum = 0;\n    for(int i=0; i < l.length; i++){\n        if(l[i] > 0)\n\
    \            sum += l[i];\n    }\n    return (sum % 3 == 0L);\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=2 tags=c++,algorithm,arrays |>\nThe idea is as follows - the\
    \ array is the set of all pairs of elements whose sum is zero. So if we want to\
    \ find three elements whose sum is zero, we need to find the subset of elements\
    \ that add to zero, e.g.\n<code>\na = {1, 2, 3, -3, -5, 6}\na[0] + a[1] + a[2]\
    \ = 6\na[0] < 0     a[1] < 0     a[2] < 0\na[0] + a[1] > 0     a[2] + a[2] > 0\n\
    </code>\nSo we can find the two elements that add to zero by considering only\
    \ the positive numbers and by finding the two positive numbers that sum to zero.\
    \ \nNow consider the set of pairs {(-3, 6), (-2, 5), (0, 1)} where the first element\
    \ is the pair of positive numbers that add to zero, and the last element is the\
    \ pair of negative numbers that add to zero.\n<code>\n{(-3, 6), (-2, 5), (0, 1)}\n\
    {(-2, 5), (0, 1)}\n{(0, 1), (-2, 5)}\n</code>\nFrom the set of pairs {(-2, 5),\
    \ (0, 1)}, we can deduce that they are the two numbers that sum to zero. \n<code>\n\
    (-2, 5) + 0 = 0\n</code>\nSo the pair (-3, 6) can be eliminated from the set.\n\
    <code>\n{(-3, 6), (-2, 5), (0, 1)}\n{(0, 1), (-2, 5)}\n{(-2, 5)}\n</code>\nAnd\
    \ if we want to find three such pairs, we will have three such sets. So the final\
    \ set is {(-1, -1), (4, 1), (-3, 6)}.\n<|/ a |>\n<| c |>\nI like this idea, but\
    \ the pairs ((-1, -1), (-3, 6)) need to be in the final set as well, no?\n<|/\
    \ c |>\n<| c |>\nThanks - I have fixed the answer to include these additional\
    \ sets.\n<|/ c |>\n<| a dscore=2 |>\nThe best way to handle this is to find all\
    \ combinations of three numbers that add up to zero in O(n choose 3) time, then\
    \ sort them in O(n log n) time.\nThe algorithm works like this:", "{\n    int\
    \ n = l.length;\n    if (n == 0) {\n        return false;\n    }\n    // create\
    \ an array with n*(n+1)/2\n    // and two elements to store count of zeros\n \
    \   // and count of non-zeros\n    int[] zeros = new int[n*(n+1)/2];\n    int[]\
    \ non_zeros = new int[n*(n+1)/2];", "{\n    sort(l, less);", "{\n    long sum\
    \ = 0;\n    for(int i =0; i < l.length; i++)\n    {\n        sum += l[i];\n  \
    \      if(sum > 0)\n            return true;\n    }\n    return false;\n}\n/*",
  "{\n    int i = 0;\n    int j = l.length;\n    while (j > 0) \n    {\n        if\
    \ (l[j] == 0) {\n            return false;\n        } else if (l[j] < 0) {\n \
    \           j--;\n        } else {\n            i += 1;\n            j -= 1;\n\
    \        }\n    }\n    return i == 3;\n}\n</code>\n<|/ a tags=c,java,performance\
    \ |>\n<| c |>\nThis is not correct. Your algorithm won't work correctly on an\
    \ array of [1L](http://ideone.com/xU6KI0).\n<|/ c |>\n<| c |>\n- Ah! You are correct,\
    \ I have edited my code to fix that.  Thank you!\n<|/ c |>\n<| c |>\n: This algorithm\
    \ works, but it has a complexity of O(n\xB2), which is not very good for large\
    \ arrays. For small arrays, it might be just fine, though.\n<|/ c |>\n<| a dscore=0\
    \ |>\nI know it's late, but I thought I'd share my solution to this.\n<code>\n\
    public class TripletSumToZero {", "{\n    if (l.length < 3)\n        return false;",
  "{\n    int c = 0;\n    int sum = 0;\n    for(int i = 0; i < l.length; ++i)\n  \
    \  {\n        sum += l[i];\n        c = (c > sum) ? c : 0;\n    }", "{\n    int\
    \ cnt = 0;\n    for (int i=0; i < l.length-1; i++) {\n        if (l[i] > 0) \n\
    \            cnt ++;\n    }\n    return cnt == 3;\n}", "{\n    long long sum;\n\
    \    long long three_count = 0;\n    for (long i : l)\n    {\n        sum += i;\n\
    \        if (sum == 0)\n        {\n            if (three_count < 3)\n        \
    \    {\n                three_count++;\n            }\n        }\n        else\n\
    \        {\n            if (three_count == 3)\n            {\n               \
    \ return true;\n            }\n            three_count = 0;\n        }\n    }\n\
    \    return false;\n}", "{\n    long long int sum = 0;\n    for(long i: l)\n \
    \       sum += i;\n    \n    if (sum > 0)\n    {\n        if (l.length == 3 &&\
    \ sum == 0)\n        {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you. I think I finally understand\
    \ the idea of summing up all the numbers and then checking if all three, at most,\
    \ sum to zero. But I can't get it to work. I edited my post to show what I tried\
    \ and what happened. Any ideas?\n<|/ c |>\n<| c |>\nYou have to return `false`\
    \ for the length of the array to be smaller than 3 as well, otherwise you return\
    \ `false` even if the array has only two distinct elements that sum to zero.\n\
    <|/ c |>\n<| c |>\nThank you. One last question, if you don't mind. Your answer\
    \ checks to see if all three numbers in each array sum to zero. It does not check\
    \ if the array contains three distinct numbers that sum to zero. It does check\
    \ if all three numbers sum to zero when the array is of length 2, but it returns\
    \ true even when the array has only two distinct numbers that sum to zero.\n<|/\
    \ c |>\n<| c |>\nNo, it does not. My answer checks all the elements in the array\
    \ and returns `false` in the event that the array has only two distinct elements\
    \ that sum to zero. The answer you accepted is just plain wrong.\n<|/ c |>\n<|\
    \ c |>\nOops, sorry. I was testing some cases. I accidentally hit submit while\
    \ I was editing the post. It did say 'return false' for the array having three\
    \ distinct numbers that sum to zero. My bad. I am really sorry.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nYour original approach is incorrect.\nIt returns true when the\
    \ array contains three distinct elements that sum to zero.\nSo for the array [2,\
    \ 5, -6] it would return true.\nBut for [1, -4, -3, 2, 1], it would return false\n\
    What you need is to check if there are (at least) two distinct elements that sum\
    \ to zero.\n<code>", "{\n    if (l.length<3) \n        return false;", "{\n  \
    \  return l.sum() == l.length && l.count() == 3;\n}", "{\n    if(l.Length < 3)\
    \ { return false; }\n    int sum = 0;\n    foreach (int i in l)\n    {\n     \
    \   if(i != 0) { sum += i; }\n    }\n    int n = 3 - l.Length;\n    if(n == 0)\
    \ { n = -1; }\n    if(sum < 0) { return false; }\n    if(n == -1) { n = -sum;\
    \ }\n    return (n == 0);\n}", "{\n    int iMax = l.length - 1;\n    int iMin\
    \ = 0;\n    long n1 = l[iMin];\n    long n2 = l[iMax];\n    long n3 = l[iMax +\
    \ 1];", "{\n\tlong sum = sum(l);\n\tif (sum < 0)\n\t\treturn false;\n\telse if\
    \ (sum > 0)\n\t{\n\t\tint n = l.Length;\n\t\tint i = n - 1;\n\t\twhile (i >= 0\
    \ && l[i] == l[i + n - 1])\n\t\t\ti--;\n\t\t\n\t\tif (i == -1)\n\t\t\treturn false;\n\
    \t\telse\n\t\t\treturn (l[i] + l[i + 1] == 0 && l[i] + l[i + 2] == 0);\n\t}\n\t\
    else\n\t\treturn true;\n}", "{\n    int j = 0;\n    for (long i = 0; i < l.length;\
    \ i++) \n    {\n        while (i + j < l.length && l[i + j] == l[i + j + 1])\n\
    \            ++j;\n        \n        if (i == 0 || i == l.length - 1 || j == 2\
    \ || j == l.length - 2)\n            return false;\n    }\n    return true;\n}",
  "{\n    int sum = 0;\n    int j = 0;\n    for(int i = 0; i < l.length; i++)\n  \
    \  {\n        while(j < 3)\n        {\n            sum += l[j];\n            j++;\n\
    \            if(sum >= 0) \n            {\n                break;\n          \
    \  }\n        }\n        if(sum == 0)\n        {\n            return true;\n \
    \       }\n        sum = 0;\n        j = 0;\n    }\n    return false;\n}\n</code>\n\
    <|/ a tags=c++,arrays |>\n<| c |>\nIf this code is given and you change it to\
    \ return true when `i == l.length-1`, it gives wrong result for some cases.\n\
    <|/ c |>\n<| c |>\nThe case `1L` is given as an example. But it is not a special\
    \ case and can be solved by simply adding `1L` to `l`. The code above does not\
    \ assume this case.\n<|/ c |>\n<| c |>\nYes, but what about `1L`? It is not in\
    \ the array, but in the code it works.\n<|/ c |>\n<| c |>\nIt is a special case.\
    \ The code above does not assume it to be true by itself. It only assumes that\
    \ there will be 3 distinct numbers whose sum will be zero.\n<|/ c |>\n<| a tags=c++,arrays\
    \ dscore=3 |>\nA recursive solution with linear space complexity (no extra memory\
    \ required):\n<code>\n#include <iostream>\n#include <utility>", "{\n    long sum\
    \ = 0;\n    for(int i : l){\n        sum += i;\n    }\n    for(int i = 0; i<l.length();\
    \ i++){\n        int x = l[i];\n        for(int j = i+1; j<l.length(); j++){\n\
    \            int y = l[j];\n            if(abs(x-y) == abs(sum)){\n          \
    \      if(abs(x-y) > sum){\n                    return false;\n              \
    \  }\n            }\n        }\n    }\n    return true;\n}\n// end code from http://www.geeksforgeeks.org/check-if-array-contains-the-same-elements-twice-each-time/",
  "{\n    size_t count = 0;\n    for (size_t i = 0; i < l.length; ++i)\n        if\
    \ (l[i] + l[i + 2] == 0)\n            ++count;\n    return count == 3;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nIt may be worth pointing out here that this is O(n)\
    \ time complexity. It also doesn't require any explicit data structures or algorithms.\
    \ It's just plain old C with plain old `int`s.\n<|/ c |>\n<| c |>\n, good point.\
    \ Since this algorithm is simple and straightforward, I didn't want to add a complex\
    \ data structure.\n<|/ c |>\n<| a tags=c++,algorithm |>\nThis is a very interesting\
    \ question. I am giving my solution with time complexity O(n+m) where n is the\
    \ number of elements and m is the number of edges. Let me explain.\nI am assuming\
    \ that you have an array that contain pairs (int a, int b). You can use binary\
    \ search to find the location of each pair.\nIn order to make it efficient, you\
    \ should keep an array of sorted pairs (a, a). To make it a little bit more interesting,\
    \ you can also keep an array of pairs that already visited.\nSo, first you find\
    \ the location of each pair, and then, by binary search, you can find which pairs\
    \ were already visited. After that you need to iterate over the sorted array of\
    \ pairs, to check which pairs are visited again. \nTo make it even more efficient,\
    \ you can use binary search on the array of the pairs visited to find where you\
    \ already visited.\n<|/ a dscore=0 |>\n<| c |>\n`a` and `b` are not necessarily\
    \ integers. And `std::binary_search` takes random access iterators.\n<|/ c |>\n\
    <| c |>\nActually, I just realized that `std::lower_bound` also uses `std::binary_search`.\n\
    <|/ c |>\n<| c |>\nHmm, how exactly do you get `O(n+m)` time? How do you find\
    \ which pairs have been visited?\n<|/ c |>\n<| c |>\n`lower_bound` uses `binary_search`,\
    \ which itself uses `std::lower_bound`, which itself uses `binary_search`.\n<|/\
    \ c |>\n<| c |>\nI suppose you mean `std::lower_bound` uses `std::binary_search`,\
    \ which itself uses `std::lower_bound`? Is that a typo? Because that's not how\
    \ I see it.\n<|/ c |>\n<| a tags=c++,algorithm |>\nHere's one way you can do this\
    \ in O(n) time complexity using an hash map to keep track of what pairs you've\
    \ seen before.\nThe idea is to ", "{\n    int a = 0, b = 0, c = 0, res = 0;\n\
    \    for (int i = 0; i < l.Length; i++)\n    {\n        if ((l[i] > 0) && (l[i]\
    \ < a))\n        {\n            a = l[i];\n        }\n        if ((l[i] > 0) &&\
    \ (l[i] < b))\n        {\n            b = l[i];\n        }\n        if ((l[i]\
    \ > 0) && (l[i] < c))\n        {\n            c = l[i];\n        }\n    }\n  \
    \  if (a == 0)\n    {\n        if ((b == 0) && (c == 0))\n        {\n        \
    \    res = 1;\n        }\n    }\n    if (b == 0)\n    {\n        if ((a == 0)\
    \ && (c == 0))\n        {\n            res = 1;\n        }\n    }\n    if (c ==\
    \ 0)\n    {\n        if ((a == 0) && (b == 0))\n        {\n            res = 1;\n\
    \        }\n    }\n    return res;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\npublic\
    \ class Solution {\n    public static void main(String[] args) {\n        int[]\
    \ a = {2, -2, 7, 4, -1};\n        System.out.println(tripleSumZero(a));\n    }",
  "{\n    long long sum = 0;\n    int i = 0;\n    while (i<l.length)\n    {\n    \
    \    sum += l[i];\n        if (sum == 0)\n        {\n            return true;\n\
    \        }\n        ++i;\n    }\n    return false;\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| a dscore=2 tags=algorithm,language-agnostic,complexity-theory,algorithm\
    \ |>\n<code>\n#include <iostream>\n#include <vector>", "{\n    int sum=0;\n  \
    \  for (int i=0;i<l.length;i++)\n    {\n        sum+=l[i];\n        if (sum%3==0)\n\
    \            return true;\n        sum-=l[i];\n    }\n    return false;\n}\n</code>\n\
    <|/ a tags=algorithm,math,dynamic-programming,c++ |>\n<| c |>\nThis answer is\
    \ the only one that provides the optimal answer for all cases. It is amazing that\
    \ it is so simple to come up with such a concise and simple solution.\n<|/ c |>\n\
    <| c |>\n: It's not because it's simple, it's because it's intuitive. `O(n^2)`\
    \ solutions are hard for computers to solve.\n<|/ c |>\n<| a tags=algorithm,math,dynamic-programming,c++\
    \ |>\nO(n) solution without any extra memory (besides what you're doing currently,\
    \ of course):\n<code>", "{\n\tif (l.length <= 3) \n\t\treturn false;\n\tlong sum=0;\n\
    \tfor (int i = 0; i < l.length; i++){\n\t\tsum += l[i];\n\t\tif (sum == 0){\n\t\
    \t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "{\n    long sum = 0;\n   \
    \ bool has_three = false;\n    for (long i = 0; i < l.length; ++i)\n        sum\
    \ += l[i];\n    if (sum != 0)\n        has_three = l.length <= 3;\n    for (long\
    \ i = 0; i < l.length; ++i)\n        sum += l[i];\n    if (sum != 0)\n       \
    \ has_three = l.length <= 3;\n    return has_three;\n}\n/*", "{\n    int n_zero=0;\n\
    \    int n_tri=0;\n    long sum=0;\n    for (int i = 0; i < l.length; i++)\n \
    \   {\n        sum+=l[i];\n        if (sum==0)\n        {\n            n_zero++;\n\
    \            if (n_zero==3)\n            {\n                n_tri++;\n       \
    \     }\n            sum=0;\n        }\n    }\n    return n_tri>0;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis code doesn't work. I've posted my own solution\
    \ which is working on all input I've tried so far.\n<|/ c |>\n<| a dscore=0 |>\n\
    This one is more efficient, because it doesn't calculate a triple (three distinct\
    \ values) but just checks if there are 3 zeros in the array. \n<code>", "{\n \
    \   //double sum;\n    int i;\n    long tSum = 0;\n    for(i = 0; i < l.length;\
    \ ++i)\n    {\n        tSum+= l[i];\n    }\n    \n    if(tSum == 0)\n    {\n \
    \       return true;\n    }\n    return false;\n}", "{\n    var first = 0;\n \
    \   var second = 0;\n    var third = 0;\n    foreach(l,i,in) \n    {\n       \
    \ first+=i; \n        if(first>0)\n        {\n            second+=i;\n       \
    \     third+=first;\n        }\n    }\n    return (second==0 && third==0);\n}\n\
    /*", "{\n    int sum = 0;\n    bool allZero = true;", "{\n    if (l.length < 3)\
    \ return false;\n    long zero = 0, sum = 0;\n    for (int i : l)\n        if\
    \ (i != 0) \n        {\n            sum += i;\n            if (sum == 0) \n  \
    \          {\n                zero = i;\n                break;\n            }\n\
    \        }\n    return sum == zero;\n}", "{\n    long a, b, c;\n    for (int i\
    \ = 0; i < l.length; ++i) {\n        a = l[i];\n        for (int j = i + 1; j\
    \ < l.length; ++j) {\n            b = l[j];\n            for (int k = j + 1; k\
    \ < l.length; ++k) {\n                c = l[k];\n                if ((a*a + b*b\
    \ + c*c) == 0) {\n                    return true;\n                }\n      \
    \      }\n        }\n    }\n    return false;\n}", "{\n    long s = 0;\n    for\
    \ (int i = 0; i < l.length; i++) {\n        if (l[i] == 0) return false;\n   \
    \     s += l[i];\n        if (s > 0) return false;\n    }\n    return true;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis is really slow, is there a way we can improve\
    \ on it ?\n<|/ c |>\n<| c |>\nHow slow is slow? The code runs in less than a second\
    \ on my computer, and I even have it run as fast as it can by compiling it to\
    \ a JIT function. What exactly are you trying to optimize?\n<|/ c |>\n<| c |>\n\
    I didn't say it's slow I said it's really slow.\n<|/ c |>\n<| c |>\nAnd what exactly\
    \ is slow? I tested this with long lists of 10 million elements, and it runs in\
    \ less than a second (even the JIT code is much faster than that).\n<|/ c |>\n\
    <| c |>\nI tested it on 10 million elements and it took 30 seconds for me. Still\
    \ it's really slow, it took more than 5 hours for me. Anyway thanks for your help.\n\
    <|/ c |>\n<| a |>\nHere is my solution:\n<code>\nimport java.util.HashMap;\nimport\
    \ java.util.List;\nimport java.util.Map;", "{\n    var total1 = 0, total2 = 0,\
    \ total3 = 0;\n    var n = l.length;\n    \n    for(int i = 0; i < n; ++i) {\n\
    \        if (l[i] < 0) {\n            if (total1 < 0)\n                total1\
    \ = -l[i];\n            else {\n                if (total2 < 0)\n            \
    \        total2 = -l[i];\n                else {\n                    if (total3\
    \ < 0)\n                        total3 = -l[i];\n                    else {\n\
    \                        return false;\n                    }\n              \
    \  }\n            }\n        }\n        else {\n            if (total1 < 0)\n\
    \                total1 += l[i];\n            else {\n                if (total2\
    \ < 0)\n                    total2 += l[i];\n                else {\n        \
    \            if (total3 < 0)\n                        total3 += l[i];\n      \
    \              else {\n                        return false;\n               \
    \     }\n                }\n            }\n        }\n    }\n    \n    if (total1\
    \ > 0 && total2 > 0 && total3 > 0)\n        return true;\n    else \n        return\
    \ false;\n}\n</code>\n<|/ a dscore=0 tags=c#,algorithm |>\n<| c |>\nThe last two\
    \ if-statements don't look right. I think you meant `if(total1 +total2 +total3\
    \ > 0)`\n<|/ c |>\n<| c |>\nIt may be, but in all cases, it will return `true`\
    \ since the first three numbers are all positive\n<|/ c |>\n<| c |>\nBut what\
    \ if there are four distinct elements in the array that sum to zero? I guess my\
    \ code will return `true` in this case.\n<|/ c |>\n<| c |>\nYes, I agree. Maybe\
    \ I didn't understand your question completely. My answer was just to help OP\
    \ with the most efficient solution\n<|/ c |>\n<| a dscore=0 |>\nThe answer to\
    \ this problem is\n<code>\n public bool IsTripletSumToZero(long[] arr) \n    {\n\
    \        bool ret = false;\n        \n        long sum = 0;\n        for (int\
    \ i = 0; i < arr.Length; i++) {\n            sum += arr[i];\n            if (sum\
    \ == 0) {\n                ret = true;\n                break;\n            }\n\
    \        }\n        return ret;\n    }\n</code>\n<|/ a tags=c#,algorithm |>\n\
    <| c |>\nThis is incorrect if there are more than one triplet that sum to zero\
    \ (for example, [1, 1, 2, 2]).\n<|/ c |>\n<| c |>\nI didn't get you, what is the\
    \ problem with above code? Can you please explain?\n<|/ c |>\n<| a dscore=0 |>\n\
    Try this solution:\n<code>\npublic static bool IsTripletSumToZero(long[] arr)\n\
    {\n    long sum = 0;\n    bool foundTripletSumToZero = false;", "{\n    int threes\
    \ = 0;\n    int nines = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n \
    \   int w = 0;\n    for (int i=0; i<l.length; i++) \n    {\n        if (l[i] %\
    \ 3 == 0) \n        {\n            x++;\n            if (x == 3) \n          \
    \  {\n                threes++;\n                x = 0;\n            }\n     \
    \   } \n        if (l[i] % 9 == 0) \n        {\n            y++;\n           \
    \ if (y == 3) \n            {\n                threes++;\n                y =\
    \ 0;\n            }\n        } \n        if (l[i] % 17 == 0) \n        {\n   \
    \         z++;\n            if (z == 3) \n            {\n                threes++;\n\
    \                z = 0;\n            }\n        } \n        if (l[i] % 37 == 0)\
    \ \n        {\n            w++;\n            if (w == 3) \n            {\n   \
    \             threes++;\n                w = 0;\n            }\n        }\n  \
    \  }"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
