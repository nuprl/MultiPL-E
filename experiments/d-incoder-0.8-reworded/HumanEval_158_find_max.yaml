name: HumanEval_158_find_max
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nWrite a function that accepts\
  \ an array of strings.\n    The array contains different words. Return the word\
  \ with maximum number\n    of unique characters. If multiple strings have maximum\
  \ number of unique\n    characters, return the one which comes first in lexicographical\
  \ order.\n\n    >>> find_max([\"name\", \"of\", \"string\"])\n    \"string\"\n \
  \   >>> find_max([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max([\"\
  aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring find_max(string[]\
  \ words) \n"
tests: "unittest\n{\n    alias candidate = find_max;\n\n    assert(candidate([\"name\"\
  , \"of\", \"string\"]) == \"string\");\n    assert(candidate([\"name\", \"enam\"\
  , \"game\"]) == \"enam\");\n    assert(candidate([\"aaaaaaa\", \"bb\", \"cc\"])\
  \ == \"aaaaaaa\");\n    assert(candidate([\"abc\", \"cba\"]) == \"abc\");\n    assert(candidate([\"\
  play\", \"this\", \"game\", \"of\", \"footbott\"]) == \"footbott\");\n    assert(candidate([\"\
  we\", \"are\", \"gonna\", \"rock\"]) == \"gonna\");\n    assert(candidate([\"we\"\
  , \"are\", \"a\", \"mad\", \"nation\"]) == \"nation\");\n    assert(candidate([\"\
  this\", \"is\", \"a\", \"prrk\"]) == \"this\");\n    assert(candidate([\"b\"]) ==\
  \ \"b\");\n    assert(candidate([\"play\", \"play\", \"play\"]) == \"play\");\n\
  }\nvoid main(){}"
completions: ["{\n    string res = \"\"; \n    map<int, string> m;\n    for(int i=0;\
    \ i<words.length; i++){\n        if(m.find(words[i]) == m.end()){\n          \
    \  m[words[i].length()] += words[i];\n        }\n    }\n    int max = 0, maxI\
    \ = -1;\n    for(map<int, string>::iterator it = m.begin(); it != m.end(); ++it){\n\
    \        if(maxI < it->first){\n            max = it->first;\n            maxI\
    \ = it->first;\n            res = it->second;\n        }\n        if(max < it->first){\n\
    \            max = it->first;\n            res = it->second;\n        }\n    }\n\
    \    return res;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\nstring max;\n\
    map<int, string> m;\nfor(int i=0; i<words.length; i++){\n    if(m.find(words[i])\
    \ == m.end()){\n        m[words[i].length()] += words[i];\n    }\n}", "{\n   \
    \ /*\n    Declare and initialize variable 'max' to 0.\n    Declare and initialize\
    \ variable 'counter' to 0.\n    \n    Write a loop that iterates through the words\
    \ array.\n    On each iteration, increase 'counter' by 1.\n    If 'counter' equals\
    \ 'max', set 'max' to 'counter'.\n    \n    If all words have the same number\
    \ of unique characters,\n    then 'max' will be the highest unique number.\n \
    \   \n    After the loop is done, return the word with the highest unique number.\n\
    \    */\n    int max = 0;\n    int counter = 0;\n    \n    foreach(string word\
    \ in words)\n    {\n        counter += 1;\n        if (counter == max)\n     \
    \       max = counter;\n    }\n    \n    return words[max];\n}\n/*\nWrite a function\
    \ that accepts an array of strings.\n    The array contains different words. Return\
    \ only those words that contain\n    every unique letter.", "{\n\tint max = 0,\
    \ index = -1;\n\tfor(int i = 0; i < words.length; i++)\n\t{\n\t\tindex = 0;\n\t\
    \tfor(int j = 1; j < words[i].length(); j++)\n\t\t{\n\t\t\tif(words[i].charAt(j)\
    \ == words[i].charAt(index)) index++;\n\t\t\telse \n\t\t\t{\n\t\t\t\tif(max <\
    \ index) max = index;\n\t\t\t\tindex = j;\n\t\t\t}\n\t\t}\n\t}\n\treturn words[max];\n\
    }", "{\n    string result = \"\";\n    size_t max = 0;\n    size_t cur = 0;\n\
    \    foreach(string word in words) \n    {\n        size_t curLen = word.length();\n\
    \        if(curLen > max) \n        {\n            max = curLen;\n           \
    \ result = word;\n        }\n        cur = cur + curLen;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=string,algorithm,string,c# |>\n<| a dscore=0 |>\nHere is\
    \ a simple solution that doesn't use dictionaries.\n<code>\n    using System;\n\
    \    using System.Collections.Generic;", "{\n    int max = 0;\n    string res\
    \ = \"\";\n    for (int i=0; i<words.length; ++i)\n    {\n        if (words[i].length()\
    \ > max)\n        {\n            max = words[i].length();\n            res = words[i];\n\
    \        }\n    }\n    return res;\n}\n</code>\n<|/ a tags=sorting,algorithm,data-structures,arrays,string\
    \ |>\n<| a |>\nI thought of a solution that uses dynamic programming and a hash\
    \ map to keep track of the number of unique letters. This is O(n * m) time and\
    \ O(n) space.\n<code>\npublic class Solution {\n    public String findLongestWord(String[]\
    \ words) {\n        if (words == null || words.length == 0) return \"\";\n   \
    \     int n = words.length;\n        Map<Character, Integer> map = new HashMap<Character,\
    \ Integer>();\n        for (int i = 0; i < n; i++) {\n            String word\
    \ = words[i];\n            for (int j = 0; j < word.length(); j++) {\n       \
    \         char c = word.charAt(j);\n                if (map.containsKey(c)) {\n\
    \                    Integer count = map.get(c);\n                    map.put(c,\
    \ count + 1);\n                } else {\n                    map.put(c, 1);\n\
    \                }\n            }\n        }\n        for (int i = 0; i < n; i++)\
    \ {\n            String word = words[i];\n            int max = Integer.MIN_VALUE;\n\
    \            Character c = null;\n            for (int j = 0; j < word.length();\
    \ j++) {\n                c = Character.toUpperCase(word.charAt(j));\n       \
    \         if (map.containsKey(c)) {\n                    Integer count = map.get(c);\n\
    \                    if (max < count) max = count;\n                }\n      \
    \      }\n            if (max == Integer.MIN_VALUE) continue;\n            String\
    \ res = \"\";\n            for (int j = 0; j < word.length(); j++) {\n       \
    \         char ch = Character.toUpperCase(word.charAt(j));\n                if\
    \ (map.containsKey(ch)) {\n                    if (map.get(ch) == max) {\n   \
    \                     res += ch;\n                    }\n                }\n \
    \           }\n            return res;\n        }\n        return \"\";\n    }\n\
    }\n</code>\n<|/ a dscore=1 tags=sorting,algorithm,data-structures,arrays,string\
    \ |>\n<| c |>\nI think this solution is incorrect if the first string in the given\
    \ array is repeated twice. For example, `findLongestWord([\"a\", \"b\", \"a\"\
    , \"b\", \"c\"])` returns `\"abbc\"` rather than `\"abc\"`. Similarly, `findLongestWord([\"\
    a\", \"b\", \"c\", \"a\", \"b\", \"c\"])` returns `\"abc\"` rather than `\"acb\"\
    `.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nimport java.util.*;\nimport java.io.*;\n\
    class Main {\n    public static void main(String[] args) {\n        String[] words\
    \ = {\"name\",\"of\",\"string\"};\n        List<String> ", "{\n  int maxUniqueChars;\n\
    \  string bestWord;\n  int bestIndex = 0;", "{\n    int highest = 0;\n    int\
    \ index = 0;\n    for(int i = 0; i < words.length; i++)\n    {\n        if(words[i].length()\
    \ > highest)\n            highest = words[i].length();\n        index = i;\n \
    \   }\n    int chars = 0;\n    for(int i = index+1; i < words.length; i++)\n \
    \   {\n        chars += words[i].length();\n        if(chars > highest)\n    \
    \        highest = chars;\n    }\n    return words[index];\n}", "{\n    int n\
    \ = words.length;\n    string strMax = null;\n    \n    for (int i = 0; i < n;\
    \ i++)\n    {\n        // find the maximum number of unique chars in str\n   \
    \     string str = words[i];\n        int count = 0;\n        for (int j = 0;\
    \ j < n; j++)\n        {\n            if (j == i) continue;\n            if (str[j]\
    \ == str[j])\n                count++;\n        }\n        if (count > strMax.length())\n\
    \        {\n            strMax = str;\n        }\n    }\n    \n    return strMax;\n\
    }", "{\n  int charCounts[255];\n  for(uint i = 0; i < words.length; ++i)\n   \
    \ for(uint j = 0; j < words[i].length; ++j)\n      ++charCounts[words[i][j]];",
  "{\n    int max = 0;\n    int i;\n    string tmp;\n    for(i = 0; i<words.length;\
    \ i++)\n    {\n        tmp = words[i];\n        int j = i;\n        int num =\
    \ 0;\n        while(j!=words.length && num < max)\n        {\n            int\
    \ compare = std.string.compare(words[j],tmp);\n            if(compare > 0)\n \
    \           {\n                max = num;\n            }\n            if(compare\
    \ == 0)\n            {\n                num = num + 1;\n            }\n      \
    \      else\n            {\n                num = num;\n            }\n      \
    \      j = j-1;\n        }\n    }\n    return words[max];\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis is an excellent answer because it gives us the option to test our\
    \ solutions. I really like the use of \"std.typecons\" and the \"std.math\" library,\
    \ and I've tried to implement this into my code, but I'm having trouble. I can't\
    \ seem to figure out how to get the function to use the std.math library. I don't\
    \ know what to do with the \"std.math\" library functions. I keep getting the\
    \ error \"undefined reference to `pow'\". Do you know how I can resolve this issue?\
    \ Or what I'm doing wrong here?\n<|/ c |>\n<| c |>\nI haven't used this library.\
    \ You can import it by copying the whole folder into the same folder with your\
    \ file. And then replace all the \"std.\" with \"std\". Also add \"using namespace\
    \ std\" to the beginning of your code file.\n<|/ c |>\n<| c |>\nI implemented\
    \ everything as you said, and when I run my code I get the error \"undefined reference\
    \ to pow\" and then the program ends. I looked at the \"std\" library in visual\
    \ studio and there are functions in it that I thought would be useful but I'm\
    \ obviously missing something.\n<|/ c |>\n<| c |>\nI made a mistake. std.math.pow\
    \ only works for C++ projects. To make it work for other languages, you can use\
    \ std.pow, which is a C library. Try changing all the \"std.math.pow\" to \"std.pow\"\
    .\n<|/ c |>\n<| c |>\nThanks for your help, you've been really helpful. I got\
    \ it working now. I'll post my updated code below.\n<|/ c |>\n<| a dscore=2 tags=string,max,algorithm,c++,function\
    \ |>\nI wrote this in Java. The result is the same for the most part. \n<code>\n\
    public static void main(String[] args)\n    {\n        String[] words = {\"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"string", "{\n    if (words.length == 0)\n\
    \        return \"\";\n    if (words[0].length() == 0)\n        return find_max(words);\n\
    \    \n    map<char, int> counter;\n    foreach (i, e) e in words) {\n       \
    \ counter[e] = 1;\n    }\n    int maxIndex = 0;\n    int maxCount = 0;\n    int\
    \ maxLen = 0;\n    foreach (i, e) e in words) {\n        int count = counter[e];\n\
    \        if (count > maxCount) {\n            maxCount = count;\n            maxIndex\
    \ = i;\n            maxLen = e.length();\n        }\n        counter[e] += 1;\n\
    \    }\n    if (maxCount == maxLen)\n        return words[maxIndex];\n    \n \
    \   string result = \"\";\n    foreach (i, e) e = words[maxIndex];\n    result\
    \ += e;\n    return find_max(result.dropLast());\n}\n</code>\n<|/ a |>\n<| a tags=string,arrays,algorithm,c++\
    \ |>\nYou can use this algorithm\n<code>", "{\n    int maxCharCount = 0;\n   \
    \ for(int i = 0; i < words.length; i++){\n        string word = words[i];\n  \
    \      string charCount = \"\";\n        for(int j = 0; j < word.length(); j++){\n\
    \            charCount = charCount + word[j];\n            \n        }\n     \
    \   int currentCharCount = std.string.length(charCount);\n        if(currentCharCount\
    \ > maxCharCount){\n            string result = \"\";\n            for(int j =\
    \ 0; j < word.length(); j++){\n                result += word[j];\n          \
    \  }\n            words[i] = result;\n            maxCharCount = currentCharCount;\n\
    \        }\n    }\n    return words[std.randomInt(words.length)];\n}", "{\n  \
    \  map <int,int> m;\n    for (int i = 0; i < words.length; ++i) {\n        if\
    \ (m.find(words[i].length()) == m.end()) {\n            m[words[i].length()] =\
    \ 0;\n        }\n        m[words[i].length()] += 1;\n    }\n    int max = 0;\n\
    \    int max_pos = -1;\n    \n    for (int i = 0; i < words.length; ++i) {\n \
    \       if (m[words[i].length()] > max) {\n            max = m[words[i].length()];\n\
    \            max_pos = i;\n        }\n    }\n    return words[max_pos];\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis isn't what the OP is looking for. You're looking\
    \ for the one with the most letters. He wants the one with the most letters alphabetically\
    \ sorted.\n<|/ c |>\n<| c |>\n, I have added a function to sort it\n<|/ c |>\n\
    <| c |>\nThe edit doesn't actually sort alphabetically. Just the string in lexicographical\
    \ order. Which is probably not what he wants.\n<|/ c |>\n<| c |>\nOh I see, thanks,\
    \ I have added a sort.\n<|/ c |>\n<| c |>\n, I am not familiar with map, but is\
    \ it possible to sort the map by the number of unique characters?\n<|/ c |>\n\
    <| a dscore=1 tags=string,algorithm,c++ |>\nThe easiest approach would be to convert\
    \ each string to a hash table:\n<code>\nstring str = \"helloworld\";\nunordered_map<char,\
    \ int> count_map;\nfor (char c : str) {\n    ++count_map[c];\n}\n</code>\nNow\
    \ you can easily find the maximum count and the word itself.\n<|/ a |>\n<| c |>\n\
    You can't convert a string to map by counting characters.\n<|/ c |>\n<| a |>\n\
    I came up with the following algorithm, where I create a map with the size of\
    \ the most common characters and then I go through all chars in the string and\
    \ update the map accordingly.\n<code>\n#include <iostream>\n#include <string>\n\
    #include <map>", "{\n    int uniqueChars = count(words);\n    string result =\
    \ null;\n    int max = uniqueChars;\n    for(int i = 0; i < words.length; i++)\n\
    \    {\n        string temp = words[i];\n        int newUniqueChars = count(temp);\n\
    \        if(newUniqueChars > max)\n        {\n            result = temp;\n   \
    \         max = newUniqueChars;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=arrays,c#,sorting dscore=2 |>\n<| c |>\nIt doesn't work if all strings\
    \ have the same number of unique chars.\n<|/ c |>\n<| c |>\nYes, but it is a little\
    \ unclear what the OP means by \"maximum unique characters\". I interpreted it\
    \ as \"the word that has the maximum number of unique characters\". So in this\
    \ case, the word with most characters is the right one (since the word `\"aaa\"\
    ` has three unique characters, so the word `\"aaa\"` is the correct one as far\
    \ as OP concerns).\n<|/ c |>\n<| c |>\nOkay, I just realized that OP also wants\
    \ to sort strings lexicographically if there are two or more strings with maximum\
    \ number of unique characters. But it isn't clear.\n<|/ c |>\n<| c |>\nNo, I don't\
    \ want maximum unique characters, I want maximum unique strings. In your example,\
    \ string `\"aaaa\"` has 4 unique characters and `string \"aaaaa\"` has 2 unique\
    \ characters. I don't want to sort by number of unique characters.\n<|/ c |>\n\
    <| a dscore=2 tags=arrays,c#,sorting |>\n<code>\npublic static string FindMaxString(string[]\
    \ array)\n{\n    List<string> max = new List<string>();\n    List<string> maxStrings\
    \ = new List<string>();\n    foreach (string item in array)\n    {\n        foreach\
    \ (string item in array)\n        {\n            if (item == item) continue;\n\
    \            int uniqueChars = item.Distinct().Count();\n            if (uniqueChars\
    \ == item.Length)\n            {\n                max.Add(item);\n           \
    \ }\n        }\n    }\n    string longest = max[0].ToUpper();\n    foreach (string\
    \ item in max)\n    {\n        if (longest.Length < item.Length)\n        {\n\
    \            longest = item;\n        }\n    }\n    maxStrings.Add(longest);\n\
    \    return longest;\n}\n</code>\n<|/ a |>\n<| c |>\nYeah, I know that this can\
    \ be done with nested for loops. I wanted to know if there is any better way of\
    \ doing this. Thanks for your reply.\n<|/ c |>\n<| c |>\nI guess the main problem\
    \ here is performance. `foreach", "{\n    var maxCount = 0;\n    var maxCountWord\
    \ = \"\";\n    for (int i = 0; i < words.length; ++i)\n    {\n        var count\
    \ = uniqueCount(words[i]);\n        if (count > maxCount)\n        {\n       \
    \     maxCount = count;\n            maxCountWord = words[i];\n        }\n   \
    \ }\n    return maxCountWord;\n}", "{\n    if(words.Length < 2) return words[0];\n\
    \    \n    map<int, string> counts = new map<int, string>();\n    map<string,\
    \ int> alphabet = new map<string, int>();\n    map<string, string> sorted_alphabet\
    \ = new map<string, string>();\n    for(int i = 0; i < words.Length; i++) {\n\
    \        string word = words[i];\n        counts[word] = counts[word] + 1;\n \
    \       alphabet[word] = alphabet[word] + 1;\n        sorted_alphabet.insert(pair<string,\
    \ string>(word,word));\n    }\n    int max_count = counts.begin()->second;\n \
    \   string max_word = counts.begin()->first;\n    \n    map<string, int> other_counts;\n\
    \    for(int i = 0; i < words.Length; i++) {\n        string word = words[i];\n\
    \        other_counts[word] = counts[word] - 1;\n    }\n    \n    map<int, string>\
    \ other_alphabet;\n    for(int i = 0; i < words.Length; i++) {\n        string\
    \ word = words[i];\n        other_alphabet[other_counts[word]] += 1;\n    }\n\
    \    \n    pair<map<int, string>, map<string, int> > results;\n    if(alphabet.size()\
    \ > other_alphabet.size()) {\n        results = sorted_alphabet.equal_range(max_word);\n\
    \    } else {\n        results = sorted_alphabet.equal_range(other_alphabet.begin()->first);\n\
    \    }\n    \n    string best_word = results[0].second;\n    int best_alphabet\
    \ = alphabet.at(best_word);\n    \n    for(int i = 1; i < words.Length; i++) {\n\
    \        string word = results[i].first;\n        int new_alphabet = alphabet.at(word);\n\
    \        if(new_alphabet > best_alphabet) {\n            best_alphabet = new_alphabet;\n\
    \            best_word = word;\n        }\n    }\n    \n    return best_word;\n\
    }\n</code>\n<|/ a dscore=0 tags=algorithm,c++,string |>\n<| a |>\nAs far as I\
    \ understood, the number of unique characters in the string is the string length.\
    \ \nSo, you can sort that array by string length, then for each element, check\
    \ the rest of the strings. \n<code>\nsort(words,words + words.length);\n</code>\n\
    then for each element in the array:\n<code>\nfor (int i = 0; i < words.length;\
    \ i++)\n    {\n        for (int j = i+1; j < words.length; j++)\n        {\n \
    \           if(words[i] == words[j] && j-i+1 < words.length)\n            {\n\
    \                swap(words[i],words[j]);\n            }\n        }\n    }\n</code>\n\
    This can be easily improved if you can make use of std::map to store the count\
    \ of each string in a map.\n<|/ a dscore=0 tags=algorithm,", "{\n    int maxCount\
    \ = 0;\n    string max = null;\n    \n    for(int i = 0; i < words.length; i++){\n\
    \        int uniqueCount = 0;\n        string word = words[i];\n        \n   \
    \     for(int j = 0; j < word.length(); j++){\n            if(word[j] == word[j]){\n\
    \                uniqueCount++;\n            }\n        }\n        if(uniqueCount\
    \ > maxCount){\n            maxCount = uniqueCount;\n            max = word;\n\
    \        }\n    }\n    return max;\n}", "{\n    unordered_set<string> unique_chars(words.size());\n\
    \    for (unsigned i = 0; i < words.size(); ++i) {\n        unique_chars[words[i]]\
    \ += 1;\n    }", "{\n\tstring max = \"\";\n\tint count = 0;\n\tint maxCount =\
    \ 0;\n\tfor (size_t i = 0; i != words.length(); ++i)\n\t{\n\t\tstring word = words[i];\n\
    \t\tint count1 = count(word, max);\n\t\tif (count1 != count)\n\t\t{\n\t\t\tmax\
    \ = word;\n\t\t\tcount = count1;\n\t\t}\n\t\tif (count > maxCount)\n\t\t{\n\t\t\
    \tmaxCount = count;\n\t\t\tmax = word;\n\t\t}\n\t}\n\treturn max;\n}", "{\n  \
    \  map<string, int> wordCount;\n    foreach (string w in words)\n    {\n     \
    \   if (wordCount.containsKey(w))\n        {\n            wordCount[w] = wordCount[w]\
    \ + 1;\n        }\n        else\n        {\n            wordCount.put(w, 1);\n\
    \        }\n    }\n    string maxWord = \"\";\n    int maxCount = wordCount.size();\n\
    \    foreach (string w in wordCount.keySet())\n    {\n        if (wordCount[w]\
    \ == maxCount)\n        {\n            maxWord = w;\n            break;\n    \
    \    }\n    }\n    return maxWord;\n}\n</code>\n<|/ a |>\n<| c |>\nI love it.\
    \ It's a shame that the language is so verbose and convoluted that people don't\
    \ realise that the foreach loop can act as a for loop in other languages.\n<|/\
    \ c |>\n<| c |>\nI think the point of the exercise is to learn about functional\
    \ programming techniques, rather than just using some more terse method of accomplishing\
    \ the same thing.\n<|/ c |>\n<| c |>\nYes, it's an exercise in functional programming.\
    \ And it is probably a reasonable one to learn about functional programming techniques.\
    \ I still think it's a useful exercise.\n<|/ c |>\n<| c |>\nI agree with you and\
    \ I agree that this is not an advanced example but a basic one which shows the\
    \ power of functional programming.\n<|/ c |>\n<| c |>\nThe foreach loop in F#,\
    \ like the for loop in C, has some great benefits. It is much easier to read than\
    \ the for loop and it is easy to add other things to the loop later. If you really\
    \ want to learn F# I would suggest looking at the examples on the F# website.\n\
    <|/ c |>\n<| a tags=algorithm,c#,functional-programming |>\n<code>\nstring[] words\
    \ = new string[] { \"string\", \"name\", \"of\", \"string\" };\nstring wordWithMaxNumberOfCharacter\
    \ = words[0]; ", "{\n    int count = 0;\n    int max = 0;\n    int i;\n    foreach(i,\
    \ words) {\n        count[words[i]]++;\n        if (count[words[i]] == max) {\n\
    \            max = count[words[i]];\n        }\n    }\n    foreach(i, count) {\n\
    \        if (count[i] > max)\n            return words[i];\n    }\n    return\
    \ words[words.length - 1];\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,language-agnostic,string\
    \ dscore=1 |>\nHere is C# solution with lambda expressions and LINQ:\n<code>\n\
    \ public class WordCounting\n    {\n        public static string WordWithMaxUniqueChars(string[]\
    \ words)\n        {\n            var counts = words.Select(word => new {word,\
    \ count = words.Count(c => c == word)})\n                             .GroupBy(x\
    \ => x.word)\n                             .OrderByDescending(g => g.Count())\n\
    \                             .First();", "{\n    map<string, int> m = Map();\n\
    \    for(int i = 0; i< words.length; i++){\n        auto it = m.find(words[i]);\n\
    \        if (it != m.end()){\n            it->second++;\n        }\n        else{\n\
    \            m[words[i]] = 1;\n        }\n    }\n    \n    for (auto it = m.begin();\
    \ it != m.end(); ++it){\n        if(it->second > 1){\n            return it->first;\n\
    \        }\n    }\n    return words[0];\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\n\
    <code>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>",
  "{\n    int n = words.length;\n    int count[26] = {0};", "{\n    int max = -1;\n\
    \    int n = 0;\n    foreach (string word : words) {\n        n = uniqueCharCount(word);\n\
    \        if (n >= max) {\n            max = n;\n        } else if (n < max) {\n\
    \            return word;\n        }\n    }\n    return words[0];\n}", "{\n  \
    \  string word = null; //first word\n    int max = 0; //maximum characters\n \
    \   int min = 0; //minimum characters", "{\n  int max = 0;\n  int maxIndex = 0;",
  "{\n    int maxIndex = 0;\n    string word = \"\";", "{\n    int max_count=0;\n\
    \    int i=0;\n    int j=words[i].length();\n    while (j>0)\n    {\n        if\
    \ (words[i].substr(0, j).length()>=max_count)\n        {\n            max_count=words[i].substr(0,\
    \ j).length();\n        }\n        j--;\n        i++;\n    }\n    return words[i];\n\
    }\n</code>\n<|/ a |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding why and/or how this code answers the question improves\
    \ its long-term value.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n/*\nWrite a function\
    \ that accepts an array of strings.\nThe array contains different words. Return\
    \ the word with maximum number\nof unique characters. If multiple strings have\
    \ maximum number of unique\ncharacters, return the one which comes first in lexicographical\
    \ order.", "{\n    int[] count = new int[256];\n    for(int i = 0; i < words.length;\
    \ i++)\n    {\n        for(int j = 0; j < words[i].length; j++)\n        {\n \
    \           count[(int)words[i][j]] += 1;\n        }\n    }", "{\n    \n    int\
    \ max = -999;\n    int j = 0;\n    for(int i = 0; i < words.length; i++)\n   \
    \ {\n        int n = count(words[i].begin(), words[i].end());\n        if(n >\
    \ max)\n        {\n            max = n;\n            j = 0;\n        }\n    }\n\
    \    \n    return words[j];\n}\n</code>\n<|/ a tags=c++,algorithm,arrays,string\
    \ |>\n<| a tags=c++,algorithm,arrays,string |>\n<code>", "{\n    int n = words.length;\n\
    \    int maxLen = words[0].len();\n    map<int, string> mmap = new map<int, string>();",
  "{\n    typedef map<char, int> char_map;\n    char_map cm_temp;\n    int max_count\
    \ = 0, index = -1;\n    for (auto &word: words) \n    {\n        char_map cm;\n\
    \        for (auto &c: word) \n        {\n            if (!cm_temp.contains(c))\
    \ \n            {\n                cm[c] = 1;\n            }\n            else\
    \ \n            {\n                cm[c]++;\n                if (cm[c] > max_count)\
    \ \n                {\n                    max_count = cm[c];\n              \
    \      index = c - 'a';\n                }\n            }\n        }\n       \
    \ cm_temp = cm;\n    }\n    return words[index];\n}\n</code>\n<|/ a dscore=1 tags=string,algorithm,c++\
    \ |>\n<| a tags=string,algorithm,c++ |>\nHere is an O(n) solution.\nThe idea is\
    \ to iterate over the strings one by one and for each word get the count of unique\
    \ characters in it and keep track of the maximum count. Once you encounter a word\
    \ with a count that is greater than the maximum count, then the word with the\
    \ maximum count is your answer.\n<code>\nstring find_max(const vector<string>\
    \ &words) {\n  unordered_map<char, int> unique;\n  unordered_map<char, int> max_count;\n\
    \  for (const auto &s : words) {\n    for(auto &c : s) {\n      if (unique.count(c)\
    \ > 0)\n        unique[c]++;\n      else\n        unique[c] = 1;\n    }\n    for(auto\
    \ &c : s) {\n      if (max_count.count(c) > max_count.at(c))\n        max_count[c]\
    \ = max_count.at(c);\n      else\n        max_count[c] = unique[c];\n    }\n \
    \ }", "{\n    int max = 0;\n    int max = words[0].hashCode();\n    int length\
    \ = words.length;\n    foreach(char c in words[0]) {\n        for (int i = 0;\
    \ i < length; i++) {\n            if (words[i].hashCode() == c) continue;\n  \
    \          if (words[i].hashCode() > max) {\n                max = words[i].hashCode();\n\
    \                max = words[i];\n            }\n        }\n    }\n    return\
    \ max;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nIn addition to Kyle Rooney's answer:\n\
    This is an algorithm that would work even if you have multiple words with similar\
    \ lengths and letters. It is based on using a dictionary to map the string length\
    \ to an ordered list of strings with that length. The dictionary is then searched\
    \ for longest string with the same length as the longest string in the dictionary.\n\
    <code>\nimport java.util.LinkedList;", "{\n    int maxCount = 0;\n    string maxWord\
    \ = \"\";\n    bool foundWord = false;\n    for (int i = 0; i < words.length;\
    \ ++i) {\n        string temp = words[i];\n        int count = 0;\n        for\
    \ (int j = 0; j < words.length; ++j) {\n            if (words[j].length() > temp.length())\n\
    \                continue;\n            count = words[j].length() - temp.length();\n\
    \            if (count > maxCount) {\n                foundWord = true;\n    \
    \            maxCount = count;\n                maxWord = temp;\n            }\n\
    \        }\n        if (foundWord) {\n            foundWord = false;\n       \
    \ }\n    }\n    return maxWord;\n}", "{\n    // Write your code here\n    map<int,\
    \ string> max;\n    for(auto w : words) {\n        auto it = max.find(w.size());\n\
    \        if(it != max.end())\n            it->second = w;\n        else\n    \
    \        max.insert(pair<int, string>(w.size(), w));\n    }\n    \n    string\
    \ res = *max.rbegin().second;\n    for(auto it : max) {\n        if(it.first >\
    \ res.size()) {\n            res = it.second;\n        }\n    }\n    return res;\n\
    }", "{\n    map<string,int> m;\n    for(int i = 0; i < words.length; ++i)\n  \
    \  {\n        auto it = m.find(words[i]);\n        if(it != m.end())\n       \
    \ {\n            if(it->second > 1)\n                return words[i];\n      \
    \  }\n        else\n        {\n            map[words[i]] = 1;\n        }\n   \
    \ }\n    map<string,int>::iterator it;\n    for(it = m.begin(); it != m.end();\
    \ ++it)\n    {\n        if(it->second == 1)\n            return it->first;\n \
    \   }\n    return words[0];\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThe easiest\
    \ way to solve your problem is to sort the letters in the strings. Then use std::count_if\
    \ to find the strings with the same number of letters. The second parameter of\
    \ std::count_if is a binary function that is supposed to return true if the letter\
    \ is in the string and false if not.\n<code>\n#include <algorithm>\n#include <vector>\n\
    #include <iostream>", "{\n    int counter = 0;\n    int max = 0;\n    string word\
    \ = words[0];\n    \n    for (int i = 1; i < words.length; i++)\n    {\n     \
    \   if(words[i].length() > max)\n        {\n            counter = words[i].length();\n\
    \            max = words[i].length();\n            word = words[i];\n        }\n\
    \    }\n    \n    return word;\n}", "{\n    int max = 0;\n    string result =\
    \ \"\";\n    for(size_t i = 0; i < words.length; ++i)\n    {\n        auto current\
    \ = words[i].size();\n        if(current > max) \n        {\n            max =\
    \ current;\n            result = words[i];\n        }\n    }\n    return result;\n\
    }", "{\n    var maxCharCount = int.MaxValue;\n    var maxWord = string.Empty;\n\
    \    foreach (string word in words)\n    {\n        int charCount = 1;\n     \
    \   foreach (char c in word)\n        {\n            charCount++;\n        }\n\
    \        if (charCount > maxCharCount)\n        {\n            maxCharCount =\
    \ charCount;\n            maxWord = word;\n        }\n    }\n    return maxWord;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nthanks for posting the code but this does not answer\
    \ my question. I want the longest string to be returned and I can't use max to\
    \ find the longest string.\n<|/ c |>\n<| a dscore=0 tags=c#,string |>\n<code>\n\
    string findLongestString(string[] strings)\n{\n    string longest = string.Empty;\n\
    \    foreach (var str in strings)\n    {\n        if (str.Length > longest.Length)\n\
    \            longest = str;\n    }\n    return longest;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nthanks for posting the code but this does not answer my question. I want\
    \ the longest string to be returned and I can't use max to find the longest string.\n\
    <|/ c |>\n<| a dscore=0 tags=c#,string |>\n<code>\nstring findLongestString(string[]\
    \ strings)\n{\n    return strings.Aggregate((s, a) => s.Length > a.Length ? s\
    \ : a).ToString();\n}\n</code>\n<|/ a |>\n<| c |>\nThis only works if all strings\
    \ have the same length. If you use another string[] containing 3 strings, this\
    \ will return \"hi\" instead of \"how\" as expected. `string[] strings = { \"\
    hi\", \"ho\", \"how\" };`\n<|/ c |>\n<| a |>\n<code>\npublic static String getLongestString(String[]\
    \ strArr){\n    String longestStr = \"\";", "{\n    int[] count = new int[26];\n\
    \    int maxIndex = 0;\n    foreach (string word in words)\n    {\n        int\
    \ index = 0;\n        for (int i = 0; i < word.length(); ++i)\n        {\n   \
    \         count[word.charAt(i) - 'a']++;\n            index++;\n        }\n  \
    \      if (index > maxIndex)\n        {\n            maxIndex = index;\n     \
    \   }\n    }\n    \n    string result = words[maxIndex];\n    for (int i = 0;\
    \ i < words.length; ++i)\n    {\n        int index = 0;\n        for (int i =\
    \ 0; i < words[i].length(); ++i)\n        {\n            count[words[i].charAt(i)\
    \ - 'a']--;\n            index++;\n        }\n        if (index > maxIndex)\n\
    \        {\n            result = words[i];\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| a tags=c++,max,arrays |>\n<code>\n#include <iostream>\n\
    using namespace std;", "{\n    string max;\n    int count = 0;\n    for (int i\
    \ = 0; i < words.length; ++i) \n    {\n        for (int j = 0; j < words[i].length();\
    \ j++) \n        {\n            if (words[i][j] == max[count]) \n            {\n\
    \                count++;\n            }\n            else\n            {\n  \
    \              if (count == 0) \n                {\n                    max =\
    \ words[i];\n                }\n            }\n        }\n    }\n    return max;\n\
    }", "{\n    int maxCount = 1;\n    string maxWord = words[0];\n    for(int i=1;\
    \ i<words.length; i++)\n    {\n        for(int j=0; j<words[i].length; j++)\n\
    \        {\n            if(words[i].length() > maxWord.length())\n           \
    \ {\n                maxCount = 1;\n                maxWord = words[i];\n    \
    \        }\n            else if(words[i].length() == maxWord.length())\n     \
    \       {\n                maxCount++;\n            }\n        }\n    }\n    return\
    \ maxWord;\n}\n/*\nWrite a function that accepts an array of strings containing\
    \ only digits.\n    Return an array with numbers from 0 to 99 that represent each\
    \ digit in \n    the string from right to left. For example, if the array is [\"\
    1\", \"2\", \"3\"]\n    then the returned array is [3, 2, 1]", "{\n    map<int,\
    \ int> m;\n    int count = 0;\n    for (int i = 0; i < words.length; i++) \n \
    \   {\n        int u = std.countChars(words[i]);\n        m.put(u, count++);\n\
    \    }", "{\n    string max = null;\n    string word = null;\n    int count =\
    \ 0;", "{\n\tstring result = \"no result\";\n\tfor(int i=0; i < words.length;\
    \ ++i) {\n\t\tint count = 0;\n\t\tfor(int j=0; j < words.length; ++j) {\n\t\t\t\
    if (words[j] == words[i]) ++count;\n\t\t}\n\t\tif (count > result.length()) result\
    \ = words[i];\n\t}\n\treturn result;\n}\n/*\nWrite a function that accepts an\
    \ array of ints.\n    The array contains different ints. Return the int with maximum\
    \ number\n    of unique elements. If multiple ints have maximum number of unique\
    \ elements,\n    return the one which comes first in lexicographical order.",
  "{\n    map<int, int> counter;\n    string max = \"not found\";\n    for (string\
    \ w : words)\n    {\n        int n = w.length();\n        if (counter.find(n)\
    \ == counter.end())\n        {\n            counter[n] = 1;\n        }\n     \
    \   else\n        {\n            int c = counter[n];\n            counter[n]++;\n\
    \            if (c > counter[max].second)\n            {\n                max\
    \ = w;\n            }\n        }\n    }\n    if (counter[max.length()].second\
    \ == 0)\n    {\n        max = \"not found\";\n    }\n    return max;\n}\n</code>\n\
    <|/ a tags=string,c++ |>\n<| c |>\nThanks for the help. It works in my case. I\
    \ have a doubt. As i understand, if i want to search the array with the key \"\
    a\" as in this case if the key is present i have to iterate through all the array\
    \ elements. Will the above code work if i search the key \"a\" in the 3rd array\
    \ element?\n<|/ c |>\n<| c |>\nIn that case, you would first have to search for\
    \ the `map` for the key \"a\" and then iterate through all the other elements\
    \ until you find `a`.\n<|/ c |>\n<| c |>\nOhk. Thanks alot for the help.\n<|/\
    \ c |>\n<| c |>\nWhy not use a set instead of a map?\n<|/ c |>\n<| c |>\nThat\
    \ would also work. It would require to first iterate through the map to get the\
    \ key \"a\" and then search the other elements for \"a\".\n<|/ c |>\n<| a dscore=0\
    \ tags=string,c++ |>\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <vector>\n#include <algorithm>\n#include <unordered_set>\nusing namespace std;",
  "{\n    if(words.length == 0) \n        return \"\";", "{\n    string result; \n\
    \    int chars;\n    int i;\n    int max_len = -1;\n    int counter = 0; \n  \
    \  for (i = 0; i < words.length; i++)\n    {\n        chars = 0;\n        for\
    \ (auto &w : words)\n            if (std.string::length(w) == std.string::length(words[i])\
    \ && std.string::lexicographical_compare(w, words[i]))\n                chars++;\n\
    \        if (chars > max_len)\n        {\n            result = words[i];\n   \
    \         max_len = chars;\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=language-agnostic,algorithm,dynamic-programming |>\n<| c |>\nCan you\
    \ explain how this works and why it works?\n<|/ c |>\n<| c |>\n: Please take a\
    \ look at my answer.\n<|/ c |>\n<| a dscore=3 tags=language-agnostic,algorithm,dynamic-programming\
    \ |>\nHere is the C++ code for this problem\n<code>\n#include <iostream>\n#include\
    \ <algorithm>\n#include <vector>\nusing namespace std;", "{\n    map<string, int>\
    \ counter;\n    \n    for(int i=0; i<words.length; ++i)\n    {\n        string\
    \ word = words[i];\n        counter[word] += 1;\n    }", "{\n    /*\n    Write\
    \ your solution here\n    */\n}\n</code>\n<|/ a tags=c++ |>\n<| c |>\nThis is\
    \ not how SO works.  We don't want to simply tell you the answer... We want to\
    \ help you, and show you where you've gone wrong.\n<|/ c |>\n<| c |>\nApologies.\
    \ I've modified my answer. Should I delete this one? I don't think the question\
    \ was that bad, even if the answer was lengthy and unclear.\n<|/ c |>\n<| c |>\n\
    Not really.  Nothing is perfect, and you did well to try to help.\n<|/ c |>\n\
    <| c |>\nThank you for helping me out. This has helped me alot !\n<|/ c |>\n<|\
    \ c |>\nWelcome to Stack Overflow!  While this answer may be correct, it's often\
    \ better to include some explanatory text along with it.  Code only answers can\
    \ become invalid if the code is changed or removed without explanation. \nThis\
    \ answer will likely be deleted by the site unless you add an explanation.\n<|/\
    \ c |>\n<| a |>\nThis is an improvement of the O(n logn) solution posted here:\
    \ https://stackoverflow.com/a/30778974/3943465\nThis is O(n) time complexity,\
    \ with O(1) space complexity.\n<code>\n#include <string>\n#include <iostream>",
  "{\n    // TODO: write your code here\n    map<string, int> m;\n    for(int i =\
    \ 0; i < words.length; i++)\n    {\n        int count = 0;\n        for(int j\
    \ = 0; j < words.length; j++)\n        {\n            if(words[i] == words[j])\n\
    \            {\n                count++;\n            }\n        }\n        m[words[i]]\
    \ = count;\n    }\n    map<int, string>::iterator it;\n    for(it = m.begin();\
    \ it != m.end(); it++)\n    {\n        if(it->second > 1)\n        {\n       \
    \     return it->first;\n        }\n    }\n    return words[0];\n}", "{\n    var\
    \ counters = std.typecons.map();\n    foreach(string w in words) {\n        foreach(char\
    \ c in w) \n            counters[c] = 1 + counters[c];\n    }\n    foreach(char\
    \ c in chars) {\n        foreach(string w in words) {\n            if (counters[c]\
    \ >= w.length()) \n                return w;\n        }\n    }\n    return null;\n\
    }\n</code>\n<|/ a dscore=0 tags=ocaml,arrays,string |>\n<| a tags=ocaml,arrays,string\
    \ |>\nI like the idea of using a map of strings, but the code is more verbose\
    \ than necessary because it is so verbose. Let's get rid of the foreach loops.\
    \ We are going to iterate through the strings and for each string find all the\
    \ characters in it. In OCaml we get this behavior for free by using the String.make\
    \ function. The code becomes a lot easier to read and debug. \n<code>\nlet max_count\
    \ (str: string array) =\n  let rec get_count (curr_index: int, curr_index : int)\
    \ =\n    match str with\n    | [] -> 0\n    | head::tail -> if head = String.make\
    \ 1 tail.[0] then get_count (curr_index + 1) (curr_index + 1) else get_count (curr_index\
    \ + 1) (curr_index)\n    | _::tail -> get_count (curr_index + 1) (curr_index)\n\
    \  in \n  get_count 0 0\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=ocaml,arrays,string\
    \ |>\nIn OCaml you can find the max number of unique characters in a string with\
    \ just one simple function:\n<code>\nlet find_max str = String.find (fun c ->\
    \ String.mem c str) str\n</code>\nBut it seems that you also need to find the\
    \ position of that character in the string and I suggest a recursive function\
    \ that counts how many times a character appears in a string:\n<code>\nlet rec\
    \ count str c =\n    match String.find c str with\n    | None -> 0\n    | Some\
    \ i -> 1 + count str (c :: i)\nlet find_max str = count str \"\"\n</code>\nIn\
    \ fact you don't need recursion at all to solve this problem. Strings are just\
    \ arrays of characters, so you can find the index of the first character of a\
    \ string in the following way:\n<code>\nlet find_max str = \n    match String.find\
    \ (fun c -> String.mem c str) str with\n    | None -> 0\n    | Some i -> i\n</code>\n\
    The same logic can be used to solve your question, but I suggest you use a map\
    \ instead of a list to store the counts of each character:\n", "{\n    map<string,\
    \ int> freq;\n    for(auto w : words) {\n        int c = std.countOccurrences(freq,\
    \ w);\n        freq[w] = c+1;\n    }\n    return std.max(freq.begin(), freq.end(),\
    \ [] (pair<string, int> p1, pair<string, int> p2) {\n        return p1.second\
    \ < p2.second;\n    });\n}", "{\n    int count = 1;\n    for (int i = 0; i < words.length;\
    \ ++i)\n    {\n        for (int j = i; j < words.length; ++j)\n        {\n   \
    \         int num_unique_chars = 0;\n            string temp_str = words[i];\n\
    \            for (int k = i; k < words.length; ++k)\n            {\n         \
    \       string str = words[k];\n                if (str.size() < temp_str.size())\n\
    \                {\n                    temp_str = str;\n                }\n \
    \               if (temp_str.size() == str.size())\n                {\n      \
    \              num_unique_chars += 1;\n                }\n            }\n    \
    \        if (num_unique_chars > count)\n            {\n                count =\
    \ num_unique_chars;\n                string tmp = words[i];\n                for\
    \ (int j = i; j < words.length; ++j)\n                {\n                    string\
    \ str = words[j];\n                    if (str.size() == tmp.size())\n       \
    \             {\n                        if (str.compare(tmp);\n             \
    \           {\n                            tmp = words[j];\n                 \
    \       }\n                    }\n                }\n                string out\
    \ = words[i];\n                if (out.size() < out.compare(tmp);\n          \
    \      {\n                    out = words[i];\n                }\n           \
    \ }\n        }\n    }\n    return words[count];\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 tags=c++,algorithm,string,sorting |>\nI find this interesting too\
    \ but since I already have a solution I want to share it with you.\nWhat I did\
    \ was to iterate over each character in each string and count the number of different\
    \ chars and then add the count into a map.\nThen I iterated over each string again\
    \ and iterated over each character in each string.\nFor each string I check if\
    \ the map already contains the char and if it is I return the index with maxCount\
    \ value.\n<code>\n #include <iostream>\n #include <map>\n #include <string>\n\
    \ using namespace std;", "{\n    int max = 0;\n    string result = \"\";\n   \
    \ for (int i = 0; i < words.length; i++) {\n        char[] chars = words[i].ToCharArray();\n\
    \        Arrays.sort(chars);\n        int cur = chars.Length;\n        if (cur\
    \ > max) {\n            max = cur;\n            result = words[i];\n        }\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for\
    \ the answer! I really like how you used the sort function with a lambda. It helps\
    \ me understand how it works and helps me to better understand for loops etc!\
    \ I also appreciate the explanations so I can understand what's going on! However,\
    \ my professor specifically asked for me to use the find method that I already\
    \ used in my code. Also, what did you mean by 'sorting in ascending order' in\
    \ the last part of the answer? I tried googling that but couldn't find anything\
    \ on the subject.\n<|/ c |>\n<| c |>\nAh I misunderstood you. I thought you wanted\
    \ to sort the array in ascending order.\n<|/ c |>\n<| c |>\nAh! Thanks for the\
    \ clarification! Yeah, I realized my mistake right as I wrote my last comment\
    \ but then I realized that I can use the sort method and just switch the sorting\
    \ order of the lamba like so: Arrays.sort(chars, (x, y) => x.CompareTo(y));\n\
    <|/ c |>\n<| a tags=c# dscore=0 |>\nI believe this to be a working solution, though\
    \ it won't be particularly efficient. It uses HashSets and LINQ.\n<code>\n   \
    \ public string FindMax(List<string> words)\n    {\n        int maxCount = -1;\n\
    \        string result = null;\n        foreach (string word in words)\n     \
    \   {\n            int count = word\n                .Select(c => c.ToLowerInvariant())\n\
    \                .Distinct()\n                .Count();", "{\n    int max = 0;\n\
    \    string wordWithMax = \"\";\n    for(int i = 0; i < words.length; i++){\n\
    \        string word = words[i];\n        int length = word.length;\n        int\
    \ count = 1;\n        for(int j = 0; j < words.length; j++){\n            string\
    \ nextWord = words[j];\n            if(nextWord.length == length){\n         \
    \       if(nextWord > word){\n                    count = count + 1;\n       \
    \         }\n                else if(nextWord < word){\n                    count\
    \ = count - 1;\n                }\n            }\n        }\n        if(count\
    \ > max){\n            max = count;\n            wordWithMax = word;\n       \
    \ }\n    }\n    return wordWithMax;\n}\n/*\nWrite a function that accepts an array\
    \ of strings.\n    The array contains different words. Return the word with minimum\
    \ number\n    of unique characters. If multiple strings have minimum number of\
    \ unique\n    characters, return the one which comes first in lexicographical\
    \ order.", "{\n    map<string, int> char_count;\n    \n    for (auto &it : words)\
    \ {\n        int char_count = it.size();\n        \n        auto it = char_count.find(char_count);\n\
    \        if (it != char_count.end()) {\n            if (it->second < char_count)\
    \ {\n                char_count[char_count] = it->second;\n            }\n   \
    \     }\n        else {\n            char_count[char_count] = 1;\n        }\n\
    \    }\n    \n    auto max_count = char_count.rbegin()->second;\n    auto max_index\
    \ = char_count.rbegin()->first;\n    for (auto it = char_count.begin(); it !=\
    \ char_count.end(); it++) {\n        if (it->second == max_count) {\n        \
    \    max_index = it->first;\n        }\n    }\n    return words[max_index];\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=c++,algorithm |>\nI wanted to do this\
    \ in a similar way. I'm writing this from memory so I might be missing some things\
    \ but it should be pretty close. I was also asked to do it with std::map instead\
    \ of map.\n<code>", "{\n    string result = null;\n    int maxCount = 0;\n   \
    \ for (int i=0; i<words.length; ++i) {\n        int count = length(words[i]);\n\
    \        if (count > maxCount) {\n            result = words[i];\n           \
    \ maxCount = count;\n        }\n    }\n    return result;\n}", "{\n    map<int,\
    \ string> map;\n    \n    for (int i = 0; i < words.length(); ++i)\n    {\n  \
    \      int c = words[i].length();\n        if (map.find(c) == map.end())\n   \
    \     {\n            map[c] = words[i];\n        }\n        else\n        {\n\
    \            map[c] = words[i] > map[c] ? words[i] : map[c];\n        }\n    }\n\
    \    \n    for (auto it : map)\n    {\n        \n        if (it.second == it.first)\n\
    \        {\n            return it.second;\n        }\n    }\n    \n    return\
    \ words[0];\n}", "{\n  int max = 0, i = 0;\n  for(string[] word: words)\n  {\n\
    \    foreach(int c, word)\n    {\n      if(max == 0)\n      {\n        max = c;\n\
    \        i = word.indexOf(c);\n      }\n      else if(max < c)\n      {\n    \
    \    max = c;\n        i = word.indexOf(c);\n      }\n    }\n  }\n  return words[i];\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,string,c++,sorting dscore=0\
    \ |>\nI suggest you to use std::set or std::unordered_set to keep count of letters\
    \ in each word. You can use std::unordered_map to keep word as key and count as\
    \ value. \nThe code would look like this:\n<code>\n#include <unordered_map>\n\
    #include <set>\n#include <vector>\n#include <iostream>", "{\n\tstring maxWord\
    \ = \"\";\n\t\n\tbool unique = true;\n\tfor (int i = 0; i < words.length; i++)\n\
    \t{\n\t\tint count = charCount(words[i]);\n\t\tif (count > unique)\n\t\t{\n\t\t\
    \tunique = count;\n\t\t\tmaxWord = words[i];\n\t\t}\n\t}\n\t\n\treturn maxWord;\n\
    }\n/* \nWrite a function that accepts an array of strings.\n    The array contains\
    \ different words. Return the word with minimum number\n    of unique characters.\
    \ If multiple strings have maximum number of unique\n    characters, return the\
    \ one which comes first in lexicographical order.", "{\n    int count = 0;\n \
    \   string result = \"\";\n    int temp = 0;\n    for (int i = 0; i < words.length;\
    \ i++)\n    {\n        for (int j = i + 1; j < words.length; j++)\n        {\n\
    \            temp = count + count_char(words[i], words[j]);\n            if (temp\
    \ > count)\n            {\n                count = temp;\n                result\
    \ = words[i];\n            }\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 tags=functional-programming,python,arrays,c++,algorithm |>\n<|\
    \ c |>\nIt doesn't compile because the `count_char` method doesn't return a value.\n\
    <|/ c |>\n<| c |>\n, Thanks. I edited my answer.\n<|/ c |>\n<| a tags=functional-programming,python,arrays,c++,algorithm\
    \ dscore=0 |>\nHere is my solution in Scala\n<code>\ndef findLongest(str: List[String]):\
    \ String = {\n  str.foldLeft(List[String]())(_ ++ _).groupBy(_).mapValues(_.length)\n\
    \  .maxBy(_._2)._1\n}\n</code>\n<|/ a |>\n<| a tags=functional-programming,python,arrays,c++,algorithm\
    \ |>\nHere is my solution in Scala.\n<code>\ndef findLongest(str: List[String]):\
    \ String = {\n str.foldLeft(List[String]())(_ ++ _).groupBy(_).mapValues(_.length)\n\
    .maxBy(_._2)._1\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=functional-programming,python,arrays,c++,algorithm\
    \ |>\nA solution in Javascript:", "{\n    \n    int max = 0;\n    int num = 0;\n\
    \    string result = \"\";\n    \n    for (int i = 0; i < words.length; ++i) \n\
    \    {\n        unordered_set<char> uniq_chars;\n        \n        for (int j\
    \ = 0; j < words[i].length(); ++j)\n        {\n            uniq_chars[words[i][j]]\
    \ = 1;\n        }\n        \n        for (int j = 0; j < uniq_chars.size(); ++j)\n\
    \        {\n            ++num;\n            if (num > max)\n            {\n  \
    \              max = num;\n                result = words[i];\n            }\n\
    \        }\n    }\n    \n    return result;\n}\n</code>\n<|/ a tags=string,c++,arrays,data-structures,sorting\
    \ |>\n<| c |>\nPlease add some explanation to your answer such that others can\
    \ learn from it\n<|/ c |>\n<| a tags=string,c++,arrays,data-structures,sorting\
    \ |>\nIn C++\n<code>\nusing namespace std;\n</code>\nDeclare a string array.\n\
    <code>\nstring name[] = \"Mary\"; //initializing string array\nstring name[] =\
    \ \"John\"; //initializing string array\nstring name[] = \"Peter\"; //initializing\
    \ string array\nstring name[] = \"Paul\"; //initializing string array\nstring\
    \ name[] = \"Mary\"; //initializing string array\nstring name[] = \"Peter\"; //initializing\
    \ string array\nstring name[] = \"Paul\"; //initializing string array\n</code>\n\
    Use the sort function to sort the string.\n<code>\nsort(name, name + 4);\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nWhy would you suggest `using namespace std;` instead\
    \ of `using std::string;`?\n<|/ c |>\n<| c |>\nNo reason. Just a suggestion. Thanks\
    \ for the comment.\n<|/ c |>\n<| a dscore=2 |>\nIn Python:\n<code>\ndef maxInArray(array):\n\
    \    max = 0\n    index = -1\n    for i in range(len(array)):\n        if array[i]\
    \ > array[index]:\n            max = array[i]\n            index = i\n    return\
    \ array[index]\n</code>\n<|/ a tags=string,c++,arrays,data-structures,sorting\
    \ |>\n<| a dscore=2 |>\nIn C++:\n<code>\nstring s[] = {\"Mary\", \"John\", \"\
    Peter\", \"Paul\", \"Mary\", \"Peter\", \"Paul\"};\nstring max;\nfor (int i=0;\
    \ i<sizeof(s)/sizeof(s[0]); i++)\n{\n   for(int j=0; j<sizeof(s)/sizeof(s[0]);\
    \ j++)\n    {\n        if(s[i].compare(s[j]) > 0) // or < if you prefer\n    \
    \    {\n            max = s[j];\n        }", "{\n\tint max = 0;\n\tstring word\
    \ = \"\";\n\tint count = 0;\n\tint index = 0;\n\tfor (int i = 0; i < words.length();\
    \ i++)\n\t{\n\t\tcount = 1;\n\t\tword = words[i];\n\t\tfor (int j = index; j <\
    \ word.length(); j++)\n\t\t{\n\t\t\tif (word[j] == word[i])\n\t\t\t{\n\t\t\t\t\
    count++;\n\t\t\t}\n\t\t}\n\t\tif (count > max)\n\t\t{\n\t\t\tmax = count;\n\t\t\
    \tindex = i;\n\t\t}\n\t}\n\treturn word;\n}\n/*\nWrite a function that accepts\
    \ a string as argument.\n    Return the number of times that the string has occurred.\n\
    \    \n    >>> count_letters(\"aaaaaaa\")\n    4\n    >>> count_letters(\"name\"\
    )\n    2\n*/", "{\n    int maxNum = 0;\n    int max = 0;\n    int index = 0;\n\
    \    for(index =0; index < words.length; index++) {\n        int[] charNum = new\
    \ int[256];\n        int[] charMax = new int[256];\n        for(int i=0; i < words[index].length();\
    \ i++) {\n            if(charNum[words[index].charAt(i)] == 0) {\n           \
    \     charNum[words[index].charAt(i)] = 1;\n                charMax[words[index].charAt(i)]\
    \ = 1;\n            }\n            else {\n                charNum[words[index].charAt(i)]++;\n\
    \                charMax[words[index].charAt(i)]++;\n            }\n        }\n\
    \        for(int i=0; i < charNum.length; i++) {\n            if(charNum[i] >\
    \ max) {\n                max = charNum[i];\n                maxNum = i;\n   \
    \         }\n        }\n    }\n    return words[maxNum];\n}\n</code>\n<|/ a dscore=0\
    \ tags=java,algorithm |>\n<| c |>\nThis solution is O(M+N) time complexity as\
    \ per my understanding and this solution is also O(N), which is not the best case\
    \ for this problem\n<|/ c |>\n<| a |>\nThis can be done in a single pass in O(N)\
    \ time complexity where N is the number of words.\nBelow is the working code snippet\
    \ in Java.\n<code>\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;",
  "{\n    map<string,int> m;\n    for(string s: words) \n        ++m[s];\n    int\
    \ max=0;\n    string maxWord=\"\";\n    foreach(string s, m)\n    {\n        if(m>max)\n\
    \        {\n            max=m[s];\n            maxWord=s;\n        }\n    }\n\
    \    return maxWord;\n}\n</code>\n<|/ a tags=c++,arrays,algorithm dscore=0 |>\n\
    <| a tags=c++,arrays,algorithm |>\n<code>", "{\n    size_t maxCount = 0;\n   \
    \ string word = \"\";\n    for(auto &w : words) \n    {\n        size_t count\
    \ = std::count_if(w.begin(), w.end(), [](char c){ return isalpha(c); });\n   \
    \     if(count > maxCount) \n        {\n            word = w;\n            maxCount\
    \ = count;\n        }\n    }\n    if(maxCount > 1)\n    {\n        auto firstSort\
    \ = [&](string a){return std::lexicographical_compare(a.begin(), a.end(), word.begin(),\
    \ word.end());};\n        std::sort(words.begin(), words.end(), firstSort);\n\
    \    }\n    return word;\n}", "{\n    int n = words.length;\n    string s = \"\
    \";\n    int max = 1;\n    int i;", "{\n\t\n}\n</cell>\n<cell>\n%%writefile wordcount/main.dart",
  "{\n    int[,] count_matrix = new int[words.length, words[0].length];\n    int[,]\
    \ maxcount_matrix = new int[words.length, words[0].length];\n    int i,j;\n  \
    \  \n    for(i=0; i<words.length; i++)\n    {\n        int count=0;\n        for(j=0;\
    \ j<words[i].length; j++)\n            count+=count_matrix[i,j];\n        count_matrix[i,0]=count;\n\
    \    }", "{\n    var result = new string();\n    var counter = -1;\n    var max\
    \ = words[0].length;\n    foreach(var word in words)\n    {\n        if(word.Length\
    \ > max)\n        {\n            max = word.Length;\n            result = word;\n\
    \        }\n        foreach (var letter in word)\n        {\n            if(letter\
    \ == ' ' || letter == '\\n')\n                continue;\n            counter++;\n\
    \            if(counter > max)\n            {\n                result = word;\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI appreciate this solution, but it is\
    \ very slow. I ran it on 20,000 random strings and it took 1.9 seconds. I did\
    \ some more testing and found that if I remove the foreach loop and replace it\
    \ with a while loop, it takes less than 1 second. This is still not the best solution\
    \ though.\n<|/ c |>\n<| c |>\nAh, I was working on something else when I came\
    \ back to check your solution. My solution was indeed much faster.\n<|/ c |>\n\
    <| a dscore=0 |>\nJust another way of doing it using linq:\n<code>\nusing System;\n\
    using System.Collections.Generic;\nusing System.Linq;", "{\n\tint maxCount = words[0].size();\n\
    \tint maxWord = words[0];\n\tint index = 1;\n\tint wordCount = 0;\n\tfor (int\
    \ i = 0; i < words.length; ++i)\n\t{\n\t\tstring word = words[i];\n\t\tint wordSize\
    \ = word.size();\n\t\tint count = 0;\n\t\tfor (int j = 0; j < wordSize; ++j)\n\
    \t\t{\n\t\t\tchar c = word[j];\n\t\t\tif (std.typecons.find(chars.contains(char(c))))\n\
    \t\t\t\t++count;\n\t\t}\n\t\tif (count > maxCount)\n\t\t{\n\t\t\tmaxCount = count;\n\
    \t\t\tmaxWord = word;\n\t\t\tindex = i;\n\t\t}\n\t}\n\treturn maxWord;\n}", "{\n\
    \    int max = 0;\n    string result = \"\";\n    foreach(string word in words)\n\
    \    {\n        int count = 0;\n        foreach(char c in word)\n        {\n \
    \           count += uniques[c];\n        }\n        if (count > max)\n      \
    \  {\n            max = count;\n            result = word;\n        }\n    }\n\
    \    return result;\n}", "{\n\tint uniqueCount = 0, longestUnique = 0, index =\
    \ 0;\n\tfor(int i = 0; i < words.length; i++){\n\t\tfor(int j = 0; j < words[i].length();\
    \ j++){\n\t\t\tuniqueCount++;\n\t\t\tif(uniqueCount == longestUnique){\n\t\t\t\
    \tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(uniqueCount > longestUnique){\n\
    \t\t\t\tlongestUnique = uniqueCount;\n\t\t\t}\n\t\t}\n\t}\n\treturn words[index];\n\
    }", "{\n\tsort(words);\n\tfor (size_t i = 0; i < words.length; ++i)\n\t{\n\t\t\
    int counter = 0;\n\t\tfor (size_t j = 0; j < words.length; ++j)\n\t\t{\n\t\t\t\
    if (i == j) continue;\n\t\t\tif (words[i].length() < words[j].length())\n\t\t\t\
    \tcounter++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (words[i].length() == words[j].length())\n\
    \t\t\t\t{\n\t\t\t\t\tif (words[i] < words[j])\n\t\t\t\t\t\tcounter++;\n\t\t\t\t\
    }\n\t\t\t\telse\n\t\t\t\t\tcounter--;\n\t\t\t}\n\t\t}\n\t\tif (counter == words.length)\n\
    \t\t\treturn words[i];\n\t}\n\treturn \"string\";\n}\n\t", "{\n    map<char, int>\
    \ counters = dict<char, int>();\n    for(auto w : words) {\n        for(char c\
    \ : w) {\n            counters[c] = counters[c] + 1;\n        }\n    }", "{\n\
    \    string result = \"\";\n    int maxCount = 0;\n    for (int i = 0; i < words.length;\
    \ i++) {\n        int count = 0;\n        for (int j = 0; j < words[i].length();\
    \ j++) {\n            if (words[i].charAt(j) == result.charAt(j))\n          \
    \      count++;\n        }\n        if (count > maxCount) {\n            result\
    \ = words[i];\n            maxCount = count;\n        }\n    }\n    \n    return\
    \ maxCount < words.length ? result : words[0];\n}\n</cell>\n<code language=.net-csharp>\n\
    #r \"Bot.dll\"\nusing Bot;\n</cell>\n<code language=.net-csharp>\nvar name = \"\
    name enam game\";\nvar words = name.Split(' ');\n</cell>\n<code language=.net-csharp>\n\
    find_max(words);\n</cell>\n<code language=.net-csharp>\nstring longest(string\
    \ words)\n{\n    string result = \"\";\n    int maxCount = 0;\n    \n    for (int\
    \ i = 0; i < words.Length; i++) {\n        int count = 0;\n        for (int j\
    \ = 0; j < words[i].Length; j++) {\n            if (words[i].Length > j)\n   \
    \             count++;\n        }\n        if (count > maxCount) {\n         \
    \   result = words[i];\n            maxCount = count;\n        }\n    }\n    \n\
    \    return maxCount < words.Length ? result : words[0];\n}\n</cell>\n<code language=.net-csharp>\n\
    longest(words);\n</cell>\n<code language=.net-csharp>\nstring longest(string words)\n\
    {\n    string result = \"\";\n    int maxCount = 0;\n    \n    for (int i = 0;\
    \ i < words.Length; i++) {\n        int count = 0;\n        for (int j = 0; j\
    \ < words[i].Length; j++) {\n            if (words[i].Length > j)\n          \
    \      count++;\n        }\n        if (count > maxCount) {\n            result\
    \ = words[i];\n            maxCount = count;\n        }\n    }\n    \n    return\
    \ maxCount < words.Length ? result : words[0];\n}\n</cell>\n<code language=.net-csharp>\n\
    var name = \"name enam game\";\nvar words = name.Split(' ');\n</cell>\n<code language=.net-csharp>\n\
    longest(words);\n</cell>\n<code language=.net-csharp>\nvar name = \"aaaaaab bb\
    \ cc\";\nvar words = name.Split(' ');\n</cell>\n<code language=.net-csharp>\n\
    longest(words);\n</cell>\n<code language=.net-csharp>\nvar name = \"aaaaaaa bb\
    \ cc\";\nvar words = name.Split(' ');\n</cell>\n<code language=.net-csharp>\n\
    longest(words);\n</cell>\n<code language=.net-csharp>\nvar name = \"aaaaaaa\"\
    ;\nvar words = name.Split('", "{\n    string best=words[0];\n    int size=words.length;\n\
    \    int i;\n    bool found=false;\n    for (i = 1; i < size; i++)\n    {\n  \
    \      if (std.universe.unique(words[i]) == 1)\n        {\n            if (std.universe.compare(words[i\
    \ - 1], words[i]) >= 0) \n            {\n                best=words[i];\n    \
    \            found=true;\n            }\n            else\n            {\n   \
    \             best=words[i - 1];\n            }\n        }\n    }\n    if (!found)\
    \ \n    {\n        return words[0];\n    }\n    return best;\n}", "{\n\tint numOfChars\
    \ = 0;\n\tstring result = \"\";\n\tfor(int i = 0; i < words.length; ++i)\n\t{\n\
    \t\tstring curr = words[i];\n\t\tnumOfChars += curr.length();\n\t\tstring tmp\
    \ = sortStringWithCharCount(curr);\n\t\tnumOfChars += tmp.length();\n\t\tfor(int\
    \ j = 0; j < tmp.length(); ++j)\n\t\t{\n\t\t\tif(numOfChars < tmp.length())\n\t\
    \t\t{\n\t\t\t\tresult = tmp;\n\t\t\t\tnumOfChars = tmp.length();\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn result;\n}\n/*\nWrite a function that accepts an array of strings.\n\
    \    The array contains different words. Return True if any of words\n    has\
    \ maximum number of unique characters. If multiple strings have maximum\n    of\
    \ unique characters, return True if first comes first in lexicographical\n   \
    \ order.", "{\n    int uniqueChars = 1;\n    string wordWithMaxChars = words[0];\n\
    \    for (int i = 1; i < words.length; i++)\n    {\n        int thisUniqueChars\
    \ = 0;\n        for (int j = 0; j < words[i].length(); j++)\n        {\n     \
    \       thisUniqueChars += words[i][j];\n        }\n        if (thisUniqueChars\
    \ > uniqueChars)\n        {\n            wordWithMaxChars = words[i];\n      \
    \      uniqueChars = thisUniqueChars;\n        }\n    }\n    return wordWithMaxChars;\n\
    }\n</cell>\n<text>\nExercise 15: Write a function to find the smallest number\
    \ in a list of numbers.", "{\n    int counter = 1;\n    int maxCount = 0;\n  \
    \  for (int i = 0; i < words.length; i++) \n    {\n        int currentCount =\
    \ counter;\n        for (int j = 0; j < words[i].length(); j++) \n        {\n\
    \            counter++;\n            if (counter == currentCount) \n         \
    \   {\n                currentCount = 1;\n            }\n        }\n        if\
    \ (maxCount < currentCount) \n        {\n            maxCount = currentCount;\n\
    \        }\n    }\n    if (maxCount == words.length) \n    {\n        return words[0];\n\
    \    }\n    if (maxCount > words.length) \n    {\n        return words[words.length\
    \ - 1];\n    }\n    else \n    {\n        throw runtime_error(\"Error: No words\
    \ found\");\n    }\n}", "{\n    // Your code here\n    int max = 1;\n    string\
    \ result = \"\";\n    for (int i = 0; i < words.length; i++) {\n        if (words[i].length()\
    \ > max) {\n            max = words[i].length();\n            result = words[i];\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nHi there,\
    \ thanks for the solution! Can you explain the method a little bit? Like whats\
    \ going on in each line? What is the use of the max variable and how does it work?\
    \ Thanks\n<|/ c |>\n<| c |>\nHi there, sorry for the late reply. Thank you for\
    \ the solution, it makes sense to me now.\n<|/ c |>\n<| c |>\nI'm glad I was able\
    \ to help, please accept the answer. Thank you.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;",
  "{\n    string result = \"\";\n    int count = 0;\n    foreach (string word in words)\n\
    \    {\n        count += word.length();\n        if (count > result.length())\n\
    \            result = word;\n    }\n    return result;\n}", "{\n    int n = words.length;\n\
    \    int i, max = 0;\n    string maxWord = words[0];\n    \n    for (i = 1; i\
    \ < n; i++)\n    {\n        int count = 0;\n        for (j = 0; j < n; j++)\n\
    \        {\n            if (j != i && words[j].length() > words[i].length())\n\
    \                continue;\n            if (words[j].length() < words[i].length())\n\
    \            {\n                count ++;\n            }\n        }\n        if\
    \ (count > max)\n        {\n            max = count;\n            maxWord = words[i];\n\
    \        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a tags=algorithm,c++ |>\n\
    <| c |>\nThis code is wrong, because it returns \"string\" even though there are\
    \ three \"string\" entries in the array.\n<|/ c |>\n<| a tags=algorithm,c++ |>\n\
    This code will return \"string\" because there is no entry in the array that is\
    \ longer than \"string\".\nIt will also return \"enam\" because there is an entry\
    \ that is longer than \"enam\" in the array.\nIt will also return \"game\" because\
    \ there is an entry that is longer than \"game\" in the array.\nIt will also return\
    \ \"string\" because there is an entry that is longer than \"string\" in the array.\n\
    <code>\n#include <iostream>\n#include <algorithm>\nusing namespace std;", "{\n\
    \tint count = int();\n\t\n\tfor (int i = 0; i < words.length; ++i)\n\t{\n\t\t\
    for (int j = i+1; j < words.length; ++j)\n\t\t{\n\t\t\tfor (int k = 0; k < words[i].length;\
    \ ++k)\n\t\t\t{\n\t\t\t\tif (words[i].chars[k] == words[j].chars[k])\n\t\t\t\t\
    {\n\t\t\t\t\tif (count < words[i].chars.length)\n\t\t\t\t\t\tcount = words[i].chars.length;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn *max<string> (words[count], words[count-1]);\n\
    }", "{\n    var max;\n    for(int i =0; i < words.length; ++i)\n    {\n      \
    \  max = i;\n        for(int j = i+1; j < words.length; ++j)\n        {\n    \
    \        if(words[j].length() > words[max].length())\n            {\n        \
    \        max = j;\n            }\n        }\n        if(max != i)\n        {\n\
    \            var temp = words[i];\n            words[i] = words[max];\n      \
    \      words[max] = temp;\n        }\n    }\n    return words[words.length - 1];\n\
    }", "{\n    map<string, int> m;\n    for(int i=0; i<words.length; i++)\n    {\n\
    \        m[words[i]] = 1;\n    }\n    map<string, int>::iterator it;\n    for(int\
    \ i=0; i<words.length; i++)\n    {\n        it = m.find(words[i]);\n        if(it\
    \ != m.end())\n        {\n            if(it->second == 1)\n            {\n   \
    \             m[words[i]] = 2;\n            }\n            else\n            {\n\
    \                m[words[i]] ++;\n                if(m[words[i]] > 1)\n      \
    \          {\n                    return words[i];\n                }\n      \
    \      }\n        }\n    }\n    return words[0];\n}\n</code>\n<|/ a tags=algorithm,string,c++,arrays\
    \ |>\n<| a dscore=1 tags=algorithm,string,c++,arrays |>\nIf anyone is interested\
    \ in C#, here's the solution I wrote for this, and an explanation of how it works.\n\
    <code>\npublic static string FindLongest(string [] array)\n{\n    string longest\
    \ = \"\";\n    int longestCount = 0;", "{\n    bool hasDuplicates = false;\n \
    \   int counter = 1;\n    int max = 1;\n    for(int i = 0; i < words.length; ++i)\n\
    \    {\n        int currentCounter = 1;\n        for(int j = 0; j < words.length;\
    \ ++j)\n        {\n            if(words[i] == words[j])\n            {\n     \
    \           hasDuplicates = true;\n                break;\n            }\n   \
    \         else if(words[i].length() > words[j].length())\n            {\n    \
    \            currentCounter++;\n            }\n            else if(words[i].length()\
    \ < words[j].length())\n            {\n                currentCounter--;\n   \
    \         }\n        }\n        if(currentCounter > counter)\n        {\n    \
    \        counter = currentCounter;\n            max = i;\n        }\n    }\n \
    \   if(hasDuplicates)\n    {\n        return words[max];\n    }\n    else\n  \
    \  {\n        return words[max];\n    }\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    The question explicitly says that the array will contain only unique strings,\
    \ so `std::set` is irrelevant.\n<|/ c |>\n<| c |>\nI guess I misunderstood the\
    \ question. I've corrected my answer. Thanks!\n<|/ c |>\n<| c |>\nI think you\
    \ understood it, but I didn't get it working right now. Maybe I'm missing some\
    \ fundamental knowledge.\n<|/ c |>\n<| c |>\nOk, now I see what is the problem.\
    \ You cannot use a `while` loop because you need to find out if the string has\
    \ duplicates without actually visiting the whole array. The solution would be\
    \ to first find the duplicates and then to perform the while loop on the duplicates.\n\
    <|/ c |>\n<| c |>\nYou also need to check if the number of characters of each\
    \ string is greater than the maximum found so far. If it is, you need to increase\
    \ the counter.\n<|/ c |>\n<| a tags=algorithm,sorting,string,c++ dscore=0 |>\n\
    <code>\n#include <iostream>\n#include <algorithm>\n#include <vector>", "{\n  \
    \  int maxValue = 0;\n    string maxWord;\n    int maxCount = 1;\n    \n    for\
    \ (int i = 0; i < words.length; i++)\n    {\n        int currentCount = 0;\n \
    \       string currentWord = words[i];", "{\n    int charCount[] = new int[words.length];\n\
    \    string returnWord = \"\";\n    for(int i = 0; i < words.length; i++)\n  \
    \  {\n        for(int j = 0; j < words[i].length(); j++)\n        {\n        \
    \    charCount[i]++;\n        }\n        if(charCount[i] > returnWord.length())\n\
    \        {\n            returnWord = words[i];\n        }\n    }\n    return returnWord;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nNice.  I was thinking something similar\
    \ to your first one before reading your answer.  I like it.\n<|/ c |>\n<| a |>\n\
    <code>\npublic string findmax(string[] words)\n    {\n        string maxword=\"\
    \";\n        int maxcount=0;\n        foreach (string word in words)\n       \
    \ {\n            int count=0;\n            foreach (char c in word)\n        \
    \    {\n                if (word.Contains(c))\n                {\n           \
    \         count++;\n                }\n            }\n            if (count >\
    \ maxcount)\n            {\n                maxcount = count;\n              \
    \  maxword = word;\n            }\n        }\n        return maxword;\n    }\n\
    </code>\n<|/ a tags=c# dscore=0 |>\n<| a tags=c# |>\n<code>\nusing System;\nusing\
    \ System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;",
  "{\n\tint n = words.length;\n\tint m = words[0].length();\n\tint c = 1;\n\tfor (int\
    \ i = 1; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (std.typecons.compare(words[i],\
    \ words[j]) <= 0)\n\t\t\t\tcontinue;\n\t\t\tif (std.typecons.compare(words[j],\
    \ words[i]) <= 0)\n\t\t\t\tbreak;\n\t\t\tif (std.math.abs(c - std.typecons.charcount(words[i]\
    \ + words[j]) - std.typecons.charcount(words[i])) < std.math.abs(c - std.typecons.charcount(words[j]\
    \ + words[i])))\n\t\t\t\tc = std.typecons.charcount(words[i] + words[j]);\n\t\t\
    }\n\t}\n\treturn words[std.math.abs(c - std.typecons.charcount(words[n - 1] +\
    \ words[n])) - 1];\n}", "{\n\tstring result = words[0];\n\tint count = 0;\n\t\
    for (int i = 1; i < words.length; i++) \n\t{\n\t\tstring word = words[i];\n\t\t\
    int n = 0;\n\t\tfor (int j = 0; j < word.length(); j++) \n\t\t{\n\t\t\tchar c\
    \ = word.charAt(j);\n\t\t\tn = count[c] + n;\n\t\t}\n\t\tif (n > count[result])\n\
    \t\t{\n\t\t\tresult = word;\n\t\t\tcount[result] = n;\n\t\t}\n\t}\n\treturn result;\n\
    }", "{\n    int max = 0;\n    int n = words.length;\n    string result = \"\"\
    ;\n    for (int i = 0; i<n; i++){\n        int x = std.string.length(words[i]);\n\
    \        if (x > max){\n            result = words[i];\n            max = x;\n\
    \        }\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\nMy version for C++:\n<code>\n#include <string>\n#include <vector>\n#include\
    \ <algorithm>", "{\n    int maximum = 0;\n    int index = 0;\n    int maxIndex\
    \ = 0;\n    for(int i = 0; i<words.length; i++)\n    {\n        int count = count_unique(words[i]);\n\
    \        if(count > maximum)\n        {\n            maximum = count;\n      \
    \      maxIndex = i;\n        }\n    }\n    \n    if(maxIndex < words.length-1)\n\
    \    {\n        string result = words[maxIndex];\n        for(int i = maxIndex+1;\
    \ i<words.length; i++)\n        {\n            int count = count_unique(words[i]);\n\
    \            if(count > maximum)\n            {\n                maximum = count;\n\
    \                result = words[i];\n            }\n        }\n        return\
    \ result;\n    }\n    return words[0];\n}", "{\n    if(words.length == 0) {\n\
    \        throw new Exception(\"The array cannot be empty\");\n    }\n    unordered_map<char,\
    \ int> uniqueCount;\n    \n    for(int i=0; i < words.length; i++) \n    {\n \
    \       int count = 0;\n        for(int j=0; j < words[i].length(); j++) \n  \
    \      {\n            if(uniqueCount.containsKey(words[i][j]))\n            {\n\
    \                count++;\n            }\n            uniqueCount[words[i][j]]\
    \ = count;\n        }\n    }\n    \n    int maxCount = -1;\n    string maxWord\
    \ = \"\";\n    \n    foreach(auto word, uniqueCount)\n    {\n        if(uniqueCount.count(word)\
    \ > maxCount)\n        {\n            maxCount = uniqueCount.count(word);\n  \
    \          maxWord = word;\n        }\n    }\n    \n    return maxWord;\n}", "{\n\
    \    if (words.length==0) {\n        return \"No word found.\";\n    }\n    map<string,int>\
    \ counts;\n    for (string w : words) {\n        int c = counts[w];\n        counts[w]=(c==0?1:c+1);\n\
    \    }\n    int max = -1;\n    string word = \"\";\n    for (map<string,int>::iterator\
    \ it = counts.begin();it != counts.end();it++) {\n        int c = it->second;\n\
    \        if (c>max) {\n            max = c;\n            word = it->first;\n \
    \       }\n    }\n    return word;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ tags=algorithm,string |>\nMy first approach would be to use a HashMap, keyed\
    \ by characters, counting the number of times a given character appears. Then\
    \ use a second HashMap, keyed by characters, to count the number of times a given\
    \ character appears.\nThen iterate over the two HashMaps, and compare the two\
    \ counts and return the string that has the higher count. This assumes that the\
    \ input array is sorted.\n<|/ a |>\n<| c |>\nThis sounds interesting. But I'm\
    \ not sure I understand how to sort the HashMap by the number of times a character\
    \ appears.\n<|/ c |>\n<| c |>\nSort the keys of the second HashMap by decreasing\
    \ count. Then iterate the keys of the first HashMap and get the value for each\
    \ key, and then use that value as the count for the key in the second HashMap.\
    \ Repeat until all of the keys are processed.\n<|/ c |>\n<| c |>\nAnd what if\
    \ there are multiple words with same count (let's say for eg `a` appears twice)?\
    \ The question asks for which one to return in lexicographical order - how can\
    \ we resolve this?\n<|/ c |>\n<| a dscore=1 |>\nMy solution is similar to the\
    \ one given by \"Bill\". This one will also allow the user to select the desired\
    \ output format and sort by word's length, length or lexicographical order. \n\
    <code>\nclass StringSort {", "{\n\tint n = words.length;\n\t\n\tfor (int i = 0;\
    \ i < n; ++i) \n\t{\n\t\tstring word = words[i];\n\t\tint count = std::count(word.begin(),\
    \ word.end(), 'a');\n\t\tif (count > words[i].length())\n\t\t{\n\t\t\tint min\
    \ = words[i].length();\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif\
    \ (std::count(words[j].begin(), words[j].end(), 'a') <= min)\n\t\t\t\t{\n\t\t\t\
    \t\tmin = std::count(words[j].begin(), words[j].end(), 'a');\n\t\t\t\t}\n\t\t\t\
    }\n\t\t\tif (min > words[i].length())\n\t\t\t{\n\t\t\t\treturn word;\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn \"\";\n}\n/*\nWrite a function that accepts an array of strings.\n\
    \    The array contains different words. Return a list of all the words with\n\
    \    maximum number of unique characters. If multiple strings have maximum number\n\
    \    of unique characters, return the one which comes first in lexicographical\
    \ order.", "{\n    unordered_map<char, int> m;\n    for (auto w : words) {\n \
    \       for (int i = 0; i < w; ++i) m[w[i]]++;\n    }\n    \n    for (auto it\
    \ : m) \n        if (it.second > 1) return it.first;\n    return words[0];\n}\n\
    </code>\n<|/ a tags=string,c++,max dscore=0 |>\n<| a dscore=0 |>\n<code>\n#include\
    \ <iostream>\n#include <algorithm>\n#include <unordered_map>", "{\n    map<string,\
    \ int> m;\n    map<string, int>::iterator mi;\n    int max = 0, index = 0;\n \
    \   for(int i = 0; i < words.length; ++i)\n    {\n        m[words[i]] = m[words[i]]\
    \ ? m[words[i]] : 0;\n        ++m[words[i]];\n        if(m[words[i]] > max)\n\
    \        {\n            max = m[words[i]];\n            index = i;\n        }\n\
    \    }\n    return words[index];\n}", "{\n    unordered_map<string,int> m;\n \
    \   for (int i = 0; i < words.length; i++) {\n        if (m.count(words[i])<1)\
    \ {\n            m[words[i]]=1;\n        } else {\n            if (m[words[i]]<m[words[i-1]]+1)\
    \ {\n                m[words[i]]=m[words[i-1]]+1;\n            } else {\n    \
    \            m[words[i]]=m[words[i-1]];\n            }\n        }\n    }\n   \
    \ string maxKey;\n    int maxCount=0;\n    for (auto it=m.begin();it!=m.end();it++)\
    \ {\n        if (it->second>maxCount) {\n            maxCount=it->second;\n  \
    \          maxKey=it->first;\n        }\n    }\n    return maxKey;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=algorithm dscore=0 |>\nHere is a simple solution\
    \ in java using the stream API:\n<code>\npublic static String maxStringWithSameMaxChars(String[]\
    \ strings) {\n    return strings\n            .stream()\n            .max(Comparator.comparingInt(s\
    \ -> s.length()))\n            .orElseThrow(RuntimeException::new);\n}\n</code>\n\
    This uses the maximum element of the stream as the key for a HashMap to store\
    \ the counts of characters. Then it returns the key if the maximum count equals\
    \ the number of elements, or throws an exception if there is no maximum element.\n\
    <|/ a |>\n<| a dscore=0 |>\n<code>\npackage com.company;", "{\n    int len = words.length;\n\
    \    int max = 0; \n    string word = \"\";\n    for(int i = 0; i < len; ++i)\n\
    \    {\n        word += words[i];\n        int count = 1;\n        for(int j =\
    \ i + 1; j < len; ++j)\n        {\n            word += \" \" + words[j];\n   \
    \         int c = count(word);\n            if(c > count)\n            {\n   \
    \             count = c;\n                word = words[j];\n            }\n  \
    \      }\n        if(max < count)\n        {\n            max = count;\n     \
    \       word = words[i];\n        }\n    }\n    return word;\n}", "{\n    int\
    \ max = 0;\n    int count = 0;\n    int min = std::numeric_limits<int>::max();\n\
    \    for(int i = 0; i < words.length; ++i) {\n        string word = words[i];\n\
    \        int c = std::count_if(word.begin(), word.end(), [](char ch) {return !ch;\
    \ });\n        max = std::max(max, c);\n        count += c;\n        min = std::min(min,\
    \ c);\n    }\n    if(count > max) {\n        return words[std::count_if(words.begin(),\
    \ words.end(), [](string word) {return std::count_if(word.begin(), word.end(),\
    \ [](char ch) {return !ch; }) == max; }) - 1];\n    } else {\n        return words[std::count_if(words.begin(),\
    \ words.end(), [](string word) {return std::count_if(word.begin(), word.end(),\
    \ [](char ch) {return !ch; }) == count; }) - 1];\n    }\n}\n</code>\n<|/ a tags=c++\
    \ |>\n<| c |>\nYou should probably explain why your code is different than the\
    \ OP's code, and why it is better/faster. Especially for a beginner, it would\
    \ be a good idea to show how you think the original code should look.\n<|/ c |>\n\
    <| c |>\nI have added explanation to my answer. Thanks.\n<|/ c |>\n<| c |>\nOh\
    \ thanks a lot! I didn't know that about std::count_if. Also, I'm actually new\
    \ to C++, it's been a while since I've coded in any other language. I'm not used\
    \ to using libraries such as std.\n<|/ c |>\n<| c |>\n, If you find this answer\
    \ helpful, you can upvote it. Thanks.\n<|/ c |>\n<| c |>\n: This code is not correct.\
    \ `std::count_if` stops searching when it finds the first match. It does not count\
    \ the matches themselves.\n<|/ c |>\n<| a tags=c++ dscore=0 |>\nThis is my code\
    \ based on yours. I just changed the loop that you wrote to make it work.\n<code>\n\
    string find_max(string* words) {\n    int max = 0;\n    int count = 0;\n    int\
    \ min = std::numeric_limits<int>::max();\n    for(int i = 0; i < words.length;\
    \ ++i) {\n        int c = std::count_if(words[i].begin(), words[i].end(), [](char\
    \ ch) {return !ch; });\n        max = std::max(max, c);\n        count += c;\n\
    \        min = std::min(min, c);\n    }\n    if(count > max) {\n        return\
    \ words[std::count_if(words.begin(), words.end(), [](string word) {return std::count_if(word.begin(),\
    \ word.end(), [](char ch) {return !ch", "{\n\tint res = 0;\n\tint len = words.length;\n\
    \tint ans = 0;\n\tfor (int i = 0; i < len; i++)\n\t{\n\t\tint count = 1;\n\t\t\
    for (int j = i+1; j < len; j++)\n\t\t\tif (words[i].count(words[j])) count++;\n\
    \t\tif (count > res)\n\t\t{\n\t\t\tres = count;\n\t\t\tans = i;\n\t\t}\n\t}\n\t\
    return words[ans];\n}", "{\n    bool ismax = false;\n    int max_char = 0;\n \
    \   string maxname = \"\";\n    for (int i = 0; i < words.length; i++){\n    \
    \    for(int j = 0; j < words[i].length(); j++){\n            if(words[i].length()\
    \ > max_char){\n                max_char = words[i].length();\n              \
    \  ismax = true;\n            }\n            if(words[i].length() == max_char\
    \ && !ismax){\n                ismax = true;\n                maxname = words[i];\n\
    \            }\n            else if(words[i].length() == max_char && ismax){\n\
    \                break;\n            }\n        }\n    }\n    return maxname;\n\
    }\n</code>\n<|/ a tags=algorithm,sorting |>\n<| c |>\nWhile this code may answer\
    \ the question, providing additional context regarding how and/or why it solves\
    \ the problem would improve the answer's long-term value.\n<|/ c |>\n<| a dscore=2\
    \ |>\nThe most efficient and clear solution would be to implement merge sort using\
    \ C++'s STL containers. The complexity would be O(n log n) and you get an O(n)\
    \ solution.\n<|/ a tags=algorithm,sorting |>\n<| a tags=algorithm,sorting |>\n\
    <code>", "{\n    return find_max(words.map<int, int>(tolower));\n}", "{\n    int[]\
    \ count = new int[65536];\n    for(int i = 0;i < words.length;++i)\n    {\n  \
    \      count[words[i].length()]++;\n    }\n    int max = count[0];\n    int idx\
    \ = 0;\n    for(;;)\n    {\n        if(count[max] != 0) break;\n        idx++;\n\
    \        if(idx == max.bit_length()) \n        {\n            return max.to_string()\
    \ + \"a\";\n        }\n        max = (max << 1) | idx;\n    }\n    char res =\
    \ max.to_string() + 'a';\n    for(;;)\n    {\n        while(idx < max.bit_length())\n\
    \        {\n            if(count[idx] == 0) break;\n            idx++;\n     \
    \   }\n        char c = max.to_string() + 'a' - idx;\n        if(c != res) return\
    \ res;\n        max = (max << 1) | idx;\n    }\n}\n</code>\n<|/ a tags=algorithm,string,c,sorting\
    \ dscore=0 |>\n<| c |>\nCan you please explain what do you mean by \"lexicographical\
    \ order\"?\n<|/ c |>\n<| c |>\nThis isn't a good solution, because you're creating\
    \ a new array every time you run the program.\n<|/ c |>\n<| c |>\nI guess he meant\
    \ \"sort by alphabet\"\n<|/ c |>\n<| c |>\nNo. Lexicographical order means the\
    \ order in which you type the alphabetic letters, as opposed to \"alphabetic order\"\
    \ which means \"alphabetic order\" as we normally think of it.\n<|/ c |>\n<| c\
    \ |>\n: I suppose this solution only works in one way. Let's say you have \"aaaaaaa\"\
    \ and \"ab\", the \"a\" will come first since it comes first in the alphabet,\
    \ if you look at the \"ab\" it will come second since it comes second in alphabet\
    \ but since it's lexicographically after \"aaaaa\" it comes first in the lexicographical\
    \ order\n<|/ c |>\n<| a |>\n<code>", "{\n\tint count = 0;\n\tstring max = \"\"\
    ;\n\tforeach(string word in words)\n\t{\n\t\tforeach(int c in word)\n\t\t{\n\t\
    \t\tif (count[c] == 0)\n\t\t\t{\n\t\t\t\tcount[c] = 1;\n\t\t\t\tmax = c;\n\t\t\
    \t}\n\t\t}\n\t}\n\tforeach(int c in count)\n\t{\n\t\tif (count[c] > 1)\n\t\t{\n\
    \t\t\tmax = \"\";\n\t\t\tforeach(int c2 in count)\n\t\t\t{\n\t\t\t\tif (c2 > 1)\n\
    \t\t\t\t{\n\t\t\t\t\tif (c2 == count[c2])\n\t\t\t\t\t{\n\t\t\t\t\t\tforeach(string\
    \ word2 in words)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (word2[c] == max)\n\t\t\t\t\
    \t\t\t{\n\t\t\t\t\t\t\t\tmax = word2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\
    }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n\
    }\n/*\nWrite a function that accepts an array of strings and returns a boolean\
    \ value\n\tthat indicates whether all strings in the array have the same number\n\
    \tof unique characters.", "{\n    int max=1;\n    string most = words[0];\n  \
    \  for(int i = 1; i < words.length; i++)\n    {\n        for(int j = 0; j < most.length;\
    \ j++)\n        {\n            if(words[i].length() > most.length)\n         \
    \   {\n                most = words[i];\n                max = i;\n          \
    \  }\n            else if(words[i].length() == most.length)\n            {\n \
    \               if(words[i].compare(most) < words[max].compare(most))\n      \
    \          {\n                    most = words[i];\n                    max =\
    \ i;\n                }\n            }\n        }\n    }\n    return most;\n}",
  "{\n    map<string, int> map;\n    for (int i=0; i<words.length; i++)\n        map[words[i]]\
    \ = map[words[i]] ? map[words[i]]+1 : 1;\n    map<string, int>::iterator iter;\n\
    \    for (iter = map.begin(); iter != map.end(); ++iter)\n    {\n        int count\
    \ = iter->second;\n        if (count > 1)\n            return iter->first;\n \
    \   }\n    return \"no match\";\n}\n</code>\n<|/ a |>\n<| a tags=string,c#,algorithm\
    \ |>\nThis is in C#. As suggested by other folks, you can use the string class\
    \ methods, but it would be easier to do so using some LINQ. This should work:\n\
    <code>\nstatic string FindMax(string[] words)\n{\n    return words.Max(x => x.Length).OrderByDescending(x\
    \ => x).First();\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis will throw a `NullReferenceException`\
    \ if `words` is null.\n<|/ c |>\n<| c |>\nGood catch, I didn't notice he was passing\
    \ an empty string. I'll edit my answer with a more complete solution.\n<|/ c |>\n\
    <| a tags=string,c#,algorithm |>\nI would use something like this (this doesn't\
    \ use LINQ):\n<code>\npublic class WordCount\n{\n    public string Word { get;\
    \ private set; }\n    public int Count { get; private set; }", "{\n    sort(words);\n\
    \    int max = words[0].length();\n    for(int i=1; i<words.length; i++)\n   \
    \ {\n        if(words[i].length() > max)\n        {\n            max = words[i].length();\n\
    \        }\n    }\n    return words[words.length-1];\n}", "{\n    //write your\
    \ code here\n    int count=0;\n    int maxCharCount=0;\n    for(int i=0;i<words.length;i++){\n\
    \        if(words[i].length()>maxCharCount){\n            maxCharCount=words[i].length();\n\
    \        }\n        for(int j=0;j<words[i].length();j++){\n            if(words[i].at(j)!=words[i].at(j)){\n\
    \                count++;\n            }\n        }\n        if(count>maxCharCount){\n\
    \            string temp=words[i];\n            words[i]=words[words[i].length-1];\n\
    \            words[words[i].length-1]=temp;\n        }\n        count=0;\n   \
    \ }\n    return words[words.length-1];\n}\n</code>\n<|/ a |>\n<| a |>\nI modified\
    \ the code and added a function that returns the max string of the list without\
    \ duplicates\n<code>\nstring find_max(string[] words)\n{", "{\n  // code here\n\
    }", "{\n    var maxCount:int = 0;\n    var maxWord:string;\n    foreach (var word\
    \ in words)\n    {\n        var numChars = word.length;\n        if (numChars\
    \ > maxCount) {\n            maxCount = numChars;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;\n}\n</code>\n<|/ a |>\n<| a tags=c#,algorithm\
    \ |>\nThis answer applies to the question title - which is ambiguous. \nIn reality\
    \ the question is about returning a string with max length, not necessarily the\
    \ strings with most occurrences.\nIn that case the answer by is correct, but here\
    \ is the C# version. \nThe code is based on Knuth's algorithm for counting sort\
    \ (http://en.wikipedia.org/wiki/Counting_sort)\nIt makes use of the StringBuilder\
    \ (http://msdn.microsoft.com/en-us/library/system.text.stringbuilder.aspx) which\
    \ should be more efficient when concatenating long strings.\n<code>\npublic string\
    \ GetLongestString(string[] array)\n{\n    var maxLength = 0;\n    var maxWord\
    \ = \"\";\n    StringBuilder builder = new StringBuilder();\n    foreach (var\
    \ item in array)\n    {\n        builder.Append(item);\n        var length = builder.Length;\n\
    \        if (length > maxLength)\n        {\n            maxLength = length;\n\
    \            maxWord = builder.ToString();\n        }\n    }\n    return maxWord;\n\
    }\n</code>\n<|/ a dscore=5 |>\n<| a dscore=4 tags=c#,algorithm |>\nHere's an example\
    \ of using LINQ to solve this:\n<code>\npublic string GetLongestString(string[]\
    \ array)\n{\n    return array.GroupBy(s => s)\n                .OrderByDescending(s\
    \ => s.Count())\n                .First()\n                .Key;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=4 tags=c#,algorithm |>\n<code>\npublic string GetLongestString(string[]\
    \ array)\n{\n    StringBuilder sb = new StringBuilder();\n    foreach (string\
    \ str in array)\n    {\n        int count = 0;\n        foreach (char c in str)\n\
    \        {\n            if (c == '-') count = count + 1;\n        }\n        if\
    \ (count > sb.Length)\n        {\n            sb.Append(str);\n        }\n   \
    \ }\n    return sb.ToString();\n}\n</code>\n<|/ a |>\n<| c |>\nI wonder how that\
    \ performs compared to the accepted answer. Would you mind telling us which one\
    \ performs better?\n<|/ c |>\n<| c |>\n, i think this is O(n) algorithm and accepted\
    \ answer is O(n^2).\n<|/ c |>", "{\n    int unique_count = unordered_set<int>().size();\n\
    \    foreach (string word in words)\n    {\n        int count = unordered_set<char>().count();\n\
    \        if (unique_count < count)\n            unique_count = count;\n    }",
  "{\n\t/*\n\t1. Sort the array in lexicographical order\n\t2. Find the first element\
    \ which contains maximum count of unique characters\n\t3. Return the word which\
    \ has minimum unique characters and lexicographical order\n\t*/\n\tsort(words);\n\
    \tint index = 0;\n\tstring word;\n\tint max_count = 0, min_count = 0, max_index\
    \ = -1;\n\tint unique_count = 0;\n\t\n\tfor(int i = 0; i < words.length; i++){\n\
    \t\tword = words[i];\n\t\tunique_count = 0;\n\t\tfor (int j = 0; j < word.length();\
    \ j++){\n\t\t\tunique_count = unique_count + std.string.length(words[j]);\n\t\t\
    }\n\t\tif (max_count == unique_count){\n\t\t\tmax_count = unique_count;\n\t\t\t\
    max_index = index;\n\t\t}\n\t\tif (unique_count < min_count){\n\t\t\tmin_count\
    \ = unique_count;\n\t\t\tindex = i;\n\t\t}\n\t\tunique_count = 0;\n\t}\n\treturn\
    \ words[max_index];\n}\n/*\nWrite a function that accepts an array of strings.\n\
    \    The array contains different words. Return the word with minimum number\n\
    \    of unique characters. If multiple strings have minimum number of unique\n\
    \    characters, return the one which comes first in lexicographical order.",
  "{\n    sort(words);\n    int max = 1;\n    int min = words[0].length();\n    \n\
    \    for (int i = 0; i < words.length; ++i) {\n        if (words[i].length() >\
    \ max) {\n            max = words[i].length();\n        }\n    }\n    for (int\
    \ i = 0; i < words.length; ++i) {\n        if (words[i].length() == max) {\n \
    \           if (words[i].compare(words[max-1]) >= 0) {\n                return\
    \ words[i];\n            }\n        }\n    }\n    return words[0];\n}\n/*\nWrite\
    \ a function that accepts an array of strings.\n    The array contains different\
    \ words. Return all the words with maximum number\n    of unique characters. If\
    \ multiple strings have maximum number of unique\n    characters, return the one\
    \ which comes first in lexicographical order.", "{\n  \n    struct {\n       \
    \ map<int, int> m;\n        map<int, int> m1;\n    }m={{0, 0}, {0,0}};\n    int\
    \ maxCount=0;\n    foreach(string word, words) {\n        int count=0;\n     \
    \   foreach(char letter, word) {\n            int count=m.m[letter]++ ;\n    \
    \        int count1=m.m1[letter]++ ;\n            m.m[letter]=count1;\n      \
    \      m.m1[letter]=count;\n        }\n        if(maxCount<count){\n         \
    \   foreach(char letter, word) {\n                m.m[letter]=0;\n           \
    \     m.m1[letter]=0;\n            }\n            maxCount=count;\n        }\n\
    \    }\n    \n    foreach(string word, words) {\n        int count=0;\n      \
    \  foreach(char letter, word) {\n            int count=m.m[letter]++ ;\n     \
    \       int count1=m.m1[letter]++ ;\n            m.m[letter]=count1;\n       \
    \     m.m1[letter]=count;\n        }\n        if(maxCount==count){\n         \
    \   if(count<word.length()) {\n                return word;\n            }\n \
    \       }\n    }\n    return words[0];\n}\n</code>\n<|/ a dscore=1 tags=algorithm,string,c++,std\
    \ |>\n<| c |>\nYou don't need to store the result as a map; if you use `std::unordered_map`\
    \ the algorithm runs in O(N) time.\n<|/ c |>\n<| c |>\nI used map because I am\
    \ thinking about implementing the same algorithm using hashmap\n<|/ c |>\n<| c\
    \ |>\n`std::unordered_map` runs in `O(1)` time (`O(N)` if the hash table is implemented\
    \ with a hash table :-)\n<|/ c |>\n<| c |>\n`unordered_map` may get you `O(N)`\
    \ performance depending on the implementation, though.\n<|/ c |>\n<| c |>\nNo,\
    \ I mean that the whole algorithm runs in `O(N)` if the hash table is implemented\
    \ with a hash table :-) But yes, it may be less efficient than a normal hash table.\n\
    <|/ c |>\n<| a dscore=1 |>\nMy simple solution: use std::map with custom comparator\n\
    <code>\n#include <iostream>\n#include <algorithm>\n#include <cctype>\n#include\
    \ <string>\n#include <map>\n#include <numeric>", "{\n    int maxIndex = -1;\n\
    \    int maxNum = 0;\n    int curNum = 0;", "{\n    unordered_map<char, int> m;\n\
    \    for(int i=0; i<words.length(); i++) {\n        m[words[i]]++;\n    }\n  \
    \  sort(words.begin(), words.end(), compare);\n    int best = 0;\n    for(int\
    \ i=0; i<words.length(); i++) {\n        m[words[i]]--;\n        if(m[words[i]]\
    \ > best) {\n            best = m[words[i]];\n        }\n    }\n    return words[best];\n\
    }", "{\n\tint unique = 0;\n\tstring max = words[0];\n\tfor (int i=1; i<words.length;\
    \ i++) \n\t{\n\t\tint count = 0;\n\t\tfor (int j=0; j<words[i].length(); j++)\
    \ \n\t\t{\n\t\t\tif (words[i][j] == 'a' || words[i][j] == 'e' || words[i][j] ==\
    \ 'i' ||\n\t\t\t\twords[i][j] == 'o' || words[i][j] == 'u' || words[i][j] == 'Y')\n\
    \t\t\t\tcount++;\n\t\t}\n\t\tif (count>unique)\n\t\t\tmax = words[i];\n\t\tunique\
    \ = count;\n\t}\n\treturn max;\n}\n</cell>\n<cell>\n%nbdev_hide\n#Testing code\n\
    words = [\"hello\", \"world\", \"foo\", \"bar\", \"a\", \"foo\", \"bar\", \"foo\"\
    ]\nfind_max(words)\n</cell>\n<text>\nNone Happy Coding", "{\n    int max = 0;\n\
    \    string maxWord = words[0];\n    for(int i = 0; i < words.length; i++) {\n\
    \        if(words[i].length() > maxWord.length()) {\n            maxWord = words[i];\n\
    \            max = words[i].length();\n        }\n    }\n    return maxWord;\n\
    }", "{\n\tmap<int, int> m;\n\tfor (int i = 0; i < words.length; ++i) {\n\t\tm[words[i]]\
    \ += 1;\n\t}\n\tfor (auto m : m) {\n\t\tif (m.second > 0) return m.first;\n\t\
    }\n\treturn words[0];\n}\n/*\nWrite a function that accepts an array of integers.\
    \ \nReturn a list of those elements which are divisible by 3\n(including 0, if\
    \ needed).", "{\n    int[,] letters = new int[words.length, words[0].length];\n\
    \    for (int i = 0; i < words.length; i++) \n    {\n        for (int j = 0; j\
    \ < words[i].length; j++) \n        {\n            if (letters[i, j] <= 0) \n\
    \            {\n                letters[i, j] = 1;\n            }\n          \
    \  else \n            {\n                letters[i, j]++;\n            }\n   \
    \     }\n    }", "{\n    size_t max = 0;\n    string temp;\n    for(auto i : words)\
    \ {\n        int chars = std.string.length(i);\n        if (chars > max) {\n \
    \           temp = i;\n            max = chars;\n        }\n    }\n    return\
    \ temp;\n}\n</code>\n<|/ a tags=string,c++ |>\n<| a dscore=0 |>\nSince my solution\
    \ isn't the best one, I give it a try:\n<code>\nstring find_max(string[] words)\
    \ \n{\n    string results[words.length];\n    bool flags[words.length];\n    size_t\
    \ curIndex = 0;\n    size_t maxCount = words[0].length();\n    for (size_t index\
    \ = 0; index < words.length; index++)\n    {\n        flags[index] = false;\n\
    \        results[index] = words[index];\n    }\n    while (curIndex < words.length)\n\
    \    {\n        for (size_t index = 0; index < words.length; index++)\n      \
    \  {\n            if (results[index].length() > maxCount)\n            {\n   \
    \             flags[index] = true;\n                results[index] = words[index];\n\
    \                maxCount = results[index].length();\n            }\n        }\n\
    \        if (flags[curIndex])\n        {\n            curIndex++;\n        }\n\
    \    }\n    return maxCount > words[0].length() ? maxCount : words[0].length();\n\
    }\n</code>\n<|/ a tags=string,c++ |>\n<| a dscore=0 |>\n<code>\n#include <bits/stdc++.h>\n\
    using namespace std;", "{\n    int n = words.length;\n    int max = 0;\n    int\
    \ maxCount = 0;\n    bool found = false;\n    for(int i = 0; i < n; i++)\n   \
    \ {\n        found = maxCount == 0;\n        for(int j = 0; j < n; j++)\n    \
    \    {\n            if(i == j)\n            {\n                continue;\n   \
    \         }\n            string word = words[j];\n            int len = word.length();\n\
    \            int count = 0;\n            for(int k = 0; k < len; k++)\n      \
    \      {\n                if(word.charAt(k) == words[i].charAt(k))\n         \
    \       {\n                    count++;\n                }\n            }\n  \
    \          if(count > maxCount)\n            {\n                max = count;\n\
    \                maxCount = count;\n                found = true;\n          \
    \  }\n        }\n        if(found)\n            break;\n    }\n    if(maxCount\
    \ == 0 && found)\n        return \"no match\";\n    return words[max];\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis solution does not handle multiple occurrences\
    \ of the same string correctly (e.g. `find_max([\"aaaaaaa\", \"aaaaa\", \"bb\"\
    , \"cc\"])` returns `\"aaaaa\"` instead of `\"aaaaaaa\"`).\n<|/ c |>\n<| c |>\n\
    Thanks for pointing out that. I was working on it and now its corrected. I will\
    \ also post the solution for multiple occurrences correctly.\n<|/ c |>\n<| c |>\n\
    The solution for multiple occurrences is now posted too.\n<|/ c |>\n<| a tags=algorithm\
    \ |>\n<code>\n//O(N) time and O(1) space\nimport java.util.HashMap;\nimport java.util.Map;",
  "{\n    stack<string> s;\n    for (int i = 0; i < (int)words.length; i++)\n    {\n\
    \        if (s.empty() || words[i].length() != s[s.size()].length())\n       \
    \ {\n            s.push(words[i]);\n        }\n        else\n        {\n     \
    \       if (s[s.size()] < words[i])\n            {\n                s.push(words[i]);\n\
    \            }\n        }\n    }\n    return (!s.empty() ? s[s.size()] : \"\"\
    );\n}\n</cell>\n<cell>\n%run \"..\\\\funcs\\\\code_utils.py\"\n</cell>\n<cell>\n\
    %run \"..\\\\funcs\\\\word_analysis.py\"\n</cell>\n<cell>\n%run \"..\\\\funcs\\\
    \\find_max.py\"\n</cell>\n<cell>\n%run \"..\\\\funcs\\\\find_min.py\"\n</cell>\n\
    <cell>\n%run \"..\\\\funcs\\\\find_median.py\"\n</cell>\n<text>\nFunction for\
    \ finding kth Smallest Element", "{\n\tint max = 0;\n\tstring word = null;\n\t\
    int count = 0;\n\tfor(int i = 0; i < words.length; i++)\n\t{\n\t\tif(words[i].length()\
    \ > max)\n\t\t{\n\t\t\tmax = words[i].length();\n\t\t\tword = words[i];\n\t\t\
    }\n\t\tif(words[i].length() == max)\n\t\t\tcount++;\n\t}\n\t\n\treturn word;\n\
    }\n/*\nWrite a function that accepts an array of strings and a string. The array\n\
    contains different words. Return true if and only if the array contains one or\n\
    more words that contain the string in lexicographical order.", "{\n    int total\
    \ = 0;\n    int max;\n    for(int i = 0; i < words.length; ++i)\n    {\n     \
    \   total += std.typecons.length(words[i]);\n        if(total > max)\n       \
    \ {\n            max = total;\n        }\n    }\n    for(int i = 0; i < words.length;\
    \ ++i)\n    {\n        total -= std.typecons.length(words[i]);\n        if(total\
    \ > max)\n        {\n            max = total;\n        }\n    }\n    return words[max];\n\
    }", "{\n    int counter = 0;\n    int max = 0;\n    string word = \"\";", "{\n\
    \    int highest = words.length;\n    int max = words[0];\n    for(int i = 1;\
    \ i < words.length; i++){\n        if (words[i].length() > words[highest].length()){\n\
    \            highest = i;\n            max = words[i];\n        }\n    }\n   \
    \ return max;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is not working. I'm\
    \ getting an index out of range exception on this line: \"string max = words[0];\"\
    \n<|/ c |>\n<| c |>\nIt should work now, had an error in the logic\n<|/ c |>\n\
    <| a tags=algorithm,c# dscore=0 |>\nHere is my code\n<code>\nstatic void Main(string[]\
    \ args)\n    {\n        string[] words = new string[] { \"and\", \"a\", \"be\"\
    , \"my\", \"apple\", \"is\", \"in\", \"my\", \"family\", \"and\", \"the\", \"\
    apple\", \"is\", \"not\", \"in\", \"my\", \"family\" };\n        string word =\
    \ \"\";\n        int max = 0;\n        for (int i = 0; i < words.Length; i++)\n\
    \        {\n            if (words.Length - 1 == i) word = words[i];\n        \
    \    else word = words[i] + \" \" + words[i + 1];\n            if (word.Count(x\
    \ => x == words[i].Substring(0, word.Length - 1)) == word.Length)\n          \
    \  {\n                if (word.Count(x => x == words[i].Substring(0, word.Length\
    \ - 1)) > max)\n                {\n                    max = word.Count(x => x\
    \ == words[i].Substring(0, word.Length - 1));\n                    word = words[i];\n\
    \                }\n            }\n        }\n        Console.WriteLine(word);\n\
    \    }\n</code>\n<|/ a |>\n<| a dscore=0 |>\nHere is my code:\n<code>\nclass Program\n\
    {\n    static void Main(string[] args)\n    {\n        string[] words = { \"and\"\
    , \"a\", \"be\", \"my\", \"apple\", \"is\", \"in\", \"my\", \"family\", \"and\"\
    , \"the\", \"apple\", \"is\", \"not\", \"in\", \"my\", \"family\" };\n       \
    \ string word = string.Empty;\n        int maxCount = 0;\n        int maxIndex\
    \ = -1;\n        for (int i = 0; i < words.Length; i++)\n        {\n         \
    \   if (i == 0)\n            {\n                word = words[i];\n           \
    \     continue;\n            }\n            if (words[i].Length == 0)\n      \
    \      {\n                continue;\n            }\n            string nextWord\
    \ = words[i];\n            for (int j = i + 1; j < words.Length; j++)\n      \
    \      {\n                if (j == words.Length - 1)\n                {\n    \
    \                break;\n                }\n                nextWord += \" \"\
    \ + words[j];\n            }\n            if (nextWord.Count(c => c == nextWord.Substring(0,\
    \ nextWord.Length - 1)) == nextWord.Length)\n            {\n                int\
    \ count = nextWord.Count(c => c == ", "{\n\tint maxcount = 0;\n\t\n\tfor (int\
    \ i = 0; i < words.length; i++){\n\t\tint count = 0;\n\t\tfor (int j = 0; j <\
    \ words[i].length(); j++){\n\t\t\tcount++;\n\t\t}\n\t\tif (count > maxcount){\n\
    \t\t\tmaxcount = count;\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < words.length; i++){\n\
    \t\tint count = 0;\n\t\tfor (int j = 0; j < words[i].length(); j++){\n\t\t\tcount++;\n\
    \t\t}\n\t\tif (count > maxcount){\n\t\t\treturn words[i];\n\t\t}\n\t}\n\treturn\
    \ null;\n}", "{\n    int result = 1;\n    for(int i = 1; i < words.length; ++i)\n\
    \        result = max(result, words[i].length());\n    string result = words[0];\n\
    \    for(int i = 1; i < words.length; ++i)\n    {\n        if(words[i].length()\
    \ > result)\n            result = words[i].length();\n    }\n    return result;\n\
    }", "{\n  unordered_map<string, size_t> counts;\n  vector<string> strings;\n \
    \ for (const string& word: words) {\n    size_t count = counts[word];\n    if\
    \ (count != 0) {\n      strings[count] = word;\n    }\n    counts[word] = counts.size();\n\
    \  }\n  return strings[max_element(counts.begin(), counts.end())->second];\n}",
  "{\n    string max;\n    int counter = 0;\n    foreach (string w in words) {\n \
    \       if(!std.is_empty(max)) {\n            int c = std.len(w);\n          \
    \  if (c > std.len(max)) {\n                max = w;\n            }\n        }\n\
    \        else {\n            max = w;\n        }\n    }\n    foreach (string w\
    \ in words) {\n        int c = std.len(w);\n        if (std.is_empty(max)) {\n\
    \            return w;\n        }\n        else if (c > std.len(max)) {\n    \
    \        return w;\n        }\n        else if (c == std.len(max)) {\n       \
    \     counter++;\n        }\n    }\n    if(std.is_empty(max)) {\n        return\
    \ max;\n    }\n    return max;\n}\n</code>\n<|/ a tags=string,arrays,algorithm\
    \ |>\n<| a dscore=2 |>\n<code>\n#include <stdio.h>\n#include <string.h>\n#include\
    \ <stdlib.h>", "{\n    int charNum = 0;\n    string maxString = \"\";\n    for\
    \ (int i = 0; i < words.length; i++) {\n        if (charNum == 0) {\n        \
    \    maxString = words[i];\n            charNum += words[i].length();\n      \
    \  }\n        else {\n            if (words[i].length() > maxString.length())\
    \ {\n                maxString = words[i];\n                charNum += words[i].length();\n\
    \            }\n        }\n    }\n    return maxString;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nHi Tasos Kanavos,\nThank you very much. Would you please give me\
    \ a hint on how I could implement your code in my existing code?\n<|/ c |>\n<|\
    \ c |>\nSure, Please see my updated answer.\n<|/ c |>\n<| c |>\nHi Tasos Kanavos,\
    \ thank you very much for your help and support. I am getting the following error\
    \ message when I try to run this code: `error: cannot find symbol\n      private\
    \ void initialize(int n, int m, int t) {\n                                   \
    \    ^\n  symbol:   variable n\n  location: class LinkedList\n1 error\n`\n<|/\
    \ c |>\n<| c |>\nI am also getting a similar error when I try to run this: `error:\
    \ cannot find symbol\n        if (t == 0)\n            throw new ArithmeticException(\"\
    Error: negative value of t.\");\n            ^\n  symbol:   variable t\n  location:\
    \ class LinkedList\n1 error\n`\n<|/ c |>\n<| c |>\nI am also getting a similar\
    \ error when I try to run this: `error: cannot find symbol\n                else\
    \ {\n                    throw new ArithmeticException(\"Error: negative value\
    \ of t.\");\n                }\n                ^\n  symbol:   variable t\n  location:\
    \ class LinkedList\n1 error\n`\n<|/ c |>\n<| a dscore=0 |>\nThank you everyone\
    \ for your help and support. I ended up solving the problem in a different way,\
    \ using the solution provided by Tasos Kanavos and Toni Allison.\nHere is the\
    \ code I used - it is slightly different from Toni Allison's code since it uses\
    \ a different method of counting the characters in each word and calculating with\
    \ the longest word:\n<code>\nimport java.util.LinkedList;\npublic class MyClass\
    \ {", "{\n    int maxChar = 0;\n    int maxIndex = -1;\n    for(int i = 0; i <\
    \ words.length(); i++)\n    {\n        int count = 0;\n        for(int j = 0;\
    \ j < words[i].length(); j++)\n        {\n            int c = words[i][j] - 'a';\n\
    \            if(c == maxChar)\n            {\n                count++;\n     \
    \       }\n            else\n            {\n                if(count > maxCount)\n\
    \                {\n                    maxChar = c;\n                    maxIndex\
    \ = i;\n                    maxCount = count;\n                }\n           \
    \ }\n        }\n    }\n    return words[maxIndex];\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis does not really answer the question asked.\n<|/ c |>\n<| c |>\nThe\
    \ question is asking for an algorithm to return the word with most number of characters.\
    \ Your algorithm only returns the most common character of the words. I'm sure\
    \ there are other issues with the algorithm. Do you have a better algorithm?\n\
    <|/ c |>\n<| c |>\nThe question was how to get the word with most number of characters.\
    \ But you still haven't answered this question yet.\n<|/ c |>\n<| c |>\nThe question\
    \ was how to get the word with most number of characters, which is what I provided\
    \ the algorithm.\n<|/ c |>\n<| c |>\nBut how does the algorithm decide if two\
    \ words have the same amount of unique characters? That's what I'm trying to understand\
    \ here.\n<|/ c |>\n<| a |>\n<code>\n// Return the word with maximum number of\
    \ unique characters.\nstring findMaxUniqueChars(string words[])\n{\n    int maxIndex\
    \ = 0;\n    int maxCharCount = 0;\n    for(int i = 0; i < words.length(); i++)\n\
    \    {\n        int count = 0;\n        for(int j = 0; j < words[i].length();\
    \ j++)\n        {\n            int c = words[i][j] - 'a';\n            if(c ==\
    \ maxCharCount)\n            {\n                count++;\n            }\n    \
    \        else\n            {\n                if(count > maxCharCount)\n     \
    \           {\n                    maxCharCount = c;\n                    maxIndex\
    \ = i;\n                }\n            }\n        }\n    }\n    return words[maxIndex];\n\
    }\n</code>\n<|/ a tags=string,algorithm,c++ dscore=1 |>\n<| c |>\nThe question\
    \ was how to get the word with most number of characters, which is what I provided\
    \ the algorithm.\n<|/ c |>\n<| c |>\nBut this doesn't solve the problem of having\
    \ the same amount of unique characters\n<|/ c |>\n<| c |>\nIt does solve the problem\
    \ of having the same amount of unique characters\n<|/ c |>\n<| a |>\nHere's an\
    \ implementation in Python:", "{\n    map<int, int> map;\n    map<int, int>::iterator\
    \ itr;\n    int maxCount = 0;\n    foreach(string s in words)\n    {\n       \
    \ itr = map.find(maxCount);\n        if(itr != map.end())\n        {\n       \
    \     string temp = s;\n            if(itr->second > 0)\n                temp\
    \ = s;\n            string temp2 = s;\n            if(itr->second > 1)\n     \
    \           temp2 = s;\n            if(temp > temp2)\n                temp = s;\n\
    \        }\n        else\n        {\n            map.insert(pair<int, int>(maxCount,\
    \ s.length()));\n        }\n        maxCount++;\n    }\n    int maxCount2 = 0;\n\
    \    foreach(string s in words)\n    {\n        itr = map.find(maxCount2);\n \
    \       if(itr != map.end())\n        {\n            string temp = s;\n      \
    \      if(itr->second > 0)\n                temp = s;\n            string temp2\
    \ = s;\n            if(itr->second > 1)\n                temp2 = s;\n        \
    \    if(temp > temp2)\n                temp = s;\n        }\n        else\n  \
    \      {\n            map.insert(pair<int, int>(maxCount2, s.length()));\n   \
    \     }\n        maxCount2++;\n    }\n    map<int, int>::iterator itr2;\n    string\
    \ result = \"\";\n    itr2 = map.begin();\n    while(itr2 != map.end())\n    {\n\
    \        if(itr2->second > 0)\n        {\n            result += itr2->first;\n\
    \            result += \"-\";\n        }\n        itr2++;\n    }\n    return result;\n\
    }", "{\n    size_t max = numeric_limits<size_t>::max();\n    size_t maxIndex =\
    \ 0;\n    string cur = words[maxIndex];\n    for (size_t i = 1; i < words.length;\
    \ ++i)\n    {\n        size_t count = 0;\n        for (size_t j = 0; j < words[i].length();\
    \ ++j)\n        {\n            if (words[i][j] == cur[j])\n                ++count;\n\
    \        }\n        if (count == words[i].length() && max < count)\n        {\n\
    \            max = count;\n            maxIndex = i;\n            cur = words[maxIndex];\n\
    \        }\n    }\n    return cur;\n}\n</code>\n<|/ a |>\n<| a tags=c++ |>\nHere\
    \ is a solution using STL algorithm and lambda function\n<code>\n#include <iostream>\n\
    #include <algorithm>\n#include <vector>\n#include <string>", "{\n\tint maxCount\
    \ = 0;\n\tstring maxWord = \"\";", "{\n   string maxWord = \"\";\n   if(words.length\
    \ == 0)\n      return maxWord;", "{\n    set <string> seen;\n    string max;",
  "{\n    //Your code here\n    map<string, int> unique;\n    foreach (word w in words)\
    \ {\n        string letters = \"\";\n        int i = 0;\n        foreach (char\
    \ c in w) {\n            if (i == 0) letters += c;\n            else if (c ==\
    \ letters[i - 1]) letters += c;\n            else {\n                if (!unique.containsKey(letters))\
    \ unique[letters] += 1;\n                else unique[letters] = max(unique[letters],\
    \ 1);\n            }\n            i++;\n        }\n    }\n    string maxKey =\
    \ unique.keys().max();\n    map<string, int> maxValue = unique[maxKey];\n    if\
    \ (maxValue != 1) maxValue += 1;\n    return maxKey;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis solution works perfectly for small arrays but gives wrong results\
    \ for large arrays. I changed `maxValue = unique[maxKey]; if (maxValue != 1) maxValue\
    \ += 1;` to `maxValue = unique[maxKey];\nif (maxValue != 1) maxValue = maxValue+1;`\
    \ and it worked for me.\n<|/ c |>\n<| a dscore=1 |>\n<code>\n// Write a function\
    \ that accepts an array of strings.\n// The array contains different words. Return\
    \ the word with maximum number\n// of unique characters. If multiple strings have\
    \ maximum number of unique\n// characters, return the one which comes first in\
    \ lexicographical order.", "{\n    /*\n    TODO: Replace this block of code with\
    \ your own\n    implementation\n    */\n    int i,j,k,l=0;\n    int n = 0;\n \
    \   for (i = 0; i < words.length; i++){\n        for (j = 0; j < words[i].length();\
    \ j++){\n            for (k = 0; k < words[i].length(); k++){\n              \
    \  if (words[i][j] == words[i][k]){\n                    n++;\n              \
    \  }\n            }\n        }\n    }\n    vector<int> u;\n    u.reserve(words.length);\n\
    \    for (i = 0; i < words.length; i++){\n        u.push_back(n);\n    }\n   \
    \ sort(u.begin(),u.end());\n    return u[l];\n}\n</code>\n<|/ a dscore=0 tags=algorithm,python\
    \ |>\n<| a dscore=0 |>\nThis solution is based on the fact that the words are\
    \ stored in lexicographical order, and that they only contain lowercase letters.\
    \ There are some optimizations left for you to consider.\n<code>\ndef longestCommonPrefix(words):\n\
    \    if words == []:\n        return \"\"\n    length = len(words[0])\n    common\
    \ = []\n    for i in range(length):\n        for j in range(len(words)):\n   \
    \         if words[j][i] == words[0][i]:\n                common.append(words[j][i])\n\
    \                break\n        if len(common) > length:\n            length =\
    \ len(common)\n            common = []\n    if common != []:\n        return longestCommonPrefix(common)\n\
    \    else:\n        return \"\"\n</code>\n<|/ a tags=algorithm,python |>\n<| a\
    \ dscore=0 |>\nThis code will find the longest common prefix and length of the\
    \ common prefix for multiple inputs without using any extra space for the strings.\n\
    <code>\ndef longestCommonPrefix(words):\n    if len(words) == 0:\n        return\
    \ \"\"\n    smallestWordLen = min([len(word) for word in words])\n    for word\
    \ in words:\n        if len(word) < smallestWordLen:\n            smallestWordLen\
    \ = len(word)\n    commonPrefix = [word[0] for word in words if word[:smallestWordLen]\
    \ == words[0][:smallestWordLen]]\n    return commonPrefix[commonPrefix.index(commonPrefix[0])]\n\
    </code>\n<|/ a tags=algorithm,python |>\n<| c |>\nThis does not answer the question.\
    \ Question asks about longest common prefix for multiple strings.\n<|/ c |>\n\
    <| c |>\nThis gives a different result from the OP's expected output.\n<|/ c |>\n\
    <| a tags=algorithm,python dscore=0 |>\n<code>\ndef find_prefix(string, list):\n\
    \    list = []\n    ans = \"\"\n    for i in string:\n        list.insert(0,i)\n\
    \    if len(list) < 2:\n        return \"\"\n    prefix_word = ", "{\n    map<string,\
    \ int> count;\n    for (string word : words) \n    {\n        auto it = count.find(word);\n\
    \        if (it == count.end()) \n        {\n            count[word] = 0;\n  \
    \      } \n        else \n        {\n            count[word] = count[word] + 1;\n\
    \        }\n    }", "{\n\tint maxNum = 0;\n\tstring word = \"\";\n\tfor (int i\
    \ = 0; i < words.length; i++)\n\t{\n\t\tstring temp = words[i];\n\t\tint numOfUniqueChars\
    \ = 1;\n\t\tfor (int j = 0; j < temp.length(); j++)\n\t\t{\n\t\t\tchar ch = temp.at(j);\n\
    \t\t\tif (std.typecons.contains(uniqueChars[ch]))\n\t\t\t{\n\t\t\t\tnumOfUniqueChars++;\n\
    \t\t\t}\n\t\t}\n\t\tif (numOfUniqueChars > maxNum)\n\t\t{\n\t\t\tmaxNum = numOfUniqueChars;\n\
    \t\t\tword = temp;\n\t\t}\n\t}\n\treturn word;\n}", "{\n    \n    map<int, char>\
    \ map;\n    int maxCount = 0;\n    for(int i=0;i<words.length; i++)\n    {\n \
    \       map[words[i]]++;\n        if (map[words[i]]>maxCount)\n        {\n   \
    \         maxCount = map[words[i]];\n        }\n    }\n    \n    bool sorted =\
    \ true;\n    int index = 0;\n    while (sorted && index<words.length)\n    {\n\
    \        if (map[words[index]]>map[words[index+1]])\n        {\n            sorted\
    \ = false;\n        }\n        else\n        {\n            index++;\n       \
    \ }\n    }\n    if (sorted)\n    {\n        return words[index];\n    }\n    else\
    \ \n    {\n        return find_max(words,index,words[index]);\n    }\n}\n</code>\n\
    <|/ a dscore=0 tags=algorithm,sorting |>\n<| c |>\nWelcome to Stack Overflow!\
    \ While this code snippet may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| c |>\nThanks, I am new on StackOverflow\
    \ and I did not know how to do it.\n<|/ c |>\n<| a tags=algorithm,sorting |>\n\
    <code>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include\
    \ <map>\nusing namespace std;", "{\n    string result = \"\";\n    int max = words[0].size();\n\
    \    for (int i = 0; i < words.length; i++)\n    {\n        int len = words[i].size();\n\
    \        if (len > max)\n        {\n            max = len;\n            result\
    \ = words[i];\n        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=python,algorithm\
    \ |>\n<| c |>\nYou can't have a variable in the inner scope of the loop in the\
    \ C code.\n<|/ c |>\n<| c |>\n: Please read the post carefully. This solution\
    \ is in Python.\n<|/ c |>\n<| c |>\n: I have added a Python version as well.\n\
    <|/ c |>\n<| c |>\nThis solution is so much clearer. Thank you!\n<|/ c |>\n<|\
    \ a |>\nHere is an iterative version of the algorithm that you described in your\
    \ question. Let me know if you have any questions about how I implemented this.\
    \ I also added some test cases to the solution below.\n<code>\ndef maxLengthWord(words):\n\
    \    words = sorted(words, key=lambda w: len(w))\n    wordCounts = {}\n    longestWord\
    \ = \"\"\n    for i in range(len(words)):\n        if words[i] not in wordCounts:\n\
    \            wordCounts[words[i]] = 1\n        else:\n            wordCounts[words[i]]\
    \ += 1\n        if wordCounts[words[i]] == 1:\n            longestWord = words[i]\n\
    \        elif wordCounts[words[i]] > 1:\n            longestWord = words[i]\n\
    \    return longestWord", "{\n    string max;\n    int counter = 0;\n    bool\
    \ duplicateFound = false;", "{\n    int maxCnt = 0;\n    int i = 0;\n    int j\
    \ = words.length;", "{\n    int nUnique = 0;\n    int index = 0;\n    int max\
    \ = words[0];", "{\n\t\n\tstring word;\n\tint maxLength = 0;\n\tfor (int i = 0;\
    \ i < words.length; ++i)\n\t{\n\t\tword = words[i];\n\t\tint numOfChar = word.size();\n\
    \t\tif (numOfChar > maxLength)\n\t\t{\n\t\t\tmaxLength = numOfChar;\n\t\t\tword\
    \ = words[i];\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < words.length; ++i)\n\t{\n\
    \t\tword = words[i];\n\t\tint numOfChar = word.size();\n\t\tif (numOfChar > maxLength)\n\
    \t\t{\n\t\t\tmaxLength = numOfChar;\n\t\t\tword = words[i];\n\t\t}\n\t}\n\treturn\
    \ word;\n}", "{\n\tint maxLen = 0, bestIndex = -1;\n\tfor (int i = 0; i < words.length;\
    \ i++)\n\t{\n\t\tint uniqueChars = std.typecons.count_if(words.begin(), words.end(),\
    \ \n\t\t\t[=](string w){ return w.length == 0; });\n\t\tif (uniqueChars > maxLen)\n\
    \t\t{\n\t\t\tmaxLen = uniqueChars;\n\t\t\tbestIndex = i;\n\t\t}\n\t}\n\tif (maxLen\
    \ == words[bestIndex].length) return words[bestIndex];\n\telse return words[bestIndex];\n\
    }\n/*\nWrite a function that accepts an array of integers. Return the sum of the\
    \ elements.", "{\n    /*\n    Your code here!\n    */\n    int n = words.length;\n\
    \    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(words[i].length()>words[j].length()){\n\
    \                string temp = words[i];\n                words[i] = words[j];\n\
    \                words[j] = temp;\n            }\n        }\n    }\n    int max\
    \ = 0;\n    string result=\"\";\n    for(int i=0;i<n;i++){\n        if(words[i].length()==words[max].length()){\n\
    \            if(words[i].compare(words[max])<0){\n                max = i;\n \
    \           }\n        }\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n\
    \            if(words[i].length()==words[j].length()){\n                if(words[i].compare(words[j])<0){\n\
    \                    string temp = words[i];\n                    words[i] = words[j];\n\
    \                    words[j] = temp;\n                }\n            }\n    \
    \    }\n    }\n    if(words[max].compare(words[result])>0){\n        result =\
    \ words[max];\n    }\n    return result;\n}", "{\n    map<string, int> m; // map\
    \ string - number of unique chars\n    for(string word: words)\n        m[word]\
    \ = m[word] ? m[word] + 1 : 1;", "{\n    // code goes here\n}", "{\n  int numchars\
    \ = std.typecons.int();\n  int maxchars = 0;\n  string result = \"\";\n  foreach\
    \ (string str in words) {\n    int[] uniquechars = std.math.ints(str.chars);\n\
    \    int totalchars = std.typecons.int();\n    foreach (int i in uniquechars)\
    \ totalchars += i;\n    if (totalchars > maxchars) {\n      maxchars = totalchars;\n\
    \      result = str;\n    }\n  }\n  return result;\n}\n</cell>\n<cell>\n%%swip\n\
    /*\nWrite a function that accepts an array of strings.\n    The array contains\
    \ different words. Return an array of strings which contains\n    all the words\
    \ with maximum number of unique characters. If multiple strings have\n    maximum\
    \ number of unique characters, return array of those which comes first in\n  \
    \  lexicographical order.", "{\n    sort(words);\n    int max=words[0].len();\n\
    \    for(int i=0;i<words.length;i++){\n        if(words[i].len()>max){\n     \
    \       max=words[i].len();\n        }\n    }\n    return words[words.length-1];\n\
    }", "{\n    int[] counter = new int[256];\n    int max_counter = 0;\n    int result\
    \ = 0;\n    for(int i = 0; i < words.length; i++){\n        int count = 0;\n \
    \       for(int j = 0; j < words[i].length; j++){\n            if(counter[words[i][j]]\
    \ != 0)\n                count++;\n            counter[words[i][j]] = 1;\n   \
    \     }\n        if (count > max_counter){\n            max_counter = count;\n\
    \            result = words[i];\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=algorithm,string,arrays |>\nIf we can get rid of\
    \ the extra spaces and only consider alphabets from a-z or A-Z and digits, we\
    \ can achieve this in O(n) time.\n<code>\nimport java.util.*;\nimport java.lang.*;\n\
    import java.io.*;\nclass Ideone\n{\n    public static void main (String[] args)\
    \ throws java.lang.Exception\n    {\n        ArrayList<String> words = new ArrayList<String>();\n\
    \        Scanner sc = new Scanner(System.in);\n        while(sc.hasNext())\n \
    \       {\n            words.add(sc.next());\n        }\n        Collections.sort(words);\n\
    \        System.out.println(\"Word: \" + words.get(words.size() - 1));\n    }\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a |>\nWe can use HashMap to achieve this in\
    \ O(n) time. ", "{\n    int count = 0;\n    int max = 0;\n    string maxString\
    \ = \"\";\n    foreach(var word in words) {\n        foreach(var letter in word)\
    \ {\n            count++;\n        }\n        if(count == max) {\n           \
    \ maxString = word;\n            max = count;\n        }\n        count = 0;\n\
    \    }\n    return maxString;\n}\n/*\nWrite a function that accepts an array of\
    \ strings.\n    The array contains different words. Return all the words with\
    \ maximum\n    number of unique characters. If multiple strings have maximum number\
    \ of unique\n    characters, return the one which comes first in lexicographical\
    \ order.\n    >>> find_max2([\"name\", \"of\", \"string\"])\n    \"string\"\n\
    \    >>> find_max2([\"name\", \"enam\", \"game\"])\n    \"enam\"\n    >>> find_max2([\"\
    aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n    \n*/\nstring[] find_max2(string[]\
    \ words) \n{\n    int count = 0;\n    int max = 0;\n    string maxString = \"\"\
    ;\n    foreach(var word in words) {\n        foreach(var letter in word) {\n \
    \           count++;\n        }\n        if(count == max) {\n            maxString\
    \ = word;\n            max = count;\n        }\n        count = 0;\n    }\n  \
    \  return new string[] {maxString};\n}\n/*\nWrite a function that accepts an array\
    \ of strings and integers. Return the\nstring with maximum number of unique characters.\
    \ If multiple strings have maximum\nnumber of unique characters, return the one\
    \ which comes first in lexicographical\norder.\n    >>> find_max3([\"name\", \"\
    of\", \"string\"], 3)\n    \"string\"\n    >>> find_max3([\"name\", \"enam\",\
    \ \"game\"], 2)\n    \"enam\"\n    >>> find_max3([\"aaaaaaa\", \"bb\", \"cc\"\
    ], 1)\n    \"aaaaaaa\"\n    \n*/\nstring find_max3(string[] words, int num) \n\
    {\n    int count = 0;\n    int max = 0;\n    string maxString = \"\";\n    foreach(var\
    \ word in words) {\n        foreach(var letter in word) {\n            count++;\n\
    \        }\n        if(count == max) {\n            maxString = word;\n      \
    \      max = count;\n        }\n        count = 0;\n    }\n    return maxString;\n\
    }\n/*\nWrite a function that accepts an array of strings and integers. Return\
    \ the\nstring with maximum number of unique characters. If multiple strings have\
    \ maximum\nnumber of unique characters, return the one which comes first in lexicographical\n\
    order.\n    >>> find_max4([\"name\", \"of\", \"string\"], 3)\n    \"string\"\n\
    \    >>> find_max4([\"name\", \"enam\", \"game\"], 2)\n    \"enam\"\n    >>> find_max4([\"\
    aaaaaaa\", \"bb\", \"cc\"], 1)\n    \"aaaa", "{\n    struct StringCount\n    {\n\
    \        string value;\n        int count;\n    }\n    struct StringCount* counts[100];\n\
    \    int count = 0;", "{\n  int n = words.length;\n  if (n == 0)\n    throw runtime_error(\"\
    cannot find max of an empty array\");\n  int count = 0;\n  int max_count = 0;\n\
    \  int max_pos = 0;\n  for (int i = 0; i < n; i++)\n  {\n    int num_chars = count(words[i],\
    \ ' ');\n    if (num_chars > max_count)\n    {\n      max_count = num_chars;\n\
    \      max_pos = i;\n    }\n  }\n  string ret(words[max_pos]);\n  for (int i =\
    \ 0; i < n; i++)\n  {\n    if (i != max_pos)\n    {\n      int num_chars = count(words[i],\
    \ ' ');\n      if (num_chars > max_count)\n      {\n        ret.clear();\n   \
    \     ret.swap(words[i]);\n        break;\n      }\n    }\n  }\n  return ret;\n\
    }", "{\n    int res = 0;\n    int max = 0;\n    for (int i = 0; i < words.length;\
    \ i++) \n    {\n        int x = words[i].length();\n        if (x > max) \n  \
    \      {\n            max = x;\n            res = i;\n        }\n    }\n    return\
    \ words[res];\n}", "{\n\tint[int] char_count = new int[256];\n\tfor(int i = 0;\
    \ i < words.length; i++) \n\t{\n\t\tfor(int j = 0; j < words[i].length; j++) \n\
    \t\t{\n\t\t\tchar_count[words[i][j]] ++;\n\t\t}\n\t}\n\tstring result = \"\";\n\
    \tfor(int i = 0; i < 256; i++)\n\t{\n\t\tif(char_count[i] == char_count[0])\n\t\
    \t\tcontinue;\n\t\tif(char_count[i] > char_count[0])\n\t\t\treturn words[i];\n\
    \t}\n\t\n}\n/*\nWrite a function that accepts an array of strings.\n    The array\
    \ contains different words. Return an array of strings which\n    contain only\
    \ words with the same amount of unique characters as in the\n    first string.",
  "{\n\tint n = words.length;\n\tint result = int.MaxValue;\n\tint j = 0;\n\tfor(int\
    \ i=0; i<n; i++)\n\t{\n\t\tint count = 1;\n\t\tfor(int k=0; k<j; k++)\n\t\t{\n\
    \t\t\tif(words[i].Length > words[k].Length)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t\
    }\n\t\t\tstring s = words[i].Substring(0,words[i].Length-1);\n\t\t\tfor(int l=0;\
    \ l<k; l++)\n\t\t\t{\n\t\t\t\tstring s2 = words[k].Substring(0,words[k].Length-1);\n\
    \t\t\t\tif(s == s2)\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t\tif(count > result)\n\t\t\t{\n\t\t\t\tresult = count;\n\t\t\t\
    \tj = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn words[j];\n}\n/*\nWrite a function that\
    \ accepts an array of strings.\n    The array contains different words. Return\
    \ the word with maximum number\n    of unique characters. If multiple strings\
    \ have maximum number of unique\n    characters, return the one which comes first\
    \ in lexicographical order.\n    \n    >>> find_max_1([\"name\", \"of\", \"string\"\
    ])\n    \"string\"\n    >>> find_max_1([\"name\", \"enam\", \"game\"])\n    \"\
    enam\"\n    >>> find_max_1([\"aaaaaaa\", \"bb\", \"cc\"])\n    \"aaaaaaa\"\n \
    \   \n*/\nstring find_max_1(string[] words) \n{\n\tint n = words.length;\n\tint\
    \ result = int.MaxValue;\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tint count = 1;\n\t\
    \tfor(int j=0; j<i; j++)\n\t\t{\n\t\t\tif(words[i].Length > words[j].Length)\n\
    \t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring s = words[i].Substring(0,words[i].Length-1);\n\
    \t\t\tstring s2 = words[j].Substring(0,words[j].Length-1);\n\t\t\tif(s == s2)\n\
    \t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(count > result)\n\
    \t\t{\n\t\t\tresult = count;\n\t\t}\n\t}\n\treturn words[i];\n}\n/*\nWrite a function\
    \ that accepts an array of strings and returns an array of\n    strings containing\
    \ only unique strings.", "{\n\tif (words.isEmpty()) {\n\t\tthrow new Exception(\"\
    Error: Array is empty.\");\n\t}\n\tchar firstChar = words[0].charAt(0);\n\tint[,]\
    \ count = new int[words.length + 1, 1];\n\tfor (int i = 0; i <= words.length;\
    \ i++) {\n\t\tint count = 0;\n\t\tfor (int j = 0; j < words[i].length; j++) {\n\
    \t\t\tif (words[i].charAt(j) == firstChar) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\
    }\n\t\tcount[i, 0] = count;\n\t}\n\tfor (int i = 0; i < words.length; i++) {\n\
    \t\tint maxCount = 0;\n\t\tfor (int j = 0; j < words[i].length; j++) {\n\t\t\t\
    if (count[i, 0] > maxCount) {\n\t\t\t\tmaxCount = count[i, 0];\n\t\t\t\tfirstChar\
    \ = words[i].charAt(j);\n\t\t\t}\n\t\t}\n\t}\n\tstring result = \"\";\n\tif (firstChar\
    \ < firstChar.toLowerCase()) {\n\t\tresult = firstChar;\n\t} else {\n\t\tresult\
    \ = firstChar.toLowerCase();\n\t}\n\tfor (int i = 0; i < words.length; i++) {\n\
    \t\tint maxCount = 0;\n\t\tfor (int j = 0; j < words[i].length; j++) {\n\t\t\t\
    if (count[i, 0] > maxCount) {\n\t\t\t\tmaxCount = count[i, 0];\n\t\t\t\tresult\
    \ = words[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n/*\nWrite a function\
    \ that accepts an array of strings.\n    The array contains different words. Return\
    \ the word with minimum number\n    of unique characters. If multiple strings\
    \ have minimum number of unique\n    characters, return the one which comes first\
    \ in lexicographical order.", "{\n\tint maxchars = 1;\n\tstring maxword = words[0];",
  "{\n    map<string, int> counter;\n    for(int i = 0; i < words.length; i++)\n \
    \   {\n        counter[words[i]] += 1;\n    }\n    auto max_count = *max_element(counter.begin(),\
    \ counter.end());\n    string max;\n    for(auto it = counter.begin(); it != counter.end();\
    \ it++)\n    {\n        if(it->second == max_count)\n        {\n            max\
    \ = it->first;\n        }\n    }\n    return max;\n}\n</code>\n<|/ a |>\n<| a\
    \ tags=arrays,c++,string dscore=2 |>\nI tried to solve the problem on paper but\
    \ could not find a way.\nThe problem is if I have 2 strings \"a\" and \"ab\",\
    \ I should return \"ab\". The only way I can think of is to keep track of number\
    \ of characters and then check which string has the maximum number of unique characters,\
    \ if I could get number of unique characters from each string, that would be a\
    \ nice solution. But I couldn't.\n<|/ a |>\n<| a tags=arrays,c++,string |>\n<code>\n\
    #include<iostream>\nusing namespace std;", "{\n    int count[128] = {0};\n   \
    \ foreach(string w in words)\n    {\n        foreach(char c in w)\n        {\n\
    \            int n = count[c];\n            count[c] = n + 1;\n        }\n   \
    \ }\n    int max = count[0];\n    int max_index = -1;\n    foreach(char c in count)\n\
    \    {\n        if(count[c] > max)\n        {\n            max = count[c];\n \
    \           max_index = c;\n        }\n    }\n    return words[max_index];\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nI don't think it's necessary to convert all\
    \ characters to lowercase.\n<|/ c |>\n<| c |>\n: Yes, it is. Otherwise the count\
    \ would not be correct.\n<|/ c |>\n<| a dscore=0 |>\nWe can do that with following\
    \ code in C++11.\n<code>\n#include <iostream>\n#include <algorithm>\n#include\
    \ <string>\n#include <unordered_map>\n#include <functional>\nusing namespace std;",
  "{\n    sort(words);\n    int count=0;\n    int maxCount=0;\n    for(string word:\
    \ words)\n    {\n        for(char c: word)\n        {\n            if(!(c in count))\n\
    \            {\n                count[c]=0;\n            }\n            count[c]++;\n\
    \            if(count[c]>=maxCount)\n            {\n                maxCount=count[c];\n\
    \                string temp=word;\n                word=word.replaceAll(count,\
    \ \"\");\n                word=word.replaceAll(maxCount, \"\");\n            \
    \    sort(word);\n                word=temp+word;\n            }\n        }\n\
    \    }\n    return words[0];\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n\
    string find_max(string str) \n{\n    string max=\"\";\n    int maxCount=0;\n \
    \   for(int i=0;i<str.size();i++)\n    {\n        for(int j=i;j<str.size();j++)\n\
    \        {\n            if(str[i]==str[j])\n            {\n                maxCount++;\n\
    \                break;\n            }\n        }\n        if(maxCount>str.size()\
    \ && maxCount>maxCount-1)\n        {\n            max=str[i];\n            maxCount=str.size();\n\
    \        }\n    }\n    return max;\n}\n</code>\n<|/ a tags=c++ |>\n<| a tags=c++\
    \ dscore=0 |>\n<code>\n int main()\n{\n    string words[5]={\"name\",\"of\",\"\
    string\",\"enam\",\"game\"};\n    sort(words);\n    for(int i=0;i<5;i++)\n   \
    \ {\n        for(int j=0;j<5;j++)\n        {\n            if(i!=j)\n         \
    \   {\n                if(words[i]>words[j])\n                {\n            \
    \        string temp=words[j];\n                    words[j]=words[i];\n     \
    \               words[i]=temp;\n                }\n            }\n        }\n\
    \    }\n    for(int i=0;i<5;i++)\n    {\n        cout<<words[i]<<endl;\n    }\n\
    \    return 0;\n}\n</code>\n<|/ a |>\n<| c |>\nThe question is tagged C++, not\
    \ C.  It would be useful to explain in English what your code is doing, instead\
    \ of just a block of code.\n<|/ c |>\n<| c |>\nThis does not provide an answer\
    \ to the question. Once you have sufficient [reputation](https://stackoverflow.com/help/whats-reputation)\
    \ you will be able to [comment on any post](https://stackoverflow.com/help/privileges/comment);\
    \ instead, [provide answers that don't require clarification from the asker](https://meta.stackexchange.com/questions/214173/why-",
  "{\n    int maxCharCount = 0;\n    \n    int maxCharIndex = 0;\n    \n    string\
    \ returnString = \"\";\n    \n    for (size_t i = 0; i < words.length(); i++)\n\
    \    {\n        auto ch = words[i].length();\n        if (maxCharCount < ch)\n\
    \        {\n            maxCharCount = ch;\n            maxCharIndex = i;\n  \
    \      }\n    }\n    \n    return returnString;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I believe this solution has time complexity of O(n * m) where n and m are the\
    \ number of elements in the array and m is the number of unique characters in\
    \ all the elements. Isn't this a better solution than O(n^2)?\n<|/ c |>\n<| c\
    \ |>\nI doubt it - for my solution you get O(n*m) but if you consider all the\
    \ possible combinations of m characters, that's just n! / (n! * n!) ~ O(n^2)\n\
    <|/ c |>\n<| c |>\nYou are right. But I thought this can be done in O(n). Thanks\
    \ anyways!\n<|/ c |>\n<| c |>\nWell I believe that it is O(n * m) where n is the\
    \ number of elements and m is the number of unique characters in all elements.\
    \ It is just a simple iteration and O(n) is O(n) because if m is big O(n) means\
    \ that it grows quicker than n. I am sorry for my mistake.\n<|/ c |>\n<| a dscore=2\
    \ |>\nFor starters, you need to be aware that sorting algorithms such as quicksort\
    \ and mergesort will take linear time in the number of elements.  Therefore, if\
    \ you want an algorithm that is linear time, you need to choose a sorting algorithm\
    \ that takes linear time in the number of elements.  As others have mentioned,\
    \ you could always take an approach like radix sort, which is linear time, in\
    \ number of elements.  Alternatively, you could use an in-place algorithm that\
    \ keeps track of the number of unique characters seen so far and updates the counter\
    \ when another character is seen.\n<|/ a tags=c++,algorithm,arrays |>\n<| a tags=c++,algorithm,arrays\
    \ dscore=2 |>\n<code>\n#include <algorithm>\n#include <bits/stdc++.h>\nusing namespace\
    \ std;", "{\n    map<string, int> m;\n    for (string word : words) \n       \
    \ m[word] += 1;\n    string word = m[max_key(m)];\n    return word;\n}\n</code>\n\
    <|/ a |>\n<| a tags=algorithm,c,string,arrays |>\nA simple solution in C is to\
    \ use a map to count the number of occurrences of each unique character and then\
    \ iterate through the map and print the character which has the maximum number\
    \ of occurrences.\n<code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\
    #include <stdint.h>\n#include <stdbool.h>", "{\n    map<int, int> maxCount;\n\
    \    for(auto &s : words) {\n        int count = 0;\n        for(int i = 0; i\
    \ < s.length(); i++) {\n            count++;\n            if(maxCount.find(i)\
    \ == maxCount.end()) {\n                maxCount[i] = count;\n            } else\
    \ {\n                if(maxCount[i] < count) {\n                    maxCount[i]\
    \ = count;\n                }\n            }\n        }\n    }\n    int max =\
    \ 1;\n    for(auto &s : words) {\n        if(maxCount.find(max) == maxCount.end())\
    \ {\n            max = maxCount[max];\n        } else {\n            if(maxCount[max]\
    \ < maxCount[maxCount[max]]) {\n                max = maxCount[max];\n       \
    \     }\n        }\n    }\n    return max;\n}", "{\n    // Your code here\n  \
    \  map<string, int> m;\n    foreach(word : words) \n        m[word] = 1;\n   \
    \ m[\"no\"] = 2;\n    m[\"no\"] = 1;\n    m[\"string\"] = 2;\n    m[\"string\"\
    ] = 1;\n    m[\"string\"] = 3;\n    m[\"string\"] = 4;\n    int max = 0;\n   \
    \ foreach(word : words)\n    {\n        auto it = m.find(word);\n        if(it\
    \ != m.end())\n        {\n            if(it->second > max)\n            {\n  \
    \              max = it->second;\n            }\n        }\n    }\n    foreach(word\
    \ : words)\n    {\n        auto it = m.find(word);\n        if(it != m.end())\n\
    \        {\n            if(it->second == max)\n            {\n               \
    \ if(it->first < words[0])\n                    words[0] = it->first;\n      \
    \      }\n        }\n    }\n    return words[0];\n}", "{\n    string res = words[0];\n\
    \    for(unsigned i = 0; i < words.length; ++i)\n        if(words[i].length()\
    \ > res[0].length())\n            res = words[i];\n    return res;\n}", "{\n\t\
    int counter = 0;\n\tstring max = words[0];\n\tfor (int i = 1; i < words.length;\
    \ i++) \n\t{\n\t\tif (words[i].Length > max)\n\t\t\tmax = words[i];\n\t}\n\tfor\
    \ (int i = 0; i < words.length; i++) \n\t{\n\t\tfor (int j = i + 1; j < words.length;\
    \ j++) \n\t\t{\n\t\t\tif (words[i].Length < words[j].Length) \n\t\t\t{\n\t\t\t\
    \tif (words[i].Length == max) \n\t\t\t\t{\n\t\t\t\t\treturn words[i];\n\t\t\t\t\
    }\n\t\t\t\tif (words[j].Length == max) \n\t\t\t\t{\n\t\t\t\t\treturn words[j];\n\
    \t\t\t\t}\n\t\t\t\tif (words[i].Length > words[j].Length) \n\t\t\t\t{\n\t\t\t\t\
    \tcounter = words[i].Length;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcounter\
    \ = words[j].Length;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}", "{\n\
    \    int max = 0, num = 0;\n    foreach (string s in words)\n    {\n        int\
    \ c = count(s);\n        if(c>max)\n        {\n            max = c;\n        \
    \    num = s;\n        }\n    }\n    return num;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nYou should change this part:\n````\nforeach (string s in words)\n   \
    \ {\n        int c = count(s);\n        if(c>max)\n        {\n            max\
    \ = c;\n            num = s;\n        }\n    }\n    return num;\n}\n````\n<|/\
    \ c |>\n<| c |>\n: That is wrong. Think about it. You only want to iterate through\
    \ the array one time. Hence the foreach.\n<|/ c |>\n<| c |>\n, Oh I see what you\
    \ mean now. Yes, it only iterates once.\n<|/ c |>\n<| a |>\nYou can use the LINQ\
    \ Aggregate method to do this in a very concise way:\n<code>\nstring maxWord =\
    \ words.Aggregate((a, b) => a.Length > b.Length ? a : b);\n</code>\n<|/ a tags=c#,winforms,arrays,loops\
    \ dscore=1 |>\n<| a tags=c#,winforms,arrays,loops dscore=1 |>\n<code>\nstring\
    \ array = \"Hello World\";\nchar[] charArray = array.ToCharArray();\nArray.Sort(charArray);\n\
    Console.WriteLine(charArray.Distinct().First());\n</code>\n<|/ a |>\n<| c |>\n\
    Thank you for your answer, but i do not want to use any array methods. I am looking\
    \ for a solution that does not use any array methods.\n<|/ c |>\n<| c |>\n: Why\
    \ do you think you can't use array methods?\n<|/ c |>\n<| c |>\n: They weren't\
    \ in the spec? http://msdn.microsoft.com/en-us/library/vstudio/bb338049(v=vs.100).aspx\n\
    <|/ c |>\n<| c |>\n: What is the criteria for deciding whether to use array methods\
    \ or not? The most obvious solution is to not use array methods. This is obviously\
    \ a homework assignment and we have no idea what your teacher wants or needs.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\nstring maxWord = string.Empty;", "{\n    int\
    \ len = words.length;\n    if (len < 1)\n        throw new Exception(\"Invalid\
    \ input\");\n    \n    int maxChars = words[0].size();\n    for(int i = 1; i <\
    \ len; i++)\n    {\n        int curChars = words[i].size();\n        if (curChars\
    \ > maxChars)\n        {\n            maxChars = curChars;\n        }\n    }",
  "{\n    bool flag = false;\n    int counts = std.typecons.max;\n    string maxWord\
    \ = \"\";\n    string maxVal = \"\";\n    foreach(string word in words){\n   \
    \     bool flag = false;\n        foreach(char c in word){\n            if(word.count(c)\
    \ == counts){\n                flag = true;\n                maxVal = word;\n\
    \                maxWord = word;\n                counts = std.typecons.max;\n\
    \                break;\n            }\n            else if(word.count(c) < counts){\n\
    \                counts = word.count(c);\n                maxVal = word;\n   \
    \             maxWord = word;\n            }\n        }\n        if(flag == false){\n\
    \            foreach(char c in word){\n                if(word.count(c) == counts){\n\
    \                    flag = true;\n                    maxVal = word;\n      \
    \              maxWord = word;\n                    counts = std.typecons.max;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return maxWord;\n}", "{\n    int[int] counts;\n    foru(int i = 0; i\
    \ < words.length; i++) \n    {\n        counts[count(words[i])] += 1;\n    }\n\
    \    return words[argmax(counts)];\n}\n</code>\n<|/ a tags=algorithm,performance,string,c++\
    \ dscore=0 |>\n<| c |>\nThis approach does not take advantage of the fact that\
    \ the question is specifically asking for lexicographical order as opposed to\
    \ alphabetical order.\n<|/ c |>\n<| c |>\nThis is exactly what I was looking for\
    \ and your solution is amazing! I'm going to study your code and understand it\
    \ better but to start off I'm going to take a guess that this approach uses some\
    \ sort of hashing algorithm that makes it so fast and efficient?\n<|/ c |>\n<|\
    \ c |>\nYes I used a hash table and I implemented it using C++.\n<|/ c |>\n<|\
    \ c |>\nThe code above is very inefficient since it computes counts[words[i]]\
    \ on every iteration, whereas all you need is to store counts[0] into counts[i]\
    \ and perform a one-time assignment when counts[0] changes. Also, it's missing\
    \ a return statement, so it won't work as written.\n<|/ c |>\n<| c |>\nI wrote\
    \ it in Python. I'm not really sure whether it's an efficient solution in C++\
    \ but I think that it is.\n<|/ c |>\n<| a |>\n<code>\nstring find_max(string words[],\
    \ int n, string word){\n    vector<int> counts(word.length(), 0);\n    for(int\
    \ i = 0; i < words.length; i++){\n        for(int j = word.size(); j > 0; j--){\n\
    \            if(words[i][j-1] != word[j]) break;\n            counts[j-1]++;\n\
    \        }\n        if(counts[0] >= counts[i]) counts[0] = counts[i];\n    }\n\
    \    return words[counts[word.length()-1]];\n}\n</code>\n<|/ a dscore=0 tags=algorithm,performance,string,c++\
    \ |>\n<| c |>\nThis approach does not take advantage of the fact that the question\
    \ is specifically asking for lexicographical order as opposed to alphabetical\
    \ order.\n<|/ c |>\n<| a |>\n<code>\n#include <bits/stdc++.h>\nusing namespace\
    \ std;", "{\n    int m = 0, n = 0;\n    map<string, int> m;\n    foreach (string\
    \ w in words)\n    {\n        n = m[w];\n        if (n > m)\n        {\n     \
    \       m = n;\n        }\n        else\n        {\n            if (n < m)\n \
    \           {\n                m = n;\n            }\n        }\n        m[w]\
    \ += 1;\n    }\n    return m.keys.toArray()[0]; \n}\n</code>\n<|/ a dscore=1 tags=string,python\
    \ |>\n<| a |>\nA possible solution is to count the unique characters in each word\
    \ in the array and find the word which has the highest frequency of unique characters.\n\
    <code>\ndef find_max(words):\n    word_dict = {}\n    for i in words:\n      \
    \  unique_chars = set(i.lower())\n        if len(unique_chars) > len(word_dict):\n\
    \            word_dict = unique_chars\n    \n    return word_dict.values()\n</code>\n\
    <|/ a tags=string,python dscore=1 |>\n<| a tags=string,python |>\nTry this one:\n\
    <code>\nfrom collections import Counter\ndef find_max(words):\n    cnt = Counter()\n\
    \    for word in words:\n        cnt.update(set(word.lower()))\n    max_length\
    \ = max(cnt.values())\n    for key, value in cnt.items():\n        if value ==\
    \  max_length:\n            return key\n</code>\n<|/ a dscore=1 |>\n<| a |>\n\
    You can use the collections.Counter class:\n<code>\nfrom collections import Counter",
  "{\n    int max = 1;\n    string maxString = \"\";\n    for (int i = 0; i < words.length;\
    \ i++) \n    {\n        if (words[i].length() > max)\n        {\n            maxString\
    \  = words[i];\n            max = words[i].length();\n        }\n    }\n    if\
    \ (max == 1) return maxString;\n    \n    int min = 1;\n    for (int i = 0; i\
    \ < words.length; i++) \n    {\n        if (words[i].length() >= min) \n     \
    \   {\n            if (words[i].length() > max) \n                maxString =\
    \ words[i];\n            min = words[i].length();\n        }\n    }\n    return\
    \ maxString;\n}", "{\n    /*\n    Your code here\n    */\n    string result =\
    \ \"\";\n    int max = 1;\n    foreach (string word in words)\n    {\n       \
    \ int count = 0;\n        foreach (char c in word)\n        {\n            if\
    \ (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n            {\n\
    \                count += 1;\n            }\n        }\n        if (count > max)\n\
    \        {\n            max = count;\n            result = word;\n        }\n\
    \    }\n    if (result == \"\")\n    {\n        foreach (string word in words)\n\
    \        {\n            int count = 0;\n            foreach (char c in word)\n\
    \            {\n                if (c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n                {\n                    count += 1;\n         \
    \       }\n            }\n            if (count > max)\n            {\n      \
    \          max = count;\n                result = word;\n            }\n     \
    \   }\n    }\n    return result;\n}", "{\n    map<string, int> map;\n    \n  \
    \  for (auto word: words) {\n        map[word] = 0;\n    }\n    \n    sort(words.begin(),\
    \ words.end());\n    \n    for (auto word: words) {\n        map[word]++;\n  \
    \  }\n    \n    int max = words[0].length();\n    \n    for (auto word: words)\
    \ {\n        if (map[word] > map[words[words.find(word)]]) {\n            max\
    \ = map[word];\n        }\n    }\n    \n    return words[words.find(max)]; \n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=c++ |>\nHere's my version. It\
    \ returns the same output as the accepted solution, although I'm sure there's\
    \ a more elegant way! I've also tried to make it as simple as possible, so it\
    \ uses only one map.\n<code>\n#include <string>\n#include <vector>\n#include <map>\n\
    using namespace std;", "{\n    map<string, int> wordCount;\n    map<string, int>\
    \ tempCount;", "{\n    unordered_set<string> names;\n    for (auto word : words)\n\
    \    {\n        auto chars = word.length();\n        if (names.count(chars))\n\
    \        {\n            if (names.at(chars) < word)\n                names[chars]\
    \ = word;\n        }\n        else\n            names[chars] = word;\n    }",
  "{\n    map<string, int> max_count; int max_length = 0;\n    foreach(string word,\
    \ words){\n        foreach(char c, word){\n            if(!max_count.containsKey(c)){\n\
    \                max_length++;\n                max_count.put(c,1);\n        \
    \    }\n            else{\n                max_count.get(c);\n            }\n\
    \        }\n    }", "{\n    int max = 0;\n    string result = \"\";\n    for(int\
    \ i = 0; i < words.length; ++i)\n        for(int j = 1; j <= words[i].length();\
    \ j++)\n            if(words[i].length() > max)\n            {\n             \
    \   max = words[i].length();\n                result = words[i];\n           \
    \ }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThe code as posted does\
    \ not compile; there are several syntax errors.\n<|/ c |>\n<| c |>\nThanks for\
    \ your comment. I edited my answer and included a full working code.\n<|/ c |>\n\
    <| a tags=c#,sorting,arrays,unique |>\nYou don't need a Linq solution just for\
    \ that. You can do it in O(n) using a HashSet and just iterate over the words\
    \ in the dictionary and add to the HashSet. The time complexity of the HashSet.Add\
    \ is O(1) so you get an O(n) solution.\n<code>\nstring findMax(string []words)\n\
    {\n    HashSet<string> hs = new HashSet<string>();\n    string result = \"\";\n\
    \    foreach(string word in words)\n        if(!hs.Add(word))\n            result\
    \ = word;\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nHe said\
    \ \"with O(n) solution\", not \"without Linq solution\"\n<|/ c |>\n<| c |>\nThanks\
    \ for your comment, you are right and I corrected my answer.\n<|/ c |>\n<| c |>\n\
    O(n) solution is also the most optimal solution, because it doesn't iterate over\
    \ the input twice (once to sort, and once for finding max).\n<|/ c |>\n<| a dscore=1\
    \ |>\nMy first idea was to use a dictionary to hold the unique words with a int\
    \ counter and to compare words with the same length with the counter from the\
    \ dictionary:\n<code>\nstatic string findMax(string []words)\n{\n    Dictionary<string,\
    \ int> dictionary = new Dictionary<string, int>();", "{\n    int n = words.length;\n\
    \    int count = std.length(words);\n    \n    int best = std.length(words[0]);\n\
    \    for(int i=1; i<n; i++)\n    {\n        int tmp = std.length(words[i]);\n\
    \        if(tmp > best)\n        {\n            best = tmp;\n            best\
    \ = i;\n        }\n    }\n    \n    return words[best];\n}\n</cell>\n<cell>\n\
    import std.random;\nimport std.randomstream;\n/*\nWrite a function that accepts\
    \ an array of strings and an integer n, \nwhere n is the number of random words\
    \ from the array of strings. Return the n random words from the array of strings.\
    \ \nIf n is not present in the array, add n random words from other arrays to\
    \ the array of strings. \nIf there are less strings than n elements, choose all\
    \ strings from array. \n*/", "{\n    string result;\n    int max_count = -1;\n\
    \    for(int i = 0; i < words.length; ++i)\n    {\n        int current_count =\
    \ count(words[i]);\n        if(current_count > max_count)\n        {\n       \
    \     max_count = current_count;\n            result = words[i];\n        }\n\
    \    }\n    return result;\n}", "{\n    var maxCharCount = 0;\n    var longest\
    \ = 0;\n    foreach(string word in words)\n    {\n        int cCount = 0;\n  \
    \      foreach(char ch in word)\n        {\n            cCount += charCount(ch);\n\
    \        }\n        if(cCount > maxCharCount)\n        {\n            maxCharCount\
    \ = cCount;\n            longest = word;\n        }\n    }\n    return longest;\n\
    }", "{\n    map<string, int> m;\n    map<int, string> m2;\n    \n    map<string,\
    \ int>::iterator it;\n    int count = 0;\n    map<int, string>::iterator it2;\n\
    \    int count2 = 0;\n    \n    for(it = m.begin(); it != m.end(); it++)\n   \
    \ {\n        int n = it->second;\n        \n        for(it2 = m2.begin(); it2\
    \ != m2.end(); it2++)\n        {\n            int n2 = it2->second;\n        \
    \    \n            if(n == n2)\n            {\n                if(it2->first <\
    \ it->first)\n                {\n                    string temp = it->first;\n\
    \                    it->first = it2->first;\n                    it2->first =\
    \ temp;\n                }\n                \n                it->second++;\n\
    \                it2->second++;\n            }\n        }\n    }\n    \n    for(it\
    \ = m2.begin(); it != m2.end(); it++)\n    {\n        if(it->second > count)\n\
    \        {\n            count = it->second;\n        }\n    }\n    \n    for(it\
    \ = m2.begin(); it != m2.end(); it++)\n    {\n        if(it->second > count2)\n\
    \        {\n            count2 = it->second;\n        }\n    }\n    \n    if(count2\
    \ == count)\n    {\n        string temp = count;\n        count = count2;\n  \
    \      count2 = temp;\n    }\n    \n    return it->first;\n}", "{\n    // Write\
    \ your function here\n    int max_unique = words[0].unique();\n    int max_index\
    \ = -1;\n    for (int i = 1; i < words.length; ++i) {\n        int unique = words[i].unique();\n\
    \        if (unique > max_unique) {\n            max_unique = unique;\n      \
    \      max_index = i;\n        } else if (unique == max_unique) {\n          \
    \  if (words[max_index] < words[i]) {\n                max_index = i;\n      \
    \      }\n        }\n    }\n    return words[max_index];\n}\n</code>\n<|/ a dscore=3\
    \ tags=arrays,c,algorithm |>\n<| c |>\nIt would be nice if you could add some\
    \ explanation of your solution.\n<|/ c |>\n<| a tags=arrays,c,algorithm |>\n<code>\n\
    // Given an array of integers arr[] and a positive integer n.\n// Find a pair\
    \ of integers (x, y) such that x is less than or equal to\n// n and y is greater\
    \ than or equal to 0 and y is less than or equal to\n// arr[x] and x is greater\
    \ than or equal to arr[y].\n// Return x if it is possible to find the pair otherwise\
    \ return -1.", "{\n    int numChars = count(words);\n    int maxCharNum = numChars;\n\
    \    int index;\n    for(int i = 0; i < words.length; ++i) {\n        index =\
    \ numChars - 1;\n        for(int j = numChars - 1; j >= 0; --j) \n           \
    \ if(words[i].compare(words[j]) > 0) \n                index = j;\n        if(index\
    \ != numChars - 1) {\n            swap(words[i], words[index]);\n            --numChars;\n\
    \            if(numChars == 0)\n                maxCharNum = maxCharNum - 1;\n\
    \        }\n    }\n    return words[maxCharNum];\n}", "{\n   int[] nums=new int[100];\n\
    \   int count=0;\n   foreach (string w; words)\n   {\n      int index=0;\n   \
    \   foreach(char c in w)\n         if (nums[c]<nums[index])\n         {\n    \
    \        index++;\n            if (nums[index] > nums[c])\n            {\n   \
    \            string temp=w;\n               w=words[index];\n               words[index]=temp;\n\
    \            }\n         }\n      nums[w]++;\n      count++;\n   }\n   return\
    \ words[count-1];\n}", "{\n\t/*\n\tStart by grouping all words that have same\
    \ number of unique characters\n\tinto a single list.\n\t*/\n\tmap<string, int>\
    \ countMap;\n\tfor (int i = 0; i < words.length; i++) \n\t{\n\t\tstring curr =\
    \ words[i];\n\t\tint count = 0;\n\t\tfor (int j = 0; j < words.length; j++)\n\t\
    \t{\n\t\t\tif (i != j && curr == words[j])\n\t\t\t\tcount++;\n\t\t}\n\t\tif (count\
    \ > 0) \n\t\t{\n\t\t\tcountMap[curr] = count;\n\t\t}\n\t}", "{\n    int count=0;\n\
    \    string word = null;\n    for(int i=0;i<words.length();i++)\n    {\n     \
    \   string temp = words[i];\n        for(int j=i+1;j<words.length();j++)\n   \
    \     {\n            string temp = words[j];\n            int count = std.algorithmic.unique(temp);\n\
    \            if(count>count)\n            {\n                count = std.algorithmic.unique(temp);\n\
    \                word = temp;\n            }\n        }\n    }\n    return word;\n\
    }", "{\n    string maxWord = words[0];\n    int maxNum = 0;\n    int len = words.length;\n\
    \    for(int i = 1; i < len; ++i)\n    {\n        int numUnique = numUniqueChars(words[i]);\n\
    \        if(numUnique > maxNum)\n        {\n            maxNum = numUnique;\n\
    \            maxWord = words[i];\n        }\n    }\n    return maxWord;\n}\n/*\n\
    Write a function that accepts an array of strings and an integer 'n'.\n    The\
    \ function should return an array of strings of size 'n' with all\n    unique\
    \ characters of all the strings in the given array.", "{\n    int i, j, n, count_unique\
    \ = 0;\n    string word;", "{\n    int counter = 1;\n    for(int i = 0; i < words.length;\
    \ i++)\n    {\n        if (words[i].length() > counter)\n        {\n         \
    \   counter = words[i].length();\n        }\n    }\n    \n    int max = 0;\n \
    \   for(int i = 0; i < words.length; i++)\n    {\n        if (words[i].length()\
    \ == max)\n        {\n            continue;\n        }\n        \n        if (words[i].length()\
    \ > max)\n        {\n            max = words[i].length();\n        }\n    }\n\
    \    \n    for(int i = 0; i < words.length; i++)\n    {\n        if (words[i].length()\
    \ != max)\n        {\n            continue;\n        }\n        \n        if (words[i].length()\
    \ > counter)\n        {\n            counter = words[i].length();\n        }\n\
    \    }\n    \n    for(int i = 0; i < words.length; i++)\n    {\n        if (words[i].length()\
    \ > counter)\n        {\n            counter = words[i].length();\n        }\n\
    \    }\n    \n    return words[counter];\n}", "{\n    map <int, int> m = new map();\n\
    \    foreach (string word in words)\n    {\n        auto it = m.find(word.length);\n\
    \        if (it == m.end())\n        {\n            int i = 1;\n            m.insert(pair<int,\
    \ int>(word.length, i++));\n        }\n        else\n        {\n            int\
    \ i = it->second;\n            it->second = i;\n        }\n    }\n    \n    int\
    \ maxLen = -1;\n    int maxI = -1;\n    foreach(auto it, m)\n    {\n        if\
    \ (maxLen < it->first)\n        {\n            maxLen = it->first;\n         \
    \   maxI = it->second;\n        }\n    }\n    \n    return words[maxI];\n}\n</cell>\n\
    <text>\nExercise 3"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
