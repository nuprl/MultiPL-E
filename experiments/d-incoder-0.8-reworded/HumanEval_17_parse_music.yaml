name: HumanEval_17_parse_music
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Input to this function is a\
  \ string representing musical notes in a special ASCII format.\n    Your task is\
  \ to parse this string and return array of integers corresponding to how many beats\
  \ does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts\
  \ four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts\
  \ one beat\n\n    >>> parse_music(\"o o| .| o| o| .| .| .| .| o o\")\n    [4L, 2L,\
  \ 1L, 2L, 2L, 1L, 1L, 1L, 1L, 4L, 4L]\n    \n*/\nlong[] parse_music(string music_string)\
  \ \n"
tests: "unittest\n{\n    alias candidate = parse_music;\n\n    assert(candidate(\"\
  \") == []);\n    assert(candidate(\"o o o o\") == [4L, 4L, 4L, 4L]);\n    assert(candidate(\"\
  .| .| .| .|\") == [1L, 1L, 1L, 1L]);\n    assert(candidate(\"o| o| .| .| o o o o\"\
  ) == [2L, 2L, 1L, 1L, 4L, 4L, 4L, 4L]);\n    assert(candidate(\"o| .| o| .| o o|\
  \ o o|\") == [2L, 1L, 2L, 1L, 4L, 2L, 4L, 2L]);\n}\nvoid main(){}"
completions: ["{\n    int n = music_string.length() - 1;\n    string rest = music_string.substr(0,\
    \ n);\n    long[] res = new long[n];\n    for (int i = 0; i < n; i++)\n    {\n\
    \        string note = music_string.substr(i + 1, 1);\n        string modifier\
    \ = \"\";\n        switch (note)\n        {\n            case \"o\": modifier\
    \ = \".\";\n                break;\n            case \"|\": modifier = \"o\";\n\
    \                break;\n            default: modifier = \"\";\n             \
    \   break;\n        }\n        res[i] = 4;\n        rest += modifier;\n    }\n\
    \    return res;\n}", "{\n    int[] nums = new int[7];\n    for (int i = 0; i\
    \ < music_string.length; i += 4)\n    {\n        long note = strtoul(music_string.Substring(i,\
    \ 4), nullptr, 10);\n        long note_type = note%12;\n        int beats = note/12;\n\
    \        nums[note_type] += beats;\n    }\n    return nums;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThank you for the help. It works as expected. I'm a bit new to\
    \ programming, and I had no idea about .Substring() method. So thanks for the\
    \ explanation as well!\n<|/ c |>\n<| c |>\nThis looks very nice, but note that\
    \ the \"| .\" case is also parsed as a single \"o\" note.\n<|/ c |>\n<| c |>\n\
    Yeah, that's true. That's why I said \"your task is to parse this string and return\
    \ array of integers corresponding to how many beats does each not last\". I just\
    \ want to give him an idea of how to solve his problem, not fully doing his homework\
    \ for him. Of course, I would not have known this problem if I had known this\
    \ one. I'm very glad that I have been of help, and I apologize for my late reply.\
    \ Have a nice day.\n<|/ c |>\n<| a dscore=1 |>\nHere's a recursive implementation\
    \ using only std library functions. The idea is to keep track of the current note\
    \ type and current beat, and only increment the note type if the current note\
    \ type is the same as the last note type.\n<code>\n// Given string containing\
    \ musical notation of notes and beat count\nvector<int> parse(const string &s)\
    \ {\n  // Track last note type and current beat\n  int note_prev = 0;\n  int beat_prev\
    \ = 0;", "{\n    var n = 0;\n    var beats = new[];\n    var index = 0;\n    var\
    \ beats_size = 0;\n    var beats_index = 0;", "{\n    int[] beats_per_bar = new\
    \ int[128];\n    string[] notes = music_string.split(' ');\n    int n_notes =\
    \ notes.Length;\n    foreach(string note in notes)\n    {\n        if(note.Length\
    \ == 1) // it's an octave \n            note = note[0] + '.';\n        int note_index\
    \ = note.ToCharArray()[0] - '0';\n        beats_per_bar[note_index] ++;\n    }\n\
    \    return beats_per_bar;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nThis is a\
    \ very good solution however one more thing is to add another condition to make\
    \ it more dynamic. You don't have to hard code the array size, but you can take\
    \ advantage of the fact that the notes are in ASCII chars and they start with\
    \ 0 to 9. So you can just create an array of a larger size and then just initialize\
    \ it to zeros so you can add new elements to it dynamically.\n<code>\n#include\
    \ <iostream>\n#include <cmath>\n#include <cstdlib>", "{\n   long beats = 1;\n\
    \   bool first = true;\n   foreach (char c in music_string)\n   {\n      if (c\
    \ == 'o')\n      {\n         if (!first)\n            beats++;\n         first\
    \ = false;\n      }\n      else if (c == 'o|')\n      {\n         if (!first)\n\
    \            beats++;\n         first = false;\n      }\n      else if (c == '.|')\n\
    \      {\n         if (!first)\n            beats++;\n         first = false;\n\
    \      }\n      else\n      {\n         if (first)\n            beats = 1;\n \
    \     }\n   }\n   return beats;\n}\n</code>\n<|/ a tags=java,arrays,string |>\n\
    <| c |>\nThank you very much!\n<|/ c |>\n<| c |>\nThank you very much for the\
    \ help!\n<|/ c |>\n<| a dscore=0 |>\n<code>\nString notes=\"o o| .| o| o| .| .|\
    \ .| .| o o\";\n</code>\nI suggest you to create a map (i.e. HashMap). This map\
    \ will contain note names as keys and beat numbers as values. So in your example,\
    \ map will have key \"o\" and value \"4\". So in the end, you will have a map\
    \ which holds number of beats per each note.\n<|/ a tags=java,arrays,string |>\n\
    <| a |>\nYou can use a HashMap of ArrayList of Integers to count each time a note\
    \ is played, and then get the array of the HashMap with your keys. \n<code>\n\
    HashMap<String, ArrayList<Integer>> map = new HashMap<String, ArrayList<Integer>>();",
  "{\n    //Initialize counters, total beats counter and empty array\n    int total_beats=0;\n\
    \    long[] beats = new long[128];", "{\n  // convert music string into a list\
    \ of note positions \n  string[] notes = music_string.split(\" \");", "{\n   \
    \ char[] music = music_string.ToCharArray();\n    int note_count = 0;\n    long[]\
    \ note_lengths = new long[music.Length];\n    \n    note_count = music.Length;\n\
    \    \n    for (int i = 0; i < music.Length; i++)\n    {\n        string s = \"\
    \";\n        \n        if (music[i] == 'o')\n        {\n            s += \"o\"\
    ;\n            note_count--;\n        }\n        else if (music[i] == '|')\n \
    \       {\n            s += \"o|\";\n            note_count--;\n        }\n  \
    \      else if (music[i] == '|')\n        {\n            s += \".|\";\n      \
    \      note_count--;\n        }\n        else\n        {\n            throw new\
    \ Exception(\"Incorrect note string \" + music[i]);\n        }\n        \n   \
    \     note_lengths[i] = note_count;\n    }\n    return note_lengths;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nOh, I see! I was actually really confused about how\
    \ I should go about this. I didn't think about how I should go about splitting\
    \ the string by `|` and then using each one individually to go through and get\
    \ the notes. Thanks a ton!\n<|/ c |>\n<| c |>\nAs a side note, if you need to\
    \ get rid of the spaces around the note strings, then just add `s = s.Trim();`\
    \ before the `note_count = s.Length;` line.\n<|/ c |>\n<| c |>\nThanks! This code\
    \ isn't perfect; I'm still trying to understand it, but I think I can get it working\
    \ with some tweaking.\n<|/ c |>\n<| a |>\nThe question has already been answered,\
    \ but I would suggest using the following approach.\nThe string parsing is actually\
    \ quite easy, you just need to split the string by | and iterate over its characters.\
    \ Then you can simply compare your character with the ones in the char[] {'o',\
    \ '|', '.'}.\nExample:\n<code>\nstring input = \"o o| .| o| o| .| .| .| .| o o\"\
    ;", "{\n    long[] beats_array = new long[128];", "{\n  long result[] = new long[music_string.Length/2];\n\
    \  int count = 0;\n  for (int i=0; i<music_string.Length; i++)\n  {\n    if (music_string[i]\
    \ == '.') \n    {\n      if (count == result.Length) \n      {\n        result\
    \ = new long[count+1];\n        count = result.Length;\n      }\n      result[count]++;\n\
    \    }\n    else if (music_string[i] == '|')\n    {\n      if (count == result.Length)\
    \ \n      {\n        result = new long[count+1];\n        count = result.Length;\n\
    \      }\n      result[count]++;\n      result[count+1]++;\n      count++;\n \
    \   }\n    else if (music_string[i] == 'o')\n    {\n      if (count == result.Length)\
    \ \n      {\n        result = new long[count+1];\n        count = result.Length;\n\
    \      }\n      result[count]++;\n      result[count+1]++;\n      count++;\n \
    \   }\n  }\n  return result;\n}\n</code>\n<|/ a tags=c#,algorithm,arrays |>\n\
    <| c |>\nAs a note, the code above works fine on ASCII strings, not unicode, but\
    \ just to point out that the original question was specifically asking for an\
    \ algorithm, not a solution.\n<|/ c |>\n<| a tags=c#,algorithm,arrays |>\n<code>\n\
    public List<int> GetNotes(string notes)\n{\n    var notes = notes.TrimEnd('o').Split(new[]\
    \ { '|', 'o', '.' }, StringSplitOptions.RemoveEmptyEntries);", "{\n    long[]\
    \ notes = \n    {\n        0, 0, 0, 0,\n        0, 0, 0, 0,\n        0, 0, 0,\
    \ 0,\n    };", "{\n    //create array to store values\n    long results[] = new\
    \ long[music_string.size()];", "{\n    long[] notes = new long[128];\n    string\
    \ note = string.Empty;", "{\n    // your code here\n    List<int> notes = music_string.split(\"\
    \ \").map(int.parse).toList();\n    int max_note = notes.last;\n    int note_count\
    \ = notes.length;", "{\n    var notes = music_string.split('|');\n    long[] result\
    \ = new long[notes.length];\n    for (var i = 0; i < notes.length; i++) \n   \
    \ {\n        var note = notes[i];\n        if (note.charAt(0) == 'o') \n     \
    \   {\n            result[i] = 4;\n        }\n        else if (note.charAt(0)\
    \ == '.') \n        {\n            result[i] = 2;\n        }\n        else if\
    \ (note.charAt(0) == '|') \n        {\n            result[i] = 1;\n        }\n\
    \    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nYour solution looks\
    \ interesting, however it is giving me `java.lang.StringIndexOutOfBoundsException:\
    \ String index out of range: -1`, any idea why? I'm on Java 8.\n<|/ c |>\n<| c\
    \ |>\nI guess your `music_string` is an empty string, make sure it has at least\
    \ two characters in it. Also, did you copy it exactly as it is? I tested it with\
    \ [this code](https://ideone.com/gGJk5T) and it works just fine.\n<|/ c |>\n<|\
    \ c |>\nI copied your code exactly and it works for you, but for me it doesn't\
    \ work for me, and that's probably because I'm on Java 8. I'm going to try that\
    \ on Java 7 and see if it works.\n<|/ c |>\n<| c |>\nIf that won't help, try using\
    \ [this code](https://ideone.com/iL0tP7) instead, I've edited my answer.\n<|/\
    \ c |>\n<| c |>\nI did exactly that and I'm still getting `java.lang.StringIndexOutOfBoundsException:\
    \ String index out of range: -1`. I'm running your code in [this online compiler\
    \ of mine](https://onlinegdb.com/H1uG4vjXK).\n<|/ c |>\n<| a |>\nJust for fun,\
    \ here's a solution using regex:\n<code>\npublic static void main(String[] args)\
    \ {\n    String music = \n            \"o o| .| o| o| .| .| .| .| .| o o\";\n\
    \    Matcher m = Pattern.compile(\"(^o|^.|^\\\\|)\").matcher(music);\n    List<Integer>\
    \ beats = new ArrayList<>();\n    while (m.find()) {\n        beats.add(Integer.parseInt(m.group(1)));\n\
    \    }\n    System.out.println(beats);\n}\n</code>\nThe regex says:", "{\n   \
    \ /*\n         Notes on this function:", "{\n    int beats_per_note = 4 / 4;\n\
    \    long notes_length = 0;\n    int beat_counter = 0;\n    int note_counter =\
    \ 0;", "{\n    long notes[] = new long[26];\n    int beats = 0;\n    int note;\n\
    \    int index = 0;\n    for (index = 0; index < music_string.length(); index++)\
    \ {\n        note = music_string.codePointAt(index);\n        switch (note) {\n\
    \            case 'o': notes[index] = (beats + 4); beats += 1; break;\n      \
    \      case 'o|': notes[index] = (beats + 2); beats += 1; break;\n           \
    \ case '.|': notes[index] = (beats + 1); beats += 1; break;\n        }\n    }\n\
    \    return notes;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis is a very good\
    \ solution and I appreciate the time you put into it for posting this answer.\
    \ I am working on a solution using the method that I posted above that involves\
    \ using a hashmap to store all the notes as keys and then using that hashmap to\
    \ return the note count for each note in the song. Would that be ok?\n<|/ c |>\n\
    <| c |>\nThe only problem that I can see with your solution above is the fact\
    \ that I am parsing it from a file and not a string. If I were to take the text\
    \ of a file and parse it that way, how would you do it?\n<|/ c |>\n<| c |>\nI\
    \ thought you were reading the music from a file somewhere else? I've updated\
    \ my answer to use your `parse_music` method.\n<|/ c |>\n<| c |>\nYou rock! Thank\
    \ you so much. I was unaware of codePointAt() and codePointAt(). I am still not\
    \ very familiar with Python yet, so this was very helpful.\n<|/ c |>\n<| c |>\n\
    No problem! Remember if my answer helped you solve your problem then you should\
    \ accept it :)\n<|/ c |>\n<| a tags=arrays,python,algorithm,string,parsing |>\n\
    I figured it out!\nI decided to use a dictionary to hold all possible notes so\
    \ that I could return the note count for each note in the song.\n<code>\nimport\
    \ std.io;\nimport std.array;\nimport std.string;\nimport std.hashmap;\nimport\
    \ std.function;\nimport std.typecons;\nimport std.math;\n/*\n Input to this function\
    \ is a string representing musical notes in a special ASCII format.\n    Your\
    \ task is to parse this string and return array of integers corresponding to how\
    \ many beats does each\n    not last.", "{\n    List<int> notes_per_beat = new\
    \ List<int>();", "{\n    long[] result = new long[music_string.Length];\n    for\
    \ (int i = 0; i < music_string.Length; i++)\n    {\n        char c = music_string[i];\n\
    \        bool is_half = (c == 'o' || c == '|');\n        bool is_rest = (c ==\
    \ '.');\n        int position;\n        switch (c)\n        {\n            case\
    \ 'o':\n                position = 0;\n                break;\n            case\
    \ '|':\n                position = 1;\n                break;\n            case\
    \ '.':\n                position = 2;\n                break;\n            default:\n\
    \                throw new Exception(string.Format(\"Unknown note at index %d\"\
    , i));\n        }", "{\n    long notes[] = new long[128];", "{\n    int n = music_string.size();\n\
    \    string last_note;\n    int i = 0;", "{\n    long[] result = new long[music_string.length()];\n\
    \    int num_beats = 0;\n    int current_note = 0;\n    int current_beat = 0;\n\
    \    bool first_note = true;", "{\n    string notes_str = \"\";\n    long beats_length\
    \ = 0;\n    foreach(char c in music_string)\n    {\n        notes_str += c;\n\
    \        beats_length += note_to_beats[c - 'o'];\n    }\n    string notes_array\
    \ = notes_str.split('|');\n    string last_note;\n    long[] beat_counts = new\
    \ long[notes_array.length];\n    foreach(string n in notes_array)\n    {\n   \
    \     int beats = note_to_beats[n];\n        long count = 0;\n        if(last_note.Length\
    \ > 0)\n        {\n            count = note_to_beats[last_note] - beats;\n   \
    \     }\n        last_note = n;\n        beat_counts[notes_array.IndexOf(n)] =\
    \ count;\n    }\n    return beat_counts;\n}\n</code>\nThis code works in C# and\
    \ probably in VB.\n<|/ a |>\n<| a dscore=0 |>\nThe other solutions don't seem\
    \ to work anymore\nHere is a simple VB code that will do the same thing:\n<code>\n\
    Public Function parseMusic(ByVal music_string As String) As Long()\n    Dim notes_str\
    \ As String = \"\"\n    Dim beats_length As Long = 0\n    For Each c As Char In\
    \ music_string\n        notes_str += c\n        beats_length = beats_length +\
    \ note_to_beats(c.ToUpper)\n    Next\n    Dim notes_array As String() = notes_str.Split(\"\
    |\")\n    Dim last_note As String = \"\"\n    Dim beat_counts As Long() = New\
    \ Long(notes_array.Length) {}\n    Dim i As Integer\n    For i = 0 To notes_array.Length\
    \ - 1\n        beat_counts(i) = note_to_beats(notes_array(i))\n        If last_note.Length\
    \ > 0 Then\n            beat_counts(i) -= note_to_beats(last_note)\n        End\
    \ If\n        last_note = notes_array(i)\n    Next\n    Return beat_counts\nEnd\
    \ Function\n</code>\n<|/ a tags=vb.net,string,parsing |>\n<| a dscore=0 |>\nHere\
    \ is another solution which uses .NET's extension methods.  This solution is more\
    \ robust in the face of non-standard notes than other solutions because it accounts\
    \ for the difference between an octave and a semi-note, as well as taking into\
    \ account the fact that the same note can have a different number of beats depending\
    \ on whether it is the last note in a song or not.\n<code>\n' Converts a string\
    \ representation of a musical note into a number of beats\n' This string representation\
    \ has the following format:\n", "{\n    int note_length;\n    long note_count\
    \ = 0;\n    string current_note = music_string.substr(0, 1);\n    long[] current_note_length\
    \ = new long[6];\n    current_note_length[note_count++] = note_length;\n    string\
    \ next_note = music_string.substr(1, 1);\n    string next_next_note = music_string.substr(2,\
    \ 1);\n    int current_note_length_index = 0;\n    int next_note_length_index\
    \ = 2;\n    while (next_note != \"|\" && next_next_note != \".\") \n    {\n  \
    \      if (next_note == \".\" && next_next_note == \".\") \n        {\n      \
    \      int note = 1;\n            string note_length = music_string.substr(next_note_length_index,\
    \ 2);\n            note_length = note_length.substr(0, 1);\n            if (note_length\
    \ != \"|\")\n            {\n                note = note_length.substr(0, 1);\n\
    \            }\n            string note_octave = music_string.substr(next_note_length_index\
    \ + 1, 2);\n            note_octave = note_octave.substr(0, 1);\n            next_note_length_index\
    \ += 3;\n            int note_octave_inte = note_octave.chars().mapToObj(c =>\
    \ (int) c).toArray()[0];\n            note_length += note_octave_inte;\n     \
    \       if (note == \"o\")\n            {\n                current_note_length[current_note_length_index++]\
    \ = note + note_length;\n            }\n            else if (note == \"|\")\n\
    \            {\n                current_note_length[current_note_length_index++]\
    \ = note * 2;\n            }\n            else\n            {\n              \
    \  System.err.print(\"invalid note name!\");\n            }\n            note_count++;\n\
    \            current_note = next_note;\n            next_note = next_next_note;\n\
    \            next_next_note = music_string.substr(next_note_length_index, 1);\n\
    \        }\n        else if (next_note == \"|\")\n        {\n            int note\
    \ = 1;\n            string note_length = music_string.substr(next_note_length_index,\
    \ 2);\n            note_length = note_length.substr(0, 1);\n            if (note_length\
    \ != \"|\")\n            {\n                note = note_length.substr(0, 1);\n\
    \            }\n            string note_octave = music_string.substr(next_note_length_index\
    \ + 1, 2);\n            note_octave = note_octave.substr(0, 1);\n            next_note_length_index\
    \ += 3;\n            int note_octave_inte = note_octave.chars().mapToObj(c =>\
    \ (int) c).toArray()[0];\n            note_length += note_octave_inte;\n     \
    \       if (note == \"o\")\n            {\n                current_note_length[current_note_length_index++]\
    \ = note + note_length;\n            }\n            else if (note == \"|\")\n\
    \            {\n                current_note_length[current_note_length", "{\n\
    \    long[] beats = parse_music_impl(music_string);\n    return beats;\n}", "{\n\
    \tlong beat_counts[7] = {0};\n\tstring temp_string = \".\";\n\tstring curr_note\
    \ = \"o\";\n\tint curr_note_len = -1;", "{\n    if (music_string.Length == 0)\n\
    \    {\n        return new long[0];\n    }", "{\n    long result[] = new long[100];\n\
    \    int i = 0;\n    char symbol = 'o';\n    long last_beat = 4L;\n    for (int\
    \ j = 0; j <= music_string.length() - 1; j++) {\n        switch (symbol) {\n \
    \           case 'o':\n                switch (music_string[j]) {\n          \
    \          case '|':\n                        last_beat = 2L;\n              \
    \          break;\n                    case '.':\n                        last_beat\
    \ = 1L;\n                        break;\n                    default:\n      \
    \                  last_beat = 4L;\n                        break;\n         \
    \       }\n                i = 0;\n                break;\n            case 'o|':\n\
    \                switch (music_string[j]) {\n                    case '|':\n \
    \                       last_beat = 2L;\n                        break;\n    \
    \                case '.':\n                        last_beat = 1L;\n        \
    \                break;\n                    default:\n                      \
    \  last_beat = 2L;\n                        break;\n                }\n      \
    \          i = 0;\n                break;\n            case '.|':\n          \
    \      switch (music_string[j]) {\n                    case '|':\n           \
    \             last_beat = 1L;\n                        break;\n              \
    \      case '.':\n                        last_beat = 1L;\n                  \
    \      break;\n                    default:\n                        last_beat\
    \ = 4L;\n                        break;\n                }\n                i\
    \ = 0;\n                break;\n            default:\n                symbol =\
    \ music_string[j];\n                last_beat = 4L;\n                i++;\n  \
    \              break;\n        }\n        result[i] = last_beat;\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=java,algorithm |>\nHere is\
    \ a solution using Java streams, a lambda and a map of streams. \n<code>\npublic\
    \ static long[] getNotes(String s) {\n    List<Long> l = new ArrayList<>();\n\
    \    s.chars().boxed().map(c -> c == 'o' ? 1 : c == '.' ? 4 : Long.parseLong(c)).forEach(l\
    \ ::add);\n    return l.stream().mapToLong(Long::longValue).toArray();\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nThanks for sharing your code with us.  Can you explain\
    \ what the streams accomplish?\n<|/ c |>\n<| c |>\nStreams allow one to iterate\
    \ on elements of a collection or an array. Java 8 streams are a way of streaming\
    \ collections and arrays as they are designed to do so. You can learn more about\
    \ streams here: https://dzone.com/articles/java-8-streams-tutorial-introduction\n\
    <|/ c |>\n<| a tags=java,algorithm dscore=3 |>\nMy solution:\n<code>\npublic static\
    \ int[] getNotes(String s) {\n    int[] result = new int", "{\n    int note_length\
    \ = 4;\n    long total_beats = 0;\n    long note_length_in_beats = 4;\n    for(int\
    \ i = 0; i < music_string.Length; i++)\n    {\n        char c = music_string[i];\n\
    \        switch(c)\n        {\n            case 'o':\n                total_beats++;\n\
    \                break;\n            case 'o|':\n                total_beats +=\
    \ 2;\n                break;\n            case '.|':\n                total_beats\
    \ += 1;\n                break;\n            default:\n                throw new\
    \ ArgumentException(\"Not valid note!\");\n        }\n    }\n    long[] result\
    \ = new long[total_beats];\n    int offset = 0;\n    for(int i = 0; i < music_string.Length;\
    \ i++)\n    {\n        char c = music_string[i];\n        switch(c)\n        {\n\
    \            case 'o':\n                result[offset] = 128;\n              \
    \  offset += note_length;\n                break;\n            case 'o|':\n  \
    \              result[offset] = 128;\n                offset += note_length_in_beats;\n\
    \                break;\n            case '.|':\n                result[offset]\
    \ = 128;\n                offset += note_length_in_beats;\n                break;\n\
    \            default:\n                throw new ArgumentException(\"Not valid\
    \ note!\");\n        }\n    }\n    return result.ToArray();\n}\n</code>\nThe code\
    \ has three parts:", "{\n    // O(n) time complexity, O(1) space complexity\n\
    \    int[] beats = new int[128];\n    for (int i = 0; i < music_string.Length;\
    \ i++)\n    {\n        string character = music_string[i];\n        char note\
    \ = character.ToLowerInvariant();\n        if (note == 'o')\n        {\n     \
    \       beats[(int)'o'] += 4;\n        }\n        else if (note == 'o|')\n   \
    \     {\n            beats[(int)'o'] += 2;\n        }\n        else if (note ==\
    \ '.|')\n        {\n            beats[(int)'o'] += 1;\n        }\n        else\n\
    \        {\n            throw new ArgumentException(\"Invalid music string\");\n\
    \        }\n    }", "{\n    int note_count = 0;\n    string current_note = \"\"\
    ;\n    for(int i = 0; i < music_string.length(); i++)\n    {\n        if(music_string[i]\
    \ == ' ')\n        {\n            note_count++;\n            current_note = \"\
    \";\n        }\n        else\n        {\n            switch(music_string[i])\n\
    \            {\n                case 'o':\n                case 'O':\n       \
    \             note_count += 4;\n                    break;\n                case\
    \ '|':\n                case '|':\n                    note_count += 2;\n    \
    \                break;\n                case '*':\n                case '*':\n\
    \                    note_count += 1;\n                    break;\n          \
    \      case '_':\n                case '.':\n                    note_count +=\
    \ 1;\n                    break;\n                case ' ':\n                \
    \    note_count += 1;\n                    break;\n                default:\n\
    \                    //Should never happen\n                    throw new Exception(\"\
    Parse Error\");\n            }", "{\n    std.string::size_type pos = 0;\n    std.string::size_type\
    \ beat = 0;\n    std.string::size_type last_beat = 0;\n    std.string::size_type\
    \ note = 1;\n    long[] result_beats = new long[music_string.size()];\n    bool\
    \ is_octave = false;\n    bool has_dot = false;\n    bool is_sharp = false;\n\
    \    bool is_flat = false;\n    bool is_rest = false;\n    bool is_semi = false;\n\
    \    \n    //parse first string\n    while(pos < music_string.size() && music_string[pos]\
    \ != '|')\n    {\n        switch (music_string[pos])\n        {\n            case\
    \ ':':\n                is_octave = true;\n                break;\n          \
    \  case '.':\n                has_dot = true;\n                break;\n      \
    \      case '#':\n                is_sharp = true;\n                break;\n \
    \           case 'b':\n                is_flat = true;\n                break;\n\
    \            case ',':\n                is_semi = true;\n                break;\n\
    \            case ' ':\n                is_rest = true;\n                break;\n\
    \            case 'o':\n                if (!is_rest)\n                    result_beats[note]\
    \ = beat;\n                note++;\n                beat = 0;\n              \
    \  break;\n            case ',':\n                note++;\n                beat\
    \ = 0;\n                break;\n            case '|':\n                if (!is_rest)\n\
    \                    result_beats[note] = beat;\n                note++;\n   \
    \             beat = 0;\n                break;\n            case '.':\n     \
    \           note++;\n                beat = 0;\n                break;\n     \
    \       default:\n                char c = music_string[pos];\n              \
    \  note = std.string::to_int_converter(c) - 128;\n                beat++;\n  \
    \              break;\n        }\n        pos += 1;\n    }", "{\n    string notes\
    \ = music_string;\n    \n    int notes_length = notes.length();", "{\n    char[]\
    \ music_array = music_string.ToCharArray();\n    long[] ret = new long[music_array.Length];\n\
    \    long current_beat = 0;\n    long last_beat = 0;\n    int num_beats = 0;\n\
    \    for(int i=0; i<music_array.Length; i++)\n    {\n        char c = music_array[i];\n\
    \        if(c != '|')\n        {\n            last_beat = current_beat;\n    \
    \        current_beat = 0;\n        }\n        if(c != '.')\n        {\n     \
    \       current_beat = 1;\n        }\n        if(c == '|')\n        {\n      \
    \      if(!(num_beats % 4))\n            {\n                ret[num_beats++] =\
    \ last_beat;\n            }\n        }\n    }\n    if(!(num_beats % 4))\n    {\n\
    \        ret[num_beats++] = last_beat;\n    }\n    return ret;\n}\n</code>\n<|/\
    \ a tags=algorithm,java,c#,arrays |>\n<| a dscore=0 |>\nI'm quite late to the\
    \ party, but here are two other implementations:\nThis one is using LINQ as per\
    \ Bryan Oakley's answer, but using an overload of SelectMany that allows you to\
    \ add parameters to your lambdas.\n<code>\npublic static long[] ParseMusic(string\
    \ music)\n{\n    var notes = music.Split('|');\n    return notes.SelectMany((note)\
    \ => (note == '.') ? Enumerable.Repeat(0, 4) : Enumerable.Repeat(0, 2))\n    \
    \             .ToArray();\n}\n</code>\nThis is using regular loops but without\
    \ an overload of SelectMany that allows you to add parameters to your lambdas.\n\
    <code>\npublic static long[] ParseMusic(string music)\n{\n    var notes = music.Split('|');\n\
    \    var ret = new long[notes.Length];\n    for (int i = 0; i < notes.Length;\
    \ i++)\n    {\n        string note = notes[i];\n        long beats = note.Equals(\"\
    .\") ? 0 : note.Equals(\".,\") ? 4 : 2;\n        ret[i] = beats;\n    }\n    return\
    \ ret;\n}\n</code>\n<|/ a tags=algorithm,java,c#,arrays |>\n<| a tags=algorithm,java,c#,arrays\
    \ |>\n<code>\n  public static long[] ParseMusic(string music)\n  {\n    char[]\
    \ music_array = music.ToCharArray();\n    long[] ret = new long[music_array.Length];\n\
    \    for (int i = 0; i < music_array.Length; i++)\n    {\n      char c = music_array[i];\n\
    \      if (c != '|')\n      {\n        if (c != '.')\n        {\n          long\
    \ last = 1;\n          if (i == 0)\n", "{\n    long[] beats = new long[music_string.Length];\n\
    \    int i = 0;", "{\n    int notes = 0;\n    int rests = 0;\n    for(int i=0;\
    \ i<music_string.length(); i++)\n    {\n        if (music_string[i] == '|')\n\
    \        {\n            notes++;\n        }\n        else\n        {\n       \
    \     rests++;\n        }\n    }\n    long[] output = new long[notes];\n    for(int\
    \ i=0; i<music_string.length(); i++)\n    {\n        if (music_string[i] == '|')\n\
    \        {\n            if (notes)\n            {\n                output[notes-1L]\
    \ ++;\n            }\n            notes--;\n        }\n        else\n        {\n\
    \            if (rests)\n            {\n                output[rests-1] ++;\n\
    \            }\n            rests--;\n        }\n    }\n    return output;\n}",
  "{\n    long[] notes;\n    \n    // Convert string to a list of characters (and\
    \ remove whitespace)\n    char[] chars = music_string.toCharArray();\n    char[]\
    \ strip = chars.filter(c -> c != ' ');", "{\n    string pattern = \"o|.|\";\n\
    \    int length = 0;\n    int last_length = 0;\n    char[] chars = music_string.ToCharArray();\n\
    \    for(int i = 0; i < chars.Length; i++)\n    {\n        if(chars[i] == pattern.ToCharArray()[0])\n\
    \            length++;\n        else if(chars[i] == pattern.ToCharArray()[pattern.Length\
    \ - 1])\n            last_length++;\n    }", "{\n\tif((music_string.size() > 3)\
    \ && (music_string[0] == 'o'))\n\t{\n\t\tstring temp;\n\t\tint counter = 0;",
  "{\n    long[] music;\n    size_t music_length = 0;\n    string notes[8] = {\"o\"\
    , \"o|\", \".|\"};\n    size_t note_count = 0;\n    size_t note_length = 0;\n\
    \    for (size_t i = 0; i < music_string.length(); i++)\n    {\n        if (music_string[i]\
    \ == 'o')\n        {\n            if (note_count < 8)\n            {\n       \
    \         music_length += note_length;\n                music = alloca(music_length\
    \ * sizeof long);\n                notes[note_count++] = music_length;\n     \
    \       }\n            note_length = 0;\n        }\n        else if (music_string[i]\
    \ == 'o|')\n        {\n            if (note_count < 8)\n            {\n      \
    \          music_length += note_length;\n                music = alloca(music_length\
    \ * sizeof long);\n                notes[note_count++] = music_length;\n     \
    \       }\n            note_length = 2;\n        }\n        else\n        {\n\
    \            if (note_length < 3)\n            {\n                music_length\
    \ += note_length;\n                music = alloca(music_length * sizeof long);\n\
    \                notes[note_count++] = music_length;\n            }\n        \
    \    note_length = 1;\n        }\n        note_length++;\n    }", "{\n    long[]\
    \ lengths = new long[128];\n    for (int i = 0; i < 128; ++i)\n    {\n       \
    \ if (music_string[i] == 'o' || music_string[i] == '|' || music_string[i] == '.')\
    \ \n        {\n            lengths[i] = 4;\n        }\n        else \n       \
    \ {\n            lengths[i] = 2;\n        }\n    }\n    return lengths;\n}\n</code>\n\
    <|/ a tags=arrays,for-loop,c# |>\n<| a tags=arrays,for-loop,c# |>\n<code>\npublic\
    \ class NoteLengths\n{\n    private static int[] noteLengths = new int[]\n   \
    \ {\n        1, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n      \
    \  4, 3, 2, 2, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n     \
    \   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n\
    \        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  \
    \      3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n     \
    \   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3,\n        3, 3, 3, 3, 3, 3, 3, 3, 3, 3, ", "{\n    Map<string,\
    \ int> note_to_beat = {\n        \"o\" => 4L,\n        \"o|\" => 2L,\n       \
    \ \".|\" => 1L\n    };", "{\n\tstring notes[] = string.split(music_string, \"\
    |\");\n\t\n\tlong[] beats = new long[notes.length];\n\tfor (long i = 0;i<notes.length;i++)\n\
    \t{\n\t\tif (notes[i]==\"o\")\n\t\t\tbeats[i] = 4L;\n\t\telse if (notes[i]==\"\
    o|\")\n\t\t\tbeats[i] = 2L;\n\t\telse if (notes[i]==\".|\")\n\t\t\tbeats[i] =\
    \ 1L;\n\t\telse\n\t\t\tSystem.err.println(\"Bad note string!\");\n\t}\n\treturn\
    \ beats;\n}\n/*\n Write a method `split_note_string(note_string) that will split\
    \ a musical note string into an array.\n    \n    The input music note string\
    \ should be in the format of 'o' or 'o|' or '.|', \n    respectively, and each\
    \ element of the array should be an integer.", "{\n    std.typecons.Vector<long>\
    \ result = new std.typecons.Vector<long>();\n    std.typecons.Vector<string> lines\
    \ = std.split.parseLines(music_string);\n    for (std.typecons.Vector<string>\
    \ line : lines) {\n        std.string.escape(line);\n        int number_of_beats\
    \ = 0;\n        string note;\n        for (std.typecons.Vector<string> note_string\
    \ : std.split.parseLines(line)) {\n            std.string.escape(note_string);\n\
    \            if (note_string.StartsWith(\"o\")) {\n                note = \"o\"\
    ;\n            } else if (note_string.StartsWith(\"|\")) {\n                note\
    \ = \"o|\";\n            } else {\n                note = \".|\";\n          \
    \  }\n            number_of_beats += 4;\n        }\n        result.add(number_of_beats);\n\
    \    }\n    long[] result = result.toArray();\n    return result;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI guess it's better to give the input as an array\
    \ of strings, not as a string.\n<|/ c |>\n<| c |>\nYes, you are right, the function\
    \ would work even with strings, but then it would be harder to parse the string\
    \ back to a string[]. But the idea is the same.\n<|/ c |>\n<| c |>\nAh, now I\
    \ see what you mean by \"the function\", I was confused by the function name.\
    \ I thought you were saying the function itself.\n<|/ c |>\n<| c |>\nThanks, it's\
    \ nice to have the code with me. I will try to make some changes based on this.\n\
    <|/ c |>\n<| c |>\nSure, no problem. I hope you find some time to do some testing\
    \ with my new code. Also, if my answer was helpful, don't forget to mark it as\
    \ \"accepted\" (by clicking on the check mark on the left side, below the up and\
    \ down arrows). Cheers!\n<|/ c |>\n<| a dscore=1 tags=arrays,string,c# |>\nYou\
    \ can use the Substring method of string\nhttp://msdn.microsoft.com/en-us/library/system.string.substring.aspx\n\
    <code>\nstring str = \"hello\";\nstring substr = str.Substring(0,1);\n</code>\n\
    This will give you h\n<|/ a |>\n<| a tags=arrays,string,c# dscore=1 |>\n<code>\n\
    public static string[] GetNotes(string notes)\n{\n    string[] result = new string[100];\n\
    \    int i = 0;\n    foreach(char c in notes)\n    {\n        if (char.IsLetter(c) ",
  "{\n    //Your code goes here\n    long[] beats_array = new long[(int)music_string.length()];\n\
    \    int i = 0, j = 0;\n    while(j < music_string.length()){\n        if(music_string[j]\
    \ == 'o'){\n            beats_array[i++] = 4;\n        }\n        if(music_string[j]\
    \ == 'o|'){\n            beats_array[i++] = 3;\n        }\n        if(music_string[j]\
    \ == '.|'){\n            beats_array[i++] = 2;\n        }\n        j++;\n    }\n\
    \    return beats_array;\n}\n</code>\n<|/ a tags=c++,arrays |>\n<| c |>\n`long[]\
    \ beats_array = new long[(int)music_string.length()];` isn't safe.\n<|/ c |>\n\
    <| c |>\n`j` isn't really used at all, it could be removed. Also, please consider\
    \ adding some explanation as to why this solves the problem.\n<|/ c |>\n<| c |>\n\
    - Thank you for your comments. I made some changes to the code, hope this will\
    \ help.\n<|/ c |>\n<| a tags=c++,arrays |>\nTry this code\n<code>", "{\n    int\
    \ beats = 0, beats_last = 0;\n    string current_note = music_string;", "{\n \
    \   string notes[] = {\"o\", \"o|\", \".|\"};\n    int note_count = 0;\n    long\
    \ note_time = 0;\n    long beat_time = 0;\n    int[] beat_count = new int[6];\n\
    \    \n    for(int i=0; i<music_string.length(); i++) {\n        if (notes[note_count]\
    \ == music_string[i]) {\n            note_count += 2;\n            if (beat_count[0]\
    \ < 4) beat_count[0] += 1;\n            if (beat_count[1] < 2) beat_count[1] +=\
    \ 1;\n            if (beat_count[2] < 1) beat_count[2] += 1;\n            if (beat_count[3]\
    \ < 2) beat_count[3] += 1;\n            if (beat_count[4] < 4) beat_count[4] +=\
    \ 1;\n            if (beat_count[5] < 4) beat_count[5] += 1;\n            if (beat_count[6]\
    \ < 4) beat_count[6] += 1;\n            note_time += (beat_count[0] * 8 + beat_count[1]\
    \ * 4 + beat_count[2] * 2 + beat_count[3] * 1 + beat_count[4] * 3 + beat_count[5]\
    \ * 2 + beat_count[6] * 4) * 4;\n            beat_count[0] = 0;\n            beat_count[1]\
    \ = 0;\n            beat_count[2] = 0;\n            beat_count[3] = 0;\n     \
    \       beat_count[4] = 0;\n            beat_count[5] = 0;\n            beat_count[6]\
    \ = 0;\n            note_time = note_time / 4;\n        } else {\n           \
    \ beat_time++;\n            beat_count[note_count] += 1;\n            note_count\
    \ = 0;\n        }\n    }", "{\n  int length = music_string.length();\n  int count\
    \ = 0;\n  int i = 0;", "{\n    string line = \"\";\n    long notes[] = new long[128];\n\
    \    int note_position = 0;", "{\n    \n    bool last = false;\n    string current\
    \ = \"o\";\n    \n    long[] result = new long[4];\n    for(int i = 0; i < music_string.length();\
    \ i++)\n    {\n        string letter = music_string[i];\n        if(letter ==\
    \ 'o')\n        {\n            last = true;\n        }\n        else if(letter\
    \ == '|')\n        {\n            last = false;\n        }\n        else\n   \
    \     {\n            if(current != letter)\n            {\n                current\
    \ = letter;\n                result[0] = result[1];\n                result[1]\
    \ = result[2];\n                result[2] = result[3];\n                result[3]\
    \ = 0;\n            }\n            \n            if(last)\n            {\n   \
    \             result[3]++;\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\n`std.typecons` doesn't have `map` and also the\
    \ line `using std.functional.ops;` produced errors for me. Also I am getting `error\
    \ CS0246: The type or namespace name 'Functional' could not be found`\n<|/ c |>\n\
    <| c |>\n, thank you for the corrections. I didn't know that `std` namespace was\
    \ so important. The `Functional` namespace is inside `std.functional.ops` as you\
    \ can see from the updated code. Did you get any error while compiling your code?\n\
    <|/ c |>\n<| c |>\nThat fixed the `Functional` namespace problem, but now I am\
    \ getting this error on `map`: error CS0246: The type or namespace name `map'\
    \ could not be found. Are you missing `using System;` at the top of your file?\n\
    <|/ c |>\n<| c |>\n, sorry, my bad. `map` is a part of [functional.collections](https://code.msdn.microsoft.com/windowsdesktop/functional-collections-44f84bcf).\
    \ I edited the answer and added the missing `using` directive.\n<|/ c |>\n<| a\
    \ |>\nI solved the problem using dynamic arrays, this is my solution\n<code>\n\
    \    string music=\"o o|.|o|o|.|.|.|.o|.o|o|.|.|.|.o\";\n    string[] notes =\
    \ music.Split('|');\n    int[] array = new int[4];\n    for(int i=0;i<notes.Length;i++)\n\
    \    {\n        for(int j=0;j<4;j++)\n        {\n            if(notes[i]==\".\"\
    \ && j!=3)\n            {\n                array[j]=array[j+1];\n            }\n\
    \            else\n            {\n                array[j]++;\n            }\n\
    \        }\n        array", "{\n    int note_length = music_string.length();\n\
    \    long beats = note_length / 2;", "{\n    Array2D<string> notes = parseMusicString(music_string);\n\
    \    return notes.asArray();\n}", "{\n    int[] notes={};", "{\n    long music;\n\
    \    long total = 0;\n    for (int i = 0; i < music_string.length(); i++)\n  \
    \  {\n        char note = music_string[i];", "{\n    int beats_per_beat;\n   \
    \ int beats_left;\n    int current_note;\n    string current_symbol;\n    long\
    \ current_beat;\n    bool end_of_string = false;\n    beats_per_beat = 440 / 12;\
    \ // one beat is 12 beats per whole note", "{\n    if (music_string == \"\")\n\
    \        throw new Exception(\"empty music string was passed\");", "{\n    long[]\
    \ result_array = new long[64];\n    for(int i = 0; i < music_string.Length; i++)\n\
    \    {\n        if (music_string[i] == '.')\n        {\n            result_array[i\
    \ * 6 + 0]++;\n            result_array[i * 6 + 1]++;\n            result_array[i\
    \ * 6 + 2]++;\n            result_array[i * 6 + 3]++;\n            result_array[i\
    \ * 6 + 4]++;\n            result_array[i * 6 + 5]++;\n            result_array[i\
    \ * 6 + 6]++;\n            result_array[i * 6 + 7]++;\n            result_array[i\
    \ * 6 + 8]++;\n            result_array[i * 6 + 9]++;\n            result_array[i\
    \ * 6 + 10]++;\n            result_array[i * 6 + 11]++;\n            result_array[i\
    \ * 6 + 12]++;\n            result_array[i * 6 + 13]++;\n            result_array[i\
    \ * 6 + 14]++;\n            result_array[i * 6 + 15]++;\n            result_array[i\
    \ * 6 + 16]++;\n        }\n        else if (music_string[i] == 'o')\n        {\n\
    \            result_array[i * 6 + 0]++;\n            result_array[i * 6 + 1]++;\n\
    \            result_array[i * 6 + 2]++;\n            result_array[i * 6 + 3]++;\n\
    \            result_array[i * 6 + 4]++;\n            result_array[i * 6 + 5]++;\n\
    \            result_array[i * 6 + 6]++;\n            result_array[i * 6 + 7]++;\n\
    \            result_array[i * 6 + 8]++;\n            result_array[i * 6 + 9]++;\n\
    \            result_array[i * 6 + 10]++;\n            result_array[i * 6 + 11]++;\n\
    \            result_array[i * 6 + 12]++;\n            result_array[i * 6 + 13]++;\n\
    \            result_array[i * 6 + 14]++;\n            result_array[i * 6 + 15]++;\n\
    \            result_array[i * 6 + 16]++;\n            result_array[i * 6 + 17]++;\n\
    \            result_array[i * 6 + 18]++;\n            result_array[i * 6 + 19]++;\n\
    \            result_array[i * 6 + 20]++;\n            result_array[i * 6 + 21]++;\n\
    \            result_array[i * 6 + 22]++;\n            result_array[i * 6 + 23]++;\n\
    \            result_array[i * 6 + 24]++;\n            result_array[i * 6 + 25]++;\n\
    \            result_array[i * 6 + 26]++;\n            result_array[i * ", "{\n\
    \    long[] beats = new long[(int)Math.Ceiling(Math.Log(music_string.length /\
    \ 2.0, 1.0 / 8.0))];\n    int i = 0;\n    for (char c : music_string)\n    {\n\
    \        if (c != '.') \n        {\n            beats[i++] = -1;\n           \
    \ continue;\n        }\n        switch (c)\n        {\n            case 'o': beats[i]\
    \ = 4; break;\n            case '|': beats[i] = 2; break;\n            case '.':\
    \ beats[i] = 1; break;\n        }\n    }\n    return beats;\n}\n</code>\n<|/ a\
    \ tags=c#,arrays,parsing,algorithm |>\n<| c |>\nThanks, this seems to work and\
    \ seems simple. Is there a way to make it scalable? I mean, imagine a musical\
    \ notation where each note is repeated several times. Would there be a way to\
    \ make it scale up? I mean something like \"|\" being the note repeated 2 times\
    \ and \"|\" being the note repeated 3 times?\n<|/ c |>\n<| c |>\n- if you have\
    \ repeating chords, you could use the `chord` algorithm to convert it to `beats`.\
    \ A `chord` is a set of notes played together. The `note` algorithm will convert\
    \ a chord to an array of `notes`. You could combine them together to make one\
    \ chord. The `chord` algorithm is described [here](http://en.wikipedia.org/wiki/Chord_(music)#Chord_notation).\n\
    <|/ c |>\n<| c |>\nThanks, this seems to be the way to go for me.\n<|/ c |>\n\
    <| a |>\nYou can try something like this\n<code>\nstring notes = \"o o| .| o|\
    \ o| .| .| .| .| o o\";\nstring[] notesSplit = notes.Split(new char[] { ' ' },\
    \ StringSplitOptions.RemoveEmptyEntries);", "{\n    string[] notes = music_string.split(\"\
    \ \");\n    long[] beats = new long[notes.Length];\n    for(int i = 0; i< notes.Length;\
    \ i++)\n    {\n        int beats = notes[i].IndexOf('.') - notes[i].IndexOf('o')\
    \ + 1;\n        beats[i] = beats;\n    }\n    return beats;\n}\n</code>\n<|/ a\
    \ dscore=0 |>\n<| a tags=c#,.net,string,algorithm,arrays |>\nHere's my solution.\
    \ It is not very pretty but it does the job. I'm sure you can make it prettier\
    \ with linq.\n<code>\n    public static void Main()\n    {\n        var stringsToBeParsed\
    \ = new[] { \"o o| .| o| o| .| .| .| .| .| o o\" };", "{\n    string last_note\
    \ = music_string;\n    int beats_per_note = 1;\n    long[] note_array = new long[music_string.size()];\n\
    \    for( int i = 0; i < note_array.size; ++i)\n    {\n        if(last_note ==\
    \ \".\")\n            beats_per_note = 2;\n        else if(last_note == \"|\"\
    )\n            beats_per_note = 4;\n        else\n            beats_per_note =\
    \ 1;\n        last_note = music_string.substr(0, music_string.find(last_note));\n\
    \        note_array[i] = beats_per_note;\n        music_string = music_string.substr(music_string.find(last_note)\
    \ + 1, music_string.length());\n    }\n    return note_array;\n}", "{\n    bool\
    \ is_last_note = false;", "{\n    string[] notes = music_string.split(\" \");\n\
    \    long[] beats = new long[notes.length];", "{\n    int beats = 0;\n    long\
    \ sum = 0;\n    string current_note = \"\";\n    string current_rest = \"\";\n\
    \    bool last_note = true;", "{\n    //Your code here\n    int notes_count=0;\n\
    \    string note_group=\"\";\n    for(int i=0;i<music_string.length();i++)\n \
    \   {\n        if(music_string[i]==\"o\")\n        {\n            notes_count+=4;\n\
    \        }\n        else if(music_string[i]==\"o|\")\n        {\n            notes_count+=2;\n\
    \        }\n        else if(music_string[i]==\".|\")\n        {\n            notes_count+=1;\n\
    \        }\n        else\n        {\n            note_group+=music_string[i];\n\
    \        }\n    }\n    long[] notes_count=new long[notes_count];\n    int i=0;\n\
    \    for(int j=0;j<music_string.length();j++)\n    {\n        if(music_string[j]==\"\
    o\")\n        {\n            notes_count[i]+=4;\n        }\n        else if(music_string[j]==\"\
    o|\")\n        {\n            notes_count[i]+=2;\n        }\n        else if(music_string[j]==\"\
    .|\")\n        {\n            notes_count[i]+=1;\n        }\n        else\n  \
    \      {\n            notes_count[i]+=1;\n        }\n        i++;\n    }\n   \
    \ return notes_count;\n}\n</code>\n<|/ a tags=c,arrays |>\n<| c |>\nThank you\
    \ so much for your help, it works and your explanation is really great. I really\
    \ appreciate your efforts to help, I am still learning about C and this was very\
    \ helpful. Thank you so much.\n<|/ c |>\n<| c |>\nYou're welcome. Hope you'll\
    \ take my advice and try write more code next time.\n<|/ c |>\n<| c |>\nYou're\
    \ welcome, glad I could help you.\n<|/ c |>\n<| c |>\nI think I should point out\
    \ that you can easily adapt this code to use a variable number of notes. Just\
    \ replace `notes_count+=n;` with `notes_count[note_count++]=n;`\n<|/ c |>\n<|\
    \ a |>\nI think this should do what you want.\n<code>\n#include <stdio.h>\n#include\
    \ <string.h>\n#include <stdlib.h>\n#include <stdint.h>", "{\n    long beats =\
    \ 0, beats_note = 0;\n    int note = 0;", "{\n    int notes_in_chords = 4;", "{\n\
    \    long beat_count;\n    beat_info info;\n    beat_info[] beats;\n    int beat;\n\
    \    beats = beat_info[music_string.length()/2]; //divide by 2 to get a correct\
    \ size of array (even number of characters)\n    beat = music_string.length()/2;",
  "{\n    long beat_number = 0;\n    long number_of_beats = 0;\n    bool is_last_note\
    \ = false;\n    long last_beat_number = 0;", "{\n  long result[] = new long[128];\n\
    \  int count = 1;\n  int current_beat = 1;", "{\n    long[] length = new long[4];",
  "{\n    var arr = new long[music_string.Length / 2];", "{\n    List<int> notes =\
    \ new List<int>();\n    notes.Add(0);", "{\n    string[] parts = music_string.split(\"\
    \ \");\n    long[] result = new long[parts.length];\n    for(int i = 0; i < parts.length;\
    \ ++i)\n    {\n        string part = parts[i];\n        long beats = 0;\n    \
    \    string last = \"\";\n        bool has_chord = false;\n        for(char c\
    \ : part)\n        {\n            string note = string.Concat(last, c);\n    \
    \        if(note == \".\" || note == \"o\")\n            {\n                beats\
    \ += 4;\n                last = \"\";\n            }\n            else if(note\
    \ == \"o|\")\n            {\n                beats += 2;\n                last\
    \ = \"o\";\n            }\n            else if(note == \".|\")\n            {\n\
    \                beats += 1;\n                last = \".\";\n            }\n \
    \           else\n            {\n                has_chord = true;\n         \
    \       last = \"\";\n            }\n        }\n        if(has_chord)\n      \
    \  {\n            throw new ArgumentException(\"music string not formatted as\
    \ expected\");\n        }\n        result[i] = beats;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=parsing,c# |>\n<| c |>\nThanks for your answer! I'm wondering\
    \ if there will be an issue when two chords share the same last note.\n<|/ c |>\n\
    <| c |>\nI checked that in code. There are no duplicate notes allowed in a chord.\n\
    <|/ c |>\n<| c |>\nYes, I know, I just wanted to point it out for other people\
    \ who might come across this question.\n<|/ c |>\n<| c |>\nI tested your code\
    \ and I get the wrong result: parse_music(\"o o| .| o| o| .| .| .| .| o o\") returns\
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L]. I guess it's because you forgot\
    \ to check when \"o\" is repeated twice in a row?\n<|/ c |>\n<| c |>\nYou are\
    \ right. I forgot to add that check. Thank you for pointing that out.\n<|/ c |>\n\
    <| a dscore=0 tags=parsing,c# |>\nI ended up using an alternative solution I saw\
    \ in another StackOverflow thread, thanks to for pointing me in the right direction:\n\
    <code>\nprivate static void Main()\n{\n    var notes = parse_music(\"o o| .| o|\
    \ o| .| .| .| .| o o\");\n    Console.WriteLine(string.Join(\",\", notes));\n}",
  "{\n    var beat_counts = new long[128];\n    var notes_counter = new int[128];",
  "{\n    var notes: int[] = new int[256];\n    var chars: char[] = music_string.toCharArray();\n\
    \    var beats: int[] = new int[32];\n    var bnotes: long[] = new long[32];\n\
    \    var last = 0;\n    var lastTime = 0;\n    var temp: int;\n    var beat: int;\n\
    \    var length: int;", "{\n    int len = music_string.Length;\n    int[] notes\
    \ = new int[len];\n    int i = 0;\n    int j = -1;\n    int last_note = -1;\n\
    \    bool found = false;\n    while (!found && i < len) \n    {\n        found\
    \ = false;\n        string part = music_string.Substring(i, 4);\n        if (part\
    \ == \"o\") \n        {\n            if (j > 0) \n            {\n            \
    \    notes[j] = notes[j - 1] + 4;\n            }\n            notes[i] = 1;\n\
    \            last_note = i;\n            found = true;\n        }\n        else\
    \ if (part == \"o|\") \n        {\n            if (j > 0) \n            {\n  \
    \              notes[j] = notes[j - 1] + 2;\n            }\n            notes[i]\
    \ = 2;\n            last_note = i;\n            found = true;\n        }\n   \
    \     else if (part == \".|\") \n        {\n            if (j > 0) \n        \
    \    {\n                notes[j] = notes[j - 1] + 1;\n            }\n        \
    \    notes[i] = 3;\n            last_note = i;\n            found = true;\n  \
    \      }\n        i++;\n        j++;\n    }\n    long[] result = new long[notes.Length];\n\
    \    for (int n = 0; n < notes.Length; n++) \n    {\n        result[n] = notes[n]\
    \ * 4 - notes[last_note];\n    }\n    return result;\n}\n</code>\n<|/ a dscore=3\
    \ tags=algorithm,c#,string |>\n<| c |>\nThanks for sharing your code. I'll have\
    \ a look at it. I still haven't gotten around to learning regex yet so I'll be\
    \ back soon to accept your answer. Thanks!\n<|/ c |>\n<| c |>\nYou're welcome!\
    \ I updated my answer with some new information and some sample code :)\n<|/ c\
    \ |>\n<| c |>\nIt works, thanks! I only accepted this answer because I realised\
    \ that the other answers aren't exactly what I need, but it's an interesting solution\
    \ that I will definitely be researching and working on. Thanks!\n<|/ c |>\n<|\
    \ c |>\nJust noticed that the solution above also works for notes that don't have\
    \ a '.', e.g. 'c' instead of '.'\n<|/ c |>\n<| a tags=algorithm,c#,string dscore=1\
    \ |>\nI like Eric Lippert's solution with regular expressions. However, I don't\
    \ think it's possible to use regexes (for me at least) to match an arbitrary number\
    \ of spaces. So my solution is just to split the string on spaces and then count\
    \ the occurrences of \"o|\" and \"o.\" Then I just subtract out the occurrences\
    \ of \"o.\"\nHere's some code:\n<code>", "{\n  char current_note, prev_note;\n\
    \  long beats_last_note;", "{\n    long result[] = new long[music_string.Length];\n\
    \    int i = 0;\n    int beat = 0;\n    int last_beat = 0;\n    int last_note\
    \ = 0;\n    int note = 0;\n    while ((i < music_string.Length) && (music_string[i]\
    \ != '|'))\n    {\n        char c = music_string[i];\n        switch (c)\n   \
    \     {\n            case 'o': \n                if (beat > 0)\n             \
    \   {\n                    beat--;\n                    last_beat = beat;\n  \
    \                  result[i] = beat - last_beat;\n                    beat = 0;\n\
    \                    last_note = note;\n                }\n                else\n\
    \                {\n                    result[i] = beat;\n                  \
    \  beat++;\n                    last_note = note;\n                }\n       \
    \         break;\n            case 'o|': \n                if (beat > 0)\n   \
    \             {\n                    beat--;\n                    last_beat =\
    \ beat;\n                    result[i] = beat - last_beat;\n                 \
    \   beat = 0;\n                    last_note = note;\n                }\n    \
    \            else\n                {\n                    result[i] = beat;\n\
    \                    beat++;\n                    last_note = note;\n        \
    \        }\n                break;\n            case '.|': \n                if\
    \ (beat > 0)\n                {\n                    beat--;\n               \
    \     last_beat = beat;\n                    result[i] = beat - last_beat;\n \
    \                   beat = 0;\n                    last_note = note;\n       \
    \         }\n                else\n                {\n                    result[i]\
    \ = beat;\n                    beat++;\n                    last_note = note;\n\
    \                }\n                break;\n            default:\n           \
    \     beat = 0;\n                note = 0;\n                last_note = 0;\n \
    \               result[i] = 0;\n        }\n        i++;\n    }\n    return result\
    \ ;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>\n    public class\
    \ Main {\n        public static void main(String[] args) {\n            String\
    \ str=\"o.o|.|.|.|.|.|.\";\n            String[] s = str.split(\"\\\\.\");\n \
    \           System.out.println(Arrays.toString(s));\n            System.out.println(getBites(s));\n\
    \            System.out.println(getBites(str));\n        }", "{\n    string note\
    \ = \".\";\n    string note2 = \".\";\n    string note3 = \".\";\n    string note4\
    \ = \".\";", "{\n    int[] notes;\n    int[] num_beats;\n    int num_index = 0;\n\
    \    int num_beats_index = 0;\n    int num_beats_before_index = 0;\n    notes\
    \ = new int[128];\n    num_beats = new int[128];\n    for(int i = 0; i < music_string.length;\
    \ i++)\n    {\n        if(music_string[i] == 'o')\n        {\n            if(notes[num_index]\
    \ % 12 == 0)\n            {\n                num_beats_before_index += num_beats_index;\n\
    \            }\n            notes[num_index] = notes[num_index] + 1;\n       \
    \     num_beats_index = 1;\n            ++num_beats_index;\n        }\n      \
    \  else if(music_string[i] == '|')\n        {\n            if(notes[num_index]\
    \ % 12 == 0)\n            {\n                num_beats_before_index += num_beats_index;\n\
    \            }\n            notes[num_index] = notes[num_index] + 1;\n       \
    \     num_beats_index = 2;\n            ++num_beats_index;\n        }\n      \
    \  else if(music_string[i] == '.')\n        {\n            if(notes[num_index]\
    \ % 12 == 0)\n            {\n                num_beats_before_index += num_beats_index;\n\
    \            }\n            notes[num_index] = notes[num_index] + 1;\n       \
    \     num_beats_index = 3;\n            ++num_beats_index;\n        }\n      \
    \  else\n        {\n            ++num_index;\n            notes[num_index] = 0;\n\
    \        }\n    }\n    num_beats[num_beats_index - 1] = num_beats_before_index;\n\
    \    return num_beats;\n}\n</code>\n<|/ a dscore=1 tags=c,arrays,string |>\n<|\
    \ c |>\nThanks! Your answer helped me understand how to approach the problem,\
    \ and I also got the code working for my problem. I'm posting the code that I\
    \ came up with for anyone else trying to solve this problem in the future. I think\
    \ I may have made a mistake when I tried to add more methods to my program to\
    \ deal with the other problems I had, but your answer helped me understand how\
    \ to do it.\n<|/ c |>\n<| c |>\n.G. Thank you for posting your code snippet, it\
    \ helped me with a similar problem I was having.\n<|/ c |>\n<| a |>\nI figured\
    \ out how to solve my problem in three ways:\n(1) I went with option 2 in the\
    \ code I posted earlier. Here was my new main method:\n<code>", "{\n    long beats[]\
    \ = new long[music_string.Length];\n    int i = 0;\n    char ch;\n    while (i\
    \ < music_string.Length && music_string[i] != '|')\n    {\n        ch = music_string[i];\n\
    \        if (ch == 'o')\n        {\n            beats[i-1] = 4L;\n        }\n\
    \        else if (ch == 'o|')\n        {\n            beats[i-1] = 2L;\n     \
    \   }\n        else if (ch == '.|')\n        {\n            beats[i-1] = 1L;\n\
    \        }\n        else\n        {\n            throw new Exception(\"Invalid\
    \ music\");\n        }\n        i++;\n    }\n    if (i == music_string.Length)\n\
    \    {\n        throw new Exception(\"Invalid music\");\n    }\n    return beats;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThank you for your response! I have run\
    \ your code and it seems to work fine. However when I try to apply it to the music\
    \ file in my main post it gives an error. Here is the error I get when I run it:",
  "{\n    var beats = [] as long[];\n    var last_beat = 0L;\n    var note = 'o';\n\
    \    \n    for(var i = 0; i < music_string.length; ++i)\n    {\n        if(music_string[i]\
    \ == 'o')\n        {\n            note = 'o';\n            beats[last_beat++]\
    \ = 1;\n        }\n        else if(music_string[i] == '|')\n        {\n      \
    \      note = '|';\n            beats[last_beat++] = 1;\n        }\n        else\
    \ if(music_string[i] == '.')\n        {\n            note = '.';\n           \
    \ beats[last_beat++] = 1;\n        }\n        else\n        {\n            if(note\
    \ == 'o')\n            {\n                beats[last_beat++] = 2;\n          \
    \      note = '|';\n            }\n            else if(note == '|')\n        \
    \    {\n                beats[last_beat++] = 1;\n                note = '.';\n\
    \            }\n            else if(note == '.')\n            {\n            \
    \    beats[last_beat++] = 1;\n                note = 'o';\n            }\n   \
    \     }\n    }\n    return beats;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nIf\
    \ I'm not mistaking, this is an example of what your algorithm would do, but not\
    \ the music itself, which is exactly what OP wants to do.\n<|/ c |>\n<| c |>\n\
    : I agree, but I think the OP already has the algorithm, so it is a good point\
    \ to start from. Thanks for the comment :)\n<|/ c |>\n<| a tags=algorithm,c# |>\n\
    The simple solution is to use Regular Expressions\n<code>\nRegex rx = new Regex(@\"\
    (o|.)\", RegexOptions.IgnoreCase);\nstring music = @\"o o| .| o| o| .| .| .| .|\
    \ o o\";\nstring newMusic = rx.Replace(music, \"\");\nstring[] newMusicSplit =\
    \ newMusic.Split('|');\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\nTry this\n\
    <code>\npublic static int[] GetBeatsFromNotes(string notes)\n{\n    if (string.IsNullOrEmpty(notes))\n\
    \    {\n        return null;\n    }", "{\n    map<string, int> map;\n    vector<string>\
    \ splitted = split(music_string, '.');\n    for(string notes : splitted) \n  \
    \  {\n        if(notes == \"o\") map[notes] = 4;\n        else if (notes == \"\
    o|\") map[notes] = 2;\n        else map[notes] = 1;\n    }\n    vector<string>\
    \ splitted1 = split(splitted[0], '|');\n    string beats = splitted1[0];\n   \
    \ long beat = 0;\n    for(string note : splitted1) \n    {\n        beat = beat\
    \ * map[\"o\"]+map[\"o|\"]+map[note];\n    }\n    vector<long> beats(splitted1.size());\n\
    \    int j = 0;\n    for(string note : splitted1) \n    {\n        beats[j] =\
    \ beat * map[\"o\"]+map[\"o|\"]+map[note];\n        j++;\n    }\n    return beats;\n\
    }\n</code>\n<|/ a tags=algorithm,c++,string |>\n<| c |>\nI'm sorry, but that's\
    \ not a solution for me. I was hoping for a solution that would not involve a\
    \ lot of if-else statements. Thank you anyway.\n<|/ c |>\n<| c |>\nYou are welcome.\
    \ The only solution I can come up with is to use an `if-else` block, but I wouldn't\
    \ call it a huge problem. `if-else` is usually a good solution for most problems.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere's another solution that's quite similar to the\
    \ one I posted earlier, but is actually a lot more general.  It should work for\
    \ any number of \"notes\" and any number of beats per note.\n<code>\nvector<int>\
    \ note_to_beats( string music ) {\n  vector<int> beats;\n  map<string, int> map;\n\
    \  int n = 0;\n  while ( n < music.length() && music[n] != '|' ) {\n    beats.push_back(\
    \ map[music[n]] );\n    n++;\n  }\n  while ( n < music.length() && music[n] ==\
    \ '|' ) {\n    beats.push_back( map.at(music[n+1]) );\n    n++;\n  }\n  return\
    \ beats;\n}\n</code>\n<|/ a tags=algorithm,c++,string |>\n<| a tags=algorithm,c++,string\
    \ |>\nThis code should do it:\n<code>", "{\n    long []res = new long[36];\n \
    \   string notes[]={\"\",\"o|\",\"\\\\.|\"};\n    string note;\n    int beats=\
    \ 0;\n    for (int i=0;i<music_string.size();i++){\n        note = music_string[i];\n\
    \        if (note==\"o\") res[beats++] = 4;\n        else if (note==\"o|\") res[beats++]\
    \ = 2;\n        else if (note==\"\\\\.|\") res[beats++] = 1;\n        else res[beats++]\
    \ = 1;\n    }\n    return res;\n}\n</code>\n<|/ a tags=java,arrays,string |>\n\
    <| c |>\nAh, so you're just using `res` to keep track of the position in the music,\
    \ and the note itself to keep track of whether it has a full note or half note.\
    \ Thanks for that explanation! I see a little bit of overkill because of the repetition\
    \ of the notes, but it certainly works! I'm wondering how this compares to my\
    \ answer though...\n<|/ c |>\n<| a tags=java,arrays,string |>\nI used this to\
    \ convert musical note to int and back. \nIt has lots of extra stuff but it is\
    \ a good starting point. \n<code>\npublic class NoteConverter {\n    private static\
    \ final int OCTAVE_SIZE = 5;\n    private static final int NOTES_NUMBER = 60;",
  "{\n    long beats=0;\n    char note='\\0';\n    while(music_string[beats] != '\\\
    0')\n    {\n        // 'o', 'o|', '.', and '|' start a note\n        note = music_string[beats];\n\
    \        // 'o|' has two octaves\n        if(note == 'o|')\n        {\n      \
    \      note = music_string[beats + 1];\n            beats += 2;\n        }\n \
    \       // '.|' has one octave\n        if(note == '.|')\n        {\n        \
    \    note = music_string[beats + 1];\n            beats += 1;\n        }\n   \
    \     // everything else is just a normal note\n        else\n        {\n    \
    \        beats += 1;\n        }\n        if(note != '\\0')\n        {\n      \
    \      // we know that beats counts from zero\n            beats += std.random.int(0,2);\n\
    \        }\n    }\n    // returns number of beats in a note\n    return std.array.to!long(std.array.create(beats,0));\n\
    }", "{\n    long[] notes;\n    \n    int note_count = 0;\n    notes = long_array(0);\n\
    \    foreach(char c in music_string)\n    {\n        if (c == '.')\n        {\n\
    \            notes[note_count] = long_array(4);\n            note_count++;\n \
    \           continue;\n        }\n        \n        int beats = 0;\n        if\
    \ (is_note(c))\n        {\n            switch (c)\n            {\n           \
    \ case 'o':\n                beats = 4;\n                break;\n            case\
    \ '|':\n                beats = 2;\n                break;\n            case '.':\n\
    \                beats = 1;\n                break;\n            }\n        }\n\
    \        notes[note_count] = beats;\n        note_count++;\n    }\n    \n    return\
    \ notes;\n}", "{\n    \n    bool is_single_note = false, is_chord = false, is_long_note\
    \ = false;", "{\n    long[] result = new long[128];\n    int i, j, note;\n   \
    \ note = -1;", "{\n    string music_notes[] = {\"C\", \"C#\", \"D\", \"D#\", \"\
    E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"};", "{\n    // Your code\
    \ here\n    // This code might not be correct\n    music_string = music_string.trim();\
    \ // remove leading and trailing spaces\n    string[] tokens = music_string.split(\"\
    \ \"); // split string into multiple tokens\n    List<long> notes = new List<long>();\n\
    \    string note = \"\";\n    long beat = 0;\n    string rest = \"\";", "{\n \
    \   char notes[] = \"01234\";\n    int notes_count = notes.length();\n    int\
    \ beats = 4, last_beat = 0;\n    int current_beat = beats;", "{\n    \n    long[]\
    \ beats;\n    beats = new long[music_string.length()];", "{\n    Vector<long>\
    \ notes_in_chord = new Vector<long>();", "{\n    int n_beats = (int)std.math.pow(2.0,\
    \ std.typecons.toDouble(music_string.charAt(0)) - 48);\n    for (int i = 1; i\
    \ < music_string.length(); i++) {\n        if (music_string[i] == '.') {\n   \
    \         n_beats = n_beats / 2;\n        } else {\n            int n_beats_this_note\
    \ = (int)std.math.pow(2.0, std.typecons.toDouble(music_string[i]) - 48);\n   \
    \         if (n_beats_this_note > n_beats) {\n                n_beats = n_beats_this_note;\n\
    \            }\n        }\n    }\n    return new long[n_beats];\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\nI actually wrote some code to do exactly\
    \ what you're trying to do, and it turns out to be really simple. As long as your\
    \ input is as simple as 'o' or 'o|' and you don't have any repeated notes, it\
    \ will work for you. Here is my code:\n<code>\n    long NoteLength(string note_str,\
    \ int num_beats)\n    {\n        long note_size = std.math.pow(2.0, std.typecons.toDouble(note_str.charAt(0))\
    \ - 48);\n        for (int i = 1; i < note_str.length(); i++)\n        {\n   \
    \         long note_len = std.math.pow(2.0, std.typecons.toDouble(note_str.charAt(i))\
    \ - 48);\n            if (note_len > note_size)\n            {\n             \
    \   note_size = note_len;\n            }\n        }\n        return (num_beats\
    \ * note_size);\n    }", "{\n\tstring[] note_chars = music_string.split(\" \"\
    );\n\tint last_beat = 0;\n\tlong[] beats = new long[note_chars.length];\n\tfor(int\
    \ i = 0; i < note_chars.length; i++){\n\t\tnote_char note_char = note_chars[i];\n\
    \t\tif (note_char == 'o'){\n\t\t\tlast_beat = 4;\n\t\t}\n\t\telse if (note_char\
    \ == 'o|'){\n\t\t\tlast_beat = 2;\n\t\t}\n\t\telse if (note_char == '.|'){\n\t\
    \t\tlast_beat = 1;\n\t\t}\n\t\telse{\n\t\t\tthrow new Exception(\"The provided\
    \ music string is not in valid format. Music string should contain o o| .| o|\
    \ o| .| .| .| .| .| o o format. Note is \" + note_char);\n\t\t}\n\t\tbeats[i]\
    \ = last_beat;\n\t}\n\treturn beats;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for\
    \ your answer! I'm new to C and this really helped me out!\n<|/ c |>\n<| c |>\n\
    No problem! I remember having to go through similar problems in the past and I\
    \ think I remember solving it with a series of loops and some if statements. But\
    \ I forgot the exact solution. Hopefully it helps you!\n<|/ c |>\n<| c |>\nI've\
    \ been working on this for a while now, and can't get it to work. I realise I'm\
    \ probably doing something stupid, but I can't figure out what it is. I've tried\
    \ using your method, and I still can't get it to work. I don't know if it has\
    \ to do with the fact that I'm using a windows pc, and I think that's the problem.\
    \ The code you gave me works perfectly for Linux, so I thought I could use it,\
    \ but then I realise I may need something with Windows instead of Linux. Would\
    \ you mind looking at the code you provided and seeing if anything else could\
    \ be wrong?\n<|/ c |>\n<| c |>\nSorry for the late reply! I did some testing on\
    \ a Windows PC and it worked exactly like you said. I tried running it on CodeBlocks\
    \ and it ran perfectly. I am going to restart my PC and see if that's the problem\
    \ and report back.\n<|/ c |>\n<| c |>\nAwesome! That would be very helpful! If\
    \ you could report back what I did wrong, that would be great!\n<|/ c |>\n<| a\
    \ dscore=1 tags=c#,algorithm,java |>\nHere is a sample C# code that seems to do\
    \ what you want:\n<code>\nusing System;", "{\n    char[] ascii_music = toAscii(music_string);\n\
    \    int n = ascii_music.length;\n    long[] beats = new long[n];\n    for(int\
    \ i = 0; i < n; i++){\n        beats[i] = 0;\n    }", "{\n    var notes = new\
    \ ArrayList();\n    var num = 0;\n    for(int i = 0; i < music_string.length;\
    \ i++)\n    {\n        if(music_string[i] == 'o' || music_string[i] == '|')\n\
    \        {\n            notes.add(num);\n            num = 0;\n        }\n   \
    \     else\n            num ++;\n    }\n    \n    for(int i = 0; i < notes.Count;\
    \ i++)\n    {\n        var note = notes[i];\n        var last_note = notes[notes.Count\
    \ - 1];\n        notes.RemoveAt(notes.Count - 1);\n        notes.Add(last_note\
    \ - note);\n    }", "{\n    long beats[]  = new long[16];\n    long notes_beat_counter\
    \ = 0;\n    long notes_in_note;\n    long notes_current_note = 0;", "{\n\tList<long>\
    \ results = new List();", "{\n    ArrayList <long> notes_in_chords = new ArrayList\
    \ <long> ();\n    int note = 0;\n    int note_count = 0;\n    int i = 0;\n   \
    \ while (i < music_string.Length) {\n        if (music_string[i] == 'o') {\n \
    \           note++;\n            note_count = 0;\n        }\n        else if (music_string[i]\
    \ == 'o|') {\n            note_count++;\n        }\n        else if (music_string[i]\
    \ == '.|') {\n            note_count--;\n        }\n        notes_in_chords.Add(note\
    \ * note_count);\n        i++;\n    }", "{\n    int last_beat = 0;\n    long[]\
    \ notes = new long[128];\n    for(int i = 0; i < music_string.length(); i++)\n\
    \    {\n        if(music_string[i] == '|')\n            last_beat = 1;\n     \
    \   else\n        {\n            int note = music_string[i] - '0';\n         \
    \   if(last_beat)\n            {\n                notes[note] += (16 * last_beat);\n\
    \                last_beat = 0;\n            }\n            else\n           \
    \     notes[note] += 1;\n        }\n    }\n    return notes;\n}\n</code>\n<|/\
    \ a tags=performance,c,c++,algorithm |>\n<| a dscore=1 |>\nI would recommend that\
    \ you use an unordered_map (C++11 or Boost libraries) to keep track of the number\
    \ of beats per note.  That will make your lookup much faster.\n<|/ a tags=performance,c,c++,algorithm\
    \ |>\n<| a dscore=0 tags=performance,c,c++,algorithm |>\nI'd say just put everything\
    \ in a hashmap - that's how you get good constant time lookup in O(1). I'm sure\
    \ you can get the best constant time lookup by using a hashmap of hashmaps, but\
    \ that requires some thought about the exact algorithms you want to use.\n<|/\
    \ a |>\n<| a tags=performance,c,c++,algorithm |>\nIf you know that your strings\
    \ are always going to be the same length you could always use a single char or\
    \ int array that stores all the characters. Then you can just check what char\
    \ you are at and if it is a | you know you are looking at a chord. \nThis assumes\
    \ you know what chords are going to be in your data ahead of time. If you are\
    \ not sure you can always use a hashmap to store your notes so you can have O(1)\
    \ lookup.\n<|/ a dscore=0 |>\n<| c |>\nThat won't work, since there are more than\
    \ 1 type of chord. Some are flat, some have a chord length, and some have multiple\
    \ chords.\n<|/ c |>\n<| c |>\nHe said \"chords\", but he didn't say anything about\
    \ chords having to be multiple chords. I think he meant chords having to be different\
    \ lengths, because he says \"the length of each chord is different\", which would\
    \ lead me to believe that chords could have different lengths.\n<|/ c |>\n<| a\
    \ |>\nA simple solution is to just keep a counter for each note until you encounter\
    \ another |. After you encounter another |, you increment the count for that note.\n\
    <|/ a tags=performance,c,c++,algorithm dscore=0 |>\n<| a tags=performance,c,c++,",
  "{\n    var beats = music.parse(music_string).asArray();\n    var beats_count =\
    \ beats.Length;", "{\n    long[] note_counts = new long[music_string.Length];\n\
    \    foreach(char c in music_string) \n    {\n        note_counts[(int)c - 64]++;\n\
    \    }", "{\n    // Your code goes here\n    long[] beats = { 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0 };\n    int note = 0;\n    for (int i = 0; i < music_string.length();\
    \ ++i) {\n        char c = music_string[i];\n        if (c == '.') {\n       \
    \     note++;\n            if (note > 4) {\n                note = 1;\n      \
    \          beats[note-1]++;\n            }\n        } else {\n            note\
    \ = 0;\n            beats[note-1]++;\n        }\n    }", "{\n    int i, beats;\n\
    \    long notes[] = new long[11];\n    for(i = 0; i < music_string.length(); i++)\n\
    \    {\n        notes[i % 11] += (music_string[i] == '.' || music_string[i] ==\
    \ 'o');\n    }\n    return notes;\n}\n</code>\nThe beat calculation works pretty\
    \ much the same way.\n<|/ a dscore=2 |>\n<| c |>\nYou don't need to use a modulus.\
    \ Just use i%11 as your array index. You don't even need to store your notes in\
    \ an array, you can just make an array of bools. `bool notes[] = { false, false,\
    \ false, false, false, false, false, false, false, false, false, false };`\n<|/\
    \ c |>\n<| c |>\nYes, I agree, I just wanted to keep it simple and easy to understand.\n\
    <|/ c |>\n<| a tags=arrays,java,loops,string dscore=1 |>\nA possible solution\n\
    <code>\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\
    import java.util.List;", "{\n    var music_array = music.split_by_space(music_string);\n\
    \    var n_music = music_array.length;\n    long[] n_beats = new long[n_music];\n\
    \    for(int i = 0; i < n_music; i++)\n        n_beats[i] = music_array[i].length()\
    \ % 4 == 0 ? music_array[i].length() / 4 : music_array[i].length() / 2 - 1;",
  "{\n    // Your code goes here!\n    int beats_per_bar = 4;\n    long[] note_durations\
    \ = new long[music_string.size()];\n    string s = music_string.substr(0,music_string.size()-1);\n\
    \    for(int i = 0; i < music_string.size(); i++)\n    {\n        string chord\
    \ = music_string.substr(i,1);\n        note_durations[i] = beats_per_bar * chords.find(chord);\n\
    \    }\n    return note_durations;\n}\n</code>\n<|/ a tags=arrays,function,java,string\
    \ |>\n<| c |>\nthanks for answering. I've only started coding Java so I don't\
    \ really know where to begin and I understand what you mean but I'm unsure how\
    \ to implement it. I've tried implementing this in my code but it gives me an\
    \ error that \"i\" is out of bounds when it reaches music_string.size(). I know\
    \ that means it's out of bounds but I don't know how to fix it.\n<|/ c |>\n<|\
    \ c |>\nOh I see I didn't use i instead of 0 but music_string.size()-1 but now\
    \ it says it's out of bounds when I run it\n<|/ c |>\n<| c |>\nSorry I forgot\
    \ to mention that music_string is a string, so music_string.size() is the size\
    \ of the string, not the size of the array\n<|/ c |>\n<| c |>\nOk thank you so\
    \ much for helping me. I understand what you meant now.\n<|/ c |>\n<| c |>\nIf\
    \ an answer has helped you to solve your issue, please mark it as the accepted\
    \ answer, so other people know that your issue is resolved.\n<|/ c |>\n<| a tags=arrays,function,java,string\
    \ |>\n<code>\npublic static long[] getDurations(String music) {\n    long[] durations\
    \ = new long[music.length()];\n    for (int i = 0; i < music.length(); i++) {\n\
    \        char c = music.charAt(i);\n        durations[i] = -1;\n        if (c\
    \ != '-') {\n            if (c != '|') {\n                if (c != 'o') {\n  \
    \                  if (c != '|') {\n                        if (c != '|') {\n\
    \                            if (c != '|') {\n                               \
    \ if (c != '|') {\n                                    if (c != '|') {\n     \
    \                                   if (c != '|') {\n                        \
    \                    if (c != '|') {\n                                       \
    \         if (c != '|') {\n                                                  \
    \  if (c != '|') {\n                                                        if\
    \ (c != '|') {\n                                                            if\
    \ (c != '|') {\n                                                             \
    \   if (c != '|') {\n                                                        \
    \            if (c != '|') {\n                                               \
    \                         durations[i] = 4;\n                                \
    \                                    }\n                                     \
    \                               if (c != '|') {\n                            \
    \                                            durations[i] = 2;\n             \
    \                                                       }\n", "{\n    bool is_full_note\
    \ = false;\n    long last_beats = 1;", "{\n    long[] result = new long[music_string.Length\
    \ / 2];\n    for (int i = 0; i < music_string.Length; i += 2)\n    {\n       \
    \ int note = music_string[i] - '0';\n        int octave = music_string[i + 1]\
    \ - '0';\n        int beats = octave + 1;\n        result[i/2] = beats;\n    }",
  "{\n    // write your code here\n    long int i = 0;\n    long int note_count =\
    \ 0;\n    int current_note = 0;\n    int j = 0;\n    for(int x=0; x<music_string.length();\
    \ x++)\n    {\n        if(music_string[x] == '|')\n        {\n            current_note\
    \ = note_count;\n            note_count = 0;\n            j++;\n        }\n  \
    \      else\n        {\n            if(music_string[x] == 'o')\n             \
    \   note_count++;\n            if(music_string[x] == ' ' || music_string[x] ==\
    \ '\\t' || music_string[x] == '\\n')\n            {\n                note_count\
    \ = current_note;\n                current_note = 0;\n                i++;\n \
    \           }\n        }\n    }\n    long[] music_array = new long[i+1];\n   \
    \ for(int x=0; x<music_string.length(); x++)\n    {\n        if(music_string[x]\
    \ == '|')\n            music_array[music_array.length-1]++;\n        else\n  \
    \          music_array[music_array.length-1] += note_count;\n    }\n    return\
    \ music_array;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for that quick\
    \ reply. I tried to make some changes to your code but I am having some problems.\
    \ Firstly, in the else statement after if(music_string[x] == 'o') you are supposed\
    \ to add note_count to the note_count, but note_count is always zero. Secondly,\
    \ I do not know what to do with the \"j++\" in the else statement, because it\
    \ seems that j is being incremented, but not being used anywhere.\n<|/ c |>\n\
    <| c |>\nOk, I managed to make your code work, but I am not getting the correct\
    \ output. Could you please have a look at my question here: https://stackoverflow.com/questions/55714290/how-to-convert-ascii-music-notation-to-beats-in-c-sharp?noredirect=1#comment95714648_55714290\
    \ Thanks\n<|/ c |>\n<| a tags=algorithm,c#,parsing |>\nI wanted to provide a different\
    \ solution in C# using regular expressions:\n<code>\n    static void Main(string[]\
    \ args)\n    {\n        var s = @\"o o| .| o| o| .| .| .| .| o o\";\n        Regex\
    \ r = new Regex(@\"o(\\|.)|(.+)\");\n        string sOutput = r.Replace(s, new\
    \ MatchEvaluator(ConvertMusic));", "{\n    string notes[] = {\"o\",\"o|\",\"|.\"\
    ,\"o|\",\"o|\",\"o|\",\"o|\",\"o|\",\"o|\",\"o|\",\"o|\",\"o|\",\"o|\",\"o|\"\
    ,\"o|\",\"o|\",\"o|\"};", "{\n    string music;\n    long temp = 0;\n    long\
    \ duration = 0;\n    string note;\n    int beat = 0;\n    long current_note =\
    \ 0;\n    long note_length = 0;\n    long note_count = 0;\n    string temp_string;\n\
    \    bool first = true;", "{\n    long notes_counter = 0;\n    bool firstNote\
    \ = true;\n    long temp_note = 0;\n    string note = \"\";\n    long last_beat\
    \ = 0;\n    long[] beats = new long[4];\n    for (int i = 0; i< music_string.length();\
    \ i++) \n    {\n        note = music_string[i];", "{\n    var notes = music_string.split(\"\
    \ \");\n    var beats = new long[notes.Length];\n    var length = notes.Length;\n\
    \    var last = 0;\n    for (var i=0; i < notes.Length; i++)\n    {\n        if\
    \ (notes[i] == '.')\n            last = 0;\n        else if (notes[i] == '|')\n\
    \            last = 1;\n        else\n        {\n            var beat = (notes[last\
    \ + 1] - '0') * 4;\n            beats[i] = beat;\n            beats[i + 1] = beat;\n\
    \            beats[i + 2] = beat;\n            beats[i + 3] = beat;\n        \
    \    last += 1;\n        }\n    }", "{\n    long output[] = new long[music_string.size()];",
  "{\n  \n  \n  vector<int> beats_per_note;\n  beats_per_note.push_back(0);", "{\n\
    \    int beat_counter = 0;\n    string beat_mark = \"\";\n    int current_beat\
    \ = 0;\n    int total_beats = 0;\n    vector<int> current_beats(7);\n    for(int\
    \ i = 0; i< music_string.size(); i++)\n    {\n        beat_mark = \"\";\n    \
    \    if(music_string[i] == '|')\n        {\n            if(current_beat == 0)\n\
    \            {\n                beat_mark = \"o\";\n                beat_counter\
    \ = 4;\n                current_beat = 1;\n            }\n            else\n \
    \           {\n                beat_mark = \"o|\";\n                beat_counter\
    \ = 2;\n                current_beat = 2;\n            }\n        }\n        else\
    \ if(music_string[i] == 'o')\n        {\n            if(current_beat == 0)\n \
    \           {\n                beat_mark = \"o\";\n                beat_counter\
    \ = 4;\n                current_beat = 1;\n            }\n            else if(current_beat\
    \ == 1)\n            {\n                beat_mark = \"o|\";\n                beat_counter\
    \ = 2;\n                current_beat = 2;\n            }\n            else if(current_beat\
    \ == 2)\n            {\n                beat_mark = \".|\";\n                beat_counter\
    \ = 1;\n                current_beat = 3;\n            }\n            else if(current_beat\
    \ == 3)\n            {\n                beat_mark = \"o|\";\n                beat_counter\
    \ = 2;\n                current_beat = 2;\n            }\n            else if(current_beat\
    \ == 4)\n            {\n                beat_mark = \".|\";\n                beat_counter\
    \ = 1;\n                current_beat = 3;\n            }\n            else if(current_beat\
    \ == 5)\n            {\n                beat_mark = \"o|\";\n                beat_counter\
    \ = 2;\n                current_beat = 2;\n            }\n            else if(current_beat\
    \ == 6)\n            {\n                beat_mark = \".|\";\n                beat_counter\
    \ = 1;\n                current_beat = 3;\n            }\n            else if(current_beat\
    \ == 7)\n            {\n                beat_mark = \"o|\";\n                beat_counter\
    \ = 2;\n                current_beat = 2;\n            }\n        }\n        else\
    \ if(music_string[i] == '.')\n        {\n            if(current_beat == 0)\n \
    \           {\n                beat_mark = \"o\";\n                beat_counter\
    \ = 4;\n                current_beat = 1;\n            }\n            else if(current_beat\
    \ == 1)\n            {\n                beat_mark = \"o|\";\n                beat_counter\
    \ = 2;\n                current_beat = 2;\n            }\n            else if(current_beat\
    \ == 2)\n            {\n                beat_mark = \".|\";\n                beat_counter\
    \ = 1;\n                current_beat = 3;\n            }\n            else if(current_beat\
    \ == 3)\n            {\n                beat_mark = \"o|\";\n                beat_counter\
    \ = 2;\n                current_beat = 2;\n            }\n            ", "{\n\
    \    int beats_counter = 0;\n    beats_counter++;\n    beats_counter = beats_counter\
    \ / 4;\n    int beats_counter1 = 0;\n    beats_counter1++;\n    beats_counter1\
    \ = beats_counter1 / 2;\n    beats_counter1 = beats_counter1 / 4;\n    beats_counter1\
    \ = beats_counter1 / 4;\n    beats_counter1 = beats_counter1 / 4;\n    int beats_counter2\
    \ = 0;\n    beats_counter2++;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;\n    beats_counter2 = beats_counter2 / 4;\n    beats_counter2\
    \ = beats_counter2 / 4;", "{\n    int[] notes = new int[128];\n    int[] beats\
    \ = new int[128];\n    int index = 0;\n    int current = 0;\n    for (int i =\
    \ 0; i < music_string.Length; i++)\n    {\n        if (music_string[i] == '.')\n\
    \        {\n            while (current != 0)\n            {\n                notes[index]\
    \ = notes[index] + beats[current];\n                current--;\n             \
    \   index++;\n            }\n            beats[current] = 1;\n            current++;\n\
    \        }\n        else if (music_string[i] == 'o')\n        {\n            while\
    \ (current != 0)\n            {\n                notes[index] = notes[index] +\
    \ beats[current];\n                current--;\n                index++;\n    \
    \        }\n            beats[current] = 4;\n            current++;\n        }\n\
    \        else if (music_string[i] == '|')\n        {\n            while (current\
    \ != 0)\n            {\n                notes[index] = notes[index] + beats[current];\n\
    \                current--;\n                index++;\n            }\n       \
    \     beats[current] = 2;\n            current++;\n        }\n        else\n \
    \       {\n            beats[current]++;\n        }\n    }\n    for (int i = 0;\
    \ i < notes.Length; i++)\n    {\n        notes[i] = notes[i] % 128;\n    }\n \
    \   return notes;\n}", "{\n    long[] res = new long[music_string.Length/2];\n\
    \    int i = 0;\n    int k = 0;\n    char c = ' ';\n    bool is_quarter = false;\n\
    \    \n    // find first space in string\n    while (c != ' ' && c != '\\t' &&\
    \ c != '\\n')\n        c = music_string[i++];", "{\n    stack<int> beats;\n  \
    \  beats.push(0);\n    beats.push(0);\n    beats.push(0);\n    beats.push(0);",
  "{\n    // TODO: Replace this with something more efficient by parsing string line\
    \ by line\n    \n    List<string> music_lines = music_string.split(\"\\\\n\");\n\
    \    long[] result = new long[music_lines.Count];", "{\n    // TODO: Fill this\
    \ in\n    return null;\n}\n</code>\nAnd here are the unit tests to verify this\
    \ works:\n<code>\n[TestFixture]\npublic class MusicTests\n{\n    [Test]\n    public\
    \ void MusicTest()\n    {\n        string music_string = \"o o| .| o| o| .| .|\
    \ .| .| o o\";\n        long[] music = parse_music(music_string);\n        Assert.AreEqual(music.Length,\
    \ 8);\n        Assert.AreEqual(music[0], 4L);\n        Assert.AreEqual(music[1],\
    \ 2L);\n        Assert.AreEqual(music[2], 1L);\n        Assert.AreEqual(music[3],\
    \ 2L);\n        Assert.AreEqual(music[4], 2L);\n        Assert.AreEqual(music[5],\
    \ 1L);\n        Assert.AreEqual(music[6], 1L);\n        Assert.AreEqual(music[7],\
    \ 1L);\n    }", "{\n    var beats = 0;\n    var notes = new List<long>();\n  \
    \  var notes_index = -1;\n    var notes_type = 0;\n    var note_char = 0;\n  \
    \  var note_char_index = 0;\n    \n    for (var beat = 0; beat < 4; beat++) {\n\
    \        beats = 0;\n        notes_index = 0;\n        note_char_index = 0;\n\
    \        \n        notes_type = notes_chars[notes_index];\n        note_char =\
    \ notes_chars[note_char_index];\n        \n        switch (note_char) {\n    \
    \        case 'o':\n                notes.Add(parse_note(music_string, notes_index,\
    \ beats, notes_type));\n                break;\n            case '|':\n      \
    \          notes.Add(parse_note(music_string, notes_index, beats, notes_type));\n\
    \                beats += 2;\n                break;\n            case '.':\n\
    \                notes.Add(parse_note(music_string, notes_index, beats, notes_type));\n\
    \                beats += 1;\n                break;\n            default:\n \
    \               note_char_index++;\n                break;\n        }\n    }\n\
    \    \n    return notes.ToArray();\n}\n/*\n Input to this function is a string\
    \ representing musical notes in a special ASCII format.\n    The function returns\
    \ last beat number of each note in the string", "{\n  string current_note;\n \
    \ long[] notes; // array to return with all the notes\n  notes = new long[MUSIC_NOTES.length];\
    \ // array to return with the count of each note", "{\n\tmusic_string = music_string.trim();\n\
    \tlong beats = 0, cur_beats = 0;\n\tlong note = 0, cur_note = 0;\n\twhile(music_string.hasNext())\n\
    \t{\n\t\tstring s = music_string.nextToken();\n\t\tswitch(s.charAt(0))\n\t\t{\n\
    \t\t\tcase 'o':\n\t\t\t\tnote = cur_note;\n\t\t\t\tbeats = cur_beats;\n\t\t\t\t\
    cur_beats = 0;\n\t\t\t\tbreak;\n\t\t\tcase 'o|':\n\t\t\t\tnote = cur_note + 4;\n\
    \t\t\t\tbeats = cur_beats;\n\t\t\t\tcur_beats = 0;\n\t\t\t\tbreak;\n\t\t\tcase\
    \ '.|':\n\t\t\t\tnote = cur_note + 8;\n\t\t\t\tbeats = cur_beats;\n\t\t\t\tcur_beats\
    \ = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"\
    Unknown note '\" + s + \"'\");\n\t\t}", "{\n    /*\n        We will use a map\
    \ to keep track of what beats each note lasts. \n        We can also use maps\
    \ to keep track of each of the notes themselves. \n        But I wanted to keep\
    \ it simple and use array as intermediate results. \n        \n        So, we\
    \ will have maps of maps. \n        First map in each map will keep track of last\
    \ beats of each note in the \n        musical note string. \n        The inner\
    \ map will have key beat of each note and value will be the note itself. \n  \
    \      \n        Note that we could have used maps to keep track of beats of chords\
    \ and \n        note itself. We would have to store all the chords in the first\
    \ map\n        in the inner maps, while keeping the note string in the outer map\n\
    \        but this way we would have to use two maps and a helper function\n  \
    \      to help us keep track of the last beats of each note. ", "{\n   long[]\
    \ results = new long[music_string.length()];\n   for (int i = 0; i < music_string.length();\
    \ i++)\n   {\n      string note = music_string.substr(i, 2);\n      switch (note)\n\
    \      {\n         case \"o\":\n         {\n            results[i] = 4;\n    \
    \        break;\n         }\n         case \"o|\":\n         {\n            results[i]\
    \ = 2;\n            break;\n         }\n         case \".|\":\n         {\n  \
    \          results[i] = 1;\n            break;\n         }\n         default:\n\
    \         {\n            break;\n         }\n      }\n   }\n   return results;\n\
    }\n</code>\n<|/ a tags=java,string dscore=1 |>\n<| c |>\nThanks alot, I will try\
    \ this and see if it works for me!\n<|/ c |>\n<| c |>\nI guess there should be\
    \ a more elegant solution with regex to match only specific notes, like \"o\"\
    \ , \".\", \"o|\", \"o|\", \".|\".\n<|/ c |>\n<| a dscore=1 tags=java,string |>\n\
    The other answer will work but its not very elegant. \nYou can use regex to find\
    \ out how many beats each note last like so.\n<code>\npublic class RegexTest{",
  "{\n    long beats_per_note[] = new long[MAX_PITCH + 2];", "{\n    string note_symbol\
    \ = string(music_string[0]);", "{\n    string current_note;\n    long current_beat\
    \ = 0;\n    long[] note_count = new long[128];", "{\n    long output[] = new long[music.size()];\n\
    \    for(int i = 0; i < music.size(); i++)\n    {\n        char c = music[i];\n\
    \        if(c == 'o')\n        {\n            output[i] = 4;\n        }\n    \
    \    else if(c == 'o|')\n        {\n            output[i] = 2;\n        }\n  \
    \      else if(c == '.|')\n        {\n            output[i] = 1;\n        }\n\
    \    }", "{\n  List <long> result = new List<long>();", "{\n    if (music_string.StartsWith(\"\
    o\"))\n    {\n        int temp = 0;\n        long beats = 4L;\n        string\
    \ note = music_string.Substring(1);\n        music_string = note;\n        foreach\
    \ (char c in note)\n        {\n            temp = temp + 2L * std.typecons.Char.IsWhiteSpace(c)\
    \ * std.typecons.Char.IsDigit(c);\n            beats *= std.math.Ceil(std.typecons.Signed.div(std.typecons.Signed.from(temp),\
    \ 12L));\n            temp = (temp - 2L * std.typecons.Char.IsWhiteSpace(c) *\
    \ std.typecons.Char.IsDigit(c));\n        }\n        return new long[] {beats,\
    \ beats, beats, beats};\n    }\n    else if (music_string.StartsWith(\"o|\"))\n\
    \    {\n        int temp = 0;\n        long beats = 2L;\n        string note =\
    \ music_string.Substring(1);\n        music_string = note;\n        foreach (char\
    \ c in note)\n        {\n            temp = temp + 2L * std.typecons.Char.IsWhiteSpace(c)\
    \ * std.typecons.Char.IsDigit(c);\n            beats *= std.math.Ceil(std.typecons.Signed.div(std.typecons.Signed.from(temp),\
    \ 12L));\n            temp = (temp - 2L * std.typecons.Char.IsWhiteSpace(c) *\
    \ std.typecons.Char.IsDigit(c));\n        }\n        return new long[] {beats,\
    \ beats, beats};\n    }\n    else if (music_string.StartsWith(\".|\"))\n    {\n\
    \        int temp = 0;\n        long beats = 1L;\n        string note = music_string.Substring(1);\n\
    \        music_string = note;\n        foreach (char c in note)\n        {\n \
    \           temp = temp + 2L * std.typecons.Char.IsWhiteSpace(c) * std.typecons.Char.IsDigit(c);\n\
    \            beats *= std.math.Ceil(std.typecons.Signed.div(std.typecons.Signed.from(temp),\
    \ 12L));\n            temp = (temp - 2L * std.typecons.Char.IsWhiteSpace(c) *\
    \ std.typecons.Char.IsDigit(c));\n        }\n        return new long[] {beats,\
    \ beats};\n    }\n    else\n    {\n        throw new ArgumentException(\"Invalid\
    \ musical note format\");\n", "{\n    string note = \"o\";\n    \n    for(int\
    \ i = 0; i < music_string.Length; i++)\n    {\n        if(note[0] == music_string[i])\n\
    \        {\n            if(note[1] == \"|\")\n                note = note.Substring(1,\
    \ note.Length - 1);\n            else if(note[1] != \".\")\n            {\n  \
    \              int count = 4;\n                int pos = 0;\n                while(note[pos]\
    \ == note[i])\n                    pos++;\n                if(pos == 1)\n    \
    \                count++;\n                else if(pos == 2)\n               \
    \     count++;\n                else if(pos == 3)\n                    count++;\n\
    \                note = note.Substring(1, note.Length - 1);\n                return\
    \ new long[count];\n            }\n            else\n                note = note.Substring(1,\
    \ note.Length - 1);\n        }\n    }\n    return null;\n}", "{\n    long[] result\
    \ = new long[64];", "{\n    long[] beats_array = new long[MUSIC_MAX_NOTES];\n\
    \    int note_counter = 0;", "{\n    string note;\n    char notes[] = \"o o| .|\
    \ o| o| .| .| .| .| .| o o\";\n    long current_beat = 1;\n    long current_note\
    \ = 0;\n    int note_count = 0;\n    long[] beats = new long[100];\n    for (int\
    \ i = 0; i < notes.length(); i += 2)\n    {\n        note = notes.substring(i,\
    \ i+2);\n        if (note.length() == 1)\n        {\n            current_note\
    \ = std.typecons.char2int(note.charAt(0)) - '0';\n        }\n        else\n  \
    \      {\n            current_note = std.typecons.char2int(note.charAt(1)) - '0';\n\
    \        }\n        \n        note_count = note_count + 1;\n        if (note_count\
    \ > 100)\n        {\n            note_count -= 100;\n            beats[current_beat]\
    \ = beats[current_beat] * 100 + note_count;\n            beats[current_beat] =\
    \ std.math.toInt(beats[current_beat]);\n            current_beat++;\n        \
    \    note_count = 0;\n        }\n    }\n    return beats;\n}\n</code>\n<|/ a tags=arrays,c#\
    \ |>\n<| c |>\nThank you for your help! I really appreciate it! However, this\
    \ one returns an array which does not correspond to my example. I am not sure\
    \ how I should change my code to return this array?\n<|/ c |>\n<| c |>\nIt looks\
    \ like your example should return the array `[4L, 2L, 1L, 2L, 2L, 1L, 1L, 1L,\
    \ 1L, 4L, 4L]`, but instead it returns `[1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L, 1L]`.\n<|/ c |>\n<| c |>\nYes, you are right. Maybe I should explain what\
    \ I am trying to do. I have an array `[6L, 6L, 7L, 7L, 8L, 8L, 8L, 9L, 9L, 9L,\
    \ 10L, 10L, 10L]`. After parsing, this array should return `[6, 6, 7, 7, 8, 8,\
    \ 8, 9, 8, 9, 8, 9, 10]`\n<|/ c |>\n<| c |>\nIf you can provide the exact output\
    \ you're looking for and explain what it's supposed to mean to return that array\
    \ in the manner you've described, then I think I can edit my answer to be more\
    \ precise about what I mean and how to achieve it. As it stands, your question\
    \ is a bit vague.\n<|/ c |>\n<| c |>\nI have made a mistake, it should be `[4,\
    \ 2, 2, 1, 2, 1, 2, 1, 2, 1, 4, 4]", "{\n    string last_note, note;\n    int\
    \ n_beats = 0, n_beats_without_last_note = 0, n_beats_with_last_note = 0;\n  \
    \  bool last_note_was_note = false;\n    long beat = 0;\n    for (int i = 0; i\
    \ < music_string.size() && !(music_string[i] == '.' || music_string[i] == 'o');\
    \ i++) {\n        note = music_string[i];\n        if (note == 'o') {\n      \
    \      last_note = note;\n            last_note_was_note = true;\n           \
    \ n_beats += 4;\n        } else if (note == 'o|') {\n            if (last_note\
    \ == 'o') {\n                last_note = note;\n                last_note_was_note\
    \ = true;\n                n_beats += 2;\n            } else {\n             \
    \   last_note_was_note = false;\n                n_beats_without_last_note +=\
    \ 2;\n            }\n        } else if (note == '.|') {\n            if (last_note\
    \ == 'o') {\n                last_note = note;\n                last_note_was_note\
    \ = true;\n                n_beats += 1;\n            } else {\n             \
    \   last_note_was_note = false;\n                n_beats_with_last_note += 1;\n\
    \            }\n        } else {\n            throw new Exception(\"The note \"\
    \ + note + \" is not supported.\");\n        }\n        if (n_beats_without_last_note\
    \ == 0 && n_beats_with_last_note == 0) {\n            beat = std.int::parse('0'\
    \ + n_beats.to_string());\n        } else {\n            if (n_beats_without_last_note\
    \ == 0) {\n                beat = std.int::parse('0' + n_beats.to_string() + last_note);\n\
    \            } else {\n                if (n_beats_with_last_note == 0) {\n  \
    \                  beat = std.int::parse('0' + n_beats.to_string() + last_note\
    \ + last_note);\n                } else {\n                    beat = std.int::parse('0'\
    \ + n_beats.to_string() + last_note + last_note + last_note);\n              \
    \  }\n            }\n        }\n    }\n    return std.array!long[beat];\n}\n</code>\n\
    Output:\n<code>\n$ ./bin/music_to_array music.txt\narray [4, 2, 2, 1, 1, 1, 2,\
    \ 1, 1, 1, 4, 4]\n</code>\n<|/ a tags=c++,algorithm,c++-modules,c++17 |>\n<| c\
    \ |>\nI like your use of the `std.array!long[beat]`. Very clever :)\n<|/ c |>\n\
    <| c |>\nWhat are those `!`? Is it a typo?\n<|/ c |>\n<| c |>\nNo, it's C++/std\
    \ syntax. `!` is `not` operator, not a typo.\n<|/ c |>\n<| c ", "{\n    var chord\
    \ = music_string;\n    var beats_in_chord = 0;\n    var current_chord = 0;\n \
    \   var last_note = 0;\n    var chords = [];\n    var length = chord.length;\n\
    \    \n    for (var i = 0; i < length; i++)\n    {\n        if (chord[i] == 'o')\n\
    \        {\n            beats_in_chord++;\n        }\n        else\n        {\n\
    \            if (chord[i] == '|')\n            {\n                chords[current_chord]\
    \ = chords[current_chord] + beats_in_chord;\n            }\n            else\n\
    \            {\n                chords[current_chord] = beats_in_chord;\n    \
    \        }\n            current_chord++;\n            beats_in_chord = 0;\n  \
    \      }\n    }\n    chords[current_chord] = chords[current_chord] + beats_in_chord;\n\
    \    return chords;\n}\n</code>\n<|/ a |>\n<| a tags=java,parsing,algorithm |>\n\
    The simple solution would be to iterate through the chars of the string and compare\
    \ them with the corresponding values inside the Chords array.\n<code>\nchar[]\
    \ ch = new char[6];", "{\n    long[] beats = new long[music_string.Length];\n\
    \    long current_beat = 0;\n    for (int i = 0; i < music_string.Length; ++i)\
    \ \n    {\n        char c = music_string[i];\n        if (c != '|' && c != '.')\n\
    \        {\n            beats[current_beat] += 1;\n        }\n        else if\
    \ (c == '|')\n        {\n            beats[current_beat] += 2;\n        }\n  \
    \      else if (c == '.')\n        {\n            beats[current_beat] += 1;\n\
    \        }\n        else\n        {\n            beats[current_beat] += 4;\n \
    \       }\n        if (i >= music_string.Length - 1 || music_string[i + 1] !=\
    \ '|')\n        {\n            current_beat += 1;\n        }\n    }\n    return\
    \ beats;\n}\n</code>\n<|/ a tags=algorithm,c# |>\n<| c |>\nThis approach fails\
    \ on: ```\"o|.o|.o|.o|.\"``` --> ```[4L, 2L, 2L, 2L, 2L]``` when it should be\
    \ ```[1L, 3L, 3L, 3L, 3L]```\n<|/ c |>\n<| c |>\nI see your point, I updated the\
    \ answer.\n<|/ c |>\n<| c |>\nThis is now failing on the following: ```\"o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o|.o",
  "{\n  int index = 0;\n  long last_beats = 1;\n  while(index < music_string.length())\
    \ {\n    char ch = music_string[index];\n    switch(ch) {\n    case 'o': \n  \
    \  case '|': \n    case '|':\n      last_beats = index+1;\n      break;\n    }\n\
    \    index++;\n  }\n  \n  if(last_beats == 0) \n    throw new Exception(\"Not\
    \ enough beats in music string\");\n  \n  int notes_number = music_string.length()-last_beats;\n\
    \  long[] beats_per_note = long[notes_number];\n  for(int i = 0; i < notes_number;\
    \ i++)\n    beats_per_note[i] = last_beats-music_string.subarray(last_beats+i-1,\
    \ last_beats+i).length();\n  return beats_per_note;\n}", "{\n    if (music_string\
    \ == null)\n        return null;", "{\n    int beats = 0;\n    string[] notes\
    \ = music_string.split(\" \");", "{\n    Stack<String> notes = new Stack<String>();\n\
    \    long[] return_list = new long[music_string.size()];\n    int[] current_duration\
    \ = new int[music_string.size()];\n    for(string letter : music_string)\n   \
    \ {\n        if(letter == 'o')\n        {\n            notes.push(letter);\n \
    \           return_list[current_duration.length - 1] += 4L;\n        }\n     \
    \   else if(letter == 'o|')\n        {\n            notes.push(letter);\n    \
    \        return_list[current_duration.length - 1] += 2L;\n        }\n        else\
    \ if(letter == '.|')\n        {\n            notes.push(letter);\n           \
    \ return_list[current_duration.length - 1] += 1L;\n        }\n        else\n \
    \       {\n            notes.push(letter);\n        }\n    }\n    for(int i =\
    \ 0; i < notes.size(); i++)\n    {\n        return_list[current_duration.length\
    \ - 1 - i] = std.math.ceilDiv(return_list[current_duration.length - 1 - i], 4L);\n\
    \    }\n    return return_list;\n}\n</code>\nOutput:", "{\n    long[] beats =\
    \ new long[128];", "{\n    // convert string to array of chars\n    string[] charArray\
    \ = music_string.split(' ');\n    // allocate array to the right number of beats\n\
    \    long[] noteArray = new long[64];\n    // for each character in string\n \
    \   for (string c : charArray)\n    {\n        // convert char c into its ascii\
    \ value\n        int noteAscii = charArray[c];\n        // for each octave\n \
    \       for (int octave = 0; octave < 6; octave++)\n        {\n            //\
    \ if octave is 0 (whole note) multiply noteAscii by 8\n            if (octave\
    \ == 0)\n                noteAscii *= 8;\n            // if noteAscii is between\
    \ 32 and 127, multiply it by 12 and add octave to it\n            else if (noteAscii\
    \ >= 32 && noteAscii <= 127)\n                noteAscii *= 12 + octave;\n    \
    \        // if noteAscii is 126, subtract one from octave and add 12\n       \
    \     else if (noteAscii == 126)\n                noteAscii -= 1;\n          \
    \  // if noteAscii is 128 or above, add 12 to octave and subtract 12\n       \
    \     else if (noteAscii >= 128)\n                noteAscii += 1;\n        }\n\
    \        // add noteAscii to noteArray\n        noteArray[noteAscii] += 1;\n \
    \   }\n    // return noteArray\n    return noteArray;\n}", "{\n    string[] parts\
    \ = split(music_string, \"|\");\n    long[] result = new long[parts.length];\n\
    \    for (int i = 0; i < parts.length; i++)\n    {\n        string part = parts[i];\n\
    \        string[] beats = split(part, \" \");\n        for (int j = 0; j < beats.length;\
    \ j++)\n        {\n            beats[j] = beats[j].ToLower();\n            switch\
    \ (beats[j])\n            {\n                case \"o\":\n                   \
    \ result[i] = 4L;\n                    break;\n                case \"o|\":\n\
    \                    result[i] = 2L;\n                    break;\n           \
    \     case \".|\":\n                    result[i] = 1L;\n                    break;\n\
    \                default:\n                    throw new Exception(\"Invalid note\
    \ type: \" + beats[j]);\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=algorithm,c#,data-structures |>\n<| c |>\nWhat does this\
    \ mean? `string[] beats = split(part, \" \");`?\n<|/ c |>\n<| c |>\nThe method\
    \ split takes two arguments: a string to split and a separator character. The\
    \ split method returns an array of all the splitted parts of the string separated\
    \ by the separator. Since we use the space character as the separator, we have\
    \ to use this method. The second argument is actually a delimiter, not a character.\
    \ So, for example, \"abc dde\".split(' ', ' ') returns [\"abc\", \"dde\"].\n<|/\
    \ c |>\n<| a tags=algorithm,c#,data-structures |>\nI would use regular expressions:\n\
    <code>\npublic List<int> ParseMusic(string music)\n{\n    string re = @\"^\\s*(?<note>[^|]*)\\\
    s*\\|\\s*(?<rest>[^|]*)\";\n    return Regex.Matches(music, re, RegexOptions.Singleline).Cast<Match>()\n\
    \        .Select(x => x.Groups[\"note\"].Value == \"o\" ? 4 : x.Groups[\"note\"\
    ].Value == \"o|\" ? 2 : 1)\n        .ToList();\n}\n</code>\nThe regex matches\
    \ the note, the rest is just optional whitespace.\n<|/ a dscore=0 |>\n<| c |>\n\
    I used this and it works pretty well, although it doesn't take into account the\
    \ length of the notes.  In other words, if I pass in something like \"o o| .|\
    \ o| .| o| .| .| .| o o\" it doesn't give me the correct number of beats.  It's\
    \ pretty close though.\n<|/ c |>\n<| c |>\nOk, then you could add a third group\
    \ with the number of beats in it: `string re = @\"^\\s*(?<note>[^|]*)\\s*\\|\\\
    s*(?<rest>", "{\n    long[] res = new long[64];\n    bool first = true;\n    for(int\
    \ i = 0; i< music_string.length(); i++) \n    {\n        if(first) {\n       \
    \     first = false;\n            continue;\n        }", "{\n    //First split\
    \ string by space characters\n    string[] notes = music_string.split(\" \");\n\
    \    //Now sort notes and convert them to ints\n    sort(notes);\n    long beat\
    \ = 0;\n    long[] beats = new long[notes.length];\n    for (int i = 0; i < notes.length;\
    \ i++) \n    {\n        if (notes[i] != \"o\" && notes[i] != \"o|\" && notes[i]\
    \ != \".|\")\n            beat = beat * 12 + notes[i].ToInt64() - 48;\n      \
    \  else\n            beats[i] = beat;\n        beat += 1;\n    }\n    return beats;\n\
    }\n</code>\n<|/ a tags=c#,algorithm |>\n<| c |>\n`parse-music(\"o| .| o| o| .|\
    \ .| .| .| .| o\")` returns `[4]` instead of `[4, 1, 1, 2, 2, 1, 3, 1, 1, 2, 1]`\n\
    <|/ c |>\n<| c |>\nOops, fixed. Now it is working :)\n<|/ c |>\n<| c |>\nIt is\
    \ not working correctly for parse-music(\"o| .| o| o| .| .| .| o| .| .| o| .|\
    \ o| .| o| .| o\"). Here it returns `[2, 1, 1, 2, 1, 1, 2, 1]` instead of `[4,\
    \ 1, 1, 2, 2, 1, 3, 1, 1, 2, 1]`. So it seems like some sort of bug.\n<|/ c |>\n\
    <| c |>\nOops, sorry. Fixed it. Thank you for pointing out the bug!\n<|/ c |>\n\
    <| c |>\nYou're welcome. I made a small mistake when checking if next notes are\
    \ different than 'o|' or '.|', so I edited it. Now it's working :)\n<|/ c |>\n\
    <| a dscore=0 tags=c#,algorithm |>\nMy first attempt would be to use a stack to\
    \ store the notes that you have already processed. You would pop them off and\
    \ perform your calculations on them.\nI quickly coded a quick example of this\
    \ in python:\n<code>\n#!/usr/bin/python", "{\n    // initialize result array\n\
    \    long[] results = new long[music_string.size()];\n    // for each music note\n\
    \    for (int i = 0; i < music_string.size(); ++i) {\n        // parse music note\
    \ from input string\n        string music_note = music_string[i];\n        //\
    \ parse note's length (i.e. what beats it lasts)\n        string note_length =\
    \ parse_length(music_note);\n        // if it was a musical note\n        if (note_length.length()\
    \ > 0) {\n            // parse note's length\n            string length = note_length;\n\
    \            // parse note's duration (i.e. how long it lasts)\n            string\
    \ duration = parse_duration(length);\n            // check if note's duration\
    \ is equal to 0\n            if (duration.length() == 0) {\n                //\
    \ if it was a whole note\n                if (duration.length() == 1) {\n    \
    \                // add note length to note's duration\n                    string\
    \ dur = duration + note_length;\n                    // remove last character\
    \ from note's duration\n                    dur = dur.substring(0, dur.length()\
    \ - 1);\n                    // convert to integer\n                    int noteLength\
    \ = Convert.toInt(dur);\n                    // add note length to result\n  \
    \                  results[i] = noteLength;\n                    // if it was\
    \ a half note\n                } else {\n                    // add note length\
    \ to note's duration\n                    string dur = duration + note_length;\n\
    \                    // remove last character from note's duration\n         \
    \           dur = dur.substring(0, dur.length() - 1);\n                    //\
    \ convert to integer\n                    int noteLength = Convert.toInt(dur);\n\
    \                    // add half note length to result\n                    results[i]\
    \ = noteLength / 2;\n                    // if it was a quarter note\n       \
    \         }\n            } else {\n                // if it was a whole note\n\
    \                if (duration.length() == 1) {\n                    // add note\
    \ length to note's duration\n                    string dur = duration + note_length;\n\
    \                    // remove last character from note's duration\n         \
    \           dur = dur.substring(0, dur.length() - 1);\n                    //\
    \ convert to integer\n                    int noteLength = Convert.toInt(dur);\n\
    \                    // add note length to result\n                    results[i]\
    \ = noteLength;\n                    // if it was a half note\n              \
    \  } else {\n                    // add note length to note's duration\n     \
    \               string dur = duration + note_length;\n                    // remove\
    \ last character from note's duration\n                    dur = dur.substring(0,\
    \ dur.length() - 1);\n                    // convert to integer\n            \
    \        int noteLength = Convert.toInt(dur);\n                    // add note\
    \ length to result\n                    results[i] = noteLength;\n           \
    \         // if it was a quarter note\n                }\n            }\n    \
    \    }\n    }\n    return results;\n}", "{\n    \n    long result[] = new long[128];\n\
    \    int index = 0;\n    \n    foreach(char c in music_string) {\n        switch(c)\
    \ {\n            case \"o\": result[index++] = 8; break;\n            case \"\
    |\": result[index++] = 4; break;\n            case \".\": result[index++] = 2;\
    \ break;\n            default: throw new Exception(\"Unknown music note: \" +\
    \ c);\n        }\n    }", "{\n    int note_count = 0;\n    int beats_for[] = new\
    \ int[128];\n    int[] note_positions = new int[128];\n    for(int i=0; i<128;\
    \ i++)\n    {\n        note_count = 0;\n        beats_for[i] = 0;\n        note_positions[i]\
    \ = 0;\n    }\n    int num_notes = music_string.Length;\n    for(int i=0; i<num_notes;\
    \ i++)\n    {\n        if(music_string[i] == '.')\n        {\n            beats_for[music_string[num_notes-i-1]-1]++;\n\
    \        }\n        else if(music_string[i] == '|')\n        {\n            beats_for[music_string[num_notes-i-1]-1]++;\n\
    \            beats_for[music_string[num_notes-i+1]-1]++;\n        }\n        else\n\
    \        {\n            note_count++;\n            beats_for[music_string[i] -\
    \ 'o']++;\n        }\n    }", "{\n    long note_counter = 0;\n    string note_symbol\
    \ = music_string[0];\n    int last_beat = 0;\n    \n    for(int i = 1; i < music_string.length();\
    \ i++)\n    {\n        char c = music_string[i];\n        \n        if(c != note_symbol)\n\
    \        {\n            note_counter = note_counter + last_beat;\n           \
    \ last_beat = 0;\n            note_symbol = c;\n        }\n        else\n    \
    \    {\n            int beats = (int) std.random(4);\n            note_counter\
    \ = note_counter + beats;\n            last_beat = beats;\n        }\n    }\n\
    \    \n    note_counter = note_counter + last_beat;\n    \n    long[] note_array\
    \ = new long[note_counter];\n    \n    note_symbol = music_string[0];\n    for(int\
    \ i = 1; i < music_string.length(); i++)\n    {\n        char c = music_string[i];\n\
    \        \n        if(c != note_symbol)\n        {\n            note_array[i-1]\
    \ = note_array[i-1] + note_array[i];\n            note_array[i] = 0;\n       \
    \ }\n        else\n        {\n            note_array[i] = note_array[i] + 1;\n\
    \        }\n        note_symbol = c;\n    }\n    \n    return note_array;\n}",
  "{\n    /*\n    Here is a diagram how function works :)", "{\n    var result = [];\n\
    \    foreach(char c in music_string)\n    {\n        switch(c)\n        {\n  \
    \          case 'o':\n                result.push(4);\n                break;\n\
    \            case 'o|':\n                result.push(2);\n                break;\n\
    \            case '.|':\n                result.push(1);\n                break;\n\
    \            default:\n                break;\n        }\n    }\n    return result;\n\
    }", "{\n    long length = 0;\n    long last_note_length = 0;\n    int[] beats\
    \ = new int[128];", "{\n    int[] note_count = {0,0,0,0,0,0,0,0};", "{\n    string\
    \ last_note;\n    int beats_last_note = 0;", "{\n    long result[] = new long[music_string.Length];\n\
    \    StringBuilder builder = new StringBuilder();\n    int index = 0;\n    bool\
    \ in_beat = false;\n    bool is_note = false;\n    bool is_chord = false;\n  \
    \  bool is_rest = false;\n    bool is_quarter_note = false;\n    bool is_whole_note\
    \ = false;\n    bool is_half_note = false;\n    bool is_quater_note = false;\n\
    \    long note = 0;\n    char symbol = ' ';", "{\n    string[] parts = music_string.Split(\"\
    \ \");\n    long[] notes = new long[parts.Length];\n    \n    for(int i = 0; i\
    \ < parts.Length; i++)\n    {\n        if(parts[i] == \"o\")\n        {\n    \
    \        notes[i] = 4;\n        }\n        else if(parts[i] == \"o|\")\n     \
    \   {\n            notes[i] = 2;\n        }\n        else if(parts[i] == \"o|\"\
    )\n        {\n            notes[i] = 1;\n        }\n        else\n        {\n\
    \            notes[i] = 4;\n        }\n    }\n    return notes;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nWhy not just `long[] notes = parts[2].Split('|')`?\n<|/ c |>\n\
    <| c |>\nYour code would have problems with notes not being specified as being\
    \ whole notes or half notes.\n<|/ c |>\n<| c |>\nThe question clearly states that\
    \ `o` and `o|` are treated as whole notes.  If the note is not specified as being\
    \ a whole note, it's a half note.  My code treats it as being a whole note and\
    \ adds the number of beats to the result array.\n<|/ c |>\n<| c |>\nThe problem\
    \ is this: `if(parts[i] == \"o|\")` then `notes[i] = 2;`\n<|/ c |>\n<| c |>\n\
    Thank you for pointing that out.  I corrected it now.\n<|/ c |>\n<| a tags=c#,string\
    \ |>\nYou can use a regex to split up the string into chunks of the correct length,\
    \ and then use linq to group the notes by their lengths:\n<code>\nstring music\
    \ = \"o| o| o| .| o| o| .| .| o| .| .| .| .| .| .| .| .| .| o| o| o| .| o| o|\
    \ .| o| o| o| o| .| o| o| o| o| .| .| o| o| o| o| .| o| o| o| o| o| o| o| .| .|\
    \ o| o| o| o| .| o| o| o| o| o| o| o| .| o| o| o| o| .| .| .| o| o| o| o| .| o|\
    \ o| o| o| o| .| o| o| o| o| o| o| o| .| .| o| o| o| o| .| o| ", "{\n  int notes_in_chord\
    \ = 0;\n  int beat_num = 0;\n  long[] notes = new long[100];\n  \n  while(true)\
    \ {\n    int pos = 0;\n    bool is_note_here = false;\n    \n    int c = music_string[pos];\n\
    \    \n    switch(c) {\n      case 'o':\n      case 'O':\n        is_note_here\
    \ = true;\n        pos++;\n        break;\n      case '|':\n      case '.':\n\
    \        is_note_here = true;\n        pos++;\n        break;\n      default:\n\
    \        pos++;\n        break;\n    }\n    \n    while(pos < music_string.size())\
    \ {\n      if(is_note_here) {\n        c = music_string[pos];\n        if(c !=\
    \ '|' && c != '.')\n          pos++;\n        else {\n          if(pos == music_string.size()\
    \ - 1) {\n            notes[notes_in_chord] = beat_num;\n            notes_in_chord++;\n\
    \            beat_num = 0;\n            is_note_here = false;\n          } else\
    \ {\n            c = music_string[pos + 1];\n            if(is_octave(c))\n  \
    \            pos += 2;\n            else {\n              beat_num++;\n      \
    \        pos = 0;\n              is_note_here = false;\n            }\n      \
    \    }\n        }\n      } else {\n        c = music_string[pos];\n        switch(c)\
    \ {\n          case ',':\n          case '#':\n            pos++;\n          \
    \  break;\n          case '/':\n          case '*':\n          case 'b':\n   \
    \       case 'B':\n          case '#':\n          case 'b':\n          case 'B':\n\
    \          case 'b':\n          case 'B':\n          case '#':\n          case\
    \ 'b':\n          case '#':\n            pos++;\n            while(pos < music_string.size()\
    \ && music_string[pos] == ',')\n              pos++;\n            break;\n   \
    \       case '+':\n          case '-':\n          case '*':\n            pos++;\n\
    \            break;\n          default:\n            pos++;\n            break;\n\
    \        }\n      }\n    }\n    if(notes_in_chord)\n      notes[notes_in_chord]\
    \ = beat_num;\n    \n    return notes;\n  }\n}\n</code>\n<|/ a dscore=1 tags=java,string,parsing\
    \ |>\n<| c |>\nHi Michael, Thank you so much! This works perfectly and I really\
    \ appreciate your explanations. One question, what if my string had more 'o' between\
    \ note and the next note? I tried putting an if statement in the while loop to\
    \ check whether a note was there before checking the next one, but that doesn't\
    \ work. Do you know how ", "{\n    // TODO: Implement!\n    \n}", "{\n    char\
    \ notes[32];\n    long last_notes[32];\n    long beats[32];", "{\n    long[] result\
    \ = new long[4];\n    int i = 0;\n    while (i < music_string.size()) {\n    \
    \    char c = music_string[i];\n        int note = std.string.toInt(c);\n    \
    \    if (c == '|') {\n            result[i] += 1;\n        } else {\n        \
    \    result[i] = note;\n            i += note;\n        }\n    }\n    \n    return\
    \ result;\n}\n/*\n Input to this function is a string representing musical notes\
    \ in a special ASCII format.\n    Your task is to parse this string and return\
    \ an array of integers corresponding to how many beats does each\n    note lasts.",
  "{\n    int n = 0;\n    int offset = 0;\n    bool first = true;\n    long output[4];",
  "{\n    if (music_string.length()<=1)\n    {\n        int n = 1;\n        long beats[]\
    \ = new long[music_string.length()];\n        beats[0] = n;\n        for (int\
    \ i = 1; i < music_string.length(); i++) {\n            if (music_string[i] ==\
    \ '|') {\n                n++;\n                beats[i] = n;\n            }\n\
    \        }\n        return beats;\n    }", "{\n    music_string = music_string.trim();\n\
    \    if(music_string.length() < 1)\n        return newLongArray(0, 0);", "{\n\
    \    // your code goes here\n    Music music;\n    music = new Music(music_string);",
  "{\n    string first_char;\n    long first_beat, last_beat, beat_number;\n    int\
    \ number_of_notes;\n    string next_note;\n    long[] notes_numbers = new long[(int)music_string.size()];\n\
    \    for(int i = 0; i < music_string.size(); i++)\n    {\n        first_char =\
    \ music_string[i];\n        if(first_char == \"o\")\n        {\n            notes_numbers[i]\
    \ = 4;\n            first_beat = 0;\n            last_beat = 4;\n        }\n \
    \       else if(first_char == \"o|\")\n        {\n            notes_numbers[i]\
    \ = 2;\n            first_beat = 0;\n            last_beat = 2;\n        }\n \
    \       else if(first_char == \".|\")\n        {\n            notes_numbers[i]\
    \ = 1;\n            first_beat = 0;\n            last_beat = 1;\n        }\n \
    \       else\n        {\n            beat_number = std.math.div(i+1, (int)music_string.size())\
    \ / 4;\n            if((int)music_string.size() - ((int)music_string.size() +\
    \ i) < 4)\n            {\n                beat_number += 1;\n            }\n \
    \           if((int)music_string.size() - ((int)music_string.size() + i) < 0)\n\
    \            {\n                beat_number += 2;\n            }\n           \
    \ notes_numbers[i] = beat_number;\n            first_beat = last_beat;\n     \
    \       last_beat = (beat_number + 4);\n        }\n    }\n    number_of_notes\
    \ = (int)music_string.size();\n    next_note = music_string[number_of_notes];\n\
    \    while(next_note == \"o|\" || next_note == \".|\")\n    {\n        number_of_notes--;\n\
    \        next_note = music_string[number_of_notes];\n    }\n    next_note = music_string[number_of_notes];\n\
    \    while(next_note == \"o\" || next_note == \".\")\n    {\n        number_of_notes--;\n\
    \        next_note = music_string[number_of_notes];\n    }\n    notes_numbers[number_of_notes]\
    \ += beat_number-1;\n    return notes_numbers;\n}\n</code>\n<|/ a tags=c#,.net,parsing,string\
    \ |>\n<| c |>\nI agree, your approach is much better. Thanks !\n<|/ c |>\n<| a\
    \ tags=c#,.net,parsing,string dscore=0 |>\nYour code has lots of redundant checks.\
    \ You can remove these lines by using if conditions.\n<code>\nif (first_char ==\
    \ \"o\")\n{\n    notes_numbers[i] = 4;\n    first_beat = 0;\n    last_beat = 4;\n\
    }\nelse if (first_char == \"o|\")\n{\n    notes_numbers[i] = 2;\n    first_",
  "{\n    long beats_array[] = new long[100];\n    int notes_index = 0;\n    \n  \
    \  // \"o\" - whole note, lasts four beats\n    // \"o|\" - half note, lasts two\
    \ beats\n    // \".|\" - quater note, lasts one beat\n    \n    string note_marker;\n\
    \    \n    // parse notes\n    for (int i = 0; i <= music.length; i++) \n    {\n\
    \        note_marker = music.Substring(i * 2, 2);\n        if (note_marker[0]\
    \ == 'o' || note_marker[0] == 'o|') \n        {\n            beats_array[notes_index++]\
    \ = 4;\n        }\n        else if (note_marker[0] == '.') \n        {\n     \
    \       beats_array[notes_index++] = 1;\n        }\n    }\n    \n    return beats_array;\n\
    }\n</code>\n<|/ a dscore=1 tags=c#,arrays,loops,parsing,string |>\n<| c |>\nIt\
    \ was my first time using StackOverflow, so I apologize for my terrible formatting.\
    \  I did this by using the Code Sample feature to post my code.  The \"c\" tag\
    \ is the one I used.\n<|/ c |>\n<| a tags=c#,arrays,loops,parsing,string |>\n\
    You can use LINQ\n<code>\nstring[] strArr = {\"o o| .| o| o| .| .| .| .| .| o\
    \ o\" };\nvar noteArr = strArr\n  .Select(x => new {\n    marker = x.Substring(0,\
    \ 2),\n    beats = x.Substring(2).TrimStart(new[] { '|', '.' })\n            \
    \     .Split()\n                 .Select(x => x.Length == 1 ? x : x.LastOrDefault())\n\
    \                 .ToArray(),\n  })\n  .Where(x => x.marker.Equals(\"o\") || x.marker.Equals(\"\
    o|\"))\n  .Select(x => new { marker = x.marker, beats = x.beats })\n  .ToArray();\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI was typing something similar :). Still\
    \ I think that LINQ will make it more readable than this \"manual\" approach\n\
    <|/ c |>\n<| a |>\nA slight variation of Dmitry Bychenko's answer, using a single\
    \ linq query.\n<code>\nstring[] strArr = new string[] { \"o o| .| o| o| .| .|\
    \ .| .| .| o o\" };", "{\n    int notes_count = music_string.length();\n    int\
    \ beats_count = 1;\n    int notes_sum = 0;\n    int index = 0;", "{\n    long[]\
    \ result = new long[music_string.Length];\n    for(int i = 0; i < music_string.Length;\
    \ ++i)\n    {\n        char c = music_string[i];\n        if(c == 'o')\n     \
    \   {\n            result[i] = 4;\n        }\n        else if(c == 'o|')\n   \
    \     {\n            result[i] = 2;\n        }\n        else if(c == '.|')\n \
    \       {\n            result[i] = 1;\n        }\n        else\n        {\n  \
    \          throw new Exception(\"Invalid music note: \"+c);\n        }\n    }\n\
    \    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nNice! I just tested it out\
    \ and it worked flawlessly!\n<|/ c |>\n<| c |>\nOkay, i will give it a try!\n\
    <|/ c |>\n<| c |>\nIt is not correct - in case of multiple notes in one string\
    \ `parse_music(\"o o| .| o| o| .| .| .| .| o o\")` will return `[1,1,1,4,4,1,1,1,1]`\n\
    <|/ c |>\n<| c |>\n: No, my code is correct: it returns `[1, 1, 1, 2, 1, 2, 1,\
    \ 1, 1]`, which are the desired results in the original post. How do you know\
    \ my code is wrong?\n<|/ c |>\n<| c |>\n\"parse_music(\"o o| .| o| o| .| .| .|\
    \ .| o o\")\" returns [1,1,1,4,4,1,1,1,1] (tested in VS 2015), but your function\
    \ returns [4,2,1,1,2,4,1,4,4]. I think that is wrong\n<|/ c |>\n<| a tags=c#,.net,parsing,algorithm,string\
    \ |>\nYou might want to look at the Fretboarding algorithm here: http://en.wikipedia.org/wiki/Fretboarding_algorithm\n\
    I tested it against your example string and it produces the expected result.\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks, i will check this out!\n<|/ c |>\n<| a tags=c#,.net,parsing,algorithm,string\
    \ |>\nThe problem is with the way the algorithm works. When looking at the pattern,\
    \ it first finds all the possible valid notes. For example, it finds oo o o o\
    \ o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o\
    \ o o o o o o o o o o o o o o o o o o o o o o o o o o ", "{\n    int n_beats[]\
    \ = new int[128];\n    int note[] = new int[128];", "{\n    /*\n        Implement\
    \ your parsing algorithm here!\n        Do not forget to return long array as\
    \ a result!\n    */\n    long[] ret = new long[music_string.Length];", "{\n  \
    \  var notes = new List<int>();\n    var notes_array = music_string.Split('|');\n\
    \    foreach (string note_str in notes_array)\n    {\n        // Get the note\
    \ (first char)\n        var note = note_str[0];\n        if (note == 'o')\n  \
    \      {\n            notes.Add(4);\n        }\n        else if (note == '.')\n\
    \        {\n            notes.Add(1);\n        }\n        else\n        {\n  \
    \          // Get the length (second char)\n            var note_length = note_str[1];\n\
    \            var last_beat = notes[notes.Count-1];\n            var beat_count\
    \ = int(note_length) - last_beat;\n            notes.Add(beat_count);\n      \
    \  }\n    }\n    return notes.ToArray();\n}\n</code>\n<|/ a tags=c#,parsing,math,.net\
    \ dscore=2 |>\n<| a dscore=2 tags=c#,parsing,math,.net |>\nTry this:\n<code>\n\
    \    using System;\n    using System.Collections.Generic;", "{\n    var beats_per_note\
    \ = 4;\n    long beats_total = 0;\n    var notes = music_string.split(\" \");\n\
    \    for (int i = 0; i < notes.length; i += 2)\n    {\n        var note = notes[i];\n\
    \        var count = notes[i+1];\n        if (count == \"o\")\n        {\n   \
    \         beats_total += beats_per_note;\n        }\n        else if (count ==\
    \ \"o|\")\n        {\n            beats_total += beats_per_note*2;\n        }\n\
    \        else if (count == \".|\")\n        {\n            beats_total += beats_per_note;\n\
    \        }\n        else\n        {\n            throw new Exception(\"Unknown\
    \ note type: \" + count);\n        }\n    }\n    return new long[beats_total];\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI see what you did here but I don't want\
    \ to change the input to a string. I just want to input the notes in C and then\
    \ output the times the note should occur.\n<|/ c |>\n<| c |>\nYou could use `char`\
    \ instead of `string`, but then you'd have to cast every letter to `char`; this\
    \ way, you can use `char` arithmetic without having to convert from string to\
    \ char.\n<|/ c |>\n<| c |>\nHow do i output a specific note with note = char variable\
    \ ?\n<|/ c |>\n<| c |>\nIf you have a `char` variable `note`, then you can output\
    \ the note by writing `System.Console.WriteLine(\"The note is {0}\", note);`.\
    \ If you want to output multiple notes, you'll have to write out `System.Console.WriteLine(\"\
    The notes are: {0}\", notes);`, where `notes` is an array of `char` variables.\n\
    <|/ c |>\n<| c |>\nI am so sorry, I forgot to mention one important detail: this\
    \ program should work on any computer with any keyboard and any type of input.\
    \ I cannot use anything specific to C#, Java, C, C++, Python, etc.\n<|/ c |>\n\
    <| a |>\nHere are some hints:\n<code>\npublic class Note\n{\n    public int Note\
    \ { get; private set; }\n    public int Beats { get; private set; }", "{\n   \
    \ long[] result = new long[128];\n    int note_count = 0;", "{\n    var notes\
    \ = music_string.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n \
    \   var beats = new long[notes.Length];\n    \n    for (int i = 0; i < notes.Length;\
    \ i++)\n    {\n        var beat_length = notes[i].Length;\n        if (beat_length\
    \ == 1) notes[i] = notes[i].ToUpper();\n        var beat_number = notes[i][0]\
    \ -64;\n        notes[i] = notes[i].Substring(1);\n        beats[i] = beat_length\
    \ * beat_number;\n    }\n    return beats;\n}", "{\n    long[] beats_array = new\
    \ long[16];\n    string[] tokens = music_string.Split('|');\n    for(int i = 0;\
    \ i<beats_array.Length; i++)\n    {\n        if(tokens[i] == \"o\")\n        \
    \    beats_array[i] = 4;\n        else if(tokens[i] == \"o|\")\n            beats_array[i]\
    \ = 2;\n        else if(tokens[i] == \".|\")\n            beats_array[i] = 1;\n\
    \        else\n            beats_array[i] = 0;\n    }\n    return beats_array;\n\
    }\n</code>\n<|/ a tags=algorithm,c# |>\n<| c |>\nHow would that even work? What\
    \ would the length of `beats_array` be if you just initialized it?\n<|/ c |>\n\
    <| c |>\nYeah you're right. I just changed it so you can initialize it to a non-0\
    \ value (which I thought would do the trick). I can change it back if you want\n\
    <|/ c |>\n<| c |>\nOk I changed it\n<|/ c |>\n<| a tags=algorithm,c# |>\nHere's\
    \ another approach using Linq:\n<code>\nstring notes = \"o o| .| o| o| .| .| .|\
    \ .| o o\";\nvar noteArray = notes.Split(new[] {' '}, StringSplitOptions.RemoveEmptyEntries)\n\
    \    .Select(s => s.Length > 0 ? s.ToCharArray().Select(c => (int)c).Sum() : 0L)\n\
    \    .ToArray();\n</code>\nNote: This is C# 3 code.\n<|/ a dscore=1 |>\n<| c |>\n\
    It will be very difficult to maintain this with large notes, since you have to\
    \ account for the length of notes array and number of notes.  If you have more\
    \ than 4 notes, your solution will fail.  Also a minor thing, but I'd use '0'\
    \ as 0, and '1' as 1 instead of using 'o' for the note.\n<|/ c |>\n<| c |>\n:\
    \ I agree with your assessment. I realized that and changed my answer to use `0`\
    \ and `1`. However, I am still curious about the efficiency of the solution. Is\
    \ that a concern?\n<|/ c |>\n<| c |>\nYes, this will be a bottleneck.  I wrote\
    \ a LINQ C# 3 solution with 3 passes over notes and it took over 20 seconds. \
    \ A similar LINQ solution using 1 pass took 3 seconds.  So I guess the original\
    \ question was really asking for a solution that could process N notes in less\
    \ than 20 seconds.\n<|/", "{\n    int[] results = new int[music_string.size()];\n\
    \    int counter = 0;", "{\n    long total = 0;\n    for(char note : music_string)\n\
    \    {\n        if(note[0] == 'o')\n        {\n            total += 4;\n     \
    \   }\n        else if(note[0] == 'o|')\n        {\n            total += 2;\n\
    \        }\n        else if(note[0] == '.|')\n        {\n            total +=\
    \ 1;\n        }\n    }\n    long[] result = new long[total];\n    for(int i =\
    \ 0; i < total; ++i)\n    {\n        result[i] = (long)i;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=algorithm,c#,arrays,math |>\n<| c |>\nWow, that looks very\
    \ good. Although my final solution is similar, I'm thinking about implementing\
    \ your suggestion. Many thanks.\n<|/ c |>\n<| c |>\nMy solution should also work\
    \ if I remember it wrong. But yeah, your approach is probably better. :)\n<|/\
    \ c |>\n<| c |>\nIt doesnt work for me with string \"o o| .| o| o| .| .| .| .|\
    \ o o\", it returns only 4 beat instead of 6 :/ maybe because of string length\
    \ limitation? Anyway thanks :)\n<|/ c |>\n<| c |>\nThis code only works if the\
    \ string has only one 'o'. If it has two 'o's, it returns only 4 beat instead\
    \ of 6.\n<|/ c |>\n<| c |>\nIt works fine for me, with those two input strings.\
    \ And if you're getting four beats, you're either running it wrong or the string\
    \ has multiple 'o'.\n<|/ c |>\n<| a dscore=2 tags=algorithm,c#,arrays,math |>\n\
    <code>\n public static int[] GetBeats(string notes)\n {\n     int[] ret = new\
    \ int[notes.Length];\n     int i = 0;\n     int currentBeat = 0;\n     char note\
    \ = notes[i];\n     while (note != '|')\n     {\n         if (note == 'o')\n \
    \        {\n             ret[currentBeat] += 4;\n             currentBeat = 0;\n\
    \         }\n         else if (note == '|')\n         {\n             ret[currentBeat]\
    \ += 1;\n             currentBeat++;\n         }\n         i++;\n         note\
    \ = notes[i];\n     }\n     return ret;\n }\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nHere is my solution:\n<code>\npublic int[] GetBeats(string notes)\n    {\n\
    \        string[] note", "{\n    //split string into notes\n    string[] notes\
    \ = music_string.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);",
  "{\n    int beats_per_note = 440;\n    beats_per_note = beats_per_note - 10;", "{\n\
    \    int n = music_string.Length;\n    int[] beats = new int[n];", "{\n    long[]\
    \ nums = new long[notes.length];\n    int[] notes_index = new int[notes.length];",
  "{\n    long sum = 0;\n    string[] notes = music_string.split(\" \");\n    for(int\
    \ i = 0; i < notes.length; i++)\n    {\n        string current_note = notes[i];\n\
    \        switch (current_note)\n        {\n            case \"o\":\n         \
    \   case \"o|\":\n            case \".|\":\n                sum += 4;\n      \
    \          break;\n            default:\n                long n = notes[i].length();\n\
    \                if (current_note[0] == '|')\n                    sum += n * (n\
    \ - 1);\n                else\n                    sum += n * (n + 1);\n     \
    \   }\n    }\n    long[] res = new long[sum];\n    sum = 0;\n    for(int i = 0;\
    \ i < notes.length; i++)\n    {\n        string current_note = notes[i];\n   \
    \     switch (current_note)\n        {\n            case \"o\":\n            case\
    \ \"o|\":\n            case \".|\":\n                res[sum++] = 4;\n       \
    \         break;\n            default:\n                long n = notes[i].length();\n\
    \                if (current_note[0] == '|')\n                    res[sum++] =\
    \ n * (n - 1);\n                else\n                    res[sum++] = n * (n\
    \ + 1);\n        }\n    }\n    return res;\n}\n</code>\n<|/ a tags=string,java,algorithm,arrays\
    \ |>\n<| c |>\nThank you, looks promising. I tried it, and it looks good at first,\
    \ but the sum of the array is always 0, even though there are other notes. I tried\
    \ printing all the notes in the array and it seems to work fine. I'm going to\
    \ investigate more and try to figure out the issue\n<|/ c |>\n<| a dscore=0 |>\n\
    It seems the issue was that I was using \"||\" and \"|\" as strings to represent\
    \ musical notes. Replacing them with their actual values worked. I'm not sure\
    \ why this would happen, but it works now. Thanks for the help\n<|/ a tags=string,java,algorithm,arrays\
    \ |>\n<| c |>\nIf you have to use those symbols to represent notes, you would\
    \ have to escape them, e.g. `\\|` instead of `|`.\n<|/ c |>\n<| c |>\nThat would\
    \ be true, but I believe that the program was already using those.\n<|/ c |>\n\
    <| a dscore=0 |>\nYou could try this\n<code>\npublic static void main(String[]\
    \ args) {\n    String s = \"o o| .| o| o| .| .| .| .| o o\";\n    char[] notes\
    \ = s.toCharArray();\n    long[] noteLength = findNoteLength(notes);\n    for\
    \ (int i = 0; i < noteLength.length; i++) {\n        if (i == noteLength.length\
    \ - 1)\n            System.out.println(i);\n    }\n}", "{\n    long total = 0;\n\
    \    int max_beat = 1;\n    int i = 0;\n    int j = 0;\n    while (i < music_string.size())\
    \ {\n        string note_val = music_string.substr(i, 2);\n        string beat\
    \ = \"\";\n        if (i < music_string.size() - 1 && music_string[i+1] == '|')\
    \ {\n            i += 2;\n        }\n        for (size_t i = 0; i < note_val.size();\
    \ i++) {\n            beat += note_val[i];\n        }\n        if (beat == \"\
    o\") {\n            total += 4;\n        } else if (beat == \"o|\") {\n      \
    \      total += 2;\n        } else if (beat == \".|\") {\n            total +=\
    \ 1;\n        } else {\n            cout << \"Music string did not match any known\
    \ note. Music string: \" << music_string << \"\\n\";\n            cout << \"Current\
    \ note: \" << beat << \"\\n\";\n            break;\n        }\n        if (total\
    \ > max_beat) {\n            max_beat = total;\n        }\n        i += 2;\n \
    \   }\n    long[] beats = new long[max_beat + 1];\n    for (int b = 0; b < beats.length;\
    \ b++) {\n        beats[b] = b;\n    }\n    return beats;\n}", "{\n    string\
    \ separator = \"o|.|\";\n    char notes[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;", "{\n    int beats_counter = 0;\n    char[] music_char = music_string.ToCharArray();\n\
    \    for (int i = 0; i < music_char.Length; i++)\n    {\n        char cur_char\
    \ = music_char[i];\n        if (cur_char == 'o' || cur_char == '|' || cur_char\
    \ == '.') \n        {\n            beats_counter++;\n        }\n    }\n    long[]\
    \ beats_result = new long[music_string.Length];\n    for (int i = 0; i < music_string.Length;\
    \ i++)\n    {\n        if (music_char[i] == 'o' || music_char[i] == '|' || music_char[i]\
    \ == '.') \n        {\n            beats_result[i] = beats_counter;\n        }\n\
    \        else\n        {\n            beats_result[i] = beats_counter;\n     \
    \       beats_counter = 0;\n        }\n    }\n    return beats_result;\n}\n</code>\n\
    <|/ a dscore=0 tags=c#,algorithm,arrays,string |>\n<| a dscore=0 |>\nHere is the\
    \ solution for string with variable number of dots:\n<code>\npublic static int[]\
    \ parseMusic(string music)\n{\n    if (string.IsNullOrEmpty(music))\n    {\n \
    \       return null;\n    }\n    List<int> beats = new List<int>();\n    string[]\
    \ dots = music.Split('.');\n    for (int i = 0; i < dots.Length; i++)\n    {\n\
    \        string s = dots[i];\n        bool first = true;\n        int total =\
    \ 0;\n        int count = 0;\n        for (int j = 0; j < s.Length; j++)\n   \
    \     {\n            if (j == s.Length - 1 || s[j] == '.')\n            {\n  \
    \              if (first)\n                {\n                    total += count++;\n\
    \                    first = false;\n                }\n                else\n\
    \                {\n                    total += count;\n                    count\
    \ = 0;\n                }\n            }\n            else\n            {\n  \
    \              char c = s[j];\n                total += (int)Char.GetNumericValue(c);\n\
    \            }\n        }\n        beats.Add(total);\n    }\n    return beats.ToArray();\n\
    }\n</code>\nAnd here is the solution for string with fixed number of dots:\n<code>\n\
    public static int[] parseMusic2(string music)\n{\n    if (string.IsNullOrEmpty(music))\n\
    \    {\n        return null;\n    }\n    List<int> beats = new List<int>();\n\
    \    for (int i = 0; i < music.Length; i++)\n    {\n        string s = music.Substring(0,\
    \ i);\n        bool first = true;\n        int total = 0;\n        int count =\
    \ 0;\n        for (int j = 0; j < s.Length; j++)\n        {\n            if (j\
    \ == s.Length - 1 || s[j] == '.')\n            {\n                if (first)\n\
    \                {\n                    total += count++;\n                  \
    \  first = false;\n                }\n                else\n                {\n",
  "{\n    var result = [0, 0, 0, 0, 0, 0, 0, 0];\n    var index = 0;\n    var last_note\
    \ = null;", "{\n    // Your code here\n    long[] beats = new long[music_string.Length];\n\
    \    char note;\n    for(int i = 0; i < music_string.Length; i++)\n    {\n   \
    \     if (music_string[i] == 'o')\n            beats[i] = 4;\n        else if\
    \ (music_string[i] == 'o|')\n            beats[i] = 2;\n        else if (music_string[i]\
    \ == '.|')\n            beats[i] = 1;\n        else\n        {\n            note\
    \ = music_string[i];\n            beats[i] = int.Parse(note);\n        }\n   \
    \ }\n    return beats;\n}\n</code>\nIt will work for the given example too:\n\
    <code>\nlong[] test = new long[] { 4, 2, 1, 2, 2, 2, 1, 1, 4, 4 };\nlong sum =\
    \ test.Sum();\n</code>\n<|/ a |>\n<| a tags=c# |>\nThe answer provided by Roger\
    \ Patel is very good.\nThe thing that I can not find is why do you need that long\
    \ array.\nThe code can be written without that array and in that case the code\
    \ will be much clearer.\nThe code will be much simpler.\n<code>\nstatic long getBeatCount(string\
    \ notes)\n{\n    long beats = 0;\n    for (int i = 0; i < notes.Length; i++)\n\
    \    {\n        if (notes[i] == 'o')\n            beats += 4;\n        else if\
    \ (notes[i] == 'o|')\n            beats += 2;\n        else if (notes[i] == '.|')\n\
    \            beats += 1;\n    }\n    return beats;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThe point of the exercise is to learn the technique of parsing\
    \ strings to calculate sequences.\n<|/ c |>\n<| c |>\nSure, but that makes your\
    \ solution more complicated then it should be.\n<|/ c |>\n<| c |>\nYes it does,\
    \ but that does not change the fact that your solution is wrong, right?\n<|/ c\
    \ |>\n<| c |>\nYes, that is true. I missed that part of your answer when I answered.\
    \ I was thinking about your solution when I wrote my answer.\n<|/ c |>\n<| a |>\n\
    <code>\npublic class Note\n{\n    public const string Octave = \"C:\";\n    public\
    \ const string Half = \"C:|\";\n    public const string Quarter = \"C:||\";\n\
    \    public const string Eighth = \"C:|||\";\n    public const string Ninth =\
    \ \"C:||||\";\n    public const string Tenth = \"C:|||||\";\n    public const\
    \ string Fifth = \"C:||||||\";", "{\n    var res = new long[64];\n    var idx\
    \ = 0;\n    while (idx < music_string.length()) {\n        var note_length = music_string[idx]\
    \ == 'o' ? 4 : 2;\n        if (music_string[idx] == 'o') {\n            res[idx]\
    \ |= Midi.MIDI_CC_NOTEON_OFF;\n        }\n        else {\n            res[idx]\
    \ |= Midi.MIDI_CC_NOTEON;\n        }\n        idx += note_length;\n    }\n   \
    \ return res;\n}\n</code>\n<code>\nimport std.traits;\nimport std.convertors;\n\
    import std.conv;\nimport std.range;\nimport std.array;\nimport std.algorithm;",
  "{\n    string notes[] = {\"o\", \"o|\", \".|\"};", "{\n    long[] results = new\
    \ long[MUSIC_LENGTH];", "{\n    int[] beats = new int[12];\n    int note = 0;\n\
    \    int beat = 0;\n    string currentNote;\n    string nextNote;\n    \n    for\
    \ (int i = 0; i < music_string.length(); i++)\n    {\n        currentNote = music_string[i];\n\
    \        nextNote = music_string[i + 1];\n        beats[note] += beat;\n     \
    \   beat = 0;\n        \n        switch (currentNote)\n        {\n        case\
    \ 'o':\n            note = 0;\n            beat++;\n            break;\n     \
    \   case 'o|':\n            note = 1;\n            beat++;\n            break;\n\
    \        case '.|':\n            note = 2;\n            beat++;\n            break;\n\
    \        case 'o|':\n            note = 3;\n            beat++;\n            break;\n\
    \        default:\n            beats[note] += beat;\n            beat = 0;\n \
    \           note = 0;\n            break;\n        }\n    }\n    \n    return\
    \ beats;\n}\n</code>\n<|/ a tags=java,string |>\n<| c |>\nThank you, very much!\
    \ I didn't know about that library, it works perfectly and is very helpful to\
    \ me! :D\n<|/ c |>\n<| c |>\nHappy to help! And welcome to StackOverflow. Feel\
    \ free to accept the answer to indicate that the problem is solved :)\n<|/ c |>\n\
    <| c |>\nHey, I've had another idea for parsing musical notes. Would you please\
    \ take a look at it? :D ", "{\n    long[] notes= new long[128];\n    int[] accidentals\
    \ = {-1, -2, -3, -4};\n    int note;", "{\n  long[] result = new long[(int)music_string.length()];\n\
    \  int pos = 0;\n  while(pos < music_string.length()) {\n    string note = music_string.substr(pos,\
    \ 1);\n    pos += 1;\n    \n    string rest = music_string.substr(pos, 1);\n \
    \   pos += 1;\n    \n    if(note == \"o\") {\n      if(rest.length() == 0) {\n\
    \        result[pos - 1] = MusicalScale.note.notes.findIndex((note) => note.equals(note));\n\
    \      } else {\n        long beats = rest.length() / 4;\n        if(rest.length()\
    \ % 4 == 0) {\n          beats += 1;\n        }\n        result[pos - 1] = beats;\n\
    \      }\n    } else {\n      int rest1 = rest.length() / 2;\n      int rest2\
    \ = rest.length() - rest1;\n      int half = rest1 % 2;\n      if(half == 0) {\n\
    \        if(rest1 == 0) {\n          if(rest2 > 0) {\n            long beats =\
    \ rest2 / 2;\n            if(rest2 % 2 == 0) {\n              beats += 1;\n  \
    \          }\n            result[pos - 1] = beats;\n          } else {\n     \
    \       result[pos - 1] = 2;\n          }\n        } else {\n          long beats\
    \ = rest1 / 2;\n          if(rest1 % 2 == 0) {\n            beats += 1;\n    \
    \      }\n          result[pos - 1] = beats;\n        }\n      } else {\n    \
    \    long beats = rest1 * 2;\n        result[pos - 1] = beats;\n      }\n    }\n\
    \  }\n  return result;\n}", "{\n    long beats = 0;\n    bool first_part = true;\n\
    \    bool last_part = false;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
