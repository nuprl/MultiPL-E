name: HumanEval_147_get_max_triples
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a positive\
  \ integer n. You have to create an integer array a of length n.\n        For each\
  \ i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the\
  \ number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j]\
  \ + a[k] is a multiple of 3.\n\n    Example :\n    >>> get_max_triples(5L)\n   \
  \ 1L\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid\
  \ triple is (1, 7, 13).\n    \n*/\nlong get_max_triples(long n) \n"
tests: "unittest\n{\n    alias candidate = get_max_triples;\n\n    assert(candidate(5L)\
  \ == 1L);\n    assert(candidate(6L) == 4L);\n    assert(candidate(10L) == 36L);\n\
  \    assert(candidate(100L) == 53361L);\n}\nvoid main(){}"
completions: ["{\n    int[] a = new int[n];\n    for(long i = 1 ; i < n ; ++i)\n \
    \   {\n        a[i] = i * i - i + 1;\n    }\n    for(long i = 0 ; i < n ; ++i)\n\
    \    {\n        if(a[i] + a[j] + a[k] % 3 == 0)\n        {\n            return\
    \ 1;\n        }\n    }\n    return 0;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\n\
    Thank you for the answer, but unfortunately, I can't use any additional libraries.\
    \ Only those two I imported (std.string and std.typecons).\n<|/ c |>\n<| c |>\n\
    Thank you for the answer, but unfortunately, I can't use any additional libraries.\
    \ Only those two I imported (std.string and std.typecons).\n<|/ c |>\n<| c |>\n\
    Thanks for the help, but I figured it out. I will post the solution here.\n<|/\
    \ c |>\n<| a dscore=0 |>\nHere's my solution:\n<code>\nlong get_max_triples(long\
    \ n)\n{\n    int[] a = new int[n];\n    long max_so_far = 0;", "{\n    long sum\
    \ = 0, i = 1L, j = n-1L;\n    while( i <= j){\n        sum += i * (i - 1) + i\
    \ + 1;\n        i = i + 2L;\n        j = j - 1L;\n    }\n    return sum % 3L;\n\
    }", "{\n    long cnt = 0;\n    long a[n];\n    for(long i = 0; i < n; i++) {\n\
    \        a[i] = i * i - i + 1;\n    }\n    for(long i = 0; i < n; i++) {\n   \
    \     for(long j = i+1; j < n; j++) {\n            for(long k = j+1; k < n; k++)\
    \ {\n                if(a[i] < a[j] && a[i] < a[k]) {\n                    cnt++;\n\
    \                }\n            }\n        }\n    }\n    return cnt;\n}\n</code>\n\
    <|/ a dscore=2 tags=algorithm,c,java |>\n<| c |>\nYou forgot the condition for\
    \ `if (cnt >= 3)`, which is `return (cnt);`.\n<|/ c |>\n<| c |>\nyes, I forgot\
    \ it. But I think the solution is correct. I just added the condition without\
    \ looking at the code carefully. Thank you!\n<|/ c |>\n<| a tags=algorithm,c,java\
    \ |>\nHere's my solution in Java using a bit of math (that I'm very rusty on):\n\
    <code>\nlong getMaxTriples(long n) {\n    long tri = 0;\n    long mod = 3n;\n\
    \    while (n%3 == 0) {\n        mod += 3;\n    }\n    while (n%5 == 0) {\n  \
    \      mod += 5;\n    }\n    while (n%7 == 0) {\n        mod += 7;\n    }\n  \
    \  long a = ((long) (mod*Math.pow(1L, mod) + 2l)/mod);\n    long b = ((long) (mod*Math.pow(1L,\
    \ mod) + 2l)/mod);\n    long c = ((long) (mod*Math.pow(1L, mod) + 2l)/mod);\n\
    \    long d = ((long) (mod*Math.pow(1L, mod) + 2l)/mod);\n    while (b > c &&\
    \ c > d && d > a && b != 0 && c != 0 && d != 0 && a != 0) {\n        tri += 1;\n\
    \        mod += 3;\n        b = ((long) (mod*Math.pow(1L, mod) + 2l)/mod);\n \
    \       c = ((long) (mod*Math.pow(1L, mod) + 2l)/mod);\n        d = ((long) (mod*Math.pow(1L,\
    \ mod) + 2l)/mod);\n    }\n    return tri;\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nCan you explain how you got the result from `long` to `int`? I don't see\
    \ that in the `pow` function, or even the `long mod` variable.\n<|/ c |>\n<| c\
    \ |>\nI assumed that long's are 64bit values, so in ", "{\n    if(n==0)\n    \
    \    return 0;\n    int i=1,j=n-2,k=3;\n    long ans=0;\n    for(i;i<n;++i)\n\
    \    {\n        long tmp=i*i-3+i+1;\n        for(j;j<n;++j)\n        {\n     \
    \       long tmp2=j*j-3+j+1;\n            for(k;k<n;++k)\n            {\n    \
    \            long tmp3=k*k-3+k+1;\n                if(tmp+tmp2+tmp3==0)\n    \
    \                break;\n                ans=max(ans,tmp*tmp*tmp+tmp2*tmp2+tmp3*tmp3);\n\
    \            }\n        }\n    }\n    return ans;\n}\n</code>\n<|/ a |>\n<| a\
    \ |>\nI am not sure if this is the most optimal solution, but it is a good start.\n\
    <code>\n#include <iostream>\n#include <cmath>", "{\n    vector<int> a(n);\n  \
    \  long cnt = 0;\n    for (long i = 0; i < n; ++i)\n    {\n        a[i] = i *\
    \ i - i + 1;\n    }\n    for (long i = 0; i < n; ++i)\n    {\n        for (long\
    \ j = i + 1; j < n; ++j)\n        {\n            for (long k = j + 1; k < n; ++k)\n\
    \            {\n                if (a[i] > a[j] && a[i] > a[k] && a[j] > a[k])\n\
    \                {\n                    ++cnt;\n                }\n          \
    \  }\n        }\n    }\n    return cnt;\n}\n</code>\n<|/ a tags=algorithm dscore=1\
    \ |>\n<| a tags=algorithm |>\n<code>\ndef triples(n):\n    count = 0\n    for\
    \ i in range(0, n):\n        for j in range(i+1, n):\n            for k in range(j+1,\
    \ n):\n                if i==j and i==k:\n                    pass\n         \
    \       elif i*i+i+j == k*k+j+1:\n                    count += 1\n           \
    \     elif i*i+i+k == j*j+k+1:\n                    count += 1\n    return count",
  "{\n    if (n == 0) return 0;", "{\n    int i, j;\n    long sum = 0;\n    int *\
    \ a = (int *) malloc(sizeof(int) * n);\n    for(i = 0; i < n; i++)\n        a[i]\
    \ = i * i - i + 1;\n    for(i = 0; i < n; i++) {\n        for(j = 0; j<i; j++)\
    \ {\n            if(a[j] >= a[i])\n                break;\n        }\n       \
    \ if(j == i) {\n            sum += a[i];\n        }\n    }\n    free(a);\n   \
    \ return sum;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is incorrect. It returns `1`\
    \ instead of `3`.\n<|/ c |>\n<| c |>\nI tested it on ideone and it gives correct\
    \ result. Can you explain your point of view?\n<|/ c |>\n<| c |>\nIt returns 1\
    \ because the OP wants to count the triples (a[i], a[j], a[k]) of a where `i <\
    \ j < k`.\n<|/ c |>\n<| c |>\nI modified the code to return 3, as you said in\
    \ the answer. Thanks :)\n<|/ c |>\n<| c |>\nThe question states *for each i (1\
    \ \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.* Your answer does not\
    \ take this into account.\n<|/ c |>\n<| a tags=math,c,algorithm,c++ |>\nI guess\
    \ this should work for you: \n<code>", "{\n    long res = 0;\n    long a[n] =\
    \ {0};\n    for (long i = 0; i < n; i++) {\n        a[i] = (i * i - i + 1);\n\
    \    }\n    sort(a, a + n);\n    for (long i = 0; i < n; i++) {\n        for (long\
    \ j = i+1; j < n; j++) {\n            for (long k = j+1; k < n; k++) {\n     \
    \           if (a[i] + a[j] + a[k] == 0) {\n                    res++;\n     \
    \               break;\n                }\n            }\n        }\n    }\n \
    \   return res;\n}\n</code>\n<|/ a |>\n<| c |>\nThank you for your time. But as\
    \ i said in the question that i don't want a solution for this. I need a solution\
    \ which runs in linear time. \nMy program is working fine but giving wrong answers.\
    \ Can you please help me??\n<|/ c |>\n<| c |>\nThen sort the array and keep track\
    \ of the highest values seen so far. At each step you know that `a[i] + a[j] +\
    \ a[k] = 3*a[i] + a[j] + a[k]`.\n<|/ c |>\n<| c |>\nCan you please post an answer??\n\
    <|/ c |>\n<| c |>\nI added an answer. But I think you should study yours carefully\
    \ and see if you can figure it out.\n<|/ c |>\n<| c |>\nOh! I didn't know we had\
    \ to sort the array and store max value so far. I got it now. \nThank you so much!!\
    \ :)\n<|/ c |>\n<| a dscore=0 tags=data-structures,algorithm,c++ |>\nI got the\
    \ program to work. :)\n<code>\n    #include <bits/stdc++.h>\nusing namespace std;",
  "{\n    long i;\n    long a[n];\n    for (i = 0; i < n; i++) {\n        a[i] = i\
    \ * i - i + 1;\n    }\n    long max_triple = 0;\n    long max_idx = 0;\n    \n\
    \    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n      \
    \      long temp = a[i] + a[j] + a[k];\n            if (temp > max_triple) {\n\
    \                max_triple = temp;\n                max_idx = i;\n          \
    \      max_idx = j;\n                max_idx = k;\n            }\n        }\n\
    \    }\n    return max_triple;\n}\n</code>\n<|/ a tags=dynamic-programming,algorithm,c++,arrays\
    \ |>\n<| a tags=dynamic-programming,algorithm,c++,arrays |>\nYou can solve this\
    \ by building a dynamic programming approach. We will consider three cases:",
  "{\n    long ans = 0;\n    int i =0, j=0, k= 0;\n    while(i < n && j < n && k <\
    \ n)\n    {\n        ans = max(ans, std.math.get_triple(i, j, k));\n        i+=1;\n\
    \        j+=1;\n        k+=1;\n    }\n    return ans;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThis solution is not optimal, because it requires n * n * n operations.\n\
    <|/ c |>\n<| c |>\nIt looks like this would be O(n^3), since you're creating n\
    \ * n arrays and performing n * n comparisons.\n<|/ c |>\n<| c |>\n: yes, I'm\
    \ aware of that. But the question was about a solution with minimal memory consumption.\
    \ The best solution here is O(n * n), so I thought it is better to leave it like\
    \ that.\n<|/ c |>\n<| c |>\n: What do you mean by \"optimal memory\"?  It requires\
    \ O(n^2) memory, but your algorithm is O(n^3).\n<|/ c |>\n<| c |>\nI'm actually\
    \ not sure what he meant by \"optimal memory\". But the algorithm is O(n^3). Maybe\
    \ I misunderstand that requirement? But I agree with you that his code is not\
    \ optimal.\n<|/ c |>\n<| a dscore=4 |>\nA simple solution is as follows: You first\
    \ create an array \"a\" that contains the numbers from 1 to n, then you sort the\
    \ array. This gives you an array \"b\" where b[i] contains the number of triples\
    \ where a[i] < a[i+1] and a[i+1] < a[i+2]. Now you just have to count the triples\
    \ in \"b\" which all numbers are divisible by 3.\n<|/ a tags=arrays,algorithm\
    \ |>\n<| c |>\nThis won't work for the case where n is large, since the time complexity\
    \ of the sort is O(n*logn). While this is probably more efficient than the answer\
    \ from David, it also uses O(n^2) memory.\n<|/ c |>\n<| c |>\n: Yes, that is why\
    \ I stated \"This solution is simple\". Although the actual solution is more complicated,\
    \ this solution is easy to implement and probably less expensive than sorting.\n\
    <|/ c |>\n<| c |>\nAgreed, but unfortunately the question didn't state that the\
    \ array should be sorted in any particular order.\n<|/ c |>\n<| c |>\n: This would\
    \ be a good answer in that case, but unfortunately the question didn't state that\
    \ the array should be sorted in any particular order.\n<|/ c ", "{\n    long a[n]\
    \ = {0};\n    long i;\n    for(i = 0; i<n; ++i)\n    {\n        a[i] = i * i -\
    \ i + 1; // i * i - i + 1 is a multiple of 3\n    }\n    sort(a, a+n, less<long>());\
    \ // Sort the array\n    long count = 0;\n    for(i = 1; i<n; ++i)\n    {\n  \
    \      if(a[i] == a[i-1])\n        {\n            ++count;\n        }\n      \
    \  else\n        {\n            if(a[i] + 3 == a[i-1]) \n            {\n     \
    \           ++count;\n            }\n            else\n            {\n       \
    \         if(a[i] + 6 == a[i-1]) \n                {\n                    ++count;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis has terrible performance for the general case. The worst\
    \ case would be n^2 iterations. To improve it, sort by the value rather than the\
    \ index.\n<|/ c |>\n<| c |>\nIt doesn't have terrible performance in the general\
    \ case. It does have terrible performance in the general case because of the unnecessary\
    \ loop. As I mentioned in the comments of the original post, the solution of sorting\
    \ the array doesn't work. Sorting works by moving one item at a time, and I haven't\
    \ found a way to apply this algorithm to sort the array by value (without moving\
    \ one item at a time).\n<|/ c |>\n<| a dscore=1 |>\nJust for completeness, an\
    \ efficient algorithm would be to sort the array and check if the next number\
    \ in the sorted array is the sum of the current one and the previous one minus\
    \ two. If it is, we have a triple.\n<code>\n#include <iostream>\n#include <vector>\n\
    #include <algorithm>\nusing namespace std;", "{\n    long a[1<<3];\n    long cnt\
    \ = 0;\n    long i, j, k;\n    for(i = 1;i<(1<<n);i++)\n    {\n        for(j=i;j<(1<<n);j++)\n\
    \        {\n            if(i<j)\n            {\n                for(k = j;k<(1<<n);k++)\n\
    \                {\n                    if((1<<k)+(1<<j) == (1<<i) + 1)\n    \
    \                    a[k] = (a[k]+a[j]+a[i])&3;\n                }\n         \
    \   }\n            else\n            {\n                for(k = j;k<(1<<n);k++)\n\
    \                {\n                    if((1<<i)+(1<<j) == (1<<k) + 1)\n    \
    \                    a[k] = (a[k]+a[j]+a[i])&3;\n                }\n         \
    \   }\n            if(a[i]+a[j]+a[i] == a[j]) \n            {\n              \
    \  if(a[i] < a[j])\n                    cnt++;\n            }\n        }\n   \
    \ }\n    return cnt;\n}", "{\n    long long int a[n];\n    for(int i=0; i<n; i++){\n\
    \        a[i]=i*i%n+1;\n    }\n    \n    long long int sum=0,m=0;\n    \n    for(int\
    \ i=0; i<n-1; i++){\n        sum+=a[i];\n    }\n    for(int i=n-1; i>0; i--){\n\
    \        sum+=a[i];\n    }\n    m=3*sum;\n    \n    int count=0;\n    for(int\
    \ i=0; i<n; i++){\n        for(int j=0; j<n; j++){\n            for(int k=0; k<n;\
    \ k++){\n                if(i<j && i<k && j<k){\n                    long long\
    \ int sum1=0;\n                    for(int m=0; m<n; m++){\n                 \
    \       sum1+=a[m];\n                    }\n                    if(sum1>=m){\n\
    \                        count++;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a |>\n<code>", "{\n    int[] a = new int[n];\n    int cnt = 0;\n    for(int\
    \ i = 0; i < n; i++){\n        a[i] = i*i - i + 1;\n        for(int j = i+1; j\
    \ < n; j++){\n            for(int k = j+1; k < n; k++){\n                if(is_triple_multip(a[i],\
    \ a[j], a[k])){\n                    cnt += 1;\n                }\n          \
    \  }\n        }\n    }\n    return cnt;\n}", "{\n    // write your code in Java\
    \ here\n    std.typecons.int[] a = new std.typecons.int[n];\n    for(int i = 0;\
    \ i < n; i++)\n    {\n        a[i] = i * i - i + 1;\n    }\n    std.math.triplet.Triplet<long>\
    \ tt = new std.math.triplet.Triplet<long>();\n    std.math.triplet.Triplet<long>[]\
    \ aa = std.math.triplet.Triplet.create(a);\n    std.math.triplet.Triplet<long>\
    \ maxTriplet = tt.max(std.math.triplet.Triplet.create(aa));\n    return maxTriplet.count;\n\
    }\n</code>\n<|/ a tags=c++,java,arrays dscore=0 |>\n<| c |>\nThat is basically\
    \ the same solution as mine. Except that mine uses `int` instead of `long`. I\
    \ think you forgot about `long` in the question and the `std.typecons` part.\n\
    <|/ c |>\n<| c |>\nI know. But what does std.typecons mean?\n<|/ c |>\n<| c |>\n\
    That's a library I've used for type checking. See https://stackoverflow.com/questions/18452538/what-is-std-typecons\n\
    <|/ c |>\n<| c |>\nThe first one I thought about it but I don't think it is possible\
    \ to find triples using a simple nested loop. Because the value of a[j] depends\
    \ on the value of a[i] and a[k] respectively. So, I thought the solution would\
    \ be more complex. But, I got your point.\n<|/ c |>\n<| c |>\nYeah, I thought\
    \ about a solution using two loops, one to loop over i and j and the other to\
    \ loop over i and k. But I was afraid of time complexity. And I don't think we\
    \ can get that with a single loop. So, time complexity is not really an issue\
    \ here.\n<|/ c |>\n<| a dscore=0 |>\nI am not entirely sure if I understood your\
    \ problem correctly.\nIs this what you are looking for?\n<code>\nimport java.util.*;",
  "{\n\tlong i, j, k;\n\tlong count = 0;\n\tint a[n];\n\tfor(i=0, j=n-1; i<n; i+=2,\
    \ j-=2)\n\t{\n\t\ta[i] = i*i-1;\n\t\ta[j]=i*j-1;\n\t\ta[k]=j*k-1;\n\t}\n\tfor(i=1,\
    \ j=1, k=0; i<n; i+=2, j-=2, k+=2) \n\t{\n\t\tif(a[i]+a[j]+a[k]==2*(i*i+j*j))\
    \ count++;\n\t}\n\treturn count;\n}\n</code>\n<|/ a tags=python,algorithm |>\n\
    <| a dscore=0 |>\n<code>\ndef get_max_triples(n):\n    triples = 0\n    for i\
    \ in range(1, n+1):\n        for j in range(1, n-i-1):\n            for k in range(j+1,\
    \ n):\n                triples += (3*j + 2*i + 1) % n\n    return triples\n</code>\n\
    <|/ a tags=python,algorithm |>\n<| a dscore=0 tags=python,algorithm |>\nWe can\
    \ also solve this question using dynamic programming.", "{\n    int[] a = new\
    \ int[n];\n    for (int i = 0; i < n; i++)\n    {\n        a[i] = i * i - i +\
    \ 1;\n    }\n    long count = 0L;\n    for (int i = 0; i < n; i++)\n    {\n  \
    \      for (int j = i + 1; j < n; j++)\n        {\n            for (int k = j\
    \ + 1; k < n; k++)\n            {\n                long temp = a[i] + a[j] + a[k];\n\
    \                if (temp % 3 == 0)\n                {\n                    count++;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=java,time-complexity,algorithm,arrays |>\n<| a tags=java,time-complexity,algorithm,arrays\
    \ |>\n<code>\npublic static void main(String[] args) {\n        long a[] = new\
    \ long[100000000];\n        Arrays.fill(a , 1);\n        long n = 5;\n       \
    \ long cnt = 0;\n        long sum = 0;\n        for(int i=0;i<n;i++) {\n     \
    \       for(int j=i+1;j<n;j++) {\n                for(int k=j+1;k<n;k++) {\n \
    \                   if(i+j+k==n*n*n) { \n                        cnt ++;\n   \
    \                 }\n                }\n            }\n            sum = sum +\
    \ i;\n        }\n        System.out.println(cnt);\n        System.out.println(sum);\n\
    \    }\n</code>\nThe above solution works in O(n^2) time complexity and O(1) space\
    \ complexity. \nWe have three nested for loops and inside each one we make n iterations.\n\
    The outer loop runs from 0 to (n-1) where n is the size of the array. So, it runs\
    \ exactly n times.\nThe inner loops runs from i+1 to n. This runs exactly n/2\
    \ times. \nSo the total time complexity is O(n^2 * n/2) = O(n^2).\nThe total space\
    \ complexity is O(n^2).\n<|/ a dscore=0 |>\n<| c |>\nThis solution is incorrect\
    \ when `n` is large because you never sum up the elements of `a`.\n<|/ c |>\n\
    <| c |>\nSorry that i overlooked that part. Now it is corrected and tested.\n\
    <|/ c |>\n<| a dscore=0 tags=java,time-complexity,algorithm,arrays |>\n<code>\n\
    import java.util.Arrays;\nimport java.util.Random;", "{\n    long triples;\n \
    \   int *a;\n    long i,j,k;\n    a=newint(n);\n    for(i=1;i<n;i++)\n       \
    \ a[i]=i*i-1;\n    for(i=1;i<n;i++) {\n        for(j=i+1;j<n;j++) {\n        \
    \    for(k=j+1;k<n;k++) {\n                if(a[i]+a[j]+a[k]==2*(i*i+j*j+k*k))\
    \ \n                    triples += 1;\n            }\n        }\n    }\n    return\
    \ triples;\n}\n</code>\n<|/ a tags=algorithm,c++ dscore=3 |>\n<| c |>\nThe time\
    \ complexity of this is O(n^4). In the worst case, where all the array elements\
    \ are equal, the number of valid triples would be equal to n(n-1)/2. On the other\
    \ hand, if the array has n equal elements, then the number of valid triples would\
    \ be n(n-1)/(n-2)/(n-3)/... =(n^2)/2. This makes the time complexity of this O(n^3).\n\
    <|/ c |>\n<| c |>\nI wonder if there is any other way to get the complexity less\
    \ than O(n^4).\n<|/ c |>\n<| c |>\nThe second one can be done in O(n^2) time using\
    \ counting sort. Though it involves more space than your solution, but that could\
    \ be significant.\n<|/ c |>\n<| c |>\nI posted the question [here](http://stackoverflow.com/questions/35671878/counting-sort-or-radix-sort)\
    \ for more details about the time complexity of counting sort.\n<|/ c |>\n<| a\
    \ tags=algorithm,c++ |>\nYou can do something like this\n<code>", "{\n    long\
    \ i,j,k,sum=0;\n    long a[n];\n    for (i = 0; i <= n; i++) {\n        a[i] =\
    \ i*i-i+1;\n    }\n    for(i = 0; i <= n; i++) {\n        for (j = 0; j <= n;\
    \ j++) {\n            for (k = 0; k <= n; k++) {\n                if(i<j && i<k\
    \ && j<k) {\n                    sum+=a[i];\n                }\n            }\n\
    \        }\n    }\n    return sum % 3;\n}", "{\n    int a[n+1];\n    for(int i=0;i<n+1;i++)\n\
    \    {\n        a[i]=i*i-i+1;\n    }\n    for(int i=1;i<n+1;i++)\n    {\n    \
    \    for(int j=1;j<n+1;j++)\n        {\n            for(int k=1;k<n+1;k++)\n \
    \           {\n                if(i<j && i<k && j<k && a[i]+a[j]+a[k]==0)\n  \
    \              {\n                    long temp=a[i]+a[j]+a[k];\n            \
    \        if(temp%3)\n                    {\n                        cout<<i<<\"\
    \ \"<<j<<\" \"<<k<<endl;\n                    }\n                }\n         \
    \   }\n        }\n    }\n    return 0;\n}\n</code>\n<|/ a |>\n<| c |>\nYou have\
    \ an extra `return 0;` in the bottom of the `for` loops\n<|/ c |>\n<| c |>\nya\
    \ but i cant understand how this code is working\n<|/ c |>\n<| c |>\nIt iterates\
    \ through all possible pairs of numbers in the array and prints the triplet for\
    \ which sum is divisible by 3.\n<|/ c |>\n<| a |>\n<code>", "{\n    long long\
    \ a[n] = {0};", "{\n\tstd.typecons.IntVector a = new std.typecons.IntVector(n);\n\
    \tfor(int i = 0; i < n; i++) a[i] = i * i - i + 1;\n\t\n\tlong res = 0;\n\tfor(int\
    \ i = 0; i < n; i++) {\n\t\tfor(int j = i+1; j < n; j++) {\n\t\t\tfor(int k =\
    \ j+1; k < n; k++) {\n\t\t\t\tif(a[i] + a[j] + a[k] == 3) {\n\t\t\t\t\tres++;\n\
    \t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n</cell>\n\
    <cell>\n%debug\n</cell>\n<text>\nProblem 5\nThis problem has a similar solution\
    \ than the previous ones. Just with different array indexing.", "{\n    long[,]\
    \ a = new long[n,n];\n    for( long i = 0; i < n ; ++i ) {\n        a[i,0] = 0;\n\
    \    }\n    for( long i = 0; i < n ; ++i ) {\n        for( long j = i+1 ; j <\
    \ n ; ++j ) {\n            for( long k = j+1 ; k < n ; ++k ) {\n             \
    \   a[i,j] += a[j,k] + 1;\n            }\n        }\n    }\n    return std.math.pow(a[a.GetLength(0)-1,a.GetLength(1)-1],3);\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI understand that my program is going\
    \ to take quadratic time. But I am just trying to understand if there is a faster\
    \ way to implement this.\n<|/ c |>\n<| c |>\nHi I updated my answer. It runs in\
    \ quadratic time but with O(1) additional space. This was the first thing I thought\
    \ of. I was also trying to think of another approach but I think it got lost in\
    \ my head.\n<|/ c |>\n<| c |>\nHey, your solution is much better than the one\
    \ I came up with. However I did some research and I found that your approach works\
    \ well in every case. Thanks!\n<|/ c |>\n<| a tags=c# dscore=0 |>\nI came up with\
    \ this solution using dynamic programming. Basically I precalculated the sum for\
    \ each possible pairing of indices and then just count how many triples are valid\
    \ (in the form of a[i+j+k] == i*i+j+k).\n<code>\nusing System;\nusing System.Collections.Generic;",
  "{\n    long long int* a = (long long int*)calloc(n,sizeof(long long int));\n  \
    \  std.assert(a != NULL);\n    long long int sum = 0;\n    for (int i=0;i<n;i++)\
    \ {\n        a[i] = i*i%n;\n        sum += a[i];\n    }\n    int j = 0;\n    long\
    \ long int ans = 1;\n    for (int i=1;i<n;i++) {\n        ans *= 3;\n        while\
    \ (j < i) {\n            ans *= 3;\n            sum += a[j];\n            j++;\n\
    \        }\n    }\n    return sum % ans;\n    free(a);\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks for the answer. But how does the answer differ from the\
    \ problem statement and what is the idea behind this answer?\n<|/ c |>\n<| c |>\n\
    The idea is that you use dynamic programming to determine your answer efficiently\
    \ by building up a table of all the triplets given any given input.\n<|/ c |>\n\
    <| c |>\nThank you for the answer. How does a table of triples help in finding\
    \ out if any number is a multiple of 3?\n<|/ c |>\n<| c |>\nIf you could give\
    \ an example I can test the code. I'll be happy to explain.\n<|/ c |>\n<| c |>\n\
    Sure. Let us say, a = [1,3,5,7]. Then, the sum is equal to 24. So, the answer\
    \ is 2*3*(5+7). Am I making sense to you? Thanks.\n<|/ c |>\n<| a dscore=0 |>\n\
    This could be a solution:\n<code>", "{\n    long a[n] = {0};\n    long long temp;\n\
    \    long long count = 0;\n    \n    for (long i = 0; i < n; i++)\n    {\n   \
    \     temp = a[i] * a[i] + a[i] + a[i];\n        if (temp > count)\n        {\n\
    \            count = temp;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=c++,arrays,algorithm,c,arrays dscore=0 |>\n<| a dscore=0 |>\nThe easiest\
    \ and fastest way is to first calculate the number of triplets using the formula\
    \ below:", "{\n\tlong ans = 0;\n\tint[] a = new int[n];\n\tfor(int i = 0 ; i <\
    \ n ; ++i) {\n\t\ta[i] = i * i - i + 1;\n\t}\n\tfor(int j = 0 ; j < n ; ++j) {\n\
    \t\tfor(int k = 0 ; k < n ; ++k) {\n\t\t\tif(a[j] > a[k] && j <  k) ans++;\n\t\
    \t}\n\t}\n\treturn ans;\n}\n</code>\n<|/ a dscore=0 tags=algorithm,c++,c,arrays,time-complexity\
    \ |>\n<| c |>\nThanks for your solution, but I don't think it will work for the\
    \ question as per the problem statement that I attached. Your code will give the\
    \ wrong answer in the example I have given in the question.\n<|/ c |>\n<| a tags=algorithm,c++,c,arrays,time-complexity\
    \ |>\n<code>", "{\n    long result = 0;\n    long i;\n    long[] a = new long[n];\n\
    \    for (i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    sort(a,\
    \ 0, n - 1);\n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++)\
    \ {\n            for (k = j + 1; k < n; k++) {\n                if ((a[i] + a[j]\
    \ + a[k]) == 3 * i * a[j] * a[k])\n                    result = result + 3;\n\
    \            }\n        }\n    }\n    return result;\n}\n'''\n</cell>\n<code language=xeus-cling-cpp11>\n\
    %%cpp get_max_triples\nlong get_max_triples(long n) \n{\n    long result = 0;\n\
    \    long i;\n    long* a = new long[n];\n    for (i = 0; i < n; i++) {\n    \
    \    a[i] = i * i - i + 1;\n    }\n    sort(a, 0, n - 1);\n    for (i = 0; i <\
    \ n; i++) {\n        for (j = i + 1; j < n; j++) {\n            for (k = j + 1;\
    \ k < n; k++) {\n                if ((a[i] + a[j] + a[k]) == 3 * i * a[j] * a[k])\n\
    \                    result = result + 3;\n            }\n        }\n    }\n \
    \   return result;\n}\n</cell>\n<code language=xeus-cling-cpp11>\nget_max_triples(5)\n\
    </cell>\n<text>\n3.3 Binary Search Triples Counting\nGiven a sorted array of integers,\
    \ find the number of triples where i < j < k", "{\n    long result = 0;\n    long\
    \ temp;\n    long t = (long)Math.pow((double)n, (double)3);\n    std.array< long,\
    \ 2> a1 = std.array< long, 2>(2);\n    std.array< long, 2> a2 = std.array< long,\
    \ 2>(2);\n    std.array< long, 2> a3 = std.array< long, 2>(2);\n    long i,j,k;",
  "{\n    int[] a = new int[n];", "{\n    long i;\n    int a[n];\n    for(i = 0; i\
    \ < n; i++) \n    {\n        a[i] = i * i - i + 1;\n    }\n    for(i = 0; i <\
    \ n - 1; i++) \n    {\n        for(j = i + 1; j < n; j++) \n        {\n      \
    \      for(k = 0; k < n - i - j; k++) \n            {\n                if (a[i\
    \ + k] + a[j + k] + a[k + k] == (3 * k)) \n                {\n               \
    \     return k;\n                }\n            }\n        }\n    }\n    return\
    \ -1L;\n}\n</code>\n<|/ a tags=optimization,algorithm,java,dynamic-programming\
    \ |>\n<| c |>\nI think this is the best solution, since the number of elements\
    \ `3^n` is bounded. Also, I think it's worth to mention that `a[i + k] + a[j +\
    \ k] + a[k + k] == (3 * k)` can be replaced with `a[i + k] + a[j + k] * 2 + a[k\
    \ + k] == (3 * k)` as long as you know that `a[i + k] == 3 * a[i]`, `a[j + k]\
    \ == 3 * a[j]` and `a[k + k] == 3 * a[k]`. Though this solution may have worse\
    \ runtime complexity.\n<|/ c |>\n<| a dscore=0 |>\nI assume that a[i] means a[i]\
    \ = (i+1)*(i+2)+(i+3) for each value of i. I also assume that if a[i] equals a[j],\
    \ and if a[i] equals a[k], then a[j] equals a[k]. \nIf a[i] is divisible by 3,\
    \ then a[j] and a[k] are both divisible by 3 and a[j+k] also is divisible by 3.\
    \ \nWe can get rid of a[i] and a[j] by subtracting 1 from a[k+j] and a[i+k] respectively,\
    \ but a[k+j] can never be divisible by 3, and a[i+k] can never be divisible by\
    \ 3. \nTherefore, we could try getting rid of a[i] and a[j] by subtracting 1 from\
    \ a[k+j] and a[i+k] respectively, but a[k+j-1] and a[i+k-1] can never be divisible\
    \ by 3, and a[k+j] and a[i+k] can never be divisible by 3.\nSo we could try getting\
    \ rid of a[i] and a[j] by subtracting 1 from a[k+j-1] and a[i+k-1] respectively,\
    \ but a[k+j-1] and a[i+k-1] can never be divisible by 3, and a[k+", "{\n    int\
    \ a[n];", "{\n    int[] a = new int[n];\n    long res = 0;\n    for(int i=0;i<n;i++)\
    \ {\n        a[i] = i*i - i+1;\n        if(i != 0 || i != n || a[i] % 3 == 0)\
    \ {\n            res++;\n        }\n    }\n    return res;\n}\n</code>\n<|/ a\
    \ |>\n<| a tags=algorithm,java,dynamic-programming |>\nThis is a dynamic programming\
    \ solution in Java.\nThe key here is using an auxiliary array of length n which\
    \ holds the sums of the triples from the array except the element at position\
    \ k (which is calculated from the array).\nFor simplicity, instead of doing this\
    \ in a separate function, I am doing it inline.\n<code>\nimport java.util.Arrays;",
  "{\n    long sum = 0;\n    Array2D<long> a(n, 3); // Array of a has 3 columns, each\
    \ column is 3 long values.\n    for (int i = 0; i < n; i++) // iterate through\
    \ all rows\n    {\n        for (int j = 0; j < i; j++) // iterate through all\
    \ columns except for i'th column\n        {\n            a[i][j] = i * i - i +\
    \ 1;\n            sum += a[i][j];\n        }\n    }\n    return count_triple_max_sum(a,\
    \ sum);\n}", "{\n    long i = 0;\n    long j = 0;\n    long k = 0;", "{\n    int[]\
    \ a = new int[n];\n    long ans = 0;\n    long cnt = 0;", "{\n    long count =\
    \ 0; \n    vector<long long int> a;\n    for (int i = 1; i < n; i++) \n    { \n\
    \        if (i % 3 == 0) \n        { \n            a.push_back(i * i - i + 1);\
    \ \n        } \n    } \n    for (int i = 0; i < n; i++) \n    { \n        for\
    \ (int j = 0; j < n; j++) \n        { \n            for (int k = 0; k < n; k++)\
    \ \n            { \n                if (i + j < k && j + k > i && i + k > j) \n\
    \                { \n                    if (a[i + j] + a[j + k] + a[i + k] ==\
    \ a[j] * a[k] * a[i]) \n                    { \n                        count++;\
    \ \n                    } \n                } \n            } \n        } \n \
    \   } \n    return count; \n} \n</code>\n<|/ a |>\n<| c |>\n`vector<long long\
    \ int> a;` should be `vector<long long unsigned> a;`\n<|/ c |>\n<| a |>\nHere\
    \ is my solution. Many thanks to Eric for his help!\n<code>\nlong long int get_max_triples(long\
    \ long int n)\n{\n    vector<long long int> a;\n    long long int count = 0; \n\
    \    for (long long int i = 0; i < n; i++)\n    {\n        if (i % 3 == 0)\n \
    \       {\n            a.push_back(i * i - i + 1);\n        }\n    }\n    for\
    \ (long long int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n\
    \        {\n            for (int k = 0; k < n; k++)\n            {\n         \
    \       if (i + j < k && j + k > i && i + k > j)\n                {\n        \
    \            if (a[i + j] + a[j + k] + a[i + k] == a[j] * a[k] * a[i])\n     \
    \               {\n                        count++;\n                    }\n \
    \               }\n            }\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a tags=c++,algorithm dscore=2 |>\n<| c |>\nThis is O(n^3), which is not the\
    \ best solution.\n<|/ c |>\n<| c |>\nYes, i know that but i think that for this\
    \ case it is not important how many times you search and it is better than O(n^3)\n\
    <|/ c |>\n<| a dscore=1 |>\nThe first thing that comes to mind is to create a\
    \ boolean array that indicates if all elements in the array are multiples of 3.\
    \ This would take O(n) time. You would then iterate through your array and only\
    \ add elements to the array that are multiples of 3, and count the elements in\
    \ the array. This would take O(n^2) time. \n<code>", "{\n    long long long a[n];\n\
    \    for (int i = 0; i < n; ++i)\n        a[i] = i * i - i + 1;", "{\n    long\
    \ a[n];\n    for(int i = 0; i < n; i++){\n        a[i] = i * (i - 1) + i + 1;\n\
    \    }\n    long triple = 0;\n    for(int i = 0; i < n; i++){\n        for(int\
    \ j = 0; j < i; j++){\n            for(int k = 0; k < j; k++){\n             \
    \   triple += std.array.get(a, i) + std.array.get(a, j) + std.array.get(a, k);\n\
    \            }\n        }\n    }\n    return triple;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis approach is quite inefficient because it has to generate all\
    \ triplets until you find the maximum.\n<|/ c |>\n<| c |>\nYes, I know.  I just\
    \ want to demonstrate how to use a nested loop to count all the triples.\n<|/\
    \ c |>\n<| c |>\nI know.  I just want to demonstrate how to use a nested loop\
    \ to count all the triples.\n<|/ c |>\n<| a |>\nA recursive solution is inefficient\
    \ because you have to generate all triples until you find the maximum.  Here is\
    \ a recursive solution using dynamic programming:\n<code>\nfunction findMaximumTriples(int\
    \ n) {\n    if (n<1) return 0;\n    if (n==1) return 1;\n    \n    long maxTriple\
    \ = 0;\n    \n    for(int i=1; i<n; i++) {\n        maxTriple += findMaximumTriples(i-1)\
    \ + 1;\n        maxTriple += i * i - i + 1;\n    }\n    return maxTriple;\n}\n\
    </code>\n<|/ a tags=c,algorithm dscore=0 |>\n<| a dscore=0 |>\nThe first approach\
    \ is quite inefficient because you have to generate all triples until you find\
    \ the maximum.\nThe second approach is too complex and error prone. Just use a\
    \ nested loop.\n<code>\nlong findMaximumTriples(long n) {\n    long maxTriple\
    \ = 0;\n    long k = 0;\n    for (int i = 1; i <= n; i++) {\n        long triple\
    \ = 0;\n        for (int j = 0; j < i; j++) {\n            triple += i + j;\n\
    \        }\n        for (int j = i; j < n; j++) {\n            triple += j;\n\
    \        }\n        for (int j = i; j < n; j++) {\n            triple += j;\n\
    \        }\n        for (int k = i; k <= j; k++) {\n            triple += k;\n\
    \        }\n        if (triple > maxTriple) {\n            maxTriple = triple;\n\
    \        }\n    }\n    return maxTriple;\n}\n</code>\n<|/ a tags=c,algorithm |>\n\
    <| c |>\nThe nested for loop makes me think this is the ", "{\n    long a[n],\
    \ i, j, k;", "{\n    std.array<long, 1> a = new std.array<long, 1>(n);\n    for(long\
    \ i = 1L; i <= n; i++) a[i] = i * i - i + 1; \n    std.sort(a, 1, a.length, (i,\
    \ j) => { return a[i] + a[j] + a[k]; });\n    return std.find_first_of(a, 1, a.length,\
    \ (a) => { \n        return (a[i] + a[j] + a[k]) % 3 == 0;\n    });\n}\n</code>\n\
    <|/ a |>\n<| c |>\nA couple notes: the sort should be std.sort(a, 1, a.length,\
    \ (i, j) => { return a[i] + a[j] + a[k]; }); instead of std.sort(a, 1, a.length,\
    \ (a, b) => { return a[0] - b[0]; });.  And I used std.find_first_of instead of\
    \ the std.find_index.  But thanks for the help!\n<|/ c |>\n<| c |>\nGood catch.\
    \ I fixed the typo. Also, if you're doing this more than once, you may want to\
    \ store it in a hash table. Finding the triple takes O(n) time (since you have\
    \ the hash table with you anyway), but finding the triplets themselves takes O(n\xB2\
    ).\n<|/ c |>\n<| c |>\nHi, I ran your benchmark program and I saw a big difference\
    \ between your solution and the solution in the accepted answer. Could you please\
    \ check it?\n<|/ c |>\n<| a dscore=2 |>\n<code>\n/**\n * Count the number of triples\
    \ that sum to the number n.\n * \n * n\n *\n */\nlong countTriples(int n) {\n\
    \    int[] arr = new int[n + 1];\n    Arrays.fill(arr, n + 1);\n    // count how\
    \ many times i appears in arr\n    long cnt = Arrays.asList(arr).stream().filter(i\
    \ -> i == n).count();\n    long ans = 0;\n    for (int i = n; i >= 1; i--) {\n\
    \        ans += ((arr[i - 1] + arr[i - 2] + arr[i - 1]) / 3) * 3 - (arr[i - 1]\
    \ + arr[i - 2]) % 3 == 0;\n    }\n    return ans / cnt;\n}\n</code>\n<|/ a tags=algorithm,time-complexity,java\
    \ |>\n<| c |>\nWhat is Arrays.asList(arr)?\n<|/ c |>\n<| c |>\nArrays.asList converts\
    \ an array to a list\n<|/ c |>\n<| c |>\nI see. But what is the purpose of this\
    \ method? Because when I tried to replace the array with a list it didn't work.\n\
    <|/ c |>\n<| a tags=algorithm,time-complexity,java ", "{\n    long cnt = 0;\n\
    \    vector<long int> a(n);\n    for (long i = 0; i < n; ++i) \n    {\n      \
    \  a[i] = i*i - i + 1;\n    }\n    sort(a.begin(), a.end());", "{\n    long count\
    \ = 0;\n    long temp = 0;\n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = i; j < n; j++)\n        {\n            for(int k = j; k < n; k++)\n    \
    \        {\n                temp = i*i  +j  + k;\n                if(temp % 3\
    \ ==0)\n                {\n                    count++;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a dscore=0 tags=algorithm,arrays,dynamic-programming |>\n<| c |>\nFor a large\
    \ n this solution will fail, as the time complexity will approach O(n^3). An O(n^2)\
    \ solution can be done in O(n^2).\n<|/ c |>\n<| c |>\nAgreed. My solution is O(n^2)\
    \ since it only calculates the number of triples and sums them up. My solution\
    \ is O(n^3) since the summing is done inside the inner for-loop. Your solution\
    \ is also O(n^3). My solution is O(n^4).\n<|/ c |>\n<| c |>\nThe inner for-loop\
    \ is O(n^2) because of the `int i` and the `for(int j = i; j < n; j++)` statements.\
    \ But the `if` statement inside the inner for-loop also runs in O(n^2) time.\n\
    <|/ c |>\n<| c |>\nAgreed, but I don't think the for loop that calculates the\
    \ number of triples runs in O(n^3). Maybe you can give me a counterexample where\
    \ my solution fails. Because I thought my solution runs O(n^3) but it seems it\
    \ runs O(n^4).\n<|/ c |>\n<| c |>\nOk, i think i missread your question. I thought\
    \ you were asking how to determine the maximum number of triples (a[i],a[j],a[k])\
    \ of a where i<j<k, but now i see you want the sum of all triples (i,j,k) where\
    \ i<j<k\n<|/ c |>\n<| a tags=algorithm,arrays,dynamic-programming |>\nHere is\
    \ my implementation in Java with O(n^2) time complexity and O(n^3) space complexity:\n\
    <code>\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\
    import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;", "{\n\
    \    std.carray<int,3> a(n);\n    long ans = 0;\n    \n    for (long i=0; i<n;\
    \ i++)\n    {\n        a[i] = i * i - i + 1;\n        if (i != n-1)\n        {\n\
    \            for (long j=0; j<n; j++)\n            {\n                if (j !=\
    \ i)\n                {\n                    if (j != n-1)\n                 \
    \   {\n                        for (long k=0; k<n; k++)\n                    \
    \    {\n                            if (k != i && k != n-1)\n                \
    \            {\n                                if (a[i+j+k] == 0)\n         \
    \                           break;\n                                else\n   \
    \                             {\n                                    if (a[i+j+k]\
    \ % 3 == 0)\n                                        ans = max(ans, i+j+k);\n\
    \                                }\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }", "{\n    \n    long sum = 0, cnt = 0;\n    for(long i = 1; i\
    \ < n; ++i)\n    {\n        sum += i * i - i + 1;\n        if(sum % 3 == 0)\n\
    \        {\n            cnt ++;\n            sum = 0;\n        }\n    }\n    return\
    \ cnt;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nThis is my solution to this problem:\n\
    <code>", "{\n    long a[n];\n    long long sum = 0;\n    for(int i=0;i<n;i++)\
    \ {\n        a[i] = i * i + i + 1;\n        sum += a[i];\n    }\n    return sum;\n\
    }\n</code>\n<|/ a dscore=1 tags=c++,algorithm,python,arrays,c |>\n<| c |>\nSorry\
    \ I forgot to mention this was a constraint of the problem, I have added this\
    \ to the question.\n<|/ c |>\n<| c |>\nThank you for the response, I think I understand\
    \ what you're saying but I'm not quite sure how to implement it into my code.\
    \ I don't quite understand what you're saying by \"You have to create an integer\
    \ array a of length n.\" Could you explain a little bit more please?\n<|/ c |>\n\
    <| a |>\nHere's a working solution that is O(n).\n<code>\ndef get_max_triples(n):\n\
    \    a = [(i+1)**2 - 2*i + 1 for i in range(n)]\n    a.sort()\n    triples = []\n\
    \    k = n-1\n    while k:\n        triples.append(a[k])\n        k = k - 1\n\
    \        if k == 0:\n            return len(triples)\n        triples.append(a[k])\n\
    \        k = k - 1\n    return len(triples)\n</code>\n<|/ a tags=c++,algorithm,python,arrays,c\
    \ dscore=1 |>\n<| a tags=c++,algorithm,python,arrays,c |>\n<code>\ndef maxTriples(n):\n\
    \    count=0\n    for i in range(n+1):\n        count+=(n-i)*(n-i)//(i-1)\n  \
    \  return count", "{\n    long a[n];\n    for (long i = 0; i < n; ++i)\n     \
    \   a[i] = i * i - i + 1;\n    long result = __gcd(a, a, n);\n    if (result <\
    \ n)\n        result = 0;\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=arrays,algorithm,c++ dscore=0 |>\nA very simple approach is to use a\
    \ triangular array and sort it using a simple bubble sort.\n<code>", "{\n    long\
    \ ans = 0;\n    long* a = new long[n];\n    for(int i=0; i<n; i++)\n    {\n  \
    \      a[i] = i * i - i + 1;\n    }\n    for(int i=1; i<n; i++)\n    {\n     \
    \   for(int j=i; j<n; j++)\n        {\n            for(int k=j; k<n; k++)\n  \
    \          {\n                if(a[i] + a[j] + a[k] % 3 == 0)\n              \
    \  {\n                    ans++;\n                }\n            }\n        }\n\
    \    }\n    return ans;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c++,algorithm\
    \ dscore=1 |>\nTry this solution:\n<code>", "{\n    long long int a[n];\n    for(int\
    \ i=0; i<n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    long long int max_triples\
    \ = 0;\n    long long int max_triple = -1;\n    for(int i=0; i<n; i++) {\n   \
    \     for(int j=0; j<n; j++) {\n            for(int k=0; k<n; k++) {\n       \
    \         max_triple = std.max(a[i], a[j], a[k]);\n                if(max_triple*3\
    \ == max_triple) {\n                    max_triples += 1;\n                }\n\
    \            }\n        }\n    }\n    return max_triples;\n}\n</code>\n<|/ a tags=algorithm,data-structures,performance,arrays\
    \ |>\n<| c |>\nWhy did you use a long long int ?\n<|/ c |>\n<| c |>\nThe integer\
    \ type should be sufficient to hold the largest `long` value. I think you misunderstood\
    \ the purpose of `long long`. Please read about it more: https://en.cppreference.com/w/cpp/language/types\n\
    <|/ c |>\n<| c |>\nYes sorry I missed that. Thanks.\n<|/ c |>\n<| a |>\nI wrote\
    \ my solution in JavaScript and I compared it to my original C++ solution.\nThis\
    \ is my C++ solution. Note that the number of triples needed is at most 3 * n\
    \ / 2 but that's OK.\n<code>\nfunction get_max_triples(n) {\n    // preallocate\
    \ memory for arrays\n    var a = new Array(n);\n    var count = 0;", "{\n    /*\n\
    \    \n    Your Task: \n    Write a function that returns an array of length n\
    \ with the number of triples that \n        (a[i], a[j], a[k]) of a where i <\
    \ j < k and a[i] + a[j] + a[k] is a multiple of 3.\n        The input will be\
    \ a positive integer n, and the output will be an array of length n with \n  \
    \      the number of triples.", "{\n    return count_valid_triples(n, 3L);\n}",
  "{\n    long long ans = 0;\n    long long temp = 0;\n    for(int i = 1; i <= n;\
    \ i++)\n    {\n        temp = i * i - i + 1;\n        if(temp >= 3)\n        \
    \    ans++;\n    }\n    return ans;\n}\n</code>\n<|/ a tags=performance,c,algorithm,python,c++\
    \ dscore=2 |>\n<| c |>\nThe `if` statement in your `for` loop can be replaced\
    \ by `ans+=i*i*i;`.\n<|/ c |>\n<| c |>\n.C. yes, that's right. It might be even\
    \ faster, but i think it's more readable.\n<|/ c |>\n<| a dscore=2 |>\nTo understand\
    \ this code, I first need to explain a bit about how it works:\n<code>\n#include\
    \ <stdio.h>", "{\n    vector<int> a(n);\n    for(int i = 0; i< n; ++i) {\n   \
    \     a[i] = i * i - i + 1;\n    }\n    \n    long triples = 0;\n    for(int i\
    \ = 1; i < n; ++i) {\n        for(int j = i+1; j < n; ++j) {\n            for(int\
    \ k = j+1; k < n; ++k) {\n                if(a[i] + a[j] + a[k] == 0) {\n    \
    \                break;\n                }\n                if(a[i] + a[j] + a[k]\
    \ == 3) {\n                    ++triples;\n                    break;\n      \
    \          }\n            }\n        }\n    }\n    return triples;\n}", "{\n \
    \   long count = 0;\n    long a[n];\n    for(int i = 1; i <= n; i++)\n    {\n\
    \        a[i] = i * i - i + 1;\n    }\n    int i = 0, j = 0;\n    while(i < n\
    \ && j < n)\n    {\n        if(a[i] < a[j])\n        {\n            count++;\n\
    \            i++;\n        }\n        else\n        {\n            j++;\n    \
    \    }\n    }\n    return count;\n}", "{\n    long ans = 0L;\n    long a[n];\n\
    \    for(int i = 0;i < n;++i) {\n        a[i] = i * i - i + 1;\n    }\n    sort(a,\
    \ a + n);\n    for(int i = 0;i < n;++i) {\n        long a1 = a[i], a2 = a[i +\
    \ 1], a3 = a[i + 2];\n        long sum = a1 + a2 + a3;\n        if(sum > ans)\
    \ {\n            ans = sum;\n        }\n    }\n    return ans;\n}\n</code>\n<|/\
    \ a dscore=1 |>\n<| c |>\nThank you very much for that :)\n<|/ c |>\n<| c |>\n\
    You're welcome. I am glad I was able to help you. :)\n<|/ c |>\n<| a tags=algorithm,math,java\
    \ dscore=1 |>\nI believe that the best solution is O(n) because we only need to\
    \ loop through the array once, sorting it is O(n log n).\n<code>\npublic static\
    \ int tripletSums(int[] arr) {\n    int sum = arr[0];\n    int maxSum = 0;", "{\n\
    \    long[] a = { 1, 1, 1 }; // a[0] = 1, a[1] = 1, a[2] = 1.\n    long ans =\
    \ -1L;\n    long long sum = 0L;\n    for (int i = 1; i < n; ++i) {\n        for\
    \ (int j = 1; j < n; ++j) {\n            for (int k = 1; k < n; ++k) {\n     \
    \           sum = a[j] * a[k] - a[i] + k;\n                if (sum == 3L) {\n\
    \                    ans = i;\n                    break;\n                }\n\
    \                sum += sum;\n            }\n        }\n    }\n    return ans;\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nHere is a solution in Kotlin\
    \ and Python. I hope that someone will find it useful:\n<code>\npackage com.companyname.mypackage;",
  "{\n    long long int a[n];\n    \n    for(int i = 0; i < n; i++) {\n        a[i]\
    \ = i * i - i + 1;\n    }\n    \n    long long int sum = 0;\n    long long int\
    \ triple = 0;\n    long long int triples = 0;\n    \n    for(int i = 1; i < n;\
    \ i++) {\n        for(int j = i; j < n; j++) {\n            for(int k = 0; k <\
    \ n; k++) {\n                if(i + j + k == a[i]) {\n                    sum\
    \ += a[i];\n                    triple++;\n                    triples += (i +\
    \ j + k == a[i]);\n                }\n            }\n        }\n    }\n    \n\
    \    return triples;\n}\n</cell>\n<cell>\nget_max_triples(5L)\n</cell>\n<text>\n\
    The function get_max_triples will return an integer that tells you how many triples\
    \ exist for a number that is a power of three.", "{\n    int a[n];\n    long res\
    \ = 0;\n    for(int i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\
    \    for(int i = 0; i < n; i++) {\n        for(int j = i + 1; j < n; j++) {\n\
    \            for(int k = j + 1; k < n; k++) {\n                if(a[i] + a[j]\
    \ + a[k] % 3 == 0) res++;\n            }\n        }\n    }\n    return res;\n}",
  "{\n    if(n == 0) return 0;\n    vector<long> a(n);\n    long result = 0;\n   \
    \ for(int i = 1 ; i <=n; i++)\n    {\n        a[i] = i * i - i + 1;\n    }\n \
    \   for(int i = 1 ; i <=n; i++)\n    {\n        for(int j = 1 ; j <= n; j++)\n\
    \        {\n            for(int k = 1; k <= n; k++)\n            {\n         \
    \       if(a[i] < a[j] && a[i] < a[k])\n                {\n                  \
    \  result = result + (a[i] - a[j]) * (a[i] - a[k]) * 3;\n                }\n \
    \           }\n        }\n    }\n    return result;\n}\n</code>\n<|/ a tags=c++,algorithm\
    \ dscore=2 |>\n<| c |>\nYour code would fail if you had `a[5]` as input.\n<|/\
    \ c |>\n<| c |>\nIt seems to me that your approach is very complicated and hard\
    \ to understand. Why do you use so many loops when you can compute all the `a[]`\
    \ values with one loop?\n<|/ c |>\n<| c |>\nI agree with you, it could be more\
    \ effective. I will edit it once I get a chance. Thanks for pointing out\n<|/\
    \ c |>\n<| c |>\nI understand that. Your code will indeed be less efficient, but\
    \ it will definitely work.\n<|/ c |>\n<| c |>\nI haven't tested it. But I guess\
    \ there are some minor errors in your code. Because when I run your code and test\
    \ it, I get an incorrect result. I tested it with `a[10]` as input. `a[5]` will\
    \ give `0L` instead of `1L`\n<|/ c |>\n<| a dscore=0 |>\nThe solution is actually\
    \ quite simple:\n<code>\nlong long count(int a[], long long n) {\n    long long\
    \ total = 0;\n    long long i = 0;\n    while(i < n) {\n        if (a[i] > a[i\
    \ + n])\n            i++;\n        else if (a[i] > a[i + 2 * n])\n           \
    \ i++;\n        else if (a[i] > a[i + 3 * n])\n            i++;\n        else\n\
    \            total++;\n    }\n    return total;\n}\n</code>\n<|/ a tags=c++,algorithm\
    \ |>\n<| c |>\nThis approach is very inefficient. If `n` is greater than `1000`,\
    \ then the code will run into stack overflow exception.\n<|/ c |>\n<| a dscore=0\
    \ |>\nHere is the correct solution. Hope this helps someone. ", "{\n    std.array<int,\
    \ 2> a(n);\n    for(int i=0; i<n; ++i)\n        a[i] = i*i-i+1;\n    long triples\
    \ = 0;\n    for(int i=0; i<n; ++i)\n    {\n        for(int j=i+1; j<n; ++j)\n\
    \        {\n            for(int k=j+1; k<n; ++k)\n            {\n            \
    \    if(i != j && i != k && j != k)\n                    triples += (a[i] + a[j]\
    \ + a[k]) % 3;\n            }\n        }\n    }\n    return triples;\n}", "{\n\
    \    List<long> list = new List<long>();\n    long counter = 0;\n    \n    for(int\
    \ i = 1; i < n; i++)\n    {\n        long a = i * i - i + 1;\n        \n     \
    \   if(list.Count == 0)\n        {\n            list.Add(a);\n            counter++;\n\
    \            continue;\n        }\n        \n        foreach(long x in list)\n\
    \        {\n            if(x == a)\n            {\n                counter++;\n\
    \                break;\n            }\n        }\n        \n        if(counter\
    \ >= 3)\n            break;\n        list.Add(a);\n    }\n    return counter;\n\
    }\n</code>\n<|/ a dscore=2 tags=algorithm,c#,dynamic-programming,java,c |>\n<|\
    \ c |>\nthank you for answering.\n<|/ c |>\n<| a tags=algorithm,c#,dynamic-programming,java,c\
    \ |>\nFor what it's worth, here's an iterative solution in Python. The idea is\
    \ to keep track of the number of triples that have already been generated. Since\
    \ we need to stop at a multiple of 3, it seems that this is the right place to\
    \ do the check.\n<code>\ndef triple_sum(N):\n    total = 0\n    triples = 0\n\
    \    for i in range(1, N+1):\n        total = (N - i) * (N - i) + 2 * i + 1\n\
    \        if total % 3 != 0:\n            break\n        triples += 1\n    return\
    \ triples\n</code>\nHere's a link to it in JsFiddle\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>\npublic long find_max(long n) {\nlong sum = 0;\nlong temp = 0;",
  "{\n\tlong long triples[3*3] = {0, 0, 0};\n\tlong long a[3];\n\tlong long sum =\
    \ 0;\n\tlong long count = 0;\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i] =\
    \ 3 * i;\n\t\tsum += a[i] + a[i] - a[i] + a[i] + a[i];\n\t}", "{\n    long a[n];\n\
    \    long i, j;", "{\n    long a = 0, b = 0;\n    for(long i = 0; i < n; i++){\n\
    \        if(i == 0){\n            a = 1;\n        }\n        else if(i == n-1){\n\
    \            b = 1;\n        }\n        else {\n            if((a*a - b*b) % 3\
    \ == 0){\n                b++;\n            }\n            else {\n          \
    \      a++;\n            }\n        }\n    }\n    return b;\n}\n</code>\n<|/ a\
    \ tags=c++ |>\n<| c |>\nI tested it, but there is a bug in the logic of the code.\
    \ Could you explain what exactly is wrong with the code? It seems fine, yet it\
    \ fails for some inputs.\n<|/ c |>\n<| c |>\nit gives wrong output for 4. It outputs\
    \ 5 for get_max_triples(4L)\n<|/ c |>\n<| c |>\n, can you post a test case which\
    \ fails?\n<|/ c |>\n<| c |>\nI posted a question on CodeReview: https://codereview.stackexchange.com/questions/224514/count-the-number-of-valid-triples-of-a-given-number\n\
    <|/ c |>\n<| c |>\n, thanks for the link. Looks like I missed a corner case while\
    \ testing my code. :)\n<|/ c |>\n<| a |>\n<code>\n#include <bits/stdc++.h>\nusing\
    \ namespace std;", "{\n    int a[n];\n    long maxTriplets=0;\n    long i,j,k;\n\
    \    long sum;", "{\n    long arr[n];\n    arr[0]=1;\n    for(int i=1;i<n;i++)\n\
    \        arr[i]=arr[i-1]+arr[i-2];\n    int res = 0;\n    for(int i=0;i<n;i++)\n\
    \    {\n        for(int j=i+1;j<n;j++)\n        {\n            for(int k=j+1;k<n;k++)\n\
    \            {\n                long triple = arr[i]+arr[j]+arr[k];\n        \
    \        res=max(res,triple);\n            }\n        }\n    }\n    return res;\n\
    }", "{\n    long a[n];\n    long i = 0;\n    long j = 0;\n    long k = 0;", "{\n\
    \    long a[n];\n    for(long i = 0; i < n; i++) \n    {\n        a[i] = i * i\
    \ - i + 1;\n    }\n    long ret = 0;\n    for(long i = 0; i < n; i++)\n    {\n\
    \        for(long j = i; j < n; j++)\n        {\n            for(long k = j; k\
    \ < n; k++)\n            {\n                if(a[i] + a[j] + a[k] == 3)\n    \
    \            {\n                    ret++;\n                    break;\n     \
    \           }\n            }\n        }\n    }\n    return ret;\n}\n</code>\n\
    <|/ a tags=arrays,algorithm,c |>\n<| c |>\nThanks for your answer but this isn't\
    \ actually homework. I'm actually trying to learn C and this is a problem that\
    \ I thought I'd have to do for practice.\n<|/ c |>\n<| c |>\nYou are welcome.\
    \ I agree with. Though I would suggest to give it a try yourself first, and then\
    \ come back with questions. Good luck.\n<|/ c |>\n<| c |>\n: thanks man I will\
    \ certainly keep that in mind. I will probably try it on my own and come back\
    \ here with questions when I run into trouble.\n<|/ c |>\n<| c |>\nSure. Keep\
    \ posting and you'll see how it goes. Good luck.\n<|/ c |>\n<| a |>\n<code>\n\
    long get_max_triples(long n) {\n    long a[n];\n    long count = 0;\n    for(long\
    \ i = 0; i < n; i++) \n    {\n        a[i] = i * i - i + 1;\n    }\n    for(long\
    \ i = 0; i < n; i++) {\n        for(long j = i; j < n; j++) {\n            for(long\
    \ k = j; k < n; k++) {\n                if(a[i] + a[j] + a[k] == 3) {\n      \
    \              count++;\n                    break;\n                }\n     \
    \       }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0 tags=arrays,algorithm,c\
    \ |>\n<| a tags=arrays,algorithm,c dscore=0 |>\n<code>\n#include<stdio.h>", "{\n\
    \    long[] a = new long[n];\n    for( long i = 0; i < n; ++i ) {\n        a[i]\
    \ = i * i - i + 1;\n    }\n    long ans = 0;\n    for( long i = 0; i < n; ++i\
    \ ) {\n        for( long j = i + 1; j < n; ++j ) {\n            for( long k =\
    \ j + 1; k < n; ++k ) {\n                if( a[i] <= a[j] && a[i] <= a[k] && a[j]\
    \ <= a[k] )\n                    ans++;\n            }\n        }\n    }\n   \
    \ return ans;\n}", "{\n    long long ans = 0;\n    Array<char, 1> a = new Array<char,\
    \ 1>(n);\n    for(long i = 1; i <= n; i++){\n        a.assign(&i, 1);\n      \
    \  ans += a[i];\n    }\n    ans = ans - ((3 * ans + a[n]) % 3);\n    return ans;\n\
    }\n</code>\nI used Array's dynamic array capabilities since that's what your teacher\
    \ was asking for. \nThis code is based on a mathematical formula which I guess\
    \ is why it might be confusing to you for beginners. \nMy code is not optimized\
    \ (it might be slow for large n), so I won't give it any hints regarding that.\n\
    <|/ a tags=arrays,algorithm,big-o,time-complexity,c |>\n<| c |>\nI feel like I'm\
    \ missing some crucial part of your answer though. Why would this be O(n*log(n))?\n\
    <|/ c |>\n<| c |>\n: You are missing that you can count the number of triples\
    \ by checking every triplet of a in O(n). Then you can subtract this number from\
    \ 3 to get the answer.\n<|/ c |>\n<| c |>\nAh, I see now. Thank you!\n<|/ c |>\n\
    <| c |>\nThe array is initialized to all zeros so why does it matter if I'm starting\
    \ at index 1?\n<|/ c |>\n<| c |>\n: Because you can calculate it by going through\
    \ the array and counting the number of triples at every index. Once you have the\
    \ number of triples at each index, you can subtract it from 3 to get your answer.\n\
    <|/ c |>\n<| a dscore=0 |>\nHere is O(n) time complexity:\n<code>", "{\n    long\
    \ long sum = 0;\n    for(int i = 1; i <= n; i++) {\n        sum += (i * i) - i\
    \ + 1;\n    }\n    long long ans = 0;\n    for(int i = 1; i <= n; i++) {\n   \
    \     for(int j = 1; j <= n; j++) {\n            for(int k = 1; k <= n; k++) {\n\
    \                if((i * i) + j + k == sum && i != j && j != k) {\n          \
    \          ans++;\n                }\n            }\n        }\n    }\n    return\
    \ ans;\n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\n<code>\n#include<bits/stdc++.h>\n\
    #define ll long long\nusing namespace std;", "{\n\tif(n<=1)\n\t\treturn 0;", "{\n\
    \    long i,j,k,count=0,a[n];\n    for(i=0; i<n; i++){\n        a[i] = i * i -\
    \ i + 1;\n    }\n    for(i=0; i<n; i++){\n        for(j=0; j<n; j++){\n      \
    \      if(i<j){\n                for(k=0; k<n; k++){\n                    if(a[i]\
    \ + a[j] + a[k]==3){\n                        count++;\n                    }\n\
    \                }\n            }\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nPlease explain your solution and why it might answer\
    \ the question. Simply posting a code block without any explanation is not very\
    \ helpful.\n<|/ c |>\n<| c |>\nThis solution does **not** work correctly if `n`\
    \ is a power of 2. For example, in your answer, for `n = 3` the correct answer\
    \ is 1, but your solution gives 0.\n<|/ c |>\n<| c |>\nMy solution is working\
    \ for all cases I've tested. I would like to know why it doesn't work on the OP's\
    \ case.\n<|/ c |>\n<| c |>\nYour code is incorrect in many cases. For example,\
    \ with `n = 5`, your code returns 0, as `a[1]` is set to `5`, instead of `11`.\n\
    <|/ c |>\n<| c |>\nYes you're right, I missed that case when coding. Now I corrected\
    \ it.\n<|/ c |>\n<| a tags=algorithm,arrays,dynamic-programming |>\nMy solution\
    \ is very simple and fast and can be extended to any type of number without using\
    \ any additional memory:\n<code>", "{\n    int a[n];\n    int i, j, k;\n    long\
    \ triples = 0;", "{\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\
    \ {\n        a[i] = i * i - i + 1;\n    }\n    int res = 0;\n    for (int i =\
    \ 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for\
    \ (int k = j + 1; k < n; k++) {\n                if (a[i] == a[i] + a[j] + a[k])\
    \ {\n                    res++;\n                }\n            }\n        }\n\
    \    }\n    return res;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nIt's not what\
    \ he asked!\n<|/ c |>\n<| c |>\nI think this doesn't answer the question since\
    \ the question is about the number of triplets and not about a triplet.\n<|/ c\
    \ |>\n<| c |>\nI think OP wanted to count the number of triplets where the sum\
    \ is less than `k`\n<|/ c |>\n<| c |>\nYes, I wanted to count the number of triplets\
    \ where the sum is less than k.\n<|/ c |>\n<| c |>\n, that's what i thought, but\
    \ I didn't find any sample with such scenario and I thought that it's obvious.\
    \ Maybe I overlooked it.\n<|/ c |>\n<| a dscore=0 |>\nMy solution is to create\
    \ an array with number of the triplets which sum to k, then find the triplet which\
    \ sums to the smallest number in the array:\n<code>\npublic int getMaxTriplets(int\
    \ k) {\n    int ans = 0;\n    int[] arr1 = new int[k + 1];\n    Arrays.fill(arr1,\
    \ 0);\n    Arrays.sort(arr1);\n    for(int i = 1; i < arr1.length; i++) {\n  \
    \      int tmp = arr1[i];\n        for(int j = 0; j < i; j++) {\n            tmp\
    \ += arr1[j];\n            if(tmp > k) {\n                break;\n           \
    \ }\n        }\n        ans += arr1[i - 1] - arr1[i];\n    }\n    return ans;\n\
    }\n</code>\n<|/ a tags=data-structures,algorithm,java |>\n<| c |>\nThis is not\
    \ correct. Ex: If k is 6, and we have 5 triplets (1,2,3,4,5), it will return 1\
    \ instead of 4 as 6 + (3+2)+(5+2)+(3+4)+5\n<|/ c |>\n<| c |>\nYou're right, thanks.\
    \ I fixed the code.\n<|/ c |>\n<| c |>\n`if (arr1[i] == arr1[i]) {` can be removed.\n\
    <|/ c |>\n<| a dscore=0 |>\nTo count the number of triplets where the sum is less\
    \ than k, you can use a simple dynamic programming approach like below.\n<code>\n\
    # Function to find triplets whose sum is less than k\ndef trip", "{\n    long\
    \ result = 0;\n    long temp;\n    int temp1, temp2, temp3;\n    for(int i = 1;\
    \ i <= n; i = i + 1) \n    {\n        temp = (i * (i-1)) / 2;\n        temp1 =\
    \ temp;\n        temp2 = 0;\n        temp3 = 0;\n        while(temp3 != temp1\
    \ && temp2 < temp3) \n        {\n            temp2 = temp3;\n            temp3\
    \ = (temp1 * temp1 - temp2 * temp2 + temp3) / 3;\n        }\n        if (temp2\
    \ == temp1) \n        {\n            temp = temp3;\n        }\n        if (temp\
    \ % 3 == 0)\n        {\n            result++;\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=java,arrays,algorithm |>\n<| c |>\ni get an infinite loop\
    \ when i run it\n<|/ c |>\n<| c |>\ni edited the code in the answer so it is compilable.\
    \ it works for me. i tested it on ideone.com (java version 8)\n<|/ c |>\n<| c\
    \ |>\nThanks for the code. I am getting a time limit exceeded on hackerrank test\
    \ case when testing with n=5000000\n<|/ c |>\n<| c |>\nthis algorithm is O(n^2)\
    \ so it will exceed the time limit on most input cases. if n is greater than 5000000\
    \ you can just use a HashMap to store the number of triplets and use that for\
    \ counting instead of recalculating it each time. but i suppose you won't be able\
    \ to use HashMaps.\n<|/ c |>\n<| a tags=java,arrays,algorithm dscore=1 |>\nThis\
    \ is my solution using two loops:\n<code>\nlong tripleSums(int n) {\n    long[]\
    \ arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};", "{\n    long a[n];\n    long s = 0;\n\
    \    for(int i = 0; i < n; i++){\n        a[i] = (i * i) - i + 1;\n        s +=\
    \ a[i];\n    }\n    long res = 0;\n    for(int i = 0; i < n; i++){\n        if(a[i]\
    \ % 3 == 0){\n            if(i != n){\n                for(int j = i; j < n; j++){\n\
    \                    if(a[j] % 3 == 0){\n                        if(j != n){\n\
    \                            for(int k = j; k < n; k++){\n                   \
    \             if(a[k] % 3 == 0){\n                                    s += a[i];\n\
    \                                    s += a[j];\n                            \
    \        s += a[k];\n                                }\n                     \
    \       }\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    return s;\n}\n</code>\n<|/ a dscore=1 tags=math,java,algorithm\
    \ |>\n<| c |>\nI don't understand your question. I'm just trying to prove that\
    \ this algorithm works.\n<|/ c |>\n<| c |>\nIf this algorithm works, how can it\
    \ be used to calculate nCk?\n<|/ c |>\n<| c |>\nThis is not a suitable algorithm\
    \ for computing N! because of the large range of values you can have.\n<|/ c |>\n\
    <| c |>\n: I agree with you. But it seems to me that the original algorithm was\
    \ a good approximation.\n<|/ c |>\n<| c |>\nYes this algorithm works, but it is\
    \ far too slow.\n<|/ c |>\n<| a tags=math,java,algorithm |>\nTo prove that the\
    \ given algorithm works (and not just proving that it is correct), you have to\
    \ prove that this can be proven mathematically. ", "{\n    long long ans = 1L;\n\
    \    long long temp = 0;", "{\n    long a[n], i, j, k, cnt;\n    for(i = 0; i\
    \ <n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n    cnt = 1L;\n    for(i =\
    \ 0 ; i < n; ++i) {\n        for(j = i+1 ; j < n; ++j) {\n            for(k=i+1;\
    \ k < n; ++k) {\n                if((a[i] + a[j] + a[k]) % 3 == 0) {\n       \
    \             cnt++;\n                }\n            }\n        }\n    }\n   \
    \ return cnt;\n}\n</code>\n<|/ a |>\n<| c |>\nCould you please explain how this\
    \ solution works? I haven't been able to understand the `cnt` variable at all.\n\
    <|/ c |>\n<| c |>\nThank you for your help, could you please explain how you came\
    \ up with this solution and what the complexity of this solution is (just wondering)?\
    \ Also what is the difference between `cnt` and `cnt2`?\n<|/ c |>\n<| a dscore=1\
    \ tags=c++,c,algorithm,dynamic-programming |>\nThe most obvious algorithm for\
    \ this problem is to find the highest number in the array. \nYou can use a hash\
    \ table to store the numbers that are already in the array and only add the new\
    \ number to the hash table. Once the array is finished you can simply iterate\
    \ over the entire array and check if the number mod 3 == 0 for each element.\n\
    If the mod 3 == 0 condition was true you can increment a counter.\nSince you are\
    \ allowed to use hash tables, you can easily create a hash table of size n + 1.\
    \ Since the array is of size n you can just use an array of size n and each element\
    \ will represent a hash table of size 1.\nSince mod 3 == 0 can only be checked\
    \ for one element in the entire array it only takes O(n) time.\n<|/ a |>\n<| c\
    \ |>\nThat is a bad hash table. The hash table is of size n + 1.\n<|/ c |>\n<|\
    \ c |>\nI see thank you, I'll make that adjustment. Sorry about the confusion.\n\
    <|/ c |>\n<| c |>\nNo problem - Thanks for editing your post to fix the problem.\n\
    <|/ c |>\n<| c |>\nA hash table of size n + 1 won't save you time.\n<|/ c |>\n\
    <| c |>\nI mean if he is allowed to use hash tables. You can create a hash table\
    \ of size n+1 to use as a hash table with all the elements set to 1 except the\
    \ element at the index i.\n<|/ c |>\n<| a dscore=1 |>\nThe first algorithm I would\
    \ use is the following:\nStart with a binary array and fill the array with 1's. ",
  "{\n    long ans = 0;\n    for(int i = 0; i <= n; ++i) {\n        for(int j = i;\
    \ j <= n; ++j) {\n            for(int k = j; k <= n; ++k) {\n                if(j\
    \ > k) continue;\n                if(i < k) continue;\n                if(j <\
    \ i) continue;\n                if(i + j + k == n) {\n                    ans++;\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\n</code>\n\
    <|/ a tags=optimization,algorithm,java |>\n<| a dscore=0 |>\nHere is how I solved\
    \ it (although it's a Python code so feel free to read it as pseudocode):\n<code>\n\
    def max_triples(n):\n  ans = 0\n  for i in range(n):\n    for j in range(i, n):\n\
    \      for k in range(j, n):\n        sum = 0\n        sum += i * i\n        sum\
    \ += j * j\n        sum += k * k\n        if sum == n:\n          ans += 1\n \
    \ return ans\n</code>\nThe sum of the first three numbers is n(n+1)/2, and the\
    \ sum of the last number is n / 2. So it suffices to count how many times you\
    \ can add the third number to get n(n+1)/2 without being divisible by n. And if\
    \ you add them up and compare it to n, that's your answer.\n<|/ a tags=optimization,algorithm,java\
    \ |>\n<| a dscore=0 |>\nHere is some C# code that seems to work:\n<code>\nstatic\
    \ int get_max_triples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n;\
    \ i++)\n    {\n        int j = i;\n        sum += j * j;\n        while ((j *=\
    \ 2) > n)\n            j -= n;", "{\n    Array<int> arr(n);\n    for(int i = 0;\
    \ i < n; ++i)\n        arr[i] = i * i - i + 1;\n    for(int i = 0; i < n-1; ++i)\n\
    \        for(int j = i+1; j < n; ++j)\n            for(int k = j+1; k < n; ++k)\n\
    \                if(arr[i]+arr[j]+arr[k] == (arr[i]+arr[j]+arr[k]) % 3)\n    \
    \                return arr[i]+arr[j]+arr[k];\n    \n    return 0L;\n}\n</code>\n\
    <|/ a tags=dynamic-programming,optimization,algorithm |>\n<| c |>\nI didn't find\
    \ this \"dynamic programming\" approach to be useful, as I only wanted to find\
    \ the highest triple in the array, and not to count how many triples there are\
    \ in the array. Your solution would return 0 for all arrays with 2 or more elements.\
    \ Also, your solution does not take any duplicate elements into account.\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\nprivate static int get_max_triples(int n) {\n\
    \        int sum = 0;\n        for (int i = 1; i < n; ++i) {\n            sum\
    \ += i * i - i;\n        }\n        int ans = 0;\n        int count = 1;\n   \
    \     ans = sum - 2;\n        for (int i = 0; i < n; ++i) {\n            int j\
    \ = n - 1;\n            while (j >= i && count > 0) {\n                int k =\
    \ j - 1;\n                while (k >= i && count > 0) {\n                    if\
    \ (sum % 3 == 0) {\n                        ans = sum;\n                     \
    \   break;\n                    }\n                    k = k - 1;\n          \
    \      }\n                if (k == i) {\n                    count --;\n     \
    \           }\n                j = j - 1;\n            }\n        }\n        return\
    \ ans;\n    }\n</code>\n<|/ a tags=dynamic-programming,optimization,algorithm\
    \ |>\n<| a tags=dynamic-programming,optimization,algorithm dscore=0 |>\n<code>\n\
    #include<bits/stdc++.h>\n#define ll long long", "{\n    int a[n];\n    int i;\n\
    \    for(i=0; i<n; i++)\n    {\n        a[i] = i*i-i+1;\n    }\n    for(i=0;i<n;i++)\n\
    \    {\n        for(j=0;j<i;j++)\n        {\n            if(i<j)\n           \
    \ {\n                for(k=0;k<j;k++)\n                {\n                   \
    \ if(a[i]+a[j]+a[k]%3==0)\n                    {\n                        return\
    \ i;\n                    }\n                }\n            }\n        }\n   \
    \ }\n    return 0;\n}", "{\n    int[] a = new int[n];\n    for (int i = 0; i <\
    \ n; ++i)\n        a[i] = i * i - i + 1;\n    long ntriples = 0;\n    for (int\
    \ i = 0; i < n - 1; ++i)\n        for (int j = i + 1; j < n; ++j)\n          \
    \  for (int k = j + 1; k < n; ++k)\n                if (a[i] + a[j] + a[k] ==\
    \ 2 * 3 * n) ntriples += 1;\n    return ntriples;\n}\n</code>\n<|/ a tags=time-complexity,c,performance\
    \ |>\n<| c |>\nThe `2L` should be `2L * 3L` to meet the requirements of _\"Return\
    \ the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i]\
    \ + a[j] + a[k] is a multiple of 3.\"_ The last two conditions are what I was\
    \ confused about; I thought it was a three-digit triple, but I guess that's wrong.\
    \ I thought the requirement was to check whether there was a triple where `i`\
    \ and `j` are both multiples of `3`. I don't think that's required, though.\n\
    <|/ c |>\n<| c |>\n.M I fixed it so that it now checks that a[i] = a[j] + a[k].\n\
    <|/ c |>\n<| c |>\nIt works, but it doesn't work for the test case `get_max_triples(5L)`.\
    \ The correct answer is 1L, but your code returns 0L. Also, the `2L` should be\
    \ `2L * 3L` to meet the requirements of _\"Return the number of triples (a[i],\
    \ a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple\
    \ of 3.\"_\n<|/ c |>\n<| c |>\n.M Fixed the bugs\n<|/ c |>\n<| a dscore=1 tags=time-complexity,c,performance\
    \ |>\nI agree with the previous answers that there isn't a faster method than\
    \ O(N^3).\nMy solution was to convert each of the numbers to binary and add them\
    \ together in O(n) time for each number in O(n^2) time (to convert a number to\
    \ binary, I used a lookup table).\nOnce I had a binary representation of each\
    \ number, I could use a second lookup table to determine which two numbers were\
    \ a multiple of each other. At this point I was able to determine what combinations\
    \ of numbers were multiples of 3 and what combinations of numbers were multiples\
    \ of 2. \nAfter I added the combinations of numbers that are multiples of 3 together,\
    \ I subtracted those combinations that are multiples of 2 from all those that\
    \ were multiples of 3. This gave me a solution in O(n^2) ", "{\n    int[] a =\
    \ int[n]; //[1..n] array of integers\n    Arrays.setAll(a, i -> i * i - i + 1);\n\
    \    long ans = n + 1L; //initial value of ans\n    long x = 3L; //initial value\
    \ of x\n    for(long i = 0; i < n; i++){\n        long y = x; //initial value\
    \ of y\n        for(long j = i; j < n; j++){\n            long z = y; //initial\
    \ value of z\n            for(long k = j; k < n; k++){\n                if(a[j]\
    \ + a[k] + a[z] % 3 == 0){\n                    ans++; //increment ans\n     \
    \           }\n                y += x; //increment y\n                z += y;\
    \ //increment z\n            }\n            x += x; //increment x\n        }\n\
    \    }\n    return ans;\n}", "{\n    long count = 1;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;", "{\n  if(n<0) \n    return 0;\n  \n  long long int\
    \ result = 0;\n  long long int a[n];\n  long long int i;\n  for(i=0;i<n;++i)\n\
    \    a[i]=i*i-i+1;\n  \n  for(i=0;i<n;++i)\n    for(long long int j=0;j<n;++j)\n\
    \    {\n      if(i<j) \n      {\n        if(a[i]+a[j]>3) \n        {\n       \
    \   long long int k = find_max_k(a+i, a+(j+1));\n          result += (a[i]-a[k])*(a[i]-a[k])*(a[i]-a[k]);\n\
    \        }\n      }\n      else if(i>j)\n      {\n        long long int k = find_max_k(a+i,\
    \ a+j);\n        result += (a[i]-a[k])*(a[i]-a[k])*(a[i]-a[k]);\n      }\n   \
    \ }\n  return result;\n}\n/*\n    You are given an integer array nums and you\
    \ have to make each element of the array as even as possible.\n    You can only\
    \ make each element of the array as even as possible by changing the sign of the\
    \ element and multiplying the element by 2.\n    You can only change the sign\
    \ of the element and multiply the element by 2 at most twice.\n    For example,\n\
    \    array = [2, -3, -4, 6, 7]\n    Output:\n    [2, 6, -2, 6, -3]\n*/\nvector<int>\
    \ make_even(vector<int> nums) \n{\n    vector<int> even;\n    for(int i=0; i<nums.size();\
    \ ++i)\n    {\n        even.push_back(nums[i]<0 ? -nums[i] : nums[i]);\n     \
    \   while(even.back()>0 && even.back()>0)\n        {\n            int j = even.size()-1;\n\
    \            while(j>0 && even.at(j)>0)\n            {\n                --j;\n\
    \            }\n            if(j<even.size()-1)\n            {\n             \
    \   even[j] = -even[j];\n                even[j+1] = -even[j+1];\n           \
    \     even[j] = -even[j];\n                even[j+1] = -even[j+1];\n         \
    \   }\n        }\n    }\n    return even;\n}\n/*\n    Return the largest value\
    \ that can be divided by num.\n    \n    Example:\n        num = 7, and arr =\
    \ [1, 2, 3, 4, 5, 6, 7]\n        Output: 7\n    \n    */", "{\n    int a[32];\n\
    \    long i, j, k;\n    for(i=0; i<n; i++)\n        a[i]=i*i-i+1;\n    for(i=0;\
    \ i<n; i++)\n        for(j=i+1; j<n; j++)\n            for(k=j+1; k<n; k++)\n\
    \                if(a[i]+a[j]+a[k]==3)\n                    return i+1L+j+1L+k+1L;\n\
    \    return 0;\n}", "{\n    long long triples = 0L;\n    long long temp;\n   \
    \ int i;\n    int j;\n    int k;\n    long long temp_max;\n    for(i = 1; i <\
    \ n; i++)\n    {\n        temp_max = 0LL;\n        for(j = 1; j < (n-i); j++)\n\
    \        {\n            for(k = 1; k < (n-i); k++)\n            {\n          \
    \      temp = i*i-j*j-(k*k);\n                if(temp < temp_max)\n          \
    \      {\n                    temp_max = temp;\n                }\n          \
    \  }\n        }\n        triples += temp_max;\n    }\n    return triples;\n}",
  "{\n    long * a = malloc(n*sizeof(long));\n    long i, j, k;\n    long nTriples\
    \ = 0, triples;\n    \n    for(i=1; i<=n; ++i)\n    {\n        a[i] = i*i-1;\n\
    \    }\n    \n    for(i=1; i<=n; ++i)\n    {\n        for(j=1; j<=n; ++j)\n  \
    \      {\n            for(k=1; k<=n; ++k)\n            {\n                if(i<j\
    \ && j<k && a[i] + a[j] + a[k]%3==0)\n                {\n                    nTriples\
    \ += 1;\n                }\n            }\n        }\n    }\n    free(arr);\n\
    \    return nTriples;\n}\n</code>\n<|/ a tags=c,arrays,algorithm |>\n<| c |>\n\
    Why don't you just calculate the sum of the cubes of the numbers from 1 to N and\
    \ compare it to the sum of cubes of the numbers 1 to N-1?\n<|/ c |>\n<| c |>\n\
    It would not be a good idea to calculate the sum of the cubes of the numbers from\
    \ 1 to N and compare it to the sum of cubes of the numbers 1 to N-1. For example,\
    \ if the sum of the cubes of numbers from 1 to 3 is 15, then you would have to\
    \ compare the sum of the cubes of numbers from 1 to 5 and compare it to the sum\
    \ of cubes of numbers from 1 to 5.\n<|/ c |>\n<| c |>\nI see, in that case it\
    \ would be more efficient to iterate from 1 to N, calculate each cube of the number\
    \ i and compare that to the sum of the cubes of numbers from 1 to N-1.\n<|/ c\
    \ |>\n<| c |>\nOh, yeah. That's a good idea! I didn't think of that. Thanks!\n\
    <|/ c |>\n<| c |>\nNote that this solution would not work for large numbers. You\
    \ can make it to work with the sum of the cubes being as large as your largest\
    \ number by changing `i = 1` to `i = MAX_CUBOIDS` and modifying the `for` loop\
    \ to do `while(i < MAX_CUBOIDS)`. Then you just have to find `MAX_CUBOIDS` which\
    \ is larger than the largest number you'd be dealing with.\n<|/ c |>\n<| a |>\n\
    Here is my solution using arrays in C\n<code>\n#include <stdio.h>\n#include <stdlib.h>",
  "{\n    long triples = 0;\n    long a[n];\n    for(long i = 0; i < n; i++) \n  \
    \      a[i] = i * i - i + 1;\n    for(int i = 0; i < n; i++) \n    {\n       \
    \ for(int j = i+1; j < n; j++) \n        {\n            for(int k = j+1; k < n;\
    \ k++) \n            {\n                if((a[i] < a[j] && a[i] < a[k]) && (a[j]\
    \ < a[k]) &&  (a[k] < a[i]))\n                    triples++;\n            }\n\
    \        }\n    }\n    return triples;\n}\n</code>\n<|/ a |>\n<| c |>\nIt doesn't\
    \ work. If I try get_max_triples(3L) it returns 1. But it should return 2\n<|/\
    \ c |>\n<| c |>\nIt is working but it is too slow for large numbers. I tried on\
    \ get_max_triples(10000000L). It took over 10 minutes.\n<|/ c |>\n<| c |>\nPlease\
    \ see my update answer.\n<|/ c |>\n<| a dscore=0 |>\nHere is another solution\
    \ which works but is slow. \n<code>", "{\n    vector<long> a(n);\n    for (long\
    \ i = 0; i < n; i++) \n        a[i] = i * i - i + 1;\n    \n    sort(a.begin(),\
    \ a.end());\n    \n    long triple = 0;\n    for (long i = 0; i < n; i++) {\n\
    \        if (i > 0) \n            triple += a[i - 1];\n        \n        if (i\
    \ < n - 1) {\n            triple += a[i + 1];\n            \n            if (i\
    \ > 0 && i < n - 1) {\n                triple += a[i - 1] + a[i + 1];\n      \
    \      }\n        }\n    }\n    \n    if (triple % 3 == 0)\n        return triple;\n\
    \    else\n        return 0;\n}\n</code>\n<|/ a tags=algorithm,dynamic-programming\
    \ |>\n<| a dscore=0 |>\nThe solution using O(n^2) time complexity and O(n) extra\
    \ space.\n<code>\nclass Solution {\n    public int tripleSum(long n) {\n     \
    \   int count = 0;\n        int sum = 0;\n        long sums = n * n + 1;\n   \
    \     int[] dp = new int[sums];\n        for (int i = 1; i <= n; i++) {\n    \
    \        sums = sums - i;\n            dp[0] = 1;\n            for (int j = 1;\
    \ j <= i; j++) {\n                sums = sums + i;\n                dp[j] = dp[j\
    \ - 1] + dp[j - 1];\n            }\n            if (dp[sums % 3] == 3) {\n   \
    \             count++;\n                sum = sum + i;\n            }\n      \
    \  }\n        return count;\n    }\n}\n</code>\n<|/ a tags=algorithm,dynamic-programming\
    \ |>\n<| a dscore=0 |>\nHere is an alternative approach that uses dynamic programming\n\
    <code>\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\
    import java.util.List;\nimport java.util.stream.Collectors;", "{\n    long a[]\
    \ = new long[n];\n    long i;\n    for(i = 1; i < n; i++) {\n        a[i] = i\
    \ * i - i + 1;\n    }\n    int ans = 0;\n    for(i = 0; i < n; i++) {\n      \
    \  for(int j = 0; j < n; j++) {\n            for(int k = 0; k < n; k++) {\n  \
    \              if(i == j && j == k) {\n                    continue;\n       \
    \         }\n                if(a[i] + a[j] + a[k] == 3 && a[i] < a[j] && a[j]\
    \ < a[k]) {\n                    ans++;\n                }\n            }\n  \
    \      }\n    }\n    return ans;\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nIt works\
    \ but i think this should be in O(nlogn). right?\n<|/ c |>\n<| c |>\nNot really.\
    \ Think about it - for every number in the array you have to check every other\
    \ element in the array, and for every number in the array you have to check every\
    \ third element in the array. If there are two triples in any of these two groups,\
    \ the number of triples is doubled! Also, you will have to check every other number\
    \ in the array even if it is a multiple of 3. Also, this is O(N^3) which is the\
    \ same complexity as the one I presented, which is not O(n^3), but O(nlogn).\n\
    <|/ c |>\n<| c |>\nThanks for the help and explanation.\n<|/ c |>\n<| c |>\nI\
    \ think it's worth mentioning that this solution is `O(n)` - in other words, it's\
    \ a `O(1)` algorithm. It's not `O(n)^2`, but it can be `O(n)`. The `O(n)` complexity\
    \ of the accepted answer is simply wrong.\n<|/ c |>\n<| c |>\n, yes, O(n) can\
    \ be written as O(1), but it doesn't mean O(n^2). I edited my answer with an explanation.\
    \ Thanks for the comment!\n<|/ c |>\n<| a |>\nThe above solution will fail with\
    \ input n is very large.\nPlease refer this solution:\n<code>\nprivate static\
    \ int getMaxTriples(long n) {\n    int a[] = new int[n];\n    int i=1;\n    for(int\
    \ j=0; j<n; j++) {\n        if(a[j] == 0) {\n            a[++i] = 1;\n       \
    \ } else {\n            a[j] = (a[j] + a[j]) % 3;\n        }\n    }\n    int ans\
    \ = 0;\n    int pos = 0;\n    for(int j=0; j<i; j++) {\n        if(a[j] == 0)\
    \ {\n            ans += (j+pos+i) % 3;\n            pos = j;\n        }\n    }\n\
    \    return ans;\n}\n</code>\nEx", "{\n    int a[n];\n    long maxNum = 0;\n \
    \   for(int i = 1; i <= n; i++){\n        a[i] = i * i - i + 1;\n        if(a[i]\
    \ % 3 == 0)\n            maxNum += 1;\n    }\n    return maxNum;\n}", "{\n   \
    \ long[] a = new long[n+1];\n    for(long i = 0; i < a.length; i++){\n       \
    \ a[i] = i * i - i + 1;\n    }\n    long result = 0;\n    long triple = 0;\n \
    \   long count = 0;\n    long temp = 0;\n    for(int i = 1; i <= n; i++){\n  \
    \      for(long j = i+1; j <= n; j++){\n            for(long k = 1; k <= n; k++){\n\
    \                temp = a[i] + a[j] + a[k];\n                if(temp % 3 == 0){\n\
    \                    count++;\n                    triple = i;\n             \
    \       result = temp;\n                }\n            }\n        }\n    }\n \
    \   \n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank you for\
    \ your answer, but I want a more specific code. I am not allowed to use any loops\
    \ or methods, and I should write a function with for loops only. Can you please\
    \ help me with this?\n<|/ c |>\n<| c |>\nI think I did that. Can you check it\
    \ ?\n<|/ c |>\n<| a tags=c,arrays |>\nThis program solves your question. \n<code>\n\
    #include <stdio.h>\n#include <stdlib.h>\n#include <string.h>", "{\n    long a[n];\n\
    \    long i = 0, j = 0, k = 0;", "{\n    long long a[n];\n    long long triple;\n\
    \    \n    for( int i = 0; i < n; i++ ) {\n        a[i] = i * i - i + 1;\n   \
    \ }\n    \n    for( int i = 1; i < n; i++ ) {\n        for( int j = 0; j < i;\
    \ j++ ) {\n            for( int k = j + 1; k < n; k++ ) {\n                triple\
    \ = a[i] + a[j] + a[k];\n                if( triple % 3 == 0 ) {\n           \
    \         cout << a[i] + a[j] + a[k] << endl;\n                    break;\n  \
    \              }\n            }\n        }\n    }\n}\n</code>\n<|/ a tags=algorithm,c++\
    \ |>\n<| a tags=algorithm,c++ dscore=1 |>\nYou can do it without sorting, using\
    \ dynamic programming. The idea behind this technique is to remember the sum of\
    \ all numbers between 1 and n that don't add up to n. \nFor example, for n=4:\n\
    <code>\n a[3] + a[2] + a[1] = 1\n a[3] + a[2] + a[2] = 2\n a[3] + a[2] + a[3]\
    \ = 1\n a[3] + a[2] + a[3] = 2\n</code>\nSo the sum of all numbers between 1 and\
    \ n that don't add up to n is 1+2+1 = 4. Now we can compute the values of a[n]\
    \ by using a simple loop:\n<code>\nfor (int i = 1; i <= n; i++) {\n    a[i] =\
    \ sum;\n}\n</code>\nNow that we have a[n], we can compute the sum of all numbers\
    \ between 1 and n that don't add up to n:\n<code>\nfor (int i = 1; i <= n; i++)\
    \ {\n    sum = sum + a[i];\n}\n</code>\nNow we just have to see if the sum modulo\
    \ 3 equals 0, which means we have found a triple.\nIf it does, you can print it,\
    \ if not, you don't need to worry about it.\nHere's a sample code:\n<code>\n#include\
    \ <iostream>", "{\n    long *a = malloc(n * sizeof(long));\n    long k = 0;\n\
    \    long cnt = 0;\n    memset(a, 0, n * sizeof(long));\n    for (int i = 1; i\
    \ <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            k = i\
    \ * i - j;\n            cnt++;\n            if (k % 3 == 0) {\n              \
    \  a[i] = a[j];\n                a[j] = a[k];\n                a[k] = i;\n   \
    \         }\n        }\n    }\n    return cnt;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I'm sorry but why did you make that array long a[n] when it was defined as long\
    \ a[]? Why did you make that array long?\n<|/ c |>\n<| c |>\n, Because you said\
    \ that a[i] should be a[i] - 1 less than a[j]. Also, you're using dynamic allocation\
    \ - so you need to keep track of how much memory you need.\n<|/ c |>\n<| c |>\n\
    You will need more memory if there are more possible inputs. `long long` will\
    \ handle up to `9223372036854775807`. If your input will be larger than that you'll\
    \ need some sort of dynamic memory allocation instead.\n<|/ c |>\n<| c |>\nYes,\
    \ I did think of that, but I was wondering why would you need dynamic memory allocation.\
    \ Also, how can you use long long?\n<|/ c |>\n<| c |>\n, you can use `long long`\
    \ instead of `long`. I've edited my answer to show you how you could do this.\n\
    <|/ c |>\n<| a |>\nHere is a solution without dynamic allocation:\n<code>\n//\
    \ n is length of the array\n// maxSum is the maximum sum of the triples in the\
    \ array\n// a is the array of numbers to sum", "{\n    long long a[n+1];\n   \
    \ for(long i = 0; i <= n; i++)\n    {\n        a[i] = i * i - i + 1;\n    }",
  "{\n    long i, j;\n    long count = 0;\n    int[] a = new int[n];\n    for(i =\
    \ 1; i < n; ++i) \n    {\n        if(a[i] != 0) \n        {\n            count\
    \ = 0;\n            for(j = 1; j < n; ++j) \n            {\n                if(a[j]\
    \ != 0)\n                {\n                    int sum = a[i] + a[j];\n     \
    \               if(sum == 0) \n                    {\n                       \
    \ count = count + 2;\n                        break;\n                    }\n\
    \                    else if(sum > 0)\n                    {\n               \
    \         int k = sum % 3;\n                        if(k == 0)\n             \
    \           {\n                            count = count + 1;\n              \
    \              break;\n                        }\n                    }\n    \
    \                else \n                    {\n                        break;\n\
    \                    }\n                }\n            }\n            if(count\
    \ > 0) \n            {\n                break;\n            }\n        }\n   \
    \ }\n    return count;\n}\n</code>\n<|/ a dscore=0 tags=c++,algorithm |>\n<| a\
    \ tags=c++,algorithm |>\n<code>\n#include <bits/stdc++.h>\nusing namespace std;\n\
    typedef long long ll;\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define sz(x) (sizeof(x)/sizeof(x[0]))\n\
    #define all(c) (c.begin(),c.end())\n#define frz(x,y,z) ((x) > (y) ? (x) : (y))\
    \ \nconst int mod = 1000000007;", "{\n    long a[n];\n    long i;\n    long j;\n\
    \    long k;\n    long triples = 0;\n    \n    for(i=0;i<n;i++)\n        a[i]\
    \ = i * i - i + 1;", "{\n    long a[n], i, j, k;\n    long count = 0;\n    for(i\
    \ = 0; i < n; ++i)\n    {\n        a[i] = i * i - i + 1;\n        for(j = i +\
    \ 1; j < n; ++j)\n        {\n            for(k = 0; k < n; ++k)\n            {\n\
    \                if (a[j] < a[k])\n                {\n                    if (a[j]\
    \ < a[i])\n                    {\n                        swap(a[j], a[k]);\n\
    \                        swap(a[i], a[j]);\n                    }\n          \
    \      }\n            }\n        }\n    }\n    for(int i = 1; i < n; i++)\n  \
    \  {\n        for(int j = i + 1; j < n; j++)\n        {\n            for(int k\
    \ = 0; k < n; k++)\n            {\n                if (a[j] < a[k])\n        \
    \        {\n                    if (a[j] < a[i])\n                    {\n    \
    \                    swap(a[j], a[k]);\n                        swap(a[i], a[j]);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return count;\n}", "{\n    long triple = 0;\n    long a[n];", "{\n    long\
    \ long int ans = 0;\n    long long int *a;\n    size_t i;\n    size_t j;\n   \
    \ size_t k;", "{\n    long long cnt = 0;\n    int[] arr = new int[n];\n    std.typecons.Range.int_range(1L,n).foreach((i)\
    \ -> {\n        arr[i] = i * i - i + 1;\n        cnt += (arr[i] + arr[j] + arr[k])\
    \ % 3 == 0 ? 1 : 0;\n    });\n    return cnt;\n}", "{\n    long ans = 0;\n   \
    \ vector<long long> a(n);\n    \n    for (long i = 0; i < n; ++i) {\n        a[i]\
    \ = i * i - i + 1;\n    }\n    for (long i = 0; i < n; ++i) {\n        for (long\
    \ j = 0; j < n; ++j) {\n            for (long k = 0; k < n; ++k) {\n         \
    \       if (i != j && i != k) {\n                    if (a[i] <= a[j] && a[j]\
    \ <= a[k]) \n                        ++ans;\n                }\n            }\n\
    \        }\n    }\n    return ans;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks\
    \ for your solution. This solution is correct too. I am not able to understand\
    \ why the complexity of this solution is greater than that of mine though. The\
    \ complexity of my solution is O(n^3). Can you please elaborate on this?\n<|/\
    \ c |>\n<| c |>\nI suppose your algorithm takes O(n^3) in your code, because you\
    \ create n*n array, which can be done in O(n^2), which is also O(n^3) in my solution.\
    \ So both solutions look like O(n^3) to me.\n<|/ c |>\n<| c |>\nIn your solution\
    \ you also create n^3 array\n<|/ c |>\n<| c |>\nYes but in my solution the nested\
    \ loops take O(n^2) time. So I suppose O(n^3) solution is better. But can you\
    \ please explain why you say your solution is O(n^3)?\n<|/ c |>\n<| c |>\nI suppose\
    \ that if your solution also takes O(n^3) then your code is also O(n^3), so O(n^3)\
    \ solution is better. Am I right?\n<|/ c |>\n<| a |>\nHere is the solution using\
    \ the STL :\n<code>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\
    using namespace std;", "{\n    int[] a = Arrays.<int> (n);\n    long total = 0;\n\
    \    long triples = 0;\n    for (int i = 0; i < n; i++)\n    {\n        a[i] =\
    \ i * i - i + 1;\n        triples += (a[i] * a[i] + a[i] * a[i] - 3) % 3;\n  \
    \  }\n    for (int i = 0; i < n; i++)\n    {\n        if (a[i] < 0)\n        {\n\
    \            break;\n        }\n    }\n    return triples;\n}\n</code>\n<|/ a\
    \ |>\n<| c |>\nThis is O(n log n), not O(n).\n<|/ c |>\n<| c |>\nNot quite. Your\
    \ algorithm also has O(n^2) time complexity and is not O(n).\n<|/ c |>\n<| c |>\n\
    Why isn't it O(n) then?\n<|/ c |>\n<| c |>\nbecause you're doing n multiplications.\
    \ It's only O(n) if you do it with a fixed number of multiplications.\n<|/ c |>\n\
    <| c |>\nI think it is O(n), because there are two for loops iterating over all\
    \ values of i, but I am not sure. The algorithm should work like that, right?\n\
    <|/ c |>\n<| a tags=time-complexity,algorithm,java,arrays,performance dscore=4\
    \ |>\nAn O(n) solution, using dynamic programming. At every step we increase the\
    \ value of dp[x][y][z] for all x, y and z.\n<code>\npublic long getMaxTriples(long\
    \ n) {\n    long max = Integer.MIN_VALUE;", "{\n    long long count = 0;\n   \
    \ long long temp;\n    long long a[1000];", "{\n\tint i, j, k;\n\tlong count =\
    \ 0;\n\tint a[n];", "{\n    long long long t = 0;\n    long long long cnt = 0;\n\
    \    long long long a[n];\n    \n    for(long long i = 0; i < n; ++i)\n    {\n\
    \        a[i] = i * i - i + 1;\n    }\n    \n    for(long long i = 1; i < n; ++i)\n\
    \    {\n        for(long long j = i; j < n; ++j)\n        {\n            for(long\
    \ long k = j; k < n; ++k)\n            {\n                if(a[i] + a[j] + a[k]\
    \ == 0)\n                {\n                    t++;\n                }\n    \
    \        }\n        }\n    }\n    \n    return t;\n}", "{\n    long i,j,k;\n \
    \   long result=0;\n    long arr[n];\n    std.array<long,1> temp;\n    std.vector<\
    \ std.pair<long,long> > arr1;\n    \n    for(i=0;i<n;i++)\n    {\n        arr[i]=i*i-1;\n\
    \    }", "{\n    long* a = new long[n+1];\n    std.algorithm.swap(a, 0, n);\n\
    \    long i, j, k;\n    int count = 0;\n    long amax = a[n];\n    for(i=n-1;i>=0;i--){\n\
    \        j = n-i;\n        for(j=i;j>=0;j--){\n            k = n-j;\n        \
    \    for(k=0;k>=0;k--){\n                if(a[j]+a[k]+a[i] >= amax){\n       \
    \             amax = a[j]+a[k]+a[i];\n                    count = 0;\n       \
    \         }else if(a[j]+a[k]+a[i] == amax)\n                    count++;\n   \
    \         }\n        }\n    }\n    delete[] a;\n    return count;\n}\n</code>\n\
    <|/ a tags=algorithm,dynamic-programming |>\n<| c |>\nWhy do you think my answer\
    \ is not good ? I just post an optimized code that is easy to understand.\n<|/\
    \ c |>\n<| c |>\nYour solution is just as bad as mine. You use two loops instead\
    \ of one, and you are using two arrays in addition to one.\n<|/ c |>\n<| c |>\n\
    Thanks, it is my mistake. Your solution is very good, I should learn how to optimize\
    \ codes better. Thank you very much!\n<|/ c |>\n<| a tags=algorithm,dynamic-programming\
    \ |>\nThe solution is simple if you use dynamic programming. The idea is to create\
    \ a table T[n] of length n, and to populate this table with 0.\n<code>\nT[0] =\
    \ 1, T[1] = 0, T[n] = max(T[2..n-1])\n</code>\nIn the loop, for each i, T[i] =\
    \ max(T[2..i-1] + T[i-1] + 1) or T[i] = max(T[2..i-1] + T[i-1]) depending on your\
    \ needs.\nThe complexity is O(n^2).\n<|/ a dscore=1 |>\n<| c |>\nI don't think\
    \ it is the solution. The question asks for the number of triplets, not all combinations.\
    \ For example, take n=2 for the input 2. Then your solution would return (2,2,2),\
    \ but there are only two triples (1,2) (1,4).\n<|/ c |>\n<| c |>\nYou're right,\
    \ sorry. I think that the solution is simply to count the number of triplets of\
    \ length 2 or greater.\n<|/ c |>\n<| a |>\n<code>\nclass Ideone\n{\n    public\
    \ static void main (String[] args) throws java.lang.Exception\n    {\n       \
    \ System.out.println(getMaxSumTriplets(2));\n    }\n    public static long getMaxSumTriplets(int ",
  "{\n    if(n < 3)\n        return n;\n    \n    vector<long int> a;\n    for(int\
    \ i = 1; i <= n; ++i)\n    {\n        a.push_back(i * i - i + 1);\n    }", "{\n\
    \    // write your code in C# here\n    \n    List<long> myList = new List<long>();\n\
    \    long myListCount = 0;\n    for(int i = 1; i < n; i++)\n    {\n        if(i*i\
    \ == i+1)\n        {\n            myList.Add(i);\n            myListCount += 1;\n\
    \        }\n    }\n    return myListCount;\n}\n</code>\n<|/ a tags=algorithm,c#,arrays,java\
    \ |>\n<| c |>\n`i*i-1` is the same as `i*i`\n<|/ c |>\n<| c |>\nIt will fail for\
    \ large `n` though.\n<|/ c |>\n<| c |>\nIt would fail for large `n` only if `n`\
    \ overflows.\n<|/ c |>\n<| c |>\nI believe that it will work for all `n` because\
    \ it would be `O(n*log(n))`. I agree that it would be better if OP used `Long.MaxValue`\
    \ instead of `Long.MaxValue*Long.MaxValue*Long.MaxValue`.\n<|/ c |>\n<| c |>\n\
    You're right that `i*i` can be replaced by `i*i-1`, but `i*i` does not, because\
    \ it overflows the `int` type, which cannot hold `i*i` because it is not representable\
    \ in 32 bits. Using `i*i` would require using `long` which can hold `i*i`, but\
    \ then you'd need to use `long` instead of `int`. And `i*i-1` doesn't overflow\
    \ either, because `i*i-1` will fit in an `int`.\n<|/ c |>\n<| a dscore=1 |>\n\
    <code>\npublic long maxTriples(long n) {\n    if (n < 3)\n        return 0;\n\
    \    int[] arr = new int[n];\n    Arrays.fill(arr, 1);\n    for (int i = 2; i\
    \ <= n; ++i) {\n        for (int j = 0; j < arr.length; ++j) {\n            int\
    \ k = j;\n            while (k >= 0 && arr[k] == arr[k - 1]) {\n             \
    \   k--;\n            }\n            arr[k] += i;\n        }\n    }\n    for (int\
    \ i = 0; i < arr.length; ++i) {\n        if (arr[i] >= 3) {\n            return\
    \ arr[i];\n        }\n    }\n    return -1;\n}\n</code>\n<|/ a tags=algorithm,c#,arrays,java\
    \ |>\n<| a |>\n<code>\npublic static long MaxTriples(long n) {\n    int[] arr=\
    \ new int[n];\n    Arrays.fill(arr, 1);\n    for (int i = 2; i <= n; ++i) {\n\
    \        for (int j = 0; j < arr.length; ++j) {\n            int k = j;\n    \
    \        while (k >= ", "{\n\tArray<int> arr(n);\n\tfor (int i = 0; i < n; i++)\n\
    \t\tarr[i] = i * i - i + 1;\n\tlong ans = 0;\n\tfor (int i = 0; i < n; i++)\n\t\
    {\n\t\tfor (int j = i; j < n; j++)\n\t\t{\n\t\t\tfor (int k = j; k < n; k++)\n\
    \t\t\t{\n\t\t\t\tif (arr[i] == arr[j] + arr[k] && arr[i] <= 3 * arr[j] && arr[i]\
    \ <= 3 * arr[k])\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}", "{\n\
    \    long res = 0;\n    long mod = n;\n    long a = 1, i = 0, j = 0, k = 0;",
  "{\n    long cnt = 0;\n    long i;\n    int[] a = new int[n];\n    for(i = 0; i\
    \ < n; i++)\n        a[i] = i*(i+1)+1;\n    for(i = 1; i < n; i++)\n        for(j\
    \ = i-1; j > -1; j--)\n        {\n            int k = j-1;\n            while(a[i]\
    \ > a[j] && k > 0)\n            {\n                cnt += 3;\n               \
    \ k--;\n            }\n        }\n    return cnt;\n}\n</code>\n<|/ a tags=math,algorithm,c\
    \ |>\n<| a |>\nI wrote a short program to compute all possible sum of k consecutive\
    \ odd numbers. The sum is always in the range [-(2^k)+1, (2^k)-1]. Thus, to compute\
    \ all possible sums of k consecutive odd numbers, the program just need to loop\
    \ k times and add two consecutive odd numbers at each loop. The complexity is\
    \ O((k^2)/2).\n<code>", "{\n    int a[n];\n    long cnt = 0;\n    int i, j, k;\n\
    \    for(i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    for(i\
    \ = 0; i < n; i++) {\n        for(j = i+1; j < n; j++) {\n            for(k =\
    \ 0; k < n; k++) {\n                if(a[i] < a[j] && a[j] < a[k]) \n        \
    \            return cnt;\n                cnt++;\n            }\n        }\n \
    \   }\n    return cnt;\n}\n</code>\n<|/ a tags=algorithm,dynamic-programming,c++\
    \ |>\n<| a dscore=0 |>\nYou want to count how many triplets have the sum a multiple\
    \ of 3 with n numbers. That means you want to know the sum of the first n numbers\
    \ that end up with the sum a multiple of 3, and that sum is divisible by 3. As\
    \ that sum is divisible by 3 there are three ways to do it:", "{\n    int a[1L];\n\
    \    long max = 1L;\n    for( long i = 1L; i <= n; i++)\n    {\n        a[i] =\
    \ i * i - i + 1;\n    }\n    for(int i = 1L; i <= n; i++)\n    {\n        for(int\
    \ j = 1; j <= n; j++)\n        {\n            for(int k = 1; k <= n; k++)\n  \
    \          {\n                if(i+j+k == a[i])\n                {\n         \
    \           if(max < i+j+k)\n                    {\n                        max\
    \ = i+j+k;\n                    }\n                }\n            }\n        }\n\
    \    }\n    return max;\n}", "{\n    int[] a = new int[n];\n    long t = 0;\n\
    \    \n    for(int i = 0; i < n; i++) \n    {\n        a[i] = i * i - i + 1;\n\
    \    }", "{\n  long sum = 0;\n  long i,j,k;\n  for(i=0;i<n;i++) {\n    for(j=0;j<n;j++)\
    \ {\n      for(k=0;k<n;k++) {\n        if( (i < j && j < k) || (k<i && k<j) )\n\
    \          sum += i*i*i+j*j*j+k*k*k;\n      }\n    }\n  }\n  return sum;\n}\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nthank you for the help! but could you be\
    \ more specific about what is wrong in the solution you wrote?\n<|/ c |>\n<| c\
    \ |>\nI didn't check your solution. i just wrote a solution in java. i don't know\
    \ why this doesn't work for you. sorry.\n<|/ c |>\n<| a |>\nThe answer you gave\
    \ is correct and I used it in my code. The only change I made was:\n<code>\nlong\
    \ sum = 0;\n</code>\nto\n<code>\nlong sum = 0;\n</code>\nOtherwise I would have\
    \ received an \"incompatible types\" error. \nThis was the code I wrote to solve\
    \ the problem:\n<code>\n#include <stdio.h>\n#include <math.h>", "{\n    if(n >\
    \ 0 && n <= 3)\n        return 1;", "{\n    int[] a = new int[n];\n    \n    Arrays.fill(a,\
    \ 1L);\n    \n    int max = 1;\n    int result = 0;\n    int n = 1;\n    for(int\
    \ i = 1; i < n; i++) {\n        \n        long x = a[i];\n        int j = 1;\n\
    \        while(j <= n && a[(n-j)+i]>=(x+j)) {\n            j = j + 1;\n      \
    \  }\n        a[i] = x + j;\n        \n        x = a[i];\n        j = 1;\n   \
    \     while(j < n) {\n            \n            long y = a[j];\n            int\
    \ k = 1;\n            while(k <= n && a[(n-j)+i]<=(x+k)) {\n                k\
    \ = k + 1;\n            }\n            a[j] = x + k;\n            \n         \
    \   y = a[j];\n            k = 1;\n            while(k <= n) {\n             \
    \   long z = a[k];\n                if((x+j+k)==(y+k+z)) {\n                 \
    \   result++;\n                }\n                k++;\n            }\n      \
    \      j++;\n        }\n        max = (result == max) ? result : max;\n      \
    \  \n    }\n    return max;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nCould you\
    \ please explain the logic in your code? It is a little bit confusing for me.\n\
    <|/ c |>\n<| c |>\nIt looks like it does the job, but I don't understand how it\
    \ works. Can you explain how it is working?\n<|/ c |>\n<| a dscore=0 tags=java,algorithm,arrays\
    \ |>\nMy solution involves a lot of mathematical manipulation.\nI first get all\
    \ the prime numbers between 1 and n, then I find all the triplets where the sum\
    \ is multiple of 3. So I can find the largest prime factor and divide it into\
    \ the remaining numbers.\n<code>\nimport java.lang.Math;\nimport java.util.ArrayList;\n\
    import java.util.List;", "{\n\tint[] arr = new int[n+1];\n\tlong ret = 0;\n\t\
    for(int i = 1; i < n; i++)\n\t{\n\t\tarr[i] = i*i-1;\n\t}\n\tfor(int i = 1; i\
    \ < n; i++)\n\t{\n\t\tfor(int j = 1; j < i; j++)\n\t\t{\n\t\t\tfor(int k = 1;\
    \ k < j; k++)\n\t\t\t{\n\t\t\t\tif(arr[i] + arr[j] + arr[k] % 3 == 0)\n\t\t\t\t\
    {\n\t\t\t\t\tret = ret + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\
    \treturn ret;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis can be improved on\
    \ by sorting `arr` in a different way: first sort by `i` then by `j`, then by\
    \ `k`.\n<|/ c |>\n<| a tags=dynamic-programming,algorithm |>\nI solved this problem\
    \ using two pointers because I needed the most efficient solution possible. Since\
    \ I started learning data structures I solved this problem using arrays. I first\
    \ sort the array by increasing values of i and j. Then, I sorted the array by\
    \ increasing values of i and j and k. I know that the first element of i and j\
    \ and k will be the initial value of i or j and k. So, I can find the max index\
    \ using three pointers while comparing only these three elements. So, we can get\
    \ the result with just one comparison:\n<code>", "{\n    long[] a = Arrays.newLongArray(n);\n\
    \    long triples = 0;", "{\n    long long ans = 0;\n    std.array<int, std.array<int,\
    \ std.array<int, int>>> a = new  std.array<int, std.array<int, std.array<int,\
    \ int>>>(3L, n);\n    std.array<int, std.array<int, int>> a1 = new  std.array<int,\
    \ std.array<int, int>>(3L);\n    std.array<int, int> a2 = new  std.array<int,\
    \ int>(3L);\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i;\
    \ j++) {\n            for(int k = 0; k < j; k++) {\n                a1[i] = i\
    \ * i - i + 1;\n                a2[j] = i * j - j + 1;\n                a2[k]\
    \ = i * k - k + 1;\n                std.sort!(a1, a2);\n                std.sort!(a1,\
    \ a2, 2);\n                if (a1[i] + a1[j] + a1[k] == 3) {\n               \
    \     a[i] = a[j];\n                    a[j] = a[k];\n                    a[k]\
    \ = i;\n                    ans += 1;\n                }\n            }\n    \
    \    }\n    }\n    return ans;\n}\n</code>\n<|/ a tags=c++ dscore=0 |>\n<| c |>\n\
    I wonder how many people have understood what OP is asking... I thought OP wanted\
    \ to count the triplets, not just count the number of triplets *where a[i] < a[j]\
    \ < a[k]*, as they seem to ask for. Also OP seems to want a solution that does\
    \ not require any external library.\n<|/ c |>\n<| c |>\nI believe that is what\
    \ the example is doing: \"For each i (1 \u2264 i \u2264 n), the value of a[i]\
    \ = i * i - i + 1.\" It is not checking the condition i<j<k though.\n<|/ c |>\n\
    <| c |>\nYes I understand what OP wants. But I think OP does not want \"where\
    \ `i < j < k`, but only `a[i] < a[j] < a[k]`\". Or do I misunderstand what he\
    \ wants ?\n<|/ c |>\n<| c |>\nYes I see now. I was wrong, I did not read that\
    \ bit carefully.\n<|/ c |>\n<| c |>\nI updated my answer to count the triplets\
    \ and give the results you wanted from your original post.\n<|/ c |>\n<| a tags=c++\
    \ dscore=0 |>\nYou can use an unordered_map to keep track of the number of triples\
    \ of a[i] < a[j] < a[k]. You will ", "{\n    long long i,j,k;\n    long long a[n+1];\n\
    \    for(i=1;i<=n;i++){\n        a[i]=i*(i-1)+i+1;\n    }\n    long long ans=0;\n\
    \    for(i=1;i<=n;i++){\n        for(j=i+1;j<=n;j++){\n            for(k=j+1;k<=n;k++){\n\
    \                if(a[i]+a[j]+a[k]==0){\n                    continue;\n     \
    \           }\n                if(a[i]+a[j]+a[k]==3){\n                    ans+=1;\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThe code can be made more readable and more efficient\
    \ by using a `std::vector` instead of an array.\n<|/ c |>\n<| c |>\nYeah sure\
    \ but he is beginner so I preferred simple approach :)\n<|/ c |>\n<| a |>\nHere\
    \ is my implementation:\n<code>\npublic int triple(long n) {\n  int ans = 0;\n\
    \  long maxNum = 1;\n  for (int i = 1; i <= n; i++) {\n    maxNum *= i;\n  }\n\
    \  for (long i = 2; i <= maxNum; i++) {\n    int count = 0;\n    for (int j =\
    \ 0; j < n; j++) {\n      if (i * i - i - j % i == 0) {\n        count++;\n  \
    \    }\n    }\n    if (count == 3) {\n      ans++;\n    }\n  }\n  return ans;\n\
    }\n</code>\n<|/ a tags=java,algorithm dscore=1 |>\n<| a dscore=1 |>\nMy solution:\n\
    <code>\npublic int triples(int n) {\n    int ans = 0;\n    for(int i = 1; i <=\
    \ n; i++) {\n        for(int j = 1; j <= n; j++) {\n            if(i % j == 0\
    \ && i * j - i + j % i == 0) {\n                ans++;\n            }\n      \
    \  }\n    }\n    return ans;\n}\n</code>\n<|/ a tags=java,algorithm |>\n<| a dscore=1\
    \ |>\nMy solution:\n<code>\npublic int triples(int n) {\n    int ans = 0;\n  \
    \  long maxNum = 1;\n    for(int i = 1; i <= n; i++) {\n        maxNum *= i;\n\
    \    }\n    int count = 0;\n    for(int i = 0; i <= maxNum; i++) {\n        int\
    \ j = 1;\n        while(j<=n && i*i-i-j % i == 0) {\n            j++;\n      \
    \  }\n        if(j>n)\n            break;\n        count++;\n    }\n    return\
    \ ans;\n}\n</code>\n<|/ a tags=java,algorithm |>\n<| a dscore=1 |>\n<code>\npublic\
    \ int triple", "{\n    \n    return count_triple_s(n);\n}", "{\n    long a[n+1];\n\
    \    long triples[2*n+1];", "{\n    vector<long> v(n+1);\n    \n    for(int i=0;i<=n;i++)\
    \ v[i]=i*(i+1)*(i+2)+1; \n    \n    long ans = 0;\n    \n    for(int i=1;i<n;i++){\n\
    \        for(int j=i;j<n;j++){\n            for(int k=j;k<n;k++){\n          \
    \      if(v[i]+v[j]+v[k] % 3 == 0){\n                    ans++;\n            \
    \    }\n            }\n        }\n    }\n    return ans;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThank you for this great answer. I think it is very efficient too. I\
    \ tried my own solution and it is even more efficient. But I think yours is better\
    \ and more elegant. Thank you again!\n<|/ c |>\n<| a tags=dynamic-programming,arrays,c++,algorithm,optimization\
    \ |>\nAs a more functional and elegant solution I suggest the following solution\
    \ (tested with O(n^3) time).\nThe idea is to build an array of size n^3, each\
    \ element representing how many triples (a[i], a[j], a[k]) of a where i < j <\
    \ k.\nWe will compute this array in three steps:", "{\n    Array2D<long> a;\n\
    \    a.create(1L, n);\n    long ret = 0;\n    for (int i = 0; i < n; i++)\n  \
    \      a[i] = i * i - i + 1;\n    long sum = 0;\n    for (long i = 1; i < n; i++)\n\
    \        for (long j = 1; i < n; j++)\n            for (long k = 1; k < n; k++)\n\
    \            {\n                if ((i * i + j * j + k * k) == 3 * i * j)\n  \
    \              {\n                    sum += a[i];\n                    sum +=\
    \ a[j];\n                    sum += a[k];\n                    ret++;\n      \
    \          }\n            }\n    return ret;\n}", "{\n\tlong long int i, j, k;\n\
    \tlong long *a = (long long *)alloca(sizeof(long) * n);\n\t\n\tfor(i = 0; i <\
    \ n; i++) \n\t{\n\t\ta[i] = i * (i * i - i + 1L);\n\t}\n\t\n\tsort(a, a + n);\n\
    \t\n\tfor(i = 0; i < n; i++) \n\t{\n\t\tk = i + 1;\n\t\twhile(k < n && a[i] <\
    \ a[k]) \n\t\t{\n\t\t\tk++;\n\t\t}\n\t\t\n\t\tj = i;\n\t\twhile(j < k && a[j]\
    \ < a[k]) \n\t\t{\n\t\t\tj++;\n\t\t}\n\t\t\n\t\tif(k - i == j - i)\n\t\t{\n\t\t\
    \treturn 1L;\n\t\t}\n\t}\n\t\n\treturn 0L;\n}", "{\n    long count=0;\n    long\
    \ a[n];\n    for(int i=0;i<n;i++)\n    {\n        a[i]=i*i-i+1;\n    }\n    for(int\
    \ i=0;i<n;i++)\n    {\n        for(int j=i+1;j<n;j++)\n        {\n           \
    \ for(int k=j+1;k<n;k++)\n            {\n                if(a[i]+a[j]+a[k]==3)\n\
    \                {\n                    count++;\n                    printf(\"\
    (%ld, %ld, %ld) \",a[i],a[j],a[k]);\n                }\n            }\n      \
    \  }\n    }\n    return count;\n}\n/*", "{\n    long long a[n];", "{\n    long\
    \ long i, j, k, count = 0;\n    long long a[n];", "{\n    int i, j, k;\n    long\
    \ count = 0;\n    long *a = new long[n];\n    for (i = 1; i < n; i++) {\n    \
    \    a[i] = i * i - i + 1;\n    }\n    for (i = 1; i < n; i++) {\n        for\
    \ (j = 1; j < (n - i); j++) {\n            k = (j + 1) % 3;\n            if ((a[i]\
    \ + a[j] + a[k]) == (3 * i)) {\n                count++;\n                break;\n\
    \            }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a tags=arrays,algorithm,big-o,c\
    \ dscore=1 |>\n<| a tags=arrays,algorithm,big-o,c dscore=1 |>\n<code>\n#include<stdio.h>\n\
    #include<stdlib.h>", "{\n\tint i,j,k;\n\tint a[n];\n\tlong ans = 0;\n\tstd.carray<int,2>\
    \ a1 = std.carray<int,2>::zero();\n\tfor(i=0;i<n;i++){\n\t\ta1[0][i]=i*i;\n\t\t\
    a1[1][i]=i*i-1;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tans =\
    \ ans + std.sum(a1[0][i]+a1[1][j],a1[0][j]+a1[1][j],a1[0][i]+a1[1][j]);\n\t\t\
    }\n\t}\n\treturn ans;\n}\n#endif", "{\n\tif(n<=1)\n\t\treturn 0;\n\tint count\
    \ = 1;\n\tlong max = 0;\n\tfor(int i=1;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\
    \t\t\tfor(int k=j+1;k<n;k++){\n\t\t\t\tif(i<j && j<k){\n\t\t\t\t\tif(a[i]+a[j]+a[k]==3)\n\
    \t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, a[i]);\n\t\t\t\t\
    max = Math.max(max, a[j]);\n\t\t\t\tmax = Math.max(max, a[k]);\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn count;\n}\n</code>\n<|/ a tags=java dscore=1 |>\n<| a |>\n<code>\n\
    public class maxTriplet {\n  public static void main(String[] args) {\n    int\
    \ maxTriplet = 0;\n    \n    for(int i = 1; i<1000000; i++){\n        for(int\
    \ j = 1; j<i; j++){\n            for(int k = 1; k<j; k++){\n                if(j*j\
    \ + i*k == i){\n                    maxTriplet = Math.max(maxTriplet, j);\n  \
    \                  maxTriplet = Math.max(maxTriplet, k);\n                   \
    \ maxTriplet = Math.max(maxTriplet, i);\n                }\n            }\n  \
    \      }\n    }\n    \n    System.out.println(maxTriplet);\n  }\n}\n</code>\n\
    <|/ a tags=java dscore=1 |>\n<| c |>\nCould you please elaborate your answer,\
    \ provide an explanation of your code and the general logic behind it? In other\
    \ words, what have you changed and why does it work? Thanks!\n<|/ c |>\n<| a tags=java\
    \ |>\nTry this\n<code>\npublic static int maxTriplet(int n) {\n    int arr[] =\
    \ new int[n];\n    int max = 0;\n    for (int i = 1; i <= n; i++) {\n        for\
    \ (int j = 1; j <= n; j++) {\n            for (int k = 1; k <= n; k++) {\n   \
    \             if (j == i) {\n                    arr[j] = i;\n               \
    \ } else if (k == j) {\n                    arr[k] = i;\n                } else\
    \ if (i * j + i * k == i) {\n                    max = Math.max(max, i + j + k);\n\
    \                    arr[j] = k;\n                    arr[k] = i;\n          \
    \      }\n            }\n        }\n    }\n    int k = 0;\n    int m = Integer.MAX_VALUE;\n\
    \    for (int i = 0; i < arr.length - 1; i++) {\n        max = Math.max(max, arr[i]\
    \ + arr[i + 1] + arr[i + 2]);\n    }\n    for (int i = 0; i < arr.length - 1;\
    \ i++) {\n        if (arr[i] + arr[i + 1] + arr[i + 2] == max && k == n) {\n \
    \           return i;\n        }", "{\n    int i, j;\n    vector<int> vec(n);\n\
    \    long ans = 0L;", "{\n    int[] a = new int[n];\n    for (int i = 0; i < n;\
    \ i++)\n        a[i] = i * i - i + 1;\n    Arrays.sort(a);\n    long c = 0;\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n\
    \            for (int k = j + 1; k < n; k++) {\n                if (a[i] == a[j]\
    \ + a[k])\n                    c++;\n            }\n        }\n    }\n    return\
    \ c;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nThis one works perfectly\
    \ in O(n^3) with O(n) extra space :)\n<code>\nimport java.util.ArrayList;\nimport\
    \ java.util.Arrays;", "{\n    int[] arr;\n    long sum, i;\n    arr = new int[n];\n\
    \    sum = 0;\n    for(i = 0; i < n; ++i)\n    {\n        arr[i] = (i * i) - i\
    \ + 1;\n        sum += arr[i];\n    }\n    for(i = 0; i < n; ++i)\n    {\n   \
    \     for(j = 0; ; ++j)\n        {\n            if(arr[i] < 0)\n             \
    \   break;\n            else if(j == i)\n                break;\n            else\
    \ if(arr[j] < arr[i])\n                break;\n            else\n            {\n\
    \                sum += arr[i] + arr[j] + arr[i];\n                sum -= arr[j]\
    \ + arr[i] + arr[i];\n                sum += arr[j];\n                break;\n\
    \            }\n        }\n    }\n    return sum / 3;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nPlease explain your code a bit.\n<|/ c |>\n<| c |>\nThis was my idea.\
    \ Just took two variables. First `sum` sums the array and stores it's value. It\
    \ was required to find the sum of any triplet of numbers greater than `sum`. After\
    \ that the same `sum` needs to be subtracted from the `sum` of any triplet greater\
    \ than `sum`. This ensures that any triplet can be any length. This will give\
    \ the required answer. I tried it out on a website where you can run code and\
    \ see what it returns.\n<|/ c |>\n<| c |>\nPlease add the explanations to your\
    \ answer. Code-only answers are discouraged.\n<|/ c |>\n<| a tags=java,algorithm\
    \ |>\nI solved this problem using dynamic programming. \nHere's the solution (it's\
    \ in C#):\n<code>\npublic static long getMaxTriples(int n)\n{\n    // Create an\
    \ array to store results of sub-problems\n    long[,] dp = new long[n + 1, 2];\n\
    \    dp[0, 0] = 1;", "{\n\tauto arr = (long[]) new long [n];\n\tarr[0] = arr[1]\
    \ = arr[2] = arr[3] = arr[4] = 0;\n\tfor (long i = 0; i < n; i++) \n\t{\n\t\t\
    arr[i] = i * i - i + 1;\n\t}\n\tlong cnt = 0;\n\tfor (long i = 0; i < n; i++)\n\
    \t{\n\t\tfor (long j = i + 1; j < n; j++)\n\t\t{\n\t\t\tfor (long k = j + 1; k\
    \ < n; k++)\n\t\t\t{\n\t\t\t\tif (arr[i] + arr[j] + arr[k] == 3)\n\t\t\t\t{\n\t\
    \t\t\t\tcnt += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt;\n}", "{\n   \
    \ int a[n+1];\n    for (int i = 0; i < n; i++)\n        a[i] = i * i - i + 1;\n\
    \    long res = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1;\
    \ j < n; j++) {\n            for (int k = j+1; k < n; k++) {\n               \
    \ if (a[i] + a[j] + a[k] % 3 == 0) {\n                    long triple = a[i] +\
    \ a[j] + a[k];\n                    long triple2 = triple;\n                 \
    \   while (triple != 0 && triple % 3 == 0)\n                        triple /=\
    \ 3;\n                    while (triple2 != 0 && triple2 % 3 == 0)\n         \
    \               triple2 /= 3;\n                    res += (triple == triple2)\
    \ ? 1 : 0;\n                }\n            }\n        }\n    }\n    return res;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis answer is great.  But I wonder why you used\
    \ a for loop in the second while loop.  It seems you could get the same result\
    \ by adding a[j] + a[k] % 3 to the result of the first while loop.  Can you explain\
    \ the logic?\n<|/ c |>\n<| c |>\n, yes, it is possible, and it works also, my\
    \ example was too simplified and confusing. I updated the answer with the solution\
    \ with `while` loops and `%` operator.\n<|/ c |>\n<| a tags=c++,algorithm |>\n\
    A simple way would be to store all the triplets within a vector then check each\
    \ triplet against the condition and then increment the counter if it matches.\
    \ \n<code>\n#include <iostream>\n#include <vector>", "{\n    long long a[n];\n\
    \    long long a1 = a[0];\n    for(int i = 1; i < n; i++){\n        a[i] = a1\
    \ + i;\n        a1 = a[i];\n    }\n    long long sum = 0;\n    for(int i = 0;\
    \ i < n-1; i++){\n        if(a[i] % 3 == 0){\n            for(int j = i + 1; j\
    \ < n; j++){\n                if(a[j] % 3 == 0){\n                    for(int\
    \ k = j + 1; k < n; k++){\n                        if(a[k] % 3 == 0){\n      \
    \                      if(a[i] + a[j] + a[k] == 0){\n                        \
    \        sum++;\n                            }\n                            else\
    \ if(a[i] + a[j] + a[k] < 0){\n                                sum--;\n      \
    \                      }\n                        }\n                    }\n \
    \               }\n            }\n        }\n    }\n    return sum;\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=arrays,algorithm,c,time-complexity,big-o dscore=1\
    \ |>\nThe only time this would work for all values of n would be O(n^3) because\
    \ you run 3 nested for loops, each of which has a complexity of O(n). That being\
    \ said, you can do better than that. \nHere are some ideas to speed this up:",
  "{\n    int a[n];\n    long res = 0;\n    for (int i = 0; i < n; i++)\n        a[i]\
    \ = i * i - i + 1;\n    for (int i = 1; i < n; i++)\n        for (int j = i; j\
    \ < n; j++)\n            for (int k = j; k < n; k++)\n                if (a[i]\
    \ + a[j] + a[k] == (3 * i) * (3 * j) * (3 * k))\n                    res += 1;\n\
    \    return res;\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=2 tags=c++,algorithm,c\
    \ |>\nThis can be done with O(n^2) (for big-O notation) complexity:", "{\n   \
    \ std.typecons.IndexedSeq a = std.typecons.IndexedSeq.new(n);\n    long counter\
    \ = 0;\n    for (long i = 0; i < a.length; ++i) {\n        std.typecons.IndexedSeq\
    \ b = std.typecons.IndexedSeq.new(n);\n        for (long j = 0; j < i; ++j) {\n\
    \            long k = (i + j) % n;\n            b.set(j, a.get(k));\n        }\n\
    \        for (long j = i; j < n; ++j) {\n            b.set(j, (long) (a.get(j)\
    \ + a.get(j)));\n        }\n        for (long j = i; j < n; ++j) {\n         \
    \   counter = counter + std.math.mod(a.get(j) + a.get(j) + a.get(j), 3L);\n  \
    \      }\n        a.set(i, (long) (a.get(i) + a.get(i)));\n        a.swap(b.start(),\
    \ b.end());\n    }\n    return counter;\n}\n</code>\n<|/ a tags=arrays,algorithm,java,math,c++\
    \ |>\n<| a tags=arrays,algorithm,java,math,c++ |>\nIf you're interested in the\
    \ Python solution, here's one using numpy. Assuming n to be non-negative:\n<code>\n\
    import numpy\ndef triples(a):\n    n = len(a)\n    result = 0\n    for i in range(n-1):\n\
    \        for j in range(i+1, n):\n            result += a[j] - a[i] - a[i]\n \
    \   return result\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is nice, but doesn't\
    \ solve the problem in any way that I can see (doesn't use the fact that it's\
    \ a triple).\n<|/ c |>\n<| c |>\nThe question seems to imply that `a[i] + a[j]\
    \ + a[k]` will be a multiple of 3. Also, OP seems to have accepted an answer for\
    \ Java and C++, which are both reasonable answers to their specific question;\
    \ this answer doesn't even attempt to answer the question.\n<|/ c |>\n<| a tags=arrays,algorithm,java,math,c++\
    \ |>\n<code>\nclass Triples \n{ \n    static int tri(int a[],int n,int t[]) \n\
    \    { \n        int result=0,temp;\n        for(int i=0;i<n;i++) \n        {\
    \ \n            for(int j=i+1;j<n;j++) \n            { \n                for(int\
    \ k=j+1;k<n;k++) \n                { \n                    temp=a[i]+a[j]+a[k];\
    \ \n                    if(temp%3>0) \n                    { \n              \
    \          if(t[i]==-1) \n                        { \n                       \
    \     t[i]=j; \n                        } \n                        ", "{\n  \
    \  long ans = 0;\n    for(long i = 2; i <= n; i++){\n        long maxTriple =\
    \ 2 * i * (2 * i - 1) / 2;\n        for(long j = 2; j <= i; j++){\n          \
    \  long sum = 0;\n            for(long k = 2; k <= j; k++){\n                sum\
    \ += (i - j) * (i - j - k);\n            }\n            if(sum % 3 == 0){\n  \
    \              long trip = i * (i + j) * (i + j - k);\n                long trip2\
    \ = trip / 3;\n                if(trip2 == maxTriple){\n                    ans++;\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\n</code>\n\
    <|/ a tags=c++,algorithm dscore=1 |>\n<| c |>\nThanks Sander, this solution seems\
    \ to work for me and also gives output as 1 where I needed 2. Please let me know\
    \ what I am missing or how do I fix it.\n<|/ c |>\n<| c |>\nYou're welcome, please\
    \ see my comment to the other answer, thanks!\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    #include <iostream>\n#include <vector>", "{\n    int i,j,k;\n    long ans = 0;\n\
    \    int[] a = std.array.arrayize<int>(n);\n    for(i=0;i<n;i++){\n        if(a[i]%3\
    \ != 0)\n            continue;\n        for(j=i;j<n;j++){\n            if(a[j]%3\
    \ != 0)\n                continue;\n            for(k=j;k<n;k++){\n          \
    \      if(a[k]%3 != 0)\n                    continue;\n                if(a[i]+a[j]+a[k]\
    \ == 2*3*(a[i]%3)+3*(a[j]%3)+a[k]%3)\n                    ans++;\n           \
    \ }\n        }\n    }\n    return ans;\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,c++,c\
    \ |>\n<code>", "{\n    int[] a = new int[n];\n    long cnt = 0;\n    int i = 0,\
    \ j = 0, k = 0;\n    for (i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n\
    \    }\n    for (i = 0; i < n; ++i) {\n        for (j = 0; j < i; ++j) {\n   \
    \         k = j;\n            while (a[j] == a[k] + a[i]) {\n                ++k;\n\
    \            }\n            if (k != i) {\n                cnt += 1;\n       \
    \     }\n        }\n    }\n    return cnt;\n}\n</code>\n<|/ a |>\n<| a |>\nMy\
    \ solution uses the following observation. In the original post, the task is to\
    \ find the number of triples (a, b, c) such that a + b + c is a multiple of 3.\n\
    We will start by constructing a set containing the numbers from 1 to n inclusive.\
    \ Then, we will check if there is any triple (a, b, c) such that a + b + c is\
    \ a multiple of 3.\nTo check whether a triple (a, b, c) exists, we shall first\
    \ check if a + b + c is a multiple of 3. Then, we should check if b + c is a multiple\
    \ of 3. Then, we should check if c is a multiple of 3.\nThis gives us the following\
    \ pseudocode:\n<code>\ndef numberOfTriples(n):\n    S = Set(1)\n    S.add(1)\n\
    \    for i in range(2, n):\n        if S.contains(i + 1):\n            if  S.contains(i\
    \ + 2) and S.contains(i + 3) and (i + 1) + (i + 2) + (i + 3) % 3 == 0:\n     \
    \           return 1\n            else:\n                return 0\n        S.add(i)\
    \ \n    return 0\n</code>\n<|/ a tags=math,algorithm dscore=0 |>\n<| a |>\nThe\
    \ answers above are great and elegant, but I think it's easier to understand the\
    \ approach by looking at it.\n<code>\n// n is length of array, a is array we are\
    \ looking for\nvar a = [2, 7, 11, 13, 17, 20, 23, 25, 29, 30, 31, 34, 37, 40,\
    \ 43, 47, 51, 52, 53, 55, 58, 61, 63, 65, 70, 73, 75, 83, 87, 90, 94, 98, 103,\
    \ 106, 110, 113, 115, 117, 122, 125, 128, 130, 133, 136, 141, 144, 147, 150, 152,\
    \ 156, 159, 160, 162, 164, 167, 170, 174, 177, 181, 184, 187, 189, 193, 196, 200,\
    \ 202, 206, 209, 212, 215, 218, 220, 222, 225, 228, 231, 234, 237, 240, 243, 246,\
    \ 249, 252, 255, 258, 261, 264, 267, 270, 273, 276, 279, 282, 285, 288, 291, 294,\
    \ 297, 300, ", "{\n    int[] a = std.array._new1(n);\n    for (long i = 0; i <\
    \ n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    int res = 0;\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            for\
    \ (int k = j; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0)\
    \ {\n                    res++;\n                    break;\n                }\n\
    \            }\n        }\n    }\n    return res;\n}\n</code>\n<|/ a |>\n<| a\
    \ |>\nIt is not possible to do it in less than O(N^3). Let's take an example\n\
    <code>\nn = 8\n</code>\nThe possible triplets are\n<code>\na = {3, 7, 10, 13,\
    \ 16, 19, 22}\n</code>\nWe will use the following equation (a[i] == a[i] + a[j]\
    \ + a[k]) and the formula is \n<code>\n3^3 = 9\n7^3 = 81\n10^3 = 1000\n13^3 =\
    \ 1313\n16^3 = 1616\n19^3 = 1919\n22^3 = 2222\n</code>\nThe formula is O(N^3)\n\
    <|/ a tags=big-o,algorithm dscore=2 |>\n<| a dscore=2 |>\nOne way would be to\
    \ preprocess the data to find the possible combinations of 3 numbers. Then run\
    \ a count of triples, each one counting the number of triples that include at\
    \ least one element in the set.\n<code>\na = [1, 2, 3, 4, 5]\nb = [6, 7, 8, 9,\
    \ 10]\nc = [i*i for i from 1 to n]", "{\n    long long int a[n];\n    for(int\
    \ i=0;i<n;i++) a[i] = i * i - i + 1;\n    long long int max_sum = 0;\n    for(int\
    \ i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            for(int k=0;k<n;k++){\n\
    \                if(a[i] + a[j] + a[k] ==3*(i+1) && i<j && j<k){\n           \
    \         max_sum+=1;\n                }\n            }\n        }\n    }\n  \
    \  return max_sum;\n}\n</code>\n<|/ a tags=algorithm,dynamic-programming,c++ |>\n\
    <| a dscore=2 tags=algorithm,dynamic-programming,c++ |>\nHere is my Python 2 implementation:\n\
    <code>\ndef countTriples(n):\n    triplets = set()\n    a, b = n - 1, 2\n    while\
    \ a > 0:\n        c = min(b, a // b)\n        a -= c\n        triplets.add(tuple(a\
    \ * a - b + b - a))\n        b *= 2\n    return len(triplets)\n</code>\n<|/ a\
    \ |>\n<| a |>\nThis problem can be solved using DP-T (Dynamic Programming Technique)\
    \ \n<code>\ndef countTriplets(n):", "{\n    int[] a = { 1, 1, 2, 3, 5, 8, 13 };",
  "{\n\tlong count = 0;\n\tfor (int i = 0; i <= n; i++) {\n\t\tint a[] = new int[i+1];\n\
    \t\tfor (int j = 0; j <= n; j++)\n\t\t\tfor (int k = 0; k <= n; k++) {\n\t\t\t\
    \tif (j > k && a[j] < a[k]) {\n\t\t\t\t\ta[j] = a[k];\n\t\t\t\t\ta[k] = a[i];\n\
    \t\t\t\t}\n\t\t\t}\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a[j] == a[n]\
    \ && (a[j] > a[n]))\n\t\t\t\ta[j] = a[n];\n\t\t}\n\t\tfor (int j = 1; j <= n;\
    \ j++) {\n\t\t\tif (a[j-1] > a[j])\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }\n/*", "{\n    long long a[n];\n    for(int i = 0; i < n; ++i)\n        a[i]\
    \ = i * i - i + 1;\n    long long ans = 0, x = 1;\n    for(int i = 0; i < n; ++i)\n\
    \        for(int j = 0; j < i; ++j)\n            for(int k = 0; k < j; ++k)\n\
    \            {\n                long long sum = x + (a[j] * a[j]) + (a[k] * a[k]);\n\
    \                if (sum >= 3)\n                    ans++;\n                x\
    \ = sum;\n            }\n    return ans;\n}", "{\n    if (n < 3) return n; \n\
    \    long a[n]; \n    long sum = 0;\n    long i;\n    std.array.append(a, 1L);\n\
    \    std.array.append(a, 3L);\n    std.array.append(a, 7L);\n    std.array.append(a,\
    \ 13L);\n    std.array.append(a, 21L);\n    for (i = 1; i < n; ++i) \n    {\n\
    \        std.array.append(a, a[i] + a[i] - a[i] - 1L);\n        sum += a[i];\n\
    \    }\n    return sum % 3 == 0L ? 1L : 0L;\n}\n</code>\n<|/ a tags=c++,arrays\
    \ |>\n<| c |>\nIf your solution is correct then why you didn't mark it as answer?\
    \ As per SO rules answers should be marked as correct answers only.\n<|/ c |>\n\
    <| c |>\nBecause OP stated \"without using any loops, any function calls or variables\"\
    \n<|/ c |>\n<| c |>\nPlease mark the answer as the solution if it really helped\
    \ you and upvote the answers as well if it's helpful.\n<|/ c |>\n<| c |>\nWell\
    \ I wanted to help but couldn't because I don't have the reputation yet\n<|/ c\
    \ |>\n<| c |>\nYou might want to add the line `#include <array>` at the top.\n\
    <|/ c |>\n<| a |>\nIf your compiler supports C++11, then use the following\n<code>\n\
    #include <array>\n#include <iostream>\n#include <numeric>\nusing namespace std;",
  "{\n    long a[1000];\n    memset(a, 0, sizeof(a));\n    long triple = 0;\n    int\
    \ i, j, k;\n    for(i = 0; i < n; ++i) {\n        a[i] = i * i - i + 1;\n    }\n\
    \    for(i = 0; i < n - 1; ++i) {\n        for(j = i + 1; j < n; ++j) {\n    \
    \        for(k = 0; k < j; ++k) {\n                if(a[i] + a[j] + a[k] == 0)\
    \ {\n                    triple++;\n                    a[k] = (a[i] > a[j] ?\
    \ a[i] : a[j]); \n                }\n            }\n        }\n    }\n    return\
    \ triple;\n}\n</code>\n<|/ a tags=dynamic-programming,c++ dscore=1 |>\n<| a |>\n\
    Here is my solution in Python:\n<code>\ndef isTriple(x):\n    x %= 3\n    if x==0:\
    \ return True\n    if x<2: return False\n    if x<3: return False\n    if x<4:\
    \ return False\n    else: return True", "{\n\tstd.typecons.Vec a = std.typecons.Vec.make(\
    \ (ulong)n);\n\tulong t = 0;\n\tfor(uint i = 0; i < a.length; ++i)\n\t\tfor(ulong\
    \ j = i; j < a.length; ++j)\n\t\t{\n\t\t\tfor(ulong k = j; k < a.length; ++k)\n\
    \t\t\t{\n\t\t\t\tt = a[i] + a[j] + a[k];\n\t\t\t\tif(t % 3 == 0) break;\n\t\t\t\
    }\n\t\t}\n\treturn t;\n}", "{\n    int[] a = new int[n];\n    for(int i=0;i<n;i++)\n\
    \    {\n        a[i]=i*i-i+1;\n    }\n    for(int i=0;i<n;i++)\n    {\n      \
    \  for(int j=i+1;j<n;j++)\n        {\n            for(int k=j+1;k<n;k++)\n   \
    \         {\n                if(a[i]+a[j]+a[k] == 3*a[i*(i+1)+j*(j+1)+k*k])\n\
    \                    return 1L;\n            }\n        }\n    }\n    return 0L;\n\
    }\n</code>\n<|/ a tags=arrays,java,algorithm,sorting |>\n<| c |>\nYour code doesn't\
    \ return the number of triples, it returns 1 if triples are possible and 0 otherwise\n\
    <|/ c |>\n<| c |>\nI have edited my answer to include more information about how\
    \ the answer works.\n<|/ c |>\n<| c |>\nStill not correct. You are counting `i*(i+1)+j*(j+1)+k*k`\
    \ instead of `a[i]+a[j]+a[k]`. Also, you do not need to do the inner loop as `k`\
    \ is `< n`.\n<|/ c |>\n<| c |>\nOops. I must have mixed up i and k as i and j.\
    \ I've corrected my code accordingly.\n<|/ c |>\n<| c |>\n, did you get this right?\
    \ Did you get it working and understand the problem? If so, could you provide\
    \ some feedback so others can learn?\n<|/ c |>\n<| a dscore=0 |>\nA bit late,\
    \ but here is my solution:\n<code>\npublic int findNoOfTriples(int n) {\n    \
    \    Arrays.sort(a);\n        int count = 0;\n        long temp = a[0] + a[1]\
    \ + a[2];\n        for(long i=0; i<=n; i++) {\n            for(int j=0; j<=n;\
    \ j++) {\n                for(int k=0; k<=n; k++) {\n                    if(i+j+k\
    \ == temp) {\n                        count++;\n                    }\n      \
    \          }\n            }\n            temp = a[i] + a[j] + a[k];\n        }\n\
    \        return count;\n    }\n</code>\n<|/ a tags=arrays,java,algorithm,sorting\
    \ |>\n<| c |>\nA little explanation will make your answer better. Thanks.\n<|/\
    \ c |>\n<| a tags=arrays,java,algorithm,sorting dscore=0 |>\n<code>\npublic static\
    \ int noOfTriples(int n) {\n    int count = 0;\n    int x = a[0] + a[1] + a[2];\
    \ // sum of first three elements\n    for (int i", "{\n    long long int a[n];\n\
    \    long long int res = 0;\n    long long int i;\n    for(i = 1 ; i < n ; ++i)\n\
    \    {\n        a[i] = i * i - i + 1;\n    }", "{\n    int[] a = new int[n+1];\n\
    \    for(int i=0;i<n;i++)\n        a[i]=i*i-i+1;\n    Arrays.sort(a);\n    long\
    \ result=0;\n    for(int i=0;i<n-1;i++)\n    {\n        for(int j=i+1;j<n;j++)\n\
    \        {\n            if(a[i]+a[j]>3)\n                break;\n            if(a[i]+a[j]==3)\n\
    \            {\n                long k=i+1;\n                while(k<n && a[k]\
    \ ==3)\n                    k++;\n                if(k<n)\n                  \
    \  result+=n-k;\n                i=j;\n            }\n        }\n    }\n    return\
    \ result;\n}", "{\n    long long count = 3LL * n + 1LL * n + 1LL * n;\n    long\
    \ long result = count;\n    \n    for (int i = 1; i < n; i++) {\n        for (int\
    \ j = i+1; j < n; j++) {\n            for (int k = j+1; k < n; k++) {\n      \
    \          if (i * i + j * j + k * k == count) \n                    result--;\n\
    \            }\n        }\n    }\n    \n    return result;\n}", "{\n    long[]\
    \ a = new long[n];\n    long k = 0;\n    for(int i = 1; i<n; i++){\n        a[i]\
    \ = i*(i - 1) + i + 1;\n        for(int j = 1; j < i; j++){\n            for(int\
    \ l = 1; l < j; l++){\n                if(a[i] + a[j] + a[k] != a[k]){\n     \
    \               k++;\n                    a[k]=a[i];\n                    a[k+1]\
    \ = a[j];\n                    a[k+2] = a[k];\n                }\n           \
    \ }\n        }\n    }\n    for(long i = 1; i < k-1; i++){\n        if(a[i] + a[k]\
    \ != a[k]){\n            return k;\n        }\n    }\n    return k-1;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\nI do not see any answer that uses no recursion, that\
    \ uses no loops, that uses no array indexing, that uses no ternary operations.\
    \ So here is an answer using all three techniques, recursion only, loops only,\
    \ and array indexing.\n<code>\npublic static int get_max_triples(long n) {\n \
    \   if (n < 3) throw new IllegalArgumentException(\"n must be positive\");", "{\n\
    \    long long count = 0;\n    long long a[n];\n    for (long i = 0; i < n; i++)\
    \ {\n        a[i] = i * i - i + 1;\n    }\n    sort(a, a + n);\n    for (int i\
    \ = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            for\
    \ (int k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3\
    \ == 0) {\n                    count++;\n                }\n            }\n  \
    \      }\n    }\n    return count;\n}\n</code>\n<|/ a |>\n<| c |>\nWhat happens\
    \ if you try this?  You've got a bug in `get_max_triples(5L)`...\n<|/ c |>\n<|\
    \ c |>\n, fixed it, check it out.\n<|/ c |>\n<| c |>\nWhat if I have to use `long\
    \ long` and not `int`?\n<|/ c |>\n<| c |>\nThen you won't be able to use `sort`,\
    \ which requires `int`.\n<|/ c |>\n<| a |>\nMy approach to this would be to start\
    \ with a small integer array of size n. For each number in the array, set it to\
    \ the current value minus 1. Then sort the array. Once you have that done, loop\
    \ through the sorted array and set an extra variable to 0 for each index you encounter\
    \ (start at n-1) and set it to 1 if the value is less than the current value minus\
    \ 1. At this point you have a list of all possible triples that you can check.\n\
    <|/ a dscore=1 tags=algorithm,c++,c |>\n<| c |>\nThis approach would work fine\
    \ for small arrays, but what about large ones? I think it would take forever to\
    \ find all possible triples\n<|/ c |>\n<| c |>\n, for large arrays, you would\
    \ need to store the triples somewhere (maybe a hashtable), and once you have a\
    \ triplet you can check whether it is the largest. As mentioned, this will quickly\
    \ run out of memory.\n<|/ c |>\n<| a dscore=1 |>\nHere is my solution :\n<code>\n\
    #include <stdio.h>\n#include <stdlib.h>", "{\n\tlong sum = 0;\n\tint[] A = new\
    \ int[n];\n\tfor(int i = 1 ; i <= n ; ++i) A[i] = i*i-1; \n\tfor(int i = 1 ; i\
    \ <= n ; ++i){\n\t\tfor(int j = 1 ; j <= n ; ++j){\n\t\t\tfor(int k = 1 ; k <=\
    \ n ; ++k){\n\t\t\t\tif(A[j]*A[j]+A[k]*A[k]==A[i]*A[i]){\n\t\t\t\t\tsum++;\n\t\
    \t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn sum;\n}", "{\n\tvector<long>\
    \ a;\n\tlong max = 0;\n\ta.resize(n);\n\tfor(long i = 0; i < n; i++) {\n\t\tlong\
    \ x = i * i - i + 1;\n\t\tlong y = 1;\n\t\tfor(long j = 1; j < i; j++) {\n\t\t\
    \ty += x;\n\t\t\tx += y;\n\t\t}\n\t\ta[i] = y;\n\t}\n\t\n\tsort(a.begin(), a.end());\n\
    \tfor(long i = 0; i < a.size(); i++) {\n\t\tif(a[i] == 0) {\n\t\t\tbreak;\n\t\t\
    }\n\t\tmax = max(max, i);\n\t}\n\t\n\treturn max;\n}\n\"\"\"", "{\n    int[] a\
    \ = new int[n];\n    \n    for(int i = 0; i < n; i++) {\n        a[i] = i * i\
    \ - i + 1;\n    }\n    \n    int count = 0;\n    for(int i = 0; i < n; i++) {\n\
    \        for(int j = 0; j < n; j++) {\n            if(i < j) {\n             \
    \   continue;\n            }\n            for(int k = 0; k < n; k++) {\n     \
    \           if(j < k) {\n                    continue;\n                }\n  \
    \              if(a[i] + a[j] + a[k] == 0) {\n                    continue;\n\
    \                }\n                if(a[i] + a[j] + a[k] % 3 == 0) {\n      \
    \              count = count + 1;\n                }\n            }\n        }\n\
    \    }\n    \n    return count;\n}\n</code>\n<|/ a tags=big-o,time-complexity,java,algorithm\
    \ |>\n<| a tags=big-o,time-complexity,java,algorithm dscore=2 |>\nHere's a nice\
    \ simple way (assuming n > 1):\n<code>\nlong tripleSums = IntStream.range(0, n).filter(i\
    \ -> i * i < n).mapToLong(i -> i*i).sum();\n</code>\nThat code basically says,\
    \ loop from 0 to n-1 and for each value i that satisfies i*i < n, calculate i*i,\
    \ then sum the results.\n<|/ a |>\n<| a tags=big-o,time-complexity,java,algorithm\
    \ |>\nI have implemented a O(n log n) solution using HashSet. The key points are\
    \ in comments.\n<code>\npackage com.company;", "{\n\t\n\tlong triples = 0;\n\t\
    long long a[n];\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = i * i - i + 1;\n\t\
    }\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\
    for (int k = 0; k < n; ++k) {\n\t\t\t\tif (i < j && j < k && k < i) {\n\t\t\t\t\
    \tif ((i + j + k) % 3 == 0) ++triples;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ triples;\n}\n</code>\n<|/ a |>\n<| a dscore=0 tags=algorithm,c++,dynamic-programming,math\
    \ |>\nO(n^3) solution is as follows. Let a be the array of the elements. Let b\
    \ be an array of the sum of array elements, i.e. sum(a) = b[i]. Let c be an array\
    \ of the number of times sum(a) appears. Let d be an array of the number of times\
    \ sum appears in a. \n<code>\nc[i] = max(c[i], d[i]+1);\nfor (i = 1 to n)\n  if\
    \ (c[i] < 3)\n     c[i] = max(c[i-1], 3);\n</code>\n<|/ a |>\n<| a dscore=0 tags=algorithm,c++,dynamic-programming,math\
    \ |>\nHere's my attempt of an optimal solution:\n<code>", "{\n    int[] a = {\
    \ 1 };\n    for(long i = 0; i < n; ++i)\n    {\n        a[i] = i * i - i + 1;\n\
    \    }\n    long ans = 1;\n    int k = n - 1;\n    int j = n - 1;\n    while(j\
    \ >= 0 && ans > 0 && k > 0)\n    {\n        if(k > j) \n        {\n          \
    \  ans = ans + a[j];\n            ++j;\n        }\n        else \n        {\n\
    \            ans = ans + a[k];\n            --k;\n        }\n    }\n    return\
    \ ans;\n}", "{\n    int[] a = new int[n];\n    for(long i = 0; i < n; i++)\n \
    \   {\n        a[i] = i * i - i + 1;\n    }\n    Arrays.sort(a);\n    long res\
    \ = 0;\n    long prev = a[0];\n    long curr = prev;\n    for(long i = 1; i <\
    \ n; i++)\n    {\n        curr = a[i] + prev;\n        if(curr % 3 == 0)\n   \
    \     {\n            res++;\n        }\n        prev = curr;\n    }\n    return\
    \ res;\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=dynamic-programming,java |>\n\
    You can use dynamic programming concept for this problem. \n<code>\nimport java.util.ArrayList;\n\
    import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\n\
    import java.util.Map;", "{\n    long count = 0;\n    long array[n];\n    long\
    \ i=1;\n    long j=1;\n    long k=1;", "{\n    if(n < 3)\n    {\n        return\
    \ 0;\n    }\n    \n    long sum = 0;\n    \n    for(int i = 1; i < n; ++i)\n \
    \   {\n        if(i < n && i % 3 == 0)\n        {\n            sum += i;\n   \
    \     }\n    }\n    \n    return sum;\n}", "{\n    long sum = 0;\n    long max\
    \ = INT_MIN;\n    long counter = 0;\n    long *a = (long*)malloc(sizeof(long)\
    \ * n);\n    for (long i = 1; i <= n; i++)\n        a[i] = i * i - i + 1;\n  \
    \  for (int i = 1; i < n; i++)\n        for (int j = 1; j <= n; j++) {\n     \
    \       for (int k = 1; k <= n; k++) {\n                if (a[j] + a[k] == 0)\
    \ {\n                    counter++;\n                    sum += counter;\n   \
    \                 max = max(a[i], a[j], a[k]);\n                }\n          \
    \      if (a[j] + a[k] > max) {\n                    counter = 0;\n          \
    \          max = a[j] + a[k];\n                }\n            }\n        }\n \
    \   free(a);\n    return sum;\n}\n</code>\n<|/ a |>\n<| c |>\nWhy don't you test\
    \ your program with different input values, like 30 and 60? The solution should\
    \ be `O(n^2)`, not `O(n^3)`. Furthermore, your solution isn't actually a solution.\
    \ E.g. your program should return the number `30` but your solution returns `0`.\n\
    <|/ c |>\n<| c |>\n: You are right, I misread the question, I think I got the\
    \ question wrongly interpreted before. Thanks.\n<|/ c |>\n<| a |>\nI made it more\
    \ simple than most of you. Hope this will help you.\n<code>\n#include <stdio.h>",
  "{\n    long i, j;\n    long a[n];\n    for(i = 0; i < n; ++i)\n        a[i] = i\
    \ * i - i + 1;\n    for(i = 0; i < n; ++i)\n        for(j = 0; j < n; ++j)\n \
    \           if(a[i] >= a[j] + a[k])\n                return i;\n    return 0L;\n\
    }", "{\n    vector<long> A(n);\n    for (int i = 0; i < n; ++i) A[i] = i * i -\
    \ i + 1;", "{\n    std.array<long, 1> a = std.array<long, 1>(3);\n    for (long\
    \ i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }", "{\n    long i;\n\
    \    long a[n];\n    for(i = 0; i < n; i++) a[i] = i * i - i + 1;\n    sort(a,\
    \ a + n);\n    long cnt = 0;\n    for(i = 0; i < n; i++) {\n        for(j = i\
    \ + 1; j < n; j++) {\n            for(k = 0; k < n; k++) {\n                if(\
    \ (a[i] + a[j] + a[k]) % 3 == 0) {\n                    cnt += 1;\n          \
    \          break;\n                }\n            }\n        }\n    }\n    return\
    \ cnt;\n}\n</code>\n<|/ a tags=algorithm,arrays,c |>\n<| c |>\nThat won't work.\
    \ You've made your array size n, but then you start iterating from 0 to n-1, so\
    \ the last element (at index n-1) will never be checked.\n<|/ c |>\n<| c |>\n\
    `if ( (a[i] + a[j] + a[k]) % 3 == 0) { cnt += 1;` That would be better written\
    \ as `if ( (a[i] + a[j] + a[k]) % 3 == 0) { cnt += n; break;`. That avoids needlessly\
    \ looping over all n elements in the third loop.\n<|/ c |>\n<| a |>\nHere is my\
    \ solution:\n<code>\n#include<stdio.h>\n#include<stdlib.h>\n#define N 1000", "{\n\
    \    int[] a = int[(int) n];\n    long triples = 0;\n    int i = n - 1;\n    while\
    \ (i > 0) \n    {\n        a[i] = (i * i) + i + 1;\n        --i;\n        ++triples;\n\
    \    }\n    long j = 0;\n    for (int k = 0; k < (int) n; k++) \n    {\n     \
    \   if (j >= k) \n        {\n            long t = 0;\n            for (int m =\
    \ k; m < n; m++) \n            {\n                t = a[m] + a[j] + a[m];\n  \
    \              if (t % 3 == 0) \n                {\n                    ++triples;\n\
    \                }\n            }\n        }\n        j++;\n    }\n    return\
    \ triples;\n}", "{\n    long i,j,k,t=0;\n    int[] a = new int[n];\n    for(i=0;i<n;i++)\n\
    \        a[i]=i*i-1;\n    for(i=0;i<n;i++) {\n        for(j=0;j<n;j++) {\n   \
    \         for(k=0;k<n;k++) {\n                if(i<j && j<k && a[i]+a[j]+a[k]==i*i+j)\
    \ {\n                    t++;\n                }\n            }\n        }\n \
    \   }\n    return t;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis fails when\
    \ the numbers are very large.\n<|/ c |>\n<| c |>\nThe numbers are not very large.\n\
    <|/ c |>\n<| c |>\nThe numbers are not very large. I would have tested a solution\
    \ for an array with 1,000,000 elements and gotten a runtime of less than a second.\
    \ My solution should work for any integer less than 100,000 elements. Anything\
    \ larger, however, is a bit longer and would require a more complicated solution.\n\
    <|/ c |>\n<| c |>\nIt fails for me when the numbers are too large.\n<|/ c |>\n\
    <| c |>\nWhat is the error or wrong output you are getting? I didn't get any errors\
    \ for large numbers on my machine.\n<|/ c |>\n<| a tags=c++,algorithm,combinatorics,algorithm\
    \ |>\nHere is a solution using a matrix data structure.\n<code>\n#include <vector>\n\
    #include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n\
    #include <cstdio>", "{\n    int[] arr = new int[n];\n    long ans = 0;\n    for(int\
    \ i = 0; i<n; i++) arr[i] = i * i - i + 1;\n    for(int i = 0; i<n; i++) {\n \
    \       for(int j = i+1; j<n; j++) {\n            for(int k = j+1; k<n; k++) {\n\
    \                if(arr[i] + arr[j] + arr[k] % 3 == 0) {\n                   \
    \ ans++;\n                    break;\n                }\n            }\n     \
    \   }\n    }\n    return ans;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n\
    Here is a O(n^2) solution that finds the largest triple that sums to a multiple\
    \ of 3:\n<code>\nfunction largestTriple(arr) {\n    let result = [];", "{\n  \
    \  long a[n];\n    long triple;\n    \n    for(int i = 0; i < n; i++){\n     \
    \   a[i] = i * i - i + 1;\n    }\n    \n    for(int i = 0; i < n; i++){\n    \
    \    for(int j = i + 1; j < n; j++){\n            for(int k = j + 1; k < n; k++){\n\
    \                triple = a[i] + a[j] + a[k];\n                if(triple % 3 ==\
    \ 0){\n                    return 1L;\n                }\n            }\n    \
    \    }\n    }\n    \n    return 0L;\n}\n</code>\n<|/ a tags=algorithm,python,dynamic-programming\
    \ |>\n<| a tags=algorithm,python,dynamic-programming dscore=0 |>\nAs I read this\
    \ you have a problem of finding a triplet of numbers that sum to a certain number.\
    \ It looks like this problem is called \"the three numbers whose sum is N\" and\
    \ the solution I offer would be to simply find all 3-combinations of the original\
    \ array and check if the sum is equal to the given number. Here is what I mean:\n\
    <code>\nfrom itertools import combinations_with_replacement\ndef find_triplet(array,target_sum):\n\
    \    possible_triplets = [i for i in combinations_with_replacement(array,3)]\n\
    \    triplets_with_sum = []\n    for i in possible_triplets:\n        if sum(i)\
    \ == target_sum:\n            triplets_with_sum.append(i)\n    return triplets_with_sum\n\
    </code>\nTo use this I would simply call the function with the target sum and\
    \ print out all triples that are greater than the target sum:\n<code>\nfind_triplet([1,2,3],4)\n\
    </code>\nThis would return the following triples:\n<code>\n[(1, 2, 3), (1, 2,\
    \ 4), (1, 3, 4), (1, 3, 4), (2, 3, 4)]\n</code>\n<|/ a |>\n<| a tags=algorithm,python,dynamic-programming\
    \ |>\nThe fastest approach would be to precompute the sum of all multiples of\
    \ 3, then just look up this sum in the dictionary or set if you have many possible\
    \ numbers to look up. \n<code>\nimport time\nimport functools", "{\n    long i,j,k,result=0,maxValue=1;\n\
    \    long long int * arr=new long long int[n];\n    long long int temp=0;\n  \
    \  int count=0;\n    for(i=0;i<n;i++)\n    {\n        arr[i]=i*i-i+1;\n      \
    \  if(arr[i]>=maxValue)\n        {\n            temp=arr[i];\n            maxValue=temp;\n\
    \        }\n    }\n    for(i=0;i<n;i++)\n    {\n        for(j=i;j<n;j++)\n   \
    \     {\n            for(k=j;k<n;k++)\n            {\n                if(arr[i]+arr[j]+arr[k]==temp)\n\
    \                    count++;\n            }\n        }\n    }\n    cout<<count<<endl;\n\
    \    return count;\n}", "{\n    long i,j,k;\n    long long count=0;\n    vector\
    \ <long long int> a;\n    \n    for(i=1;i<=n;i++)\n    {\n        a.push_back(i*i-1);\n\
    \    }", "{\n    long i,j,k;\n    int a[n];\n    for(i=0;i<n;i++){\n        a[i]=i*i-i+1;\n\
    \    }\n    for(i=0;i<n-1;i++){\n        for(j=i+1;j<n;j++){\n            if(a[i]+a[j]+a[k]==0){\n\
    \                return 0;\n            }\n        }\n    }\n    return 1;\n}",
  "{\n    Array2D<long> a(n);\n    forall(i in n){\n        a[i] = i * i - i + 1;\n\
    \    }\n    long triples = 0;\n    Array2D<long> result(n);\n    forall(i in n){\n\
    \        forall(j in n){\n            forall(k in n){\n                if(i <\
    \ j && j < k && a[i] + a[j] + a[k] == 3){\n                    result[i][j][k]\
    \ = 1;\n                    results++;\n                }\n            }\n   \
    \     }\n    }\n    return triples;\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\n\
    I guess this could be improved on, but it seems to be working:\n<code>\nfunction\
    \ tripples($n){\n    $array=array_fill(0, $n, 0);\n    $i=1;\n    while(count($array)>0){\n\
    \        foreach($array as $index => $value){\n            if($i!=$index){\n \
    \               $temp=array_search($value, $array);\n                if($temp!==false){\n\
    \                    unset($array[$temp]);\n                }\n            }else{\n\
    \                $array[$index]=$value;\n            }\n        }\n        $i++;\n\
    \    }\n    return $i;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,php,arrays,php-5.3,multidimensional-array\
    \ |>\n<| c |>\nit seems to me that it would be better to remove the duplicates.\n\
    <|/ c |>\n<| a tags=algorithm,php,arrays,php-5.3,multidimensional-array |>\nI\
    \ have tried this solution\n<code>\n$arr=array(1,2,3,4,5,6,7,8,9);\n$i=0;\n$n=sizeof($arr);\n\
    for($i;$i<$n;$i++){\n    for($j=$i;$j<$n;$j++){\n        for($k=$j+1;$k<$n;$k++){\n\
    \            if($arr[$i]==$arr[$j] && $arr[$i]==$arr[$k] && $arr[$j]+$arr[$k]==3){\n\
    \                echo $arr[$i].\"<br>\";\n                echo $arr[$j].\"<br>\"\
    ;\n                echo $arr[$k].\"<br>\";\n            }\n        }\n    }\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nIn PHP you can use the array\
    \ filter function http://php.net/manual/en/function.array-filter.php\n<code>\n\
    $array = array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', '", "{\n\tlong\
    \ a[n];\n\tstd.typecons.init(a);\n\tstd.math.reset(0L);\n\tlong total = 0L;\n\t\
    for(int i = 1; i < n; i++)\n\t{\n\t\tlong a = i * i - i + 1;\n\t\tstd.math.reset(a);\n\
    \t\twhile(!std.math.is_divisible_by_three(a))\n\t\t{\n\t\t\ttotal += a;\n\t\t\t\
    std.math.reset(a);\n\t\t}\n\t\tstd.math.reset(a);\n\t}\n\treturn total;\n}", "{\n\
    \    long i,j;\n    long sum;\n    long long a[n+1];\n    for (i=0; i<=n; i++)\n\
    \    {\n        a[i]=i*(i+1)-1;\n    }", "{\n    int a[1<<15];\n    int n2 = n\
    \ >> 1;\n    int n1 = n >> 1;", "{\n    int a[n];\n    for(int i=0;i<n;i++){\n\
    \        a[i]=i*i-i+1;\n    }\n    long res = 0;\n    for(int i=0;i<n;i++){\n\
    \        for(int j=0;j<i;j++){\n            for(int k=0;k<j;k++){\n          \
    \      if(a[i]+a[j]+a[k]*3>0){\n                    res++;\n                }\n\
    \            }\n        }\n    }\n    return res;\n}\n</cell>\n<cell>\nget_max_triples(5L);\n\
    </cell>\n<cell>\n%%time\nget_max_triples(10000L);\n</cell>\n<text>\nWrite a recursive\
    \ function get_max_triples2(int n) that returns the number of triples (a[i], a[j],\
    \ a[k]) of a where i < j < k, \n    such that a[i] < a[j] < a[k]. ", "{\n    long\
    \ a[n];\n    memset(a, 0, sizeof(a));\n    for (int i = 0; i < n; i++) \n    {\n\
    \        a[i] = (i * i - i + 1);\n    }\n    int count = 0;\n    for (int i =\
    \ 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n    \
    \        for (int k = 0; k < n; k++)\n            {\n                if (a[i]\
    \ < a[j] && a[i] < a[k])\n                {\n                    if (a[j] > a[k])\n\
    \                    {\n                        count++;\n                   \
    \ }\n                    else if (a[k] > a[j])\n                    {\n      \
    \                  count++;\n                        count += 2;\n           \
    \         }\n                    else if (a[j] == a[k])\n                    {\n\
    \                        count++;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return count;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis isn't the correct answer because this doesn't consider any\
    \ triplets where the sum is less than 3.\n<|/ c |>\n<| c |>\nI think you might\
    \ be right and I misunderstood the question. I did however find a similar question\
    \ on leetcode http://leetcode.com/problems/triple-sum/discuss/67884/Java-Solution-with-O(n)-time-and-O(1)-space-solution-and-explanation-by-Sean\n\
    <|/ c |>\n<| c |>\nThat's not what I want. For example, if you call `get_max_triples(10)`\
    \ the answer is `3`, but the correct answer is `2`. The question I linked above\
    \ does have an answer that solves this problem in O(n) and O(1) space, but it\
    \ was wrong because I realized that I was thinking about this problem in terms\
    \ of permutations.\n<|/ c |>\n<| a dscore=0 |>\nThis solution is based on the\
    \ assumption that you have only positive integers and you are allowed to create\
    \ array of size N.\n<code>\ndef max_triple_sum(arr):\n    # Sort array from minimum\
    \ to maximum\n    arr.sort()", "{\n    long result = 0;\n    for(int i = 0; i\
    \ < n; ++i)\n    {\n        long a[i];\n        long triples[] = { a[i] + a[j]\
    \ + a[k] }; // get all possible triples of length i\n        for(size_t j = 0;\
    \ j < i; ++j)\n            std::sort(triples, triples + i);\n        for(size_t\
    \ j = 0; j < i; ++j)\n            result += triples[j] - triples[i - 1];\n   \
    \ }\n    return result;\n}\n</code>\n<|/ a tags=arrays,c++,sorting,algorithm |>\n\
    <| c |>\nYou missed a `for` loop in `get_max_triples()`. It should loop `for (size_t\
    \ j = i; j < n; ++j)` instead.\n<|/ c |>\n<| c |>\n, you are right that `size_t`\
    \ should be used here instead of `int`. But the problem statement asks for `int`,\
    \ so it's better to use `int`.\n<|/ c |>\n<| c |>\n`j` is uninitialized, so `j\
    \ - 1 == i` when `j < i` in the `for` loop. But you also have the problem that\
    \ `j` is only initialized in the outer `for` loop; it should be set to `0` before\
    \ the inner loop, and you also need to make sure `j` does not wrap around.\n<|/\
    \ c |>\n<| c |>\n, you are right again. I added `j = 0` before `for(size_t j =\
    \ i; j < n; ++j)` in the outer loop. Thanks for pointing that.\n<|/ c |>\n<| c\
    \ |>\n`j - 1 == i` only after `j` is initialized in the outer loop, but not before\
    \ the inner loop. Also, `j = 0` is only executed once, so `j - 1 == i` will not\
    \ occur anymore when `j` is initialized in the inner loop.\n<|/ c |>\n<| a tags=arrays,c++,sorting,algorithm\
    \ dscore=1 |>\nThis should work:\n<code>\nlong get_max_triples(long n) \n{\n \
    \   long triples = 0L;\n    long a[n+1];", "{\n    Array2D<long> a(n+1,n+1);\n\
    \    for(int i=1; i<=n; i++)\n    {\n        a[i] = i*i - i + 1;\n    }\n    for(int\
    \ i=n-2; i>=0; i--)\n    {\n        for(int j=i+1; j<=n; j++)\n        {\n   \
    \         long k = (long)j - i;\n            if(a[j]*a[j] - a[k] * a[k] == 3)\n\
    \            {\n                return i+1L;\n            }\n        }\n    }\n\
    \    return 0L;\n}\n</code>\n<|/ a tags=c++,arrays,algorithm |>\n<| c |>\nWhile\
    \ the answer does address the OP's question, it's not a good answer, because in\
    \ C++ you have access to STL and therefore you can just use `std::array` or `std::vector`\
    \ instead of implementing the same thing yourself. As such I recommend adding\
    \ that as a comment on the question. (Also, note that it's possible that the OP\
    \ might not be permitted to use STL either)\n<|/ c |>\n<| c |>\n: yes i missed\
    \ the C++ tag. thanks for pointing out.\n<|/ c |>\n<| c |>\n`std::array` doesn't\
    \ support random access. But you can use a `std::vector`. That also has the advantage\
    \ of being able to use the existing code (which uses `std::array`).\n<|/ c |>\n\
    <| a tags=c++,arrays,algorithm dscore=1 |>\n<code>\n#include <iostream>\nusing\
    \ namespace std;", "{\n    std.typecons.IndexRange<long> iRange = std.typecons.IndexRange.range(0L,\
    \ n);\n    \n    std.array.array<long, 1> a = iRange.map(i -> i * i - i + 1);",
  "{\n    long long int a[1000], n1, n2, n3;\n    long long int c = 0;\n    n1 = n2\
    \ = n3 = 0;", "{\n    long i, j, k, max_triple = 0;\n    long a[n];\n    for(i\
    \ = 0; i < n; i++)\n        a[i] = i*i-i+1;\n    for(; i < n; i++) {\n       \
    \ for(j = 0; j < i; j++) {\n            for(k = 0; k < j; k++) {\n           \
    \     if(a[i] < a[j] && a[i] < a[k] && a[j] < a[k] && a[j] + a[k] == i) {\n  \
    \                  max_triple++;\n                    break;\n               \
    \ }\n            }\n        }\n    }\n    return max_triple;\n}\n</code>\n<|/\
    \ a tags=c |>\n<| c |>\nWhy do you think it's O(n^2)? It's O(n^3). Plus, `a[b]`\
    \ is an `O(1)` operation so it doesn't actually change the asymptotic complexity\
    \ (which is always `O(n)`). Asymptotic complexity is a pretty broad term.\n<|/\
    \ c |>\n<| c |>\nThanks for the help. I guess its O(n^3) since the inner loop\
    \ is iterating i times and hence it is making the complexity to O(n^2). Also,\
    \ the complexity of the outer loop was O(n) and hence O(n^2) was the correct answer.\n\
    <|/ c |>\n<| c |>\nIt is O(n^3) as well because all loops run n times. But as\
    \ I said, it's `O(n)` because all loops run n times.\n<|/ c |>\n<| c |>\nYou are\
    \ right, I got confused with your explanation. Thanks for correcting\n<|/ c |>\n\
    <| c |>\nThank you for your answer.\n<|/ c |>\n<| a tags=c |>\nJust to add to\
    \ the good answers above, you can simply use a loop to find the maximum triplet\
    \ and store the result in a variable.\n<code>", "{\n    int a[n];\n    long i,\
    \ j, k;\n    long total = 0;\n    for (i = 0; i < n; i++) a[i] = i * i - i + 1;\n\
    \    sort(a, a + n);", "{\n\tlong a[n];\n\tfor(long i=0;i<n;i++)\n\t{\n\t\ta[i]\
    \ = i*i-1+1+n;\n\t}\n\tArrays.sort(a);\n\tlong ans=0;\n\tfor(long i=1;i<n;i++)\n\
    \t{\n\t\tlong tmp = a[i] + a[i - 1];\n\t\tif(tmp%3 == 0)\n\t\t{\n\t\t\tans++;\n\
    \t\t}\n\t}\n\treturn ans;\n}", "{\n    int a[n];\n    long ans = 0;\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        a[i] = i * i - i + 1;\n    }\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n\
    \            if(a[j] * a[j] <= a[i])\n            {\n                for(int k\
    \ = j + 1; k < n; k++)\n                {\n                    if(a[j] * a[k]\
    \ + a[j] * a[i] > a[k])\n                    {\n                        a[k] =\
    \ a[j] * a[j] + a[k] * a[k];\n                        ans += 1;\n            \
    \            break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    return ans;\n}", "{\n    long t = 0;\n    long ans = 0;\n\
    \    long a[n];\n    for(int i = 0; i < n; i++)\n    {\n        a[i] = i * i -\
    \ i + 1;\n    }\n    sort(a, a + n);\n    for(int i = 1; i < n; i++)\n    {\n\
    \        for(int j = i; j < n; j++)\n        {\n            for(int k = j; k <\
    \ n; k++)\n            {\n                if(3 * a[i] < 3 * a[j] + 3 * a[k])\n\
    \                {\n                    ans = ans + 1;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\n</code>\n\
    <|/ a tags=algorithm |>\n<| a tags=algorithm |>\nMy solution (no sorting is needed):\n\
    <code>\npublic long getMaxTriples(int n) {\n    long res = 0;\n    long cur =\
    \ 1;\n    for (int i = 1; i < n; i++) {\n        int j = i;\n        while (j\
    \ < n && 3 * cur < 3 * a[j] + 3 * a[j - 1]) { j++; }\n        if (j == i) {\n\
    \            long k = 1;\n            while (j < n && 3 * k * cur < 3 * a[j] +\
    \ 3 * a[i - 1]) { k++; }\n            if (j == i) {\n                res++;\n\
    \            }\n        }\n        cur *= a[i];\n    }\n    return res;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nO(n^3)\n<code>\npublic long getMaxTriples(int n) {\n\
    \    long res = 0;\n    long cur = 1;\n    long i = 1;\n    long j = 1;\n    long\
    \ k = 1;\n    long sum = 0;\n    \n    while(i <= n) {\n        while(j <= n &&\
    \ 3 * sum <= 3 * a[j] + 3 * a[j-1]) j++;\n        sum *= a[i];\n        \n   \
    \     if(j == i) {\n            k += 1;\n            while(k < n && 3 * sum <=\
    \ 3 * a[k] + 3 * a[k-1]) k++;\n            \n            if(k == i) {\n      \
    \          res++;\n            }\n            \n            sum += a[j];\n   \
    \     }\n        \n        i += 1;\n    }\n    return res;\n}\n</code>\n<|/ a\
    \ tags=algorithm dscore=0 |>\n<| a tags=algorithm |>\n<code>\npublic static long\
    \ getMaxTriples(int n) {\n    long res = 0;\n    long cur = 1;\n    for (int i\
    \ = 1; i <= n; i++) {\n        int j = 1;\n        while (j <= n && 3 * cur <\
    \ 3 * a[j] + 3 * a[j - 1]) {\n            j++;\n        }\n        if (j == i)\
    \ {\n            long k = 1;\n            while (k <= n && 3 * k * cur < 3 * a",
  "{\n\tlong arr[n];\n\tlong ans = 0;\n\tmemset(arr, 0, sizeof(arr));\n\tfor (int\
    \ i = 1; i < n; i++) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tfor (int k =\
    \ i; k < n; k++) {\n\t\t\t\tif (i + j + k == n)\n\t\t\t\t\tcontinue;\n\t\t\t\t\
    if (arr[i + j] + arr[j + k] + arr[k] == n)\n\t\t\t\t\tans += 1;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn ans;\n}", "{\n    long long int* a = new long long int[n+1];\n\
    \    memset(a, 0L, sizeof(a));\n    for(long long int i = 1; i <= n; i++)\n  \
    \      a[i] = i * i - i + 1;\n    return findmax(a, n);\n}", "{\n    long long\
    \ a[n+1];\n    long long sum = 0;\n    long long triple = 0;", "{\n    long triples[]={0};\n\
    \    long sum=0;\n    long i,j;\n    long cnt=0;\n    long max=0;\n    for(i=1;i<=n;i++)\n\
    \    {\n        for(j=1;j<=n;j++)\n        {\n            sum=0;\n           \
    \ for(k=1;k<=n;k++)\n            {\n                if(i<k)\n                \
    \    sum+=a[k] * a[k] - a[i] * a[k];\n                else if(j<k)\n         \
    \           sum+=a[k] * a[k] - a[j] * a[k];\n                else\n          \
    \          sum+=a[k] * a[k] - a[j] * a[k] - a[i] * a[j];\n            }\n    \
    \        if(cnt>sum)\n            {\n                cnt=sum;\n              \
    \  max=i;\n            }\n        }\n    }\n    return max;\n}\n</code>\n<|/ a\
    \ tags=c,algorithm |>\n<| c |>\nThe problem is this takes too long for a input\
    \ of 100^5 and takes more than 4 minutes!! Is there a way to optimize this code?\n\
    <|/ c |>\n<| c |>\n: This answer is too long for a comment so I've added an answer\
    \ with the code added.\n<|/ c |>\n<| a |>\nI think it's pretty cool to see that\
    \ there are two ways to solve the question without actually solving it.  I like\
    \ the answer by, but he missed a critical point.  For his solution to work, the\
    \ answer has to be a multiple of 3.  So the question should be changed to how\
    \ do you find the largest number that is divisible by 3 that is also a multiple\
    \ of 3.  To find such number, one can use the \"mod\" operator.  And then the\
    \ answer is just to use the mod operator three times to get the correct result.\
    \  To get that answer quickly, we can use a lookup table.  So here is the working\
    \ code:\n<code>\nunsigned long long max_triples(unsigned long long n) {\n    unsigned\
    \ long long a[n + 1];\n    unsigned long long sum = 0;\n    unsigned long long\
    \ cnt = 0;\n    unsigned long long max = 0;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
