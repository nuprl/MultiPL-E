language: d
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  long deepest_level\
    \ = 0;\n  stack<string> paren_stack;\n  string paren_string_tmp;\n  vector<string>\
    \ paren_strings;\n  paren_strings.push_back(paren_string);\n  while (!paren_strings.empty())\n\
    \  {\n    paren_string_tmp = paren_strings.back();\n    paren_strings.pop_back();\n\
    \    size_t pos = paren_string.find(paren_string_tmp);\n    if (pos != string::npos)\
    \ {\n      size_t paren_end = paren_string.find(paren_string_tmp, pos + 1);\n\
    \      if (paren_end != string::npos)\n      {\n        string paren_string_tmp2\
    \ = paren_string.substr(pos + 1, paren_end - pos - 1);\n        size_t paren_end2\
    \ = paren_string.find(paren_string_tmp2, pos + 1);\n        if (paren_end2 !=\
    \ string::npos) {\n          string paren_string_tmp3 = paren_string.substr(pos\
    \ + 1, paren_end2 - pos - 1);\n          paren_strings.push_back(paren_string_tmp3);\n\
    \          deepest_level++;\n        }\n      }\n      else\n      {\n       \
    \ string paren_string_tmp2 = paren_string.substr(pos + 1, paren_end - pos - 1);\n\
    \        paren_strings.push_back(paren_string_tmp2);\n        deepest_level++;\n\
    \      }\n    }\n  }\n  return deepest_level;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9u7b32w3.d(15): Error: found `>` when expecting `;` following statement

    /tmp/tmp9u7b32w3.d(17): Error: found `>` when expecting `;` following statement

    /tmp/tmp9u7b32w3.d(24): Error: found `:` when expecting `)`

    /tmp/tmp9u7b32w3.d(24): Error: found `:` instead of statement

    /tmp/tmp9u7b32w3.d(26): Error: found `:` when expecting `)`

    /tmp/tmp9u7b32w3.d(26): Error: found `:` instead of statement

    /tmp/tmp9u7b32w3.d(30): Error: found `:` when expecting `)`

    /tmp/tmp9u7b32w3.d(30): Error: found `:` instead of statement

    /tmp/tmp9u7b32w3.d(36): Error: declaration expected, not `else`

    /tmp/tmp9u7b32w3.d(39): Error: function declaration without return type. (Note
    that constructors are always named `this`)

    /tmp/tmp9u7b32w3.d(39): Error: no identifier for declarator `paren_strings.push_back(paren_string_tmp2)`

    /tmp/tmp9u7b32w3.d(40): Error: no identifier for declarator `deepest_level`

    /tmp/tmp9u7b32w3.d(40): Error: declaration expected, not `++`

    /tmp/tmp9u7b32w3.d(41): Error: unrecognized declaration

    Failed: ["dmd'
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong []\
    \ levels = new long[paren_string.length()];\n\tint max_level = 0;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpczile0o_.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpczile0o_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_stack = paren_string;\n    long[] result = new long[paren_stack.size()];\n\
    \    long depth = 1;\n    \n    while (!paren_stack.empty())\n    {\n        //\
    \ Parse opening parenthesis\n        if (paren_stack[0] == '(')\n        {\n \
    \           if (depth < result.length)\n                result[depth++] = 1;\n\
    \        }\n        // Parse closing parenthesis\n        else if (paren_stack[0]\
    \ == ')')\n        {\n            if (depth > 1)\n                result[--depth]\
    \ = 1;\n        }\n        // Parse nested parenthesis\n        else if (paren_stack[0]\
    \ == '(')\n        {\n            if (depth < result.length)\n               \
    \ result[depth++] = depth;\n        }\n        // Parse unmatched parenthesis\n\
    \        else if (paren_stack[0] == '#')\n        {\n            if (depth < result.length)\n\
    \                result[depth++] = depth;\n        }\n        else\n        {\n\
    \            error(\"Unexpected character: '\" + paren_stack[0] + \"'\");\n  \
    \      }\n        \n        paren_stack.remove_prefix(1);\n    }\n    \n    return\
    \ result;\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis is so cool.\
    \ I think there can be some optimization to it. But it's awesome!\n<|/ c |>\n\
    <| a tags=c++,algorithm |>\nIt's pretty simple, you can use a stack to count parenthesis\
    \ and then use the results to build the result array. Here's a sample in Javascript\
    \ (but you can easily convert it to C):\n<code>\nfunction countParenthesis(str){\n\
    \  var result = [];\n  var opening = 0;\n  var closing = 0;\n  var index = 0;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxc2p2esx.d(54): Error: declaration expected, not `<`

    /tmp/tmpxc2p2esx.d(57): Error: unterminated character constant

    /tmp/tmpxc2p2esx.d(60): Error: unterminated character constant

    /tmp/tmpxc2p2esx.d(60): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxc2p2esx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    char[]\
    \ c = paren_string.toCharArray();\n    long nest = 0;\n    for(long i = 0; i <\
    \ c.length; ++i) {\n        string token = c[i];\n        if(token == ')') {\n\
    \            ++nest;\n        } else {\n            --nest;\n        }\n     \
    \   if(nest < 0) {\n            throw new Exception(\"Malformed parens string\"\
    );\n        }\n    }\n    long[] res = new long[nest];\n    for(long i = 0; i\
    \ < nest; ++i) {\n        res[i] = i;\n    }\n    return res;\n}\n'''\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptmwos6lf.d(33): Error: unterminated character constant

    /tmp/tmptmwos6lf.d(33): Error: declaration expected, not `63U`

    /tmp/tmptmwos6lf.d(33): Error: unterminated character constant

    /tmp/tmptmwos6lf.d(38): Error: declaration expected, not `assert`

    /tmp/tmptmwos6lf.d(39): Error: declaration expected, not `assert`

    /tmp/tmptmwos6lf.d(40): Error: declaration expected, not `assert`

    /tmp/tmptmwos6lf.d(41): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptmwos6lf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  int num;\n\
    \  \n  num = 0;\n  stack<long> s;\n  s.push(0L);\n  \n  for (auto s : paren_string)\n\
    \  {\n    if (s == '(')\n      s.push(0L);\n    else if (s == '{')\n      s.push(1L);\n\
    \    else if (s == '[')\n      s.push(2L);\n    else\n    {\n      s.push(s.pop()\
    \ + 1L);\n      if (num < s.pop())\n        num++;\n    }\n  }\n  \n  long[] res;\n\
    \  res.resize(num);\n  for (auto i = 0ul; i < num; i++)\n    res[i] = s.pop();\n\
    \  \n  return res;\n}\n</code>\n<|/ a |>\n<| c |>\nI like this solution, but it\
    \ will fail to give the correct result for \"((())())\" due to the unbalanced\
    \ parentheses in the input.\n<|/ c |>\n<| c |>\nYes, it will. Fixed.\n<|/ c |>\n\
    <| c |>\nSorry for the very late response. It works perfectly. Thanks!\n<|/ c\
    \ |>\n<| a tags=parsing,python,algorithm,c++,parentheses |>\nHere is a solution\
    \ using stacks:\n<code>\n// Function to parse nested parentheses string\n// Returns\
    \ highest number of nested parentheses\nlong paren(string input) {\n    int stack\
    \ = 0;\n    stack = paren_count(input, stack); // Count opening parens\n    if\
    \ (stack == 0) return 0;\n    stack = paren_count(input, stack); // Count closing\
    \ parens\n    return stack;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmlshe7f7.d(17): Error: found `>` when expecting `.` following long

    /tmp/tmpmlshe7f7.d(20): Error: no identifier for declarator `s`

    /tmp/tmpmlshe7f7.d(20): Error: expression expected, not `:`

    /tmp/tmpmlshe7f7.d(20): Error: found `paren_string` when expecting `;` following
    `for` condition

    /tmp/tmpmlshe7f7.d(38): Error: lower case integer suffix ''l'' is not allowed.
    Please use ''L'' instead

    /tmp/tmpmlshe7f7.d(43): Error: declaration expected, not `<`

    /tmp/tmpmlshe7f7.d(61): Error: no identifier for declarator `stack`

    /tmp/tmpmlshe7f7.d(61): Error: declaration expected, not `=`

    /tmp/tmpmlshe7f7.d(62): Error: declaration expected, not `if`

    /tmp/tmpmlshe7f7.d(63): Error: no identifier for declarator `stack`

    /tmp/tmpmlshe7f7.d(63): Error: declaration expected, not `=`

    /tmp/tmpmlshe7f7.d(64): Error: declaration expected, not `return`

    /tmp/tmpmlshe7f7.d(65): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmlshe7f7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tstring\
    \ paren_groups[] =paren_string.split(\" \");\n\tlong result[] = new long[paren_groups.length];\n\
    \tlong depths[] = new long[paren_groups.length];\n\tint index = 0;\n\tfor(int\
    \ i = 0; i < paren_groups.length; i++) {\n\t\tif (paren_groups[i].length()>0)\
    \ {\n\t\t\tdepths[index] = parse_nested_parens(paren_groups[i]);\n\t\t\tindex++;\n\
    \t\t} else {\n\t\t\tresult[i] = depths[paren_groups.length - i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n*/\nlong parse_nested_parens(string paren_string)\n{\n\t\
    long result = 0;\n\tstring paren_groups[] = paren_string.split(\" \");\n\tlong\
    \ depths[] = new long[paren_groups.length];\n\tfor (int i = 0; i < paren_groups.length;\
    \ i++)\n\t{\n\t\tif (paren_groups[i].length() > 0) {\n\t\t\tdepths[i] = parse_nested_parens(paren_groups[i]);\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tdepths[i] = 1;\n\t\t}\n\t\tresult += depths[i];\n\
    \t}\n\treturn result;\n}\n/*\n Given a string representation of nested parentheses,\
    \ return the maximum number of levels of nesting.\n    The string must be represented\
    \ with parentheses, e.g. (()) and must include at least one space between each\
    \ group of parenthesis.\n    Valid parenthesis are those containing only non-nested\
    \ parenthesis or a single nesting level.\n    \n    >>> parse_max_nesting(\"((()))\"\
    )\n    1\n    >>> parse_max_nesting(\"((()))(\")\n    1\n    >>> parse_max_nesting(\"\
    ((()) ())\")\n    2\n    >>> parse_max_nesting(\"((()) (((())((())))\"))\n   \
    \ 3\n    >>> parse_max_nesting(\"((()))(()((())())())()\")\n    5\n    \n*/\n\
    long parse_max_nesting(string paren_string) {\n\tlong max_nesting = 1;\n\tstring\
    \ paren_groups[] = paren_string.split(\" \");\n\tfor (int i = 0; i < paren_groups.length;\
    \ i++) {\n\t\tif (paren_groups[i].length() > 0)\n\t\t{\n\t\t\tlong current_nesting\
    \ = parse_nested_parens(paren_groups[i]);\n\t\t\tmax_nesting = max(max_nesting,\
    \ current_nesting);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmax_nesting++;\n\t\t}\n\t}\n\
    \treturn max_nesting;\n}\n/*\n Given a string representation of nested parentheses,\
    \ return a string representing the deepest level of nesting.\n    The string must\
    \ be represented with parentheses, e.g. (()) and must include at least one space\
    \ between each group of parenthesis.\n    Valid parenthesis are those containing\
    \ only non-nested parenthesis or \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp313zq8ua.d(14): Deprecation: instead of C-style syntax, use D-style
    syntax `string[] paren_groups`

    /tmp/tmp313zq8ua.d(15): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] result`

    /tmp/tmp313zq8ua.d(16): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] depths`

    /tmp/tmp313zq8ua.d(28): Error: declaration expected, not `*`

    /tmp/tmp313zq8ua.d(32): Deprecation: instead of C-style syntax, use D-style syntax
    `string[] paren_groups`

    /tmp/tmp313zq8ua.d(33): Deprecation: instead of C-style syntax, use D-style syntax
    `long[] depths`

    /tmp/tmp313zq8ua.d(34): Error: declaration expected, not `for`

    /tmp/tmp313zq8ua.d(34): Error: no identifier for declarator `i`

    /tmp/tmp313zq8ua.d(34): Error: declaration expected, not `<`

    /tmp/tmp313zq8ua.d(34): Error: no identifier for declarator `i`

    /tmp/tmp313zq8ua.d(34): Error: declaration expected, not `++`

    /tmp/tmp313zq8ua.d(38): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp313zq8ua.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    if (paren_string\
    \ == \"\") return long.Zero;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4dhe304r.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4dhe304r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ current_level = 0;\n    long[] current_nesting = new long[paren_string.length()];\n\
    \    for(int i = 0; i< paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            current_level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            if(current_level == 0)\n            {\n    \
    \            throw new Exception(\"Error parsing nested parentheses\");\n    \
    \        }\n            else\n            {\n                current_level--;\n\
    \            }\n        }\n        else\n        {\n            if(current_level\
    \ == 0)\n            {\n                current_nesting[i] = current_level;\n\
    \            }\n            else\n            {\n                throw new Exception(\"\
    Error parsing nested parentheses\");\n            }\n        }\n    }\n    return\
    \ current_nesting;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1_lxyfnu.d(15): Error: no property `length` for type `string`

    /tmp/tmp1_lxyfnu.d(16): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1_lxyfnu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    if(paren_string.length()\
    \ == 0) return null;\n    long level = 0;\n    stack<long> openParenStack;\n \
    \   openParenStack.push(0);\n    long openParenCount = 1;\n    for(size_t i =\
    \ 0, imax = paren_string.length(); i < imax; ++i)\n    {\n        char c = paren_string[i];\n\
    \        if(c == '(') openParenCount++;\n        else if(c == ')')\n        {\n\
    \            long parenLevel = openParenStack.top();\n            openParenStack.pop();\n\
    \            openParenCount -= 1;\n            if(openParenCount == parenLevel)\
    \ level += 1;\n        }\n        else openParenCount = 0;\n        if(openParenCount\
    \ != 0) openParenStack.push(openParenCount);\n    }\n    if(openParenStack.empty())\
    \ level = 0;\n    return long[level];\n}\n/*\n Takes a string of the form \"(A)(B(C))(D)\"\
    \n    and returns the corresponding string \"ABCD\" representing the concatenation\
    \ of all characters in each group.\n    E.g. \"((()))\" yields \"ABCD\"\n    \n\
    \    >>> parse_concatenated_parens(\"((()))\")\n    \"ABCD\"\n*/\nstring parse_concatenated_parens(string\
    \ paren_string)\n{\n    long[] nestedLevels = parse_nested_parens(paren_string);\n\
    \    string result = \"\";\n    for(size_t i = 0, imax = paren_string.length();\
    \ i < imax; ++i)\n    {\n        char c = paren_string[i];\n        if(c == '(')\
    \ result += nestedLevels[paren_string.find('(', i)] + nestedLevels[paren_string.find('(',\
    \ i+1)];\n        else result += c;\n    }\n    return result;\n}\n/*\n Takes\
    \ a string of the form \"ABCD\" representing the concatenation of all characters\
    \ in each group\n    and returns the corresponding string \"(A)(B)(C)(D)\"\n \
    \   E.g. \"ABCD\" yields \"(A)(B)(C)(D)\"\n    \n    >>> parse_concatenated_parens(\"\
    ABCD\")\n    \"((()))\"\n*/\nstring parse_concatenated_parens_back(string concatenated_string)\n\
    {\n    if(concatenated_string.length() == 0) return \"\";\n    char current =\
    \ concatenated_string[0];\n    string result = \"\";\n    for(size_t i = 0, imax\
    \ = concatenated_string.length(); i < imax; ++i)\n    {\n        char c = concatenated_string[i];\n\
    \        if(c == '(')\n        {\n            char nextChar = concatenated_string[i+1];\n\
    \            if(current == '(' && nextChar == '(') result += current;\n      \
    \      else if(current == '(' && nextChar == ')\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptvi37piv.d(16): Error: found `>` when expecting `.` following long

    /tmp/tmptvi37piv.d(34): Error: found `[` when expecting `.` following long

    /tmp/tmptvi37piv.d(34): Error: found `]` when expecting `;` following `return`
    statement

    /tmp/tmptvi37piv.d(34): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmptvi37piv.d(76): Error: unterminated character constant

    /tmp/tmptvi37piv.d(77): Error: found `unittest` when expecting `)`

    /tmp/tmptvi37piv.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmptvi37piv.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmptvi37piv.d(85): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptvi37piv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stringstream\
    \ ss;\n    string paren_contents;\n    long num_parentheses = 0;\n    long max_parentheses\
    \ = -1L;\n    long parentheses_level = 1;\n    long parentheses_levels[64]; //64\
    \ long array\n    for(auto c : paren_string)\n    {\n        if(c == '(')\n  \
    \      {\n            parentheses_levels[num_parentheses]++;\n        }\n    \
    \    else if (c == ')')\n        {\n            parentheses_levels[num_parentheses]--;\n\
    \        }\n        parentheses_levels[num_parentheses] = parentheses_level;\n\
    \        num_parentheses++;\n        if(num_parentheses > max_parentheses)\n \
    \       {\n            max_parentheses = num_parentheses;\n        }\n    }\n\
    \    long max_level = max_parentheses;\n    for(long i = 0; i <= max_parentheses;\
    \ i++)\n    {\n        if(parentheses_levels[i] > max_level)\n        {\n    \
    \        max_level = parentheses_levels[i];\n        }\n    }\n    long[] parentheses_levels_array\
    \ = new long[max_level + 1];\n    long level = 1;\n    for(long i = 0; i <= max_parentheses;\
    \ i++)\n    {\n        if(parentheses_levels[i] > level)\n        {\n        \
    \    parentheses_levels_array[level] = parentheses_levels[i];\n            level++;\n\
    \        }\n    }\n    long result = 0;\n    for(long i = 0; i <= max_level; i++)\n\
    \    {\n        result += parentheses_levels_array[i];\n    }\n    parentheses_levels_array[0]\
    \ = 0;\n    for(long i = 0; i <= max_level; i++)\n    {\n        parentheses_levels_array[i]\
    \ = parentheses_levels_array[i] > 0 ? parentheses_levels_array[i] : 1;\n    }\n\
    \    return parentheses_levels_array;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprjlqlumk.d(19): Deprecation: instead of C-style syntax, use D-style
    syntax `long[64] parentheses_levels`

    /tmp/tmprjlqlumk.d(20): Error: no identifier for declarator `c`

    /tmp/tmprjlqlumk.d(20): Error: expression expected, not `:`

    /tmp/tmprjlqlumk.d(20): Error: found `paren_string` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprjlqlumk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<int>\
    \ parenStack;\n    string parens = paren_string;\n    string nested;\n    int\
    \ numberOfNested = 0;\n    int lastSpace = 0;\n    bool foundNewLine = false;\n\
    \    bool foundEndParentheses = false;\n    bool foundEndParentheses = false;\n\
    \    int parenthesisOpenCount = 0;\n    int parenthesisClosedCount = 0;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpymwtebba.d(14): Error: found `>` when expecting `.` following int

    /tmp/tmpymwtebba.d(24): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpymwtebba.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    int i = 0;\n    while (i < paren_string.length())\n\
    \    {\n        int j = paren_string.find(\"( )\", i);\n        if (j == string::npos)\n\
    \        {\n            levels[i] = j;\n            i = paren_string.find(' ',\
    \ i);\n        }\n        else \n        {\n            levels[i] = j;\n     \
    \       i = paren_string.find(' ', j + 1);\n        }\n    }\n    return levels;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpk4mgojax.d(19): Error: found `:` when expecting `)`

    /tmp/tmpk4mgojax.d(19): Error: found `:` instead of statement

    /tmp/tmpk4mgojax.d(24): Error: found `else` without a corresponding `if`, `version`
    or `debug` statement

    /tmp/tmpk4mgojax.d(29): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpk4mgojax.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.Length];\n    char c;\n    int i;\n    int level\
    \ = 1;\n    int open = 0;\n    int close = 0;\n    int levels_left = 0;\n    bool\
    \ has_levels = false;\n    \n    // count number of left parentheses to decide\
    \ number of levels\n    for (i = 0; i <= paren_string.Length - 2; i++) {\n   \
    \     c = paren_string[i];\n        if (c == '(') open++;\n        if (c == ')')\
    \ close++;\n    }\n    has_levels = open > close;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa39c2n7n.d(30): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa39c2n7n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tint[]\
    \ result = new int[paren_string.length()];\n\tStack<int> paren_stack = new Stack<int>();\n\
    \t\n\tfor (int i = 0; i < paren_string.length(); i++) {\n\t\tif (paren_string[i]\
    \ == '(') paren_stack.push(i);\n\t\telse if (paren_string[i] == ')') {\n\t\t\t\
    int j = paren_stack.top();\n\t\t\tparen_stack.pop();\n\t\t\twhile (paren_stack.size()\
    \ > 1 && paren_stack.pop() == j) --j;\n\t\t\tresult[i] = j;\n\t\t}\n\t}\n\treturn\
    \ result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphvw9qadi.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmphvw9qadi.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmphvw9qadi.d(15): Error: found `(` when expecting identifier following `int`.

    /tmp/tmphvw9qadi.d(15): Error: found `)` when expecting `;` following statement

    /tmp/tmphvw9qadi.d(15): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphvw9qadi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<string>\
    \ opens, closes;\n    string currOpen, currClose, currNestingGroup;\n    long\
    \ numOpeningGroups = 0;\n    long numClosingGroups = 0;\n    long numNestingGroups\
    \ = 0;\n    bool inOpen = false;\n    bool inClose = false;\n    for(long i =\
    \ 0; i < paren_string.length(); i++) \n    {\n        char c = paren_string.at(i);\n\
    \        string openClose;\n        if(inOpen)\n        {\n            openClose\
    \ = opens.top();\n            inOpen = false;\n            opens.pop();\n    \
    \        if(openClose.empty()) \n            {\n                if(inClose)\n\
    \                    throw new Exception(\"Unbalanced parenthesis\");\n      \
    \          else if(opens.top().empty())\n                    throw new Exception(\"\
    Unbalanced parenthesis\");\n                else\n                    currOpen\
    \ = opens.top();\n                currNestingGroup = openClose;\n            \
    \    numOpeningGroups++;\n            }\n        }\n        else if(inClose)\n\
    \        {\n            openClose = closes.top();\n            inClose = false;\n\
    \            closes.pop();\n            currClose = closes.top();\n          \
    \  numClosingGroups++;\n        }\n        else \n        {\n            if(c\
    \ == '(')\n                opens.push(currNestingGroup = c + \"(\");\n       \
    \     else if(inOpen)\n                throw new Exception(\"Unbalanced parenthesis\"\
    );\n            else if(c == ')')\n            {\n                opens.push(currNestingGroup\
    \ = currNestingGroup + \")\");\n                numNestingGroups++;\n        \
    \        if(opens.top().empty())\n                    throw new Exception(\"Unbalanced\
    \ parenthesis\");\n                else\n                    currNestingGroup\
    \ = opens.top();\n            }\n            else if(c == '(' || c == ')')\n \
    \           {\n                opens.push(currNestingGroup + c);\n           \
    \     numNestingGroups++;\n            }\n            else if(numOpeningGroups\
    \ == 0 && c == ' ')\n            {\n                inOpen = true;\n         \
    \   }\n            else if(numOpeningGroups > 0 && c == ' ')\n            {\n\
    \                inOpen = true;\n            }\n            else if(numClosingGroups\
    \ > 0 && c == ' ')\n            {\n                inClose = true;\n         \
    \   }\n            else if(c == '(')\n            {\n                opens.push(currNestingGroup\
    \ = c + \"(\");\n                numOpeningGroups++;\n            }\n        \
    \    else if(c == ')')\n            {\n                closes.push(currNestingGroup\
    \ = currNestingGroup + \")\");\n                numClosingGroup\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp88buieab.d(14): Error: found `>` when expecting `;` following statement

    /tmp/tmp88buieab.d(91): Error: found `unittest` when expecting `;` following statement

    /tmp/tmp88buieab.d(99): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp88buieab.d(99): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp88buieab.d(99): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp88buieab.d(99): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp88buieab.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tstring\
    \ s = paren_string;\n\tlong[] levels = new long[paren_string.length()];\n\tint\
    \ paren_level = 0;\n\tfor (int i = 0; i < paren_string.length(); i++) {\n\t\t\
    if (s[i] == '(') {\n\t\t\tif (paren_level < levels[paren_level]) {\n\t\t\t\tlevels[paren_level]\
    \ = paren_level;\n\t\t\t}\n\t\t\tparen_level++;\n\t\t}\n\t\telse if (s[i] == ')')\
    \ {\n\t\t\tparen_level--;\n\t\t}\n\t}\n\treturn levels;\n}\n/*\n Input to this\
    \ function is a string represented multiple groups for nested parentheses separated\
    \ by spaces.\n    For each of the group, output the deepest level of nesting of\
    \ parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((()))\
    \ has three.\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsuvdlhas.d(30): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsuvdlhas.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ max_levels = new long[paren_string.length()];\n\tlong[] levels = new long[paren_string.length()];\n\
    \tstack<long> stack = new stack<long>();\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3zju5u8d.d(16): Error: found `>` when expecting `.` following long

    /tmp/tmp3zju5u8d.d(16): Error: found `>` when expecting `.` following long

    /tmp/tmp3zju5u8d.d(16): Error: found `(` when expecting identifier following `long`.

    /tmp/tmp3zju5u8d.d(16): Error: found `)` when expecting `;` following statement

    /tmp/tmp3zju5u8d.d(16): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp3zju5u8d.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3zju5u8d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int[]\
    \ max_level = new int[paren_string.length()];\n    int[] number_of_open_braces\
    \ = new int[paren_string.length()];\n    int level = 0;\n    long max_level_value\
    \ = 0;\n    for(int i = 0; i < paren_string.length(); i++) {\n        switch(paren_string[i])\
    \ {\n            case ')': \n                if(level == max_level[i - number_of_open_braces[i]])\n\
    \                    max_level_value = level;\n                level--;\n    \
    \            break;\n            case '(':\n                level++;\n       \
    \         number_of_open_braces[i]++;\n                break;\n        }\n   \
    \ }\n    max_level_value = max(max_level_value, level);\n    return max_level_value;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=parsing,language-agnostic,parentheses,python,c#\
    \ |>\nI like Hamlet and Eric's solutions, but I've been working on a JavaScript\
    \ solution for some time now:\n<code>\nfunction parseParens(s) {\n  var len =\
    \ s.length;\n  var stack = [];\n  var res = [];\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjoi3mxnz.d(34): Error: declaration expected, not `<`

    /tmp/tmpjoi3mxnz.d(37): Error: unterminated character constant

    /tmp/tmpjoi3mxnz.d(37): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjoi3mxnz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ level = 0;\n    long max_level = 0;\n    bool first_level_open = false;\n  \
    \  bool second_level_open = false;\n    bool last_level_open = false;\n    string\
    \ token = \"\";\n    string open = paren_string[0];\n    string close = paren_string[paren_string.length-1];\n\
    \    foreach(char c in paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            if(!first_level_open)\n            {\n                first_level_open\
    \ = true;\n                level++;\n            }\n        }\n        else if(c\
    \ == ')')\n        {\n            if(!second_level_open)\n            {\n    \
    \            second_level_open = true;\n                level--;\n           \
    \ }\n            else if(last_level_open)\n            {\n                level--;\n\
    \            }\n        }\n        else if(c == '(')\n        {\n            if(!last_level_open)\n\
    \            {\n                last_level_open = true;\n                level++;\n\
    \            }\n        }\n        else\n        {\n            if(!last_level_open)\n\
    \            {\n                last_level_open = true;\n                level++;\n\
    \            }\n        }\n        if(!first_level_open && !second_level_open\
    \ && level > max_level)\n        {\n            max_level = level;\n        }\n\
    \        if(!first_level_open && second_level_open && level > max_level)\n   \
    \     {\n            max_level = level;\n        }\n        token += c;\n    }\n\
    \    \n    return long[max_level, level];\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa67ce95m.d(22): Error: found `in` when expecting `;`

    /tmp/tmpa67ce95m.d(71): Error: found `[` when expecting `.` following long

    /tmp/tmpa67ce95m.d(71): Error: found `]` when expecting `;` following `return`
    statement

    /tmp/tmpa67ce95m.d(71): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa67ce95m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ level = 0;\n    stack<int> s;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfxsibebi.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmpfxsibebi.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfxsibebi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  int size\
    \ = paren_string.length();\n  long[] nlevels = new long[size];\n  nlevels[size\
    \ - 1] = paren_string.length();\n  int i = size - 2;\n  while (i >= 0) {\n   \
    \ string paren = paren_string.substring(i, i + 1);\n    string next_paren = paren_string.substring(i\
    \ + 1, i + 2);\n    if (paren == \"(\") {\n      nlevels[i] = parse_nested_parens(next_paren);\n\
    \    } else if (paren == \")\") {\n      if (nlevels[i + 1] != parse_nested_parens(next_paren))\n\
    \        throw runtime_error(\"unmatched \")\" in string{paren_string.c_str()});\n\
    \      nlevels[i] = nlevels[i + 1];\n    } else {\n      throw runtime_error(\"\
    unrecognized parentheses in string{\" + paren_string.c_str()+\"}\");\n    }\n\
    \    i--;\n  }\n  return nlevels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpndxn14ak.d(25): Error: found `" in string{paren_string.c_str()});\x0a      nlevels[i]
    = nlevels[i + 1];\x0a    } else {\x0a      throw runtime_error("` when expecting
    `;` following `throw` statement

    /tmp/tmpndxn14ak.d(28): Error: semicolon expected, not `in`

    /tmp/tmpndxn14ak.d(28): Error: found `in` instead of statement

    /tmp/tmpndxn14ak.d(38): Error: expression expected, not `)`

    /tmp/tmpndxn14ak.d(38): Error: expression expected, not `)`

    /tmp/tmpndxn14ak.d(38): Error: expression expected, not `)`

    /tmp/tmpndxn14ak.d(38): Error: found `") == [2L, 3L, 1L, 3L]);\x0a    assert(candidate("`
    when expecting `,`

    /tmp/tmpndxn14ak.d(39): Error: expression expected, not `)`

    /tmp/tmpndxn14ak.d(39): Error: expression expected, not `)`

    /tmp/tmpndxn14ak.d(39): Error: expression expected, not `)`

    /tmp/tmpndxn14ak.d(39): Error: expression expected, not `)`

    /tmp/tmpndxn14ak.d(39): Error: found `") == [1L, 2L, 3L, 4L]);\x0a    assert(candidate("`
    when expecting `,`

    /tmp/tmpndxn14ak.d(40): Error: unterminated string const'
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tauto brackets\
    \ = paren_string.find_first_of(\"()\");\n\tint cur_level = 1;\n\tauto cur_end\
    \ = paren_string.find(\")\", brackets);\n\tstring cur_group = \"\";\n\tfor (auto\
    \ i = brackets; i < paren_string.length(); ++i) {\n\t\tif (paren_string[i] ==\
    \ '(') cur_level ++;\n\t\telse cur_level --;\n\t\tif (cur_level == 0) cur_end\
    \ = i;\n\t\tcur_group += paren_string[i];\n\t}\n\tassert(brackets < paren_string.length());\n\
    \tassert(cur_end != paren_string.length());\n\tauto max_level = (paren_string.find_first_of(\"\
    )\", brackets) - brackets);\n\tlong[] cur_levels = new long[max_level + 1];\n\t\
    long[] cur_groups = new long[max_level + 1];\n\tcur_groups[max_level] = cur_group.length();\n\
    \tcur_levels[max_level] = cur_level;\n\tfor (auto i = brackets; i < paren_string.length();\
    \ ++i) {\n\t\tif (paren_string[i] == '(') {\n\t\t\tcur_level ++;\n\t\t\tcur_group\
    \ += paren_string[i];\n\t\t}\n\t\telse if (paren_string[i] == ')') {\n\t\t\tcur_level\
    \ --;\n\t\t}\n\t\telse if (paren_string[i] == '(') {\n\t\t\tcur_level ++;\n\t\t\
    }\n\t\telse if (paren_string[i] == ')') {\n\t\t\tcur_level --;\n\t\t}\n\t\tcur_groups[cur_level]\
    \ = cur_group.length();\n\t\tcur_levels[cur_level] = cur_level;\n\t}\n\tassert(cur_groups[max_level]\
    \ == cur_group.length());\n\treturn cur_levels;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpba044tkf.d(14): Error: no property `find_first_of` for type `string`

    /tmp/tmpba044tkf.d(16): Error: no property `find` for type `string`

    /tmp/tmpba044tkf.d(18): Error: no property `length` for type `string`

    /tmp/tmpba044tkf.d(24): Error: no property `length` for type `string`

    /tmp/tmpba044tkf.d(25): Error: no property `length` for type `string`

    /tmp/tmpba044tkf.d(26): Error: no property `find_first_of` for type `string`

    /tmp/tmpba044tkf.d(31): Error: no property `length` for type `string`

    /tmp/tmpba044tkf.d(45): Error: no property `length` for type `string`

    /tmp/tmpba044tkf.d(48): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpba044tkf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ parens = \"()\";\n    string stack = \"()\";\n    long n = 0;\n    \n    for(int\
    \ i = 0; i != paren_string.length(); ++i) {\n        if(paren_string[i] == parens[0])\
    \ {\n            stack = stack + parens[0];\n        } else {\n            n =\
    \ max(n, stack.size());\n            stack = stack + parens[i];\n        }\n \
    \   }\n    \n    return Vector.<long>(n).map(stack -> stack.size());\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiq95tu9z.d(27): Error: identifier expected following `.`, not `<`

    /tmp/tmpiq95tu9z.d(27): Error: found `long` when expecting `;` following `return`
    statement

    /tmp/tmpiq95tu9z.d(27): Error: found `>` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiq95tu9z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    \n \
    \   int[] levels = new int[paren_string.length()];\n    bool has_closed = false;\n\
    \    int  cur_level = 0;\n    long max_level = 0;\n    \n    int open = 0;\n \
    \   int close = 0;\n    int index = 0;\n    int parens = 0;\n    bool is_first\
    \ = true;\n    \n    for(int i = 0; i < paren_string.length(); i++, index++) {\n\
    \        char c = paren_string[index];\n        \n        // is closing a parenthesis\n\
    \        if(c == '(') {\n            open++;\n            \n            // has\
    \ this a closing parenthesis within previous parenthesises?\n            if(open\
    \ > 1 && close > 0) {\n                \n                levels[parens] += max_level;\n\
    \                \n                // is this the first parenthesis in this group\n\
    \                if(is_first) {\n                    max_level = parens;\n   \
    \             }\n            }\n            \n            // is this a new parenthesis\
    \ group?\n            if(open > 1) {\n                \n                parens++;\n\
    \            }\n            \n            open--;\n        }\n        \n     \
    \   // is this a closing parenthesis?\n        else if(c == ')') {\n         \
    \   close++;\n            \n            // has this a closing parenthesis within\
    \ previous parenthesises?\n            if(open > 1 && close > 0) {\n         \
    \       \n                levels[parens] += max_level;\n                \n   \
    \             // is this the last parenthesis in this group?\n               \
    \ if(parens == levels[parens] - 1) {\n                    max_level = parens -\
    \ 1;\n                }\n                \n            }\n            \n     \
    \       // is this a new parenthesis group?\n            if(close > 1) {\n   \
    \             \n                parens--;\n            }\n            \n     \
    \       close--;\n        }\n        \n        // is this a new parenthesis group?\n\
    \        else if(c == ' ') {\n            levels[parens] = 0;\n            \n\
    \            parens++;\n        }\n        \n        // is this another type of\
    \ parenthesis\n        else if(open == 0 && close == 0) {\n            levels[parens]++;\n\
    \        }\n        \n        // is this a close parenthesis?\n        else if(c\
    \ == '\\n') {\n            \n            // has this a closing parenthesis within\
    \ previous parenthesises?\n            if(open > 1 && close > 0) {\n         \
    \       \n                levels[parens] += max_level;\n                \n   \
    \             // is this the last parenthesis in this group?\n               \
    \ if(parens == levels[parens] - 1) {\n                    max_level = parens -\
    \ 1;\n                }\n                \n            }\n            \n     \
    \       // is this a new parenthesis group?\n            if(open > 1) {\n    \
    \            \n                parens++;\n            }\n            \n      \
    \      open--;\n            close--;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5gdgab_9.d(113): Error: found `unittest` instead of statement

    /tmp/tmp5gdgab_9.d(121): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp5gdgab_9.d(121): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5gdgab_9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    int level = 0;\n    int pos =\
    \ 0;\n    while((pos = paren_string.IndexOf('(', pos)) != -1)\n    {\n       \
    \ int start = paren_string.IndexOf('(', pos);\n        int end = paren_string.IndexOf(')',\
    \ pos);\n        if(end == -1)\n            end = paren_string.Length;\n     \
    \   string part = paren_string.Substring(start, end - start);\n        result[level++]\
    \ = long.Parse(part);\n        pos = end;\n    }\n    return result;\n}\n</code>\n\
    <|/ a |>\n<| a tags=c#,algorithm,parsing |>\nYou can do this with Regex. I've\
    \ got an example of one solution here. I recommend looking up the Regex reference\
    \ for details about how to use it.\n<|/ a dscore=0 |>\n<| c |>\nThis only seems\
    \ to give one level of nesting. E.g. (()) has only one level of nesting while\
    \ ((())) has two.\n<|/ c |>\n<| c |>\nSorry - missed the second level.\n<|/ c\
    \ |>\n<| a tags=c#,algorithm,parsing |>\nI guess you need to build something like\
    \ this:\n<code>\n    static void Main(string[] args)\n    {\n        string input\
    \ = \"((())()) ((())) () ((())()())\";\n        List<String> tokens = input.Split('\
    \ ');\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1dguite4.d(29): Error: declaration expected, not `<`

    /tmp/tmp1dguite4.d(32): Error: unterminated character constant

    /tmp/tmp1dguite4.d(46): Error: no identifier for declarator `List`

    /tmp/tmp1dguite4.d(46): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1dguite4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.Length];\n    long prev_level = 0;\n    \n  \
    \  bool in_paren = false;\n    for(char c: paren_string)\n    {\n        if(!in_paren)\n\
    \        {\n            in_paren = true;\n            continue;\n        }\n \
    \       if(c == '(')\n        {\n            prev_level = prev_level + 1;\n  \
    \      }\n        else if(c == ')')\n        {\n            prev_level = prev_level\
    \ - 1;\n        }\n        else if(c == '\\\\')\n        {\n            prev_level\
    \ -= 2;\n            prev_level = prev_level % 4;\n            \n            //\
    \ check for odd number of (\n            if(prev_level == 0)\n            {\n\
    \                prev_level = 1;\n            }\n        }\n        else\n   \
    \     {\n            prev_level = 0;\n        }\n        result[result.Length\
    \ - prev_level] = result.Length - prev_level + 1;\n    }\n    \n    return result.Take(result.Length\
    \ - 1).ToArray();\n}\n</code>\nNote that this is slightly more complicated than\
    \ the one in \"Efficient parsing of nested parentheses in C++\", and uses a slightly\
    \ different algorithm that works more efficiently than the one in \"Efficient\
    \ parsing of nested parentheses in C++\". For this code to work as is, the string\
    \ to be parsed must be in the following format: \n(...)\nWhere ... can be any\
    \ sequence of '(', ')', '\\\\', or '()', with optional whitespace.\n<|/ a dscore=4\
    \ |>\n<| a dscore=3 tags=parsing,c#,parentheses,regex,nested |>\nI wrote a parser\
    \ for this type of thing for Ruby. I think it should be easy to convert it back\
    \ to C#, but here it is. I'm sure it can be simplified.\n<code>\n# Parse a string\
    \ and return the level of nesting.\n# An empty string returns zero.\n# Nested\
    \ parens are ignored.\n#\n# Example input strings:\n#   \"()\"\n#   \"( ( () )\
    \ )\"\n#   \"( ( () ) ( ) )\"\n#   \"( ( )) \"\n#   \"( ( ( ) ) ( ) )\"\n#   \"\
    ( ( ( ) ) ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )\
    \ ) ) )\"\n# \n# Example output values:\n#   0\n#   1\n#   3\n#   4\n#   0\n#\
    \   1\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplnsb8wcp.d(18): Error: semicolon expected, not `:`

    /tmp/tmplnsb8wcp.d(18): Error: expression expected, not `:`

    /tmp/tmplnsb8wcp.d(18): Error: found `paren_string` when expecting `;` following
    `for` condition

    /tmp/tmplnsb8wcp.d(53): Error: declaration expected, not `<`

    /tmp/tmplnsb8wcp.d(56): Error: unterminated character constant

    /tmp/tmplnsb8wcp.d(56): Error: unterminated character constant

    /tmp/tmplnsb8wcp.d(59): Error: unterminated character constant

    /tmp/tmplnsb8wcp.d(85): Error: declaration expected, not `assert`

    /tmp/tmplnsb8wcp.d(86): Error: declaration expected, not `assert`

    /tmp/tmplnsb8wcp.d(87): Error: declaration expected, not `assert`

    /tmp/tmplnsb8wcp.d(88): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplnsb8wcp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tint max_levels\
    \ = 0, levels = 0, current_level = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1lokg1zv.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1lokg1zv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ total = 0;\n    for (string s : paren_string.split(\"\\\\s\")) {\n        for\
    \ (string group : s.split(\"\\\\(\")) {\n            long level = parse_nested_parens(group);\n\
    \            total += level;\n        }\n        total += 1;\n    }\n    \n  \
    \  return total;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5w8h_mj6.d(15): Error: found `s` when expecting `;` following statement

    /tmp/tmp5w8h_mj6.d(15): Error: expression expected, not `:`

    /tmp/tmp5w8h_mj6.d(15): Error: found `paren_string` when expecting `;` following
    `for` condition

    /tmp/tmp5w8h_mj6.d(16): Error: found `group` when expecting `;` following statement

    /tmp/tmp5w8h_mj6.d(16): Error: expression expected, not `:`

    /tmp/tmp5w8h_mj6.d(16): Error: found `s` when expecting `;` following `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5w8h_mj6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  long level\
    \ = 0;\n  long maxLevel = 0;\n  int paren_count = 0;\n  int i = 0;\n  while(i<paren_string.length())\n\
    \  {\n    if(paren_string[i]=='(')\n      paren_count++;\n    else if(paren_string[i]==')')\n\
    \    {\n      paren_count--;\n      if(paren_count==0)\n        maxLevel = level;\n\
    \      level++;\n    }\n    i++;\n  }\n  long[] levels = new long[paren_count];\n\
    \  for(i=0; i<paren_count; i++)\n    levels[i] = maxLevel;\n  return levels;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThe solution is very close to what i am\
    \ looking for, thanks. However, the answer you provided has issues, in that it\
    \ doesn't give the correct output if the input is \"(((())))\". For this input,\
    \ your code outputs 2 instead of 3 when it should output 3.\n<|/ c |>\n<| c |>\n\
    It is not hard to adjust this code to meet your needs. Just use a counter `int\
    \ paren_count` and initialize it with `paren_count = 0;` inside `for`-loop of\
    \ `parse_nested_parens`. Then add another `if` statement to check `paren_count`\
    \ before incrementing `i`.\n<|/ c |>\n<| a |>\nThis is a problem from Project\
    \ Euler. Here is the solution I found. I did not see it at first. I found it by\
    \ looking at this answer:\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.List;\nimport java.util.Map;\nimport java.util.HashMap;\nimport\
    \ java.util.Set;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxwfv8ddw.d(36): Error: declaration expected, not `<`

    /tmp/tmpxwfv8ddw.d(39): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxwfv8ddw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<string>\
    \ paren_stack;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxlnd3wcb.d(14): Error: found `>` when expecting `;` following statement

    /tmp/tmpxlnd3wcb.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxlnd3wcb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tstring\
    \ s = paren_string;\n\tchar[] c = s.toCharArray();\n\tlong n = s.length();\n\t\
    long[] result = new long[n];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp52dtz7il.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp52dtz7il.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    char[]\
    \ parens_array = paren_string.toCharArray();\n    long max_level = 0;\n    long\
    \ cur_level = 0;\n    for(char c: parens_array)\n    {\n        if(!(c == '('\
    \ || c == '[' || c == '{' || c == '{'))\n        {\n            cur_level--;\n\
    \        }\n        else if(c == '(')\n        {\n            cur_level++;\n \
    \       }\n        else if(c == '[') \n        {\n            cur_level++;\n \
    \       }\n        else if(c == '{')\n        {\n            cur_level++;\n  \
    \      }\n        else if(c == '}') \n        {\n            cur_level--;\n  \
    \      }\n        max_level = max(cur_level, max_level);\n    }\n    long[] result\
    \ = new long[max_level+1];\n    for(char c: parens_array)\n    {\n        if(!(c\
    \ == '(' || c == '[' || c == '{' || c == '{'))\n        {\n            result[cur_level]\
    \ = cur_level;\n        }\n        else if(c == '(')\n        {\n            result[cur_level]\
    \ = cur_level;\n            cur_level++;\n        }\n        else if(c == '[')\
    \ \n        {\n            result[cur_level] = cur_level;\n            cur_level++;\n\
    \        }\n        else if(c == '{')\n        {\n            result[cur_level]\
    \ = cur_level;\n            cur_level++;\n        }\n        else if(c == '}')\
    \ \n        {\n            result[cur_level] = cur_level;\n            cur_level--;\n\
    \        }\n    }\n    return result ;\n}\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb6ap_zju.d(17): Error: semicolon expected, not `:`

    /tmp/tmpb6ap_zju.d(17): Error: expression expected, not `:`

    /tmp/tmpb6ap_zju.d(17): Error: found `parens_array` when expecting `;` following
    `for` condition

    /tmp/tmpb6ap_zju.d(42): Error: semicolon expected, not `:`

    /tmp/tmpb6ap_zju.d(42): Error: expression expected, not `:`

    /tmp/tmpb6ap_zju.d(42): Error: found `parens_array` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb6ap_zju.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  int open_bracket\
    \ = 0, closed_bracket = 0;\n  \n  stack<int> nesting;\n  stack<int> new_nesting;\n\
    \  \n  int max_depth = 0;\n  \n  for(int i = 0; paren_string[i] != '\\0'; i++)\n\
    \  {\n    \n    if(paren_string[i] == ')')\n    {\n      open_bracket--;\n   \
    \   \n      if(open_bracket == 0 && new_nesting.size() == 0)\n      {\n      \
    \  nesting.push(closed_bracket);\n        new_nesting.push(closed_bracket);\n\
    \        max_depth = nesting.size();\n      }\n      \n      closed_bracket++;\n\
    \      \n      if(nesting.size() > nesting.top())\n      {\n        int current_depth\
    \ = nesting.size() - 1;\n        int parent_depth = nesting.top() - 1;\n     \
    \   \n        if(current_depth > max_depth)\n        {\n          max_depth =\
    \ current_depth;\n        }\n        \n        if(parent_depth > max_depth)\n\
    \        {\n          max_depth = parent_depth;\n        }\n        \n       \
    \ if(parent_depth <= max_depth)\n        {\n          nesting.pop();\n       \
    \   new_nesting.push(current_depth);\n        }\n      }\n    }\n    else if(paren_string[i]\
    \ == '(')\n    {\n      open_bracket++;\n      \n      if(open_bracket == 0 &&\
    \ new_nesting.size() == 0)\n      {\n        nesting.push(closed_bracket);\n \
    \       new_nesting.push(closed_bracket);\n        max_depth = nesting.size();\n\
    \      }\n      \n      closed_bracket++;\n      \n      if(nesting.size() > nesting.top())\n\
    \      {\n        int current_depth = nesting.size() - 1;\n        int parent_depth\
    \ = nesting.top() - 1;\n        \n        if(current_depth > max_depth)\n    \
    \    {\n          max_depth = current_depth;\n        }\n        \n        if(parent_depth\
    \ > max_depth)\n        {\n          max_depth = parent_depth;\n        }\n  \
    \      \n        if(parent_depth <= max_depth)\n        {\n          nesting.pop();\n\
    \          new_nesting.push(current_depth);\n        }\n      }\n    }\n  }\n\
    \  \n  long[] result = new long[max_depth+1];\n  \n  for(int i = max_depth; i\
    \ >= 0; i--)\n  {\n    result[i] = new_nesting.size() - 1;\n  }\n  \n  return\
    \ result;\n}\n</code>\n<|/ a |>\n<| c |>\nThe code above is very simple and works\
    \ very well in most cases but there are two problems in some cases (such as \"\
    ((()\"))\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ko1mnzo.d(16): Error: found `>` when expecting `.` following int

    /tmp/tmp8ko1mnzo.d(17): Error: found `>` when expecting `.` following int

    /tmp/tmp8ko1mnzo.d(105): Error: declaration expected, not `<`

    /tmp/tmp8ko1mnzo.d(113): Error: declaration expected, not `assert`

    /tmp/tmp8ko1mnzo.d(114): Error: declaration expected, not `assert`

    /tmp/tmp8ko1mnzo.d(115): Error: declaration expected, not `assert`

    /tmp/tmp8ko1mnzo.d(116): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ko1mnzo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ n = paren_string.length();\n    long index = 0;\n    long[] level = new long[n];\n\
    \    long[] count = new long[n];\n    level[0] = count[0] = 1;\n    level[1] =\
    \ 1;\n    long max_level = 0;\n    \n    // Find the deepest level of nesting\n\
    \    while (index < n && paren_string[index] == ' ') {\n        ++index;\n   \
    \ }\n    while (index < n && paren_string[index] != ')') {\n        if (level[index]\
    \ < count[index]) {\n            level[index] = count[index];\n            ++max_level;\n\
    \        }\n        ++index;\n    }\n    \n    // Compute the output result\n\
    \    long[] result = new long[max_level];\n    long cur_level = level[0];\n  \
    \  for (long i = 1; i < max_level; ++i) {\n        long new_level = level[i];\n\
    \        result[cur_level - 1] = result[cur_level - 1] + new_level;\n        cur_level\
    \ = new_level;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqwsjo01f.d(14): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqwsjo01f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  string\
    \ current_paren_string;\n  string paren_group;\n  long max_level = 0;\n  int paren_level\
    \ = 1;\n  int i;\n  for(i = 0; i < paren_string.length; ++i) {\n    current_paren_string\
    \ = paren_string.substr(i, 1);\n    paren_group = paren_string.substr(i, paren_string.length-1);\n\
    \    if(paren_group.length==0) {\n      max_level = max_level * paren_level;\n\
    \      paren_level = 1;\n      --i;\n    } else if(paren_group.equals(\")\"))\
    \ {\n      max_level = max_level * paren_level;\n      ++paren_level;\n    } else\
    \ {\n      if(current_paren_string.length() > 0) {\n        string tmp_string\
    \ = current_paren_string;\n        while(!tmp_string.equals(\"(\") && !tmp_string.equals(\"\
    )\")) {\n          tmp_string = tmp_string.substr(0, tmp_string.length()-1);\n\
    \        }\n        if(tmp_string.equals(\"(\"))\n          max_level = max_level\
    \ * paren_level;\n        else\n          max_level = max_level / paren_level;\n\
    \      }\n      paren_level = 1;\n    }\n  }\n  return new long[max_level+1];\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcil04rs9.d(20): Error: no property `substr` for type `string`

    /tmp/tmpcil04rs9.d(21): Error: no property `substr` for type `string`

    /tmp/tmpcil04rs9.d(26): Error: no property `equals` for type `string`

    /tmp/tmpcil04rs9.d(30): Error: no property `length` for type `string`

    /tmp/tmpcil04rs9.d(32): Error: no property `equals` for type `string`

    /tmp/tmpcil04rs9.d(32): Error: no property `equals` for type `string`

    /tmp/tmpcil04rs9.d(33): Error: no property `substr` for type `string`

    /tmp/tmpcil04rs9.d(35): Error: no property `equals` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcil04rs9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int[]\
    \ levels = paren_string.find_parens(\"()\", paren_string);\n    long[] result\
    \ = new long[levels.length];\n    for (int i = 0; i < levels.length; i++)\n  \
    \      result[i] = levels[i];\n    return result;\n}\n</code>\n<|/ a dscore=4\
    \ tags=string,java,regex |>\n<| c |>\nThis does not answer the question at all,\
    \ it just uses another way to solve the problem and doesn't answer the question\
    \ at all. Also your solution is very similar to [this answer](http://stackoverflow.com/a/17875760/829571).\n\
    <|/ c |>\n<| c |>\nAm I missing something? This does not give the level of nesting\
    \ as asked by the OP. The level of nesting is only returned as a string. `[2,\
    \ 3, 1, 3]`.\n<|/ c |>\n<| c |>\nThe OP wrote \"for each of the group\" in the\
    \ question.\n<|/ c |>\n<| c |>\nI see what you mean. But then the question is\
    \ badly phrased. I think my solution is the best solution for this problem. I\
    \ think it solves the OP's problem as asked. The OP asked for \"output the deepest\
    \ level of nesting\". My solution does just that. \"output the deepest level of\
    \ nesting\".\n<|/ c |>\n<| c |>\nI'm sorry. I don't think this really answers\
    \ the question. The OP asked for \"for each of the group\".\n<|/ c |>\n<| a dscore=3\
    \ tags=string,java,regex |>\nI know this answer is already accepted, but I had\
    \ this exact question to solve and thought I'd post my solution anyways. I like\
    \ to use recursion and recursion is a nice feature that java can have.\n<code>\n\
    public static int getNestingLevel(String input){\n  if(input == null || input.length()\
    \ == 0)\n    return 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt9v57_7e.d(20): Error: declaration expected, not `<`

    /tmp/tmpt9v57_7e.d(23): Error: unterminated character constant

    /tmp/tmpt9v57_7e.d(32): Error: unterminated character constant

    /tmp/tmpt9v57_7e.d(35): Error: unterminated character constant

    /tmp/tmpt9v57_7e.d(35): Error: unterminated character constant

    /tmp/tmpt9v57_7e.d(38): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt9v57_7e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<int>\
    \ paren_levels;\n    paren_levels.push();\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4uv_vvg7.d(14): Error: found `>` when expecting `.` following int

    /tmp/tmp4uv_vvg7.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4uv_vvg7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string[]\
    \ paren_groups = paren_string.split(\" \");\n    long[] levels_of_nesting = new\
    \ long[paren_groups.length];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprugubgvt.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprugubgvt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    string s;\n    for(int i = 0;\
    \ i < paren_string.length(); i++) \n    {\n        s = paren_string.substr(i,\
    \ 1);\n        if(s == \")\")\n        {\n            levels[i] = levels[i-1]\
    \ + 1;\n        }\n        else if(s == \"(\")\n        {\n            levels[i]\
    \ = 0;\n        }\n        else\n        {\n            levels[i] = levels[i-1];\n\
    \        }\n    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplj9dsoey.d(14): Error: no property `length` for type `string`

    /tmp/tmplj9dsoey.d(16): Error: no property `length` for type `string`

    /tmp/tmplj9dsoey.d(18): Error: no property `substr` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplj9dsoey.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.Length];\n    int open = paren_string.IndexOf('(');\n\
    \    int close = paren_string.IndexOf(')');\n    int counter = 0;\n    for (int\
    \ i = 0; i < paren_string.Length; i++)\n    {\n        if (paren_string[i] ==\
    \ '(') \n        {\n            if (paren_string[open + counter] == ')') \n  \
    \          {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == ')') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == ')') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else\n            {\n                result[i] = open;\n\
    \                counter++;\n            }\n        }\n        else if (paren_string[i]\
    \ == ')') \n        {\n            if (paren_string[open + counter] == '(') \n\
    \            {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == '(') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == '(') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else\n            {\n                result[i] = open;\n\
    \                counter++;\n            }\n        }\n        else if (paren_string[i]\
    \ == ')') \n        {\n            if (paren_string[open + counter] == '(') \n\
    \            {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == '(') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == '(') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else\n            {\n                result[i] = open;\n\
    \                counter++;\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\nThe output is the maximum level of nesting for each group:\n<code>\n\
    public static long MaxNesting(string input)\n{\n    string result = null;\n  \
    \  long[] nesting_levels = ParseNestedParens(input);\n    for (int i = 0; i <\
    \ nesting_levels.Length; i++)\n    {\n        if (nesting_levels[i] > result)\
    \ result = nesting_levels[i];\n    }\n    return result;\n}\n</code>\nThe input\
    \ for the last example is:\n<code>\nstring input = \"(((()))())((((((((((()))()))))))))\"\
    ;\n</code>\nThe output of this function should be 6.\n<|/ a tags=c#,algorithm\
    \ |>\n<| c |>\nNice! Can you make some comments in your code?\n<|/ c |>\n<| c\
    \ |>\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe6ypde3t.d(92): Error: declaration expected, not `<`

    /tmp/tmpe6ypde3t.d(99): Error: declaration expected, not `for`

    /tmp/tmpe6ypde3t.d(99): Error: no identifier for declarator `i`

    /tmp/tmpe6ypde3t.d(99): Error: declaration expected, not `<`

    /tmp/tmpe6ypde3t.d(99): Error: no identifier for declarator `i`

    /tmp/tmpe6ypde3t.d(99): Error: declaration expected, not `++`

    /tmp/tmpe6ypde3t.d(102): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe6ypde3t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ nestings = new long[paren_string.length()];\n    long current_level;\n    for\
    \ (long i = 0; i < paren_string.length(); ++i) {\n        char c = paren_string[i];\n\
    \        if (c == '(' || c == '[') {\n            current_level = i;\n       \
    \ } else if (c == ')' || c == ']') {\n            nestings[current_level] = max(nestings[current_level],\
    \ i - current_level);\n        }\n    }\n    return nestings;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxov84iu_.d(14): Error: no property `length` for type `string`

    /tmp/tmpxov84iu_.d(16): Error: no property `length` for type `string`

    /tmp/tmpxov84iu_.d(21): Error: undefined identifier `max`, did you mean function
    `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxov84iu_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ paren_counts = new long[paren_string.length()];\n    long max_count = 1;\n \
    \   \n    foreach(char c in paren_string) {\n        int i = paren_string.indexOf(c,\
    \ 0);\n        paren_counts[i] = paren_counts[i] + 1;\n        if (paren_counts[i]\
    \ > max_count) {\n            max_count = paren_counts[i];\n        }\n    }\n\
    \    \n    long[] max_paren_level = new long[max_count + 1];\n    foreach(int\
    \ i in paren_counts) {\n        max_paren_level[i] = max_paren_level[i - 1];\n\
    \    }\n    \n    foreach(long l in max_paren_level) {\n        if (l == 0) {\n\
    \            l++;\n        }\n    }\n    \n    max_paren_level[max_count + 1]++;\n\
    \    max_paren_level[max_count]++;\n    \n    foreach(long l in max_paren_level)\
    \ {\n        if (l == 0) {\n            l++;\n        }\n    }\n    \n    return\
    \ max_paren_level;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is very similar\
    \ to the one above. I will try it out, thank you!\n<|/ c |>\n<| a tags=string,function,c#,recursion,parsing\
    \ |>\nHere is the answer, thank you for all suggestions and comments.\n<code>\n\
    public static long ParseString(string input)\n{\n    long output = 0;\n    Stack<long>\
    \ stack = new Stack<long>();\n    char[] parenthesis = new char[] { '(', ')' };\n\
    \    char[] brackets = new char[] { '{', '}' };\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgg8n8gps.d(17): Error: found `in` when expecting `;`

    /tmp/tmpgg8n8gps.d(26): Error: found `in` when expecting `;`

    /tmp/tmpgg8n8gps.d(30): Error: found `in` when expecting `;`

    /tmp/tmpgg8n8gps.d(39): Error: found `in` when expecting `;`

    /tmp/tmpgg8n8gps.d(47): Error: declaration expected, not `<`

    /tmp/tmpgg8n8gps.d(58): Error: no identifier for declarator `Stack`

    /tmp/tmpgg8n8gps.d(58): Error: declaration expected, not `<`

    /tmp/tmpgg8n8gps.d(59): Error: semicolon expected, not `{`

    /tmp/tmpgg8n8gps.d(59): Error: declaration expected, not `{`

    /tmp/tmpgg8n8gps.d(60): Error: semicolon expected, not `{`

    /tmp/tmpgg8n8gps.d(60): Error: declaration expected, not `{`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgg8n8gps.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t// parse\
    \ nested parens\n\tlong max_level = 0;\n\tchar[] parens = paren_string.toCharArray();\n\
    \tint n_parens = 0;\n\tfor (int i = 0; i < parens.length; ++i)\n\t{\n\t\tchar\
    \ c = parens[i];\n\t\tswitch(c)\n\t\t{\n\t\t\tcase '(':\n\t\t\t\t++n_parens;\n\
    \t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\t--n_parens;\n\t\t\t\tif (max_level <\
    \ n_parens) max_level = n_parens;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tlong[] results\
    \ = new long[max_level + 1];\n\tresults[0] = 0;\n\tfor (int i = 0; i < parens.length;\
    \ ++i)\n\t{\n\t\tchar c = parens[i];\n\t\tswitch(c)\n\t\t{\n\t\t\tcase '(':\n\t\
    \t\t\t++results[results[0]];\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\t--results[results[0]];\n\
    \t\t\t\tbreak;\n\t\t}\n\t}\n\treturn results;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpauwtukfn.d(16): Error: no property `toCharArray` for type `string`

    /tmp/tmpauwtukfn.d(21): Error: `switch` statement without a `default`; use `final
    switch` or add `default: assert(0);` or add `default: break;`

    /tmp/tmpauwtukfn.d(37): Error: `switch` statement without a `default`; use `final
    switch` or add `default: assert(0);` or add `default: break;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpauwtukfn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res = new long[paren_string.length()];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyihc5roy.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyihc5roy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    var\
    \ level = 0;\n    var deepest_level = 0;\n    for(int i=0;i<paren_string.size();i++)\
    \ {\n        if (paren_string[i] == '(') {\n            level++;\n        }\n\
    \        else if (paren_string[i] == ')') {\n            level--;\n        }\n\
    \        if (level > deepest_level) {\n            deepest_level = level;\n  \
    \      }\n    }\n    return new long[] { deepest_level + 1 };\n}\n</code>\n<|/\
    \ a tags=java,algorithm dscore=1 |>\n<| c |>\nthanks. can you please give a small\
    \ code sample of the algorithm?\n<|/ c |>\n<| c |>\nI've added an example in Java.\n\
    <|/ c |>\n<| c |>\nthanks for all the help. one more question - what is the significance\
    \ of the last line of code?\n<|/ c |>\n<| c |>\nI've added comments to the last\
    \ line of code explaining the purpose.\n<|/ c |>\n<| a tags=java,algorithm dscore=0\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\
    import java.util.Map;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl8nj04pk.d(27): Error: found `{` when expecting `;` following `return`
    statement

    /tmp/tmpl8nj04pk.d(27): Error: found `}` when expecting `;` following statement

    /tmp/tmpl8nj04pk.d(27): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpl8nj04pk.d(29): Error: declaration expected, not `<`

    /tmp/tmpl8nj04pk.d(35): Error: unterminated character constant

    /tmp/tmpl8nj04pk.d(41): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl8nj04pk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ current_level = 0;\n    int nested_level = paren_string.length();\n    long[]\
    \ levels = new long[nested_level];\n    string last_char_without_closing;\n  \
    \  char open_parenthesis = '(';\n    \n    for(int i = 0; i < levels.length; ++i)\n\
    \    {\n        last_char_without_closing = paren_string[i];\n        levels[i]\
    \ = 0;\n    }\n    \n    for(int i = nested_level - 1; i >= 0; --i)\n    {\n \
    \       int j = nested_level - 1 - i;\n        if (paren_string[j] == '(')\n \
    \       {\n            levels[i] = levels[j] + 1;\n        }\n        else if\
    \ (paren_string[j] == ')')\n        {\n            if (levels[j] == current_level)\n\
    \            {\n                levels[j] = 0;\n            }\n            else\n\
    \            {\n                levels[j] = levels[j] - 1;\n            }\n  \
    \      }\n        else if (paren_string[j] == ' ' && levels[j] != 0)\n       \
    \ {\n            levels[j] = 0;\n        }\n    }\n    \n    long[] ret_levels\
    \ = new long[levels.length];\n    for (int i = 0; i < levels.length; ++i)\n  \
    \  {\n        if (levels[i] > 0)\n        {\n            ret_levels[i] = levels[i];\n\
    \        }\n        else\n        {\n            ret_levels[i] = 0;\n        }\n\
    \    }\n    \n    return ret_levels;\n}\n</code>\n<|/ a dscore=1 tags=java,algorithm,c++,dynamic-programming\
    \ |>\n<| a dscore=1 |>\nI know I'm late to the party but I had a similar problem\
    \ and this is how I solved it:\n<code>\npublic static int maxNestings(String input)\
    \ {\n    if (input == null || input.length() == 0)\n        return 0;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfm4cezw4.d(65): Error: declaration expected, not `<`

    /tmp/tmpfm4cezw4.d(68): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfm4cezw4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tassert(paren_string.length()\
    \ >= 2);\n\tint level = 0;\n\tint max_level = paren_string.length();\n\tlong current_level;\n\
    \tint i = 0;\n\tstring current_opening = \"\";\n\tstring current_closing = \"\"\
    ;\n\tstring current_token = paren_string.substr(i, max_level - i);\n\tfor (; i\
    \ < max_level; ++i) \n\t{\n\t\tif (current_token == \")\") \n\t\t{\n\t\t\tassert(level\
    \ > 0);\n\t\t\tassert(level != current_level);\n\t\t\tcurrent_level--;\n\t\t\t\
    current_closing = \"\";\n\t\t}\n\t\telse if (current_token == \"(\") \n\t\t{\n\
    \t\t\tassert(level == 0);\n\t\t\tassert(level != current_level);\n\t\t\tcurrent_level++;\n\
    \t\t\tcurrent_opening = \"\";\n\t\t}\n\t\telse \n\t\t{\n\t\t\tassert(level !=\
    \ 0);\n\t\t\tassert(level == current_level);\n\t\t\tcurrent_closing += current_token;\n\
    \t\t}\n\t\tif (level == current_level) \n\t\t{\n\t\t\tassert(current_closing[0]\
    \ == current_opening[0]);\n\t\t\tcurrent_token = current_closing;\n\t\t\ti +=\
    \ current_closing.length();\n\t\t}\n\t\telse \n\t\t{\n\t\t\tcurrent_opening =\
    \ current_token;\n\t\t\ti += current_opening.length();\n\t\t\tcurrent_token =\
    \ paren_string.substr(i, max_level - i);\n\t\t}\n\t}\n\tassert(level == current_level);\n\
    \tassert(paren_string.length() == i);\n\tlong[] result = { 0 };\n\tfor (; i <\
    \ max_level; ++i)\n\t{\n\t\tlong opening = current_opening.length();\n\t\tcurrent_opening\
    \ = \"\";\n\t\tcurrent_closing = \"\";\n\t\tcurrent_token = paren_string.substr(i,\
    \ max_level - i);\n\t\tcurrent_level = 0;\n\t\tfor (; i < max_level; ++i) \n\t\
    \t{\n\t\t\tif (current_token == \")\") \n\t\t\t{\n\t\t\t\tassert(level > 0);\n\
    \t\t\t\tassert(level != current_level);\n\t\t\t\tcurrent_level--;\n\t\t\t\tcurrent_closing\
    \ = \"\";\n\t\t\t}\n\t\t\telse if (current_token == \"(\") \n\t\t\t{\n\t\t\t\t\
    assert(level == 0);\n\t\t\t\tassert(level != current_level);\n\t\t\t\tcurrent_level++;\n\
    \t\t\t\tcurrent_opening = \"\";\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tassert(level\
    \ != 0);\n\t\t\t\tassert(level == current_level);\n\t\t\t\tcurrent_closing +=\
    \ current_token;\n\t\t\t}\n\t\t\tif (level == current_level) \n\t\t\t{\n\t\t\t\
    \tassert(current_closing[0] == current_opening[0]);\n\t\t\t\tcurrent_token = current_closing;\n\
    \t\t\t\ti += current_closing.length();\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\t\
    current_opening = current_token;\n\t\t\t\ti += current_opening.length();\n\t\t\
    \t\tcurrent_token = paren_string.substr(i, max_level - i);\n\t\t\t}\n\t\t}\n\t\
    \tassert(level == current_level);\n\t\tassert(\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ym32gvm.d(104): Error: expression expected, not `unittest`

    /tmp/tmp_ym32gvm.d(105): Error: found `{` when expecting `)`

    /tmp/tmp_ym32gvm.d(106): Error: found `alias` when expecting `;` following statement

    /tmp/tmp_ym32gvm.d(112): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ym32gvm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ level = 1;\n    long max_level = 0;\n    long max_paren_level = 0;\n    long\
    \ paren_count = 0;\n    vector<long> paren_levels(paren_string.length(), max_level);\n\
    \    map<long, long> paren_to_max_level;\n    \n    for (long i = 0; i < paren_string.length();\
    \ ++i)\n    {\n        char ch = paren_string[i];\n        \n        if (ch ==\
    \ ')') // closing a parens\n        {\n            paren_levels[paren_count] =\
    \ level;\n            paren_count++;\n            \n            if (paren_count\
    \ > max_paren_level)\n                max_paren_level = paren_count;\n       \
    \     \n            if (paren_count == max_paren_level)\n            {\n     \
    \           if (paren_count > max_level)\n                    max_level = paren_count;\n\
    \                \n                // increment level to count next nested level\n\
    \                level++;\n            }\n        }\n        else if (ch == '(')\
    \ // opening another parens\n        {\n            level--;\n        }\n    \
    \    else if (ch == ' ')\n        {\n            if (paren_count == max_paren_level)\n\
    \            {\n                // We are at the deepest level\n             \
    \   paren_levels[paren_count] = level;\n            }\n        }\n    }\n    \n\
    \    long[] max_levels = { max_level };\n    \n    for (long i = 0; i < max_paren_level;\
    \ ++i)\n    {\n        long paren_level = paren_levels[i];\n        \n       \
    \ max_levels[max_paren_level - 1 - i] = paren_level;\n    }\n    \n    return\
    \ max_levels;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis was my first thought,\
    \ but I wonder how it handles nested parens which have different levels of nesting\
    \ (e.g. \"()()()\")\n<|/ c |>\n<| c |>\n: It will work, but as you can see, it\
    \ will be a lot more complicated. I'll try to write something more efficient.\n\
    <|/ c |>\n<| c |>\n: I've updated my answer with a more efficient version.\n<|/\
    \ c |>\n<| a |>\nA simple iterative function should do:\n<code>\ndef paren_levels(s):\n\
    \    level = 0\n    result = []\n    while s:\n        ch = s[0]\n        if ch\
    \ == ')':\n            level += 1\n            if level > len(result):\n     \
    \           result.append(level)\n        else:\n            if level == 0:\n\
    \                raise Exception('invalid input')\n            level -= 1\n  \
    \          \n        s, s = s[1:], s[1:]\n    return result\n</code>\n<|/ a tags=language-agnostic,recursion,algorithm\
    \ dscore=2 |>\n<| a tags=language-agnostic\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeks7ho18.d(18): Error: found `>` when expecting `.` following long

    /tmp/tmpeks7ho18.d(19): Error: found `,` when expecting `.` following long

    /tmp/tmpeks7ho18.d(19): Error: found `long` when expecting identifier following
    `long`.

    /tmp/tmpeks7ho18.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpeks7ho18.d(67): Error: declaration expected, not `<`

    /tmp/tmpeks7ho18.d(73): Error: unterminated character constant

    /tmp/tmpeks7ho18.d(76): Error: unterminated character constant

    /tmp/tmpeks7ho18.d(92): Error: unterminated character constant

    /tmp/tmpeks7ho18.d(92): Error: unterminated character constant

    /tmp/tmpeks7ho18.d(104): Error: declaration expected, not `assert`

    /tmp/tmpeks7ho18.d(105): Error: declaration expected, not `assert`

    /tmp/tmpeks7ho18.d(106): Error: declaration expected, not `assert`

    /tmp/tmpeks7ho18.d(107): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeks7ho18.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ s = paren_string;\n    Stack<long> stack;\n    stack.Push(0);\n    long current_level\
    \ = 0;\n    long level = 0;\n    long max_level = 0;\n    while (!stack.IsEmpty())\
    \ {\n        level = stack.Pop();\n        if (level > max_level) {\n        \
    \    max_level = level;\n        }\n        if (s.Length == 0) {\n           \
    \ stack.Push(level);\n            break;\n        }\n        long count = 0;\n\
    \        long brackets = 0;\n        string s_sub = s.Substring(0,s.Length-1);\n\
    \        while (s_sub.Length > 0) {\n            char ch = s_sub[0];\n       \
    \     if (ch == '(') brackets++;\n            if (ch == ')') brackets--;\n   \
    \         s_sub = s_sub.Substring(1);\n            count++;\n        }\n     \
    \   if (brackets == 0) current_level++;\n        if (brackets == 1 && level ==\
    \ 1) current_level--;\n        stack.Push(level + brackets);\n        s = s.Substring(s.Length-1);\n\
    \    }\n    long max_count = max_level + 1;\n    long[] ans = new long[max_count];\n\
    \    long current_pos = 0;\n    stack.Push(current_level);\n    while(!stack.IsEmpty())\
    \ {\n        level += stack.Pop();\n        ans[current_pos++] = level;\n    }\n\
    \    return ans;\n}\n/*\n This function takes an array of numbers represented\
    \ as a string and\n    returns a new string that has all the numbers with the\
    \ same value grouped together.\n    E.g. for numbers \"1, 3, 7, 8, 2, 5, 9\" the\
    \ function returns \"1, 7, 8\"\n    Note that in case of repetition of value the\
    \ function returns only the last group of repetition.\n    \n    Example 1:\n\
    \    >>> split_into_groups(\"1, 3, 7, 8, 2, 5, 9, 4, 1, 3\")\n    \"1, 7, 8, 2,\
    \ 5, 9, 4, 1, 3\"\n    \n    Example 2:\n    >>> split_into_groups(\"1, 2, 3,\
    \ 4, 3, 2\")\n    \"1, 2, 3, 4, 3, 2\"\n    \n    Example 3:\n    >>> split_into_groups(\"\
    1, 2, 1, 2, 1, 2\")\n    \"1, 2, 1, 2, 1, 2\"\n    \n*/\nstring split_into_groups(string\
    \ number_group_string) {\n    Stack<long> stack_levels = new Stack<long>();\n\
    \    stack_levels.Push(0);\n    stack_levels.Push(0);\n    string number_group\
    \ = \"\";\n    string number_group_with_no_repetition_or_no_values = \"\";\n \
    \   int current_pos = 0;\n    long level = 0;\n    long max_level = 0;\n    while\
    \ (!stack_levels.IsEmpty()) {\n        level = stack_levels.Pop();\n        if\
    \ (level > max_level) {\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpida4equ8.d(15): Error: found `>` when expecting `.` following long

    /tmp/tmpida4equ8.d(74): Error: found `>` when expecting `.` following long

    /tmp/tmpida4equ8.d(74): Error: found `>` when expecting `.` following long

    /tmp/tmpida4equ8.d(74): Error: found `(` when expecting identifier following `long`.

    /tmp/tmpida4equ8.d(74): Error: found `)` when expecting `;` following statement

    /tmp/tmpida4equ8.d(74): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpida4equ8.d(86): Error: found `unittest` instead of statement

    /tmp/tmpida4equ8.d(94): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpida4equ8.d(94): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpida4equ8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ current_level = 0;\n    long last_level = 0;\n    long level_length = 0;\n \
    \   long level = 0;\n    string sub_string;\n    stack<string> st;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx3fenbrk.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpx3fenbrk.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx3fenbrk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong max_level\
    \ = 0;\n\tlong level = 0;\n\tbool first_paren = true;\n\t\n\tfor(int i = 0; i\
    \ < paren_string.length; ++i)\n\t{\n\t\tchar c = paren_string[i];\n\t\t\n\t\t\
    if(c == '(')\n\t\t\t++level;\n\t\telse if(c == ')')\n\t\t\t--level;\n\t\telse\
    \ if(c == ' ' && level == 0)\n\t\t\tlevel = max_level;\n\t\telse if(c == ' ' &&\
    \ level > max_level)\n\t\t\tmax_level = level;\n\t}\n\t\n\tlong[] result = new\
    \ long[max_level+1];\n\tfor(int i = 0; i < paren_string.length; ++i)\n\t{\n\t\t\
    char c = paren_string[i];\n\t\t\n\t\tif(c == '(')\n\t\t\t++level;\n\t\telse if(c\
    \ == ')')\n\t\t\t--level;\n\t\telse if(c == ' ' && level == 0)\n\t\t\tlevel =\
    \ max_level;\n\t\telse if(c == ' ' && level > max_level)\n\t\t{\n\t\t\tresult[i-1]\
    \ = level;\n\t\t\tlevel = max_level;\n\t\t}\n\t}\n\tresult[i-1] = max_level;\n\
    \t\n\treturn result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2zbcop14.d(49): Error: undefined identifier `i`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2zbcop14.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tstringstream\
    \ ss;\n\tvector<long> ret;\n\tlong max_level = 0;\n\tfor(auto c : paren_string)\n\
    \t{\n\t\tif(c == '(')\n\t\t{\n\t\t\tret.push_back(1);\n\t\t\tmax_level = max(max_level,\
    \ ret.back());\n\t\t}\n\t\telse if(c == ')')\n\t\t{\n\t\t\tret.push_back(0);\n\
    \t\t\tmax_level = max(max_level, ret.back());\n\t\t}\n\t\telse if(c == ',')\n\t\
    \t{\n\t\t\tret.push_back(1);\n\t\t\tmax_level = max(max_level, ret.back());\n\t\
    \t}\n\t}\n\tret.push_back(max_level);\n\treturn ret;\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyyfolpyu.d(15): Error: found `>` when expecting `.` following long

    /tmp/tmpyyfolpyu.d(17): Error: no identifier for declarator `c`

    /tmp/tmpyyfolpyu.d(17): Error: expression expected, not `:`

    /tmp/tmpyyfolpyu.d(17): Error: found `paren_string` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyyfolpyu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t// Recursive\
    \ function call stack.\n\tlong[] recursive_stack = new long[paren_string.length()];\n\
    \tint i, paren_count = 0;\n\t\n\t// Keep track of parentheses in string and keep\
    \ track of the count of each one.\n\tfor(i = 0; i < paren_string.length(); ++i)\n\
    \t{\n\t\tchar c = paren_string[i];\n\t\tif(c == '(') ++paren_count;\n\t\telse\
    \ if(c == ')') --paren_count;\n\t\trecursive_stack[paren_count] = i;\n\t}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphl_75non.d(26): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphl_75non.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    Stack\
    \ stack = new Stack();\n    stack.Push(paren_string.Length);\n    long[] levels\
    \ = new long[paren_string.Length];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp52njy7bo.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp52njy7bo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    var\
    \ stack = new Stack<long[]>();\n    foreach (var group in paren_string.Split('\
    \ '))\n    {\n        if (group.length == 0)\n        {\n            stack.Push(null);\
    \ // push null to stack if it has no nested parentheses\n        }\n        else\
    \ if (group[0] == '(')\n        {\n            stack.Push(parse_nested_parens(group));\n\
    \        }\n        else if (group[0] == '{' || group[0] == '[')\n        {\n\
    \            stack.Push(parse_nested_brackets(group));\n        }\n        else\n\
    \        {\n            long level_of_parentheses = stack.Peek().Length;\n   \
    \         stack.Push(new long[] { level_of_parentheses }); // push an array with\
    \ only one element to stack\n        }\n    }\n    return stack.Peek();\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphgp_6yl0.d(14): Error: found `[` when expecting `.` following long

    /tmp/tmphgp_6yl0.d(14): Error: found `]` when expecting identifier following `long`.

    /tmp/tmphgp_6yl0.d(14): Error: semicolon expected, not `>`

    /tmp/tmphgp_6yl0.d(14): Error: found `>` instead of statement

    /tmp/tmphgp_6yl0.d(15): Error: found `in` when expecting `;`

    /tmp/tmphgp_6yl0.d(32): Error: found `{` when expecting `,`

    /tmp/tmphgp_6yl0.d(32): Error: found `}` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphgp_6yl0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    Stack\
    \ open_pars_stack = new Stack();\n    long nested_level = 1;\n    long level_stack[]\
    \ = new long[MAX_LEVEL];\n    Arrays.fill(level_stack,0);\n    open_pars_stack.push(0);\n\
    \    \n    char[] par_string = paren_string.toCharArray();\n    for (int i = 0;\
    \ i < par_string.length; i++)\n    {\n        switch (par_string[i])\n       \
    \ {\n            case '(':\n                level_stack[open_pars_stack.getTop()]\
    \ = nested_level++;\n                open_pars_stack.push(level_stack.length -\
    \ 1);\n                break;\n            case ')':\n                level_stack[open_pars_stack.pop()]--;\n\
    \                break;\n        }\n    }\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpreqg9jjo.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] level_stack`

    /tmp/tmpreqg9jjo.d(34): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpreqg9jjo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ current_group = \"\";\n    long current_group_nesting = 1;\n    long max_group_nesting\
    \ = 1;\n    long[] groups = new long[paren_string.length()];\nunittest\n{\n  \
    \  alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp13f3x0vc.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp13f3x0vc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    map<string,\
    \ int> paren_depth;\n    vector<string> paren_strings = split(paren_string, \"\
    \ \");\n    for (size_t i = 0; i < paren_strings.size(); ++i) {\n        string\
    \ str = paren_strings[i];\n        int depth = 0;\n        while (i < str.size())\
    \ {\n            if (str[i] == '(')\n                ++depth;\n            if\
    \ (str[i] == ')')\n                --depth;\n            ++i;\n        }\n   \
    \     paren_depth[str] = depth;\n    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp55kipq3x.d(14): Error: found `>` when expecting `.` following int

    /tmp/tmp55kipq3x.d(15): Error: found `>` when expecting `;` following statement

    /tmp/tmp55kipq3x.d(28): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp55kipq3x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_string = paren_string.trim();\n    if (paren_string.length() == 0) \n\
    \        return null;\n    long[] levels = new long[paren_string.length()];\n\
    \    \n    long[] level = 0;\n    int paren_level = 0;\n    long maxlevel = 0;\n\
    \    long levels[] = new long[paren_string.length()];\n    \n    for (int i =\
    \ 0; i < (int)paren_string.length(); i++) {\n        if (paren_string[i] == ')')\
    \ {\n            levels[paren_level] = levels[paren_level - 1];\n            levels[paren_level\
    \ - 1] = -1;\n            if (maxlevel < levels[paren_level - 1]) \n         \
    \       maxlevel = levels[paren_level - 1];\n            levels[paren_level] =\
    \ -1L;\n            levels[paren_level + 1] = maxlevel;\n            \n      \
    \      levels[paren_level] = maxlevel;\n            paren_level++;\n         \
    \   levels[paren_level] = -1L;\n        } else if (paren_string[i] == '(') {\n\
    \            if (paren_level == 0) \n                levels[paren_level] = -1L;\n\
    \            levels[paren_level] = maxlevel;\n            paren_level++;\n   \
    \     } else {\n            levels[paren_level] = maxlevel;\n        }\n    }\n\
    \    \n    for (int i = 0; i < paren_level; i++) {\n        levels[i] = -1L;\n\
    \    }\n    for (int i = 0; i < (int)paren_string.length(); i++) {\n        if\
    \ (paren_string[i] == ')') {\n            levels[levels[paren_level - 1]] = levels[levels[paren_level\
    \ - 1] - 1];\n            levels[levels[paren_level - 1] - 1] = -1L;\n       \
    \     levels[levels[paren_level - 1]] = -1L;\n        } else if (paren_string[i]\
    \ == '(') {\n            levels[levels[paren_level - 1]] = maxlevel;\n       \
    \     levels[levels[paren_level - 1] - 1] = -1L;\n        }\n    }\n    \n   \
    \ return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbybwwpe4.d(22): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] levels`

    /tmp/tmpbybwwpe4.d(24): Error: C style cast illegal, use `cast(int)paren_string.length()`

    /tmp/tmpbybwwpe4.d(49): Error: C style cast illegal, use `cast(int)paren_string.length()`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbybwwpe4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    var\
    \ result = 0;\n    var stack = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpockl2wd6.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpockl2wd6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  stack<long>\
    \ s;\n  \n  for(auto c : paren_string) \n  {\n    switch(c) {\n    case '(':\n\
    \      s.push(0);\n      break;\n    case ')':\n      if (s.top() == 0) \n   \
    \   {\n        return long_array(0, 0L);\n      }\n      \n      s.pop();\n  \
    \    break;\n    case '\\n': \n      if (s.top() == 0) \n      {\n        return\
    \ long_array(0, 0L);\n      }\n      \n      s.pop();\n      s.push(0L);\n   \
    \   break;\n    case ' ':\n      if(s.top() == 0) \n      {\n        return long_array(0,\
    \ 0L);\n      }\n      \n      s.pop();\n      break;\n    default:\n      s.push(1L);\n\
    \      break;\n    }\n  }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4v8p_4uf.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmp4v8p_4uf.d(16): Error: no identifier for declarator `c`

    /tmp/tmp4v8p_4uf.d(16): Error: expression expected, not `:`

    /tmp/tmp4v8p_4uf.d(16): Error: found `paren_string` when expecting `;` following
    `for` condition

    /tmp/tmp4v8p_4uf.d(52): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4v8p_4uf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string[]\
    \ nested_paren = paren_string.Split(new[] { ' ' }, System.StringSplitOptions.RemoveEmptyEntries);\n\
    \    long[] levels = new long[nested_paren.Length];\n    long max_level = 0;\n\
    \    for (int i = 0; i < nested_paren.Length; i++) {\n        string paren_string\
    \ = nested_paren[i];\n        long level = paren_string.Length;\n        if (paren_string.Contains(\"\
    (\") && paren_string.Contains(\")\")) {\n            level++;\n        }\n   \
    \     if (level > max_level) {\n            max_level = level;\n        }\n  \
    \      levels[i] = level;\n    }\n    return levels;\n}\n</code>\n<|/ a tags=c#,algorithm,string\
    \ |>\n<| c |>\nJust a heads-up: this won't work on languages that have parentheses\
    \ other than those that are legal in code blocks, for example Python or C/C++.\
    \ Although they are still valid in string literals (and are unbalanced).\n<|/\
    \ c |>\n<| c |>\nIt won't work if the nested parentheses are balanced.\n<|/ c\
    \ |>\n<| c |>\n: Your sample input doesn't show balanced parentheses, but it does\
    \ show unbalanced parentheses, e.g. `\"()\"`. The solution in this answer gives\
    \ an answer for `\"\"` too (which you say is incorrect).\n<|/ c |>\n<| a dscore=5\
    \ |>\nHere's another approach. I've implemented it in JavaScript. As per your\
    \ example:\n<code>\nfunction countNestedParens(expression) {\n    var openParens\
    \ = new Array(expression.length);\n    var closeParens = new Array(expression.length);\n\
    \    for (var i = 0, len = expression.length; i < len; i++) {\n        var parenCount\
    \ = 0;\n        for (var j = i + 1; j < len; j++) {\n            if (expression[j]\
    \ == '(') {\n                parenCount++;\n            } else if (expression[j]\
    \ == ')') {\n                parenCount--;\n            }\n        }\n       \
    \ if (parenCount == 0) {\n            openParens[i] = 0;\n        } else {\n \
    \           openParens[i] = parenCount;\n        }\n    }\n    return openParens;\n\
    }\n</code>\n<|/ a tags=c#,algorithm,string |>\n<| c |>\nYeah, that would work\
    \ fine too. I'm not sure why I added the C# tag; I thought the question was language\
    \ agnostic. I'd probably just use Python, where you could just use `string.count(\"\
    (\")`. I also added the [tag:algorithm] tag to get all the answers I was looking\
    \ for.\n<|/ c |>\n<| c |>\nAh, but what about the case where the input has two\
    \ parentheses and no opening parentheses? You would have to add one more iteration\
    \ to \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdhgb4xnf.d(14): Error: basic type expected, not `[`

    /tmp/tmpdhgb4xnf.d(14): Error: found `{` when expecting `,`

    /tmp/tmpdhgb4xnf.d(14): Error: found `}` when expecting `,`

    /tmp/tmpdhgb4xnf.d(14): Error: expression expected, not `,`

    /tmp/tmpdhgb4xnf.d(14): Error: found `System` when expecting `,`

    /tmp/tmpdhgb4xnf.d(30): Error: declaration expected, not `<`

    /tmp/tmpdhgb4xnf.d(33): Error: unterminated character constant

    /tmp/tmpdhgb4xnf.d(36): Error: unterminated character constant

    /tmp/tmpdhgb4xnf.d(39): Error: unterminated character constant

    /tmp/tmpdhgb4xnf.d(42): Error: unterminated character constant

    /tmp/tmpdhgb4xnf.d(42): Error: unterminated character constant

    /tmp/tmpdhgb4xnf.d(47): Error: declaration expected, not `for`

    /tmp/tmpdhgb4xnf.d(47): Error: no identifier for declarator `i`

    /tmp/tmpdhgb4xnf.d(47): Error: declaration expected, not `<`

    /tmp/tmpdhgb4xnf.d(47): Error: no identifier for declarator `i`

    /tmp/tmpdhgb4xnf.d(47): Error: declaration expected, not `++`

    /tmp/tmpdhgb4xnf.d(49): Error'
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<string>\
    \ paren_stack;\n    stack<int> nesting_levels;\n    string curr_str = \"\";\n\
    \    long nest_level;\n    long cur_nest = 0;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn6hpjwgw.d(14): Error: found `>` when expecting `;` following statement

    /tmp/tmpn6hpjwgw.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmpn6hpjwgw.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn6hpjwgw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ stripped = paren_string.trim();\n    if(stripped.length() == 0) \n        throw\
    \ new Exception(\"No parens\");\n    long[] levels = new long[stripped.length()];\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwb78j0nh.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwb78j0nh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ token_str = paren_string;\n    \n    int[] levels = { 0, 0, 0 };\n    int[]\
    \ index = 0;\n    string last_group_open = \"(\";\n    string last_group_close\
    \ = \")\";\n    bool is_first_group = true;\n    bool is_last_group = true;\n\
    \    bool last_is_open = false;\n    bool is_last_group_close = false;\n    bool\
    \ is_last_group_open = false;\n    string last_group;\n    \n    for(int i = 0;\
    \ i < token_str.size(); ++i)\n    {\n        if(token_str[i] == '(')\n       \
    \ {\n            if(is_first_group) levels[0]++;\n            else\n         \
    \   {\n                levels[1]++;\n            }\n            is_first_group\
    \ = false;\n        }\n        else if(token_str[i] == ')')\n        {\n     \
    \       if(is_last_group)\n            {\n                if(levels[1] > levels[0])\n\
    \                {\n                    levels[2] += levels[1] - levels[0];\n\
    \                }\n                else\n                {\n                \
    \    levels[1]--;\n                }\n            }\n            is_last_group\
    \ = false;\n        }\n        else if(token_str[i] == '\"')\n        {\n    \
    \        if(is_last_group)\n            {\n                last_is_open = true;\n\
    \                is_last_group_open = false;\n                is_last_group_close\
    \ = false;\n            }\n        }\n        else if(token_str[i] == '\"')\n\
    \        {\n            if(is_last_group)\n            {\n                last_is_open\
    \ = false;\n                is_last_group_open = true;\n                is_last_group_close\
    \ = false;\n            }\n        }\n        else if(token_str[i] == '\\\\')\n\
    \        {\n            token_str[i - 1] = '\\0';\n            token_str.insert(i,\
    \ token_str[i + 1]);\n            token_str.erase(i + 1, 1);\n        }\n    \
    \    else\n        {\n            if(last_is_open)\n            {\n          \
    \      last_is_open = false;\n                is_last_group_open = false;\n  \
    \          }\n        }\n    }\n    if(is_last_group)\n    {\n        if(levels[1]\
    \ > levels[0])\n        {\n            levels[2] += levels[1] - levels[0];\n \
    \       }\n        else\n        {\n            levels[1]--;\n        }\n    }\n\
    \    string result[] = new string[levels[2] + 1];\n    \n    for(int i = 0; i\
    \ < result.length; ++i)\n    {\n        result[i] = \"\";\n    }\n    \n    for(int\
    \ i = 0; i < token_str.size(); ++i)\n    {\n        if(token_str[i] == '(')\n\
    \        {\n            if(!is_first_group) index[levels[0]] = i;\n          \
    \  levels[0]++;\n        }\n        else if(token_str[i] == ')')\n        {\n\
    \            if(!is_last_group) index[levels[1]] = i;\n            levels[1]--;\n\
    \        }\n        else if(token_str[i] == '\"')\n        {\n            if(!is_last_\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj3xy3u03.d(97): Deprecation: instead of C-style syntax, use D-style
    syntax `string[] result`

    /tmp/tmpj3xy3u03.d(119): Error: found `unittest` when expecting `)`

    /tmp/tmpj3xy3u03.d(127): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpj3xy3u03.d(127): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpj3xy3u03.d(127): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj3xy3u03.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    Stack<long>\
    \ paren_stack = new Stack<long>();\n    string input_string = paren_string;\n\
    \    bool last_bracket = true;\n    long nesting_level = 0;\n    bool at_least_one_open\
    \ = false;\n    long level = 0;\n    long[] levels = new long[64];\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpmzaslbnn.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmpmzaslbnn.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmpmzaslbnn.d(14): Error: found `(` when expecting identifier following `long`.

    /tmp/tmpmzaslbnn.d(14): Error: found `)` when expecting `;` following statement

    /tmp/tmpmzaslbnn.d(14): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpmzaslbnn.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmzaslbnn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<pair<string,\
    \ long>> paren_stack;\n    vector<pair<string, long>> paren_groups;\n    string\
    \ group_str;\n    long cur_level = 0;\n    long cur_group = 0;\n    for(auto c\
    \ : paren_string)\n    {\n        if(c != ' ' && c != '(' && c != ')')\n     \
    \   {\n            group_str += c;\n        }\n        else\n        {\n     \
    \       group_str = group_str.substr(0, group_str.size()-1);\n            cur_level\
    \ = cur_level + 1;\n            paren_stack.emplace_back(group_str, cur_level);\n\
    \            paren_groups.emplace_back(group_str, cur_group);\n            group_str\
    \ = \"\";\n        }\n        if(c != ')')\n        {\n            cur_level =\
    \ paren_stack.top().second;\n            cur_group = paren_stack.top().first +\
    \ (cur_group + 1);\n        }\n        else\n        {\n            paren_stack.pop();\n\
    \            paren_groups.pop();\n        }\n    }\n    \n    if(group_str.empty())\n\
    \    {\n        return paren_groups.size();\n    }\n    return -1;\n}\n</code>\n\
    <|/ a tags=string,c++,parsing |>\n<| c |>\nNice algorithm. Elegant and fast. Nicely\
    \ done.\n<|/ c |>\n<| a tags=string,c++,parsing |>\nA very simple recursive solution:\n\
    <code>\n#include <iostream>\n#include <string>\n#include <vector>\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6etqj22_.d(14): Error: found `<` when expecting `;` following statement

    /tmp/tmp6etqj22_.d(14): Error: found `>>` when expecting `.` following long

    /tmp/tmp6etqj22_.d(15): Error: found `<` when expecting `;` following statement

    /tmp/tmp6etqj22_.d(15): Error: found `>>` when expecting `.` following long

    /tmp/tmp6etqj22_.d(19): Error: no identifier for declarator `c`

    /tmp/tmp6etqj22_.d(19): Error: expression expected, not `:`

    /tmp/tmp6etqj22_.d(19): Error: found `paren_string` when expecting `;` following
    `for` condition

    /tmp/tmp6etqj22_.d(51): Error: declaration expected, not `<`

    /tmp/tmp6etqj22_.d(66): Error: declaration expected, not `assert`

    /tmp/tmp6etqj22_.d(67): Error: declaration expected, not `assert`

    /tmp/tmp6etqj22_.d(68): Error: declaration expected, not `assert`

    /tmp/tmp6etqj22_.d(69): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6etqj22_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ paren_index = 0;\n    int paren_depth = 1;\n    bool parentheses_open = true;\n\
    \    bool opening_parenthese_closed = false;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0vb6gu9s.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0vb6gu9s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    \n \
    \   /*\n    Example of input:\n    (()()) ((())) () ((())()())\n    \n    Output\
    \ will be a long array containing the deepest level of nesting of each parentheses\n\
    \    \n    */\n    \n    char[] chars = paren_string.toCharArray();\n    long\
    \ deepest_levels[] = new long[chars.length];\n    deepest_levels[] = new long[chars.length];\n\
    \    long level = 0;\n    for (int i = 0; i < chars.length; i++) {\n        //\
    \ if parentheses match, increment level\n        if (chars[i] == '(') {\n    \
    \        deepest_levels[level]++;\n        }\n        // if parentheses match,\
    \ decrement level\n        else if (chars[i] == ')') {\n            deepest_levels[level]--;\n\
    \        }\n        // otherwise, level is 0\n        else {\n            level\
    \ = 0;\n        }\n    }\n    return deepest_levels;\n}\n</code>\n<|/ a |>\n<|\
    \ a |>\nI implemented a similar solution in Python.\n<code>\ndef parens_level(s):\n\
    \    level = 0\n    levels = [level]\n    \n    chars = s.toCharArray()\n    \n\
    \    for c in chars:\n        \n        if c == '(':\n            level += 1\n\
    \            levels.append(level)\n        \n        elif c == ')':\n        \
    \    level -= 1\n        \n        elif c == '\\n':\n            level = 0\n \
    \           levels.append(level)\n    \n    return levels\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp81i705n6.d(24): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] deepest_levels`

    /tmp/tmp81i705n6.d(43): Error: declaration expected, not `<`

    /tmp/tmp81i705n6.d(72): Error: declaration expected, not `assert`

    /tmp/tmp81i705n6.d(73): Error: declaration expected, not `assert`

    /tmp/tmp81i705n6.d(74): Error: declaration expected, not `assert`

    /tmp/tmp81i705n6.d(75): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp81i705n6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ n = paren_string.length();\n    long[] result = new long[n];\n    stack<int>\
    \ parens;\n    \n    for(int i = 0; i < n; i++) {\n        char c = paren_string[i];\n\
    \        \n        // Handle parentheses inside parentheses, e.g. ()()\n     \
    \   if(parens.empty() || c == '(' || c == ')') {\n            if(parens.empty())\
    \ {\n                result[i] = 0;\n            } else {\n                long\
    \ level = parens.top();\n                if(parens.empty() && c != '(' && c !=\
    \ ')') {\n                    result[i] = level;\n                } else {\n \
    \                   result[i] = level + 1;\n                }\n            }\n\
    \            \n        // Handle nested parentheses, e.g. ()()()\n        } else\
    \ if(c != '(' && c != ')') {\n            parens.push(c);\n            \n    \
    \    // Handle the case where a bracket is closed without an opening one, e.g.\
    \ ())\n        } else {\n            char p = parens.top();\n            parens.pop();\n\
    \            result[i] = parens.top();\n        }\n    }\n    \n    return result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nthank you so much, this works perfectly.\n<|/ c\
    \ |>\n<| a dscore=3 |>\nHere's a recursive approach to counting parentheses.\n\
    <code>\npublic static int countOpenParens(String str) {\n    return countOpenParens(str,\
    \ 0);\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphccei2ow.d(16): Error: found `>` when expecting `.` following int

    /tmp/tmphccei2ow.d(48): Error: declaration expected, not `<`

    /tmp/tmphccei2ow.d(54): Error: unterminated character constant

    /tmp/tmphccei2ow.d(58): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphccei2ow.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong num_paren_group\
    \ = 0;\n\tlong num_open = 0;\n\tlong num_closed = 0;\n\tstringstream ss(paren_string);\n\
    \tstring cur_paren;\n\twhile(ss.peek() != EOF)\n\t{\n\t\tss >> cur_paren;\n\t\t\
    switch(cur_paren)\n\t\t{\n\t\t\tcase \")\":\n\t\t\t\tnum_closed += 1;\n\t\t\t\t\
    break;\n\t\t\tcase \"(\":\n\t\t\t\tnum_open += 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\
    \t\t\t\tbreak;\n\t\t}\n\t\tif(num_paren_group > num_open)\n\t\t{\n\t\t\tnum_paren_group\
    \ -= num_open;\n\t\t}\n\t}\n\t\n\tlong max_level = num_paren_group;\n\tlong levels[max_level];\n\
    \tlong max_level_pos = -1;\n\t\n\tlong i;\n\tfor(i = 0; i < num_paren_group; i++)\n\
    \t{\n\t\tlevels[i] = num_open;\n\t\tmax_level_pos = i;\n\t}\n\tfor(i = 0; i <\
    \ num_paren_group; i++)\n\t{\n\t\tswitch(cur_paren)\n\t\t{\n\t\t\tcase \")\":\n\
    \t\t\t\tnum_closed -= 1;\n\t\t\t\tbreak;\n\t\t\tcase \"(\":\n\t\t\t\tnum_open\
    \ -= 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tif(num_paren_group\
    \ > num_open)\n\t\t{\n\t\t\tmax_level = num_paren_group;\n\t\t}\n\t\telse if(num_paren_group\
    \ < num_open)\n\t\t{\n\t\t\tmax_level = num_open;\n\t\t}\n\t\tif(levels[i] > levels[max_level_pos])\n\
    \t\t{\n\t\t\tmax_level_pos = i;\n\t\t}\n\t\telse if(levels[i] > levels[max_level])\n\
    \t\t{\n\t\t\tmax_level = i;\n\t\t}\n\t}\n\t\n\tlong[] result = new long[max_level];\n\
    \t\n\tint pos = 0;\n\t\n\tfor(i = 0; i < max_level; i++)\n\t{\n\t\tpos += levels[i];\n\
    \t\tresult[pos] = i;\n\t}\n\t\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdez3pc4m.d(40): Deprecation: instead of C-style syntax, use D-style
    syntax `long[max_level] levels`

    /tmp/tmpdez3pc4m.d(17): Error: undefined identifier `stringstream`

    /tmp/tmpdez3pc4m.d(17): Error: `paren_string` is used as a type

    /tmp/tmpdez3pc4m.d(19): Error: undefined identifier `EOF`

    /tmp/tmpdez3pc4m.d(40): Error: variable `max_level` cannot be read at compile
    time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdez3pc4m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    char[]\
    \ open_parens = {')'};\n    long[] max_levels = new long[1];\n    char[] open_chars\
    \ = {'('};\n    char[] close_chars = {')'};\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp95yxo_oc.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp95yxo_oc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tassert(paren_string.length()\
    \ == paren_string.Length() && paren_string.Length() > 0);\n\t\n\tlong[] levels\
    \ = new long[paren_string.Length()];\n\t\n\tint current_level = 0;\n\tbool first_item\
    \ = true;\n\tchar last_item_char = paren_string[0];\n\tstring last_item = paren_string;\n\
    \t\n\tforeach (char c in paren_string.Substring(1))\n\t{\n\t\tassert(c == '('\
    \ || c == ')');\n\t\t\n\t\tif (c == ')')\n\t\t{\n\t\t\tassert(current_level >\
    \ 0);\n\t\t\t\n\t\t\t--current_level;\n\t\t}\n\t\telse if (c == '(')\n\t\t{\n\t\
    \t\tif (current_level == 0)\n\t\t\t{\n\t\t\t\tlevels[level_index] = current_level;\n\
    \t\t\t\tcurrent_level++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurrent_level++;\n\
    \t\t\t}\n\t\t}\n\t\telse if (last_item_char != c)\n\t\t{\n\t\t\tif (last_item.Length\
    \ > 0)\n\t\t\t{\n\t\t\t\tlevels[level_index] = current_level;\n\t\t\t}\n\t\t\t\
    \n\t\t\tcurrent_level = 0;\n\t\t\tfirst_item = false;\n\t\t\tlast_item_char =\
    \ c;\n\t\t\tlast_item = c;\n\t\t}\n\t}\n\t\n\tif (last_item.Length > 0)\n\t{\n\
    \t\tlevels[level_index] = current_level;\n\t}\n\t\n\treturn levels;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe5bffuy4.d(23): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe5bffuy4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    long[] levels = new long[paren_string.length()];\n\
    \    levels[0] = 1;\n    int pos = 1;\n    int level = 1;\n    string chars =\
    \ paren_string.substr(0, paren_string.length()-1);\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzb8vikyf.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzb8vikyf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ level = 0; \n    int depth = 0; \n    long nested_paren_levels[]; \n    bool\
    \ seen_paren = true; \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprhwohkiv.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `long[] nested_paren_levels`

    /tmp/tmprhwohkiv.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprhwohkiv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ paren_pairs = paren_string.split(\"( )\");\n    long[] levels = new long[paren_pairs.size()];\n\
    \    int index = 0;\n    for (auto pair : paren_pairs) {\n        string group_str\
    \ = pair;\n        int current_level = 0;\n        bool is_last_pair = false;\n\
    \        for (index; index < (index+group_str.size()); ++index) {\n          \
    \  if (group_str[index] == '(') ++current_level;\n            else if (group_str[index]\
    \ == ')') --current_level;\n            if (current_level == 0 && is_last_pair)\
    \ break;\n            if (current_level == 0 && !is_last_pair) break;\n      \
    \  }\n        if (current_level == 0) continue;\n        levels[index] = current_level;\n\
    \        is_last_pair = index + group_str.size() == paren_pairs.size() - 1;\n\
    \    }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdjbvq3p9.d(17): Error: no identifier for declarator `pair`

    /tmp/tmpdjbvq3p9.d(17): Error: expression expected, not `:`

    /tmp/tmpdjbvq3p9.d(17): Error: found `paren_pairs` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdjbvq3p9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 0;\n    long level = 0;\n    long idx = 0;\n    string temp = \"\
    \";\n    string[] levels = new string[paren_string.size()];\n    levels[paren_string.size()]\
    \ = \"\";\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpis6o6y3w.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpis6o6y3w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    char[]\
    \ paren_chars = paren_string.toCharArray();\n    \n    int paren_count = 0;\n\
    \    int paren_level = 0;\n    int paren_pos = 0;\n    long nest_level = 0;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyyufxmvh.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyyufxmvh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Parse\
    \ input string\n    string token;\n    Stack<string> stack = new Stack<string>();\n\
    \    long level = 0;\n    int token_count = 0;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7bxu4_fr.d(16): Error: found `>` when expecting `;` following statement

    /tmp/tmp7bxu4_fr.d(16): Error: found `>` when expecting `;` following statement

    /tmp/tmp7bxu4_fr.d(16): Error: expression expected, not `)`

    /tmp/tmp7bxu4_fr.d(16): Error: found `;` when expecting `)`

    /tmp/tmp7bxu4_fr.d(17): Error: found `long` when expecting `;` following statement

    /tmp/tmp7bxu4_fr.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7bxu4_fr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<long>\
    \ paren_levels;\n    stack<long> paren_numbers;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1dnv2xx7.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmp1dnv2xx7.d(15): Error: found `>` when expecting `.` following long

    /tmp/tmp1dnv2xx7.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1dnv2xx7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ i;\n    long max_level = 0;\n    long cur_level = 0;\n    int[] group = new\
    \ int[paren_string.Length()];\n    for(i=0;i<paren_string.Length();i++)\n    {\n\
    \        group[i] = paren_string[i];\n        if(group[i]=='(')\n        {\n \
    \           cur_level++;\n            if(cur_level > max_level)\n            \
    \    max_level = cur_level;\n        }\n        else if(group[i]==')')\n     \
    \   {\n            cur_level--;\n        }\n    }\n    long[] levels = new long[max_level+1];\n\
    \    for(i=0;i<max_level+1;i++)\n    {\n        levels[i] = i;\n    }\n    levels[max_level]\
    \ = paren_string.Length();\n    for(i=1;i<max_level;i++)\n    {\n        levels[i]\
    \ += levels[i-1];\n    }\n    return levels;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpltvn7toa.d(17): Error: no property `Length` for type `string`

    /tmp/tmpltvn7toa.d(18): Error: no property `Length` for type `string`

    /tmp/tmpltvn7toa.d(37): Error: no property `Length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpltvn7toa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  Stack<long>\
    \ paren_stack = new Stack<long>();\n  long cur = 0;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfu0fbhvn.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmpfu0fbhvn.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmpfu0fbhvn.d(14): Error: found `(` when expecting identifier following `long`.

    /tmp/tmpfu0fbhvn.d(14): Error: found `)` when expecting `;` following statement

    /tmp/tmpfu0fbhvn.d(14): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpfu0fbhvn.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfu0fbhvn.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    if(\
    \ paren_string.empty() )\n        return new[] {};\n    \n    int paren_len =\
    \ paren_string.length();\n    long[] deepest_level = new long[paren_len];\n  \
    \  int deepest_level_index = 0;\n    int deepest_level_max = 0;\n    for( int\
    \ i = 1; i < paren_len; i++ ) {\n        string cur_char = paren_string[i];\n\
    \        string prevChar = paren_string[i-1];\n        \n        //Check if last\
    \ character is \")\"\n        if( cur_char == \"(\" || cur_char == \"{\" || cur_char\
    \ == \"[\" ) {\n            //If last character is \")\", move 1 level deeper\n\
    \            if( i == paren_len-1 ) deepest_level[deepest_level_index] = 0;\n\
    \            else deepest_level[deepest_level_index]++;\n            deepest_level_max\
    \ = Math.max(deepest_level_max, deepest_level[deepest_level_index]);\n       \
    \     if( i == paren_len-1 ) deepest_level_index++;\n        }\n        else if(\
    \ cur_char == \")\" ) {\n            //If last character is \")\", move 1 level\
    \ deeper\n            if( i == paren_len-1 ) deepest_level[deepest_level_index]\
    \ = 0;\n            else deepest_level[deepest_level_index]--;\n            deepest_level_max\
    \ = Math.max(deepest_level_max, deepest_level[deepest_level_index]);\n       \
    \     if( i == paren_len-1 ) deepest_level_index++;\n        }\n        else if(\
    \ cur_char == \",\" ) {\n            //If last character is \",\", move 1 level\
    \ deeper\n            if( i == paren_len-1 ) deepest_level[deepest_level_index]\
    \ = 0;\n            else deepest_level[deepest_level_index]--;\n            deepest_level_max\
    \ = Math.max(deepest_level_max, deepest_level[deepest_level_index]);\n       \
    \     if( i == paren_len-1 ) deepest_level_index++;\n        }\n        else if(\
    \ cur_char == \"]\" ) {\n            //If last character is \"]\", move 1 level\
    \ deeper\n            if( i == paren_len-1 ) deepest_level[deepest_level_index]\
    \ = 0;\n            else deepest_level[deepest_level_index]--;\n            deepest_level_max\
    \ = Math.max(deepest_level_max, deepest_level[deepest_level_index]);\n       \
    \     if( i == paren_len-1 ) deepest_level_index++;\n        }\n        else if(\
    \ cur_char == \"}\" ) {\n            //If last character is \"}\", move 1 level\
    \ deeper\n            if( i == paren_len-1 ) \nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphm36ri6_.d(15): Error: basic type expected, not `[`

    /tmp/tmphm36ri6_.d(15): Error: found `{` when expecting `;` following `return`
    statement

    /tmp/tmphm36ri6_.d(21): Error: declaration expected, not `for`

    /tmp/tmphm36ri6_.d(21): Error: no identifier for declarator `i`

    /tmp/tmphm36ri6_.d(21): Error: declaration expected, not `<`

    /tmp/tmphm36ri6_.d(21): Error: no identifier for declarator `i`

    /tmp/tmphm36ri6_.d(21): Error: declaration expected, not `++`

    /tmp/tmphm36ri6_.d(26): Error: declaration expected, not `if`

    /tmp/tmphm36ri6_.d(29): Error: declaration expected, not `else`

    /tmp/tmphm36ri6_.d(30): Error: no identifier for declarator `deepest_level_max`

    /tmp/tmphm36ri6_.d(30): Error: declaration expected, not `=`

    /tmp/tmphm36ri6_.d(31): Error: declaration expected, not `if`

    /tmp/tmphm36ri6_.d(32): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphm36ri6_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t\n\tlong[]\
    \ level = new long[3];\n\tlong current_level;\n\tstring paren_group;\n\t\n\t/*\n\
    \t\tTo get the current level of nesting of a group of parenthesis\n\t\twe need\
    \ to go through all the parenthesis string and count the parenthesis\n\t\tat each\
    \ position. If number of opening and closing parenthesis at that position\n\t\t\
    is equal to opening and closing parenthesis counter, increment level by one.\n\
    \t\t\n\t\tFor example:\n\t\t\n\t\t(\"()\") has maximum two level of nesting while\
    \ (\"()(\") has three.\n\t\t\n\t\tAlso we have to consider that if the last parenthesis\
    \ is closing parenthesis\n\t\twe should add 1 to level to show that we're at deepest\
    \ level.\n\t\t\n\t\tSo, the steps are as follows:\n\t\t\n\t\t1) We need to go\
    \ through all string and count opening and closing parenthesis in each position.\n\
    \t\t2) For each position, if we have two equal opening and closing parenthesis,\
    \ increment level by one\n\t\t3) If last position is closing parenthesis, add\
    \ 1 to level\n\t\t4) If last position is not closing parenthesis, add 2 to level\n\
    \t\t\n\t\tSo, at first we initialize level and current_level to 0 and 1\n\t\t\n\
    \t\tFor example at position 3, level will be [2,1,1]\n\t\t\n\t\tAfter first step:\n\
    \t\t\n\t\t   current_level \t\tlevel = level\n\t\t   1\t\t\t\t\t\t[2L, 1L, 1L]\n\
    \t\t   2\t\t\t\t\t\t[2L, 1L, 2L]\n\t\t   3\t\t\t\t\t\t[3L, 1L, 2L]\n\t\t   4\t\
    \t\t\t\t\t[3L, 1L, 3L]\n\t\t   5\t\t\t\t\t\t[4L, 1L, 3L]\n\t\t   6\t\t\t\t\t\t\
    [4L, 1L, 4L]\n\t\t\n\t\tWe increment level by one for every opening parenthesis\
    \ encountered.\n\t\tSo, if there are 4 opening parenthesis at the beginning of\
    \ the string, level will be [2,4,4]\n\t\t\n\t\tAfter second step:\n\t\t\n\t\t\
    \   current_level \t\tlevel = level\n\t\t   1\t\t\t\t\t\t[2L, 4L, 4L]\n\t\t  \
    \ 2\t\t\t\t\t\t[2L, 4L, 5L]\n\t\t   3\t\t\t\t\t\t[3L, 4L, 5L]\n\t\t   4\t\t\t\t\
    \t\t[3L, 4L, 6L]\n\t\t   5\t\t\t\t\t\t[4L, 4L, 6L]\n\t\t\n\t\tWe increment level\
    \ by two for every opening parenthesis encountered.\n\t\tSo, if there are 7 opening\
    \ parenthesis at the beginning of the string, level will be [2,7,7]\n\t\t\n\t\t\
    After third step:\n\t\t\n\t\t   \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp852pc8ag.d(19): Error: unterminated /* */ comment

    /tmp/tmp852pc8ag.d(79): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp852pc8ag.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong nested_level\
    \ = 0;\n\tlong result = 0;\n\tstring::const_iterator start_it = paren_string.begin();\n\
    \tstring::const_iterator paren_it = paren_string.begin();\n\tstring::const_iterator\
    \ end_it = paren_string.end();\n\twhile(start_it != end_it && paren_it != end_it)\
    \ {\n\t\tchar c = *paren_it;\n\t\tif (c == '(') ++nested_level;\n\t\telse if (c\
    \ == ')') --nested_level;\n\t\telse if (nested_level == 0) result = std.math.max(result,\
    \ std.typecons.distance(start_it, paren_it));\n\t\t++paren_it;\n\t}\n\treturn\
    \ result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjqna919l.d(16): Error: use `.` for member lookup, not `::`

    /tmp/tmpjqna919l.d(17): Error: use `.` for member lookup, not `::`

    /tmp/tmpjqna919l.d(18): Error: use `.` for member lookup, not `::`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjqna919l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ left_paren, right_paren, paren_level;\n    long level_array;\n    long parent_counter\
    \ = 0;\n    size_t number_of_paren;\n    size_t paren_counter = 0;\n    long[]\
    \ levels = new long[MAX_LEVEL];\n    paren_level = \"\";\n    number_of_paren\
    \ = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvejpbch3.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvejpbch3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    size_t\
    \ paren_length = 0;\n    size_t max_level = 0;\n    string paren_string1 = \"\"\
    ;\n    string paren_string2 = \"\";\n    \n    size_t start_pos = 0;\n    size_t\
    \ end_pos = 0;\n    \n    for(size_t i = 0; i < paren_string.length(); i+=1) \n\
    \    {\n        char c = paren_string[i];\n        \n        if(paren_length ==\
    \ 0) \n        {\n            if(paren_string1 == \"(\" && paren_string2 == \"\
    )\") \n            {\n                start_pos = i;\n                end_pos\
    \ = i;\n            }\n        }\n        else if(paren_string1 == \"(\" && paren_string2\
    \ == \")\" && c == ')') \n        {\n            paren_length++;\n        }\n\
    \        else if(paren_string1 == \"(\" && c == ')') \n        {\n           \
    \ paren_length--;\n        }\n        else if(paren_string1 == \")\" && c == ')')\
    \ \n        {\n            paren_length++;\n            \n            if(paren_length\
    \ == 0) \n            {\n                max_level = i-(start_pos-1);\n      \
    \      }\n        }\n        else if(c == '(')\n        {\n            paren_string1\
    \ += c;\n        }\n        else\n        {\n            paren_string2 += c;\n\
    \        }\n    }\n    \n    assert(paren_string1.length() == 0 && paren_string2.length()\
    \ == 0);\n    \n    return long[max_level];\n}\n</code>\nTo test the above function,\
    \ you can use this function in the following way:\n<code>\nimport std.array;\n\
    import std.conv;\nimport std.digest;\nimport std.range;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.random;\nimport std.stdio;\nunittest\n{\n  \
    \  alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpngm5u9ot.d(63): Error: found `[` when expecting `.` following long

    /tmp/tmpngm5u9ot.d(63): Error: found `]` when expecting `;` following `return`
    statement

    /tmp/tmpngm5u9ot.d(63): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpngm5u9ot.d(65): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpngm5u9ot.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ groups = paren_string.split(\" \");\n    long[] deepest_nesting = new long[groups.length];\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsv1uad5s.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsv1uad5s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<int>\
    \ parens;\n    int paren_depth;\n    paren_depth = 0;\n    parens.push();\n  \
    \  int cur_level = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8y64h4_h.d(14): Error: found `>` when expecting `.` following int

    /tmp/tmp8y64h4_h.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8y64h4_h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ levels = new long[paren_string.size()];\n\tlong current_level = 0;\n\tfor(int\
    \ i = 0; i < paren_string.size(); i++) {\n\t\tchar c = paren_string[i];\n\t\t\
    if(c == '(') {\n\t\t\tlevels[i] = current_level;\n\t\t\tcurrent_level++;\n\t\t\
    } else if(c == ')') {\n\t\t\tcurrent_level--;\n\t\t} else if(c == ' ') {\n\t\t\
    \tlevels[i] = current_level;\n\t\t}\n\t}\n\treturn levels;\n}\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv3njlw6w.d(14): Error: no property `size` for type `string`

    /tmp/tmpv3njlw6w.d(16): Error: no property `size` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv3njlw6w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ paren_string_with_groups = paren_string;\n    string[] group_tokens = paren_string_with_groups.Split(new[]\
    \ { ' ' }, StringSplitOptions.RemoveEmptyEntries);\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4v48bvwa.d(15): Error: basic type expected, not `[`

    /tmp/tmp4v48bvwa.d(15): Error: found `{` when expecting `,`

    /tmp/tmp4v48bvwa.d(15): Error: found `}` when expecting `,`

    /tmp/tmp4v48bvwa.d(15): Error: expression expected, not `,`

    /tmp/tmp4v48bvwa.d(15): Error: found `StringSplitOptions` when expecting `,`

    /tmp/tmp4v48bvwa.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4v48bvwa.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ num_open = 0, num_close = 0, num_open_brace = 0, num_close_brace = 0;\n    string\
    \ paren_substring;\n    vector<string> paren_groups;\n    vector<long> nesting_level;\n\
    \    char open_brace, close_brace;\n    for(int i = 0; i < paren_string.length();\
    \ ++i) {\n        open_brace = paren_string[i];\n        close_brace = paren_string[paren_string.length()\
    \ - 1];\n        paren_substring = \"\";\n        paren_substring = paren_string.substr(0,\
    \ i);\n        paren_substring = paren_substring;\n        paren_substring = paren_substring;\n\
    \        paren_substring = paren_substring;\n        if(open_brace == '(')\n \
    \           ++num_open_brace;\n        if(open_brace == '{')\n            ++num_open;\n\
    \        if(open_brace == '[')\n            ++num_open;\n        if(close_brace\
    \ == ')')\n            ++num_close_brace;\n        if(close_brace == '}')\n  \
    \          ++num_close;\n        if(close_brace == ']')\n            ++num_close;\n\
    \        if(open_brace == '{' && close_brace == '}')\n            ++num_close;\n\
    \        if(open_brace == '{' && close_brace == '[')\n            ++num_open;\n\
    \        if(open_brace == '(' && close_brace == ')')\n            ++num_close;\n\
    \        if(open_brace == '(' && close_brace == ']')\n            ++num_open;\n\
    \        if(open_brace == '[' && close_brace == ']')\n            ++num_open;\n\
    \        if(num_open < num_close && num_open < num_open_brace && num_open < num_close_brace)\
    \ {\n            nesting_level.push_back(num_close);\n            paren_groups.push_back(paren_substring);\n\
    \            paren_groups[paren_groups.size() - 1] += (char)open_brace;\n    \
    \    }\n    }\n    return nesting_level;\n}\n/*\n Input to this function is a\
    \ string represented nested parentheses separated by spaces.\n    For each of\
    \ the group, output the maximum level of nesting.\n    E.g. \"(()) has maximum\
    \ two levels of nesting while ((())) has three.\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjip_gnp3.d(16): Error: found `>` when expecting `;` following statement

    /tmp/tmpjip_gnp3.d(17): Error: found `>` when expecting `.` following long

    /tmp/tmpjip_gnp3.d(52): Error: C style cast illegal, use `cast(char)open_brace`

    /tmp/tmpjip_gnp3.d(57): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjip_gnp3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string[]\
    \ parens = paren_string.Split(\" \");\n    long[] levels = new long[parens.Length];\n\
    \    long level = 0;\n    bool inQuotes = false; // used to determine if we are\
    \ inside a set of quotes\n    long index = 0;\n    long index2 = 0;\n    long\
    \ index3 = 0;\n    \n    foreach(string paren in parens)\n    {\n        if (paren\
    \ == \"(\" || paren == \")\")\n        {\n            level++;\n        }\n  \
    \      else if (paren == \"[\" || paren == \"]\")\n        {\n            levels[index2]\
    \ = level;\n            index2++;\n        }\n        else if (paren == \"{\"\
    \ || paren == \"}\")\n        {\n            levels[index3] = level;\n       \
    \     index3++;\n        }\n        else if (paren == '\\'' && inQuotes == false)\n\
    \        {\n            inQuotes = true;\n        }\n        else if (paren ==\
    \ '\\'' && inQuotes == true)\n        {\n            inQuotes = false;\n     \
    \   }\n        else\n        {\n            throw new NotSupportedException(\"\
    This is not a valid parenthesis string: \" + paren);\n        }\n    }\n    \n\
    \    foreach(string paren in parens)\n    {\n        if (paren == \"(\" || paren\
    \ == \")\")\n        {\n            level--;\n        }\n        else if (paren\
    \ == \"[\" || paren == \"]\")\n        {\n            levels[index2] = level;\n\
    \            index2--;\n        }\n        else if (paren == \"{\" || paren ==\
    \ \"}\")\n        {\n            levels[index3] = level;\n            index3--;\n\
    \        }\n        else if (paren == '\\'' && inQuotes == false)\n        {\n\
    \            inQuotes = true;\n        }\n        else if (paren == '\\'' && inQuotes\
    \ == true)\n        {\n            inQuotes = false;\n        }\n        else\n\
    \        {\n            throw new NotSupportedException(\"This is not a valid\
    \ parenthesis string: \" + paren);\n        }\n    }\n    return levels;\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nthanks alot. i've had a look at the source\
    \ code and i'll try to understand it.\n<|/ c |>\n<| c |>\nhow would the c# function\
    \ look like?\n<|/ c |>\n<| c |>\n: You would just copy the code into your program,\
    \ changing `string` into `char[]`, and adding a `using System;` at the top.\n\
    <|/ c |>\n<| c |>\n: You would probably want to write a test program that actually\
    \ tests all the corner cases, rather than just throwing an `UnsupportedException`.\
    \  That would let you prove to yourself that your code works.  That would be a\
    \ good learning experience.  You'd also want to add some code to verify that the\
    \ parentheses work properly with expression\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx5q9wxck.d(22): Error: found `in` when expecting `;`

    /tmp/tmpx5q9wxck.d(52): Error: found `in` when expecting `;`

    /tmp/tmpx5q9wxck.d(83): Error: declaration expected, not `<`

    /tmp/tmpx5q9wxck.d(86): Error: unterminated character constant

    /tmp/tmpx5q9wxck.d(86): Error: unterminated character constant

    /tmp/tmpx5q9wxck.d(95): Error: unterminated character constant

    /tmp/tmpx5q9wxck.d(100): Error: declaration expected, not `assert`

    /tmp/tmpx5q9wxck.d(101): Error: declaration expected, not `assert`

    /tmp/tmpx5q9wxck.d(102): Error: declaration expected, not `assert`

    /tmp/tmpx5q9wxck.d(103): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx5q9wxck.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tstring[]\
    \ group_stack = new string[5];\n\tlong[] paren_groups = new long[4];\n\tlong paren_level;\n\
    \tint group_counter = 0;\n\tint i;\n\tfor(i = 0; i < paren_string.Length; i++)\n\
    \t{\n\t\tswitch (paren_string[i])\n\t\t{\n\t\t\tcase ')':\n\t\t\t{\n\t\t\t\tgroup_counter--;\n\
    \t\t\t\tif (group_counter == 0)\n\t\t\t\t{\n\t\t\t\t\tgroup_level++;\n\t\t\t\t\
    }\n\t\t\t\tgroup_stack[group_level] = group_counter;\n\t\t\t\tgroup_stack[group_level+1]\
    \ = group_stack[group_level];\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\
    {\n\t\t\t\tgroup_counter++;\n\t\t\t\tgroup_level++;\n\t\t\t\tgroup_stack[group_level]\
    \ = group_counter;\n\t\t\t\tgroup_stack[group_level+1] = group_stack[group_level];\n\
    \t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tgroup_level = 0;\n\tparen_level = 0;\n\t\
    for(i = 0; i < paren_string.Length; i++)\n\t{\n\t\tswitch (paren_string[i])\n\t\
    \t{\n\t\t\tcase ')':\n\t\t\t{\n\t\t\t\tparen_level--;\n\t\t\t\tif (paren_level\
    \ == -1)\n\t\t\t\t{\n\t\t\t\t\tparen_level--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\
    \t\t\tcase '(':\n\t\t\t{\n\t\t\t\tparen_level++;\n\t\t\t}\n\t\t\tbreak;\n\t\t\
    }\n\t}\n\tparen_level = 0;\n\tfor(i = 0; i < paren_string.Length; i++)\n\t{\n\t\
    \tswitch (paren_string[i])\n\t\t{\n\t\t\tcase ')':\n\t\t\t{\n\t\t\t\tparen_level--;\n\
    \t\t\t\tif (paren_level == -1)\n\t\t\t\t{\n\t\t\t\t\tparen_level--;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t{\n\t\t\t\tparen_level++;\n\t\
    \t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\tif (paren_groups[i]\
    \ != 0)\n\t\t{\n\t\t\tparen_groups[i] = paren_level;\n\t\t}\n\t}\n\treturn paren_groups;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn2s_3bxk.d(19): Error: no property `Length` for type `string`

    /tmp/tmpn2s_3bxk.d(28): Error: undefined identifier `group_level`

    /tmp/tmpn2s_3bxk.d(30): Error: undefined identifier `group_level`

    /tmp/tmpn2s_3bxk.d(31): Error: undefined identifier `group_level`

    /tmp/tmpn2s_3bxk.d(37): Error: undefined identifier `group_level`

    /tmp/tmpn2s_3bxk.d(38): Error: undefined identifier `group_level`

    /tmp/tmpn2s_3bxk.d(39): Error: undefined identifier `group_level`

    /tmp/tmpn2s_3bxk.d(44): Error: undefined identifier `group_level`

    /tmp/tmpn2s_3bxk.d(46): Error: no property `Length` for type `string`

    /tmp/tmpn2s_3bxk.d(48): Error: `switch` statement without a `default`; use `final
    switch` or add `default: assert(0);` or add `default: break;`

    /tmp/tmpn2s_3bxk.d(67): Error: no property `Length` for type `string`

    /tmp/tmpn2s_3bxk.d(69): Error: `switch` statement without a `default`; use `final
    switch` or add `default: assert(0);` or add `default: break;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn2s_3bxk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ level = 0;\n    Stack<long[]> stack = new Stack<long[]>();\n    for(int i =\
    \ 0; i < paren_string.length(); i++)\n    {\n        char c = paren_string[i];\n\
    \        if(c == '(')\n        {\n            level++;\n        }\n        else\
    \ if(c == ')')\n        {\n            level--;\n        }\n        else if(level\
    \ > 0)\n        {\n            long[] stack_tmp = new long[] {i, level};\n   \
    \         while(level > 0)\n            {\n                stack.push(stack_tmp);\n\
    \                stack_tmp = stack.pop();\n                level--;\n        \
    \    }\n        }\n    }\n    long[] result = new long[stack.size()];\n    for(int\
    \ i = 0; i < result.length; i++)\n    {\n        result[i] = stack.pop();\n  \
    \  }\n    return result;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,string,regex,c#\
    \ |>\n<| c |>\nCan you explain why you think this would solve the problem described\
    \ in the question?\n<|/ c |>\n<| c |>\nI disagree with the \"not working\" part.\
    \ OP stated that the code works when he uses `@\"\\(([^()]+)\\)\";`. That means\
    \ the regexp will match the whole string. `parse_nested_parens()` is an adaptation\
    \ of https://stackoverflow.com/a/52564413/661786 which works in the same way but\
    \ is slightly different in some cases. He stated that OP is trying to understand\
    \ his code and asked for a regex that matches that same string. So I am just pointing\
    \ out that his solution doesn't work because the regexp he is using doesn't match\
    \ the entire string.\n<|/ c |>\n<| c |>\nNo, I think you're misinterpreting what\
    \ OP wants to do. He states that his method works with `\"((()())())\"` but fails\
    \ with `\"(()())\"`. He also states that his method \"doesn't work\", but his\
    \ code still produces a result of 3L, which I believe is the correct result. OP\
    \ says \"I need a regex that can match \"((()())())\" but only when \"(()())\"\
    \ is in the string\". He did not state that he only wanted it to match `((())`\
    \ but not `()`. To me, that's what OP wants to do.\n<|/ c |>\n<| c |>\n\"I need\
    \ a regex that can match \"((()())())\" but only when \"(()())\" is in the string\"\
    \ I thought OP was saying that he only wanted to match `((())` but not `()`. I\
    \ agree with you that OP\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjw4_pret.d(15): Error: found `[` when expecting `.` following long

    /tmp/tmpjw4_pret.d(15): Error: found `]` when expecting identifier following `long`.

    /tmp/tmpjw4_pret.d(15): Error: found `>` when expecting `;` following statement

    /tmp/tmpjw4_pret.d(15): Error: found `[` when expecting `.` following long

    /tmp/tmpjw4_pret.d(15): Error: found `]` when expecting identifier following `long`.

    /tmp/tmpjw4_pret.d(15): Error: found `>` when expecting `;` following statement

    /tmp/tmpjw4_pret.d(15): Error: expression expected, not `)`

    /tmp/tmpjw4_pret.d(15): Error: found `;` when expecting `)`

    /tmp/tmpjw4_pret.d(16): Error: found `for` when expecting `;` following statement

    /tmp/tmpjw4_pret.d(16): Error: found `i` when expecting `.` following int

    /tmp/tmpjw4_pret.d(16): Error: found `=` when expecting identifier following `int`.

    /tmp/tmpjw4_pret.d(16): Error: found `0` when expecting `)`

    /tmp/tmpjw4_pret.d(16): Error: found `)` when expecting `;` following statement

    /tmp/tmpjw4_pret.d(29): Error: semicolon exp'
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ paren_start_index = 0;\n    int paren_end_index = 0;\n    int paren_level =\
    \ 0;\n    int previous_paren_level = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_ivzim35.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ivzim35.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tstring[]\
    \ parens = paren_string.split(\" \");\n\tlong[] out = new long[parens.length];\n\
    \tlong max_level = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpycgnxp6_.d(15): Error: no identifier for declarator `long[]`

    /tmp/tmpycgnxp6_.d(15): Error: found `out` instead of statement

    /tmp/tmpycgnxp6_.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpycgnxp6_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    map<string,\
    \ vector<string>> parens_to_level;\n    vector<string> parens;\n    stringstream\
    \ ss(paren_string);\n    string paren;\n    while (getline(ss, paren, ' '))\n\
    \    {\n        if (paren.empty())\n            continue;\n        parens.push_back(paren);\n\
    \        string current_level = \"\";\n        for (string::iterator i = paren.begin();\
    \ i < paren.end(); ++i)\n        {\n            if (*i == '(')\n             \
    \   current_level = current_level + \"L\";\n            else if (*i == ')')\n\
    \            {\n                string level_str = current_level.substr(0, current_level.size()-1);\n\
    \                parens_to_level.insert(pair<string, vector<string> >(*i, level_str));\n\
    \                current_level = level_str;\n            }\n        }\n    }\n\
    \    long max_level = 0;\n    long* level_array = new long[parens.size()];\n \
    \   for (int i = 0; i < parens.size(); ++i)\n    {\n        string current_level\
    \ = parens_to_level.at(parens[i]);\n        level_array[i] = atoi(current_level.c_str());\n\
    \        if (level_array[i] > max_level)\n            max_level = level_array[i];\n\
    \    }\n    delete[] level_array;\n    return max_level;\n}\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb38ru_4d.d(15): Error: found `>` when expecting `;` following statement

    /tmp/tmpb38ru_4d.d(24): Error: use `.` for member lookup, not `::`

    /tmp/tmpb38ru_4d.d(24): Error: found `i` when expecting `;` following `for` condition

    /tmp/tmpb38ru_4d.d(24): Error: expression expected, not `=`

    /tmp/tmpb38ru_4d.d(24): Error: found `paren` when expecting `)`

    /tmp/tmpb38ru_4d.d(24): Error: found `)` when expecting `;` following statement

    /tmp/tmpb38ru_4d.d(31): Error: found `>` when expecting `,`

    /tmp/tmpb38ru_4d.d(31): Error: expression expected, not `>`

    /tmp/tmpb38ru_4d.d(45): Error: found `level_array` when expecting `;` following
    statement

    /tmp/tmpb38ru_4d.d(45): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb38ru_4d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tif (paren_string.length()\
    \ <= 0)\n\t{\n\t\tthrow new ArgumentException(\"Invalid paren string\");\n\t}\n\
    \tstack<int> paren_stack;\n\tlong[] max_levels_of_nesting = new long[paren_string.length()];\n\
    \tint curr_level = 0;\n\tfor (auto i = 0; i < paren_string.length(); i++)\n\t\
    {\n\t\tchar c = paren_string[i];\n\t\tswitch (c)\n\t\t{\n\t\t\tcase ')':\n\t\t\
    \t\t{\n\t\t\t\t\t--curr_level;\n\t\t\t\t\tif (curr_level == 0)\n\t\t\t\t\t{\n\t\
    \t\t\t\t\tparen_stack.push(curr_level);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\
    \t\t\tcase '(':\n\t\t\t\t{\n\t\t\t\t\t++curr_level;\n\t\t\t\t\tif (curr_level\
    \ == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tparen_stack.push(curr_level);\n\t\t\t\t\t}\n\
    \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\t{\n\t\t\
    \t\t\tint paren_nesting = paren_stack.top();\n\t\t\t\t\tif (paren_nesting > curr_level)\n\
    \t\t\t\t\t{\n\t\t\t\t\t\tmax_levels_of_nesting[i] = paren_nesting;\n\t\t\t\t\t\
    }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmax_levels_of_nesting[i]\
    \ = curr_level;\n\t\t}\n\t}\n\treturn max_levels_of_nesting;\n}\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8f5jpxgv.d(18): Error: found `>` when expecting `.` following int

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8f5jpxgv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    if(paren_string.length()\
    \ == 0)\n        return long.ZERO;\n    \n    long[] levels = long.ZERO;\n   \
    \ levels[0] = paren_string.length() - 1;\n    \n    int current = 0;\n    bool\
    \ has_close_brace = paren_string.charAt(current) == '(';\n    int close_brace_level\
    \ = paren_string.length() - 1;\n    bool has_open_brace = paren_string.charAt(current)\
    \ == ')';\n    int open_brace_level = 1;\n    int open_open_level = 1;\n    \n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(has_close_brace)\n\
    \        {\n            open_brace_level--;\n            if(open_brace_level ==\
    \ 0)\n            {\n                levels[current] = close_brace_level;\n  \
    \              has_close_brace = false;\n                current++;\n        \
    \    }\n        }\n        else if(has_open_brace)\n        {\n            close_brace_level--;\n\
    \            if(close_brace_level == 0)\n            {\n                levels[current]\
    \ = open_brace_level;\n                has_open_brace = false;\n             \
    \   current++;\n            }\n        }\n        else if(paren_string.charAt(i)\
    \ == ')')\n        {\n            open_open_level--;\n            if(open_open_level\
    \ == 0)\n            {\n                levels[current] = open_open_level;\n \
    \               has_open_brace = true;\n                current++;\n         \
    \   }\n        }\n        else if(paren_string.charAt(i) == '(')\n        {\n\
    \            open_open_level++;\n            if(open_open_level == 0)\n      \
    \      {\n                levels[current] = open_open_level;\n               \
    \ has_close_brace = true;\n                current++;\n            }\n       \
    \ }\n    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ result = new long[paren_string.length()];\n\tint i, j, level, paren_level;\n\
    \tchar paren_char;\n\tstring temp_str;\n\t\n\tint count = 0;\n\tbool parens_left\
    \ = false;\n\tbool brackets_left = false;\n\t\n\tfor (i=0; i<paren_string.length();\
    \ i++) {\n\t\tparen_char = paren_string[i];\n\t\tparens_left = false;\n\t\tbrackets_left\
    \ = false;\n\t\t\n\t\t// Paren level\n\t\tif (paren_char == '(') parens_left =\
    \ true;\n\t\tif (paren_char == ')') parens_left = false;\n\t\t\n\t\t// Bracket\
    \ level\n\t\tif (paren_char == '[') brackets_left = true;\n\t\tif (paren_char\
    \ == ']') brackets_left = false;\n\t\t\n\t\t// Handle the parens\n\t\tif (parens_left\
    \ && brackets_left) {\n\t\t\tresult[count] = parens_left;\n\t\t\tparens_left =\
    \ false;\n\t\t\tbrackets_left = false;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t// Handle\
    \ brackets\n\t\tif (parens_left && !brackets_left) {\n\t\t\tresult[count] = brackets_left;\n\
    \t\t\tparens_left = false;\n\t\t\tbrackets_left = false;\n\t\t\tcount++;\n\t\t\
    }\n\t\t\n\t\t// Handle brackets\n\t\tif (!parens_left && brackets_left) {\n\t\t\
    \tresult[count] = brackets_left;\n\t\t\tparens_left = false;\n\t\t\tbrackets_left\
    \ = false;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t}\n\treturn result;\n}\n/*\n    Function\
    \ to compute the maximum depth of the parenthesis and nested brackets.\n    \n\
    \    input (string) paren_string:\n        a string represented multiple groups\
    \ of parentheses separated by spaces.\n        \n    output (int) max_level:\n\
    \        Maximum level of nesting in the string.\n*/\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwa_z_c1q.d(14): Error: no property `length` for type `string`

    /tmp/tmpwa_z_c1q.d(23): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwa_z_c1q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tassert(paren_string.length()\
    \ != 0);\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9612qv7i.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9612qv7i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_level;\n    string parens_pattern = \"\\\\((.+?)\\\\)\";\n    long paren_nesting_depth\
    \ = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6k6ieurz.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6k6ieurz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tif (paren_string.length()\
    \ == 0)\n\t\treturn long.empty;\n\t\n\tlong[] level = new long[paren_string.length()];\n\
    \tlong max_level = 0;\n\t\n\tfor (int i = 0; i < level.length; i++)\n\t\tlevel[i]\
    \ = 0;\n\t\n\tint open = 0;\n\tint close = 0;\n\t\n\tfor (int i = 0; i < paren_string.length();\
    \ i++)\n\t{\n\t\tchar c = paren_string[i];\n\t\t\n\t\tif (c == '(')\n\t\t{\n\t\
    \t\topen++;\n\t\t}\n\t\telse if (c == ')')\n\t\t{\n\t\t\tclose++;\n\t\t}\n\t\t\
    else if (c == '\\0')\n\t\t\tbreak;\n\t\t\n\t\tlevel[i] = max(level[i], open);\n\
    \t\tlevel[i] = min(level[i], close);\n\t\t\n\t\tmax_level = max(max_level, level[i]);\n\
    \t}\n\t\n\treturn level;\n}\n/*\n Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    For each of\
    \ the group, output the deepest level of nesting of parentheses.\n    E.g. (()())\
    \ has maximum two levels of nesting while ((())) has three.\nunittest\n{\n   \
    \ alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpd_b1ltsx.d(49): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd_b1ltsx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Find\
    \ parenthesis starting locations\n    int[] parens_starts = paren_string.find_parens_starts();\n\
    \    // Find starting locations of each parenthesis\n    int[] paren_starts =\
    \ find_paren_starts(parens_starts);\n    // Count depth of nesting of each parenthesis\n\
    \    long[] depths = count_nested_depths(paren_starts);\n    return depths;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0pt_w584.d(15): Error: no property `find_parens_starts` for type
    `string`

    /tmp/tmp0pt_w584.d(17): Error: undefined identifier `find_paren_starts`

    /tmp/tmp0pt_w584.d(19): Error: undefined identifier `count_nested_depths`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0pt_w584.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = { 0 };\n    bool is_first = true;\n    foreach (char c in paren_string)\
    \ {\n        if (c == '(') {\n            if (is_first) {\n                levels[0]++;\n\
    \                is_first = false;\n            } else {\n                levels[1]++;\n\
    \            }\n        } else if (c == ')') {\n            if (is_first) {\n\
    \                levels[0]--;\n            } else {\n                levels[1]--;\n\
    \            }\n        } else {\n            assert(c == ' ');\n        }\n \
    \   }\n    return levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphlifkm3n.d(16): Error: found `in` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphlifkm3n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    if(\
    \ !paren_string.endsWith( \")\" ) )\n        paren_string = paren_string + \"\
    )\";\n    string opening_paren = paren_string.substr(0, paren_string.find_first_of(\"\
    ()\"));\n    string closing_paren = paren_string.substr(paren_string.find_last_of(\"\
    ()\") + 1, paren_string.length());\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpubx7qmc5.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpubx7qmc5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ res = new long[paren_string.length()];\n    int cnt = 0;\n    \n    for(int\
    \ i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i] ==\
    \ '(')\n        {\n            if(paren_string[i + 1] == '(')\n            {\n\
    \                res[cnt++] = 2L;\n            }\n            else\n         \
    \   {\n                res[cnt++] = 1L;\n            }\n        }\n        else\
    \ if(paren_string[i] == ')')\n        {\n            if(paren_string[i + 1] ==\
    \ '(')\n            {\n                res[cnt++] = 3;\n            }\n      \
    \      else\n            {\n                res[cnt++] = 2L;\n            }\n\
    \        }\n        else\n        {\n            res[cnt++] = paren_string[i]\
    \ + 1;\n        }\n    }\n    return res;\n}\n</code>\nThe above function returns\
    \ the result in a long[].\nTo test it:\n<code>\nimport std.string;\nimport std.array;\n\
    import std.stdio;\nimport std.typecons;\nimport std.math;\nimport std.conv;\n\
    /*\n Input to this function is a string represented multiple groups for nested\
    \ parentheses separated by spaces.\n    For each of the group, output the deepest\
    \ level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of\
    \ nesting while ((())) has three.\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tw2qu0g.d(48): Error: declaration expected, not `<`

    /tmp/tmp_tw2qu0g.d(58): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_tw2qu0g.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string[]\
    \ paren_groups = paren_string.split(\" \");\n    long[] result = new long[paren_groups.length];\n\
    \    long max_level = 1;\n    for(int i=0; i < paren_groups.length; i++) {\n \
    \       // Remove first parenthesis (if present)\n        if(paren_groups[i].length()\
    \ > 0) {\n            paren_groups[i] = paren_groups[i].substring(1);\n      \
    \  }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpheowg2pw.d(22): Error: found `unittest` instead of statement

    /tmp/tmpheowg2pw.d(30): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpheowg2pw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    unordered_map<char,\
    \ unordered_map<int, long>> paren_nest;\n    int level = 0, level_max_nest = 0;\n\
    \    int opening_parens = 0, open_parens_level = 0;\n    string current_level\
    \ = paren_string;\n    unordered_map<char, int> char_count;\n    unordered_map<int,\
    \ long> nesting_counts;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt0a5qupi.d(14): Error: found `,` when expecting `.` following char

    /tmp/tmpt0a5qupi.d(14): Error: found `<` when expecting `;` following statement

    /tmp/tmpt0a5qupi.d(14): Error: no identifier for declarator `int`

    /tmp/tmpt0a5qupi.d(14): Error: found `,` instead of statement

    /tmp/tmpt0a5qupi.d(18): Error: found `,` when expecting `.` following char

    /tmp/tmpt0a5qupi.d(18): Error: found `int` when expecting identifier following
    `char`.

    /tmp/tmpt0a5qupi.d(18): Error: found `>` when expecting `;` following statement

    /tmp/tmpt0a5qupi.d(19): Error: found `,` when expecting `.` following int

    /tmp/tmpt0a5qupi.d(19): Error: found `long` when expecting identifier following
    `int`.

    /tmp/tmpt0a5qupi.d(19): Error: found `>` when expecting `;` following statement

    /tmp/tmpt0a5qupi.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt0a5qupi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // TODO:\
    \ rewrite this to use stacks instead\n    string str = paren_string;\n    stack<string>\
    \ levelStack;\n    string curLevel;\n    string curStack = \"\";\n    long maxLevel\
    \ = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn2k_83q3.d(16): Error: found `>` when expecting `;` following statement

    /tmp/tmpn2k_83q3.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn2k_83q3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tauto paren\
    \ = paren_string.find_first_of(\"()\");\n\tlong number_of_open_brackets = 0;\n\
    \tlong maximum_number_of_open_brackets = 0;\n\tlong paren_level = 0;\n\tbool first_time_encountering_parens\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6iz09ruy.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6iz09ruy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  long level\
    \ = 0;\n  stack<string> parenStack = new stack<string>();\n  stack<string> levelStack\
    \ = new stack<string>();\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0hrq06bu.d(15): Error: found `>` when expecting `;` following statement

    /tmp/tmp0hrq06bu.d(15): Error: found `>` when expecting `;` following statement

    /tmp/tmp0hrq06bu.d(15): Error: expression expected, not `)`

    /tmp/tmp0hrq06bu.d(15): Error: found `;` when expecting `)`

    /tmp/tmp0hrq06bu.d(16): Error: found `stack` when expecting `;` following statement

    /tmp/tmp0hrq06bu.d(16): Error: found `<` instead of statement

    /tmp/tmp0hrq06bu.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0hrq06bu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    var\
    \ max_level = 0;\n    var max_level_paren = 0;\n    long level = 0;\n    long\
    \ paren = 0;\n    long levels_left_to_right = 0;\n    bool found_paren = false;\n\
    \    bool found_left_paren = false;\n    bool found_right_paren = false;\n   \
    \ for(int i=0; i<paren_string.length; ++i)\n    {\n        if (paren_string[i]\
    \ == '(')\n        {\n            if (level > max_level)\n            {\n    \
    \            max_level = level;\n                max_level_paren = paren;\n  \
    \          }\n            level++;\n            paren = 0;\n            found_paren\
    \ = true;\n        }\n        else if (paren_string[i] == ')')\n        {\n  \
    \          if (level == max_level)\n            {\n                levels_left_to_right\
    \ = paren;\n            }\n            level--;\n            found_paren = true;\n\
    \        }\n        else if (paren_string[i] == '(')\n        {\n            paren++;\n\
    \            found_left_paren = true;\n        }\n        else if (paren_string[i]\
    \ == ')')\n        {\n            paren--;\n            found_right_paren = true;\n\
    \        }\n        else\n        {\n            error(\"parse_nested_parens\"\
    , 0, \"Unexpected character %c in the paren string \\\"%s\\\"\", paren_string[i],\
    \ paren_string.c_str());\n        }\n    }\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2c7anoll.d(59): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2c7anoll.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  // TODO:\
    \ Rewrite this to handle empty paren string\n  long count = 0; // Level of nesting\
    \ of a pair of parentheses\n  long index = 0;\n  stack<int> open_paren;\n  stack<string>\
    \ paren_strings;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw_g53uuu.d(17): Error: found `>` when expecting `.` following int

    /tmp/tmpw_g53uuu.d(18): Error: found `>` when expecting `;` following statement

    /tmp/tmpw_g53uuu.d(19): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw_g53uuu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    if (paren_string\
    \ == \"\" || paren_string.length() == 0)\n    {\n        return null;\n    }\n\
    \    Stack<long> nested_depths = new Stack<long>();\n    long[] results = new\
    \ long[paren_string.Length];\n    int i = 0;\n    while (i < paren_string.Length)\n\
    \    {\n        char c = paren_string[i];\n        switch (c)\n        {\n   \
    \         case '(':\n                nested_depths.push(i);\n                break;\n\
    \            case ')':\n                nested_depths.pop();\n               \
    \ break;\n            default:\n                results[i] = nested_depths.top();\n\
    \                nested_depths.pop();\n                results[i + 1] = nested_depths.top();\n\
    \                nested_depths.pop();\n                break;\n        }\n   \
    \     i += 1;\n    }\n    return results;\n}\n// end of function parse_nested_parens\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4puudt0y.d(18): Error: found `>` when expecting `.` following long

    /tmp/tmp4puudt0y.d(18): Error: found `>` when expecting `.` following long

    /tmp/tmp4puudt0y.d(18): Error: found `(` when expecting identifier following `long`.

    /tmp/tmp4puudt0y.d(18): Error: found `)` when expecting `;` following statement

    /tmp/tmp4puudt0y.d(18): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4puudt0y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t// Write\
    \ your code here.\n    int paren = 0;\n    int bracket = 0;\n    int depth = 0;\n\
    \    long[] output = new long[paren_string.length()];\n    bool stack[paren_string.length()];\n\
    \    for (int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n            stack[paren] = true;\n        else if(paren_string[i] ==\
    \ ')')\n            stack[paren] = false;\n        else\n            stack[paren]\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyul52rau.d(19): Deprecation: instead of C-style syntax, use D-style
    syntax `bool[paren_string.length()] stack`

    /tmp/tmpyul52rau.d(28): Error: found `unittest` instead of statement

    /tmp/tmpyul52rau.d(36): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyul52rau.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.size()];\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8hh_pzlb.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8hh_pzlb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ paren_vals = new long[paren_string.Length];\n\t\n\tint level_of_nesting = 0;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfsca2_wu.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfsca2_wu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_count = 0;\n    long current_count = 1;\n    long last_count = 1;\n    long\
    \ max_level = 0;\n    long level = -1;\n    long deepest_level = 0;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2c3daym4.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2c3daym4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tint opening\
    \ = paren_string.find_first_of('(', 0);\n\tint closing = paren_string.find_first_of(')',\
    \ opening);\n\tif (closing == -1L) return null;\n\tlong[] depths = new long[closing\
    \ - opening + 1];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7974bpts.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7974bpts.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  std.typecons.ListNode\
    \ parens = std.typecons.ListNode.fromString(paren_string);\n  long[] result =\
    \ new long[parens.count / 2];\n  long depth = 1;\n  for(auto el : parens)\n  {\n\
    \    if(!el.isNode() || el.isLeaf())\n    {\n      depth++;\n      continue;\n\
    \    }\n    string sub_str = el.value.stringValue();\n    std.typecons.ListNode\
    \ sub_parens = std.typecons.ListNode.fromString(sub_str);\n    for(auto sub_el\
    \ : sub_parens)\n    {\n      string sub_sub_str = sub_el.value.stringValue();\n\
    \      std.typecons.ListNode sub_sub_parens = std.typecons.ListNode.fromString(sub_sub_str);\n\
    \      long sub_sub_depth = sub_sub_parens.count / 2;\n      if(depth > sub_sub_depth)\n\
    \      {\n        depth = sub_sub_depth;\n      }\n    }\n  }\n  return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplf9gpogp.d(17): Error: no identifier for declarator `el`

    /tmp/tmplf9gpogp.d(17): Error: expression expected, not `:`

    /tmp/tmplf9gpogp.d(17): Error: found `parens` when expecting `;` following `for`
    condition

    /tmp/tmplf9gpogp.d(26): Error: no identifier for declarator `sub_el`

    /tmp/tmplf9gpogp.d(26): Error: expression expected, not `:`

    /tmp/tmplf9gpogp.d(26): Error: found `sub_parens` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplf9gpogp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr0x9yb_7.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr0x9yb_7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ s = paren_string;\n    long n = s.length();\n    long[] levels = new long[n];\n\
    \    \n    long level = 0;\n    long current = 0;\n    long next = 0;\n    int\
    \ open_brackets = 0;\n    int close_brackets = 0;\n    \n    stack<long> brackets_stack\
    \ = new stack<long>();\n    \n    for(int i = 0; i < n; i++) {\n        if(s.charAt(i)\
    \ == '(') open_brackets++;\n        else if(s.charAt(i) == ')') close_brackets++;\n\
    \        \n        if(open_brackets > 0 && close_brackets == 0) {\n          \
    \  levels[next] = level;\n            brackets_stack.push(next);\n           \
    \ level++;\n            open_brackets = 0;\n            close_brackets = 0;\n\
    \            next++;\n        }\n        else if(open_brackets == 0 && close_brackets\
    \ > 0) {\n            current = brackets_stack.top();\n            levels[current]\
    \ = level;\n            brackets_stack.pop();\n            level--;\n        \
    \    open_brackets = 0;\n            close_brackets = 0;\n        }\n        else\
    \ if(open_brackets == 0 && close_brackets == 0) {\n            levels[next] =\
    \ level;\n            level++;\n            next++;\n            open_brackets\
    \ = 0;\n            close_brackets = 0;\n        }\n    }\n    \n    return levels;\n\
    }\n</code>\n<|/ a dscore=1 tags=regex,c# |>\n<| c |>\nI checked and your code\
    \ worked for most examples, but failed for some others. I posted a sample of input\
    \ and output.\n<|/ c |>\n<| c |>\nThanks a lot that seems to work perfectly. Could\
    \ you explain the regex though a bit please? I am relatively new to using regex\
    \ and my understanding is a bit rusty.\n<|/ c |>\n<| c |>\nAwesome! I appreciate\
    \ the explanation as well.\n<|/ c |>\n<| c |>\nYes. I appreciate that. Thanks\
    \ again for the help! I am learning regexes and your explanation made everything\
    \ much easier to understand.\n<|/ c |>\n<| a dscore=0 |>\nFor a Regex that does\
    \ NOT use the non-capturing groups (?:) this is more efficient than others posted\
    \ here.  \n<code>\nvar input = \"((() ((((()())))(()))()()))\";\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqjl8_sba.d(24): Error: found `>` when expecting `.` following long

    /tmp/tmpqjl8_sba.d(24): Error: found `>` when expecting `.` following long

    /tmp/tmpqjl8_sba.d(24): Error: found `(` when expecting identifier following `long`.

    /tmp/tmpqjl8_sba.d(24): Error: found `)` when expecting `;` following statement

    /tmp/tmpqjl8_sba.d(24): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpqjl8_sba.d(57): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqjl8_sba.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ result = new long[paren_string.length()];\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_6ajdmng.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_6ajdmng.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tchar[]\
    \ paren_chars = paren_string.toCharArray();\n\tArrayList paren_levels = new ArrayList();\n\
    \tlong paren_count = 1;\n\tfor (int i = 0; i < paren_chars.length; i++) {\n\t\t\
    if (paren_chars[i] == '(') \n\t\t\tparen_levels.add(paren_count);\n\t\telse if\
    \ (paren_chars[i] == ')') {\n\t\t\tif (paren_levels.lastElement() > 0) {\n\t\t\
    \t\tparen_levels.remove(paren_levels.lastElement() - 1);\n\t\t\t\tparen_count\
    \ += paren_levels.lastElement();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparen_levels.add(paren_count);\n\
    \t\t\t}\n\t\t}\n\t\telse if (paren_chars[i] == ' ') {\n\t\t\tparen_count = 1;\n\
    \t\t\tparen_levels.clear();\n\t\t}\n\t}\n\treturn paren_levels.getRange(0, paren_levels.size());\n\
    }\n</code>\n<|/ a dscore=4 tags=java,algorithm,recursion |>\n<| c |>\nIt's a nice\
    \ recursive solution, but it does not handle cases like `((((())))`, where the\
    \ level of nested parentheses is `2`.\n<|/ c |>\n<| c |>\nIndeed. The OP didn't\
    \ specify what should happen with the string. I just thought it would be helpful\
    \ to give an answer that at least somewhat works.\n<|/ c |>\n<| c |>\nThe question\
    \ is tagged 'java' so I believe it would be helpful to give a java answer.\n<|/\
    \ c |>\n<| c |>\nI've updated the answer. Hope it helps :)\n<|/ c |>\n<| c |>\n\
    I believe that this still does not handle cases like `(((())()))` where the number\
    \ of nested parentheses is `2`. It's still only handling the case where the level\
    \ of nesting for a set of parentheses is at most `n`, where `n` is the maximum\
    \ nesting level of the input.\n<|/ c |>\n<| a |>\nHere is an example of a recursive\
    \ solution that counts how many nested parentheses there are in a string. \nThe\
    \ important thing is to consider all the characters from the first to the current\
    \ position of the character. \nA recursive solution like this has the advantage\
    \ of being able to handle strings with multiple nested parentheses.\n<code>\n\
    static int count_nested_parentheses(String s) {\n    if (s.length() == 0) {\n\
    \        return 0;\n    }\n    if (s.charAt(0) == '(') {\n        int left = count_nested_parentheses(s.substring(1));\n\
    \        int right = count_nested_parentheses(s.substring(1));\n        return\
    \ left + right;\n    }\n    if (s.charAt(0) == ')') {\n        return count_nested_parentheses(s.substring(1));\n\
    \    }\n    return 1 + count_nested_parentheses(s.substring(1));\n}\n</code>\n\
    <|/ a tag\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsyk65__3.d(36): Error: declaration expected, not `<`

    /tmp/tmpsyk65__3.d(39): Error: unterminated character constant

    /tmp/tmpsyk65__3.d(42): Error: unterminated character constant

    /tmp/tmpsyk65__3.d(45): Error: unterminated character constant

    /tmp/tmpsyk65__3.d(45): Error: unterminated character constant

    /tmp/tmpsyk65__3.d(48): Error: unterminated character constant

    /tmp/tmpsyk65__3.d(51): Error: unterminated character constant

    /tmp/tmpsyk65__3.d(61): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsyk65__3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  string\
    \ groups = paren_string;\n  groups = remove_outer_parens(groups);\n  groups =\
    \ remove_double_backslashes(groups);\n  groups = remove_escapes(groups);\n  \n\
    \  long[] levels = count_levels(groups);\n  \n  return levels;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjvm6gsvz.d(15): Error: undefined identifier `remove_outer_parens`

    /tmp/tmpjvm6gsvz.d(16): Error: undefined identifier `remove_double_backslashes`

    /tmp/tmpjvm6gsvz.d(17): Error: undefined identifier `remove_escapes`

    /tmp/tmpjvm6gsvz.d(19): Error: undefined identifier `count_levels`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjvm6gsvz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ temp_string = \"\";\n    long temp_int_max = 1;\n    long[] temp_long = new\
    \ long[paren_string.length()];\n    int i = 0;\n    int j = 0;\n    \n    //parse\
    \ all groups of nested parenthesis\n    while (i < paren_string.length()) {\n\
    \        //check if this is a group ending parenthesis\n        if (paren_string[i]\
    \ == '(') {\n            int temp = i;\n            temp_string = paren_string.substr(i,\
    \ paren_string.length() - i);\n            //parse group ending parenthesis\n\
    \            while (i < paren_string.length() && !paren_string[i] == '(') {\n\
    \                temp_string = temp_string + paren_string.substr(i++, paren_string.length()\
    \ - i);\n            }\n            //append the number of the current group to\
    \ temp_int\n            int num_group = std.parseuint(temp_string);\n        \
    \    temp_int_max = std.max(temp_int_max, num_group);\n        }\n        //check\
    \ if this is a group starting parenthesis\n        else if (paren_string[i] ==\
    \ ')') {\n            temp_int++;\n            //get the current group starting\
    \ parenthesis\n            int temp_int = i;\n            //get the rest of the\
    \ group and append to temp_string\n            temp_string = paren_string.substr(i,\
    \ paren_string.length() - i);\n            //parse group ending parenthesis\n\
    \            while (i < paren_string.length() && !paren_string[i] == ')') {\n\
    \                temp_string = temp_string + paren_string.substr(i++, paren_string.length()\
    \ - i);\n            }\n            //append the number of the current group to\
    \ temp_int\n            int num_group = std.parseuint(temp_string);\n        \
    \    temp_int_max = std.max(temp_int_max, num_group);\n        }\n        //check\
    \ if this is a group ending parenthesis\n        else if (paren_string[i] == '\
    \ ') {\n            //get the current group ending parenthesis\n            int\
    \ temp_int = i;\n            //get the rest of the group and append to temp_string\n\
    \            temp_string = paren_string.substr(i, paren_string.length() - i);\n\
    \            //parse group ending parenthesis\n            while (i < paren_string.length()\
    \ && !paren_string[i] == ' ') {\n                temp_string = temp_string + paren_string.substr(i++,\
    \ paren_string.length() - i);\n            }\n            //append the number\
    \ of the current group to temp_int\n            int num_group = std.parseuint(temp_string);\n\
    \            temp_int_max = std.max(temp_int_max, num_group);\n        }\n   \
    \     //check if this is a group starting parenthesis\n        else if (paren_string[i]\
    \ == '-') {\n            //get the current group ending parenthesis\n        \
    \    int temp_int = i;\n            //get the rest of the group and append to\
    \ temp_string\n            temp_string = paren_string.substr(i, paren_string.length()\
    \ - i);\n            //parse group ending parenthesis\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdu8536bo.d(70): Error: found `unittest` instead of statement

    /tmp/tmpdu8536bo.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpdu8536bo.d(78): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdu8536bo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = {0}; //result will contain the deepest number of nesting levels.\n\
    \    auto iter = paren_string.begin();\n    auto end = paren_string.end();\n \
    \   for (auto i = iter; !i==end; i=iter+1) {\n        switch (*i) {\n        \
    \    case '(':\n                ++i;\n                for (auto j = i; !j==end\
    \ && paren_string[j]!=')'; j=j+1) {\n                    ++j;\n              \
    \  }\n                result[result.length-1] += (j==end ? 0 : 1);\n         \
    \       iter=j;\n                break;\n            case ')':\n             \
    \   --i;\n                for (auto j = i; !j==end && paren_string[j]!='('; j=j+1)\
    \ {\n                    --j;\n                }\n                result[result.length-1]\
    \ += (j==end ? 0 : 1);\n                iter=j;\n                break;\n    \
    \        default:\n                iter+=1;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0waf5hz1.d(14): Error: a struct is not a valid initializer for
    a `long[]`

    /tmp/tmp0waf5hz1.d(15): Error: no property `begin` for type `string`

    /tmp/tmp0waf5hz1.d(16): Error: no property `end` for type `string`

    /tmp/tmp0waf5hz1.d(24): Error: undefined identifier `j`

    /tmp/tmp0waf5hz1.d(32): Error: undefined identifier `j`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0waf5hz1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ num_open = 0, num_close = 0;\n    long num_levels = 0;\n    Stack<long> parenStack;\n\
    \    char[] chars = paren_string.toCharArray();\n    for (int i = 0, len = chars.length;\
    \ i < len; ++i) {\n        if (chars[i] == '(') \n            parenStack.push(num_open++);\n\
    \        else if (chars[i] == ')') \n            num_close += parenStack.pop();\n\
    \        else\n            num_levels += (parenStack.empty() ? 0 : parenStack.top());\n\
    \    }\n    if (parenStack.empty())\n        num_levels = 1;\n    if (num_open\
    \ != num_close)\n        num_levels = 1;\n    if (num_levels != 0)\n        num_levels--;\n\
    \    return newlong[num_levels];\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxb_ec0tg.d(16): Error: found `>` when expecting `.` following long

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxb_ec0tg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  int paren_level\
    \ = 0;\n  int open_paren_counter = 0;\n  long[] max_level_array = new long[paren_string.length()];\n\
    \  for(int i = 0; i < paren_string.length(); i++) {\n    char c = paren_string[i];\n\
    \    if(c == '(') {\n      open_paren_counter++;\n    } else if(c == ')') {\n\
    \      open_paren_counter--;\n    } else if(c == ' ') {\n      if(open_paren_counter\
    \ == paren_level) {\n        max_level_array[i] = max_level_array[i - 1];\n  \
    \    } else {\n        max_level_array[i] = paren_level;\n      }\n      paren_level\
    \ = 0;\n    } else {\n      paren_level++;\n    }\n  }\n  return max_level_array;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis solution will not work for input\
    \ `((())())` since your code treats parenthesis as separate delimiters.\n<|/ c\
    \ |>\n<| a dscore=0 tags=string,regex,pattern-matching,java |>\nUsing a regex\
    \ and split\n<code>\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphgnfc7cx.d(36): Error: declaration expected, not `<`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphgnfc7cx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    List<long>\
    \ level_stack = new List<long>();\n    long current_level = 0;\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphmaxns59.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmphmaxns59.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmphmaxns59.d(14): Error: found `(` when expecting identifier following `long`.

    /tmp/tmphmaxns59.d(14): Error: found `)` when expecting `;` following statement

    /tmp/tmphmaxns59.d(14): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmphmaxns59.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphmaxns59.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    int num_levels = 0;\n    bool\
    \ in_parantheses;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdifqf5bk.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdifqf5bk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    if(\
    \ paren_string.length() == 0 )\n    {\n        return newlong[0];\n    }\n   \
    \ string parens[] = paren_string.split(' ');\n    int max_level = 0;\n    long[]\
    \ result = newlong[0];\n    for( int i = 1; i < parens.length; ++i )\n    {\n\
    \        int level = parens.Length - i;\n        if( parens[i][0] == '(' )\n \
    \       {\n            int j = i;\n            while( ( parens[j][ 0 ] != '('\
    \ && parens[j][ 0 ] != ')' ) && j < parens.length )\n            {\n         \
    \       ++j;\n            }\n            if( j == parens.length )\n          \
    \  {\n                throw new Exception(\"Unbalanced parentheses in \" + paren_string);\n\
    \            }\n            string substr = parens[j];\n            if( substr.length()\
    \ >= 2 )\n            {\n                --j;\n                string left = substr;\n\
    \                string right = substr.substr( 1, substr.Length - 2 );\n     \
    \           if( left == right )\n                {\n                    throw\
    \ new Exception(\"Unbalanced parentheses in \" + paren_string);\n            \
    \    }\n                if( left.Length > right.Length )\n                {\n\
    \                    right = right.substr( 0, left.Length - right.Length );\n\
    \                }\n                string left_str = left.substr( 1, left.Length\
    \ - 1 );\n                string right_str = right.substr( 1, right.Length - 1\
    \ );\n                if( left_str == right_str )\n                {\n       \
    \             throw new Exception(\"Unbalanced parentheses in \" + paren_string);\n\
    \                }\n            }\n            if( level > max_level )\n     \
    \       {\n                result = newlong[0];\n                max_level = level;\n\
    \            }\n            for( int k = 0; k < level; ++k )\n            {\n\
    \                result = newlong[result.length + 1];\n            }\n       \
    \     for( int k = 0; k < level; ++k )\n            {\n                result[\
    \ k ] = long.MaxValue;\n            }\n            result[ level ] = long.MaxValue;\n\
    \        }\n        else\n        {\n            int j = i;\n            while(\
    \ ( parens[j][ 0 ] != ')' && parens[j][ 0 ] != ')' ) && j < parens.length )\n\
    \            {\n                ++j;\n            }\n            if( j == parens.length\
    \ )\n            {\n                throw new Exception(\"Unbalanced parentheses\
    \ in \" + paren_string);\n            }\n            string substr = parens[j];\n\
    \            if( substr.length() >= 2 )\n            {\n                --j;\n\
    \                string left = substr;\n                string right = substr.substr(\
    \ 1, substr.Length - 2 );\n                if( left == right )\n             \
    \   {\n                    throw new Exception(\"Unbalanced parentheses in \"\
    \ + paren_string);\n                }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpen_3zwja.d(18): Deprecation: instead of C-style syntax, use D-style
    syntax `string[] parens`

    /tmp/tmpen_3zwja.d(92): Error: found `unittest` instead of statement

    /tmp/tmpen_3zwja.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpen_3zwja.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpen_3zwja.d(100): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpen_3zwja.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ paren_max_depth = 0;\n    long depth = 0;\n    stack<int> paren_depth_stack;\n\
    \    map<string, int> paren_nesting_map;\n    for(auto c : paren_string) {\n \
    \       switch(c) {\n        case '(':\n            paren_depth_stack.push(depth);\n\
    \            depth += 1;\n            break;\n        case ')':\n            paren_depth_stack.push(depth);\n\
    \            long current_depth = paren_depth_stack.pop();\n            depth\
    \ -= 1;\n            if(current_depth > paren_max_depth) {\n                paren_max_depth\
    \ = current_depth;\n            }\n            break;\n        }\n    }\n    while(!paren_depth_stack.empty())\
    \ {\n        depth += 1;\n        paren_depth_stack.pop();\n    }\n    for(int\
    \ i = 0; i < paren_depth_stack.size(); i++) {\n        long current_depth = paren_depth_stack.top();\n\
    \        if(current_depth > paren_max_depth) {\n            paren_max_depth =\
    \ current_depth;\n        }\n    }\n    long[] result = new long[paren_max_depth];\n\
    \    for(int i = 0; i < paren_depth_stack.size(); i++) {\n        long current_depth\
    \ = paren_depth_stack.top();\n        result[current_depth] = i;\n        paren_depth_stack.pop();\n\
    \    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2fn6anqk.d(16): Error: found `>` when expecting `.` following int

    /tmp/tmp2fn6anqk.d(17): Error: found `>` when expecting `.` following int

    /tmp/tmp2fn6anqk.d(18): Error: no identifier for declarator `c`

    /tmp/tmp2fn6anqk.d(18): Error: expression expected, not `:`

    /tmp/tmp2fn6anqk.d(18): Error: found `paren_string` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2fn6anqk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ results = new long[paren_string.Length];\n\tStack<long> stack = new Stack<long>();\n\
    \tlong level = 0;\n\tbool inside_group = false;\n\tfor (int i = 0; i < paren_string.Length;\
    \ ++i)\n\t{\n\t\tchar c = paren_string[i];\n\t\tif ((c == '(' || c == '[') &&\
    \ inside_group == false)\n\t\t{\n\t\t\tinside_group = true;\n\t\t\tstack.push(level);\n\
    \t\t\t++level;\n\t\t}\n\t\telse if ((c == ')' || c == ']') && inside_group ==\
    \ true)\n\t\t{\n\t\t\tlevel = stack.pop();\n\t\t\t++level;\n\t\t\tinside_group\
    \ = false;\n\t\t}\n\t\telse if (inside_group == true)\n\t\t\t++level;\n\t\telse\n\
    \t\t\tstack.Pop();\n\t\tresults[i] = level;\n\t}\n\treturn results;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpngdld46e.d(15): Error: found `>` when expecting `.` following long

    /tmp/tmpngdld46e.d(15): Error: found `>` when expecting `.` following long

    /tmp/tmpngdld46e.d(15): Error: found `(` when expecting identifier following `long`.

    /tmp/tmpngdld46e.d(15): Error: found `)` when expecting `;` following statement

    /tmp/tmpngdld46e.d(15): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpngdld46e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<int>\
    \ paren_stack;\n    paren_stack.push(0)\n    long result = 0;\n    for(int i =\
    \ 0; i < paren_string.length; i ++)\n    {\n        // Handle opening paren\n\
    \        if(paren_string[i] == '(')\n        {\n            // If we had an opening\
    \ paren already, pop off the top and add the current one\n            if(paren_stack.top()\
    \ > 0)\n            {\n                result = result + paren_stack.top();\n\
    \                paren_stack.pop();\n            }\n            paren_stack.push(i);\n\
    \        }\n        // Handle closing paren\n        else if(paren_string[i] ==\
    \ ')')\n        {\n            // If the number of opened parens are equal to\
    \ the deepest level of nesting\n            if(paren_stack.size() == result)\n\
    \            {\n                // If we are at the deepest level, pop off the\
    \ top and add it as the result\n                if(paren_stack.top() > 0)\n  \
    \              {\n                    result = result + paren_stack.top();\n \
    \                   paren_stack.pop();\n                }\n            }\n   \
    \         else\n            {\n                // We aren't at the deepest level\
    \ of nesting, recursively add our current paren level\n                result\
    \ = result + paren_stack.size();\n                paren_stack.push(i);\n     \
    \       }\n        }\n        // Handle space\n        else if(paren_string[i]\
    \ == ' ')\n        {\n            // Skip spaces\n        }\n        else\n  \
    \      {\n            throw new RuntimeException(\"Malformed nested parens.\"\
    );\n        }\n    }\n    // Get the result of the stack\n    return paren_stack.toArray();\n\
    }\n</code>\n<|/ a tags=string,java,parentheses,algorithm,recursion |>\n<| c |>\n\
    Nice solution. I would just add that if you have a string like `(  ((  )) (  (\
    \  ))  )  )  ) ( )  )` it will return `[8, 11, 14, 12, 9, 10, 13, 10, 11, 12,\
    \ 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11,\
    \ 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10,\
    \ 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13,\
    \ 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12,\
    \ 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11,\
    \ 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10,\
    \ 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13,\
    \ 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12,\
    \ 13, 10, 11, 12, \nunittest\n{\n    alias candidate = parse_nested_parens;\n\n\
    \    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi0n69654.d(14): Error: found `>` when expecting `.` following int

    /tmp/tmpi0n69654.d(16): Error: found `long` when expecting `;` following statement

    /tmp/tmpi0n69654.d(63): Error: declaration expected, not `<`

    /tmp/tmpi0n69654.d(66): Error: unterminated string constant starting at /tmp/tmpi0n69654.d(66)

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi0n69654.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ temp_string;\n    long[] result;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpujpj880h.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpujpj880h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    map<string,\
    \ long> max_nesting_level;\n    stack<string> paren_stack;\n    long paren_count\
    \ = 0;\n    for (auto c : paren_string) \n    {\n        switch (c) \n       \
    \ {\n            case '(':\n                paren_stack.push(c);\n           \
    \     paren_count++;\n                break;\n            case ')':\n        \
    \        if (!paren_stack.empty()) \n                {\n                    auto\
    \ pop = paren_stack.top();\n                    auto count = paren_count;\n  \
    \                  paren_stack.pop();\n                    if (!max_nesting_level.count(pop))\
    \ \n                    {\n                        max_nesting_level[pop] = count;\n\
    \                    } \n                    else \n                    {\n  \
    \                      if (max_nesting_level[pop] < count) \n                \
    \        {\n                            max_nesting_level[pop] = count;\n    \
    \                    }\n                    }\n                    paren_count--;\n\
    \                } \n                else \n                {\n              \
    \      throw runtime_error(\"unexpected '('\");\n                }\n         \
    \       break;\n            case ' ':\n                if (!paren_stack.empty())\
    \ \n                {\n                    auto pop = paren_stack.top();\n   \
    \                 auto count = paren_count;\n                    paren_stack.pop();\n\
    \                    if (!max_nesting_level.count(pop)) \n                   \
    \ {\n                        max_nesting_level[pop] = count;\n               \
    \     } \n                    else \n                    {\n                 \
    \       if (max_nesting_level[pop] < count) \n                        {\n    \
    \                        max_nesting_level[pop] = count;\n                   \
    \     }\n                    }\n                    paren_count--;\n         \
    \       }\n                break;\n            default:\n                if (paren_stack.empty())\
    \ \n                {\n                    max_nesting_level[c] = paren_count;\n\
    \                }\n                break;\n        }\n    }\n    return max_nesting_level.size();\n\
    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp60mrdxsd.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmp60mrdxsd.d(15): Error: found `>` when expecting `;` following statement

    /tmp/tmp60mrdxsd.d(17): Error: no identifier for declarator `c`

    /tmp/tmp60mrdxsd.d(17): Error: expression expected, not `:`

    /tmp/tmp60mrdxsd.d(17): Error: found `paren_string` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp60mrdxsd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  if(paren_string.length()==0)\n\
    \    return new long[] {};\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpunocxbv0.d(15): Error: found `{` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpunocxbv0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ ret = 0;\n    foreach(char c in paren_string)\n    {\n        if(c == '(')\n\
    \            ++ret;\n        else if(c == ')')\n            --ret;\n    }\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9a1sgj09.d(15): Error: found `in` when expecting `;`

    /tmp/tmp9a1sgj09.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9a1sgj09.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    var\
    \ levels = paren_string.split(\" \");\n    long[] levels_deepest = new long[levels.length];\n\
    \    int current = 0;\n    long[] result = new long[levels.length];\n    \n  \
    \  while(current < levels.length)\n    {\n        string current_level = levels[current];\n\
    \        int levels_level_length = current_level.length();\n        int levels_current_level_index\
    \ = 0;\n        \n        while(levels_level_length > 0 && current < levels.length)\n\
    \        {\n            string next_level = levels[current];\n            levels_level_length\
    \ = next_level.length();\n            levels_current_level_index++;\n        \
    \    current++;\n        }\n        int levels_current_level_index_in_current_level\
    \ = levels_current_level_index - 1;\n        string next_level = levels[current];\n\
    \        \n        // We will add the next level's nesting level to the result\
    \ \n        // of the previous level\n        if(levels_current_level_index_in_current_level\
    \ != 0)\n        {\n            int levels_current_level_index_in_next_level =\
    \ levels_current_level_index_in_current_level;\n            string next_level_with_level\
    \ = next_level.substring(0, next_level.length() - levels_current_level_index_in_current_level);\n\
    \            levels_deepest[levels_current_level_index_in_next_level] = new std.math.toInt64(next_level_with_level);\n\
    \            \n            current++;\n        }\n        \n        if(levels_level_length\
    \ == 0)\n        {\n            levels_deepest[levels_current_level_index_in_current_level]\
    \ = new std.math.toInt64(current_level);\n            current++;\n        }\n\
    \    }\n    \n    for(int i = 0; i < levels_deepest.length; i++)\n    {\n    \
    \    result[i] = levels_deepest[i];\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpin1hi4hq.d(14): Error: undefined identifier `var`

    /tmp/tmpin1hi4hq.d(14): Error: no property `split` for type `string`

    /tmp/tmpin1hi4hq.d(22): Error: no property `length` for type `string`

    /tmp/tmpin1hi4hq.d(28): Error: no property `length` for type `string`

    /tmp/tmpin1hi4hq.d(40): Error: no property `substring` for type `string`

    /tmp/tmpin1hi4hq.d(41): Error: undefined identifier `toInt64` in module `std.math`

    /tmp/tmpin1hi4hq.d(48): Error: undefined identifier `toInt64` in module `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpin1hi4hq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<int>\
    \ nesting;\n    long current_nesting = 1;\n    bool is_empty = false;\n    string\
    \ temp_string;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n  \
    \  assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n \
    \   assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"\
    (()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps6eeu8gp.d(14): Error: found `>` when expecting `.` following int

    /tmp/tmps6eeu8gp.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps6eeu8gp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stringstream\
    \ ss;\n    ss << paren_string;\n    string paren_string2 = ss.str();\n    paren_string2.pop_back();\n\
    \    long[] nest_level;\n    long *p_nest;\n    char *p_tok_string;\n    stringstream\
    \ ss2;\n    ss2 << paren_string2;\n    string paren_string3 = ss2.str();\n   \
    \ paren_string3.pop_back();\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqrcnvkb5.d(25): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqrcnvkb5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ brackets = \"([{([\";\n    string punct = \"[]})]\";\n    string open = \"\\\
    \\((\";\n    string close = \"\\\\))\";\n    string closebracket = \"\\\\)\\\\\
    )\\\\)\";\n    string openbracket = \"\\\\((\";\n    string openbrace = \"\\\\\
    {(\";\n    string closebrace = \"\\\\})\";\n    string closebrace2 = \"\\\\})\"\
    ;\n    string closebrace3 = \"\\\\})\";\n    string closebrace4 = \"\\\\}}\";\n\
    \    string closebrace5 = \"\\\\}}\";\n    string openbrace2 = \"\\\\{(\";\n \
    \   string openbrace3 = \"\\\\{{\";\n    string openbrace4 = \"\\\\{\";\n    string\
    \ openbrace5 = \"\\\\{\";\n    string openbrace6 = \"\\\\{{\";\n    string openbrace7\
    \ = \"\\\\{\";\n    string openbrace8 = \"\\\\{{\";\n    string closebracket =\
    \ \"\\\\))\";\n    string openbracket2 = \"\\\\({\";\n    string openbracket3\
    \ = \"\\\\{{\";\n    string openbracket4 = \"\\\\{\";\n    string openbracket5\
    \ = \"\\\\{\";\n    string openbracket6 = \"\\\\{{\";\n    string openbracket7\
    \ = \"\\\\{\";\n    string openbracket8 = \"\\\\{{\";\n    string closebracket2\
    \ = \"\\\\))\";\n    string openbracket2 = \"\\\\({\";\n    string openbracket3\
    \ = \"\\\\{{\";\n    string openbracket4 = \"\\\\{\";\n    string openbracket5\
    \ = \"\\\\{\";\n    string openbracket6 = \"\\\\{{\";\n    string openbracket7\
    \ = \"\\\\{\";\n    string openbracket8 = \"\\\\{{\";\n    string closebracket3\
    \ = \"\\\\))\";\n    string openbracket2 = \"\\\\({\";\n    string openbracket3\
    \ = \"\\\\{{\";\n    string openbracket4 = \"\\\\{\";\n    string openbracket5\
    \ = \"\\\\{\";\n    string openbracket6 = \"\\\\{{\";\n    string openbracket7\
    \ = \"\\\\{\";\n    string openbracket8 = \"\\\\{{\";\n    string closebracket4\
    \ = \"\\\\))\";\n    string openbracket2 = \"\\\\({\";\n    string openbracket3\
    \ = \"\\\\{{\";\n    string openbracket4 = \"\\\\{\";\n    string openbracket5\
    \ = \"\\\\{\";\n    string openbracket6 = \"\\\\{{\";\n    string openbracket\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2sy_gafg.d(63): Error: found `openbracket` when expecting `;` following
    statement

    /tmp/tmp2sy_gafg.d(64): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2sy_gafg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  long max\
    \ = 0;\n  long n = 0;\n  long[] levels = new long[paren_string.length()];\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7jci8r04.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7jci8r04.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    if(paren_string.length()\
    \ == 0)\n        return 0;\n    stack<int> paren_stack;\n    int paren_count =\
    \ 0;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_stack.empty())\n\
    \        {\n            if(paren_string[i] == '(')\n                paren_stack.push(i);\n\
    \        }\n        else\n        {\n            if(paren_string[i] == ')')\n\
    \            {\n                long parent_level_of_interest = paren_count;\n\
    \                while(!paren_stack.empty())\n                {\n            \
    \        int parent_index = paren_stack.top();\n                    paren_stack.pop();\n\
    \                    if(paren_count + 1 < parent_level_of_interest)\n        \
    \                break;\n                    paren_count += 1;\n             \
    \   }\n                paren_count += 1;\n            }\n            else\n  \
    \          {\n                if(paren_string[i] == '(')\n                   \
    \ paren_stack.push(i);\n                else if(paren_string[i] == ')')\n    \
    \            {\n                    long parent_level_of_interest = paren_count;\n\
    \                    while(!paren_stack.empty())\n                    {\n    \
    \                    int parent_index = paren_stack.top();\n                 \
    \       paren_stack.pop();\n                        if(paren_count + 1 < parent_level_of_interest)\n\
    \                            break;\n                        paren_count += 1;\n\
    \                    }\n                    paren_count += 1;\n              \
    \  }\n            }\n        }\n    }\n    long[] results = {paren_count};\n \
    \   while(!paren_stack.empty())\n    {\n        int parent_index = paren_stack.top();\n\
    \        paren_stack.pop();\n        results[parent_index] += 1;\n    }\n    return\
    \ results;\n}\n</code>\n<|/ a dscore=0 tags=java,parsing,c++,algorithm |>\n<|\
    \ c |>\nThe OP said the solution had to be in Java, so this doesn't really help\
    \ the OP.\n<|/ c |>\n<| c |>\nI see what you mean. I tried to write the code in\
    \ a way that would still be understandable. However I agree, that it's better\
    \ to point out the mistake and let the OP fix it instead of posting an unreadable\
    \ answer...\n<|/ c |>\n<| c |>\nThanks for the code. Really appreciate it. But\
    \ I was specifically looking for algorithmic solutions. I do understand the code.\
    \ But it just requires understanding what you are doing and not an implementation\
    \ in Java or a pseudo code. Thanks for the effort though.\n<|/ c |>\n<| c |>\n\
    No problem! I edited the post to add the Java solution. I'll add some explanation\
    \ later when I get home.\n<|/ c \nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvs05tgib.d(16): Error: found `>` when expecting `.` following int

    /tmp/tmpvs05tgib.d(69): Error: declaration expected, not `<`

    /tmp/tmpvs05tgib.d(72): Error: unterminated character constant

    /tmp/tmpvs05tgib.d(75): Error: unterminated character constant

    /tmp/tmpvs05tgib.d(81): Error: unterminated character constant

    /tmp/tmpvs05tgib.d(87): Error: declaration expected, not `assert`

    /tmp/tmpvs05tgib.d(88): Error: declaration expected, not `assert`

    /tmp/tmpvs05tgib.d(89): Error: declaration expected, not `assert`

    /tmp/tmpvs05tgib.d(90): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvs05tgib.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ levels = new long[paren_string.length()];\n    int i = 0;\n    for(;i<paren_string.length();++i)\n\
    \    {\n        if(paren_string[i] == '(')\n            ++levels[i];\n       \
    \ if(paren_string[i] == ')')\n            --levels[i];\n    }\n    long[] result\
    \ = new long[paren_string.length()];\n    for(i=0;i<paren_string.length();++i)\n\
    \        result[i] = levels[i];\n    return result;\n}\n</code>\n<|/ a |>\n<|\
    \ c |>\nI really like the idea of using std.typecons instead of manual recursion.\
    \ I was just wondering whether there is already a std.typecons implementation\
    \ in some library that i could use.\n<|/ c |>\n<| c |>\n: There are two std.typecons\
    \ implementations, one in `boost` called `typecons_iterator` and another in `std`\
    \ called `typecons_range_iterator`. Both are part of the `std` namespace.\n<|/\
    \ c |>\n<| a dscore=1 tags=functional-programming,parsing,c++ |>\nA recursive\
    \ descent parser can produce this kind of data structure. The problem is that\
    \ it requires a stack frame to hold the nesting level. Which means you can't use\
    \ stack frames from other stack frames unless you manage to copy the data or use\
    \ global variables. A simple example would be\n<code>\n#include <stdio.h>\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj67t3f2m.d(28): Error: declaration expected, not `<`

    /tmp/tmpj67t3f2m.d(37): Error: unterminated character constant

    /tmp/tmpj67t3f2m.d(44): Error: declaration expected, not `assert`

    /tmp/tmpj67t3f2m.d(45): Error: declaration expected, not `assert`

    /tmp/tmpj67t3f2m.d(46): Error: declaration expected, not `assert`

    /tmp/tmpj67t3f2m.d(47): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj67t3f2m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ i = 0;\n    long[] result = new long[paren_string.size()];\n    int open_brackets\
    \ = 0;\n    \n    while (i<paren_string.size()) {\n        if (paren_string[i]\
    \ == '(') {\n            open_brackets++;\n        }\n        if (paren_string[i]\
    \ == ')') {\n            open_brackets--;\n        }\n        result[i] = open_brackets;\n\
    \        i++;\n    }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpujvz4lzo.d(28): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpujvz4lzo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    if(!paren_string.contains(\"\
    (\")) error(\"Need at least one opening parenthesis\");\n    if(paren_string.contains(\"\
    )\")) error(\"Need at least one closing parenthesis\");\n    stack<long[]> paren_levels\
    \ = new stack<long[]>(); //stack of groups to which open parentheses belong\n\
    \    long max_level = 1;\n    for(auto it = paren_string.rbegin(); it != paren_string.rend();\
    \ ++it) //for each pair of parenthesis separated by space\n    {\n        auto\
    \ left_open_paren = *it;\n        auto right_open_paren = paren_string.find('(',\
    \ it); //find first closing parenthesis\n        auto group_string = paren_string.subspan(left_open_paren,\
    \ right_open_paren); //create group string from left open parenthesis to left\
    \ closing parenthesis\n        if(!paren_levels.empty()) //if there is any group\
    \ stack\n        {\n            long[] new_level = paren_levels.pop(); //pop stack\
    \ group\n            if(new_level.length > max_level) //if we have encountered\
    \ a new maximum level\n            {\n                max_level = new_level.length;\n\
    \            }\n        }\n        if(!group_string.empty()) //if group string\
    \ is not empty\n        {\n            paren_levels.emplace(group_string.begin(),\
    \ group_string.end()); //push group string to stack\n        }\n    }\n    if(paren_levels.empty())\
    \ return new long[]{0};\n    return new long[]{max_level};\n}\nunittest\n{\n \
    \   alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdi4c6xqb.d(16): Error: found `[` when expecting `.` following long

    /tmp/tmpdi4c6xqb.d(16): Error: found `]` when expecting identifier following `long`.

    /tmp/tmpdi4c6xqb.d(16): Error: found `>` when expecting `;` following statement

    /tmp/tmpdi4c6xqb.d(16): Error: found `[` when expecting `.` following long

    /tmp/tmpdi4c6xqb.d(16): Error: found `]` when expecting identifier following `long`.

    /tmp/tmpdi4c6xqb.d(16): Error: found `>` when expecting `;` following statement

    /tmp/tmpdi4c6xqb.d(16): Error: expression expected, not `)`

    /tmp/tmpdi4c6xqb.d(16): Error: found `;` when expecting `)`

    /tmp/tmpdi4c6xqb.d(17): Error: found `long` when expecting `;` following statement

    /tmp/tmpdi4c6xqb.d(36): Error: found `{` when expecting `;` following `return`
    statement

    /tmp/tmpdi4c6xqb.d(36): Error: found `}` when expecting `;` following statement

    /tmp/tmpdi4c6xqb.d(36): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpdi4c6xqb.d(37): Error: found `{` when expecting `;` following `return`
    statement

    /tmp'
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    /*\n\
    \    Input is a string represented multiple groups for nested parentheses separated\
    \ by spaces.\n    For each of the group, output the deepest level of nesting of\
    \ parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((()))\
    \ has three.\n    */\n    long max_level = 0;\n    string paren_level = paren_string;\n\
    \    long level = 1;\n    string temp_string;\n    while(paren_level.size()>0)\n\
    \    {\n        bool found = false;\n        temp_string = \"\";\n        for(int\
    \ i=0;i<paren_level.size(); i++)\n        {\n            if(paren_level[i]=='(')\n\
    \                found = true;\n            else if(paren_level[i]==')')\n   \
    \         {\n                found = false;\n                break;\n        \
    \    }\n            temp_string += paren_level[i];\n        }\n        if(found\
    \ == true)\n            level++;\n        if(temp_string != \"\") \n         \
    \   paren_level += temp_string;\n        else\n            break;\n        if(level>max_level)\n\
    \        {\n            max_level = level;\n        }\n    }\n    if(max_level\
    \ == 0)\n        throw new runtime_error(\"Invalid input\");\n    long[] ans =\
    \ {max_level};\n    return ans;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb6q9vcpj.d(23): Error: no property `size` for type `string`

    /tmp/tmpb6q9vcpj.d(27): Error: no property `size` for type `string`

    /tmp/tmpb6q9vcpj.d(36): Error: slice `temp_string` is not mutable

    /tmp/tmpb6q9vcpj.d(41): Error: slice `paren_level` is not mutable

    /tmp/tmpb6q9vcpj.d(50): Error: undefined identifier `runtime_error`

    /tmp/tmpb6q9vcpj.d(51): Error: a struct is not a valid initializer for a `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb6q9vcpj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ ret = 0;\n    int num_paras = 0;\n    bool in_paras = false;\n    char paras_string[]\
    \ = \"()\";\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn7vbbucw.d(17): Deprecation: instead of C-style syntax, use D-style
    syntax `char[] paras_string`

    /tmp/tmpn7vbbucw.d(18): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn7vbbucw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ s = paren_string;\n    stack<int> parens_levels;\n    parens_levels.push(0);\
    \ \n    long max_level = 0;\n    for(int i = 1; i < s.length(); i++)\n    {\n\
    \        if (s[i] == '(')\n        {\n            parens_levels.push(parens_levels.size());\n\
    \            max_level = max(max_level, parens_levels.size());\n        }\n  \
    \      else if (s[i] == ')')\n        {\n            int level = parens_levels.pop();\n\
    \            if (level > max_level)\n                max_level = level;\n    \
    \    }\n    }\n    return max_level;\n}\n</code>\n<|/ a |>\n<| a tags=parentheses,algorithm,language-agnostic\
    \ |>\nYou can find this problem easier if you use parentheses as some kind of\
    \ stack (a tree data structure). The problem can be solved by searching the tree\
    \ until you hit an open parentheses pair. Here is a quick pseudo code:\n<code>\n\
    let paren_level = depth(root)\nlet open_count = 0\nwhile root != null\n    open_count\
    \ = open_count + 1\n    root = root.next\nfor i = 0 to open_count\n    paren_level\
    \ = paren_level - 1\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=parentheses,algorithm,language-agnostic\
    \ |>\nHere's a JavaScript solution using recursion:\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp74ljhu_2.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmp74ljhu_2.d(34): Error: declaration expected, not `<`

    /tmp/tmp74ljhu_2.d(49): Error: unterminated character constant

    /tmp/tmp74ljhu_2.d(54): Error: declaration expected, not `assert`

    /tmp/tmp74ljhu_2.d(55): Error: declaration expected, not `assert`

    /tmp/tmp74ljhu_2.d(56): Error: declaration expected, not `assert`

    /tmp/tmp74ljhu_2.d(57): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp74ljhu_2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ res = 0;\n    size_t level = 0;\n    size_t max_nest = 0;\n    for (auto c:\
    \ str::crlf_toascii(paren_string))\n    {\n        switch (c) {\n        case\
    \ '(':\n            if (level == 0) {\n                level++;\n            }\
    \ else {\n                level--;\n            }\n            break;\n      \
    \  case ')':\n            if (level == 0) {\n                level++;\n      \
    \      } else {\n                level--;\n            }\n            break;\n\
    \        case '\\n':\n            if (level == 0) {\n                level++;\n\
    \            } else {\n                level--;\n            }\n            break;\n\
    \        default:\n            if (level > max_nest) {\n                max_nest\
    \ = level;\n            }\n            break;\n        }\n        res += level;\n\
    \    }\n    res--;\n    return long[res];\n}\n/*\n Input: \n \n Output :\n \n\
    \ \n This function solves the problem of finding number of valid parenthesis expression\
    \ of a given string. \n \n Valid Parenthesis Expression : \n \n A valid parenthesis\
    \ expression must have atleast one pair of parentheses ( ), \n where each pair\
    \ of parentheses is closed by another pair of parentheses, \n i.e. either of the\
    \ two pairs are balanced. \n \n Example: Valid parenthesis expressions are :\n\
    \ \n \"()\" and \"(()) \" are valid \n \"((()))\" and \"(()(()))\" are valid \n\
    \ \"(())()\" and \"(()())\" are valid \n \"(())(()\" and \"((()))\" are valid\
    \ \n \"(()()()\" and \"(())()()\" are valid \n \"()(()())\" and \"()(())()\" are\
    \ valid \n \"(()(())()\" and \"((()(())))\" are valid \n \"(())(()(()))\" and\
    \ \"(())(()())\" are valid \n \"()(()(()()))\" and \"(())(())()\" are valid \n\
    \ \"(()(()())()\" and \"((()(())()))\" are valid \n \"()(()(())())\" and \"(())(())()\"\
    \ are valid \n \"(()(()(())))\" and \"(())(())()\" are valid \n \"()(()(()(())))\"\
    \ and \"(())(())()\" are valid \n \"()(()(()(())))\" and \"(())(())()\" are valid\
    \ \n \"()(()(()(()(())))\" and \"(())(())()\" are valid \n \"()(()(()(()(()(()))))\
    \ and ()()()\" are valid \n \"(()()(()(()(()(())))) and ()()()\" are valid \n\
    \ \"()()()(()(()(()(()(())))) and ()()()\" are valid \n \"()(()()(\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9js3gymr.d(17): Error: no identifier for declarator `c`

    /tmp/tmp9js3gymr.d(17): Error: expression expected, not `:`

    /tmp/tmp9js3gymr.d(17): Error: found `str` when expecting `;` following `for`
    condition

    /tmp/tmp9js3gymr.d(17): Error: expression expected, not `:`

    /tmp/tmp9js3gymr.d(17): Error: found `:` when expecting `)`

    /tmp/tmp9js3gymr.d(17): Error: found `)` when expecting `;` following statement

    /tmp/tmp9js3gymr.d(50): Error: found `[` when expecting `.` following long

    /tmp/tmp9js3gymr.d(50): Error: found `]` when expecting `;` following `return`
    statement

    /tmp/tmp9js3gymr.d(50): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp9js3gymr.d(52): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9js3gymr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_levels = { 0, 0, 0 };\n    stack<int> paren_levels;\n    \n    for(auto\
    \ c : paren_string) {\n        if (c == '(') paren_levels.push(int.parse(\"\"\
    ));\n        else if (c == ')') {\n            int current_level = paren_levels.pop();\n\
    \            if (max_levels[current_level] > max_levels[max_levels.length - 1])\
    \ {\n                max_levels[current_level] = max_levels[max_levels.length\
    \ - 1];\n            }\n            \n            max_levels[max_levels.length\
    \ - 1] = current_level;\n        }\n    }\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbqsvxajf.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmpbqsvxajf.d(17): Error: no identifier for declarator `c`

    /tmp/tmpbqsvxajf.d(17): Error: expression expected, not `:`

    /tmp/tmpbqsvxajf.d(17): Error: found `paren_string` when expecting `;` following
    `for` condition

    /tmp/tmpbqsvxajf.d(28): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbqsvxajf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int\
    \ levels[paren_string.Length];\n    int pos = 0;\n    for(int i = 1; i < paren_string.Length;\
    \ i++) levels[i] = 0;\n    levels[paren_string.Length - 1] = 1;\n    while(pos\
    \ < paren_string.Length)\n    {\n        if(paren_string[pos] == '(')\n      \
    \  {\n            levels[paren_string.Length - 1]++;\n        }\n        else\
    \ if(paren_string[pos] == ')')\n        {\n            levels[paren_string.Length\
    \ - 1]--;\n        }\n        pos++;\n    }\n    long[] levelsArray;\n    if(paren_string.Length\
    \ == 0)\n    {\n        levelsArray = new long[0];\n    }\n    else\n    {\n \
    \       levelsArray = new long[paren_string.Length];\n        for(int i = 0; i\
    \ < paren_string.Length; i++)\n        {\n            levelsArray[i] = levels[i];\n\
    \        }\n    }\n    return levelsArray;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2le3v8zt.d(14): Deprecation: instead of C-style syntax, use D-style
    syntax `int[paren_string.Length] levels`

    /tmp/tmp2le3v8zt.d(14): Error: no property `Length` for type `string`

    /tmp/tmp2le3v8zt.d(16): Error: no property `Length` for type `string`

    /tmp/tmp2le3v8zt.d(18): Error: no property `Length` for type `string`

    /tmp/tmp2le3v8zt.d(31): Error: no property `Length` for type `string`

    /tmp/tmp2le3v8zt.d(37): Error: no property `Length` for type `string`

    /tmp/tmp2le3v8zt.d(38): Error: no property `Length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2le3v8zt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Start\
    \ with empty array for storing max level of nested parenthesis\n    long[] max_level\
    \ = new long[paren_string.length()];\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvmgi3qjo.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvmgi3qjo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164261
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ s = paren_string;\n    string last_opening = \"\";\n    bool opening_found =\
    \ false;\n    string paren_level = \"\";\n    long[] levels;\n    bool nested_paren_found\
    \ = false;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp93x4q3mr.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp93x4q3mr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    List<long>\
    \ list = new List<long>();\n    string parens = \"\";\n    bool inside_paranthesis\
    \ = false;\n    bool last = false;\n    bool start = false;\n    long level =\
    \ 0;\n    int paren_counter = 1;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1dcus2_k.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmp1dcus2_k.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmp1dcus2_k.d(14): Error: found `(` when expecting identifier following `long`.

    /tmp/tmp1dcus2_k.d(14): Error: found `)` when expecting `;` following statement

    /tmp/tmp1dcus2_k.d(14): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp1dcus2_k.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1dcus2_k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ results = new long[paren_string.Length];\n\tfor (int i=0; i<paren_string.Length;\
    \ i++) {\n\t\tchar c = paren_string[i];\n\t\tif (c == '(') {\n\t\t\tif (i<paren_string.Length-1)\n\
    \t\t\t\tresults[i+1]++;\n\t\t\telse\n\t\t\t\tresults[0]++;\n\t\t} else if (c ==\
    \ ')') {\n\t\t\tif (i>0) {\n\t\t\t\tresults[i-1]++;\n\t\t\t\tresults[i]--;\n\t\
    \t\t} else {\n\t\t\t\tresults[0]--;\n\t\t\t}\n\t\t} else {\n\t\t\tresults[i]--;\n\
    \t\t}\n\t}\n\treturn results;\n}\n/*\n    Input to this function is a string represented\
    \ for nesting \n    parentheses separated by spaces. Output all the \n    string\
    \ representations possible by repeating and \n    appending parentheses. \n  \
    \  E.g. \"(()()())\" has six possible string representations.\n\t\n    Note this\
    \ function is very slow on large inputs. The maximum complexity is O(N^2)\n\t\n\
    \t\n\t>>> parse_nested_parens(\"(()())\")\n\t[u'(()())', u'()(())', u'(())()',\
    \ u'()(())', u'(())', u'()(()', u'()()()', u'(()', u'()()', u'()()']\n\t>>> parse_nested_parens(\"\
    (())\")\n\t[u'(())', u'(()())', u'()()()', u'(()', u'()()', u'()()', u'()']\n\t\
    >>> parse_nested_parens(\"()()()()\")\n\t[u'()()()()', u'()()()', u'()()()', u'()()()',\
    \ u'()()()', u'()()']\n\t>>> parse_nested_parens(\"()()()\")\n\t[u'()()()', u'()()()',\
    \ u'()()()', u'()()', u'()()', u'()']\n\t>>> parse_nested_parens(\"()()\")\n\t\
    [u'()()', u'()()()', u'()()', u'()()', u'()()', u'()']\n\t>>> parse_nested_parens(\"\
    ()\")\n\t[u'()', u'()()', u'()()', u'()()', u'()()', u'()']\n\t>>> parse_nested_parens(\"\
    ()\")\n\t[u'()', u'()', u'()', u'()', u'()', u'()', u'']\n\t>>> parse_nested_parens(\"\
    ()\")\n\t[u'()', u'()', u'()', u'()', u'()', u'()', u'']\n\t>>> parse_nested_parens(\"\
    ()\")\n\t[u'()', u'()', u'()', u'()', u'()', u'()', u'']\n\t>>> parse_nested_parens(\"\
    ()\")\n\t[u'()', u'()', u'()', u'()', u'()', u'()', u'']\n\t>>> \nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbr8z3akh.d(35): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbr8z3akh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max_level = 1;\n    long max_level2 = 0;\n    string paren_str = paren_string;\n\
    \    int depth = 0;\n    long temp;\n    int index = 0;\n    while(index < paren_str.Length)\n\
    \    {\n        char c = paren_str[index];\n        if(c == '(')\n        {\n\
    \            depth += 1;\n            if((temp = get_max_level(paren_string,index+1,depth,max_level))\
    \ == -1)\n                return null;\n            else\n                max_level\
    \ = temp;\n        }\n        else if(c == ')')\n        {\n            depth\
    \ -= 1;\n            if((temp = get_max_level(paren_string,index+1,depth,max_level))\
    \ == -1)\n                return null;\n            else\n                max_level\
    \ = temp;\n        }\n        index += 1;\n    }\n    long[] result = new long[max_level+1];\n\
    \    for(int i = 1; i <= max_level; i++)\n    {\n        result[i-1] = i;\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5u5scema.d(20): Error: no property `Length` for type `string`

    /tmp/tmp5u5scema.d(26): Error: undefined identifier `get_max_level`

    /tmp/tmp5u5scema.d(34): Error: undefined identifier `get_max_level`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5u5scema.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ s = paren_string;\n    s = s.substr(0, s.length()-1);\n    size_t len = s.length();\n\
    \    size_t i;\n    long[] counts = new long[len];\n    for(i=0; i < len; ++i)\n\
    \    {\n        // skip any parens\n        if(i == 0) \n        {\n         \
    \   continue;\n        }\n        if(s[i] == '(')\n        {\n            ++counts[len\
    \ - 1 - i];\n        }\n        else if(s[i] == ')')\n        {\n            counts[len\
    \ - 1 - i] = 0;\n        }\n    }\n    for(i=0; i < len; ++i)\n    {\n       \
    \ // skip any parens\n        if(i == 0) \n        {\n            continue;\n\
    \        }\n        if(s[i] == '(')\n        {\n            ++counts[len - 1 -\
    \ i];\n        }\n        else if(s[i] == ')')\n        {\n            counts[len\
    \ - 1 - i] = 0;\n        }\n    }\n    return counts;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThanks for posting your code! I wasn't sure how to deal with the\
    \ brackets within the parens, but I got it! I added another for loop to check\
    \ for parens and increase the count for that level of nesting! That was really\
    \ helpful! I appreciate your help.\n<|/ c |>\n<| c |>\nThanks, I missed your comments.\
    \ I posted my complete solution in the question itself. I hope it helps someone!\n\
    <|/ c |>\n<| c |>\nIt's better to use `if (s.substr(i) == '(')` instead of `if\
    \ (s[i] == '(')`\n<|/ c |>\n<| a |>\nHere is my solution that works in C# .Net\
    \ and C++. I am not sure about Python.\n<code>\n#include <iostream>\n#include\
    \ <stack>\nusing namespace std;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpypfcgmk7.d(53): Error: declaration expected, not `<`

    /tmp/tmpypfcgmk7.d(56): Error: unterminated character constant

    /tmp/tmpypfcgmk7.d(62): Error: unterminated character constant

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpypfcgmk7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    Stack<long> stack = new Stack<long>();\n\
    \    int cur = 0;\n    long depth = 0;\n    string curStr = paren_string;\n  \
    \  for (int i = 0; i < paren_string.length(); ++i)\n    {\n        char c = paren_string[i];\n\
    \        if (c == '(')\n        {\n            if (stack.empty())\n          \
    \  {\n                result[cur] = i;\n                stack.push(i);\n     \
    \       }\n            else\n            {\n                long top = stack.peek();\n\
    \                long bottom = top;\n                while (bottom < i)\n    \
    \            {\n                    stack.pop();\n                    bottom =\
    \ stack.peek();\n                }\n                stack.pop();\n           \
    \     result[cur] = i - bottom + 1;\n                stack.push(top);\n      \
    \      }\n        }\n        else if (c == ')')\n        {\n            long top\
    \ = stack.peek();\n            long bottom = top;\n            while (bottom <\
    \ i)\n            {\n                stack.pop();\n                bottom = stack.peek();\n\
    \            }\n            stack.pop();\n            result[cur] = i - bottom\
    \ + 1;\n            stack.push(top);\n        }\n        else\n        {\n   \
    \         stack.pop();\n        }\n    }\n    while (!stack.empty())\n    {\n\
    \        long top = stack.peek();\n        long bottom = top;\n        while (bottom\
    \ < i)\n        {\n            stack.pop();\n            bottom = stack.peek();\n\
    \        }\n        result[cur] = i - bottom + 1;\n        stack.push(top);\n\
    \    }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nI actually think my\
    \ code will break for nested parentheses in the same string that are not in groups\
    \ of three. I think your answer is better because it also handles those cases.\
    \ I would recommend accepting it as the answer though since it actually works\
    \ ;)\n<|/ c |>\n<| c |>\n- You are right, I missed that case. I updated my answer\
    \ to reflect the new specifications\n<|/ c |>\n<| c |>\nNice solution! +1. One\
    \ thing though: your `while` loop runs until `stack.empty()` is true, but since\
    \ you pop the stack each time you enter the loop, you can't go back up to `i`.\
    \ You might want to add a `break` inside the `if`-block.\n<|/ c |>\n<| a dscore=2\
    \ |>\nMy solution uses recursion.  I start by taking the first character off the\
    \ string.\nThen I call this function and pass it whatever I got left over, which\
    \ is a string of only the parentheses I encountered.  \nIf the string is empty\
    \ I add 1 to my answer as I consider that to be the number of groups I am \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj01hqto9.d(15): Error: found `>` when expecting `.` following long

    /tmp/tmpj01hqto9.d(15): Error: found `>` when expecting `.` following long

    /tmp/tmpj01hqto9.d(15): Error: found `(` when expecting identifier following `long`.

    /tmp/tmpj01hqto9.d(15): Error: found `)` when expecting `;` following statement

    /tmp/tmpj01hqto9.d(15): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpj01hqto9.d(75): Error: declaration expected, not `<`

    /tmp/tmpj01hqto9.d(78): Error: declaration expected, not `)`

    /tmp/tmpj01hqto9.d(84): Error: unterminated character constant

    /tmp/tmpj01hqto9.d(94): Error: declaration expected, not `assert`

    /tmp/tmpj01hqto9.d(95): Error: declaration expected, not `assert`

    /tmp/tmpj01hqto9.d(96): Error: declaration expected, not `assert`

    /tmp/tmpj01hqto9.d(97): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj01hqto9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    if (paren_string.length()\
    \ == 0)\n    {\n        return empty_nested_paren_list();\n    }\n    \n    /*\n\
    \    Stack used to hold groups of parentheses.\n    \n    We always insert an\
    \ extra level of parentheses just in case one is not found.\n    \n    In the\
    \ case of ((())) we have:\n    \n    Paren Stack\n    (\n    Paren Stack\n   \
    \ )\n    \n    In the case of ((())) we have:\n    \n    Paren Stack\n    (\n\
    \    Paren Stack\n    )\n    \n    In the case of (()()) we have:\n    \n    Paren\
    \ Stack\n    (\n    Paren Stack\n    )\n    \n    In the case of (()()) we have:\n\
    \    \n    Paren Stack\n    (\n    Paren Stack\n    )\n    \n    In the case of\
    \ ()(()) we have:\n    \n    Paren Stack\n    (\n    Paren Stack\n    )\n    \n\
    \    In the case of () () () we have:\n    \n    Paren Stack\n    (\n    Paren\
    \ Stack\n    )\n    \n    In the case of () () () () () () () we have:\n    \n\
    \    Paren Stack\n    (\n    Paren Stack\n    )\n    \n    */\n    stack<string>\
    \ paren_stack = new stack<string>();\n    \n    /*\n    Used to hold current level\
    \ of nesting.\n    \n    We always insert an extra level of nesting just in case\
    \ one is not found.\n    \n    In the case of (()()) we have:\n    \n    Nested\
    \ Level\n    3\n    \n    In the case of ((())) we have:\n    \n    Nested Level\n\
    \    2\n    \n    In the case of (()()) we have:\n    \n    Nested Level\n   \
    \ 1\n    \n    In the case of ()(()) we have:\n    \n    Nested Level\n    0\n\
    \    \n    In the case of ()(()) () () () () () () () () () () we have:\n    \n\
    \    Nested Level\n    0\n    \n    In the case of () () () () () () () () ()\
    \ () () () () () () () () () () () () () () () () () () () () () () () () () ()\
    \ () () () () () () () () () () () () () () () () () () () () () () () () () ()\
    \ () () () () () () () () () () () () () () () () () () () () () () () \nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6z1k1k2o.d(74): Error: found `>` when expecting `;` following statement

    /tmp/tmp6z1k1k2o.d(74): Error: found `>` when expecting `;` following statement

    /tmp/tmp6z1k1k2o.d(74): Error: expression expected, not `)`

    /tmp/tmp6z1k1k2o.d(74): Error: found `;` when expecting `)`

    /tmp/tmp6z1k1k2o.d(76): Error: unterminated /* */ comment

    /tmp/tmp6z1k1k2o.d(115): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmp6z1k1k2o.d(115): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6z1k1k2o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int[]\
    \ levels;\n    long[] output;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp083_sgx2.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp083_sgx2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\t\n\tstring\
    \ parens_str = paren_string;\n\tlong[] result = new long[parens_str.size()];\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy5a5uf7b.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy5a5uf7b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ max_level = new long[paren_string.Length];\n\tmax_level[0] = 0;\n\tfor (int\
    \ i = 1; i < paren_string.Length; ++i)\n\t{\n\t\tstring paren = paren_string[i];\n\
    \t\tint level = 1;\n\t\tfor (int j = 1; j < paren.Length; ++j)\n\t\t{\n\t\t\t\
    string open_paren = paren[j];\n\t\t\tstring close_paren = paren[j + 1];\n\t\t\t\
    long open_level = get_open_level_and_level(open_paren, close_paren);\n\t\t\tif\
    \ (open_level < max_level[i])\n\t\t\t\tmax_level[i] = open_level;\n\t\t}\n\t}\n\
    \treturn max_level;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpab_igoj6.d(14): Error: no property `Length` for type `string`

    /tmp/tmpab_igoj6.d(16): Error: no property `Length` for type `string`

    /tmp/tmpab_igoj6.d(18): Error: cannot implicitly convert expression `paren_string[cast(ulong)i]`
    of type `immutable(char)` to `string`

    /tmp/tmpab_igoj6.d(20): Error: no property `Length` for type `string`

    /tmp/tmpab_igoj6.d(22): Error: cannot implicitly convert expression `paren[cast(ulong)j]`
    of type `immutable(char)` to `string`

    /tmp/tmpab_igoj6.d(23): Error: cannot implicitly convert expression `paren[cast(ulong)(j
    + 1)]` of type `immutable(char)` to `string`

    /tmp/tmpab_igoj6.d(24): Error: undefined identifier `get_open_level_and_level`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpab_igoj6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_level = new long[paren_string.length()];\n    size_t cur_pos = 0;\n    size_t\
    \ max_pos = 0;\n    size_t cur_depth = 0;\n    \n    for(size_t i=0; i<paren_string.length();\
    \ i++)\n    {\n        if(paren_string[i] == '(')\n        {\n            cur_depth++;\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            cur_depth--;\n\
    \        }\n        else if(cur_depth > 0)\n        {\n            max_level[max_pos]\
    \ = cur_depth;\n            max_pos = i;\n        }\n    }\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb4l5vvfd.d(35): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb4l5vvfd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  int level;\n\
    \  int i, n, k, max_level;\n  string paren_string;\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjyzugk7k.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjyzugk7k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ result = 0;\n    long level = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsgp27xwg.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsgp27xwg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    auto\
    \ s = paren_string;\n    long[] levels;\n    string level;\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn1ry3_b1.d(17): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn1ry3_b1.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ max=0;\n    stack<int> stack_of_parens;\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphnmq52ga.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmphnmq52ga.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphnmq52ga.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tstring[]\
    \ tokens = lex(paren_string);\n\tlong[] nest = new long[tokens.length];\n\tfor\
    \ (int i = 0; i < tokens.length; i++)\n\t{\n\t\tnest[i] = 1;\n\t\tint level =\
    \ i;\n\t\twhile (level >= 0)\n\t\t{\n\t\t\tlevel--;\n\t\t\tif (tokens[level] ==\
    \ '(')\n\t\t\t\tnest[i]++;\n\t\t\tif (tokens[level] == ')')\n\t\t\t\tnest[i]--;\n\
    \t\t\tif (nest[i] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn nest;\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgidp701b.d(14): Error: undefined identifier `lex`

    /tmp/tmpgidp701b.d(23): Error: incompatible types for `(tokens[cast(ulong)level])
    == (''('')`: `string` and `char`

    /tmp/tmpgidp701b.d(25): Error: incompatible types for `(tokens[cast(ulong)level])
    == ('')'')`: `string` and `char`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgidp701b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n  int max_level\
    \ = 0;\n  int open_parens = 0;\n  int level = 0;\n  string[] parens = paren_string.split(\"\
    \ \");\n  for (int i = 0; i < parens.length; ++i) {\n    string paren = parens[i];\n\
    \    if (paren == \"(\" || paren == \")\") {\n      if (open_parens > 0) {\n \
    \       --open_parens;\n      }\n      else {\n        if (level > max_level)\
    \ {\n          max_level = level;\n        }\n        level++;\n      }\n    }\n\
    \    else if (paren != \"\") {\n      open_parens++;\n      level = 1;\n    }\n\
    \  }\n  assert(level == 0);\n  return new long[max_level + 1];\n}\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpztkle_gu.d(17): Error: no property `split` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpztkle_gu.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<int>\
    \ stack;\n    long level = 0;\n    long max_level = 0;\n    foreach(char c in\
    \ paren_string)\n    {\n        switch(c)\n        {\n            case '(':\n\
    \                stack.push(c);\n                break;\n            case ')':\n\
    \                while(stack.top() != '(')\n                {\n              \
    \      max_level = max(max_level, level);\n                    level++;\n    \
    \            }\n                stack.pop();\n                break;\n       \
    \     default:\n                level++;\n                break;\n        }\n\
    \    }\n    max_level = max(max_level, level);\n    return long[max_level];\n\
    }\n</code>\n<|/ a |>\n<| a |>\nI've been struggling with this one for a while\
    \ and I finally came up with a solution:\n<code>\nstatic char[] stringToCharArray(string\
    \ s) {\n    if (s == null) throw new ArgumentNullException(\"s\");\n    var results\
    \ = new char[s.Length];\n    for (int i = 0; i < s.Length; i++) {\n        char\
    \ c = s[i];\n        switch (c) {\n            case '(':\n                ++i;\n\
    \                break;\n            case ')':\n                --i;\n       \
    \         break;\n            case '[':\n                ++i;\n              \
    \  break;\n            case ']':\n                --i;\n                break;\n\
    \            case '{':\n                ++i;\n                break;\n       \
    \     case '}':\n                --i;\n                break;\n            case\
    \ '<':\n                ++i;\n                break;\n            case '>':\n\
    \                --i;\n                break;\n            case '\"':\n      \
    \          ++i;\n                break;\n            case '\\'':\n           \
    \     --i;\n                break;\n            case '+':\n                ++i;\n\
    \                break;\n            case '-':\n                --i;\n       \
    \         break;\n        }\n        results[i - 1] = c;\n    }\n    return results.ToArray();\n\
    }\n</code>\n<|/ a dscore=2 tags=regex,c# |>\n<| a dscore=2 tags=regex,c# |>\n\
    I've had to deal with this problem for about a year now (I inherited some C# code\
    \ that handles parentheses differently than I thought it would).  I've done my\
    \ best to document the solution as best as I can.\n<code>\n// Create a \"Stack\"\
    \ class with properties for \"top\" and \"pop\"\npublic class Stack<T>\n{\n  \
    \  // Private data members\n    private StackNode<T> node = new StackNode<T>(null);\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps5a38clg.d(14): Error: found `>` when expecting `.` following int

    /tmp/tmps5a38clg.d(17): Error: found `in` when expecting `;`

    /tmp/tmps5a38clg.d(38): Error: found `[` when expecting `.` following long

    /tmp/tmps5a38clg.d(38): Error: found `]` when expecting `;` following `return`
    statement

    /tmp/tmps5a38clg.d(38): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmps5a38clg.d(40): Error: declaration expected, not `<`

    /tmp/tmps5a38clg.d(43): Error: unterminated character constant

    /tmp/tmps5a38clg.d(48): Error: declaration expected, not `for`

    /tmp/tmps5a38clg.d(48): Error: no identifier for declarator `i`

    /tmp/tmps5a38clg.d(48): Error: declaration expected, not `<`

    /tmp/tmps5a38clg.d(48): Error: no identifier for declarator `i`

    /tmp/tmps5a38clg.d(48): Error: declaration expected, not `++`

    /tmp/tmps5a38clg.d(50): Error: declaration expected, not `switch`

    /tmp/tmps5a38clg.d(53): Error: declaration expected, not `break`

    /tmp/tmps5a38clg.d(54): Error: declaration expected, not `case`

    /tmp/tmps5a38clg.d(56): Error: declaration expected, not `break`

    /tmp/tmps5a38clg.d(57): Error: declaration expected, not `case`

    /tmp/tmps5a38clg.d(59): Error: declaration expected, not `break`

    /tmp/tmps5a38clg.d(60): Error: declaration expected, not `case`

    /tmp/tmps5a38clg.d(62): Error: declaration expected, not `break`

    /tmp/tmps5a38clg.d(63): Error: declaration expected, not `case`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps5a38clg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = {0};\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n \
    \   assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwc4rddna.d(15): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwc4rddna.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong result\
    \ = long.MaxValue;\n\tint num_levels = 0;\n\tStack<long> stack = new Stack<long>();\n\
    \tstack.Push(result);\n\tstring group_counter = \"0\";\n\tbool has_error = false;\n\
    \tforeach(char c in paren_string)\n\t{\n\t\tstring next_group = group_counter.Insert(group_counter.Length(),\
    \ \"0\");\n\t\tgroup_counter = next_group;\n\t\tlong group_index = 0;\n\t\tbool\
    \ group_opened = false;\n\t\tswitch(c)\n\t\t{\n\t\t\tcase '(':\n\t\t\t\tgroup_opened\
    \ = true;\n\t\t\t\tstack.Push(stack.Peek());\n\t\t\t\tstack.Push(group_index);\n\
    \t\t\t\tgroup_index++;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(!group_opened)\n\
    \t\t\t\t{\n\t\t\t\t\tstack.Pop(group_index);\n\t\t\t\t\tgroup_opened = true;\n\
    \t\t\t\t}\n\t\t\t\tlong level = stack.Pop();\n\t\t\t\twhile(!stack.Contains(level))\n\
    \t\t\t\t{\n\t\t\t\t\tstack.Pop(level);\n\t\t\t\t\tgroup_opened = false;\n\t\t\t\
    \t}\n\t\t\t\tif(level > num_levels)\n\t\t\t\t{\n\t\t\t\t\tnum_levels = level;\n\
    \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '1':\n\t\t\t\tif(stack.Contains(group_index))\n\
    \t\t\t\t{\n\t\t\t\t\tstack.Pop(group_index);\n\t\t\t\t\tgroup_opened = false;\n\
    \t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstack.Push(group_index);\n\t\t\t\
    \t\tgroup_index++;\n\t\t\t\t\tgroup_opened = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\
    \t\t\tcase '2':\n\t\t\t\tif(stack.Contains(group_index))\n\t\t\t\t{\n\t\t\t\t\t\
    stack.Pop(group_index);\n\t\t\t\t\tgroup_opened = false;\n\t\t\t\t}\n\t\t\t\t\
    else\n\t\t\t\t{\n\t\t\t\t\tstack.Push(group_index);\n\t\t\t\t\tgroup_index++;\n\
    \t\t\t\t\tgroup_opened = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '3':\n\t\
    \t\t\tif(stack.Contains(group_index))\n\t\t\t\t{\n\t\t\t\t\tstack.Pop(group_index);\n\
    \t\t\t\t\tgroup_opened = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\
    stack.Push(group_index);\n\t\t\t\t\tgroup_index++;\n\t\t\t\t\tgroup_opened = true;\n\
    \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\tif(stack.Contains(group_index))\n\
    \t\t\t\t{\n\t\t\t\t\tstack.Pop(group_index);\n\t\t\t\t\tgroup_opened = false;\n\
    \t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstack.Push(group_index);\n\t\t\t\
    \t\tgroup_index++;\n\t\t\t\t\tgroup_opened = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\
    \t\t\tcase '5':\n\t\t\t\tif(stack.Contains(group_index))\n\t\t\t\t{\n\t\t\t\t\t\
    stack.Pop(group_index);\n\t\t\t\t\tgroup_opened = false;\n\t\t\t\t}\n\t\t\t\t\
    else\n\t\t\t\t{\n\t\t\t\t\t\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5s41f1yh.d(16): Error: found `>` when expecting `.` following long

    /tmp/tmp5s41f1yh.d(16): Error: found `>` when expecting `.` following long

    /tmp/tmp5s41f1yh.d(16): Error: found `(` when expecting identifier following `long`.

    /tmp/tmp5s41f1yh.d(16): Error: found `)` when expecting `;` following statement

    /tmp/tmp5s41f1yh.d(16): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp5s41f1yh.d(20): Error: found `in` when expecting `;`

    /tmp/tmp5s41f1yh.d(112): Error: found `unittest` instead of statement

    /tmp/tmp5s41f1yh.d(120): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp5s41f1yh.d(120): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp5s41f1yh.d(120): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5s41f1yh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ result;\n\tint[] open = {-1, -1};\n\tint[] close = {-1, -1};\n\tint[] ind =\
    \ {-1, -1};\n\tstring space;\n\tsize_t len = 0;\n\tsize_t pos = 0;\n\tstring curr_char;\n\
    \tint curr_char_idx = 0;\n\tbool done = false;\n\tint char_idx = 0;\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3p38a4sz.d(25): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3p38a4sz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<int>\
    \ level_stack;\n    long[] levels = new long[paren_string.length()];\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5jon6p53.d(14): Error: found `>` when expecting `.` following int

    /tmp/tmp5jon6p53.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5jon6p53.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    // Start\
    \ with a list of paren groups of length 1 that have not yet been fully evaluated\n\
    \    var unevaluated_groups = new List<int>();\n    unevaluated_groups.append(0);\n\
    \    \n    // The deepest groups are the groups where all parent groups have been\
    \ fully evaluated\n    var deepest_groups = new List<int>();\n    \n    // The\
    \ deepest groups are the groups where all parent groups have been fully evaluated\n\
    \    // The deepest groups are the groups where all parent groups have been fully\
    \ evaluated\n    var deepest_groups = new List<int>();\n    \n    // The deepest\
    \ groups are the groups where all parent groups have been fully evaluated\n  \
    \  // The deepest groups are the groups where all parent groups have been fully\
    \ evaluated\n    // The deepest groups are the groups where all parent groups\
    \ have been fully evaluated\n    // The deepest groups are the groups where all\
    \ parent groups have been fully evaluated\n    var deepest_groups = new List<int>();\n\
    \    \n    int group_size = paren_string.Length - paren_string.Replace(\"(\",\
    \ \"\").Replace(\")\", \"\").Length;\n    string group_str = paren_string.Replace(\"\
    (\", \"\").Replace(\")\", \"\");\n    \n    // Start with a list of paren groups\
    \ of length 1 that have not yet been fully evaluated\n    var unevaluated_groups\
    \ = new List<int>();\n    unevaluated_groups.append(0);\n    \n    // The deepest\
    \ groups are the groups where all parent groups have been fully evaluated\n  \
    \  var deepest_groups = new List<int>();\n    \n    // The deepest groups are\
    \ the groups where all parent groups have been fully evaluated\n    // The deepest\
    \ groups are the groups where all parent groups have been fully evaluated\n  \
    \  var deepest_groups = new List<int>();\n    \n    // The deepest groups are\
    \ the groups where all parent groups have been fully evaluated\n    // The deepest\
    \ groups are the groups where all parent groups have been fully evaluated\n  \
    \  // The deepest groups are the groups where all parent groups have been fully\
    \ evaluated\n    var deepest_groups = new List<int>();\n    \n    int group_size\
    \ = paren_string.Length - paren_string.Replace(\"(\", \"\").Replace(\")\", \"\"\
    ).Length;\n    string group_str = paren_string.Replace(\"(\", \"\").Replace(\"\
    )\", \"\");\n    \n    // Start with a list of paren groups of length 1 that have\
    \ not yet been fully evaluated\n    var unevaluated_groups = new List<int>();\n\
    \    unevaluated_groups.append(0);\n\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdzije0g9.d(15): Error: found `>` when expecting `.` following int

    /tmp/tmpdzije0g9.d(15): Error: found `(` when expecting identifier following `int`.

    /tmp/tmpdzije0g9.d(15): Error: semicolon expected, not `)`

    /tmp/tmpdzije0g9.d(15): Error: found `)` instead of statement

    /tmp/tmpdzije0g9.d(19): Error: found `>` when expecting `.` following int

    /tmp/tmpdzije0g9.d(19): Error: found `(` when expecting identifier following `int`.

    /tmp/tmpdzije0g9.d(19): Error: semicolon expected, not `)`

    /tmp/tmpdzije0g9.d(19): Error: found `)` instead of statement

    /tmp/tmpdzije0g9.d(23): Error: found `>` when expecting `.` following int

    /tmp/tmpdzije0g9.d(23): Error: found `(` when expecting identifier following `int`.

    /tmp/tmpdzije0g9.d(23): Error: semicolon expected, not `)`

    /tmp/tmpdzije0g9.d(23): Error: found `)` instead of statement

    /tmp/tmpdzije0g9.d(29): Error: found `>` when expecting `.` following int

    /tmp/tmpdzije0g9.d(29): Error: found `(` when expecting identifier following `int`.

    /tmp/tmpdzije0g9.d(29): Error'
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong[]\
    \ levels = new long[paren_string.Length];\n\tbool paren_stack[paren_string.Length];\n\
    \tint stack_index = 0, paren_count = 0;\n\tstring paren_curr, next_curr;\n\tfor\
    \ (uint i = 0; i < paren_string.Length; ++i)\n\t{\n\t\tparen_curr = paren_string[i];\n\
    \t\tnext_curr = paren_string[i + 1];\n\t\tif (paren_curr == \"(\") paren_stack[stack_index++]\
    \ = true;\n\t\tif (paren_curr == \")\") paren_stack[stack_index++] = false;\n\t\
    \tif (paren_stack[stack_index - 1] == false && paren_curr == \" \")\n\t\t{\n\t\
    \t\tif (paren_count == 0)\n\t\t\t\tlevels[i] = paren_count;\n\t\t\t++paren_count;\n\
    \t\t}\n\t\telse\n\t\t\tparen_count = 0;\n\t}\n\tif (paren_count != 0) throw runtime_error(\"\
    Invalid nested parentheses\");\n\treturn levels;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5_l9kc4n.d(15): Deprecation: instead of C-style syntax, use D-style
    syntax `bool[paren_string.Length] paren_stack`

    /tmp/tmp5_l9kc4n.d(14): Error: no property `Length` for type `string`

    /tmp/tmp5_l9kc4n.d(15): Error: no property `Length` for type `string`

    /tmp/tmp5_l9kc4n.d(18): Error: no property `Length` for type `string`

    /tmp/tmp5_l9kc4n.d(20): Error: cannot implicitly convert expression `paren_string[cast(ulong)i]`
    of type `immutable(char)` to `string`

    /tmp/tmp5_l9kc4n.d(21): Error: cannot implicitly convert expression `paren_string[cast(ulong)(i
    + 1u)]` of type `immutable(char)` to `string`

    /tmp/tmp5_l9kc4n.d(33): Error: undefined identifier `runtime_error`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5_l9kc4n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ level = 1;\n    long levels[MAX_PARENTHESES] = {0};\n    long level_sizes[MAX_PARENTHESES]\
    \ = {0};\n    string curr_paren_string = \"\";\n    long curr_paren_level = 0;\n\
    \    int i = 0;\n    for(i=0; i<paren_string.length(); i++) {\n        char c\
    \ = paren_string[i];\n        switch (c) {\n            case '(':\n          \
    \      levels[curr_paren_level]++;\n                level_sizes[curr_paren_level]++;\n\
    \                curr_paren_level++;\n                break;\n            case\
    \ ')':\n                level_sizes[curr_paren_level]--;\n                curr_paren_level--;\n\
    \                if (curr_paren_level == -1) {\n                    curr_paren_string\
    \ = \"\";\n                    curr_paren_level = 0;\n                }\n    \
    \            break;\n            case ' ':\n                if (levels[curr_paren_level]\
    \ == 0) {\n                    curr_paren_string = \"\";\n                   \
    \ curr_paren_level = 0;\n                }\n                break;\n         \
    \   default:\n                curr_paren_string += c;\n        }\n    }\n    return\
    \ levels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpnrru6aw5.d(15): Deprecation: instead of C-style syntax, use D-style
    syntax `long[MAX_PARENTHESES] levels`

    /tmp/tmpnrru6aw5.d(16): Deprecation: instead of C-style syntax, use D-style syntax
    `long[MAX_PARENTHESES] level_sizes`

    /tmp/tmpnrru6aw5.d(15): Error: undefined identifier `MAX_PARENTHESES`

    /tmp/tmpnrru6aw5.d(15): Error: a struct is not a valid initializer for a `_error_`

    /tmp/tmpnrru6aw5.d(16): Error: undefined identifier `MAX_PARENTHESES`

    /tmp/tmpnrru6aw5.d(16): Error: a struct is not a valid initializer for a `_error_`

    /tmp/tmpnrru6aw5.d(20): Error: no property `length` for type `string`

    /tmp/tmpnrru6aw5.d(43): Error: slice `curr_paren_string` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnrru6aw5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long\
    \ level_of_nesting = 1;\n    bool is_open = true;\n    bool is_close = false;\n\
    \    long level = 0;\n    stack<long> paren_list = new stack<long>();\n    paren_list.push(0);\n\
    \    while(paren_string.size() > 0) {\n        string s = paren_string.substr(0,\
    \ paren_string.size() - 1);\n        if(is_open) {\n            if(s == \"(\"\
    )\n                paren_list.push(level_of_nesting);\n            else if(s ==\
    \ \")\")\n                is_close = true;\n            else if(s.empty() || s.front()\
    \ == '(' || s.front() == ')') {\n                is_open = false;\n          \
    \      paren_list.pop();\n                if(!is_close)\n                    level_of_nesting--;\n\
    \            }\n            else\n                level_of_nesting++;\n      \
    \  }\n        else if(is_close && !s.empty() && s.front() == '(')\n          \
    \  level_of_nesting--;\n        else if(is_close && s.front() == ')')\n      \
    \      level_of_nesting--;\n        else if(s.empty() || s.front() == '(' || s.front()\
    \ == ')') {\n            if(!is_close)\n                is_open = false;\n   \
    \     }\n        else {\n            level_of_nesting--;\n        }\n        \n\
    \        if(!is_close)\n            paren_list.push(level_of_nesting);\n     \
    \   \n        paren_string = paren_string.substr(paren_string.size() - 1);\n \
    \   }\n    \n    long[] res = new long[paren_list.size()];\n    int idx = 0;\n\
    \    while(!paren_list.empty()) {\n        res[idx++] = paren_list.pop();\n  \
    \  }\n    return res;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjva7ghne.d(18): Error: found `>` when expecting `.` following long

    /tmp/tmpjva7ghne.d(18): Error: found `>` when expecting `.` following long

    /tmp/tmpjva7ghne.d(18): Error: found `(` when expecting identifier following `long`.

    /tmp/tmpjva7ghne.d(18): Error: found `)` when expecting `;` following statement

    /tmp/tmpjva7ghne.d(18): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjva7ghne.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ parens_str = paren_string;\n    char c;\n    long paren_level = 0;\n    for(size_t\
    \ i = 0; i < parens_str.size(); ++i)\n    {\n        c = parens_str[i];\n    \
    \    if(c == ')')\n        {\n            paren_level--;\n        }\n        else\
    \ if(c == '(')\n        {\n            paren_level++;\n        }\n        else\
    \ if(c == ',')\n        {\n            paren_level = paren_level == 0 ? 1 : paren_level;\n\
    \        }\n    }\n    if(paren_level > 0)\n    {\n        return fail(paren_string);\n\
    \    }\n    \n    long[] nesting = new long[parens_str.size()];\n    string paren_group;\n\
    \    for(size_t i = 0; i < parens_str.size(); ++i)\n    {\n        c = parens_str[i];\n\
    \        if(c == ')')\n        {\n            paren_group = \"\";\n        }\n\
    \        else if(c == '(')\n        {\n            paren_group += \"(\" + paren_level\
    \ + \")\";\n        }\n        else\n        {\n            paren_group += c;\n\
    \        }\n        nesting[i] = paren_level;\n    }\n    return nesting;\n}\n\
    unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjmwltlq0.d(17): Error: no property `size` for type `string`

    /tmp/tmpjmwltlq0.d(35): Error: undefined identifier `fail`, did you mean function
    `ceil`?

    /tmp/tmpjmwltlq0.d(38): Error: no property `size` for type `string`

    /tmp/tmpjmwltlq0.d(40): Error: no property `size` for type `string`

    /tmp/tmpjmwltlq0.d(49): Error: incompatible types for `("(") + (paren_level)`:
    `string` and `long`

    /tmp/tmpjmwltlq0.d(53): Error: slice `paren_group` is not mutable

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjmwltlq0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    int[]\
    \ num_groups = new int[paren_string.Length];\n    int[] max_levels = new int[paren_string.Length];\n\
    \    int cur_level = 0;\n    int open_paren = 0;\n    long[] levels = new long[paren_string.Length];\n\
    \    int i, j;\n    int cur_max_level = -1;\n    for(i=0; i<paren_string.Length;\
    \ ++i)\n    {\n        if(paren_string[i]=='(')\n        {\n            open_paren+=1;\n\
    \            \n            if(num_groups[i]==0)\n            {\n             \
    \   num_groups[i] = 1;\n                cur_level = 1;\n            }\n      \
    \      else\n            {\n                num_groups[i]++;\n            }\n\
    \        }\n        else if(paren_string[i]==')')\n        {\n            open_paren-=1;\n\
    \            if(open_paren==0)\n            {\n                cur_level-=1;\n\
    \            }\n            if(cur_level<0)\n            {\n                throw\
    \ new ArgumentException(\"Unexpected closing bracket\");\n            }\n    \
    \        if(cur_level>cur_max_level)\n            {\n                cur_max_level\
    \ = cur_level;\n            }\n            if(num_groups[i]>0)\n            {\n\
    \                num_groups[i]--;\n            }\n            else\n         \
    \   {\n                throw new ArgumentException(\"Parentheses do not match\"\
    );\n            }\n        }\n        else\n        {\n            if(num_groups[i]==0)\n\
    \            {\n                throw new ArgumentException(\"Missing opening\
    \ bracket\");\n            }\n            if(open_paren>0)\n            {\n  \
    \              throw new ArgumentException(\"Unexpected opening bracket\");\n\
    \            }\n            if(num_groups[i]>0)\n            {\n             \
    \   throw new ArgumentException(\"Parentheses do not match\");\n            }\n\
    \            cur_level++;\n        }\n    }\n    if(open_paren!=0) throw new ArgumentException(\"\
    Unexpected closing bracket\");\n    if(cur_max_level!=paren_string.Length) throw\
    \ new ArgumentException(\"Incorrect number of nested brackets\");\n    for(i=0;\
    \ i<paren_string.Length; ++i)\n    {\n        if(num_groups[i]==0)\n        {\n\
    \            num_groups[i] = 1;\n        }\n        else\n        {\n        \
    \    num_groups[i]--;\n        }\n        levels[i] = num_groups[i]>0?num_groups[i]:-1;\n\
    \    }\n    return levels;\n}\n/*\n This function takes in a string and returns\
    \ a string with spaces inserted to make the string match the original string exactly.\n\
    \    It will throw an ArgumentException if there are extra spaces.\nunittest\n\
    {\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()())\
    \ ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (())\
    \ ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8_llfqbx.d(94): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8_llfqbx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ result = new long[paren_string.length()];\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if (c == '(' || c ==\
    \ ')')\n            result[i] = 0;\n        else if (c == '(')\n            result[i]\
    \ = 1;\n        else if (c == ')')\n            result[i] = 0;\n        else\n\
    \        {\n            if (result[i] > 0)\n            {\n                int\
    \ j = i - 1;\n                while (j >= 0)\n                {\n            \
    \        if (paren_string[j] == ')')\n                    {\n                \
    \        result[i] = 0;\n                        break;\n                    }\n\
    \                    if (paren_string[j] == '(')\n                        result[i]++;\n\
    \                    j--;\n                }\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzjvc5boi.d(14): Error: no property `length` for type `string`

    /tmp/tmpzjvc5boi.d(15): Error: no property `length` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzjvc5boi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tstring\
    \ paren_list_string = paren_string.strip();\n    long[] paren_list_sizes = paren_list_string.split('\
    \ ').map((string x)->{return x.length();});\n    long paren_list_sum = 0;\n  \
    \  for (long i : paren_list_sizes)\n        paren_list_sum += i;\n    \n    long[]\
    \ max_paren_list_sizes = paren_list_sizes.map((long x)->{return x;});\n    long\
    \ max_paren_list_sum = 0;\n    for (long i : max_paren_list_sizes)\n        max_paren_list_sum\
    \ += i;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmps0w66t1d.d(15): Error: found `x` when expecting `)`

    /tmp/tmps0w66t1d.d(15): Error: expression expected, not `>`

    /tmp/tmps0w66t1d.d(15): Error: semicolon expected, not `{`

    /tmp/tmps0w66t1d.d(15): Error: found `)` instead of statement

    /tmp/tmps0w66t1d.d(17): Error: semicolon expected, not `:`

    /tmp/tmps0w66t1d.d(17): Error: expression expected, not `:`

    /tmp/tmps0w66t1d.d(17): Error: found `paren_list_sizes` when expecting `;` following
    `for` condition

    /tmp/tmps0w66t1d.d(20): Error: found `x` when expecting `.` following long

    /tmp/tmps0w66t1d.d(20): Error: found `)` when expecting identifier following `long`.

    /tmp/tmps0w66t1d.d(20): Error: expression expected, not `>`

    /tmp/tmps0w66t1d.d(20): Error: found `{` when expecting `)`

    /tmp/tmps0w66t1d.d(20): Error: found `return` when expecting `,`

    /tmp/tmps0w66t1d.d(20): Error: found `;` when expecting `,`

    /tmp/tmps0w66t1d.d(20): Error: expression expected, not `}`

    /tmp/tmps0w66t1d.d(22): Error: semicolon expected, not `:`

    /tmp/tmps0w66t1d.d(22): Error: expressi'
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tint i\
    \ = 0;\n\tlong[] results = new long[paren_string.length()];\n\tstring paren_chars[]\
    \ = paren_string.ToCharArray();\n\tfor (int j = 0; j < paren_chars.Length; j++)\
    \ {\n\t\tstring paren_char = paren_chars[j];\n\t\tif (paren_char.ToUpper() ==\
    \ \"(\") {\n\t\t\tresults[i] = 1;\n\t\t} else if (paren_char.ToUpper() == \"(\"\
    ) {\n\t\t\tresults[i] = 0;\n\t\t} else {\n\t\t\tresults[i] = 0;\n\t\t}\n\t\ti++;\n\
    \t}\n\treturn results;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp372r4s2y.d(16): Deprecation: instead of C-style syntax, use D-style
    syntax `string[] paren_chars`

    /tmp/tmp372r4s2y.d(15): Error: no property `length` for type `string`

    /tmp/tmp372r4s2y.d(16): Error: no property `ToCharArray` for type `string`

    /tmp/tmp372r4s2y.d(17): Error: no property `Length` for type `string[]`

    /tmp/tmp372r4s2y.d(19): Error: no property `ToUpper` for type `string`

    /tmp/tmp372r4s2y.d(21): Error: no property `ToUpper` for type `string`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp372r4s2y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    char[]\
    \ parens = paren_string.toCharArray();\n    int paren_count = 1;\n    long max_nesting\
    \ = 1;\n    bool is_open = true;\n    bool is_close_paren = true;\n    long open_paren_level\
    \ = 1;\n    long[] nesting_levels = new long[paren_count];\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr1fjj5qf.d(21): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr1fjj5qf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tint n\
    \ = paren_string.length();\n\tint level = 0;\n\tint open_count = 0;\n\tint[] result\
    \ = new int[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c = paren_string[i];\n\
    \t\tif (open_count > 0) {\n\t\t\tif (c == ')' && open_count == level) {\n\t\t\t\
    \topen_count--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\topen_count = 1;\n\t\t\t}\n\t\t\
    }\n\t\telse {\n\t\t\tif (c == '(') {\n\t\t\t\topen_count++;\n\t\t\t\tlevel++;\n\
    \t\t\t}\n\t\t\telse if (c == ')') {\n\t\t\t\topen_count--;\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\topen_count = 1;\n\t\t\t\tlevel = 1;\n\t\t\t}\n\t\t}\n\t\tresult[i\
    \ - 1] = level;\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp907uus8u.d(14): Error: no property `length` for type `string`

    /tmp/tmp907uus8u.d(43): Error: cannot implicitly convert expression `result` of
    type `int[]` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp907uus8u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    map<int,\
    \ long> level_nesting;\n    int level = 1;\n    int index = 0;\n    int open_brackets\
    \ = 0;\n    for(int i = 0; i <= paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n            open_brackets++;\n        else if(paren_string[i] == ')')\n\
    \        {\n            if(open_brackets == level) // found the deepest level\
    \ of nesting\n            {\n                if(!level_nesting.count(level))\n\
    \                    level_nesting[level] = index;\n                level++;\n\
    \                open_brackets = 0;\n            }\n            else\n       \
    \         open_brackets--;\n        }\n        else\n            open_brackets\
    \ = 0;\n    }\n    long[] deepest_level_nesting = new long[level_nesting.size()];\n\
    \    for(int i = 0; i < deepest_level_nesting.size(); i++)\n        deepest_level_nesting[i]\
    \ = level_nesting[i];\n    return deepest_level_nesting;\n}\n</code>\n<|/ a tags=java,string,algorithm,arrays\
    \ |>\n<| a dscore=0 |>\n<code>\npublic static int count_parentheses(String str)\
    \ {\n    if (str == null || str.isEmpty()) {\n        return 0;\n    }\n    int\
    \ count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char ch =\
    \ str.charAt(i);\n        if (ch == '(') {\n            count++;\n        } else\
    \ if (ch == ')') {\n            count--;\n        }\n        if (count == 0)\n\
    \            break;\n    }\n    return count;\n}\n</code>\n<|/ a tags=java,string,algorithm,arrays\
    \ |>\n<| c |>\nA simple loop is enough.\n<|/ c |>\n<| c |>\nThis code doesn't\
    \ work.\n<|/ c |>\n<| a |>\n<code>\n public int countParenthesis(String str){\n\
    \    char[] strArray = str.toCharArray();\n    int parenCount = 0;\n    int stack\
    \ = 0;\n    for(int i = 0; i < strArray.length; i++){\n        if(strArray[i]\
    \ == '('){\n            stack++;\n        }\n        else if(strArray[i] == ')'){\n\
    \            stack--;\n        }\n        else if(stack > 0){\n            parenCount++;\n\
    \        }\n    }\n    return parenCount;\n}\n</code>\n<|/ a dscore=0 tags=java,string,algorithm,arrays\
    \ |>\n<| c |>\nThis code doesn't work.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic\
    \ static int countParenthesis(String str) {\n    int count = 0;\n    int i = 0;\n\
    \    while (i<str.length()) {\n        if (str.charAt(i) == '('\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzbrdecp7.d(14): Error: found `,` when expecting `.` following int

    /tmp/tmpzbrdecp7.d(14): Error: found `long` when expecting identifier following
    `int`.

    /tmp/tmpzbrdecp7.d(14): Error: found `>` when expecting `;` following statement

    /tmp/tmpzbrdecp7.d(42): Error: declaration expected, not `<`

    /tmp/tmpzbrdecp7.d(49): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzbrdecp7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    string\
    \ curr_pos = paren_string;\n    string curr_group = paren_string;\n    long curr_level\
    \ = 1;\n    long total_level = 0;\n    int open_parentheses = 0;\n    long curr_level_count\
    \ = 0;\nunittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
    (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"\
    () (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
    ) == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzm5y1qom.d(20): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzm5y1qom.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong result\
    \ = 0;\n\tfor (int i = 0; i < paren_string.length; i += 1)\n\t{\n\t\tif (paren_string[i]\
    \ == '(')\n\t\t\tresult++;\n\t\telse if (paren_string[i] == ')')\n\t\t\tresult--;\n\
    \t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqkbq96dj.d(22): Error: cannot implicitly convert expression `result`
    of type `long` to `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqkbq96dj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    long[]\
    \ max_levels = new long[paren_string.length()];\n    for (int i = 0; i < paren_string.length();\
    \ i++) \n    {\n        // Get current character\n        char ch = paren_string[i];\n\
    \        \n        // Open an new level\n        if (ch == '(')\n            max_levels[i]\
    \ = 1;\n        else\n        {\n            // Get existing level\n         \
    \   long level = max_levels[i];\n            \n            // Close an existed\
    \ level\n            if (ch == ')')\n                max_levels[i] = --level;\n\
    \            else\n            {\n                // Add new level\n         \
    \       long new_level = max_levels[i] + 1;\n                max_levels[i] = new_level;\n\
    \            }\n        }\n    }\n    return max_levels;\n}\n</code>\n<|/ a dscore=0\
    \ tags=algorithm,depth-first-search,language-agnostic |>\n<| c |>\nThe idea is\
    \ to not modify the input string since it may contain other groups of the same\
    \ size.\n<|/ c |>\n<| c |>\nI guess it also depends on the interpretation of the\
    \ input: e.g. `((())())` is not a valid input. On the other hand `((())(()))`\
    \ does have only one level of nesting. I am not able to fully understand what\
    \ you mean by \"maximum depth\" is greater than the actual nesting level (since\
    \ `((())(()))` has three levels).\n<|/ c |>\n<| c |>\nI guess I should rephrase\
    \ the question: what is the maximum level of nesting in the given input?\n<|/\
    \ c |>\n<| c |>\nThe input can be nested parentheses of different size. For example:\
    \ `((())(()))`. I am not sure how do you mean `((())(()))` has three levels of\
    \ nesting?\n<|/ c |>\n<| c |>\nThe input can be nested parentheses of different\
    \ size. For example: `((())(()))`. I am not sure how do you mean `((())(()))`\
    \ has three levels of nesting? Do you mean each input `((())(()))` has three levels\
    \ of nesting? If so, I would say that it is three levels of nesting. I guess I'm\
    \ confused of what you mean.\n<|/ c |>\n<| a tags=algorithm,depth-first-search,language-agnostic\
    \ dscore=0 |>\nWe can use a stack. As we pop a parentheses, we push its level.\
    \ As we pop a parentheses, we push its level. As we pop a parentheses, we push\
    \ its level. As we pop a parentheses, we push its level. As we pop a parentheses,\
    \ we push its level. As we pop a parentheses, we push its \nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoa0r_iut.d(41): Error: declaration expected, not `<`

    /tmp/tmpoa0r_iut.d(56): Error: unterminated character constant

    /tmp/tmpoa0r_iut.d(64): Error: declaration expected, not `assert`

    /tmp/tmpoa0r_iut.d(65): Error: declaration expected, not `assert`

    /tmp/tmpoa0r_iut.d(66): Error: declaration expected, not `assert`

    /tmp/tmpoa0r_iut.d(67): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoa0r_iut.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<int>\
    \ stack;\n    long[] results;\n    stack<int> parens_stack;\n    parens_stack.push(0)\n\
    \    int count_parens = 0;\n    string buffer = \"\";\n    int pos = 0;\n    while(!paren_string.empty())\
    \ \n    {\n        char c = paren_string.at(pos);\n        pos++;\n        if(c\
    \ == '(') {\n            stack.push(count_parens);\n            parens_stack.push(count_parens);\n\
    \        }\n        if(c == ')') \n        {\n            count_parens = stack.pop();\n\
    \            long parens = parens_stack.pop();\n            if(parens > 0 && parens\
    \ == count_parens) {\n                results[count_parens-1]++;\n           \
    \     buffer = \"\";\n            }\n            else if((parens == 0) || (parens\
    \ == count_parens) || (parens == count_parens - 1)) \n            {\n        \
    \        if(buffer != \"\") {\n                    results[count_parens-1] +=\
    \ buffer.size();\n                }\n                buffer = \"\";\n        \
    \    }\n        }\n        if(c == ' ') {\n            buffer += paren_string.at(pos);\n\
    \        }\n    }\n    if(buffer != \"\") {\n        results[count_parens-1] +=\
    \ buffer.size();\n    }\n    return results;\n}\nunittest\n{\n    alias candidate\
    \ = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\") ==\
    \ [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpheuimuwz.d(14): Error: found `>` when expecting `.` following int

    /tmp/tmpheuimuwz.d(16): Error: found `>` when expecting `.` following int

    /tmp/tmpheuimuwz.d(18): Error: found `int` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpheuimuwz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    if (paren_string\
    \ == null || paren_string.length() == 0)\n        return null;\nunittest\n{\n\
    \    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((()))\
    \ (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\")\
    \ == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpikxg26f4.d(16): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpikxg26f4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    map<string,\
    \ long> paren_string_to_max_level;\n    \n    // First pass: count how many groups\
    \ in the paren_string\n    string paren_string_with_groups = \"(\" + paren_string\
    \ + \")\";\n    size_t paren_string_count = 1;\n    map<string, size_t> paren_string_to_paren_string_group;\n\
    \    while(paren_string_with_groups.length())\n    {\n        auto it = paren_string_to_paren_string_group.find(paren_string_with_groups);\n\
    \        if(it == paren_string_to_paren_string_group.end())\n        {\n     \
    \       paren_string_to_paren_string_group[paren_string_with_groups] = paren_string_count;\n\
    \            paren_string_to_max_level[paren_string_with_groups] = 0;\n      \
    \      paren_string_count++;\n        }\n        else\n        {\n           \
    \ paren_string_to_max_level[paren_string_with_groups] = max(paren_string_to_max_level[paren_string_with_groups],\
    \ it->second);\n        }\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1_11fe_p.d(14): Error: found `>` when expecting `.` following long

    /tmp/tmp1_11fe_p.d(31): Error: use `.` for member lookup, not `->`

    /tmp/tmp1_11fe_p.d(33): Error: found `unittest` instead of statement

    /tmp/tmp1_11fe_p.d(41): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1_11fe_p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n    stack<int>\
    \ paren_levels;\n    long[] max_level_of_nesting = new long[paren_string.length()];\n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            paren_levels.push(i);\n        }\n        else\
    \ if(paren_string[i] == ')')\n        {\n            long levels_of_nesting =\
    \ paren_levels.pop();\n            if((max_level_of_nesting[levels_of_nesting]\
    \ <= max_level_of_nesting[levels_of_nesting - 1]))\n                max_level_of_nesting[levels_of_nesting]\
    \ = max_level_of_nesting[levels_of_nesting - 1];\n        }\n    }\n    return\
    \ max_level_of_nesting;\n}\n</code>\n<|/ a dscore=4 |>\n<| a |>\nI wrote a JavaScript\
    \ implementation of the longest nested parentheses algorithm, in response to the\
    \ question \"Given a string of characters, how many parentheses are there?\".\
    \ The answer is 7. It works by first counting how many nested parentheses are\
    \ at each position, from right to left. Then it compares the two counts, and stops\
    \ when they are equal, or when the difference is exactly 1.\nThe JavaScript code\
    \ below shows the recursive function, and the test case:\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbbtscsxp.d(14): Error: found `>` when expecting `.` following int

    /tmp/tmpbbtscsxp.d(31): Error: declaration expected, not `<`

    /tmp/tmpbbtscsxp.d(40): Error: declaration expected, not `assert`

    /tmp/tmpbbtscsxp.d(41): Error: declaration expected, not `assert`

    /tmp/tmpbbtscsxp.d(42): Error: declaration expected, not `assert`

    /tmp/tmpbbtscsxp.d(43): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbbtscsxp.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong maxlevel\
    \ = 0;\n\tlong[] maxlevels = new long[paren_string.length()];\n\tfor(int i = 0;\
    \ i < paren_string.length(); ++i)\n\t{\n\t\tif(paren_string[i] == '(')\n\t\t{\n\
    \t\t\t++maxlevel;\n\t\t}\n\t\telse if(paren_string[i] == ')')\n\t\t{\n\t\t\tif(maxlevel\
    \ > 0)\n\t\t\t{\n\t\t\t\t--maxlevel;\n\t\t\t}\n\t\t}\n\t\telse if(paren_string[i]\
    \ == ',')\n\t\t{\n\t\t\tif(maxlevel > 0)\n\t\t\t{\n\t\t\t\tmaxlevel = std.min(maxlevel,\
    \ maxlevels[i - 1] + 1);\n\t\t\t\tmaxlevels[i - 1]++;\n\t\t\t}\n\t\t}\n\t}\n\t\
    return maxlevels;\n}\nunittest\n{\n    alias candidate = parse_nested_parens;\n\
    \n    assert(candidate(\"(()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n\
    \    assert(candidate(\"() (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n   \
    \ assert(candidate(\"(()(())((())))\") == [4L]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp95mi251d.d(15): Error: no property `length` for type `string`

    /tmp/tmp95mi251d.d(16): Error: no property `length` for type `string`

    /tmp/tmp95mi251d.d(33): Error: undefined identifier `min` in package `std`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp95mi251d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
- exit_code: 1
  program: "import std.typecons;\nimport std.math;\n/*\n Input to this function is\
    \ a string represented multiple groups for nested parentheses separated by spaces.\n\
    \    For each of the group, output the deepest level of nesting of parentheses.\n\
    \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n\
    \    >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L,\
    \ 3L]\n    \n*/\nlong[] parse_nested_parens(string paren_string) \n{\n\tlong curlevel\
    \ = 0;\n\tlong maxlevel = 0;\n\tList<long> results = new List<long>();\n\tchar?\
    \ opening_brace = '(';\n\tfor (char ch in paren_string)\n\t{\n\t\tresults.Add(curlevel);\n\
    \t\tlong count = results.Last() - results.First() + 1;\n\t\tif (ch == opening_brace)\
    \ \n\t\t{\n\t\t\tcurlevel++;\n\t\t}\n\t\telse if (ch == closing_brace)\n\t\t{\n\
    \t\t\tcurlevel--;\n\t\t}\n\t\tif (maxlevel < curlevel) \n\t\t{\n\t\t\tmaxlevel\
    \ = curlevel;\n\t\t}\n\t}\n\treturn results.ToArray();\n}\nunittest\n{\n    alias\
    \ candidate = parse_nested_parens;\n\n    assert(candidate(\"(()()) ((())) ()\
    \ ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"() (()) ((())) (((())))\"\
    ) == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\") == [4L]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpeys3gzdc.d(16): Error: found `>` when expecting `.` following long

    /tmp/tmpeys3gzdc.d(16): Error: found `>` when expecting `.` following long

    /tmp/tmpeys3gzdc.d(16): Error: found `(` when expecting identifier following `long`.

    /tmp/tmpeys3gzdc.d(16): Error: found `)` when expecting `;` following statement

    /tmp/tmpeys3gzdc.d(16): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpeys3gzdc.d(17): Error: no identifier for declarator `char`

    /tmp/tmpeys3gzdc.d(17): Error: found `?` instead of statement

    /tmp/tmpeys3gzdc.d(18): Error: semicolon expected, not `in`

    /tmp/tmpeys3gzdc.d(18): Error: expression expected, not `in`

    /tmp/tmpeys3gzdc.d(18): Error: found `paren_string` when expecting `;` following
    `for` condition

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpeys3gzdc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164262
