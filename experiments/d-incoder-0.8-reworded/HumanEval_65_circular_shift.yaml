name: HumanEval_65_circular_shift
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nCircular shift the digits of\
  \ the integer x, shift the digits right by shift\n    and return the result as a\
  \ string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12L,\
  \ 1L)\n    \"21\"\n    >>> circular_shift(12L, 2L)\n    \"12\"\n    \n*/\nstring\
  \ circular_shift(long x, long shift) \n"
tests: "unittest\n{\n    alias candidate = circular_shift;\n\n    assert(candidate(100L,\
  \ 2L) == \"001\");\n    assert(candidate(12L, 2L) == \"12\");\n    assert(candidate(97L,\
  \ 8L) == \"79\");\n    assert(candidate(12L, 1L) == \"21\");\n    assert(candidate(11L,\
  \ 101L) == \"11\");\n}\nvoid main(){}"
completions: ["{\n    string result = \"\";\n    \n    while (x > 0)\n    {\n    \
    \    result = (char) (x % 10 + result + 12 - shift % 12);\n        x /= 10;\n\
    \        shift /= 10;\n    }\n    \n    while (shift > 0)\n    {\n        result\
    \ = (char) (result + 10 - shift % 10);\n        shift /= 10;\n    }\n    \n  \
    \  return result;\n}", "{\n    string s = \"\";\n    unsigned long i = x;\n  \
    \  \n    while (i > 0)\n    {\n        s += char(i % 10);\n        i /= 10;\n\
    \    }\n    \n    unsigned long n = i;\n    unsigned long s = shift;\n    \n \
    \   while (n > 0)\n    {\n        s += n % 10;\n        n /= 10;\n    }\n    \n\
    \    while (s > 0)\n    {\n        s += n % 10;\n        n /= 10;\n        --s;\n\
    \    }\n    \n    return s;\n}", "{\n    string s;\n    string str = to_string(x\
    \ >> shift);\n    string first = str.substr(0, shift);\n    string last = str.substr(str.length()\
    \ - shift);\n    s = first + last;\n    str = s.reverse();\n    s += str;\n  \
    \  return s;\n}\n//\nstring circular_shift(int x, int shift) \n{\n    string s;\n\
    \    string str = to_string(x);\n    string first = str.substr(0, shift);\n  \
    \  string last = str.substr(str.length() - shift);\n    s = first + last;\n  \
    \  str = s.reverse();\n    s += str;\n    return s;\n}", "{\n    int len = x.length;\n\
    \    string result = \"\";\n    while(len > 0) {\n        long digit = len % 10;\n\
    \        string a = to_string(x%10);\n        string b = to_string((digit-shift%10)%10);\n\
    \        string c = to_string((digit-shift/10)%10);\n        string d = to_string((digit-shift/100)%10);\n\
    \        string e = to_string((digit-shift/1000)%10);\n        string f = to_string((digit-shift/10000)%10);\n\
    \        string g = to_string((digit-shift/100000)%10);\n        string h = to_string((digit-shift/1000000)%10);\n\
    \        string i = to_string((digit-shift/10000000)%10);\n        string j =\
    \ to_string((digit-shift/100000000)%10);\n        string k = to_string((digit-shift/1000000000)%10);\n\
    \        string l = to_string((digit-shift/10000000000)%10);\n        string m\
    \ = to_string((digit-shift/100000000000)%10);\n        string n = to_string((digit-shift/1000000000000)%10);\n\
    \        string o = to_string((digit-shift/10000000000000)%10);\n        string\
    \ p = to_string((digit-shift/100000000000000L)%10);\n        string q = to_string((digit-shift/1000000000000000L)%10);\n\
    \        string r = to_string((digit-shift/10000000000000000L)%10);\n        string\
    \ s = to_string((digit-shift/100000000000000000L)%10);\n        string t = to_string((digit-shift/1000000000000000000L)%10);\n\
    \        string u = to_string((digit-shift/10000000000000000000L)%10);\n     \
    \   string v = to_string((digit-shift/100000000000000000000L)%10);\n        string\
    \ w = to_string((digit-shift/1000000000000000000000L)%10);\n        string x =\
    \ to_string((digit-shift/10000000000000000000000L)%10);\n        string y = to_string((digit-shift/100000000000000000000000L)%10);\n\
    \        string z = to_string((digit-shift/1000000000000000000000000L)%10);\n\
    \        string A = to_string((digit-shift/10000000000000000000000000L)%10);\n\
    \        string B = to_string((digit-shift/100000000000000000000000000L)%10);\n\
    \        string C = to_string((digit-shift/1000000000000000000000000000L)%10);\n\
    \        string D = to_string((digit-shift/10000000000000000000000000000L)%10);\n\
    \        string E = to_string((digit-shift/100000000000000000000000000000L)%10);\n\
    \        string F = to_string((digit-shift/1000000000000000000000000000000L)%10);\n\
    \        string G = ", "{\n    string digits = tostring(x);\n    string result\
    \ = \"\";\n    \n    for(int i = 0; i < (int) digits.length(); ++i) {\n      \
    \  if(i == shift)\n            result += (char)tostring(int(digits[i]) - int(digits[i-1]));\n\
    \        else\n            result += digits[i];\n    }\n    return result;\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nI think this is very inefficient. `string`\
    \ concatenation is very expensive. You can use a `char[]` instead, and do a single\
    \ `strcpy`.\n<|/ c |>\n<| c |>\n- Yes, but it is only a small part of the total\
    \ cost of converting a `long` to `string`. But `char[]` might just be too small\
    \ to save on memory, and `string` doesn't have that problem.\n<|/ c |>\n<| c |>\n\
    I tested with large numbers (`1000000` -> `123456789` and it worked (about 2%\
    \ of the time), so I think `char[]` is good enough for most cases. But a good\
    \ library would have this implemented as a class or function in the standard library,\
    \ and I think this could have saved us some time...\n<|/ c |>\n<| c |>\n- Yes,\
    \ it could. But `char[]` isn't part of the standard library. `string` is. And\
    \ `string` is likely to be more efficient in this case. `char[]` might be more\
    \ efficient in some edge cases, but the standard library doesn't have a function\
    \ for this. And if you need to do this in more than one place in your code, it\
    \ could be more expensive than `string`, but it's unlikely to save a significant\
    \ amount of time here.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "{\n    long i, res\
    \ = 0;\n    string ret = \"\";\n    \n    if (shift > 64) { //should never happen\n\
    \        shift = 64;\n    }\n    \n    for (i = shift; i >= 0; i--) {\n      \
    \  res += x % 10;\n        x = x / 10;\n    }\n    \n    while (x != 0) {\n  \
    \      res += x % 10;\n        x = x / 10;\n    }\n    \n    return res + ret;\n\
    }", "{\n    stringstream s;\n    string result = \"\";", "{\n    const int digits\
    \ = (int)std::log10(x) + 1;\n    string result;\n    int i = 0;\n    do {\n  \
    \      string digit = string(i, '0');\n        char c = digits[i--];\n       \
    \ result.append(c);\n        if (i == 0) {\n            digits.append(digit);\n\
    \        }\n        if (i >= digits) {\n            digits.append(digit);\n  \
    \      }\n    } while (shift > digits);\n    do {\n        digits.append(digits[i--]);\n\
    \    } while (shift > i);\n    result.append(digits);\n    return result;\n}",
  "{\n    if (shift > digitcount(x))\n        shift = digitcount(x);\n    long t =\
    \ 0;\n    while (shift > 0)\n    {\n        t = t << 1;\n        shift -= 1;\n\
    \    }\n    while (t != 0)\n    {\n        t >>>= 1;\n    }\n    return to_string(t,\
    \ 1);\n}", "{\n    int numdigits;\n    char res[MAXDIGITS];\n    \n    // Determine\
    \ how many digits x has.\n    numdigits = count_digits(x);\n    \n    // Shift\
    \ the digits by shift.\n    shift(numdigits, shift, res);\n    \n    // Reverse\
    \ the digits before returning them.\n    reverse(res, 0, numdigits);\n    \n \
    \   return string(res);\n}\n\"\"\"", "{\n    long remainder, carry = 0;\n    string\
    \ result = \"\";\n    \n    while (x) {\n        remainder = x % 10;\n       \
    \ x += shift;\n        if (shift == 1) {\n            carry = remainder;\n   \
    \     } else {\n            carry = 0;\n        }\n        result += std.string(x%10);\n\
    \        x = remainder;\n    }\n    if (carry) result += \"1\";\n    return result;\n\
    }\n*/", "{\n    int len = bitcount(x);\n    int i;\n    string s = \"\";\n   \
    \ \n    while (shift > 0) {\n        if (shift >= len) {\n            s += \"\
    1\";\n            shift -= len;\n        } else {\n            s += bitset(x);\n\
    \            shift -= len;\n        }\n    }\n    \n    for (i = len - 1; i >\
    \ shift; --i) {\n        s += \"0\";\n    }\n    \n    return s;\n}", "{\n   \
    \ auto sx = to_string(int(x % 10));\n    auto sz = to_string(int(x / 10) % shift);\n\
    \    auto result = sz + sx;\n    return result;\n}", "{\n    string res = \"\"\
    ;\n    string sres = \"\";\n    long temp = x;\n    long mod;\n    long d = 0;\n\
    \    long temp2 = mod;\n    for(long i = shift; i >= 0; --i){\n        temp /=\
    \ 10;\n        temp2 %= 10;\n        d *= 10;\n        d += temp2;\n    }\n  \
    \  for(; d < temp; ++d){\n        res += '0';\n    }\n    while(temp > 0){\n \
    \       res += '0';\n        temp /= 10;\n    }\n    return res;\n}", "{\n   \
    \ string result;\n    if (shift >= x.digits)\n    {\n        result += \"0\";\n\
    \    }\n    else\n    {\n        long tmp = x;\n        long rem = 1;\n      \
    \  bool negate = false;\n        if (tmp < 0)\n        {\n            tmp = negate\
    \ = !tmp;\n            rem = -rem;\n        }\n        for (long i = 0; i < shift;\
    \ i++)\n        {\n            rem <<= 1;\n            if (tmp < rem)\n      \
    \      {\n                tmp -= rem;\n                result[i-shift] = tmp %\
    \ 10;\n                rem = tmp / 10;\n            }\n            else\n    \
    \        {\n                tmp >>= 1;\n                tmp -= rem;\n        \
    \        result[i-shift] = tmp % 10;\n                rem = tmp / 10;\n      \
    \      }\n        }\n        if (negate)\n        {\n            result[result.length-1]\
    \ = '-';\n        }\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a |>\n\
    Since this is a fairly old question I thought I'd add some more recent info. \
    \ I used an approach similar to the accepted answer from Steve Rabinowitz, but\
    \ in addition to handling negative numbers I added a check to make sure that the\
    \ final value has at least 10 digits.  So the code looked like this:\n<code>\n\
    string circular_shift(long x, int shift)\n{\n    int length = x.ToString().Length;\n\
    \    if (length < 10) {\n        throw new ArgumentException(\"Input must be at\
    \ least 10 digits\");\n    }\n    string result = x.ToString();\n    while (shift\
    \ < length)\n    {\n        result = circular_shift(x, shift);\n        shift++;\n\
    \    }\n    string resultStr = result.Substring(0, Math.Min(length, 10));\n  \
    \  if (result.Length > 10) resultStr = \"0000000000\" + resultStr.Substring(10);\n\
    \    return resultStr;\n}\n</code>\nThis can then be used to perform an XOR operation\
    \ on an unsigned integer by performing the following steps:", "{\n    string result\
    \ = \"\";\n    if (shift > DIGITS.length()) shift = DIGITS.length() - shift;\n\
    \    for (unsigned short i = 0; i < DIGITS.length(); ++i) \n    {\n        if\
    \ (i < shift) \n        {\n            result += DIGITS[i]; \n        }\n    \
    \    else\n        {\n            result += DIGITS[DIGITS.length() - i - 1]; \n\
    \        }\n    }\n    return result;\n}", "{\n\tlong remainder = 0;\n\tstring\
    \ result = \"\";\n\twhile (shift > 0) {\n\t\tremainder = x % 10;\n\t\tx = x/10;\n\
    \t\tresult+=to_string(remainder);\n\t\tshift--;\n\t}\n\twhile (shift < 0) {\n\t\
    \tremainder = x % 10;\n\t\tx = x/10;\n\t\tresult+=to_string(remainder);\n\t\t\
    shift++;\n\t}\n\treturn result;\n}\n/*\nConvert the decimal string to a floating\
    \ point number using floating point\n    point rules.\n    \n>>> decimalToFloat(\"\
    0.1234\")\n1234\n>>> decimalToFloat(\"0.12341\", 5)\n0.12341\n>>> decimalToFloat(\"\
    0.12341\", 0)\n0.\n*/\ndouble decimalToFloat(string decimal)\n{\n\tstring digits\
    \ = decimalToBinary(decimal);\n\treturn from_string(digits);\n}\n/*\nConvert the\
    \ binary string to a decimal string using floating point\n    point rules.\n \
    \   \n>>> binaryToDecimal(\"0.1234\")\n1234\n>>> binaryToDecimal(\"0.12341\")\n\
    0.12341\n*/\nstring binaryToDecimal(string binary)\n{\n\tlong result = 0, sign\
    \ = 0, bits = 0;\n\tbool bits_positive;\n\tstringstream ss;\n\tfor (auto c : binary)\
    \ {\n\t\tswitch (c) {\n\t\tcase '1':\n\t\t\tresult+=sign*pow(2, bits);\n\t\t\t\
    sign = -1;\n\t\t\tbits_positive = false;\n\t\t\tbreak;\n\t\tcase '0':\n\t\t\t\
    result+=sign*pow(2, bits);\n\t\t\tsign = 0;\n\t\t\tbits_positive = true;\n\t\t\
    \tbreak;\n\t\tcase '-':\n\t\t\tsign = -1;\n\t\t\tbits_positive = false;\n\t\t\t\
    break;\n\t\tcase '+':\n\t\t\tsign = 1;\n\t\t\tbits_positive = false;\n\t\t\tbreak;\n\
    \t\tdefault:\n\t\t\tss << \"Illegal character '\" << c << \"' at position \" <<\
    \ binary.size();\n\t\t\tthrow runtime_error(ss.str());\n\t\t}\n\t\tbits++;\n\t\
    }\n\tif (bits_positive) result++;\n\treturn to_string((double)result);\n}\n/*\n\
    Convert the binary string to a decimal string using floating point\n    point\
    \ rules.\n    \n>>> binaryToDecimal(\"1001\")\n3\n*/\nstring binaryToDecimal(string\
    \ binary, int decimal_points)\n{\n\tlong result = 0, sign = 0, bits = 0;\n\tbool\
    \ bits_positive;\n\tstringstream ss;\n\tfor (auto c : binary) {\n\t\tswitch (c)\
    \ {\n\t\tcase '1':\n\t\t\tresult+=sign*pow(2, bits);\n\t\t\tsign = -1;\n\t\t\t\
    bits_positive = false;", "{\n  string result;\n  long digits, i, carry;\n  digits\
    \ = __int2long(x);\n  carry = 0;\n  for (i = shift - 1; i < digits; i--)\n  {\n\
    \    carry = digits[digits-i-1] >> shift_digits;\n    carry |= carry << shift_digits;\n\
    \    digits = digits-i-1;\n    digits[i] &= ~(carry >> shift_digits);\n  }\n \
    \ result = __long2int(digits);\n  return result;\n}", "{\n    if (shift >= digits(x))\n\
    \        return to_string(digits(x));\n    string result = \"\";\n    string strx\
    \ = to_string(x);\n    for (int i=0; i<strx.length(); i++) {\n        result.append(strx[i]);\n\
    \        if (shift > strx.length()-1) { shift = strx.length()-1; }\n        if\
    \ (shift < strx.length()-1) { shift = strx.length()-1; }\n        strx = to_string(shift(strx));\n\
    \    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a tags=circular-shift,algorithm,java\
    \ |>\n<code>\nprivate static String circularShift(int i) {\n        StringBuilder\
    \ sb = new StringBuilder();\n        if (i > 0) {\n            while (i >= 10)\
    \ {\n                sb.append(i % 10).append(i % 10);\n                i /= 10;\n\
    \            }\n            if (i >= 1) {\n                sb.append(i % 10);\n\
    \            }\n        }\n        return sb.toString();\n    }\n</code>\n<|/\
    \ a dscore=2 |>\n<| a tags=circular-shift,algorithm,java |>\nI wrote the following\
    \ code in Python\n<code>\ndef circular_shift(i, shift):\n    '''\n    Function\
    \ to return the integer i circular shifted by shift digits times by one\n    shift:\
    \ number of digits to be shifted \n    '''\n    string = str(i)\n    string =\
    \ string[shift:] + string[:shift]\n    return int(string)\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nThis is my solution.\nThe algorithm is based on modulo\
    \ arithmetic, so this implementation does not require any library function.\n\
    <code>\npublic class CircularShift {\n  public static String circularShift(String\
    \ numbers, int shift) {\n    int len = numbers.length();\n    if (len == 0 ||\
    \ shift < 1 || shift > len) {\n      System.out.println(\"Invalid shift \" + shift);\n\
    \      return null;\n    }\n    int len = numbers.length();\n    StringBuilder\
    \ sb = new StringBuilder(numbers);\n    while (shift > 0) {\n      int pos = len\
    \ % shift != 0 ? shift : (len - shift) % shift;\n      sb.insert(pos, numbers.length());\n\
    \      shift -= pos;\n    }\n    return sb.toString();\n  }\n}\n</code>\n<|/ a\
    \ tags=circular-shift,algorithm,java |>\n<| c |>\n`numbers.length()` is an O(n)\
    \ operation. You'd better use a String constructor instead.\n<|/ c |>\n<| c |>\n\
    I used it for the string length, as I didn't have any better ideas. Do you know\
    \ of a faster way? Would appreciate a reference. Thanks.\n<|/ c |>\n<| c |>\n\
    The most efficient solution I can ", "{\n    int i;\n    string result=\"\";\n\
    \    for(shift=shift;shift>0;shift--)\n    {\n        result+=char(int(x / pow(10,\
    \ shift)));\n        x = x % pow(10, shift);\n    }\n    if (x>0) \n        result+=char(int(x\
    \ % pow(10, shift)));\n    return result;\n}", "{\n\tif(x == 0)\n\t\treturn \"\
    0\";\n\tstring ans = to_string(shift(x, 0, shift));\n\tfor(int i = 0; i < ans.length();\
    \ i++)\n\t\tif((ans[i] - '0') > '9')\n\t\t\tans = ans.insert(i, ans[i] - '0' +\
    \ shift);\n\treturn ans;\n}", "{\n    string result = \"\";\n    int i;\n    for(i\
    \ = 0; i < shift; i++)\n    {\n        result += std.string(\"0123456789abcdef\"\
    [x % ((int)pow((int)10, i) % 10)]);\n    }\n    if (shift < 0)\n    {\n      \
    \  for(i = 0; i < -shift; i++)\n        {\n            result += std.string(\"\
    0123456789abcdef\"[x % ((int)pow((int)10, -i) % 10)]);\n        }\n    }\n   \
    \ return result;\n}\n</code>\n<|/ a tags=c++ |>\n<| a tags=c++ |>\nHere is my\
    \ version of solution (without using string::append):\n<code>\n#include <cmath>",
  "{\n    string result = \"\";\n    \n    if(shift > length(x))\n    {\n        result\
    \ = reverse(x);\n        shift -= length(x);\n    }\n    \n    for(size_t i =\
    \ 0; i < shift; ++i)\n    {\n        result += x[i];\n    }\n    \n    return\
    \ result;\n}", "{\n    string s;\n    long t;\n    for(long i = shift - 1; i >\
    \ 0; i--)\n    {\n        t = x % 10;\n        x /= 10;\n        s += t;\n   \
    \ }\n    s = reverse(s, s.length);\n    \n    return s;\n}\n/*\nReturn the number\
    \ of times the digit appears in a given string. For example,\n    \"11111\" has\
    \ twice as many '1' digits as '22222'.\n    >>> count_digits(\"11111\")\n    2\n\
    \    >>> count_digits(\"222222\")\n    5\n    \n*/\nlong count_digits(string s)\
    \ \n{\n    long count = 0;\n    for(unsigned i = 0; i < s.length(); i++)\n   \
    \ {\n        count += count_digit(s[i]);\n    }\n    \n    return count;\n}\n\
    /*\nReturn the number of times a single digit appears in a given string.\n   \
    \ >>> count_digit(\"1\")\n    1\n    >>> count_digit(\"10\")\n    2\n    >>> count_digit(\"\
    9\")\n    1\n    >>> count_digit(\"12\")\n    3\n    \n*/\nlong count_digit(char\
    \ digit) \n{\n    switch(digit)\n    {\n    case '0':\n    case '1':\n    case\
    \ '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n\
    \    case '8':\n    case '9':\n        return 1;\n    case 'a':\n    case 'b':\n\
    \    case 'c':\n    case 'd':\n    case 'e':\n    case 'f':\n    case 'g':\n \
    \   case 'h':\n    case 'i':\n    case 'j':\n    case 'k':\n    case 'l':\n  \
    \  case 'm':\n    case 'n':\n    case 'o':\n    case 'p':\n    case 'q':\n   \
    \ case 'r':\n    case 's':\n    case 't':\n    case 'u':\n    case 'v':\n    case\
    \ 'w':\n    case 'x':\n    case 'y':\n    case 'z':\n        return 2;\n    default:\n\
    \        return 0;\n    }\n}\n/*\nCount the number of digits in the string of\
    \ digits of x, up to the specified limit.\n    >>> count_digits(\"11111\", 3)\n\
    \    2\n    >>> count_digits(\"11111\", 10)\n    0\n    \n*/\nlong count_digits(string\
    \ s, long limit)\n{\n    long digits = 0;\n    for(unsigned i = 0; i < s.length();\
    \ i++)\n    {\n        digits += count_digit(s[i]);\n        if(digits >= limit)\n\
    \            return limit;\n    }\n    return digits;\n}\n/*\nReturn the number\
    \ of times the digit appears in the string s.\n    >>> count_digit(\"1\")\n  \
    \  1\n    >>> count_digit(\"10\")\n    2\n    >>> count_digit(\"9\")\n    1\n\
    \    >>> count_digit(\"12\")", "{\n    const int digits = (int)((double)(x) +\
    \ 0.5);\n    string result = \"\";\n    int i;\n    if (shift >= digits)\n   \
    \ {\n        for (i = digits; i >= shift; i--)\n        {\n            result\
    \ += (char)((x >> (i - shift)) & 0xFF);\n        }\n        result += (char)((x\
    \ >> shift) & 0xFF);\n    }\n    else\n    {\n        for (i = digits; i < shift;\
    \ i++)\n        {\n            result += (char)((x >> (i - shift)) & 0xFF);\n\
    \        }\n        result += (char)((x >> shift) & 0xFF);\n    }\n    return\
    \ result;\n}", "{\n    string result;\n    bool is_neg = (x < 0);\n    long abs_x\
    \ = abs(x);\n    long mod_shift = shift%mod_long_bits;\n    \n    if (shift <\
    \ mod_long_bits) {\n        result = \"\";\n    } else if (shift > mod_long_bits)\
    \ {\n        mod_shift += mod_long_bits;\n        is_neg = true;\n    }\n    \n\
    \    long abs_xy = abs_x*abs_x;\n    long shift_mul = mod_shift*mod_shift;\n \
    \   \n    for (int i = abs_xy; i > 0; i /= abs_xy) {\n        long digit = x %\
    \ abs_x;\n        \n        //check if digit > 0, i.e. it must be in range and\
    \ \n        //shifting digits is necessary\n        if (digit > 0) {\n       \
    \     long shift_digit = digit/shift_mul;\n            digit = digit%shift_mul;\n\
    \            \n            string carry = 0;\n            for (int j = 0; j <\
    \ shift_digit; j++) {\n                carry = carry + (digit>>shift_digit*j);\n\
    \                digit = digit%shift_mul;\n            }\n            \n     \
    \       //append new digit to the result\n            if (carry > 0) {\n     \
    \           result = to_string(carry) + result;\n            }\n        }\n  \
    \      \n        //append the digit to result\n        if (digit > 0) {\n    \
    \        result = to_string(digit) + result;\n        }\n        \n        x =\
    \ x/abs_x;\n    }\n    \n    if (!is_neg) result = to_string(-1) + result;\n \
    \   return result;\n}\n/*\nAdd two strings and return the result.\n    \n    Addition\
    \ algorithm is straight forward.\n    If strings are of different length, pad\
    \ string with zeros at the end.\n    \n    >>> add(\"abc\", \"def\")\n    \"abcdef\"\
    \n    >>> add(\"ab\", \"c\")\n    \"abc\"\n    \n*/\nstring add(string a, string\
    \ b) \n{\n    if (a.length < b.length) a = addzeros(a, b.length);\n    if (b.length\
    \ < a.length) b = addzeros(b, a.length);\n    \n    string result;\n    \n   \
    \ for (int i = 0; i < a.length; i++)\n        result = a[i] + b[i] + result;\n\
    \    \n    return result;\n}\n/*\nAdd two strings and return the result.\n   \
    \ \n    Addition algorithm is straight forward.\n    If strings are of different\
    \ length, pad string with zeros at the end.\n    \n    >>> add(\"abc\", \"def\"\
    )\n    \"abcdef\"\n    >>> add(\"ab\", \"c\")\n    \"abc\"\n    \n*/\nstring sub(string\
    \ a, string b) \n{\n    string result;\n    \n    if (a.length < b.length) a =\
    \ subzeros(a, b.length);\n    if (b.length < a.length) b = subzeros(b, ", "{\n\
    \tlong n, d;\n\tstring result = \"\";\n\t\n\tn = x % 10;\n\tx = x / 10;\n\td =\
    \ shift % 10;\n\tshift = shift / 10;\n\twhile (shift > 0)\n\t{\n\t\tresult +=\
    \ (n % 10) + d;\n\t\tn /= 10;\n\t\td /= 10;\n\t\tshift -= 1;\n\t}\n\t\n\treturn\
    \ reverse(result, 0, result.length());\n}\n/*\nReturn the number of times the\
    \ digit in digit appears in the number x.\n    digit can be any digit. \n    For\
    \ example, digits in 123 would be 0, 1, or 2.\n    >>> count_digits(123, 1)\n\
    \    1\n    >>> count_digits(123, 2)\n    2\n*/\nlong count_digits(long x, long\
    \ digit) \n{\n\tlong count = 0;\n\tlong n = x / 10;\n\twhile (n > 0)\n\t{\n\t\t\
    count++;\n\t\tn /= 10;\n\t}\n\t\n\tif (count == 0)\n\t{\n\t\tcount = 1;\n\t}\n\
    \t\n\treturn count - ((x % 10) == digit);\n}\n/*\nCompute the sum of the digits\
    \ of the number x.\n    >>> compute_digits(123)\n    6\n*/\nlong compute_digits(long\
    \ x) \n{\n\tlong sum = 0;\n\tlong n = x / 10;\n\twhile (n > 0)\n\t{\n\t\tsum +=\
    \ n % 10;\n\t\tn /= 10;\n\t}\n\t\n\treturn sum;\n}\n/*\nGiven an integer x, round\
    \ it to an integer multiple of y.\n    For example, with x and y both equal to\
    \ 10, the number 123456 will be\n    rounded to 123000.\n    \n    \n    >>> round_to_multiple(123456L,\
    \ 10L)\n    12300L\n*/\nlong round_to_multiple(long x, long y) \n{\n\tlong mult\
    \ = compute_digits(y) * y;\n\tlong result = x / mult + y / mult % y;\n\treturn\
    \ result;\n}\n/*\nCompute the factorial of a given integer.\n    \n    >>> factorial(5)\n\
    \    120\n*/\nlong factorial(long x) \n{\n\tlong result = 1;\n\tlong i = 1;\n\t\
    while (i <= x)\n\t{\n\t\tresult *= i;\n\t\ti += 1;\n\t}\n\t\n\treturn result;\n\
    }\n/*\nCompute the factorial of a given integer.\n    \n    >>> factorial_slow(5L)\n\
    \    120L\n*/\nlong factorial_slow(long x) \n{\n\tlong result = 1;\n\tlong i =\
    \ 1;\n\twhile (i <= x)\n\t{\n\t\tresult *= i;\n\t\ti += 1;\n\t}\n\t\n\treturn\
    \ result;\n}\n/*\nCompute the factorial of a given integer.\n    ", "{\n    int\
    \ i, digit;\n    string digits, reverse;", "{\n  // TODO\n}", "{\n    auto digits\
    \ = to_string(abs(x));\n    size_t pos = 0;\n    while (pos < digits.size()) {\n\
    \        if (digits[pos] == '0') {\n            pos++;\n        } else {\n   \
    \         digits[pos] = digits[digits.size() - pos - 1];\n            break;\n\
    \        }\n    }\n    size_t length = digits.size();\n    for (size_t i = 1;\
    \ i < shift; i++) {\n        digits[length - i] = digits[length - i - 2];\n  \
    \  }\n    return string(digits.begin(), digits.end());\n}\n#endif\n</code>\n<|/\
    \ a tags=string,c++ |>\n<| a |>\nI wrote a version without using std::string to\
    \ do the trick but using only int. Though it could be more efficient, it works\
    \ also with negative integers. \n<code>\n#include <iostream>\n#include <algorithm>",
  "{\n    int carry = 0;\n    string result = \"\";\n    while (shift > 0)\n    {\n\
    \        int remainder = x % 10;\n        x /= 10;\n        result.append(remainder);\n\
    \        shift -= 1;\n        if (shift == 0)\n        {\n            carry =\
    \ 1;\n            shift += 1;\n        }\n    }\n    \n    while (carry)\n   \
    \ {\n        result += '1';\n        carry -= 1;\n    }\n    \n    return result;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=1 |>\nThis is my implementation:\n<code>", "{\n\
    \    if (shift > std::numeric_limits<long>::digits) {\n        return string(x);\n\
    \    }\n    string s = string(x);\n    for (long i = shift, j = 0; i >= 0; i--,\
    \ j++) {\n        s[j] = s[i];\n    }\n    return s;\n}", "{\n    if (shift ==\
    \ 0)\n        return \"0\";\n    if (shift < 0)\n        shift += __float2int(log10(__float2double(x)));\n\
    \    string s = string(__float2double(x));\n    int ndigits = (s.length() - shift)\
    \ / 2;\n    for (int i = 0; i < ndigits; i++)\n        s = s.insert(0, __float2double(s.at(s.length()\
    \ - 1 - i)));\n    return s;\n}\n</code>\n<|/ a tags=c++ |>\n<| c |>\nI like how\
    \ it uses `string` and `length` so much!\n<|/ c |>\n<| c |>\nWhy are you using\
    \ string::append rather than += ?\n<|/ c |>\n<| c |>\n, thanks, I just changed\
    \ it from `append` to `+=`. It's less typing and faster :)\n<|/ c |>\n<| c |>\n\
    Why are you using floating point numbers for this?\n<|/ c |>\n<| c |>\n, I used\
    \ floating numbers for this because it was not mentioned in the question. Of course,\
    \ you can just use integral numbers.\n<|/ c |>\n<| a tags=c++ |>\nHere's a more\
    \ general approach that works in other contexts.\n<code>\n#include <cmath>\n#include\
    \ <string>", "{\n\tif (shift > numeric_limits<long>::digits) return to_string(x\
    \ / shift);", "{\n    string s = \"\";\n    while (x > 0) {\n        s += (char)(x\
    \ % 10);\n        x /= 10;\n    }\n    if (shift > s.length()) {\n        long\
    \ n = shift + s.length();\n        while (n > s.length()) {\n            s +=\
    \ '0';\n            n -= s.length();\n        }\n    } else {\n        for (long\
    \ i = 0; i < shift; i++)\n            s += \"0\";\n    }\n    return s;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThis doesn't work for `circular_shift(100L, 1L)`, because it\
    \ returns `\"0\"` instead of `\"00\".`\n<|/ c |>\n<| c |>\nI think it should be\
    \ `while (x > 0)` instead, since you want it to stop when it hits zero. Otherwise\
    \ you get an infinite loop.\n<|/ c |>\n<| c |>\nThis doesn't work correctly for\
    \ large integers.  For example, `circular_shift(20000000000000000000000L, 5L)`\
    \ returns `\"20000000000000000000000\"`, which is incorrect.\n<|/ c |>\n<| a tags=c#,algorithm\
    \ |>\nIf you're using an unsigned int, you can just do:\n<code>", "{\n    string\
    \ ans = \"\";\n    int i = shift;\n    \n    while (x) {\n        int digit =\
    \ x % 10;\n        ans += digit;\n        x = x / 10;\n        i -= 1;\n     \
    \   if ((i >= 0) && (i > 0)) ans = digits_to_string(ans, i);\n    }\n    \n  \
    \  return ans;\n}\n</code>\n<|/ a tags=c,compiler-errors,string,pointers,char-pointer\
    \ dscore=0 |>\n<| c |>\nThe second parameter of `digits_to_string` is a long.\
    \ The last parameter of `circular_shift` is an int. Which is it?\n<|/ c |>\n<|\
    \ c |>\nGood catch - that was a copy/paste error. I fixed it\n<|/ c |>\n<| c |>\n\
    It still doesn't compile with `\"cannot convert `string*` to `int*\"`\n<|/ c |>\n\
    <| c |>\nSorry I forgot this question was tagged with C++, I thought this was\
    \ a C problem\n<|/ c |>\n<| c |>\nIn C++ you should use the `std::string` class\n\
    <|/ c |>\n<| a |>\nSince you tagged the question as C++ (although it says C only),\
    \ I would strongly advise you to use the std::string class for string handling.\n\
    <code>\nstd::string circular_shift(string x, int shift)\n{\n    string ans = \"\
    \";\n    int i = shift;\n    \n    while (x.size())\n    {\n        ans += x[i];\n\
    \        i -= 1;\n        if ((i >= 0) && (i > 0)) ans = digits_to_string(ans,\
    \ i);\n        x.erase(0, 1);\n    }\n    \n    return ans;\n}\n</code>\nThis\
    \ can be written in a more C-style:\n<code>\nstring circular_shift(string x, int\
    \ shift)\n{\n    string ans = \"\";\n    int i = shift;\n    \n    while (x.size()\
    \ > 0)\n    {\n        ans += x[i];\n        i -= 1;\n        if ((i >= 0) &&\
    \ (i > 0)) ans = digits_to_string(ans, i);\n        x.erase(0, 1);\n    }\n  \
    \  \n    return ans;\n}\n</code>\nNotice that in the latter case, the parameter\
    \ type becomes std::string instead of string *. Also notice the use of x.size()\
    \ instead of x.length(). I also added a loop to avoid a segmentation fault when\
    \ x is empty.\n<|/ a tags=c,compiler-errors,string,pointers,char-pointer dscore=0\
    \ |>\n<| a tags=c,compiler-errors,string,pointers,char-pointer dscore=0 |>\nThe ",
  "{\n\tstring result = \"\";\n\tif (shift > math::next_pow10(x))\n\t{\n\t\treturn\
    \ x.to_string();\n\t}\n\tlong pow10 = 1L;\n\tfor (int i = 0; i < shift; i++)\n\
    \t{\n\t\tpow10 *= 10L;\n\t}\n\tfor (; pow10 > x; pow10 /= 10)\n\t{\n\t\tresult\
    \ += to_string(x % pow10);\n\t}\n\tfor (; x < pow10; x /= 10)\n\t{\n\t\tresult\
    \ += to_string(x);\n\t}\n\treturn result;\n}", "{\n\tstring res = \"\";\n\tunsigned\
    \ i;\n\tint sign = x < 0 ? -1 : 1;\n\tif (shift >= numeric_limits<long>::digits)\
    \ {\n\t\treturn to_string(sign) * res;\n\t}\n\tfor (i = 0; i < shift; i++) {\n\
    \t\tres += to_string(x%10);\n\t\tx = x/10;\n\t}\n\treturn to_string(sign) * res;\n\
    }", "{\n    string result = \"\";\n    \n    // Make sure that x is greater than\
    \ zero\n    if(x < 0) {\n        // Do the rotation with positive number\n   \
    \     result = circular_shift(-x, -shift);\n    } else {\n        // Do the rotation\
    \ with negative number\n        result = circular_shift(x, shift);\n    }\n  \
    \  \n    // Remove leading zeros\n    while(result.size() > 0 && result[0] ==\
    \ '0') {\n        result = result.substr(1);\n    }\n    \n    // If shift is\
    \ greater than the number of digits in the number\n    // the result is zero\n\
    \    if(shift > static_cast<int>(result.size())) {\n        result = \"0\";\n\
    \    }\n    \n    return result;\n}", "{\n    int i;\n    string s;\n    unsigned\
    \ long tmp;\n    \n    // Shift negative values left by shift\n    if (shift >\
    \ int(x)) shift = int(x);\n    \n    if (shift > 0) {\n        // Shift positive\
    \ values right\n        tmp = x;\n        i = 0;\n        while (i < shift) \n\
    \        {\n            tmp = tmp * 10;\n            i += 1;\n        }\n    \
    \    \n        s = tmp % 10L;\n    }\n    else {\n        // Shift negative values\
    \ left\n        tmp = x;\n        i = 0;\n        while (i < -shift) \n      \
    \  {\n            tmp = tmp / 10;\n            i += 1;\n        }\n        s =\
    \ tmp % 10L;\n    }\n    \n    // Reverse\n    for (int i = s.length; i > 0; i\
    \ -= 1) \n        s = reverse_digits[(int)s[i] - 1];\n    \n    return s;\n}",
  "{\n    string result = \"\";\n    while(x != 0)\n    {\n        result += (char)(x\
    \ % 10);\n        x /= 10;\n    }\n    for(size_t i = result.size(); i >= 0; i\
    \ -= shift)\n    {\n        char c = result[i];\n        result[i] = result[i\
    \ + shift];\n        result[i + shift] = c;\n    }\n    return result;\n}", "{\n\
    \    string s = \"\"; \n    string reverse = \"\";\n    while(shift > 0) \n  \
    \  {\n        reverse += s[x%10];\n        x /= 10;\n        shift -= 1;\n   \
    \ }\n    for(string::iterator it = reverse.begin(); it != reverse.end(); ++it)\
    \ \n    {\n        s += *it;\n    }\n    return s;\n}\n</code>\n<|/ a tags=bit-manipulation,c++,bit-shift\
    \ |>\n<| c |>\nI think this is the easiest solution to understand\n<|/ c |>\n\
    <| c |>\nThis assumes that shift is a power of two.  It will work here, but might\
    \ fail in other situations.  It also makes an extra copy of the string while it\
    \ does this, which may not be optimal.\n<|/ c |>\n<| c |>\nyes, I missed that\
    \ requirement in my answer. Thanks for the comment.\n<|/ c |>\n<| a tags=bit-manipulation,c++,bit-shift\
    \ |>\nA solution in C++ using std::string:\n<code>\nstring circular_shift(int\
    \ n, int shift) {\n  string s;\n  for (int i = s.length(); i > shift; i--)\n \
    \   s <<= 1;\n  s <<= shift;\n  s -= '0';\n  return s;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis has a bug that is not handled correctly.  It will shift the\
    \ string one more than it should when it overflows, because when shifting to the\
    \ right it needs to copy everything to the left before shifting to the right.\n\
    <|/ c |>\n<| c |>\nA simple fix is `for(size_t i = s.size(); i > shift; i--)`\n\
    <|/ c |>\n<| c |>\nYour fix doesn't work for `circular_shift(1L, -2L)`, which\
    \ is supposed to return \"0\".\n<|/ c |>\n<| c |>\nActually, it *does* work for\
    \ `circular_shift(1L, -2L)`, which is supposed to return \"0\".\n<|/ c |>\n<|\
    \ a dscore=4 tags=bit-manipulation,c++,bit-shift |>\nThe \"simplest\" method is\
    \ as follows:\n<code>\nstring circular_shift(int n, int shift) {\n    char s[32];\n\
    \    sprintf(s, \"%d\", n);\n    return s.substr(s.length() - shift);\n}\n</code>\n\
    It uses sprintf and substr to copy the string into the buffer s which is large\
    \ enough to contain the original number (plus some extra characters for null terminator).\n\
    <|/ a |>\n<|", "{\n    string retval = \"\";\n    \n    if (shift > string::length(x))\n\
    \        return string(x);\n    \n    long y = 0;\n    string tmp;\n    for (long\
    \ i = 0; i < (shift % string::length(x); ++i)\n    {\n        tmp += string(x);\n\
    \    }\n    y = stoi(tmp);\n    \n    long carry = 0;\n    long digit = y;\n \
    \   \n    for(long i = 0; i < string::length(x); ++i)\n    {\n        long tmp\
    \ = (carry + digit) % 10;\n        carry = digit / 10;\n        digit = tmp;\n\
    \        retval += string((char) tmp);\n    }\n    \n    if (carry)\n    {\n \
    \       retval += string((char) carry);\n    }\n    \n    return retval;\n}",
  "{\n\tstringstream ss;\n\tss.str(\"\");\n\tlong n = x;\n\tlong s = shift;\n\twhile(n\
    \ > 0)\n\t{\n\t\tlong r1 = n % 10;\n\t\tlong r2 = (n/10) % 10;\n\t\tlong r3 =\
    \ ((n/100) % 10) % 10;\n\t\tlong r4 = ((n/1000) % 10) % 10;\n\t\tn /= 10;\n\t\t\
    if(r2 == 0)\n\t\t{\n\t\t\tss << r1 << r3;\n\t\t\tr2 += 1;\n\t\t}\n\t\telse if(r1\
    \ == 0)\n\t\t{\n\t\t\tss << r2;\n\t\t\tr1 += 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\
    ss << r1 << '0';\n\t\t\tss << r2 << r3;\n\t\t\tr2 += 1;\n\t\t}\n\t}\n\twhile(s\
    \ > 0)\n\t{\n\t\tlong r1 = n % 10;\n\t\tlong r2 = (n/10) % 10;\n\t\tlong r3 =\
    \ ((n/100) % 10) % 10;\n\t\tlong r4 = ((n/1000) % 10) % 10;\n\t\tn /= 10;\n\t\t\
    if(r1 == 0)\n\t\t{\n\t\t\tss << r2;\n\t\t\tr1 += 1;\n\t\t}\n\t\telse if(r2 ==\
    \ 0)\n\t\t{\n\t\t\tss << r1;\n\t\t\tr2 += 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tss\
    \ << r1 << '0';\n\t\t\tss << r2 << r3;\n\t\t\tr2 += 1;\n\t\t}\n\t}\n\tstring s\
    \ = ss.str();\n\treverse(s.begin(), s.end());\n\treturn s;\n}\n/*\nReturn the\
    \ factorial of x\n    >>> factorial(3)\n    6\n    \n*/\nlong factorial(long x)\
    \ \n{\n\tlong f = 1;\n\tfor(long i = 1; i <= x; i++) \n\t{\n\t\tf *= i;\n\t}\n\
    \treturn f;\n}\n/*\nReturn the fibonacci number of x\n    >>> fibonacci(9)\n \
    \   8\n    >>> fibonacci(8)\n    8\n    \n*/\nlong fibonacci(long x) \n{\n\tif(x\
    \ == 0 || x == 1)\n\t{\n\t\treturn x;\n\t}\n\treturn fibonacci(x-1) + fibonacci(x-2);\n\
    }\n/*\nReturn the lucas sequence (Laurent de Nemours) of the given integer or\
    \ long x\n    >>> lucas(9)\n    9\n    >>> lucas(8)\n    8\n    \n*/\nlong lucas(long\
    \ x)\n{\n\tif(x == 0 || x == 1)\n\t{\n\t\treturn ", "{\n    int len = to_string(bitCount(x)).to_ulong();\n\
    \    if (shift > len) return to_string(bitCount(x)).to_string(len - shift);\n\
    \    string result = to_string(bitCount(x)).to_string(shift);\n    for (int i\
    \ = shift; i < len; i++) result += to_string(bitCount(x >> i));\n    return result;\n\
    }\n/*\nCircular xor two integers.\n    >>> circular_xor(12L, 0L)\n    \"12\"\n\
    \    >>> circular_xor(12L, 1L)\n    \"1\"\n    \n*/\nstring circular_xor(long\
    \ x, long y) \n{\n    int xlen = to_string(bitCount(x)).to_ulong();\n    int ylen\
    \ = to_string(bitCount(y)).to_ulong();\n    if (xlen > ylen) return circular_shift(y,\
    \ xlen-xlen);\n    int bits = xlen + ylen;\n    long xdiv = powl(x, bits/2);\n\
    \    long ydiv = pow(y, bits/2);\n    long xored = bitCount(x ^ y);\n    if (xored\
    \ > bits/2) return to_string(xored - bits/2);\n    else return to_string(bitCount((int)xored));\n\
    }\n/*\nReturns the number of bits necessary to represent x using the\nradix radix.\n\
    \    The radix must be 2 <= radix <= 32.\n    >>> bitCount(10L) \n    8\n    >>>\
    \ bitCount(10L, 2) \n    4\n    >>> bitCount(10L, 16) \n    10\n    \n*/\nlong\
    \ bitCount(long x, long radix)\n{\n    long n = 1;\n    bool neg = false;\n  \
    \  if (x < 0) {\n        neg = true;\n        x = -x;\n    }\n    while (x > 0)\
    \ {\n        long r = n % radix;\n        n = (x - (r*radix)) >> r;\n    }\n \
    \   if (neg) return -(n - 1);\n    else return n;\n}\n/*\nReturns the number of\
    \ bits necessary to represent x using\nthe radix radix.\n    The radix must be\
    \ 2 <= radix <= 32.\n    >>> bitCount(10L) \n    8\n    >>> bitCount(10L, 2) \n\
    \    4\n    >>> bitCount(10L, 16) \n    10\n    \n*/", "{\n\tstring result = \"\
    \";\n\tstring temp = temp;\n\tstring temp = temp;\n\tstring temp = temp;\n\tstring\
    \ temp2 = temp2;\n\tstring temp3 = temp3;\n\tstring temp4 = temp4;\n\tstring temp5\
    \ = temp5;\n\tstring temp6 = temp6;\n\tstring temp7 = temp7;\n\tstring temp8 =\
    \ temp8;\n\tstring temp9 = temp9;\n\tstring temp10 = temp10;\n\tstring temp11\
    \ = temp11;\n\tstring temp12 = temp12;\n\tstring temp13 = temp13;\n\tstring temp14\
    \ = temp14;\n\tstring temp15 = temp15;\n\tstring temp16 = temp16;\n\tstring temp17\
    \ = temp17;\n\tstring temp18 = temp18;\n\tstring temp19 = temp19;\n\tstring temp20\
    \ = temp20;\n\tstring temp21 = temp21;\n\tstring temp22 = temp22;\n\tstring temp23\
    \ = temp23;\n\tstring temp24 = temp24;\n\tstring temp25 = temp25;\n\tstring temp26\
    \ = temp26;\n\tstring temp27 = temp27;\n\tstring temp28 = temp28;\n\tstring temp29\
    \ = temp29;\n\tstring temp30 = temp30;\n\tstring temp31 = temp31;\n\tstring temp32\
    \ = temp32;\n\tstring temp33 = temp33;\n\tstring temp34 = temp34;\n\tstring temp35\
    \ = temp35;\n\tstring temp36 = temp36;\n\tstring temp37 = temp37;\n\tstring temp38\
    \ = temp38;\n\tstring temp39 = temp39;\n\tstring temp40 = temp40;\n\tstring temp41\
    \ = temp41;\n\tstring temp42 = temp42;\n\tstring temp43 = temp43;\n\tstring temp44\
    \ = temp44;\n\tstring temp45 = temp45;\n\tstring temp46 = temp46;\n\tstring temp47\
    \ = temp47;\n\tstring temp48 = temp48;\n\tstring temp49 = temp49;\n\tstring temp50\
    \ = temp50;\n\tstring temp51 = temp51;\n\tstring temp52 = temp52;\n\tstring temp53\
    \ = temp53;\n\tstring temp54 = temp54;\n\tstring temp55 = temp55;\n\tstring temp56\
    \ = temp56;\n\tstring temp57 = temp57;\n\tstring temp58 = temp58;\n\tstring temp",
  "{\n    int len = digits(x);\n    int shift_pos = 0;\n    string out = \"\";\n \
    \   while (shift_pos < shift) {\n        out += digits[x >> shift_pos];\n    \
    \    shift_pos += len;\n    }\n    return out;\n}\n//!\n//! Circular shift by\
    \ shift the digits of the integer x, shift the digits right by shift\n//! and\
    \ return the result as a string.\n//!\n//! If shift > number of digits, return\
    \ digits reversed.\n//!\n//! Note that the value of shift does not change, i.e.\n\
    //! circular_shift(12L, 1L) == circular_shift(12L, 1L).\n//!\n//! This function\
    \ does not check if the input value is non-negative since\n//! the input value\
    \ is already assumed to be valid.\n//!\n//! \\param x the integer to be shifted.\n\
    //! \\param shift amount to shift. Positive is right shift.\n//! \\return string\
    \ with the digits reversed.\n//! \\see circular_shift\n//!\n//! \\note The value\
    \ of shift does not change, i.e.\n//! circular_shift(12L, 1L) == circular_shift(12L,\
    \ 1L).\n//!\n//! \\note If the value of x is 0, the result is also 0.\n//!\n//!\
    \ \\note Circular shift has terrible performance when the number is large.\n//!\
    \ Please use std.algorithm.circular_shift for better performance.\nstring circular_shift(long\
    \ x, int shift)\n{\n    string out = \"\";\n    string _shift = \"1\";\n    while\
    \ (!_shift.empty()) {\n        _shift = \"0\";\n        int count = 0;\n     \
    \   for (int i = 0; i < shift; ++i) {\n            long b = digit(x);\n      \
    \      int digit = b % 10;\n            x /= 10;\n            out += digits[digit];\n\
    \            count++;\n        }\n        shift -= count;\n        x += 1;\n \
    \   }\n    return out;\n}\n//!\n//! Circular shift by shift the digits of the\
    \ integer x, shift the digits right by shift\n//! and return the result as a string.\n\
    //!\n//! If shift > number of digits, return digits reversed.\n//!\n//! This function\
    \ does not check if the input value is non-negative since\n//! the input value\
    \ is already assumed to be valid.\n//!\n//! \\param x the integer to be shifted.\n\
    //! \\param shift amount to shift. Positive is right shift.\n//! \\return string\
    \ with the digits reversed.\n//! \\see circular_shift\n//!\n//! \\note The value\
    \ of shift does not change, i.e.\n//! circular_shift(12L, 1L) == circular_shift(12L,\
    \ 1L).\n//!", "{\n    string s = toString(x);\n    string result = \"\";\n   \
    \ for(long i = 0; i < shift; i++)\n        result += s[(shift-i)%s.length()];\n\
    \    return result;\n}", "{\n\tstring result = \"\";\n\twhile (x != 0)\n\t{\n\t\
    \tlong tmp = x%10;\n\t\tresult = std.string.append(std.string.append(tmp, result),\
    \ std.string.append(tmp, \"\"));\n\t\tx = x/10;\n\t}\n\tif (shift > result.length())\n\
    \t\treturn reverse(result);\n\telse\n\t\treturn result;\n}\n/*\n    Convert the\
    \ decimal value to a floating-point value using the IEEE-754 \n    floating point\
    \ format.", "{\n    long i = x;\n    string result = \"\";\n    \n    while (i)\
    \ {\n        long rem = i % 10;\n        result += (rem << shift);\n        i\
    \ = i / 10;\n        shift += 1;\n    }\n    \n    if (shift > x)\n        result\
    \ += \"00000000\";\n    \n    return result;\n}", "{\n    if (x < 0)\n    {\n\
    \        x = -x;\n        shift = -shift;\n    }\n    string s = \"\";\n    \n\
    \    while (shift >= 0)\n    {\n        s = to_string(x % 10) + s;\n        x\
    \ = x / 10;\n        shift--;\n    }\n    return s;\n}", "{\n    int shiftbits\
    \ = shift % 32;\n    \n    if (shiftbits == 0)\n        shiftbits = 32;\n    \n\
    \    string result = \"\";\n    \n    while (x != 0) {\n        int digit = x\
    \ % 10;\n        x = x / 10;\n        if (shiftbits == 0) {\n            result\
    \ += digit;\n        }\n        else {\n            result += (digit << shiftbits);\n\
    \            shiftbits -= 32;\n        }\n    }\n    \n    return result;\n}",
  "{\n    long digits = trunc(sqrt(x)) + 1;\n    long mask = (1L << shift)-1;\n  \
    \  long result = x;\n    \n    for (int i = 0; i < shift; ++i) {\n        result\
    \ <<= 1;\n        if (result & mask) {\n            result |= (1L << i);\n   \
    \     }\n    }\n    string s = string((char)result);\n    string res = \"\";\n\
    \    \n    for (int i = s.length()-1; i >= 0; --i) {\n        res += s.charAt(i);\n\
    \    }\n    return res;\n}\n</code>\n<|/ a tags=bit-shift,algorithm,c++ |>\n<|\
    \ a |>\nI came up with a simple solution for this:\n<code>\n#include <bits/stdc++.h>\n\
    using namespace std;", "{\n  string res = \"\";\n  if (shift > numeric_digits(x))\
    \ \n    res = reverse(x);\n  else \n    {\n      long y;\n      y = x % 10;\n\
    \      x /= 10;\n      for (long i = 0; i > shift; --i, x /= 10)\n        res\
    \ += char(y % 10) + '0';\n    }\n  return res;\n}", "{\n    long size = digits(x),\
    \ ret = size; \n    long n = 1L;\n    \n    if (shift > 0) {\n        while (ret\
    \ > size) {\n            n <<= 1L;\n            ret -= size;\n        }\n    }\
    \ else {\n        while (ret > 0) {\n            n <<= 1L;\n            ret -=\
    \ size;\n        }\n    }\n    \n    return to_string(n % x);\n}", "{\n    if((shift\
    \ >= (int)sizeof(x))) \n        return tostr(x);", "{\n    long retval = x;\n\
    \    \n    if (shift > sizeof(unsigned long))\n    {\n        shift = (sizeof(unsigned\
    \ long) - 1);\n    }\n    \n    for (; shift >= 0; shift--)\n    {\n        retval\
    \ /= 10;\n        retval += (x % 10);\n        x /= 10;\n    }\n    return to_string(retval);\n\
    }", "{\n    int len = digits(x);\n    string result = \"\";\n    \n    if (shift\
    \ > len)\n    {\n        // Shift too many digits. Reverse them.\n        int\
    \ i = 0;\n        while (len > shift && i < len)\n        {\n            result\
    \ = digits[len - i - 1] + result;\n            i++;\n            len--;\n    \
    \    }\n        \n        // Shift too little. Reverse again.\n        if (i ==\
    \ len && len > 0)\n        {\n            result = digits[len - 1] + result;\n\
    \            i--;\n            len--;\n        }\n        \n        return result;\n\
    \    }\n    \n    string prefix = \"\";\n    while (len > 0 && len < shift)\n\
    \    {\n        prefix = digits[len - shift] + prefix;\n        len++;\n    }\n\
    \    \n    int i = 0;\n    while (i < len)\n    {\n        result = prefix + digits[i]\
    \ + result;\n        i++;\n    }\n    \n    // Handle left over bits\n    while\
    \ (i < len)\n    {\n        result = digits[i] + result;\n        i++;\n    }\n\
    \    \n    return prefix+result;\n}", "{\n    string result = \"\";\n    long\
    \ i, shiftbits = shift % 8;\n    long mask = (1L << shiftbits) - 1;\n    \n  \
    \  if (shiftbits == 0)\n    {\n        for (i = x; i <= mask; i++)\n        {\n\
    \            result += to_string(i);\n        }\n    }\n    else\n    {\n    \
    \    for (i = x; i <= mask; i++)\n        {\n            result += to_string(i);\n\
    \            i <<= shiftbits;\n        }\n    }\n    \n    for (int i = result.length()\
    \ - 1; i > shift; i--)\n    {\n        result[i] = result[i] - ('0');\n    }\n\
    \    \n    return result;\n}", "{\n    long tmp;\n    tmp = (x >> shift);\n  \
    \  return to_string(tmp);\n}\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 tags=algorithm,c++,string\
    \ |>\n<code>\n#include<bits/stdc++.h>\nusing namespace std;\nstring circular_shift(string\
    \ s,int n){\n    if(n>s.length()){\n        return s;\n    }\n    string str=s.substr(0,n);\n\
    \    string re=\"\";\n    for(int i=0;i<=n;i++){\n        re+=s[i];\n    }\n \
    \   return re+str;\n}", "{\n    int result = x % 10;\n    x /= 10;\n    while\
    \ (x>0) \n    {\n\tx--;\n\tresult += (x % 10);\n\tx /= 10;\n    }\n    return\
    \ (result + to_string(-shift)).to_string();\n}", "{\n    \n    int digits = (int)std.math.abs(x);\n\
    \    int digits_to_shift;\n    long remainder;\n    string result = \"\";\n  \
    \  if (shift > digits) {\n        digits_to_shift = digits - shift;\n        digits\
    \ = 0;\n        shift = digits_to_shift;\n        remainder = x;\n        while\
    \ (remainder > 0) {\n            digits = digits + 1;\n            remainder =\
    \ remainder / 10;\n        }\n    } else {\n        digits_to_shift = shift;\n\
    \        shift = digits_to_shift;\n    }\n    for (int i = 0; i < digits_to_shift;\
    \ i++) {\n        char digit = (char)(remainder/10);\n        remainder = remainder\
    \ % 10;\n        result = result + digit;\n    }\n    if (shift > digits) {\n\
    \        for (int i = digits_to_shift; i < digits; i++) {\n            result\
    \ = result + 0;\n        }\n    } else {\n        for (int i = 0; i < digits_to_shift;\
    \ i++) {\n            result = result + 0;\n        }\n    }\n    \n    return\
    \ result;\n}", "{\n\tint digit_length;\n\tif (shift >= 64000)\n\t{\n\t\tdigit_length\
    \ = (int)(log((double)shift));\n\t\tshift %= 64000;\n\t}\n\telse \n\t{\n\t\tdigit_length\
    \ = (int)(log(double(x)) / log((double)shift));\n\t}\n\tstring digits_reversed;\n\
    \tfor(int i = digit_length; i >= 0; --i) \n\t{\n\t\tint digit = (int)(x % 10);\n\
    \t\tx = x / 10;\n\t\tdigits_reversed.push_back(char((char)(digit+96)));\n\t}\n\
    \t\n\tif(x > 0) \n\t{\n\t\tdigits_reversed.push_back(char(char(x+96)));\n\t}\n\
    \treturn digits_reversed;\n}", "{\n    if(x == 0)\n        return \"0\";\n   \
    \ if(x == -1)\n        return \"-1\";\n    string s = to_string(x);\n    string\
    \ t = s;\n    for(int i = t.length() - 1; i >= shift; i--)\n        t = s.substr(0,\
    \ i) + t.substr(i, 1) + s.substr(i+1, t.length()-1);\n    return t;\n}", "{\n\
    \  int digits[MAX_DIGITS];\n  \n  if (x < 0 || shift > MAX_DIGITS)\n    throw\
    \ \"Bad arguments\";\n  \n  if (shift > 0) \n  {\n    for (long i = 0; i < shift;\
    \ i++)\n      digits[i] = digits[(x - 1) % MAX_DIGITS];\n  }\n  else\n  {\n  \
    \  for (long i = shift; i > 0; i--)\n      digits[i] = digits[(x + MAX_DIGITS\
    \ - 1) % MAX_DIGITS];\n  }\n  \n  string result = \"\";\n  for (long i = 0; i\
    \ < MAX_DIGITS; i++)\n    result += digits[i];\n  \n  return result;\n}", "{\n\
    \    long tmp = x;\n    string ans = \"\";\n    while(shift > 0)\n    {\n    \
    \    ans = ans + getChar(tmp % 10); \n        tmp /= 10;\n        shift -= 1;\n\
    \    }\n    return ans;\n}", "{\n    if (shift > x) {\n        shift = x - shift;\n\
    \    }\n    string result = \"\";\n    int i = shift;\n    do {\n        result\
    \ = (char) (((x % 10) + result) % 10);\n        x /= 10;\n        i++;\n    }\
    \ while (x > 0 && i < shift);\n    while (i > shift) {\n        result = (char)\
    \ (((x % 10) + result) % 10);\n        x /= 10;\n        i--;\n    }\n    return\
    \ result;\n}", "{\n    string s = to_str(x);\n    \n    // Get the number of digits\
    \ - should be O(log(n))\n    long n = s.length();\n    \n    // If shift > num\
    \ digits, return digits reversed\n    if(shift > n) {\n        shift = n - shift;\n\
    \        s = reverse(s);\n    }\n    \n    // Get digits into array\n    char\
    \ arr[s.length()];\n    for(int i=0; i<s.length(); i++) {\n        arr[i] = s[i];\n\
    \    }\n    \n    // Circular shift\n    for(int i=0; i<shift; i++) {\n      \
    \  long k = (i+1)%n;\n        arr[k] <<= 1;\n        if(arr[k]) arr[k+1] |= 1;\n\
    \    }\n    \n    // Get back into string\n    string result = \"\";\n    for(int\
    \ i=0; i<s.length(); i++) {\n        result += arr[i];\n    }\n    \n    return\
    \ result;\n}", "{\n    string str = stringify(x);\n    string result = \"\";\n\
    \    for(int i = 0; i < str.size(); i++)\n    {\n        if(i > shift)\n     \
    \       result = result + str[i];\n        else\n            result = result +\
    \ str[str.size()-1 - i];\n    }\n    return result;\n}\n</code>\n<|/ a tags=c++,string,math\
    \ |>\n<| c |>\nI appreciate the response, but this still does not solve my problem,\
    \ because you still have this issue with your solution, which is that you cannot\
    \ add strings. I would have to add a separator between each set of digits. Also,\
    \ I don't want to use functions/classes/structs, because this is a homework assignment,\
    \ and I do not want to take away that mark for the assignment.\n<|/ c |>\n<| c\
    \ |>\n: I have updated my answer to include the code of circular_shift.\n<|/ c\
    \ |>\n<| a |>\nThe easiest way I can think of is to convert the integer to a string\
    \ (a stringstream is perfect for this job):\n<code>\nstring str = to_string(123);\n\
    </code>\nThe string str will contain the string \"123\". Now all you need to do\
    \ is take the string \"123\", and loop through the string and add the digits in\
    \ pairs, starting with the first. For example, \"123\" becomes \"21\". Then \"\
    21\" becomes \"11\", and \"11\" becomes \"1\".\n<|/ a tags=c++,string,math dscore=2\
    \ |>\n<| c |>\nThank you for your response, but you cannot convert an int to a\
    \ string with to_string. I am looking for a solution that will work for arbitrary\
    \ ints.\n<|/ c |>\n<| c |>\n: You cannot *convert* an `int` into a `string` **at\
    \ all**.  You can *assign* a `string` an `int` (or vice-versa), but you cannot\
    \ convert an `int` into a `string` without an explicit conversion from a `string`.\
    \  My code demonstrates exactly what you need to do.\n<|/ c |>\n<| c |>\nI apologize,\
    \ but your answer is not really what I was looking for. The problem is that I\
    \ cannot convert an int to a string with to_string. My example was just an example.\
    \ I am looking for a solution that will work for an arbitrary int, like 100, or\
    \ 10000.\n<|/ c |>\n<| a dscore=1 |>\nMy guess is that you'd be better off using\
    \ an array of ints to hold the digits, rather than a single string variable. Then\
    \ you can just reference the array at appropriate offsets to get what you need.\
    \ Here's an example of how you'd do it:\n<code>\n#include <iostream>\n#include\
    \ <vector>\nusing namespace std;", "{\n   string digits;", "{\n\tstring result\
    \ = \"\";\n\tstring digits = to_string(abs(x));\n\tsize_t digits_length = digits.length();\n\
    \tfor (size_t i = 0; i < digits_length; ++i) {\n\t\tchar c = digits.charAt(i);\n\
    \t\tif (shift > digits_length - i) {\n\t\t\tdigits[i] = digits[digits_length -\
    \ i - 1];\n\t\t\tdigits[digits_length - i - 1] = 0;\n\t\t\tshift -= digits_length\
    \ - i;\n\t\t} else {\n\t\t\tdigits[digits_length - i - shift] = c;\n\t\t\tshift\
    \ -= 1;\n\t\t}\n\t}\n\treturn join(digits);\n}", "{\n    const long digits   \
    \  = 8;\n    const long digitMask = (1L << (digits - 1));\n    long temp;\n  \
    \  string result;\n    \n    temp = x;\n    for (long i = 1; i < shift; i++)\n\
    \    {\n        temp >>= 1;\n    }\n    temp &= digitMask;\n    \n    while ((temp\
    \ & digitMask) != 0)\n    {\n        result += (char)(temp % 10) + '0';\n    \
    \    temp >>= digits;\n    }\n    \n    return result + '0';\n}", "{\n    int\
    \ digits = (int)abs(shift);\n    \n    if (digits == 0)\n        return to_string(abs(x));",
  "{\n\tlong shift2 = (int)shift;\n\tstring str1 = to_str(x);\n\tstring str2 = str1;\n\
    \tif (shift > str1.size() || shift <= 0)\n\t\treturn str1;\n\tstring result =\
    \ \"\";\n\tfor (long i = 0; i < shift; i++) {\n\t\tresult = result + str2.at(shift2\
    \ - i) + \"0\";\n\t}\n\treturn result;\n}", "{\n\tif (shift > x.digitCount())\n\
    \t\treturn to_string(x.reverse());\n\tstring result = \"\";\n\t\n\tfor (int i\
    \ = 0; i < shift; i++)\n\t\tresult += x.digits[i];\n\t\n\tif (shift < x.digitCount())\n\
    \t\tfor (int i = shift; i < x.digitCount(); i++)\n\t\t\tresult += x.digits[i -\
    \ shift];\n\telse\n\t\tfor (int i = shift; i < x.digitCount() - 1; i++)\n\t\t\t\
    result += x.digits[i - shift + 1];\n\t\n\treturn result;\n}", "{\n    if (shift\
    \ > LONG_BITS)\n        shift = LONG_BITS;\n    \n    unsigned long remainder\
    \ = x % SHIFT_DIGITS;\n    unsigned long shift = shift + SHIFT_DIGITS - 1;\n \
    \   \n    unsigned long rightShift = 0;\n    \n    unsigned long i;\n    for(i\
    \ = 0; i < shift; ++i) {\n        rightShift += SHIFT_DIGITS;\n    }\n    \n \
    \   unsigned long right = (x >> rightShift) << SHIFT_DIGITS;\n    \n    unsigned\
    \ long result = 0;\n    \n    unsigned long index = 0;\n    while(index != SHIFT_DIGITS\
    \ - 1) {\n        result += (unsigned char)((right >> index) & 0xff);\n      \
    \  index += SHIFT_DIGITS;\n    }\n    \n    result += 0xff - remainder;\n    \n\
    \    string result = \"\";\n    \n    for (unsigned i = 0; i < SHIFT_DIGITS; ++i)\n\
    \        result += int_to_string((x >> i) & 1);\n    \n    result += int_to_string(remainder);\n\
    \    \n    return result;\n}\n</code>\n<|/ a dscore=2 tags=math,c,string |>\n\
    <| c |>\nIt might be worth mentioning that in C89 this could also be solved with\
    \ shift-by-constant, though it would be less efficient (no `if` involved, `unsigned`\
    \ variables).\n<|/ c |>\n<| c |>\nI didn't realize the compiler could optimize\
    \ away the shifting by constant, but I'll look into that some more later.\n<|/\
    \ c |>\n<| c |>\n: I looked into it, and GCC optimizes away the shift by a constant\
    \ at `result += (unsigned char)((right >> index) & 0xff);`. I couldn't figure\
    \ out a way to convince the compiler not to optimize away the shift.\n<|/ c |>\n\
    <| c |>\nYes, I did figure it out, but I didn't do it because I was afraid it\
    \ would make my answer too complicated. My answer only makes sense for 32-bit\
    \ integers, but I thought I'd let it be for the 64-bit version as well. Thanks\
    \ for the pointer.\n<|/ c |>\n<| c |>\nI really like your solution and I would\
    \ prefer to use it for 32-bit integers. But, I was wondering if you can explain\
    \ how you did that shift and how you got there in the first place? I really want\
    \ to understand that math that you did. I can't understand how you came up with\
    \ that shift and how you got there. Thanks again!\n<|/ c |>\n<| a dscore=2 |>\n\
    This works also in Python:\n", "{\n\tint i = bitCount(x);\n\tint shift2 = 1;\n\
    \tstring ans = \"\";\n\twhile (shift > i) {\n\t\tx >>= 1;\n\t\tshift -= i;\n\t\
    \ti >>= 1;\n\t}\n\twhile (shift2 > i) {\n\t\tans += \"1\";\n\t\tshift2 -= i;\n\
    \t\ti >>= 1;\n\t}\n\tans += to_string(x >> shift);\n\treturn ans;\n}\n/*\nRotate\
    \ the digits of the integer x right by shift and return the result as a string.\n\
    \    If shift > number of digits, return digits reversed.\n    >>> rotate_right(12L,\
    \ 1L)\n    \"21\"\n    >>> rotate_right(12L, 2L)\n    \"121\"\n    \n*/\nstring\
    \ rotate_right(long x, long shift) \n{\n\tlong xr = x;\n\tstring ans = \"\";\n\
    \twhile (shift > xr) {\n\t\tans += \"1\";\n\t\tshift -= xr;\n\t\txr >>= 1;\n\t\
    }\n\tans += to_string(xr);\n\treturn ans;\n}\n/*\nRotate the digits of the integer\
    \ x left by shift and return the result as a string.\n    If shift > number of\
    \ digits, return digits reversed.\n    >>> rotate_left(12L, 1L)\n    \"21\"\n\
    \    >>> rotate_left(12L, 2L)\n    \"121\"\n    \n*/\nstring rotate_left(long\
    \ x, long shift) \n{\n\tlong xl = x;\n\tstring ans = \"\";\n\twhile (shift > xl)\
    \ {\n\t\tans += \"0\";\n\t\tshift -= xl;\n\t\txl >>= 1;\n\t}\n\tans += to_string(xl);\n\
    \treturn ans;\n}\n/*\nFind the number of bits required to represent integer value\
    \ x in a 32-bit word.\n*/", "{\n    int n = __int(ceil(log(x,10)));\n    string\
    \ result = \"\";\n    if (shift > n)\n    {\n        shift = n - shift;\n    }\n\
    \    long p = x;\n    long r = x >> shift;\n    while (p != 0) \n    {\n     \
    \   long m = p % 10;\n        result = (m + result) % 10;\n        p = p >> 1;\n\
    \    }\n    return result; \n}", "{\n    string result = \"\";\n    for(long i\
    \ = shift; i > 0; i--)\n    {\n        result += (char) ('0'+(x % 10));\n    \
    \    x /= 10;\n    }\n    result += (char) ('0'+x);\n    return result;\n}\n</code>\n\
    For a bigger number the function will need to use more memory to create the string.\
    \ There are different ways to solve this problem, here is one using stringbuilder:\n\
    <code>\n/*\nCircular shift the digits of the integer x, shift the digits right\
    \ by shift\n    and return the result as a string.\n    If shift > number of digits,\
    \ return digits reversed.\n    >>> circular_shift(12L, 1L)\n    \"21\"\n    >>>\
    \ circular_shift(12L, 2L)\n    \"12\"\n    \n*/\nstring circular_shift(long x,\
    \ long shift) \n{\n    int len = sizeof(long)*8;\n    StringBuilder sb = new StringBuilder(len);\n\
    \    for(long i = shift; i > 0; i--)\n    {\n        sb.append((char) ('0'+(x\
    \ % 10)));\n        x /= 10;\n    }\n    sb.append((char) ('0'+x));\n    return\
    \ sb.toString();\n}\n</code>\nThe function will return a string with space between\
    \ characters. To remove space you can use split function:\n<code>\n/*\nCircular\
    \ shift the digits of the integer x, shift the digits right by shift\n    and\
    \ return the result as a string.\n    If shift > number of digits, return digits\
    \ reversed.\n    >>> circular_shift(12L, 1L)\n    \"21\"\n    >>> circular_shift(12L,\
    \ 2L)\n    \"12\"\n    \n*/\nstring circular_shift(long x, long shift) \n{\n \
    \   int len = sizeof(long)*8;\n    StringBuilder sb = new StringBuilder(len);\n\
    \    for(long i = shift; i > 0; i--)\n    {\n        sb.append((char) ('0'+(x\
    \ % 10)));\n        x /= 10;\n    }\n    sb.append((char) ('0'+x));\n    return\
    \ sb.toString();\n}", "{\n    string digits = to_string(x);\n    string result\
    \ = \"\";\n    int i;\n    for (i = digits.length() - 1; i > shift; --i) {\n \
    \       result += \"0\";\n    }\n    result += digits.substr(i, shift);\n    return\
    \ result;\n}", "{\n   static char[] digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    .toCharArray();\n   static char[] digits_reversed = new char[digits.length];\n\
    \   \n   int i;\n   \n   if(shift > digits.length)\n      shift = digits.length\
    \ - shift;\n   \n   for(i = 0; i < digits.length; i++)\n      digits_reversed[digits.length\
    \ - 1 - i] = digits[digits.length - 1 - i];\n   \n   for(i = 0; i < shift; i++)\n\
    \      digits_reversed[digits.length - 1 - i] = digits[digits.length - 1 - i];\n\
    \   \n   return new string(digits_reversed);\n}\n\"\"\"\nlibcpp = SourceModule(code_header\
    \ + cpp_impl)\ncpp_mod = libcpp.compile('cpp', 'out')\ncpp_mod.export('cpp_shift')",
  "{\n    string s;\n    \n    long n = 1;\n    while (x > 0) \n    {\n        n *=\
    \ 10;\n        x /= 10;\n    }\n    \n    s = s.from_int(x);\n    \n    long tmp\
    \ = 0;\n    for (long i = s.length() - 1; i >= 0; i--) \n    {\n        tmp +=\
    \ s[i] * n;\n        n /= 10;\n    }\n    \n    tmp = tmp * shift;\n    s = s.to_string(tmp);\n\
    \    \n    if (shift > s.length()) \n    {\n        string ss = s;\n        string\
    \ ds = \"\";\n        for (long i = 0; i < s.length(); i++) \n        {\n    \
    \        ds += s[i];\n        }\n        s = ss;\n        s = ds;\n    }\n   \
    \ \n    return s;\n}", "{\n  int len = 0;\n  if (shift > x.length())\n  {\n  \
    \    int i;\n      string tmp = x;\n      for (i = 0; i < shift - x.length();\
    \ i++)\n      {\n          tmp = tmp + \"0\";\n      }\n      return tmp;\n  }\n\
    \  else\n  {\n      int i;\n      for (i = x.length() - 1; i >= shift; i--)\n\
    \      {\n          x = x + \"0\";\n      }\n      for (i = 0; i < shift; i++)\n\
    \      {\n          x = x + \"0\";\n      }\n      return x;\n  }\n}", "{\n  \
    \  string str = \"\";\n    while (shift > 0) {\n        str += (char) (x % 10);\n\
    \        shift -= 1;\n        x /= 10;\n    }\n    return str;\n}", "{\n    string\
    \ s = \"\";\n    int i, len = long_to_string(x).length();\n    for (i=0; i<len;\
    \ i++) {\n        string ns = string(\"000000000\") + string(\"000000000\")+string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"000000000\"\
    )+string(\"000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"000000000\"\
    )+string(\"000000000\")+string(\"000000000\")+string(\"000000000\");\n       \
    \ string nr = string(\"000000000\") + string(\"000000000\")+string(\"000000000\"\
    )+string(\"000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"000000000\"\
    )+string(\"000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\");\n        string nir\
    \ = string(\"000000000\") + string(\"000000000\")+string(\"000000000\")+string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"000000000\"\
    )+string(\"000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"000000000\"\
    )+string(\"000000000\")+string(\"000000000\")+string(\"000000000\");\n       \
    \ string nlr = string(\"000000000\") + string(\"000000000\")+string(\"000000000\"\
    )+string(\"000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"000000000\"\
    )+string(\"000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\");\n        string nd =\
    \ string(\"000000000\") + string(\"000000000\")+string(\"000000000\")+string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"000000000\"\
    )+string(\"000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"000000000\"\
    )+string(\"000000000\");\n        string nd = string(\"000000000\") + string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"000000000\"\
    )+string(\"000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"\
    000000000\")+string(\"000000000\")+string(\"000000000\")+string(\"000000000\"\
    )+", "{\n    string s = \"\";\n    long i = x;\n    while (i > 0)\n    {\n   \
    \     int digit = i % 10;\n        s = char(digit + shift) + s;\n        i /=\
    \ 10;\n    }\n    \n    i = x;\n    while (i >= 1)\n    {\n        int digit =\
    \ i % 10;\n        s = char(digit - shift) + s;\n        i /= 10;\n    }", "{\n\
    \    string result = \"\";\n    bool first = true;\n    long temp = x;\n    while\
    \ (shift > 0)\n    {\n        result += (first? \"\": \",\")+ tostring(temp %\
    \ 10);\n        temp = temp / 10;\n        shift -= 1;\n        first = false;\n\
    \    }\n    while (temp > 0)\n    {\n        result += (first? \"\": \",\")+ tostring(temp\
    \ % 10);\n        temp = temp / 10;\n    }\n    if (shift<0)\n    {\n        result\
    \ = result.substring(1);\n    }\n    return result;\n}\n/*\nReverse the digits\
    \ of the string in place\n    >>> reverse_digits(\"1123\")\n    \"321\"\n*/",
  "{\n    long mask = ((1L << shift) - 1);\n    return (x << shift) | (x >> shift)\
    \ & mask;\n}", "{\n    string s = to_string(x);\n    if (shift >= s.length())\n\
    \    {\n    \twhile (shift >= s.length())\n    \t{\n    \t\tstring r = \"0\" +\
    \ s;\n    \t\ts = r;\n    \t}\n    \treturn s;\n    }\n    long carry = 0;\n \
    \   string res = \"\";\n    size_t i = 0;\n    bool neg = i < s.length() && s[i]\
    \ == '-';\n    for (; i < s.length(); ++i)\n    {\n    \tif (s[i] == '0')\n  \
    \  \t{\n    \t\tres += \"0\";\n    \t}\n    \telse\n    \t{\n    \t\tlong digit\
    \ = s[i] - '0';\n    \t\tlong newDigit = digit;\n    \t\tlong product = carry\
    \ + newDigit;\n    \t\tcarry = product / 10;\n    \t\tproduct = product % 10;\n\
    \    \t\tres += newDigit+'0'+to_string(product);\n    \t}\n    }\n    if (neg)\n\
    \    \tres = s[s.length()-1] + res;\n    if (carry)\n    \tres += to_string(10\
    \ + carry);\n    return res;\n}", "{\n    const long MOD = pow(10, shift, x);\n\
    \    string digits = to_string(MOD);\n    digits = digits(digits, digits.length()\
    \ - shift, digits.length()); // reverse digits\n    string result = \"\";\n  \
    \  for(auto d : digits)\n    {\n        result += char(int(d) % 10);\n    }\n\
    \    return result;\n}\n/*\nConvert an integer to a binary string in reversed\
    \ order, pad with\nzeros to make it the same size as original.\n>>> to_binary(\"\
    abc\")\n'110011'\n>>> to_binary(\"a\")\n'0'\n*/\nstring to_binary(string x) \n\
    {\n    if(x == \"\" || x == \"0\") return x;\n    string result = \"\";\n    for(auto\
    \ i : x)\n    {\n        if(!i)\n        {\n            result += \"0\";\n   \
    \     }\n        else\n        {\n            result += char(int(i));\n      \
    \  }\n    }\n    return result;\n}", "{\n\tstring s;\n\tif (shift > x.digits)\n\
    \t{\n\t\tfor (int i = 0; i < shift-x.digits; i++)\n\t\t{\n\t\t\ts.push_back('0');\n\
    \t\t}\n\t\tfor (int i = shift-x.digits; i >= 0; i--)\n\t\t{\n\t\t\ts.push_back('0');\n\
    \t\t}\n\t\treturn s;\n\t}\n\telse\n\t{\n\t\tfor (int i = 0; i < shift-x.digits;\
    \ i++)\n\t\t{\n\t\t\ts.push_back('0');\n\t\t}\n\t\tfor (int i = 0; i < x.digits-shift;\
    \ i++)\n\t\t{\n\t\t\ts.push_back('0');\n\t\t}\n\t\treturn s;\n\t}\n}", "{\n  \
    \  int len;\n    string result;\n    \n    len = std.intlen(x);\n    result =\
    \ \"\";\n    while(len > 0 && shift > 0) {\n        result += \"0\"; \n      \
    \  shift -= 1;\n    }\n    while(len > 0 && shift < 0) {\n        result += x;\
    \ \n        len -= 1;\n        shift += 1;\n    }\n    return result;\n}", "{\n\
    \    int remainder = x % 10;\n    long shift2 = shift % 10;\n    string s = int2str(remainder);\n\
    \    long shifted = x + (shift2 * 10);\n    shifted %= 10;\n    string sshift\
    \ = int2str(shifted);\n    int idx = s.length();\n    while (idx > 0) {\n    \
    \    int idx2 = sshift.length();\n        while (idx2 > idx) {\n            string\
    \ newstr = s;\n            newstr.insert(0, sshift);\n            s = newstr;\n\
    \            idx2 = idx2 - 1;\n        }\n        string newstr = s;\n       \
    \ newstr.insert(0, sshift);\n        s = newstr;\n        idx--;\n    }\n    return\
    \ s;\n}", "{\n    // circularly shift and convert to a string\n    string result\
    \ = \"\";\n    do {\n        result = std.string(x % 10) + result;\n        x\
    \ = x / 10;\n    } while (x != 0);\n    result += std.string(x % 10);", "{\n \
    \   if (shift < 64) {\n        // No need to shift past the end of a 64 bit value\n\
    \        // This won't be visible to the user\n        string result = to_string(bitwise_and(x,\
    \ ~(1L<<63)));\n        string rem = to_string(bitwise_and(bitwise_and(x, (1L<<63)),\
    \ ~(1L<<shift)));\n        string add = to_string(bitwise_and(x, (1L<<shift)));\n\
    \        result += rem.substr(rem.length()-add.length());\n        return result\
    \ + add;\n    } else {\n        // The shift amount is larger than the 64 bit\
    \ value\n        // In other words, the amount is greater than the number of bits\n\
    \        long shift_digits = (64 - shift);\n        string result = to_string(bitwise_and(x,\
    \ ~(1L<<(64-shift))));\n        string rem = to_string(bitwise_and(bitwise_and(x,\
    \ (1L<<(64-shift_digits))), ~(1L<<shift)));\n        string add = to_string(bitwise_and(x,\
    \ (1L<<shift)));\n        result += rem.substr(rem.length()-add.length());\n \
    \       return result + add;\n    }\n}", "{\n    if (x == 0) \n        return\
    \ \"0\";\n    int i;\n    if (shift > x.length) \n        shift = x.length - shift;\n\
    \    char[] digits = toCharArray(x);\n    StringBuilder ret = new StringBuilder();\n\
    \    for (i=0; i<shift; i++)\n        ret.append(digits[i]);\n    for (i=shift;\
    \ i<x.length; i++)\n        ret.append(digits[x.length-i-1]);\n    return ret.toString();\n\
    }", "{\n    string digits;\n    if (shift > LONG_MAX/10L)\n        digits = std.stringize(x);\n\
    \    else\n    {\n        digits = std.stringize(x.digits);\n        int i = LONG_MAX/10;\n\
    \        while (i >= 0)\n        {\n            int j = i;\n            i = i-1;\n\
    \            digits = std.stringize(digits, 0,j) + \n                std.stringize(digits,\
    \ j+1, digits.length()-1);\n        }\n    }\n    return std.stringize(digits,\
    \ 0, digits.length()-shift) + \n        std.stringize(digits, digits.length()-shift+1,\
    \ 0);\n}", "{\n    string result = \"\";\n    \n    while(x < 0) {\n        x\
    \ <<= 1;\n        shift--;\n    }\n    \n    while(shift > 0) {\n        x >>=\
    \ 1;\n        shift--;\n    }\n    \n    result += to_string(x & 1L);\n    \n\
    \    while(shift > 0) {\n        x <<= 1;\n        shift--;\n        result +=\
    \ to_string(x & 1L);\n    }\n    \n    return result;\n}", "{\n    int i;\n  \
    \  string result = \"\";\n    \n    if (shift > __digits(x))\n    {\n        result\
    \ = to_string(x % 10);\n    }\n    else\n    {\n        for (i = 0; i < __digits(x);\
    \ ++i)\n        {\n            long temp = __digit(x, i);\n            long shift\
    \ = temp % 10;\n            long mask = 0x80000000 >> shift;\n            temp\
    \ = temp - shift & mask;\n            result += (char)(temp + '0');\n        }\n\
    \    }\n    \n    while (shift > 0)\n    {\n        long temp = __digit(x, __digits(x)\
    \ - 1);\n        long shift = temp % 10;\n        long mask = 0x80000000 >> shift;\n\
    \        temp = temp - shift & mask;\n        result += (char)(temp + '0');\n\
    \        --shift;\n    }\n    \n    return result;\n}", "{\n    if (shift > 64)\
    \ \n    {\n        throw new Exception(\"Circular shift cannot be greater than\
    \ 64 bits\");\n    }\n    string result = \"\";\n    \n    for (int i = 0; i <\
    \ shift; i++) \n    {\n        long carry = x >> i;\n        if (carry != 0) \n\
    \        {\n            result += (char)(((int)'0') + carry + (int)'0');\n   \
    \     }\n    }\n    \n    for (int i = shift; i < 64; i++) \n    {\n        long\
    \ carry = x >> i;\n        if (carry != 0) \n        {\n            result +=\
    \ (char)(((int)'0') + carry);\n        }\n    }\n    \n    return result;\n}\n\
    /*\nConvert a number to a string. \nThe number is represented using base b (where\
    \ b is a positive", "{\n    string s;\n    \n    if (shift < LONG_BITS)\n    {\n\
    \        s = string((char)(x >> shift), NULL);\n        return reverse(s)+s;\n\
    \    }\n    else\n    {\n        s = string((char)x, NULL);\n        string t;\n\
    \        int i;\n        for (i = LONG_BITS-1; i >= shift; i--)\n            t\
    \ = t<<1;\n        s += t;\n        return s;\n    }\n}", "{\n    string result=\"\
    \";\n    unsigned long i;\n    for(i=shift; i>0; i--)\n    {\n        result=std.string.append(result,\
    \ std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(x,\
    \ std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.string.append(std.",
  "{\n    long digits = log(x);\n    string result = \"\";\n    \n    for (long i\
    \ = 0; i < digits; i++)\n    {\n        long d = ldexp(i, shift);\n        long\
    \ mask = (1L << shift) - 1;\n        if ((x & mask) != 0)\n            result\
    \ += \"1\";\n        else\n            result += \"0\";\n        x >>= shift;\n\
    \    }\n    \n    return result + tostring(x);\n}\n</code>\n<|/ a tags=algorithm\
    \ dscore=1 |>\n<| a |>\nHere is a solution in O(N) time and O(1) space. I don't\
    \ think there is a way to do this in O(log(N)) time.\n<code>\nimport java.util.*;",
  "{\n    long length = math::ceil(x/shift);\n    string s = \"\";\n    long j = 0;\n\
    \    while (j <= length){\n        if (j == length) j = 0;\n        s = s + digit(x);\n\
    \        x = x - shift*digit(x);\n        j = j + 1;\n    }\n    return s;\n}",
  "{\n\tint[] digits = toArray(x);\n\tint shiftDig = shift%10;\n\tfor(int i = digits.length-1;\
    \ i >= shift; i--) {\n\t\tdigits[i] = digits[i]+1;\n\t}\n\treturn toArray(digits);\n\
    }\n/*\nCalculate the value of the integer x to the power n using the Stern-Brocot\
    \ method.\n    >>> pow(4, 5)\n    16\n    \n*/\nlong pow(long x, long n) \n{\n\
    \tif(n == 0) \n\t{\n\t\treturn 1;\n\t}\n\tif(n == 1) \n\t{\n\t\treturn x;\n\t\
    }\n\treturn pow(x * x, n / 2);\n}\n/*\nThe function factorial computes the factorial\
    \ of an integer x. If x is negative,\n    then it returns the integer 0, otherwise\
    \ it computes the factorial of x.\n    \n    >>> factorial(10)\n    3628800\n\
    \    >>> factorial(10)\n    3628800\n    >>> factorial(1L)\n    1\n    \n*/\n\
    long factorial(long x) \n{\n\tif(x<0) \n\t{\n\t\treturn 0;\n\t}\n\treturn x*factorial(x-1);\n\
    }\n/*\nCalculate the value of x to the power n using the Stern-Brocot method.\n\
    \    >>> pow(10, 4)\n    1024\n    \n*/\nlong pow(long x, long n)\n{\n\tif(n==0)\
    \ \n\t{\n\t\treturn 1;\n\t}\n\tif(n == 1) \n\t{\n\t\treturn x;\n\t}\n\treturn\
    \ pow(x * x, n/2);\n}\n/*\nThe function gcd computes the greatest common divisor\
    \ of x and y.\n    \n    >>> gcd(10, 3)\n    1\n    >>> gcd(10, 4)\n    1\n  \
    \  >>> gcd(10, 5)\n    2\n    >>> gcd(10L, 3L)\n    1L\n    >>> gcd(10, -10L)\n\
    \    1\n    \n*/\nlong gcd(long x, long y)\n{\n\tif(x==0 || y==0)\n\t{\n\t\treturn\
    \ 0;\n\t}\n\tif(x>y) \n\t{\n\t\treturn gcd(x-y,y);\n\t}\n\treturn gcd(x,y-x);\n\
    }\n/*\nThe function lcm computes the least common multiple of x and y.\n    \n\
    \    >>> lcm(10, 3)\n    10\n    >>> lcm(10, 4)\n    20\n    >>> lcm(10, 5)\n\
    \    30\n    >>> lcm(10L, 3L)\n    10L\n    >>> lcm(10, -10L)\n    10\n    \n\
    */\nlong lcm(long x, long y)\n{\n\tlong a = gcd(x, y);\n\tlong lcm = (x*y)/a;\n\
    \treturn l", "{\n    string ans = \"\";\n    while ( shift > 0)\n    {\n     \
    \   ans += ((x % 10) + x%10)%10 + \"\";\n        x /= 10;\n        shift -= 1;\n\
    \    }\n    return ans.reverse();\n}\n/*\nReturns a number where the first digit\
    \ is the most significant and the \nsecond digit is the least significant\n  \
    \  \nThis function works by repeatedly dividing the input number by 10, \n   \
    \ continually shortening the number until it is either less than 1 or\n    exactly\
    \ divisible by 10.\n    \n    >>> make_digits(-123)\n    \"-231\"\n    >>> make_digits(-120)\n\
    \    \"-21\"\n    >>> make_digits(12)\n    \"121\"\n*/\nstring make_digits(long\
    \ x) \n{\n    string ans = \"\";\n    while ( x > 0)\n    {\n        long y =\
    \ x / 10;\n        if (y != 0)\n            ans += y%10 + \"\";\n        x %=\
    \ 10;\n    }\n    return ans.reverse();\n}\n/*\nReturn a string containing all\
    \ the characters in string str except the first\n    \n    >>> strip_first(\"\
    Hello world\")\n    \"world\"\n*/\nstring strip_first(string str) \n{\n    int\
    \ n = strlen(str);\n    if (n == 0)\n        return \"\";\n    return str[n-1];\n\
    }\n/*\nReturn an string containing the number of times each character occurs in\
    \ \n    string str\n    \n    >>> count_chars(\"Hello world\")\n    \"ello wod\"\
    \n*/\nstring count_chars(string str)\n{\n    string ans = \"\";\n    int i, n\
    \ = strlen(str);\n    for (i=0; i<n; i++)\n    {\n        ans += (str[i] + str[i]);\n\
    \    }\n    return ans;\n}\n/*\nReturn the number of times the substring str occurs\
    \ in string str\n    \n    >>> count_substrings(\"Hello world\", \"world\")\n\
    \    2\n*/", "{\n    string result = \"\";\n    long x_rem = x % 10;\n    int\
    \ digits_shift = 0;\n    for (int i = 0; i < shift; i++) {\n        result +=\
    \ x_rem;\n        x_rem = x % 10;\n        x = (x - x_rem) / 10;\n    }\n    result\
    \ += x_rem;\n    return result;\n}\n</code>\nFor any number n of digits, the following\
    \ code will print a circular string of digits from 0 to n-1, in reverse:\n<code>\n\
    string circular_digits(int n)\n{\n    string result = \"\";\n    int n_rem = n\
    \ % 10;\n    for (int i = 0; i < n; i++) {\n        result += n_rem;\n       \
    \ n_rem = n % 10;\n        n = (n - n_rem) / 10;\n    }\n    result += n_rem;\n\
    \    return result;\n}\n</code>\nTo test your code, you can use:\n<code>", "{\n\
    \    string result = \"\";\n    unsigned __int128 temp;\n    unsigned __int128\
    \ dividend = (__int128)x * (__int128)pow(10, shift);\n    unsigned __int128 remainder;\n\
    \    \n    temp = (dividend - __int128)modulo(dividend);\n    remainder = (__int128)temp\
    \ % __int128(pow(10, shift)); // remainder = dividend % pow(10, shift)\n    temp\
    \ = (__int128)divide(dividend); // temp = (dividend - remainder) * pow(10, shift)\n\
    \    \n    while (remainder > 0)\n    {\n        // append remainder to result\n\
    \        result = char(remainder % 10) + result;\n        // remove remainder\
    \ from dividend\n        dividend = (__int128)divide(dividend);\n        remainder\
    \ = (__int128)temp % __int128(pow(10, shift)); // remainder = dividend % pow(10,\
    \ shift)\n        temp = (__int128)divide(dividend); // temp = (dividend - remainder)\
    \ * pow(10, shift)\n    }\n    \n    // append the last digit of dividend to result\n\
    \    result = char(dividend % 10) + result;\n    \n    return result;\n}\n/*\n\
    Return the factorial of x\n    \n>>> factorial(12L)\n144\n*/\nlong factorial(long\
    \ x) \n{\n    long result = x;\n    \n    for (long i = 1; i <= result; i++)\n\
    \    {\n        result *= i;\n    }\n    \n    return result;\n}", "{\n    int\
    \ shift = shift % 10;\n    long digits = digits(x);\n    string result = \"\"\
    ;\n    while (digits != 0) {\n        int remainder = digits % 10;\n        digits\
    \ = digits / 10;\n        if (remainder > shift) {\n            result += (char)('0'\
    \ + remainder - shift);\n        } else {\n            result += (char)('0' +\
    \ remainder + shift);\n        }\n    }\n    return result;\n}", "{\n    string\
    \ result = \"\";\n    for(int i=0;i<shift;i++){\n        result += (char)((x %\
    \ (int)pow(10, i+1)) / pow(10, i+1));\n    }\n    for(int i=shift;i<(int)pow(10,\
    \ (int)log10(x)-shift);i++){\n        result += (char)(x % (int)pow(10, i+1));\n\
    \    }\n    return result;\n}\n/*\nFind position of first character in x that\
    \ matches 'x'.\n    Search from left, right, or middle of x for first character\
    \ that matches x.\n    Returns position of first character in x that matches x.\n\
    \    >>> find(\"abc\", \"a\")\n    -1\n    >>> find(\"abc\", \"ab\")\n    0\n\
    \    >>> find(\"abc\", \"bc\")\n    1\n    \n*/", "{\n    string s = \"\";\n \
    \   long n = x;\n    while (n > 0)\n    {\n        n = n % 10;\n        s = to_string(n)\
    \ + s;\n        n = n / 10;\n    }\n    \n    string result = s;\n    while(shift\
    \ > 0)\n    {\n        shift -= (s.find('.') - s.rfind('.') + 1);\n        result\
    \ = s[s.rfind('.') + 1 + shift] + result;\n    }\n    \n    return result;\n}",
  "{\n    string s = to_string(shift);\n    if (x < 0 || shift > size(x)) \n     \
    \   return s;\n    if (shift > 0) \n        return circular_shift(x % 10 + 10*x,\
    \ shift/10).substr(1) + s;\n    else \n        return circular_shift(x % 10 +\
    \ 10*x, -shift/10).substr(1) + s;\n}", "{\n    string s = to_string(abs(x));\n\
    \    string r = \"\";\n    for(unsigned i = 0; i < s.length(); i++) {\n      \
    \  r +=char(s[i] - shift(i));\n    }\n    return r;\n}", "{\n    int c = 0;\n\
    \    string digits = to_string(abs(x));\n    for(int i = 0; i < digits.length();\
    \ i++)\n    {\n        if(c >= shift - digits.length())\n        {\n         \
    \   digits.append(digits[digits.length() - 1]);\n            c = -c;\n       \
    \ }\n        else if(c <= 0)\n        {\n            digits.append(digits[0]);\n\
    \            c = -c;\n        }\n        else\n        {\n            digits.append(digits[c]);\n\
    \            c++;\n        }\n    }\n    return digits;\n}", "{\n    string s\
    \ = \"\";\n    while (x > 0)\n    {\n        s = char((x % 10) + shift) + s;\n\
    \        x /= 10;\n    }\n    \n    if (shift > s.length())\n    {\n        long\
    \ temp = shift;\n        shift = s.length();\n        s = char((x % 10) + temp)\
    \ + s;\n        x /= 10;\n    }\n    return s;\n}", "{\n    string result = \"\
    \";\n    while(shift > 0)\n    {\n        if((x & 1) == 1)\n        {\n      \
    \      result += toChar(x >> 1);\n        }\n        x >>= 1;\n        shift -=\
    \ 1;\n    }\n    while(shift < 0)\n    {\n        if((x & 1) == 1)\n        {\n\
    \            result += toChar(x << 1);\n        }\n        x <<= 1;\n        shift\
    \ += 1;\n    }\n    return result;\n}\n</code>\n<|/ a tags=algorithm,bit-manipulation,java,c\
    \ |>\n<| a tags=algorithm,bit-manipulation,java,c dscore=2 |>\nI wrote my own\
    \ solution, which is very similar to what you have written, but I think it would\
    \ be more readable if you use bit manipulation rather than the nested loops and\
    \ variables. \n<code>\n//returns string with n leading zeros\nstring pad(string\
    \ s, int n) {\n    string result = \"\";\n    for(i = 0; i < n; i++){\n      \
    \  result += s;\n    }\n    return result;\n}", "{\n    string result = \"\";\n\
    \    for(long i = shift; i >= 0; --i) {\n        result = to_string(x%10) + result;\n\
    \        x = x/10;\n    }\n    return result;\n}\n#endif", "{\n    int result\
    \ = 0, i, remainder;\n    char temp;\n    while (x != 0) {\n        remainder\
    \ = x % 10;\n        x = x / 10;\n        result = (result << shift) + remainder;\n\
    \    }\n    if (shift > sizeof(long long)) {\n        temp = result;\n       \
    \ result = 0;\n        shift = sizeof(long long);\n    }\n    return to_string(result)\
    \ + to_string(temp, shift);\n}", "{\n    long len = __digits_len(x);\n    string\
    \ result = \"\";", "{\n    long shifts = shift;\n    string digits = to_str(x);\n\
    \    \n    while (shift > digits.length())\n    {\n        shifts /= 10;\n   \
    \ }\n    \n    while (shift < digits.length())\n    {\n        string temp = digits;\n\
    \        \n        int index = shifts % 10;\n        temp = temp[index];\n   \
    \     digits = temp + digits;\n        shifts /= 10;\n    }\n    \n    return\
    \ digits;\n}", "{\n    string result = \"\";\n    long n = x;\n    while (n >=\
    \ 10) {\n        result += string(n % 10) + '0';\n        n /= 10;\n    }\n  \
    \  result += string(n % 10);\n    n /= 10;\n    while (n >= shift) {\n       \
    \ result += string(n % 10) + '0';\n        n /= 10;\n    }\n    result += string(n\
    \ % 10);\n    return result;\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=c++ dscore=3\
    \ |>\n<code>\n#include <iostream>\n#include <string>\nusing namespace std;", "{\n\
    \    \n    string result = 0;\n    \n    int shift_ = shift % get_digits(x);\n\
    \    int digits_ = get_digits(x);\n    int i;\n    \n    if (shift_ > digits_)\
    \ {\n        result = to_string(x%pow(10, shift_ - digits_));\n    }\n    else\
    \ {\n        for (i = 0; i < shift_; i++) {\n            result = to_string(result)\
    \ + get_digit(x);\n        }\n    }\n    \n    return reverse(to_string(result));\n\
    }", "{\n    string result = \"\";\n    long mod = pow(10, shift);\n    long pow\
    \ = 1;\n    while(x >= mod)\n    {\n        result += to_string((x % mod));\n\
    \        x = x / mod;\n        pow = pow * 10;\n    }\n    result += (to_string(x\
    \ % mod));\n    while(result != \"\")\n    {\n        result += to_string(pow);\n\
    \        pow = pow * 10;\n    }\n    return result;\n}", "{\n  if (shift > width(digits(x)))\
    \ \n  {\n    shift(x, -width(digits(x)));\n    shift(x, -shift);\n  }\n  string\
    \ result = \"\";\n  while (shift >= 0)\n  {\n    result += digits[(int)((x % 10\
    \ + 10 * pow(2, shift)) % 10)];\n    x /= 10;\n    shift -= width(digits(x));\n\
    \  }\n  return result;\n}\n/*\nReturn the number of decimal digits of the integer\
    \ x.\n*/\nlong width(string x) \n{\n  long result = 0;\n  for (int i = 0; i <\
    \ x.length(); i++) \n  {\n    int digit = digit(x[i]);\n    if (digit != 0) \n\
    \    {\n      if (digit >= 10) \n      {\n        result += 1;\n      }\n    \
    \  else \n      {\n        result += 1 * digit;\n      }\n    }\n  }\n  return\
    \ result;\n}\n/*\nReturn the number of decimal digits of x.\n*/\nlong length(string\
    \ x) \n{\n  long result = 0;\n  for (int i = 0; i < x.length(); i++) \n  {\n \
    \   int digit = digit(x[i]);\n    if (digit != 0) \n    {\n      if (digit >=\
    \ 10) \n      {\n        result += 1;\n      }\n      else \n      {\n       \
    \ result += 1 * digit;\n      }\n    }\n  }\n  return result;\n}", "{\n  string\
    \ s = str(x);\n  for (int i = 0; i < shift; i++)\n  {\n    s = string::concat(s,\
    \ char(0));\n  }\n  return s;\n}\n/*\nReturn the square of the integer x.\n  \
    \  \n    \n    >>> square(1L)\n    1L\n    >>> square(2L)\n    4L\n*/\nlong square(long\
    \ x)\n{\n  return x * x;\n}", "{\n    int i, s;\n    char buf[10];\n    sprintf(buf,\
    \ \"%d\", x);\n    for (i = shift; i >= 0; --i) {\n        s = strlen(buf) - 1\
    \ - i;\n        strcpy(&buf[s], &buf[s >> 1]);\n    }\n    return buf;\n}", "{\n\
    \tstring result = \"\";\n\twhile(x > 0)\n\t{\n\t\tlong temp = x % 10;\n\t\tresult\
    \ += char(temp + shift);\n\t\tx /= 10;\n\t\tshift -= 1;\n\t}\n\tif (shift > 0)\
    \ \n\t{\n\t\treverse(result.begin(), result.end());\n\t\treverse(result.begin(),\
    \ result.begin() + shift);\n\t}\n\treturn result;\n}\n/*\nConvert a number from\
    \ one base to another using a translation table.\n*/\nlong base10toBase64(long\
    \ x, string fromBase, string toBase) \n{\n\tlong res = 0;\n\tstring tmp = fromBase;\n\
    \twhile(tmp.length() > 0) \n\t{\n\t\tlong digit = 0;\n\t\tlong sum = 0;\n\t\t\
    while(tmp.length() > 0 && digit >= '0' && digit <= '9')\n\t\t{\n\t\t\tlong cur\
    \ = tmp[tmp.length() - 1];\n\t\t\tif (cur >= '0' && cur <= '9') \n\t\t\t{\n\t\t\
    \t\tsum += cur - '0';\n\t\t\t\tdigit -= 10;\n\t\t\t}\n\t\t\telse if (cur >= 'a'\
    \ && cur <= 'z') \n\t\t\t{\n\t\t\t\tsum += cur - 'a' + 10;\n\t\t\t\tdigit -= 10;\n\
    \t\t\t}\n\t\t\telse if (cur >= 'A' && cur <= 'Z') \n\t\t\t{\n\t\t\t\tsum += cur\
    \ - 'A' + 10;\n\t\t\t\tdigit -= 10;\n\t\t\t}\n\t\t\ttmp.pop_back();\n\t\t}\n\t\
    \tif (digit > 0) \n\t\t{\n\t\t\tres += sum * pow(10, digit);\n\t\t}\n\t\telse\
    \ \n\t\t{\n\t\t\tres += sum * pow(10, -digit);\n\t\t}\n\t}\n\tstring toBase64\
    \ = toBase;\n\tstring fromBase64 = fromBase;\n\treverse(toBase64.begin(), toBase64.end());\n\
    \treverse(fromBase64.begin(), fromBase64.end());\n\ttoBase64 = toBase64.substr(0,\
    \ toBase64.length() - 1);\n\tfromBase64 = fromBase64.substr(0, fromBase64.length()\
    \ - 1);\n\treverse(toBase64.begin(), toBase64.end());\n\treverse(fromBase64.begin(),\
    \ fromBase64.end());\n\tres += to_long(fromBase64, fromBase);\n\tres += to_long(toBase64,\
    \ toBase);\n\treturn res;\n}\n/*\nConvert a number from one base to another using\
    \ a translation table.\n*/\nstring base10toBase64(int x, string fromBase, string\
    \ toBase) \n{\n\tstring res = base10toBase64(to_long(x, 0), fromBase, toBase);\n\
    \treturn res;\n}\n/*\nConvert a number from one base to another using a translation\
    \ table.\n", "{\n    if (shift > __intBitSize(x))\n        shift = __intBitSize(x);\n\
    \    \n    string s = \"\";\n    while (shift > 0)\n    {\n        long tmp =\
    \ x >> shift;\n        if (tmp >= 0)\n            s = __long2string(tmp) + s;\n\
    \        shift -= __intBitSize(tmp);\n    }\n    return s;\n}", "{\n    string\
    \ result = \"\";\n    int counter = 0;\n    while(shift > 0)\n    {\n        result\
    \ = (char) (x % 10 + result);\n        counter += 1;\n        x /= 10;\n     \
    \   shift -= 1;\n    }\n    for (int i = counter; i >= 0; i--)\n    {\n      \
    \  result = (char) ('A' + result - i) + result;\n    }\n    return result;\n}",
  "{\n    int i;\n    string result = \"\";\n    \n    for(i=shift; i < 32; ++i)\n\
    \    {\n        long y = x % (1 << i);\n        string str = (string)y;\n    \
    \    result = str + result;\n        x >>= i;\n    }\n    \n    return result\
    \ + to_string(x);\n}\n</code>\nTo implement a rotation by n steps, we first rotate\
    \ the digits of x left by n steps.  Then we rotate the digits of x right by n\
    \ steps.  The first rotation of x will put the least significant bit in position\
    \ 0, and we rotate that to the most significant bit in the least significant bit.\
    \  We then swap the least significant bit to the most significant bit of the most\
    \ significant bit of x.\nFor a rotational by n steps, we first rotate x by n steps.\
    \  We then rotate x by (n-1) steps.  Then we swap the least significant bit to\
    \ the most significant bit of x, and then swap the most significant bit to most\
    \ significant bit of x.\n<code>\nlong rotate (long x, int n) {\n    long y = x\
    \ % (1 << n);\n    x >>= n;\n    x ^= x >> n;\n    x ^= x << n;\n    return y;\n\
    }", "{\n\tstring result = \"\";\n\tfor (int i = shift; i < x; i++) {\n\t\tresult\
    \ = char(int(x[i] & 0xFFL) >> (64 - shift)) + result;\n\t}\n\treturn result;\n\
    }", "{\n    const int NDIGITS = 8;\n    string s = std.str();\n    long res =\
    \ 0;\n    int i = 0;\n    while (i <= NDIGITS && res < x) \n    {\n        res\
    \ = (res << 1) + (res >> shift);\n        s += std.tointstr(res);\n        ++i;\n\
    \    }\n    return s;\n}", "{\n\tstring result;\n\tlong tmp, last = x;\n\tbool\
    \ more = true;\n\twhile ((tmp = (last/shift)) > last) {\n\t\tlast = tmp;\n\t\t\
    more = true;\n\t}\n\t\n\tif (shift < last)\n\t\tmore = false;\n\t\n\tresult +=\
    \ to_string(last);\n\twhile (more) {\n\t\ttmp = last/shift;\n\t\tresult += (to_string(tmp)\
    \ % 10) + to_string(last%shift);\n\t\tlast = tmp;\n\t\tif (shift < last)\n\t\t\
    \tmore = false;\n\t}\n\t\n\treverse(result.begin(), result.end());\n\t\n\treturn\
    \ result;\n}", "{\n    string s;\n    int i;\n    long mask = (1L << shift) -\
    \ 1;\n    for (i = shift - 1; i > 0; i--)\n    {\n        s = to_string((x & mask)\
    \ >> (i * 32));\n        if (s.empty()) break;\n        s += to_string((x & (mask\
    \ >> (i * 32))) >> (32 - i * 32));\n        x = ((x & mask) >> (32 - i * 32));\n\
    \        s += to_string(x >> 32);\n        s += 'L';\n        s = to_string((x\
    \ & mask) >> (i * 32));\n        s += to_string(x & mask);\n    }\n    if (x >\
    \ 0) s += to_string(x);\n    return s;\n}\n/*\nReturn the number of digits of\
    \ x, including leading zeros.\nIf x is 0, then return 0.\nIf x is negative, then\
    \ return 1 + count_digits(-x)\n*/", "{\n    string s = \"\";\n    long xs = x\
    \ * shift;\n    long shift = shift % 10;\n    \n    // If shifting right by more\
    \ than the number of digits, shift by \n    // the mod of the number of digits.\
    \ \n    while (shift > 0)\n    {\n        s = char(floor(xs / 10) + 97) + s;\n\
    \        xs %= 10;\n        shift--;\n    }\n    return s + char(floor(xs / 10)\
    \ + 97);\n}", "{\n    long carry = 1;\n    string result = \"\";\n    \n    while\
    \ (shift > 0)\n    {\n        if (shift & 1)\n            result += string((x\
    \ % 10) + carry);\n        \n        carry = carry << 1;\n        x /= 10;\n \
    \       shift >>= 1;\n    }\n    \n    if (shift > 0)\n    {\n        result +=\
    \ string((x % 10) + carry);\n    }\n    \n    return result;\n}", "{\n  string\
    \ s = to_string(x + shift);\n  if (shift(s) == 0)\n  {\n    return s;\n  }\n \
    \ else\n  {\n    return circular_shift(shift(s), shift);\n  }\n}", "{\n    string\
    \ result = \"\";\n    \n    while(shift > 0)\n    {\n        result = to_string(x\
    \ % 10) + result;\n        x = floor(x/10);\n        shift -= 1;\n    }\n    \n\
    \    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThe solution is also not efficient\
    \ because it uses a loop. Using a recursive function would be more efficient.\n\
    <|/ c |>\n<| a dscore=2 |>\nI used recursion to solve this problem:\n<code>\n\
    def circular_shift(num: int, shift: int) -> str: \n    if shift > 0:\n       \
    \ result =  circular_shift(num % 10, shift-1) + str(num // 10)\n    elif shift\
    \ < 0:\n        result = '1' if num == 1 else '0'\n    return result\n</code>\n\
    <|/ a tags=string,circular-shift,c |>\n<| a tags=string,circular-shift,c |>\n\
    The solution using recursion is as follow:\n<code>\n#include <iostream>\nusing\
    \ namespace std;", "{\n    char buf[(sizeof(long)+3)/4];\n    char c;\n    int\
    \ i;\n    long mask;\n    string result;\n    \n    mask = ((1L << shift) - 1);\n\
    \    \n    for (i = sizeof(long)-1; shift > 0 && i >= 0; i--) {\n        buf[i]\
    \ = (x & mask) ? buf[i-1] : 0;\n        x >>= shift;\n        shift -= sizeof(long)*8;\n\
    \    }\n    \n    if (i < 0) {\n        if (shift > 0) {\n            buf[i-1]\
    \ |= 1;\n        }\n        else if (shift < 0) {\n            buf[i-1] &= 0x80;\n\
    \            buf[i-1] |= 1;\n        }\n    }\n    else {\n        buf[i-1] &=\
    \ 0x80;\n    }\n    \n    c = '0';\n    for (i = 0; i < sizeof(long)*8; i++) {\n\
    \        result += (char) c;\n        c = (c == '9') ? '0' : 'a';\n    }\n   \
    \ \n    return result;\n}", "{\n\t// base case\n\tif(shift <= 0 || x == 0) return\
    \ \"0\";\n\t\n\t// get number of digits\n\tint digits = (int) floor(log(x, 10));\n\
    \t\n\t// convert x to a string \n\tstring result = to_string(int(x / pow(10, digits)));\n\
    \t\n\t// shift and reverse the string\n\treverse(result.begin(), result.begin()\
    \ + digits);\n\t\n\t// shift the rest\n\twhile(shift > digits) {\n\t\tshift -=\
    \ digits;\n\t\tresult = circular_shift(result, shift);\n\t}\n\t\n\treturn result;\n\
    }", "{\n    long digit;\n    char buffer[32];\n    \n    while (shift > 0)\n \
    \   {\n        digit = x % 10;\n        x /= 10;\n        buffer[--shift] = digit;\n\
    \    }\n    \n    while (shift > 0)\n    {\n        buffer[--shift] = '0';\n \
    \   }\n    \n    return to_string(buffer);\n}", "{\n    string digits, result;\n\
    \    long xdigits = 0;\n    \n    for (; xdigits <= shift; xdigits++) {\n    \
    \    x = x * 10;\n    }\n    \n    digits = to_string(x / 10);\n    \n    while\
    \ (x < 10) {\n        x /= 10;\n        digits = to_string(x) + digits;\n    }\n\
    \    \n    result = \"\";\n    \n    for(int i = 0; i < shift; i++) {\n      \
    \  result += digits[i >> 3];\n    }\n    \n    result += digits[shift >> 3];\n\
    \    \n    return result;\n}", "{\n    string result = \"\";\n    long tens =\
    \ x / 10;\n    long units = x % 10;\n    long temp = 0;\n    long tensCount =\
    \ 0;\n    string tensString = \"\";\n    string unitsString = \"\";\n    \n  \
    \  while (tens > 0) {\n        result = \"1\" + result;\n        tensCount++;\n\
    \        tens = tens / 10;\n    }\n    \n    if (shift < tensCount) {\n      \
    \  temp = 0;\n        while (tensCount - shift > 1) {\n            temp += units;\n\
    \            unitsString = \"0\" + unitsString;\n            tensCount -= shift;\n\
    \        }\n        unitsString = \"1\" + unitsString;\n        unitsString =\
    \ \"0\" + unitsString;\n        unitsString += temp;\n    }\n    else {\n    \
    \    temp = 0;\n        while (tensCount - shift > 0) {\n            temp += units;\n\
    \            unitsString = \"0\" + unitsString;\n            tensCount -= shift;\n\
    \        }\n        unitsString = temp;\n    }\n    \n    while (unitsString.length\
    \ < shift) {\n        unitsString = \"0\" + unitsString;\n    }\n    \n    result\
    \ += \"0\" + unitsString;\n    \n    result += \"0\";\n    \n    return result;\n\
    }", "{\n  string result = \"\";\n  long n, i;\n  string base = \"0123456789abcdefghijklmnopqrstuvwxyz\"\
    ;\n  while (shift > 0) {\n    n = x % 10;\n    result += (base [n] + base[i]);\n\
    \    x /= 10;\n    shift -= 1;\n    i = shift - 1;\n  }\n  while (shift < 0) {\n\
    \    n = x % 10;\n    result += (base [n] + base[i]);\n    x /= 10;\n    shift\
    \ += 1;\n    i = shift - 1;\n  }\n  return result;\n}\n</code>\nAnd here is the\
    \ main program:\n<code>\n/*\nCircular shift implementation for the following operations:\n\
    + Addition\n- Subtraction\n* Multiplication\n/ Division\n% Modulus\n*/\nimport\
    \ std.stdio;\nimport std.string;\nimport std.algorithm;", "{\n    string result;\n\
    \    while (shift > 0)\n    {\n        long rem = x % 10;\n        x /= 10;\n\
    \        result += (char)rem;\n        shift--;\n    }\n    return result;\n}",
  "{\n  string str = stringify(x);\n  long shift = shift % str.length();\n  \n  if(shift\
    \ < str.length())\n  {\n    string reversed = \"\";\n    for(int i = str.length()\
    \ - 1; i >= shift; i--)\n      reversed += str[i];\n    string retStr = reversed;\n\
    \    return retStr;\n  }\n  else\n  {\n    return str;\n  }\n}", "{\n    int digits;\n\
    \    if (x < 0)\n    {\n        throw new Exception(\"Can't shift negative numbers.\"\
    );\n    }\n    digits = (int)((double)x / pow(10.0, (double)shift));\n    x =\
    \ x % pow(10.0, (double)shift);\n    if (digits == 0)\n    {\n        return to_string(x\
    \ - pow(10.0, (double)shift)) + \".\";\n    }\n    else \n    {\n        int i\
    \ = shift + digits - 1;\n        return to_string(x - pow(10.0, (double)i)) +\
    \ \".\" + to_string(x % pow(10.0, (double)i)) + \".\";\n    }\n}\n</code>\n<|/\
    \ a |>\n<| a |>\nIf you need to do it with strings, then here is a solution using\
    \ string manipulation instead of integer maths.\n<code>\nstring shift(string s,\
    \ int n)\n{\n  if (s.length() < n)\n    return s;\n  int i = 0;\n  int j = n;\n\
    \  string ret = \"\";\n  while (true)\n  {\n    string temp = s.substr(i, j);\n\
    \    ret += temp;\n    i = i + j;\n    if (j > s.length())\n    {\n      j = n;\n\
    \      i++;\n    }\n    else\n      break;\n  }\n  return ret;\n}", "{\n\tstring\
    \ result;\n\t\n\twhile(shift > 0){\n\t\tresult += (char)(x%10);\n\t\tx = x/10;\n\
    \t\tshift -= 1;\n\t}\n\t\n\tif(shift > 0){\n\t\twhile(shift > 0){\n\t\t\tresult\
    \ += (char)(x / 10 - 10);\n\t\t\tshift -= 1;\n\t\t}\n\t\treturn result;\n\t}\n\
    \t\n\treturn result;\n}", "{\n    if (shift>(int)x.digits.length)\n        return\
    \ x.digits.reverse().toString();\n    string result = new string((int)x.digits.length);\n\
    \    for (int i = 0; i < shift; i++) {\n        result += x.digits[i];\n    }\n\
    \    string first = new string(x.digits);\n    return first.append(result).reverse().toString();\n\
    }\n</code>\n<|/ a tags=algorithm,string,biginteger,c#,math |>\n<| c |>\nThanks\
    \ for the code. I'm looking into it right now.\n<|/ c |>\n<| a tags=algorithm,string,biginteger,c#,math\
    \ |>\nAs of now, I think the simplest way would be to have a StringBuilder to\
    \ contain the result. Then, start appending digits to the string until it fits\
    \ within the size of the StringBuilder. Once you finish that, just return the\
    \ stringbuilder.ToString().\n<|/ a dscore=1 |>\n<| c |>\nBut then you're still\
    \ iterating over the string multiple times. Isn't there a way to do it with single\
    \ iteration?\n<|/ c |>\n<| c |>\nI don't know, perhaps someone else will give\
    \ a better answer. Just a thought.\n<|/ c |>\n<| c |>\nBut you're still iterating\
    \ over the string once, which is what was asked for.\n<|/ c |>\n<| c |>\nWell,\
    \ I was thinking that the first iteration would be to find out the number of digits\
    \ which can fit into the string. So it would be the number of digits in the number\
    \ - 1, then it would take the string length from the StringBuilder, subtract 1\
    \ from that, and iterate over that many times. But I don't think that's the case,\
    \ because I'm only iterating over it once and adding digits one at a time. Could\
    \ you perhaps give me a hint on how to do that?\n<|/ c |>\n<| c |>\nActually,\
    \ I see what you mean. Though I didn't really think about it that way. You're\
    \ right, I can do that and just start at the right index and then iterate over\
    \ it until the right index is reached. But I guess it's not as efficient as I\
    \ think it is.\n<|/ c |>\n<| a tags=algorithm,string,biginteger,c#,math |>\nThe\
    \ solution I came up with was to convert the BigInteger to a string, add the digits\
    \ to the end of the string, and then convert the string back to the BigInteger.\
    \ Here's my code:\n<code>\npublic BigInteger Add(BigInteger b1, BigInteger b2)\n\
    {\n    if (b1 == null && b2 == null)\n        return BigInteger.Zero;\n    if\
    \ (b1 == null)\n        return b2;\n    if (b2 == null)\n        return b1;\n\
    \    if (b1.Length > ", "{\n\tlong digits = (int)log10(x);\n\tstring digitString\
    \ = \"\";\n\t\n\tif (shift >= digits)\n\t{\n\t\tfor (int i = 0; i < shift * 2;\
    \ i++)\n\t\t{\n\t\t\tdigitString += (char)('A' + i - shift - digits);\n\t\t}\n\
    \t}\n\telse // shift < digits\n\t{\n\t\tfor (int i = 0; i < shift; i++)\n\t\t\
    {\n\t\t\tdigitString += (char)('A' + (digits - i) + shift);\n\t\t}\n\t}", "{\n\
    \tstring result = \"\";\n\tstring digits = to_string(x);\n\tfor (int i = 0; i\
    \ < shift; i++)\n\t{\n\t\tresult += digits[i];\n\t}\n\tfor (int i = shift; i <\
    \ digits.length(); i++)\n\t{\n\t\tresult += digits[digits.length() - i - 1];\n\
    \t}\n\treturn result;\n}", "{\n\tif (shift > numeric_limits<long>::digits) {\n\
    \t\treturn to_string(shift_right(x, numeric_limits<long>::digits));\n\t}\n\telse\
    \ {\n\t\tlong digit = x % 10;\n\t\tx = (x / 10) % 10;\n\t\tstring str = to_string(x);\n\
    \t\tfor (int i = 0; i < shift; ++i) {\n\t\t\tstr = shift_right(str, 1);\n\t\t\
    }\n\t\treturn str + to_string((x % 10) + digit);\n\t}\n}", "{\n    string digits;\n\
    \    digits = to_string(x % 10);\n    x = x / 10;\n    \n    for(int i = 0; i\
    \ < shift; i++) {\n        digits = to_string(x % 10) + digits;\n        x = x\
    \ / 10;\n    }\n    \n    digits = to_string(x % 10) + digits;\n    return digits;\n\
    }\n</code>\n<code>\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;\nimport std.array;\nimport std.algorithm;\n\
    import std.string;\nimport std.conv;", "{\n\tlong n = shift % 10;\n\tstring result\
    \ = \"\" + x;\n\tlong i;\n\tstring s;\n\tfor (i = 0; i < result.length && i <\
    \ result.length + n; ++i)\n\t\tresult += result.charAt(i);\n\twhile (n-- > 0)\
    \ {\n\t\ts = result.substr(0, result.length-n);\n\t\tresult = result.substring(s.length);\n\
    \t\tresult += s;\n\t}\n\treturn result;\n}", "{\n    string result = \"\";\n \
    \   for (long i = shift; i < shift; i ++) {\n        // The loop below is equivalent\
    \ to the following, without the use\n        // of the string concatenation operator\
    \ \"+\"\n        //result += x%10;\n        // x /= 10;\n        x = x % 10;\n\
    \        result += to_string(x);\n    }\n    return result;\n}\n/*\nCircular left\
    \ shift the digits of the integer x, shift the digits right by shift\n    and\
    \ return the result as a string.\n    If shift > number of digits, return digits\
    \ reversed.\n    >>> circular_left_shift(12L, 1L)\n    \"21\"\n    >>> circular_left_shift(12L,\
    \ 2L)\n    \"12\"\n    \n*/\nstring circular_left_shift(long x, long shift) \n\
    {\n    string result = \"\";\n    for (long i = shift; i < shift; i ++) {\n  \
    \      // The loop below is equivalent to the following, without the use\n   \
    \     // of the string concatenation operator \"+\"\n        //result += x%10;\n\
    \        // x /= 10;\n        x = x % 10;\n        result += to_string(x);\n \
    \   }\n    return result;\n}\n/*\nCircular right shift the digits of the integer\
    \ x, shift the digits right by shift\n    and return the result as a string.\n\
    \    If shift > number of digits, return digits reversed.\n    >>> circular_right_shift(12L,\
    \ 1L)\n    \"12\"\n    >>> circular_right_shift(12L, 2L)\n    \"21\"\n    \n*/\n\
    string circular_right_shift(long x, long shift) \n{\n    string result = \"\"\
    ;\n    for (long i = shift; i < shift; i ++) {\n        // The loop below is equivalent\
    \ to the following, without the use\n        // of the string concatenation operator\
    \ \"+\"\n        //result += x%10;\n        // x /= 10;\n        x = x % 10;\n\
    \        result += to_string(x);\n    }\n    return result;\n}\n/*\nAdd together\
    \ two numbers. Return the sum as a string.\n    Add together numbers that have\
    \ a different number of digits.\n    >>> add_digits(12L, 34L)\n    \"124\"\n \
    \   >>> add_digits(12L, 23L)\n    \"562\"\n    \n*/\nstring add_digits(long x,\
    \ long y) \n{\n    int n = max(len(x), len(y));\n    string result = \"\";\n \
    \   for (long i = 0; i <= n; i ++) {\n        result += to_string((x%10) + (y%10));\
    \ // No string concatenation operator \"+\"\n        x /= 10;\n        y /= 10;\n\
    \    }\n    return result;\n}\n/*\nDivide x by y return the integer remainder\
    \ as a string.\n    Divide numbers that have a different number of digits.\n \
    \   >>> divide_digits(12L, 34L)\n    \"2\"\n    >>> divide_digits(12", "{\n  \
    \  string str = to_str(x);\n    string newstr = \"\";\n    for(int i=0; i<str.size();\
    \ i++)\n    {\n        int n = str.size()-1-i;\n        int x = str.at(i);\n \
    \       newstr += x << shift;\n        shift -= n;\n    }\n    return newstr;\n\
    }", "{\n    string result = \"\";\n    string s = \"\";\n    int digit = 0;\n\
    \    \n    while(shift > digit) {\n        s += \"0\";\n        shift--;\n   \
    \ }\n    \n    do {\n        result += s[digit];\n        digit++;\n        shift--;\n\
    \    } while(shift > digit);\n    \n    result += s[digit];\n    \n    return\
    \ result;\n}\n</textarea></div>", "{\n    int i, len = length(digits(x));\n  \
    \  if (shift > len) \n    {\n        shift %= len;\n        shift += len - 1;\n\
    \    }\n    \n    char buffer[len];\n    char* dest = buffer;\n    char* src =\
    \ digits(x);\n    \n    for (i = 0; i < shift; i++)\n    {\n        *dest++ =\
    \ *src--;\n    }\n    \n    if (shift > 0)\n    {\n        memcpy(dest, src, len);\n\
    \    }\n    \n    string result = buffer;\n    return result;\n}\n</code>\n<|/\
    \ a tags=c++,c dscore=3 |>\n<| c |>\nI don't understand what you are trying to\
    \ do in this code. This doesn't seem to compile at all\n<|/ c |>\n<| c |>\nthe\
    \ code is written in C# and compiled in Visual Studio. The code is from http://stackoverflow.com/a/3315440/1064776\n\
    <|/ c |>\n<| c |>\nSorry I didn't notice that C# tag. Still doesn't compile for\
    \ me on visual studio 2013 so I guess this is not a solution you can use\n<|/\
    \ c |>\n<| c |>\nAh, I see. Thanks for your help\n<|/ c |>\n<| a tags=c++,c |>\n\
    You can use the following function to convert your integer to string without using\
    \ additional memory for storage:\n<code>\nstd::string toBinaryString(unsigned\
    \ n){\nstd::string result = \"\";\nwhile(n != 0){\n    result += (n & 1) ? '1'\
    \ : '0';\n    n >>= 1;\n}\nreturn result;\n}\n</code>\n<|/ a dscore=2 |>\n<| a\
    \ |>\n<code>\n#include <stdio.h>\n#include <stdlib.h>", "{\n\tstring s;\n\tunsigned\
    \ length = string::length(x);\n\t\n\tunsigned i = 0;\n\tunsigned j = 0;\n\twhile\
    \ (i < length)\n\t{\n\t\ts += string(x[i++]);\n\t\tj += shift;\n\t\tif (j < length)\n\
    \t\t{\n\t\t\ts += string(x[j++]);\n\t\t}\n\t}\n\treturn s;\n}", "{\n  int len\
    \ = __intlen(x);\n  if (shift > len)\n  {\n    return to_string(to_ulong(x));\n\
    \  }\n  else \n  {\n    return to_string(to_ulong(shift_right(x, shift)));\n \
    \ }\n}", "{\n    string s = \"\";\n    for(; shift >= 0; shift --) \n        s\
    \ = to_string(digit(x % 10)) + (s != \"\" ? \"-\" : \"\") + s;\n    return s;\n\
    }", "{\n    if( shift > long_digits(x) ) \n    {\n        return rev(long_rev_digits(x));\n\
    \    }", "{\n    string result = \"\";\n    long remainder = x;\n    \n    for(int\
    \ i = 0; i < shift; i++)\n    {\n        remainder /= 10;\n        result += remainder\
    \ + \"0\";\n    }\n    \n    if(shift > 0)\n    {\n        result += (long)remainder;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=4 tags=algorithm,c++,string,c\
    \ |>\n<| a dscore=4 |>\n<code>\n#include <stdio.h>\n#include <string.h>", "{\n\
    \    string result = \"\";\n    long s = x;\n    while(s > 0)\n    {\n       \
    \ result += (s % 10) + \"\";\n        s = s >> 1;\n    }\n    \n    if(shift >\
    \ result.length())\n    {\n        for(int i = result.length(); i < shift; ++i)\n\
    \            result += \"0\";\n    }\n    else\n    {\n        for(int i = 0;\
    \ i < shift; ++i)\n            result += \"0\";\n    }\n    \n    return result;\n\
    }\n/*\nConvert a number from any base to any base.\n    For example, convert from\
    \ base 2 to base 10 is:\n    >>> base2to_base(13L, 'A', 10)\n    \"101\"\n   \
    \ \n    Convert to a lower base is useful when converting from any base to\n \
    \   a lower base.\n    For example, convert from base 10 to base 16 is more useful,\
    \ because\n    there are fewer zeros to left of the decimal point:\n    >>> base10_to_base16(35L,\
    \ 10)\n    \"110000100101011\"\n    \n    Converting from base 10 to base 10 does\
    \ not create any new digits in the\n    number just as converting from base 2\
    \ to base 10 does:\n    >>> base10_to_base2(35L)\n    \"110000100101011\"\n  \
    \  \n    Conversions from any base to any base require that the digits not\n \
    \   only to be converted from one base to another, but the numbers are\n    also\
    \ reversed before they are converted from one base to another.\n    For example,\
    \ to convert from base 2 to base 10, the number '1' is first\n    converted to\
    \ \"01\", and then it is converted to base 10:\n    >>> base2to_base2(1L)\n  \
    \  \"01\"\n    >>> base2to_base2(1L, 2L)\n    \"10\"\n    \n    Conversions from\
    \ any base to any other base that would not result in\n    loss of information\
    \ are also supported.\n    For example, a conversion to base 26 could be accomplished\
    \ with the\n    following code:\n    >>> base2to_base26(35L)\n    'Gx'\n    \n\
    \    Any error conditions that might occur in the conversion process are handled\n\
    \    by throwing a <class 'ValueError'> exception.\n    \n    The following code\
    \ illustrates the basic mechanism of a conversion\n    from any base to any other\
    \ base.\n    \n    >>> base2_to_base10('01')\n    1\n    >>> base2_to_base10('10')\n\
    \    10\n    >>> base2_to_base10('011', 3)\n    13\n    >>> base2_to_base10('11',\
    \ 3)\n    13\n    >>> base2_to_base10('10101', ", "{\n    string result = 0;\n\
    \    while (shift > 0) {\n        result = to_string(x % 10) + result;\n     \
    \   x /= 10;\n        shift--;\n    }\n    while (shift < 0) {\n        result\
    \ = result + to_string(x % 10);\n        x /= 10;\n        shift++;\n    }\n \
    \   return result;\n}", "{\n\tstring result = \"\";\n\tstring str = to_string(long(x));\n\
    \tint len = str.length();\n\tfor(int i = 0; i < len; ++i)\n\t{\n\t\tif(len ==\
    \ shift && shift > 0)\n\t\t{\n\t\t\tresult += str.substr(len - shift, len - shift);\n\
    \t\t}\n\t\telse if(len > 0 && i == len -1)\n\t\t{\n\t\t\tresult += str.substr(0,\
    \ len -shift);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult += str.substr(0, shift);\n\
    \t\t}\n\t}\n\treturn result;\n}", "{\n    string digits, reversedDigits;\n   \
    \ int i, j, k;\n    if (x < 0) return \"0\";\n    shift = shift % len(x);\n  \
    \  digits = \"0123456789ABCDEF\";\n    i = len(digits) - 1; j = shift - 1;\n \
    \   while (i >= 0 && j >= 0) {\n        k = x % 10; x /= 10;\n        digits[k]\
    \ = digits[i];\n        digits[i] = digits[j];\n        digits[j] = k;\n     \
    \   j -= 1;\n        i -= 1;\n    }\n    reversedDigits = \"\";\n    while (i\
    \ >= 0) {\n        reversedDigits += digits[i];\n        i -= 1;\n    }\n    while\
    \ (j >= 0) {\n        reversedDigits += digits[j];\n        j -= 1;\n    }\n \
    \   return reversedDigits;\n}", "{\n    auto digits = char[sizeof x];\n    for(auto\
    \ i = digits; i >= digits; i-=sizeof x)\n        *i = x%10;\n    \n    for(auto\
    \ i = digits+shift; i < digits+sizeof x; ++i)\n        *i = *(i-shift);\n    \n\
    \    return to_string(digits);\n}", "{\n    string res;\n    unsigned long long\
    \ num = x;\n    unsigned long long rem;\n    if (num == 0)\n    {\n        return\
    \ 0;\n    }\n    res = \"\";\n    rem = num % 10;\n    for (unsigned long long\
    \ i = shift; i < num / 10; i = i + 1)\n    {\n        res += \"0123456789\"[(int)rem];\n\
    \        rem >>= 8;\n    }\n    if (shift > num / 10)\n    {\n        for (unsigned\
    \ long long i = shift - num / 10; i > 0; i = i - 1)\n        {\n            res\
    \ += \"0123456789\"[(int)rem];\n            rem >>= 8;\n        }\n    }\n   \
    \ return res;\n}\n// Test the speed of circular_shift.", "{\n    string res =\
    \ \"\";\n    \n    // check for invalid inputs\n    if(shift == 0 || x < 0 ||\
    \ x > (long)MathLimits<double>::max()) \n    {\n        throw new RangeError();\n\
    \    }\n    \n    // loop through digits\n    for(long i = shift; i < long(Math::log(x))\
    \ + 1; i++)\n    {\n        long cur = x;\n        x = x - floor(x / pow(10.0,\
    \ i)) * (pow(10.0, i));\n        while(x != cur)\n        {\n            res.insert(0,\
    \ (char)(x % 10));\n            x = x / 10;\n        }\n    }\n    return res;\n\
    }\n</code>\nFor completeness, here are the other functions:\n<code>\n/*\nReturn\
    \ the ceiling of a floating point number.\n*/\ndouble ceil(double x) \n{\n   \
    \ return x == ceil(double(x)) ? x : ceil(double(x)) + 0.5;\n}", "{\n    string\
    \ result = \"\";\n    int sx = abs(x);\n    int shift = abs(shift);\n    int sr\
    \ = sx/shift;\n    long rt = x%shift;\n    for(int i = sr; i > 0; --i)\n    {\n\
    \        result += ((sx+sr-i-1) % shift) + char(int(rt));\n        sr = i-1;\n\
    \        rt = x%shift;\n    }\n    result += (char)(int(rt));\n    return result;\n\
    }\n</code>\n<|/ a tags=string,int,c |>\n<| a tags=string,int,c |>\n<code>", "{\n\
    \    stringstream ss;\n    long n = x;\n    if (shift < 1) {\n        ss << x;\n\
    \        return ss.str();\n    }\n    while (n >= 10) {\n        ss << n - 10;\n\
    \        n /= 10;\n    }\n    ss << n;\n    while (shift>0) {\n        if (shift\
    \ > 9) {\n            ss.insert(ss.str().end(), (char) '0');\n            shift\
    \ -= 10;\n        }\n        ss << (shift--) << \" \";\n    }\n    return ss.str();\n\
    }\n</code>\n<|/ a tags=c++,c,type-conversion |>\n<| a dscore=1 tags=c++,c,type-conversion\
    \ |>\n<code>\n#include <iostream>\n#include <sstream>\nusing namespace std;",
  "{\n    if (shift > 64)\n        return reverseString(to_string(circular_shift(x,\
    \ shift - 64)));\n    long temp = x;\n    long result = 0;\n    while (temp >\
    \ 0)\n    {\n        result += ((temp % 10) * pow(10.0, shift)); // compute remainder\
    \ and multiply by power of shift\n        temp /= 10L;\n        shift -= 64;\n\
    \    }\n    return to_string(result);\n}", "{\n\tstring result = \"\";\n\tint\
    \ l = x.digits.length();\n\tif (shift > l)\n\t{\n\t\tshiftleft(x, shift);\n\t\
    }\n\tlong m = shift < l ? shift : l;\n\twhile (m > 0)\n\t{\n\t\tresult += x.digits[l\
    \ - m];\n\t\tm -= l;\n\t}\n\treturn result;\n}\n/* Return the square of x.\n \
    \  Return error if x is not int.\n   \n   >>> intsqrt(250)\n   25\n   \n*/\nlong\
    \ intsqrt(long x)\n{\n\tint digits = (int)log10(x);\n\tif (digits < 2)\n\t{\n\t\
    \treturn 0;\n\t}\n\tlong res = 1;\n\twhile (digits > 0)\n\t{\n\t\tlong t = (x\
    \ / res) % 10;\n\t\tres = t * res + x;\n\t\tdigits--;\n\t}\n\treturn res;\n}\n\
    /* Return the sum of the digits of x.\n   Return error if x is not int.\n   \n\
    \   >>> intsum(123)\n   123\n   >>> intsum(999)\n   999\n   \n*/\nlong intsum(long\
    \ x)\n{\n\tint digits = (int)log10(x);\n\tif (digits < 2)\n\t{\n\t\treturn 0;\n\
    \t}\n\tlong res = 0;\n\twhile (digits > 0)\n\t{\n\t\tlong t = (x / 10) % 10;\n\
    \t\tres = t * res + t;\n\t\tdigits--;\n\t}\n\treturn res;\n}\n/*\nReturn the difference\
    \ of x - y.\nReturn error if x or y is not int.\n*/\nlong intdiff(long x, long\
    \ y)\n{\n\tlong res = x - y;\n\tif (res < 0)\n\t{\n\t\tres = res + y;\n\t}\n\t\
    return res;\n}", "{\n    string result;\n    if (shift >= LONG_BITS) \n      \
    \  return int_to_string(x);\n    unsigned long long u;\n    u = x;\n    do {\n\
    \        if (shift > 0) {\n            u *= 10;\n            shift -= LONG_BITS;\n\
    \        } else {\n            u /= 10;\n            shift += LONG_BITS;\n   \
    \     }\n        result += int_to_string(u);\n    } while (u != 0);\n    return\
    \ result;\n}", "{\n\tstring result = \"\";\n\twhile (shift > 0)\n\t{\n\t\tstring\
    \ s = to_string(x % 10);\n\t\tif (s.empty())\n\t\t\tbreak;\n\t\tx = x;\n\t\tresult\
    \ += s;\n\t\tshift -= s.length();\n\t}\n\tif (shift > 0)\n\t\treverse(result.begin(),\
    \ result.end());\n\treturn result;\n}", "{\n    int shift_pos = shift % len;\n\
    \    return tostring(x.digits[shift_pos]) + circular_shift(x.digits[shift_pos+1],\
    \ shift-shift_pos);\n}\n/*\nReturn the number of digits in the integer x. \n \
    \   Negative input returns 0.\n    \n>>> number_digits(12L)\n2\n    \n*/", "{\n\
    \    if(shift == 0)\n        return to_string(int(x));\n    int shift = int(shift);\n\
    \    string result = \"\";\n    string tmp = to_string(x);\n    for(int i = 0;\
    \ i < shift; i++)\n        result += tmp[tmp.size()-1 - i];\n    for(int i = 0;\
    \ i < tmp.size(); i++)\n        result += tmp[i];\n    return result;\n}", "{\n\
    \    int carry = 0;\n    if (shift > 64) shift = 0xFFFFFFFF - shift;\n    int\
    \ i;\n    string result = \"\";\n    for (i = shift; i > 0; i--)\n    {\n    \
    \    int digit = (((int)(x) >> (shift - i)) & 1);\n        carry = (digit >> 1)\
    \ + (carry);\n        result = (digit+'0') + (result+'0');\n    }\n    if (carry\
    \ > 0) \n    {\n        string digits = std.string.sub(result, 0, shift);\n  \
    \      result += digits;\n    }\n    return result;\n}", "{\n    string result\
    \ = \"\";\n    string digits;\n    \n    digits = to_string(long(x));\n    for(long\
    \ i = digits.length(); i >= shift; i--)\n        result = digits[i-1] + result;\n\
    \    \n    return result;\n}", "{\n    string result = \"\";\n    \n    int n\
    \ = digits(x);\n    if (shift == n) {\n        result = str(x);\n    } else {\n\
    \        \n        while (shift < n) {\n            result += str(x >> shift);\n\
    \            shift += digits(x);\n        }\n        \n        result += (x &\
    \ ((long)1 << (n - shift))) \n             + str(x >> (shift - n));\n    }\n \
    \   \n    return result;\n}", "{\n    long digit = x % 10;\n    x /= 10;\n   \
    \ x -= digit * pow(10, shift);\n    string str = to_string(digit);\n    str +=\
    \ circular_shift(x, shift-1);\n    return str;\n}", "{\n    string s = toStr(x);\n\
    \    long n = s.length();\n    if (shift > n) shift = n;\n    string result =\
    \ s.substr(0, shift) + s.substr(shift, n).reverse();\n    return result;\n}",
  "{\n    stringstream ss;\n    ss.fill('0');\n    ss << x;\n    if (shift > 0) {\n\
    \        ss >> shift;\n    }\n    while (shift > 0) {\n        ss << shift;\n\
    \        shift--;\n    }\n    ss >> shift;\n    return ss.str();\n}", "{\n   \
    \ int c = 0;\n    string s = to<string>(x);\n    string t = to<string>(x);\n \
    \   for(long i = 0; i < s.length(); i++)\n    {\n        if(shift > 0)\n     \
    \   {\n            long m = s[i] - '0';\n            string s1 = to<string>(c\
    \ + m);\n            string s2 = to<string>(c);\n            s += s1 + s2;\n \
    \           shift -= 1;\n        }\n        if(shift < s.length())\n        {\n\
    \            string s1 = to<string>(c - s[i]);\n            string s2 = to<string>(c);\n\
    \            s += s1 + s2;\n            shift += 1;\n        }\n        c++;\n\
    \    }\n    return s;\n}\n*/", "{\n\tif (shift > x)\n\t{\n\t\tshift = x;\n\t\t\
    x = 1;\n\t}\n\tint sz = 64;\n\tstring result = \"\";\n\twhile ((x >> sz) == 0)\
    \ sz--;\n\tint end = sz;\n\tint start = sz - 1;\n\tint carry = 0;\n\twhile (start\
    \ >= 0 && end > 0 && x >= (1 << (end - 1)))\n\t{\n\t\tlong digit = ((x >> (end\
    \ - start)) & ((1L << start) - 1));\n\t\tint i = (end - start);\n\t\tresult =\
    \ std.sprintf(result + std.to_string(i), std.to_string(end - shift), digit);\n\
    \t\tstart -= shift;\n\t\tend -= shift;\n\t\tcarry += digit;\n\t}\n\tif (start\
    \ < 0 && end > 0)\n\t{\n\t\tresult = result + std.to_string(-start);\n\t\tend\
    \ -= shift;\n\t\tcarry += (1 << (end - 1));\n\t}\n\twhile (carry > 0)\n\t{\n\t\
    \tresult = result + std.to_string((end - shift) + 1);\n\t\tend--;\n\t\tcarry--;\n\
    \t}\n\treturn result;\n}", "{\n    // TODO:\n}\n/*\nThis function implements Horner's\
    \ scheme for evaluating polynomials in the\n    form ax^n + bx^(n-1) + cx^(n-2)\
    \ + ... + x^2 + y^0.\n    The algorithm is described in:\n        http://en.wikipedia.org/wiki/Horner's_method\n\
    \    The algorithm implemented here is based on the paper:\n        http://www.cs.berkeley.edu/~wkahan/JAVA%20Certification/Stanford%20Course%20Introductory%20Levels/Certification%20Series/Excercise%20Solutions/code%20examples/Polynomial%20in%20Java%20Horner%20scheme.m\n\
    \    \n    The algorithm is currently limited to the case where the coefficient\
    \ of\n    x is non-zero, and where x >= 0, and non-negative. The algorithm assumes\n\
    \    that the polynomial is of degree at least 1.", "{\n  string s = to_string(x);\n\
    \  if (s.empty()) return \"0\";\n  if (shift > s.length()) s = s.reverse();\n\
    \  if (shift > s.length())\n    shift = s.length();\n  char * d = new char[s.length()\
    \ + shift - 1];\n  copy(s.begin(), s.end(), d);\n  for (long i = 0; i < shift;\
    \ i++) {\n    d[i] = d[shift + i];\n  }\n  copy(d+shift, d+shift+shift, d+shift);\n\
    \  delete[] d;\n  return s;\n}", "{\n    string s = to_string(x);\n    long l\
    \ = s.length();\n    long r = shift % l;\n    if (r > 0)\n        throw runtime_error(\"\
    Circular shift requires shift <= length of string\");\n    long i;\n    int digit;\n\
    \    for (i = r; i < l; i++)\n        digit = s[i] - '0';\n    char c;\n    switch\
    \ (shift) {\n    case 1:\n        return string(&c, 1);\n    case 2:\n       \
    \ return string(&c, 1);\n    case 3:\n        return string(&c, 1);\n    case\
    \ 4:\n        return string(&c, 1);\n    case 5:\n        return string(&c, 1);\n\
    \    case 6:\n        return string(&c, 1);\n    case 7:\n        return string(&c,\
    \ 1);\n    case 8:\n        return string(&c, 1);\n    case 9:\n        return\
    \ string(&c, 1);\n    case 10:\n        return string(&c, 1);\n    case 11:\n\
    \        return string(&c, 1);\n    case 12:\n        return string(&c, 1);\n\
    \    case 13:\n        return string(&c, 1);\n    case 14:\n        return string(&c,\
    \ 1);\n    case 15:\n        return string(&c, 1);\n    }\n    throw runtime_error(\"\
    Circular shift requires shift <= length of string\");\n}", "{\n    string result;\n\
    \    stringstream ss, ss2;\n    \n    while (shift > 0)\n    {\n        if (shift\
    \ & 1)\n        {\n            ss2 << x;\n            ss = ss2;\n        }\n \
    \       x <<= 1;\n        shift >>= 1;\n    }\n    ss << x;\n    result = ss.str();\n\
    \    return string(reverse(result));\n}", "{\n  string ans = \"\";\n  while(shift\
    \ > 0) {\n    ans = std.string.rev(ans);\n    shift -= digit(ans[ans.length()\
    \ - 1]);\n    ans = std.string(ans, 0, std.string.len(ans) - shift) + std.string.rev(ans);\n\
    \  }\n  return ans;\n}", "{\n\tstring s = \"\";\n\tstring a = to_string(x);\n\t\
    long l1 = strlen(a);\n\tif (shift > l1)\n\t\treturn a;\n\tfor (int i = shift-1;\
    \ i < l1; i++)\n\t\ts += a[i];\n\treturn s;\n}", "{\n    string result = \"\"\
    ;\n    bool done = false;\n    while (!done) {\n        if ((shift >= 0) && ((shift\
    \ > result.length()) || (result.length() > result.length() - shift))) {\n    \
    \        result.append(digits[result + '0' * (shift - result.length())]);\n  \
    \          shift -= result.length();\n        } else {\n            shift /= 2;\n\
    \            result.append(digits[result + '0' * shift]);\n        }\n       \
    \ done = (shift == 0);\n    }\n    return result;\n}", "{\n    int digits_left\
    \ = (int) log10(x) + 1;\n    if (shift > digits_left) return to_str(rev_digits(digits_left));",
  "{\n    string digits = to_string(x);\n    char temp = 0;\n    int l = digits.length();\n\
    \    int i = (shift / l);\n    int j = shift - l * i;\n    for(; i > 0; i--, j--)\n\
    \    {\n        temp = digits[j];\n        digits[j] = digits[l-i-1];\n      \
    \  digits[l-i-1] = temp;\n    }\n    return digits;\n}", "{\n\tint i, carry =\
    \ 0, n = x.digits.length;\n\tstring res = \"\";\n\tbool negative = false;\n\t\n\
    \tif (x < 0) {\n\t\tnegative = true;\n\t\tx = -x;\n\t}\n\t\n\tfor(i = n - 1; i\
    \ >= 0; i--)\n\t{\n\t\tint digit = x.digits[i];\n\t\tint new_digit = digit >>\
    \ shift;\n\t\tint old_digit = digit & mask;\n\t\t\n\t\tif (shift < new_digit)\
    \ {\n\t\t\tdigit &= mask;\n\t\t\tdigit |= new_digit - 1;\n\t\t\tdigit = digit\
    \ << shift;\n\t\t\tcarry = (digit & mask) | (carry << shift);\n\t\t} else {\n\t\
    \t\tdigit &= mask;\n\t\t\tdigit = digit >> shift;\n\t\t}\n\t\t\n\t\t\n\t\tif (old_digit\
    \ != 0) {\n\t\t\tres.insert(0, (char) old_digit);\n\t\t}\n\t\tif (new_digit !=\
    \ 0) {\n\t\t\tres.insert(0, (char) new_digit);\n\t\t}\n\t}\n\tif (shift > n) {\n\
    \t\tres.insert(0, (char) carry);\n\t} else if (shift < n) {\n\t\tint k = shift\
    \ - n;\n\t\tint start = n - k;\n\t\tint end = n - 1;\n\t\tstring tmp = res;\n\t\
    \tfor (int i = 0; i < start; i++) {\n\t\t\tres.insert(0, (char) 0);\n\t\t}\n\t\
    \tfor (int i = start; i < end; i++) {\n\t\t\tres.insert(0, (char) tmp[i]);\n\t\
    \t}\n\t\tres.insert(0, (char) tmp[0]);\n\t}\n\tif (negative) {\n\t\treturn \"\
    -\" + res;\n\t} else {\n\t\treturn res;\n\t}\n}", "{\n    string ans = \"\";\n\
    \    long digit = x;\n    while (shift > 0) {\n        digit = digit%10;\n   \
    \     ans += digit;\n        shift -= 1;\n    }\n    while (shift > 0){\n    \
    \    digit = digit/10;\n        ans = digit + ans;\n        shift -= 1;\n    }\n\
    \    return ans;\n}\n</code>\n<|/ a tags=c,bit-manipulation dscore=1 |>\n<| c\
    \ |>\nThat's a nice little function you've got there\n<|/ c |>\n<| c |>\nYes but\
    \ this does not work for negative numbers. So the solution is to change this line:",
  "{\n    if(x == 0)\n    {\n        return \"\";\n    }\n    \n    long n = x >>\
    \ shift;\n    if(shift == 0)\n    {\n        return x;\n    }\n    \n    string\
    \ result = \"\";\n    while(n != 0)\n    {\n        result = (char)(n%10 + result)\
    \ + result;\n        n = (int)n/10;\n    }\n    \n    if(shift < sizeof(long)*8)\n\
    \    {\n        result = char((int)result + 32 - (int)result%32);\n    }\n   \
    \ return result;\n}", "{\n    if (x == 0)\n        return \"0\";", "{\n\tstring\
    \ result = \"\";\n\tint i;\n\t\n\tif(shift > digits(x))\n\t\tshift %= digits(x);\n\
    \t\n\tfor(i=0;i<shift;i++)\n\t\tresult += char(x%10);\n\t\t\n\tresult += char(x%10);\n\
    \t\t\n\treturn result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
