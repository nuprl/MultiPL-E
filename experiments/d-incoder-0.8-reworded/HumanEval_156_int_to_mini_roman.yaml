name: HumanEval_156_int_to_mini_roman
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
  \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
  \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19L)\n\
  \    \"xix\"\n    >>> int_to_mini_roman(152L)\n    \"clii\"\n    >>> int_to_mini_roman(426L)\n\
  \    \"cdxxvi\"\n    \n*/\nstring int_to_mini_roman(long number) \n"
tests: "unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
  \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
  \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
  \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
  iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) == \"\
  xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L) == \"\
  dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L) ==\
  \ \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
completions: ["{\n    long num = (number%100);\n    long rest = (number%1000L)/100;\n\
    \    string result = \"\";\n    while (rest >= 10) {\n        result += mini_roman[rest%10];\n\
    \        rest = (rest/10L) - (rest%10);\n    }\n    result += mini_roman[rest];\n\
    \    return (result + mini_roman[num]);\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=c++,c-preprocessor,macros,c\
    \ |>\nHere is a solution in C++ that does not require a special tool.\n<code>\n\
    #include <iostream>\n#include <string>", "{\n    string roman = \"\";\n    int\
    \ n = 0;\n    int max_value = long(pow(10.0, 9));\n    while (number >= max_value)\
    \ {\n        roman = roman + romans[n % 10];\n        number /= 10;\n        n\
    \ += 1;\n    }\n    roman = roman + romans[number % 10];\n    return roman;\n}",
  "{\n    static char romans[] = \"MCMXCIV\";\n    string roman_num = \"\";", "{\n\
    \tstring roman = \"\";\n\tstring num_str = to_string(number);\n\t\n\tfor(size_t\
    \ i = 0; i < num_str.size(); ++i)\n\t{\n\t\tif(num_str[i] == '0')\n\t\t\troman\
    \ = \"m\" + roman;\n\t\telse\n\t\t\troman = \"d\" + roman;\n\t}\n\t\n\treturn\
    \ roman;\n}", "{\n    auto ret = \"ERROR\";\n    auto base = [&]() -> int {\n\
    \        static map<int, char> basemap = {\n            { 0, \"I\" }, { 1, \"\
    V\" }, { 2, \"X\" }, { 3, \"L\" },\n            { 4, \"C\" }, { 5, \"D\" }, {\
    \ 6, \"M\" }, { 7, \"N\" },\n            { 8, \"X\" }, { 9, \"C\" }, { 10, \"\
    D\" }, { 11, \"M\" },\n            { 12, \"X\" }, { 13, \"C\" }, { 14, \"D\" },\
    \ { 15, \"M\" },\n            { 16, \"X\" }, { 17, \"C\" }, { 18, \"D\" }, { 19,\
    \ \"M\" },\n            { 20, \"X\" }, { 21, \"C\" }, { 22, \"D\" }, { 23, \"\
    M\" },\n            { 24, \"X\" }, { 25, \"C\" }, { 26, \"D\" }, { 27, \"M\" },\n\
    \            { 28, \"X\" }, { 29, \"C\" }, { 30, \"D\" }, { 31, \"M\" },\n   \
    \         { 32, \"X\" }, { 33, \"C\" }, { 34, \"D\" }, { 35, \"M\" },\n      \
    \      { 36, \"X\" }, { 37, \"C\" }, { 38, \"D\" }, { 39, \"M\" },\n         \
    \   { 40, \"X\" }, { 41, \"C\" }, { 42, \"D\" }, { 43, \"M\" },\n            {\
    \ 44, \"X\" }, { 45, \"C\" }, { 46, \"D\" }, { 47, \"M\" },\n            { 48,\
    \ \"X\" }, { 49, \"C\" }, { 50, \"D\" }, { 51, \"M\" },\n            { 52, \"\
    X\" }, { 53, \"C\" }, { 54, \"D\" }, { 55, \"M\" },\n            { 56, \"X\" },\
    \ { 57, \"C\" }, { 58, \"D\" }, { 59, \"M\" },\n            { 60, \"X\" }, { 61,\
    \ \"C\" }, { 62, \"D\" }, { 63, \"M\" },\n            { 64, \"X\" }, { 65, \"\
    C\" }, { 66, \"D\" }, { 67, \"M\" },\n            { 68, \"X\" }, { 69, \"C\" },\
    \ { 70, \"D\" }, { 71, \"M\" },\n            { 72, \"X\" }, { 73, \"C\" }, { 74,\
    \ \"D\" }, { 75, \"M\" },\n            { 76, \"X\" }, { 77, \"C\" }, { 78, \"\
    D\" }, { 79, \"M\" },\n            { 80, \"X\" }, { 81, \"C\" }, { 82, \"D\" },\
    \ { 83, \"M\" },\n            { 84, \"X\" }, { 85, \"C\" }, { 86, \"D\" }, { 87,\
    \ \"M\" },\n            { 88, \"X", "{\n    string mini_roman = \"\";\n    string\
    \ roman = \"bcdfghjklmnpqrstvwxyz\"; // b to i, c to l, d to n, etc.\n    long\
    \ n = number;\n    string romn_counters = \"\";\n    string mini_romn_counters\
    \ = \"\";\n    string int_to_romn_counters = \"\";\n    string int_to_mini_romn_counters\
    \ = \"\";\n    string int_to_mini_roman = \"\";\n    string int_to_romn = \"\"\
    ;\n    int counter = 0;\n    \n    while(n > 0)\n    {\n        counter++;\n \
    \       romn_counters = roman[n % 10] + \" \" + romn_counters;\n        mini_romn_counters\
    \ = mini_roman[n % 10] + \" \" + mini_romn_counters;\n        int_to_romn_counters\
    \ = roman[n % 10] + \" \" + int_to_romn_counters;\n        int_to_mini_romn_counters\
    \ = mini_roman[n % 10] + \" \" + int_to_mini_romn_counters;\n        int_to_mini_roman\
    \ = mini_roman[n % 10] + \" \" + int_to_mini_roman;\n        int_to_romn = roman[n\
    \ % 10] + \" \" + int_to_romn;\n        n = n / 10;\n    }\n    mini_roman = mini_romn_counters;\n\
    \    mini_roman = int_to_mini_roman;\n    mini_roman = int_to_mini_romn_counters;\n\
    \    mini_roman = int_to_romn;\n    return mini_roman;\n}\n</code>\n<|/ a tags=c++,type-conversion,int,string\
    \ dscore=0 |>\n<| a tags=c++,type-conversion,int,string |>\nThe code in this thread\
    \ is great, but the code can be improved in some places:", "{\n    string roman\
    \ = \"\";\n    long num1 = number;\n    if (num1 < 1)\n        throw \"int_to_roman_numeral:\
    \ number must be positive\";\n    if (num1 > 999)\n        throw \"int_to_roman_numeral:\
    \ number must be < 999\";", "{\n\tint result = 0;\n\tstring output = \"\";\n\t\
    while (number > 0)\n\t{\n\t\tint remainder = (int) (number % 10);\n\t\tnumber\
    \ /= 10;\n\t\tstring currentChar = int_to_roman[remainder];\n\t\tresult += currentChar;\n\
    \t}\n\treturn result;\n}\n/*", "{\n    string mini_roman = \"\";\n    long roman_num\
    \ = 1;\n    int i=1;\n    while (roman_num < number){\n        roman_num = roman_num*10\
    \ + i;\n        i++;\n    }\n    while (i>0){\n        string temp_str = int_to_roman(roman_num);\n\
    \        roman_num = roman_num/10;\n        mini_roman += temp_str;\n        i--;\n\
    \    }\n    return mini_roman;\n}", "{\n    stringstream out;\n    long temp;\n\
    \    out << \".\";\n    while (number > 1000) {\n        temp = number % 1000;\n\
    \        number /= 1000;\n        out << int_to_mini_roman(temp);\n        if\
    \ (number > 1000) {\n            out << int_to_mini_roman(number % 1000) << \"\
    , \" << int_to_mini_roman(number / 1000);\n            number /= 1000;\n     \
    \   }\n        out << temp;\n    }\n    temp = number;\n    if (temp > 0)\n  \
    \      out << int_to_mini_roman(temp);\n    string roman_num = out.str();\n  \
    \  roman_num = string::to_lower(roman_num);\n    return roman_num;\n}", "{\n \
    \   string mini_roman;\n    string roman_to_mini_roman = {\"M\"=>\"m\", \"CM\"\
    =>\"cm\", \"D\"=>\"d\", \"CD\"=>\"dc\", \"C\"=>\"c\", \"XC\"=>\"xc\", \"L\"=>\"\
    l\", \"XL\"=>\"xl\", \"X\"=>\"x\", \"IX\"=>\"ix\", \"V\"=>\"v\", \"IV\"=>\"iv\"\
    , \"I\"=>\"i\"};\n    long tens = number;\n    long ones = number;\n    string\
    \ roman_numeral;\n    bool first_iteration = true;\n    while(tens-- && ones--)\n\
    \    {\n        if (roman_to_mini_roman.find(roman_numeral) != string::npos)\n\
    \        {\n            break;\n        }\n        roman_numeral += (ones--)*(roman_to_mini_roman.size()-1);\n\
    \        if (roman_to_mini_roman.find(roman_numeral) == string::npos)\n      \
    \  {\n            string roman_numeral_temp = roman_to_mini_roman.at(roman_to_mini_roman.size()-1);\n\
    \            roman_to_mini_roman.push_back(roman_numeral_temp);\n        }\n \
    \   }\n    if (roman_numeral.size() == 1)\n    {\n        mini_roman = roman_numeral;\n\
    \    }\n    else\n    {\n        if (ones == 1)\n        {\n            mini_roman\
    \ = roman_to_mini_roman.at(roman_to_mini_roman.size()-1);\n        }\n       \
    \ else\n        {\n            string roman_numeral_temp = roman_to_mini_roman.at(roman_to_mini_roman.size()-1);\n\
    \            roman_to_mini_roman.insert(roman_to_mini_roman.begin(), roman_numeral_temp);\n\
    \            mini_roman = roman_to_mini_roman.at(roman_to_mini_roman.size()-1);\n\
    \        }\n    }\n    if (first_iteration)\n    {\n        mini_roman += (ones--)*(roman_to_mini_roman.size()-1);\n\
    \        string roman_numeral_temp = roman_to_mini_roman.at(roman_to_mini_roman.size()-1);\n\
    \        roman_to_mini_roman.insert(roman_to_mini_roman.begin(), roman_numeral_temp);\n\
    \    }\n    while (roman_to_mini_roman.back() == \"M\")\n    {\n        roman_to_mini_roman.pop_back();\n\
    \    }\n    return mini", "{\n    // write your code in C# here\n    return \"\
    \";\n}\n</code>\n<|/ a |>\n<| c |>\nHi, this is great! Just wanted to point out\
    \ that the `string` type is part of the .Net framework, not the C# standard.\n\
    <|/ c |>\n<| c |>\nThanks for the heads up! I've edited my answer to reflect that.\n\
    <|/ c |>\n<| a tags=.net,c# dscore=5 |>\n<code>\npublic static string IntToRoman(long\
    \ number)\n{\n    string roman = \"????\";\n    while (number > 0)\n    {\n  \
    \      int remainder = number % 10;\n        roman = string.Format(\"{0}{1}\"\
    , roman, Convert.ToString(\"IV\", CultureInfo.InvariantCulture));\n        number\
    \ = number / 10;\n    }\n    return roman;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for this answer, I tried to add this function to my code (without success) and\
    \ I made a mistake - I called it the wrong way (toRoman) instead of IntToRoman...\
    \ thanks!\n<|/ c |>\n<| a tags=.net,c# |>\n<code>\npublic static string NumberToRoman(long\
    \ numberToConvert)\n{\n    string roman = string.Empty;", "{\n    if (number <\
    \ 0)\n        throw new ArgumentException(string.Format(\"{0} is not a positive\
    \ integer\", number));\n    if (number == 0)\n        return string.Empty;\n \
    \   \n    string roman = string.Empty;\n    \n    string digits = romanize.Digits(number);\n\
    \    int maxDigits = digits.Length;\n    string maxRoman = romanize.Digits(number).Max();\n\
    \    int index = maxDigits;\n    \n    while (index > 0)\n    {\n        int digit\
    \ = digits.IndexOf(maxRoman[index - 1]);\n        if (digit >= 0)\n        {\n\
    \            roman += (digits[digit].ToString());\n            \n            index\
    \ -= 1;\n            \n        }\n        else\n            break;\n    }\n  \
    \  \n    if (index < maxDigits)\n        roman += (digits[maxDigits - 1].ToString());\n\
    \    \n    return roman.ToLower();\n}\n</code>\n<|/ a |>\n<| c |>\nThat is very\
    \ cool. I would have thought that doing this kind of thing in .NET would be more\
    \ difficult.\n<|/ c |>\n<| a |>\nBased on Jeff Duncalcal's answer, I decided to\
    \ try an alternative solution that doesn't require the use of LINQ and was quite\
    \ a bit faster. My implementation is based on this solution and uses recursion\
    \ to iterate through the digits of the original number until only one digit is\
    \ left. \n<code>\npublic static string IntToMiniRoman(long number)\n    {\n  \
    \      string roman = string.Empty;\n        string digits = romanize.Digits(number);\n\
    \        int maxDigits = digits.Length;\n        string maxRoman = romanize.Digits(number).Max();\n\
    \        int index = maxDigits;", "{\n    string result;\n    if (number == 0)\n\
    \        return \"x\";\n    if (number > 1000)\n        return \"error\";\n  \
    \  int roman[] = { 1000,100,10,1,5,1,4,1,3,5,1,2,1 };\n    int x = number;\n \
    \   int nroman;\n    while (x!=0)\n    {\n        nroman = (x%1000);\n       \
    \ result += roman[nroman];\n        x/=1000;\n    }\n    return result;\n}", "{\n\
    \    long temp;\n    long temp2 = number;\n    char buffer[6];\n    string roman;\n\
    \    while (temp2 > 0) {\n        temp = temp2 % 1000;\n        temp2 /= 1000;\n\
    \        buffer[0] = char(temp + 1000);\n        buffer[1] = char(temp + 900);\n\
    \        buffer[2] = char(temp + 500);\n        buffer[3] = char(temp + 400);\n\
    \        buffer[4] = char(temp + 100);\n        buffer[5] = '\\0';\n        roman.append(buffer);\n\
    \    }\n    return roman;\n}\n</code>\n<|/ a tags=c++,string,c++11 |>\n<| c |>\n\
    Thanks for the answer, however, what I am looking for is the reverse. Convert\
    \ roman number to decimal.\n<|/ c |>\n<| c |>\nI updated the question to include\
    \ another version of `int_to_mini_roman`.\n<|/ c |>\n<| a |>\nI used your version\
    \ and added some code to make it more efficient:\n<code>\nstring int_to_mini_roman(int\
    \ number)\n{\n    string roman = \"\";", "{\n    // Get roman digit\n    long\
    \ value = number;", "{\n    int n = (int) number;\n    int count = 0;\n    int\
    \ result = 'I';\n    \n    while (n)\n    {\n        int digit = n % 10;\n   \
    \     string s = int_to_mini_roman(digit);\n        \n        if (count == 0)\
    \ \n        {\n            result = s;\n        }\n        else if (count == 1)\
    \ \n        {\n            result += s;\n        }\n        \n        n /= 10;\n\
    \        count++;\n    }\n    \n    return result.toLowerCase();\n}", "{\n   \
    \ string result;\n    long remainder = number;\n    int currentDigit;\n    string\
    \ romanNumberTable[100] = \n    {\n        \"M\", \n        \"CM\", \n       \
    \ \"D\", \n        \"CD\", \n        \"C\", \n        \"XC\", \n        \"L\"\
    , \n        \"XL\", \n        \"X\", \n        \"IX\", \n        \"V\", \n   \
    \     \"IV\", \n        \"I\"\n    };\n    while (remainder > 0)\n    {\n    \
    \    currentDigit = remainder % 10;\n        remainder = remainder / 10;\n   \
    \     result = romanNumberTable[currentDigit] + result;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=roman-numerals,c++,c |>\n<| c |>\nWhile this link may answer\
    \ the question, it is better to include the essential parts of the answer here\
    \ and provide the link for reference.  Link-only answers can become invalid if\
    \ the linked page changes. - [From Review](/review/low-quality-posts/26248824)\n\
    <|/ c |>\n<| c |>\nI don't think so - the question was how to convert an integer\
    \ to a \"mini-roman\" (a string of chars) in C/C++ that uses only 26 characters.\
    \ I wrote the function in the question and then linked it to a Wikipedia article\
    \ on \"Roman numerals\" that describes how it works. There's nothing in that article\
    \ that says it's not a good idea, but it's just not what this question is about.\n\
    <|/ c |>\n<| c |>\nYou linked to a Wikipedia article on \"Roman numerals\" that\
    \ describes how it works... But that doesn't make your answer, or yours, an answer.\
    \  And what is the difference between this answer and this answer (which does\
    \ not use a lookup table at all!)\n<|/ c |>\n<| c |>\nI agree with your comments,\
    \ I've edited my answer to reflect your points.\n<|/ c |>\n<| c |>\nThanks, I\
    \ see now.  I didn't realize that lookup-table was unnecessary in this case.\n\
    <|/ c |>\n<| a tags=roman-numerals,c++,c |>\nThis code is quite compact, but uses\
    \ a lookup table that is quite inefficient.  If you were to convert a number from\
    \ 1000 to 99999 it would take about 7 million iterations.\n<code>\n#include <stdio.h>\n\
    #include <string.h>\n#include <stdlib.h>\n#include <inttypes.h>", "{\n    string\
    \ res = \"\";\n    while(number > 0)\n    {\n        long c = number % 1000;\n\
    \        string s = mini_roman[(int)c];\n        res += s;\n        number /=\
    \ 1000;\n    }\n    return res.toLower();\n}", "{\n    string retVal = \"\";\n\
    \    int remainder = number;", "{\n    string result = \"\";\n    int numBase\
    \ = 1, lastNum, lastPower;", "{\n    long counter = 0;\n    string roms = \"\"\
    ;\n    char letter;", "{\n    string roman, roman_roman, roman_m1, roman_int;\n\
    \    long max_roman_length = 0, max_roman_value = 0;\n    string result;", "{\n\
    \    const string [] roman = { \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\",\
    \ \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\"\
    , \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\" };\n    const string [] tens =\
    \ { \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\",\
    \ \"C\", \"CX\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"\
    CM\" };\n    long n = number;\n    string s = \"\";\n    string t = \"0\";\n \
    \   int i = 0;\n    while (n > 0)\n    {\n        int d = n % 10;\n        s +=\
    \ roman[d];\n        n /= 10;\n    }\n    while (i < s.length())\n    {\n    \
    \    if (s[i] == t[0])\n        {\n            t.erase(0,1);\n            t.insert(0,\"\
    i\");\n        }\n        else\n        {\n            t.insert(0,t[0]);\n   \
    \     }\n        i++;\n    }\n    return t;\n}\n/*", "{\n    int romanValue[]\
    \ = { 1000,500,100,50,10,5,1,4,2,1,4,2,1,4,2,2,1 };\n    string returnString =\
    \ number.to<string>();\n    for(int i=0;i<returnString.length();i++)\n    {\n\
    \        if(returnString[i]=='0')\n            romanValue[i]--;\n        else\
    \ if(returnString[i]=='1')\n            romanValue[i]--;\n        else if(returnString[i]=='2')\n\
    \            romanValue[i]--;\n        else if(returnString[i]=='3')\n       \
    \     romanValue[i]--;\n        else if(returnString[i]=='4')\n            romanValue[i]--;\n\
    \        else if(returnString[i]=='5')\n            romanValue[i]--;\n       \
    \ else if(returnString[i]=='6')\n            romanValue[i]--;\n        else if(returnString[i]=='7')\n\
    \            romanValue[i]--;\n        else if(returnString[i]=='8')\n       \
    \     romanValue[i]--;\n        else if(returnString[i]=='9')\n            romanValue[i]--;\n\
    \        else if(returnString[i]=='x')\n            romanValue[i]--;\n       \
    \ else if(returnString[i]=='v')\n            romanValue[i]--;\n    }\n    for(int\
    \ i=0;i<returnString.length();i++)\n    {\n        if(romanValue[i]!=0)\n    \
    \    {\n            returnString.insert(i,\".\");\n            romanValue[i]--;\n\
    \        }\n    }\n    for(int i=0;i<returnString.length();i++)\n    {\n     \
    \   if(romanValue[i]!=0)\n        {\n            string romanNum = romanValue_to_string(romanValue);\n\
    \            returnString.insert(i,romanNum);\n            romanValue[i]--;\n\
    \        }\n    }\n    return returnString.toLower();\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| a dscore=4 |>\nI have another solution, by using the built-in function\
    \ std::to_string and std::atoi :\n<code>\n#include <iostream>\n#include <string>\n\
    #include <cstdlib>\n#include <cmath>", "{\n    string roman = \"\";\n    long\
    \ counter = 0;\n    long hundreds = number % 1000;\n    long reminder = number\
    \ - hundreds;", "{\n\tstring roman = \"\";\n\tlong i = number;", "{\n\tint numStringLength\
    \ = 0;\n\tint lastDigit = 0;\n\tlong temp = 0;\n\tstring resultString = \"\";\n\
    \tchar lastChar;\n\tint lastDigitStringLength;\n\tint romanIntegerBase = int((int)(num/1000))+1;\n\
    \tint romanNumBase = 1000 - romanIntegerBase;", "{\n    string result = \"\";\n\
    \    char digits[] = {'i','v','x','c'};\n    int i;", "{\n\tstring result = \"\
    \";\n\tlong nr = number;\n\tlong roman = std.math.floor(nr/100);\n\tlong tens\
    \ = nr % 100;\n\t\n\tresult += roman_to_mini_roman(roman);\n\tif (tens > 0) \n\
    \t{\n\t\tresult += roman_to_mini_roman(tens);\n\t}\n\treturn result;\n}", "{\n\
    \tchar chars[] = {'M','CM','D','CD','C','XC','L','XL','X','IX','V','IV','I','I'};\n\
    \tint i = 1;\n\tstring ret = \"\";\n\tlong nums[] = {1, 10, 100, 1000, 10000,\
    \ 100000, 1000000, 10000000, 100000000, 1000000000};\n\twhile(number >= nums[i])\n\
    \t\ti++;\n\tint j = (int) (number - nums[i]);\n\twhile(j > 0)\n\t{\n\t\tret =\
    \ chars[j%10] + ret;\n\t\tj = (int) j/10;\n\t}\n\t\n\twhile(i < 10)\n\t{\n\t\t\
    ret = chars[i-1] + ret;\n\t\ti++;\n\t}\n\treturn ret.toLowerCase();\n}\n/*", "{\n\
    \    int n1, n2, n3, n4, n5, n6, n7, n8, n9, n10;\n    int i1;\n    n1 = number\
    \ % 10;\n    number -= n1;\n    n2 = number % 10;\n    number -= n2;\n    n3 =\
    \ number % 10;\n    number -= n3;\n    n4 = number % 10;\n    number -= n4;\n\
    \    n5 = number % 10;\n    number -= n5;\n    n6 = number % 10;\n    number -=\
    \ n6;\n    n7 = number % 10;\n    number -= n7;\n    n8 = number % 10;\n    number\
    \ -= n8;\n    n9 = number % 10;\n    number -= n9;\n    n10 = number % 10;\n \
    \   number -= n10;\n    i1 = 1;\n    switch (n1) {\n        case 1:\n        \
    \    i1 = 3;\n            break;\n        case 2:\n            i1 = 3;\n     \
    \       break;\n        case 3:\n            i1 = 1;\n            break;\n   \
    \     case 4:\n            i1 = 2\n            break;\n        case 5:\n     \
    \       i1 = 3;\n            break;\n        case 6:\n            i1 = 2\n   \
    \         break;\n        case 7:\n            i1 = 2;\n            break;\n \
    \       case 8:\n            i1 = 1;\n            break;\n        case 9:\n  \
    \          i1 = 3;\n            break;\n        case 10:\n            i1 = 1;\n\
    \            break;\n        case 11:\n            i1 = 2;\n            break;\n\
    \        case 12:\n            i1 = 1;\n            break;\n        case 13:\n\
    \            i1 = 3;\n            break;\n        case 14:\n            i1 = 1;\n\
    \            break;\n        case 15:\n            i1 = 3;\n            break;\n\
    \        case 16:\n            i1 = 1;\n            break;\n        case 17:\n\
    \            i1 = 3;\n            break;\n        case 18:\n            i1 = 2;\n\
    \            break;\n        case 19:\n            i1 = 1;\n            break;\n\
    \        case 20:\n            i1 = 3;\n            break;\n        case 21:\n\
    \            i1 = 1;\n            break;\n        case 22:\n            i1 = 3;\n\
    \            break;\n        case 23:\n            i1 = 1;\n            break;\n\
    \        case 24:\n            i1 = 3;\n            break;\n        case 25:\n\
    \            i1 = 1;\n            break;\n        case 26:\n            i1 = 1;\n\
    \            break;\n        case 27:\n            i1 = 3;\n            break;\n\
    \        case 28:\n            i1 = 1;\n            break;\n        case 29:\n\
    \            i1 = 1;\n            break;\n        case 30:\n            i1 = 1;\n\
    \            break;\n        case 31:\n            i1 = 2;\n            break;\n\
    \        case 32:\n            i1 = 1;\n            break;\n        case 33:\n\
    \            i1 = 3;\n            break;\n        case 34:\n            i1 = 1;\n\
    \            break;\n        case 35:\n            i1 = 2;\n            break;\n\
    \        case 36:\n            i1 = 1;\n            break;\n        case 37:\n\
    \            i1 = 3;\n            break;\n        case 38:\n            i1 = 1;\n\
    \            break;\n        case 39:\n            i1 = 3;\n            break;\n\
    \        case 40:\n            i1 = 1;\n            break;\n        case 41:\n\
    \            i1 = 3;\n            break;\n        case 42:\n            i1 = 1;\n\
    \            break;\n        case 43", "{\n    int num_bits = ceil(log2(number));\n\
    \    string result = \"\";\n    \n    int i = num_bits;\n    while (i > 0)\n \
    \   {\n        long next_power = pow(2, i - 1);\n        if (next_power > number)\n\
    \        {\n            break;\n        }\n        string next_num_bits = to_string(next_power);\n\
    \        result = to_string(number%next_power) + result;\n        number /= next_power;\n\
    \        i -= 1;\n    }\n    if (number > 0)\n    {\n        result = to_string(number)\
    \ + result;\n    }\n    \n    // handle negative numbers\n    if (number < 0)\n\
    \    {\n        string negated = to_string(abs(number));\n        result = to_string(-1\
    \ * number) + result;\n        negated = negated.substr(1);\n        result =\
    \ negated + result;\n    }\n    \n    return result;\n}\n</code>\n<|/ a |>\n<|\
    \ a dscore=0 |>\nA few more examples:\n<code>\n(def fib 0\n  (lambda (n) (if (<\
    \ n 1) 1 ((fib (- n 1)) (+ (fib (- n 2)) n))))\n  (fib 3))", "{\n    int sum =\
    \ 0L;\n    string rom = \"x\";\n    \n    while (number > 0)\n    {\n        int\
    \ current = number % 10;\n        rom = charcat(rom, get_roman_digit(current));\n\
    \        number = number / 10;\n    }\n    return charreverse(rom);\n}\n</code>\n\
    <|/ a tags=roman-numerals,haskell |>\n<| a tags=roman-numerals,haskell |>\nI wrote\
    \ this for fun in Haskell to convert an integer into its Roman numeral representation.\n\
    <code>\nimport Data.Char", "{\n    long roman = number;\n    long roman_num =\
    \ 0;\n    string result = \"\";", "{\n    /*\n        Find the smallest number\
    \ i such that i * 2^(num-i) <= number", "{\n\tstring result=\"\";\n\twhile(number!=0)\n\
    \t{\n\t\tlong remainder=number%1000;\n\t\tstring s=remainder<10?(\"0\"+\"0\"+remainder):(\"\
    0\"+\"x\"+remainder);\n\t\tresult+=(s-\"0\");\n\t\tnumber=number/1000;\n\t}\n\t\
    return result;\n}\n/*", "{\n    string mini_roman = \"\";\n    int temp;\n   \
    \ \n    while (number) {\n        int temp = (number%1000)/1000;\n        mini_roman\
    \ += mini_romans[temp];\n        number /= 1000;\n    }\n    \n    return mini_roman;\n\
    }", "{\n\tstring roman;\n\t\n\tfor (long i = 1; i < number; i++)\n\t{\n\t\troman\
    \ += mini_roman[i % 10];\n\t}\n\treturn roman;\n}", "{\n    int num;\n    char\
    \ mini_roman[20];\n    char nums[10]; // nums[0] => num\n    int j;", "{\n\tassert(number\
    \ >= 1);\n\tassert(number <= 1000);", "{\n\tstring roman = \"\";\n\tunsigned int\
    \ i = 1, n = number;\n\twhile(n > 0)\n\t{\n\t\troman = roman_digit(n % 10) + roman;\n\
    \t\tn /= 10;\n\t\ti++;\n\t}\n\treturn roman;\n}", "{\n    if (number < 1 || number\
    \ > 1000) \n        throw new Exception(\"Number too big!\");\n    if (number\
    \ == 0) \n        return \"0\";", "{\n    string result; \n    if (number >= 1000)\
    \ \n    {\n        long temp = number;\n        number /= 1000;\n        result\
    \ += int_to_mini_roman(temp);\n        number %= 1000;\n    }\n    string number_str\
    \ = to_string(number); \n    size_t positions[] = { 0,1,2,3,4,5,6,7,8,9,10 };\
    \ \n    size_t length = sizeof(positions) / sizeof(positions[0]); \n    for (size_t\
    \ i = 0; i < length; ++i) \n    {\n        string s = \"\"; \n        string t\
    \ = number_str; \n        for (size_t k = 0; k < positions[i]; ++k) \n       \
    \ {\n            s += t[positions[i] - 1 - k]; \n        } \n        if (s ==\
    \ \"\") \n        {\n            s += \"0\"; \n        }\n        result += s;\
    \ \n    }\n    return result; \n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThe code\
    \ above doesn't handle a number that is 1000. It returns `000` instead of `C`\
    \ when it should.\n<|/ c |>\n<| c |>\nIt also returns `0` when `number == 1`.\n\
    <|/ c |>\n<| c |>\nThis answer is pretty good, but I find it really hard to read\
    \ it, so I have written my own version, which I believe is more readable. See\
    \ my answer below.\n<|/ c |>\n<| c |>\n, for those who want to use this answer\
    \ as a library, [the function `int_to_mini_roman`](http://stackoverflow.com/a/39342462/1627325)\
    \ returns a `string`. You can then use it like `println(int_to_mini_roman(135))`.\n\
    <|/ c |>\n<| a |>\nI took Ron's answer and wrote a functional version of it, which\
    \ I think is easier to read. The code below (untested) should handle a wide range\
    \ of input values without producing any error messages.\n<code>\nstring int_to_mini_roman(long\
    \ number) \n{\n    string result = \"\";\n    long temp = number;\n    while (temp\
    \ > 0) {\n        int romanValue = (int)(temp % 10);\n        result += (romanValue\
    \ == 0) ? \"0\" : romanValue;\n        temp /= 10;\n    }\n    temp = number;\n\
    \    while (temp > 0) {\n        int romanValue = (int)(temp % 100);\n       \
    \ result += (romanValue == 0) ? \"0\" : romanValue;\n        temp /= 100;\n  \
    \  }\n    temp = number;\n    while (temp > 0) {\n        int romanValue = (int)(temp\
    \ % 1000);\n        result += (romanValue == 0) ? \"0\" : ro", "{\n    // Convert\
    \ to string and remove all whitespace\n    string roman_num = to_string(number);\n\
    \    remove_if(roman_num, [](char c) { return c == '\\t' || c == '\\n'; });\n\
    \    remove_if(roman_num, [](char c) { return c == '\\r'; });", "{\n\tint romanLength\
    \ = 0;\n\tstring roman = \"\";\n\tstring alphabet = \"bcdfghjklmnpqrstvwxyz\"\
    ;\n\t\n\tint remainder = number;\n\t\n\twhile(true)\n\t{\n\t\tif(remainder % 1000\
    \ > 0) \n\t\t{\n\t\t\tremainder /= 1000;\n\t\t\tromanLength += 1;\n\t\t}\n\t\t\
    else if(remainder % 100 > 0) \n\t\t{\n\t\t\tremainder /= 100;\n\t\t\tromanLength\
    \ += 2;\n\t\t}\n\t\telse if(remainder % 10 > 0) \n\t\t{\n\t\t\tremainder /= 10;\n\
    \t\t\tromanLength += 1;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tromanLength += 1;\n\t\t\
    }\n\t\t\n\t\tif(remainder == 0) break;\n\t\tremainder -= 1;\n\t}\n\t\n\tchar ch;\n\
    \t\n\twhile(romanLength > 0)\n\t{\n\t\tch = alphabet[romanLength-1];\n\t\t\n\t\
    \tif(romanLength > 1 && romanLength < 5) \n\t\t{\n\t\t\tstring romanNumber = to_string(remainder)\
    \ + ch;\n\t\t\troman += romanNumber;\n\t\t}\n\t\telse if(romanLength == 1)\n\t\
    \t{\n\t\t\tstring romanNumber = to_string(remainder) + ch;\n\t\t\troman += romanNumber;\n\
    \t\t}\n\t\telse \n\t\t{\n\t\t\tstring romanNumber = to_string(remainder % 100)\
    \ + ch;\n\t\t\troman += romanNumber;\n\t\t\tremainder /= 100;\n\t\t}\n\t\tromanLength\
    \ -= 1;\n\t}\n\treturn roman;\n}", "{\n    long roman = 0;\n    string romanOutput\
    \ = \"\";\n    string miniRomanOutput = \"\";\n    string miniRoman = \"\";\n\
    \    long numMod = 1000;\n    long numPower = 1;\n    long romInt;\n    long num;\n\
    \    string romChar;\n    int j;\n    int temp;", "{\n    string roman =\"\";\n\
    \    string roman_number =\"\";\n    string num2roman;\n    long i;\n    \n  \
    \  bool isRomanNumeral;", "{\n\tif (number == 0 || number > 1000) \n\t{\n\t\t\
    return \"0\";\n\t}\n\tif (number > 1000)\n\t{\n\t\tstring result = \"\";\n\t\t\
    long numDigits = number%1000;\n\t\tnumber /= 1000;\n\t\tstring firstRoman = \"\
    \";\n\t\tint romanNum = number%10;\n\t\tnumber /= 10;\n\t\tstring firstDigit =\
    \ \"\";\n\t\twhile (numDigits-- != 0)\n\t\t{\n\t\t\tfirstDigit += romanNum;\n\t\
    \t}\n\t\t\n\t\tif (number != 0)\n\t\t{\n\t\t\tstring secondDigit = \"\";\n\t\t\
    \tromanNum = number%10;\n\t\t\tnumber /= 10;\n\t\t\twhile (numDigits-- != 0)\n\
    \t\t\t{\n\t\t\t\tsecondDigit += romanNum;\n\t\t\t}\n\t\t\tfirstRoman += firstDigit;\n\
    \t\t\tfirstRoman += secondDigit;\n\t\t}\n\t\t\n\t\treturn firstRoman + result;\n\
    \t}\n\tif (number == 100)\n\t{\n\t\treturn \"x\";\n\t}\n\tif (number == 10)\n\t\
    {\n\t\treturn \"c\";\n\t}\n\tif (number == 1)\n\t{\n\t\treturn \"m\";\n\t}\n\t\
    string firstRoman = \"\";\n\tint romanNum = number%10;\n\tnumber /= 10;\n\tstring\
    \ firstDigit = \"\";\n\twhile (romanNum-- != 0)\n\t{\n\t\tfirstDigit += romanNum;\n\
    \t}\n\tif (number != 0)\n\t{\n\t\tstring secondDigit = \"\";\n\t\tromanNum = number%10;\n\
    \t\tnumber /= 10;\n\t\twhile (romanNum-- != 0)\n\t\t{\n\t\t\tsecondDigit += romanNum;\n\
    \t\t}\n\t\tfirstRoman += firstDigit;\n\t\tfirstRoman += secondDigit;\n\t}\n\t\
    return firstRoman + result;\n}", "{\n    long remainder = number;\n    string\
    \ s = \"\";\n    while (number > 0)\n    {\n        long temp = number % 10;\n\
    \        if (temp == 0)\n        {\n            s += \"i\";\n            number\
    \ /= 10;\n        }\n        else if (temp == 1)\n        {\n            s +=\
    \ \"v\";\n            number /= 10;\n        }\n        else if (temp == 2)\n\
    \        {\n            s += \"x\";\n            number /= 10;\n        }\n  \
    \      else if (temp == 3)\n        {\n            s += \"l\";\n            number\
    \ /= 10;\n        }\n        else if (temp == 4)\n        {\n            s +=\
    \ \"c\";\n            number /= 10;\n        }\n        else if (temp == 5)\n\
    \        {\n            s += \"d\";\n            number /= 10;\n        }\n  \
    \      else if (temp == 6)\n        {\n            s += \"m\";\n            number\
    \ /= 10;\n        }\n        else if (temp == 7)\n        {\n            s +=\
    \ \"c\";\n            number /= 10;\n        }\n        else if (temp == 8)\n\
    \        {\n            s += \"v\";\n            number /= 10;\n        }\n  \
    \      else if (temp == 9)\n        {\n            s += \"i\";\n            number\
    \ /= 10;\n        }\n        else\n        {\n            s += \"x\";\n      \
    \      number /= 10;\n        }\n    }\n    \n    while (remainder > 0)\n    {\n\
    \        long temp = remainder % 10;\n        if (temp == 0)\n        {\n    \
    \        s += \"i\";\n            remainder /= 10;\n        }\n        else if\
    \ (temp == 1)\n        {\n            s += \"v\";\n            remainder /= 10;\n\
    \        }\n        else if (temp == 2)\n        {\n            s += \"x\";\n\
    \            remainder /= 10;\n        }\n        else if (temp == 3)\n      \
    \  {\n            s += \"l\";\n            remainder /= 10;\n        }\n     \
    \   else if (temp == 4)\n        {\n            s += \"c\";\n            remainder\
    \ /= 10;\n        }\n        else if (temp == 5)\n        {\n            s +=\
    \ \"d\";\n            remainder /= 10;\n        }\n        else if (temp == 6)\n\
    \        {\n            s += \"m\";\n            remainder /= 10;\n        }\n\
    \        else if (temp == 7)\n        {\n            s += \"c\";\n           \
    \ remainder /= 10;\n        }\n        else if (temp == 8)\n        {\n      \
    \      s += \"v\";\n            remainder /= 10;\n        }\n        else if (temp\
    \ == 9)\n        {\n            s += \"i\";\n            remainder /= 10;\n  \
    \      }\n        else\n        {\n            s += \"x\";\n            remainder\
    \ /= 10;\n        }\n    }\n    \n    if (number > 0)\n    {\n        s += \"\
    i\";\n    }\n", "{\n    // we use a map to store the mappings of integer numbers\
    \ to romans\n    map<long, string> mini_roman;\n    map<long, string>::iterator\
    \ it;\n    \n    // we iterate over the map to build the string \"mini_roman\"\
    \n    for (it = mini_roman.begin(); it != mini_roman.end(); ++it) {\n        //\
    \ if the current number we iterate over matches the number we get as a parameter,\n\
    \        // we get the corresponding roman\n        if (it->second == number_to_roman(number))\
    \ {\n            return it->first;\n        }\n    }\n    // if the number we\
    \ get as a parameter is outside the accepted range,\n    // we return the string\
    \ \"unknown\"\n    return \"unknown\";\n}", "{\n    // convert integer to a String\n\
    \    string s = to_string(number);\n    // find its number of digits\n    int\
    \ len = s.length();", "{\n    string result = \"\";\n    for(int i=0;i<=number;i++)\
    \ {\n        int c = number % 10;\n        string s = int_to_mini_roman_digit(c,i);\n\
    \        result += s;\n        number = number / 10;\n    }\n    return result.lowercase();\n\
    }", "{\n    string mini = int_to_mini_roman(number);\n    return mini.substr(0,\
    \ mini.find_first_not_of('x'));\n}", "{\n    static const string romans[] = \n\
    \    { \n        \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"\
    X\", \"IX\", \"V\", \"IV\", \n        \"I\" \n    };\n    string result = \"\"\
    ;\n    int roman = number % 10;\n    while (roman != 0)\n    {\n        result\
    \ += romans[roman];\n        roman = number % 10;\n        number /= 10;\n   \
    \ }\n    return result;\n}", "{\n    string roman = \"\";\n    char digit = number_of_bits(number);\n\
    \    int num_bits = __builtin_clz(number);\n    int remainder = number % 10;\n\
    \    int index = 0;\n    for(int i=0;i<num_bits;i++)\n    {\n        if(digit\
    \ != 0)\n        {\n            roman += int_to_roman[digit];\n            digit--;\n\
    \        }\n        else\n        {\n            if(index == remainder)\n    \
    \            roman += \"i\";\n            else\n                roman += \"v\"\
    ;\n        }\n        index++;\n    }\n    return roman;\n}\n</code>\nThe above\
    \ code has been tested on Ubuntu 15.10 with GCC 4.8.5\n<|/ a tags=c++,roman-numerals,c,algorithm,int\
    \ dscore=2 |>\n<| c |>\n`__builtin_clz` is available in GCC 4.7 and Clang 3.5.\n\
    <|/ c |>\n<| c |>\nI added a version that doesn't require GCC 4.7 and Clang 3.5\n\
    <|/ c |>\n<| a tags=c++,roman-numerals,c,algorithm,int |>\n<code>\n//Roman numeral\
    \ of int number is returned", "{\n    int romanNumbers[] = { 'M',  'CM', 'D',\
    \ 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I' };\n    int numeralIndex\
    \ = 0;\n    int numZeros = 0;\n    while (number > 0 && numZeros++ < number)\n\
    \    {\n        numeralIndex++;\n        number -= romanNumbers[numeralIndex];\n\
    \    }\n    long decimalDigits = number;\n    string result = \"\";\n    while\
    \ (decimalDigits > 0)\n    {\n        if (decimalDigits % 10 == 0)\n        {\n\
    \            result += romanNumbers[numeralIndex];\n        }\n        decimalDigits\
    \ /= 10;\n        numeralIndex++;\n    }\n    // Make sure romanIndex is correct.\n\
    \    while (numeralIndex < len(romanNumbers) && romanNumbers[numeralIndex] ==\
    \ 0)\n    {\n        numeralIndex++;\n    }\n    while (len(romanNumbers) < numeralIndex)\n\
    \    {\n        romanNumbers[len(romanNumbers)] = romanNumbers[len(romanNumbers)\
    \ - 1];\n    }\n    result += romanNumbers[numeralIndex];\n    return result;\n\
    }\n</code>\n<|/ a dscore=3 tags=roman-numerals,roman-numeral,c++,algorithm |>\n\
    <| a tags=roman-numerals,roman-numeral,c++,algorithm |>\nYou probably want a library\
    \ for this, but here's some code for you as a starting point.\nI didn't bother\
    \ to write the full algorithm, as it's not that complex. Instead I just used the\
    \ conversion tables that Wikipedia provides.\n<code>\n#include <string>\n#include\
    \ <iostream>", "{\n    unsigned long long num = number;\n    string res = \"\"\
    ;\n    string romanArray[] = {\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\", \"x\", \"xi\", \"xii\", \"xiii\", \"xiv\", \"xv\", \"\
    xvi\", \"xvii\", \"xviii\"};\n    bool romanArrayContainsNumber = false;\n   \
    \ string romanArraySubstring = \"\";\n    int lengthOfRomanArray = sizeof(romanArray)\
    \ / sizeof(romanArray[0]);\n    int index = 0;\n    int indexRomanArray = 0;\n\
    \    \n    // Iterate through the numeral digits of the integer and find if they\
    \ exist in the Roman array\n    for(int indexDigit = 0; indexDigit < lengthOfRomanArray;\
    \ indexDigit++)\n    {\n        if(num >= 1000 && num % 1000 == 0)\n        {\n\
    \            if(romanArrayContainsNumber)\n            {\n                romanArraySubstring\
    \ = \"\";\n            }\n            else\n            {\n                romanArrayContainsNumber\
    \ = true;\n                romanArraySubstring = romanArray[indexRomanArray];\n\
    \            }\n        }\n        \n        // Check if the numeral digit we're\
    \ checking is the same as the numeral digit in the Roman array\n        // If\
    \ so, consider the numeral digit, if it equals to the numeral digit in the Roman\
    \ array\n        if(num % 10 == romanArray[indexDigit])\n        {\n         \
    \   romanArraySubstring += romanArray[indexDigit];\n            indexRomanArray++;\n\
    \            \n            if(indexRomanArray == lengthOfRomanArray)\n       \
    \     {\n                romanArraySubstring = romanArray[indexRomanArray];\n\
    \                indexRomanArray = 0;\n            }\n        }\n        else\n\
    \        {\n            romanArraySubstring = \"\";\n        }\n    }\n    \n\
    \    // If no digit in the integer is found in the Roman array, the integer is\
    \ invalid \n    if(romanArraySubstring == \"\")\n    {\n        throw \"Invalid\
    \ number\";\n    }\n    \n    // The last digit of the integer is added to the\
    \ Roman string\n    romanArraySubstring += romanArray[indexRomanArray];\n    \n\
    \    // If the last digit of the integer is not in the Roman array, it is invalid\n\
    \    if(romanArraySubstring != romanArray[indexRomanArray])\n    {\n        throw\
    \ \"Invalid number\";\n    }\n    \n    // If the integer equals to the last digit\
    \ in the Roman array, we know that it is valid\n    // Convert the last digit\
    \ of the integer to the string equivalent of the Roman string\n    res += roman",
  "{\n    if(number == 1)\n    {\n        return string(\"x\");\n    }\n    else if((number\
    \ > 1) && (number < 500))\n    {\n        string result = \"\";\n        long\
    \ num = number;\n        for(long i = 2; i <= num; i++)\n        {\n         \
    \   long digit = num % i;\n            result += roman[digit];\n        }\n  \
    \      return result;\n    }\n    else\n    {\n        string result = \"\";\n\
    \        long num = (number * 1000) / 1000;\n        for(long i = 4; i <= num;\
    \ i++)\n        {\n            long digit = num % i;\n            result += roman[digit];\n\
    \        }\n        return result;\n    }\n}\n</code>\n<|/ a |>\n<| c |>\nHi Nick!\
    \  Thanks for your help, but that didn't work either.  It returned \"XIX\" instead\
    \ of \"xix\".  However, I did find a very similar solution (just posted below)\
    \ that works perfectly.\n<|/ c |>\n<| a dscore=2 |>\nYou have to change the last\
    \ two lines of your function int_to_mini_roman:\n<code>\nstring int_to_mini_roman(long\
    \ number) \n{\n    if(number == 1)\n    {\n        return string(\"x\");\n   \
    \ }\n    else if((number > 1) && (number < 500))\n    {\n        string result\
    \ = \"\";\n        long num = number;\n        for(long i = 2; i <= num; i++)\n\
    \        {\n            long digit = num % i;\n            result += roman[digit];\n\
    \        }\n        return result;\n    }\n    else\n    {\n        string result\
    \ = \"\";\n        long num = (number * 1000) / 1000;\n        for(long i = 4;\
    \ i <= num; i++)\n        {\n            long digit = num % i;\n            result\
    \ += roman[digit];\n        }\n        return result;\n    }\n}\n</code>\nAnd\
    \ then you will be able to use it:\n<code>\nstring result = int_to_mini_roman(19L);\n\
    </code>\nThis gives us:\n<code>\nstring result = \"xix\";\n</code>\nIf you want\
    \ it lowercase:\n<code>\nstring result = string(\"X\") + int_to_mini_roman(19L);\n\
    </code>\n<|/ a tags=c++,roman-numerals |>\n<| c |>\nWow, what a stupid mistake.\
    \  Thank you!\n<|/ c |>\n<| a tags=c++,roman-numerals |>\nThe above answers were\
    \ good, but they did not seem to solve the problem for me.  I ended up using this\
    \ code:\n<code>", "{\n    string roman = string();\n    long num = number;\n \
    \   long r = 1;\n    long temp;\n    int k = 1;", "{\n    if (number == 0)\n \
    \       return \"0\";\n    \n    char roman[4];\n    bool isprime = true;\n  \
    \  int counter = 1;\n    int result = 0;\n    char ch;\n    int index = 0;\n \
    \   \n    // find prime factors\n    for (int i = 2; i <= number; i++)\n    {\n\
    \        if (number % i == 0)\n            isprime = false;\n    }\n    // if\
    \ prime\n    if (isprime)\n    {\n        roman[0] = 'I';\n        roman[1] =\
    \ 'V';\n        roman[2] = 'X';\n        roman[3] = 'L';\n        \n        //\
    \ find first prime\n        for (int i = 2; i <= number; i++)\n        {\n   \
    \         if (number % i == 0)\n            {\n                counter = 1;\n\
    \                while (number % i == 0)\n                {\n                \
    \    number /= i;\n                    counter++;\n                }\n       \
    \         \n                // if prime found\n                if (counter ==\
    \ 1)\n                {\n                    roman[4] = char(number + '0');\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    else\n    {\n        // find remainder\n        for (int i = 1; i <=\
    \ number; i++)\n        {\n            if (number % i == 0)\n            {\n \
    \               roman[4] = char(number - i);\n                break;\n       \
    \     }\n        }\n    }\n    // remove last roman\n    roman[4] = '0';\n   \
    \ // remove first roman\n    roman[1] = '0';\n    // remove middle roman\n   \
    \ roman[2] = '0';\n    // replace last roman by zero\n    roman[3] = '0';\n  \
    \  // reverse string\n    for (int i = 0; i < 4; i++)\n    {\n        ch = roman[i];\n\
    \        roman[i] = roman[4 - i];\n        roman[4 - i] = ch;\n    }\n    \n \
    \   // get result\n    while (roman[index])\n    {\n        result += roman[index++]\
    \ - '0';\n    }\n    \n    // remove leading zero\n    while (result == '0' &&\
    \ roman[index])\n    {\n        roman[index--] = '0';\n    }\n    \n    // remove\
    \ trailing zero\n    while (roman[index] && roman[index] == '0')\n    {\n    \
    \    roman[index--] = '0';\n    }\n    \n    char temp[4];\n    \n    // reverse\
    \ string\n    for (int i = 0; i < 4; i++)\n    {\n        ch = roman[i];\n   \
    \     roman[i] = roman[4 - i];\n        roman[4 - i] = ch;\n    }\n    \n    return\
    \ temp;\n}", "{\n    string roman =\"\";\n    long number = number;\n    if (number\
    \ < 100)\n        roman = mini_roman[number];\n    else {\n        long temp =\
    \ number % 10;\n        number /= 10;\n        while(number > 0){\n          \
    \  roman += (mini_roman[temp]);\n            number /= 10;\n            temp =\
    \ temp + temp;\n        }\n    }\n    return roman;\n}", "{\n    string roman\
    \ = \"\";\n    string alphabet = \"MCMXCIV\";\n    int romanNumeralIndex = 0;",
  "{\n    string numeral = \"\";\n    \n    while (number >= 1000) {\n        number\
    \ -= 1000;\n        numeral += \"v\";\n    }\n    \n    while (number >= 100)\
    \ {\n        number -= 100;\n        numeral += \"c\";\n    }\n    \n    while\
    \ (number >= 10) {\n        number -= 10;\n        numeral += \"l\";\n    }\n\
    \    \n    if (number >= 1) {\n        numeral += \"m\";\n    }\n    \n    numeral\
    \ += std.to_string(number);\n    return numeral;\n}\n</code>\n<|/ a tags=c,functional-programming,string,string\
    \ |>\n<| c |>\nWhile this code snippet may solve the question, [including an explanation](http://meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion.\n<|/ c |>\n<| a tags=c,functional-programming,string,string\
    \ |>\nHere is another version that uses a single loop.  It uses strcat to append\
    \ characters to a string, rather than a for loop.  \nThe only real trick is that\
    \ the second argument of strcat is the null character.  The null character is\
    \ guaranteed to be in the range of a char to make the pointer arithmetic work.\
    \  \n<code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>", "{\n\
    \    // 1. Get a roman numeral representation of a positive integer.\n    string\
    \ roman = to_roman(number);\n    \n    // 2. Convert the roman numeral to a lowercase\
    \ string.\n    string lower_roman = roman.substr(0, roman.length()).toLowerCase();",
  "{\n    string roman;\n    long num2 = number;\n    long num1 = number;\n    string\
    \ roman_numerals = \"IX VI X L C D M\";\n    \n    if(number < 0 || number > 1000)\n\
    \    {\n        return number; // shouldn't happen - just in case\n    }\n   \
    \ \n    while(num1 >= 10000)\n    {\n        num1 /= 1000;\n        num2 /= 10;\n\
    \    }\n    while(num2 >= 10)\n    {\n        roman_numerals = roman_numerals\
    \ + \" \";\n        num2 /= 10;\n    }\n    \n    roman_numerals = roman_numerals\
    \ + \" \";\n    \n    int i;\n    string num;\n    string nums[7];\n    for(i\
    \ = 0; i < 7; i++)\n    {\n        nums[i] = num1;\n        num1 = num2;\n   \
    \     num2 = num1;\n    }\n    \n    num = nums[0];\n    for(i = 1; i < 7; i++)\n\
    \    {\n        if(nums[i] != 0)\n        {\n            num += \" \" + nums[i];\n\
    \        }\n        else\n        {\n            num += roman_numerals[i];\n \
    \       }\n    }\n    \n    return num.substr(0, num.length() - 1);\n}", "{\n\t\
    assert(number > 0);\n\tassert(number <= 1000);", "{\n    string result;", "{\n\
    \    int numDigits = intToStr(number).length();\n    string roman = \"\";\n  \
    \  string num = \"\";\n    if (numDigits >= ROMAN_MINIMUM_DIGITS)\n    {\n   \
    \     roman = intToStr(number);\n    }\n    else if (numDigits >= ROMAN_EXTRA_DIGITS)\n\
    \    {\n        roman = intToStr(number);\n        roman = roman.substr(0, ROMAN_EXTRA_DIGITS);\n\
    \    }\n    else if (numDigits >= ROMAN_THIRD_DIGITS)\n    {\n        roman =\
    \ intToStr(number);\n        roman = roman.substr(0, ROMAN_THIRD_DIGITS);\n  \
    \  }\n    else\n    {\n        roman = intToStr(number);\n        roman = roman.substr(0,\
    \ ROMAN_MINIMUM_DIGITS);\n    }\n    num = intToStr(number);\n    while (num.length()\
    \ > 0)\n    {\n        roman = roman.substr(0, ROMAN_ROUND);\n        roman =\
    \ roman + intToStr(floor(pow(10, ROMAN_ROUND)) * (num.substr(0, ROMAN_ROUND)));\n\
    \        num = num.substr(ROMAN_ROUND, num.length() - ROMAN_ROUND);\n        ROMAN_ROUND++;\n\
    \    }\n    roman = roman.substr(0, ROMAN_MINIMUM_DIGITS);\n    return roman;\n\
    }", "{\n    if  (number < 0 || number >= 1000L) \n        return string();\n \
    \   string result = \"\";\n    int remainder = 0;\n    \n    while (remainder\
    \ < number)\n    {\n        int digit = number % 10;\n        result += string_of_integers[digit];\n\
    \        number /= 10;\n        remainder *= 100;\n    }\n    \n    if (number\
    \ > 0)\n    {\n        int digit = number % 10;\n        result += string_of_integers[digit];\n\
    \    }\n    \n    return result;\n}", "{\n    string ret = \"x\";\n    int num\
    \ = number;", "{\n    assert(number<=1000);\n    string s = \"\";\n    for(int\
    \ i=1;i<=number;++i) \n    {\n        long x = number%i;\n        if(x>0)\n  \
    \          s += \"m\";\n        else\n            s += \"d\";\n        s +=  char(x);\n\
    \        number /= i;\n    }\n    return s;\n}", "{\n    long long remainder,\
    \ digit, index = 0;\n    string roman;", "{\n    string roman = \"\";\n    string\
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    string numerals = \"123456789\"\
    ;\n    char temp;\n    for(int i=0;i<3;i++)\n    {\n        if(number<1)\n   \
    \     {\n            roman = roman + \"I\";\n            number = number * -1;\n\
    \        }\n        while(number > 0)\n        {\n            temp = number %\
    \ 10;\n            number = number/10;\n            roman = roman + alphabet[temp];\n\
    \        }\n        roman = roman + \"M\";\n    }\n    return roman;\n}", "{\n\
    \    int n = (int) number;\n    \n    if (n < 0 || n > 1000)\n        throw new\
    \ IllegalArgumentException(\"invalid integer \" + n);\n    \n    string result\
    \ = \"\";\n    \n    while (n > 0)\n    {\n        int d = (int) (n/10);\n   \
    \     string rom  = int_to_mini_roman(d);\n        n = n % 10;\n        if (rom.length()\
    \ > 0)\n            result += rom;\n    }\n    \n    return result;\n}\n</code>\n\
    <|/ a tags=algorithm,java |>\n<| a tags=algorithm,java |>\nHere is the short code.\
    \ \n<code>\npublic String intToRoman(int num) {\n    int[] a = new int[1000];\n\
    \    Arrays.fill(a, 0, 999);\n    int i = 0;\n    while (num > 0) {\n        if\
    \ (num >= 1000) {\n            a[num / 1000] = a[num / 1000] + 1;\n          \
    \  num = (num % 1000) + 1000;\n        } else {\n            a[i] = num;\n   \
    \         i++;\n        }\n    }\n    StringBuilder sb = new StringBuilder(\"\"\
    );\n    for (int k = 0; k <= i; k++) {\n        if (k != 0)\n            sb.insert(1,\
    \ a[k]);\n        sb.insert(1, (k == i) ? \"\" : \" \");\n    }\n    return sb.toString();\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,java |>\nThis is my solution\
    \ in Java 8:\n<code>\npublic static String intToRoman(int num)\n{\n    StringBuilder\
    \ result = new StringBuilder();\n    List<Integer> roman = new ArrayList<>();\n\
    \    int[] a = intToRoman(num, roman);\n    result.append(\"[\").append(String.join(\"\
    , \", a)).append(\"]\");\n    return result.toString();\n}", "{\n    string roman;\n\
    \    int num;", "{\n    string romNum;\n    long a = number % 10;\n    long b\
    \ = number / 10;\n    string romanNum = \"x\";\n    if (a > 0) \n        romanNum\
    \ += int_to_mini_roman(a);\n    if (b > 0) \n        romanNum += int_to_mini_roman(b);\n\
    \    romNum = romanNum.substr(1) + romanNum.substr(0,1);\n    return romNum;\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI thought it would be best to add the\
    \ code to the original post, so that people would see what it was for without\
    \ needing to follow a link.  Anyway, the function above does work properly.  I\
    \ had not realized that I had to convert it to string.  Thank you so much for\
    \ your help!\n<|/ c |>\n<| c |>\nNo problem. Glad it helped.\n<|/ c |>\n<| c |>\n\
    This is O(n^2), isn't it? It should be O(n) or less.\n<|/ c |>\n<| c |>\nThis\
    \ would be O(n) because of the recursion overhead.  A lookup table would be more\
    \ efficient.\n<|/ c |>\n<| c |>\nI see you have the code in the original post,\
    \ but it might be better to post a new answer with this code.  It would make my\
    \ answer more clear.\n<|/ c |>\n<| a |>\nThe other solutions did not work for\
    \ me, but this one:\n<code>\nstring int_to_mini_roman(long number)\n{\n  char\
    \ c = number % 10;\n  string romanNum = \"x\";\n  for (int i = intToStringLength(c);\
    \ i >= 0; i--)\n    romanNum += int_to_mini_roman(number % 1000 / 10 * 10 % 10\
    \ + c / 10 - 1);\n  return romanNum;\n}\n</code>\n<|/ a dscore=2 tags=roman-numerals,algorithm,big-o\
    \ |>\n<| a dscore=1 tags=roman-numerals,algorithm,big-o |>\nHere is my solution\
    \ using Javascript:\n<code>\nfunction intToRoman(num) {", "{\n    // Find how\
    \ many times the given number is to be repeated\n    int times = pow(10, (int)(log10(number)));\n\
    \    // Find the correct roman's numeral for given number of times. \n    return\
    \ roman[(int)((number - 1) * times)];\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=roman-numerals,integer,c#,python\
    \ |>\n<code>\ndef int_to_roman(num):\n    return ''.join(str(n) for n in roman_nums(num))",
  "{\n    string roman = \"\";\n    if (number == 0)\n    {\n        return \"0\"\
    ;\n    }\n    \n    long temp;\n    for (long i=number; i>0; i--)\n    {\n   \
    \     temp = i%1000;\n        roman += roman[temp];\n        i /= 1000;\n    }\n\
    \    \n    int digit = number%10;\n    roman = roman.substr(0, digit) + roman.substr(digit)\
    \ + roman[digit];\n    \n    return roman;\n}", "{\n    long roman = number;\n\
    \    string res = \"\";\n    \n    while(roman > 0)\n    {\n        int remain\
    \ = roman % 10;\n        roman = roman / 10;\n        res += string_to_int[remain].to_string();\n\
    \    }\n    return std.string(res.begin(), res.end());\n}", "{\n    assert(number\
    \ > 0);\n    assert(number <= 1000);\n    if (number == 1)\n        return \"\
    x\";", "{\n    long num = number;", "{\n    string result;\n    string numerals\
    \ = \n        \"MCMXCIV\";\n    string conversionTable = \n        \"M=1000\"\
    \ \" C=100\" \" L=10\" \" X=1\" \" V=9\" \" I=8\";", "{\n    if(number < 0 ||\
    \ number >= 1000)\n        return \"Invalid Number\";\n    string roman_numeral\
    \ = \"\";\n    string int_to_roman_digits(long num, string roman_numeral, string\
    \ roman_numeral_rev, string roman_numeral_digits) {\n        if(num < 10) {\n\
    \            return roman_numeral + roman_numeral_digits[num];\n        } else\
    \ if(num >= 100 && num < 1000) {\n            roman_numeral_digits += roman_numeral_digits[num\
    \ / 10] + roman_numeral_digits[num % 10];\n            return roman_numeral_rev\
    \ + int_to_roman_digits(num % 10, roman_numeral_rev, roman_numeral, roman_numeral_digits);\n\
    \        } else {\n            return roman_numeral_digits + roman_numeral_digits[num\
    \ / 100] + roman_numeral_digits[num % 100] + int_to_roman_digits(num % 1000, roman_numeral_rev,\
    \ roman_numeral, roman_numeral_digits);\n        }\n    }\n    roman_numeral_digits\
    \ = \"MCMXCIV\";\n    roman_numeral = int_to_roman_digits(number, roman_numeral,\
    \ roman_numeral_rev, roman_numeral_digits);\n    return roman_numeral.toLower();\n\
    }", "{\n    long romanNumeral = number;\n    romanNumeral = romanNumeral - (number\
    \ % 1000);\n    romanNumeral = romanNumeral - ((number % 1000) >> 1);\n    romanNumeral\
    \ = romanNumeral - ((number % 1000) >> 2);\n    romanNumeral = romanNumeral -\
    \ ((number % 1000) >> 3);\n    romanNumeral = romanNumeral - ((number % 1000)\
    \ >> 4);\n    romanNumeral = romanNumeral - ((number % 1000) >> 5);\n    romanNumeral\
    \ = romanNumeral - ((number % 1000) >> 6);\n    romanNumeral = romanNumeral +\
    \ (number % 1000);\n    return to_string(romanNumeral);\n}\n</code>\n<|/ a dscore=2\
    \ tags=python-3.x,python,roman-numerals |>\n<| c |>\nIt would be more useful if\
    \ you were to include the explanation as to what the code does, rather than link\
    \ to an external site.\n<|/ c |>\n<| c |>\nThis is great but I don't understand\
    \ how it works! Can you clarify?\n<|/ c |>\n<| c |>\nI added a code section to\
    \ explain it.\n<|/ c |>\n<| a tags=python-3.x,python,roman-numerals |>\nJust for\
    \ fun, here's a version that avoids using division and remainder altogether:\n\
    <code>\ndef int_to_mini_roman(num):\n    if num == 0:\n        return ''\n   \
    \ elif num == 100:\n        return 'm'\n    elif num == 50:\n        return 'd'\n\
    \    elif num == 10:\n        return 'c'\n    elif num == 5:\n        return 'l'\n\
    \    elif num == 1:\n        return 'x'\n    else:\n        if num > 400:\n  \
    \          return int_to_mini_roman(num//100) + int_to_mini_roman(num%100)\n \
    \       elif num > 100 and num < 400:\n            return int_to_mini_roman(num//50)\
    \ + int_to_mini_roman(num%50)\n        elif num > 50 and num < 100:\n        \
    \    return int_to_mini_roman(num//10) + int_to_mini_roman(num%10)\n        elif\
    \ num > 10 and num < 50:\n            return int_to_mini_roman(num//5) + int_to_mini_roman(num%5)\n\
    \        elif num > 5 and num < 10:\n            return int_to_mini_roman(num//1)\
    \ + int_to_mini_roman(num%1)\n        else:\n            return int_to_mini_roman",
  "{\n    \n    long num;\n    long factor = 1;\n    string result = \"\";\n    long\
    \ place = number;\n    \n    do {\n        \n        // get factor\n        num\
    \ = (number / factor);\n        \n        result += int_to_mini_roman(num);\n\
    \        \n        // set factor\n        factor = num;\n        \n    } while(\
    \ (number / factor) > 1 );\n    \n    while(place > 0) {\n        result += int_to_mini_roman(place\
    \ % 10);\n        place /= 10;\n    }\n    \n    return result.lower();\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\nA Python version using recursion:\n<code>\n\
    def mini_roman(num):\n    def recursive(num, roman, place):\n        if num ==\
    \ 1:\n            return roman\n        roman = roman[:place] + int_to_mini_roman(num\
    \ % 10) + roman[place:]\n        return recursive(num // 10, roman, place + 1)\n\
    \    return recursive(num, 0, 0)\n</code>\n<|/ a tags=c,roman-numerals,algorithm\
    \ |>\n<| a dscore=0 |>\nThis answer is for those who might need this in the future\
    \ and are still looking for an answer. In the first part of the code, it counts\
    \ the number of \"9\" in the number (countnines). Then it calculates the number\
    \ of \"10\"s in the number (counttens). This number is then used to calculate\
    \ the number of \"I\"s. This is then used to calculate the number of \"V\"s. Once\
    \ all of the \"I\"s are calculated, it iterates through the remaining \"10\"s,\
    \ using the countnines and counttens numbers to calculate each \"V\". This can\
    \ be done recursively. After that, the remaining \"10\"s are counted to calculate\
    \ the next \"V\" and so on. \n<code>\n#include <iostream>\nusing namespace std;",
  "{\n    string roman = \"\";\n    if (number < 0 || number > 999) {\n        return\
    \ \"?\";\n    }\n    if (number < 1000) {\n        roman = string(\"0\") + int_to_mini_roman(number\
    \ % 1000);\n    }\n    else {\n        int num1000 = number / 1000;\n        int\
    \ num100 = number % 1000;\n        int num10 = number / 10;\n        int num1\
    \ = number % 10;\n        roman = string(\"0\") + int_to_mini_roman(number % 10);\n\
    \        roman += string(\"x\") + int_to_mini_roman(number / 10);\n        roman\
    \ += string(num1000) + int_to_mini_roman(number % 1000);\n        roman += string(num100)\
    \ + int_to_mini_roman(number % 100);\n        roman += string(num10) + int_to_mini_roman(number\
    \ % 10);\n        roman += string(num1);\n    }\n    return roman;\n}", "{\n \
    \   string result;\n    string roman[] = {\"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\",\n                       \"xc\", \"\
    xcc\", \"xci\", \"xii\", \"xiv\", \"xix\"};\n    \n    if (number == 0) {\n  \
    \      return \"0\";\n    }\n    \n    long base = 1;\n    string result = \"\"\
    ;\n    while (number >= base) {\n        result += roman[number % base];\n   \
    \     number /= base;\n        base *= 100;\n    }\n    \n    return result;\n\
    }\n/*", "{\n    string roman_numeral = \"\";\n    if (number <= 0)\n    {\n  \
    \      throw new invalid_argument(\"Invalid input\");\n    }\n    long counter\
    \ = 1;\n    while(counter*number <= 1000)\n    {\n        roman_numeral += chars[(int)counter];\n\
    \        counter++;\n    }\n    roman_numeral += chars[(int)counter];\n    return\
    \ roman_numeral.toLowerCase();\n}", "{\n    string roman = \"\";", "{\n\tint n\
    \ = 0;\n\tint m = number;\n\tstring ret = \"\";", "{\n    int result = 0;\n  \
    \  int counter = 0;\n    long remainder = 0;\n    string roman = \"\";\n    \n\
    \    // we start with the number\n    string tmp = to_string(number);\n    \n\
    \    // we keep adding digits to the roman string\n    while (tmp.length() > 0)\n\
    \    {\n        char digit = tmp[0];\n        \n        counter++;\n        \n\
    \        // we take the remaining digit\n        remainder = remainder % 10;\n\
    \        remainder = 10 - remainder;\n        \n        if (remainder == 0)\n\
    \        {\n            // if the remainder is zero, we add the number's digit\n\
    \            roman += digit;\n            \n            // we subtract it from\
    \ the number's digit\n            remainder = 1;\n        }\n        else\n  \
    \      {\n            // otherwise we add the remainder's digit\n            roman\
    \ += (digit+\"\"+remainder);\n            \n            // we subtract the remainder's\
    \ digit\n            remainder = 0;\n        }\n        \n        tmp = tmp.substr(1);\n\
    \    }\n    \n    // if counter is greater than 1, we add \"i\" to roman\n   \
    \ if (counter > 1)\n        roman += \"i\";\n    \n    return roman;\n}", "{\n\
    \    string mini_roman = \"\";\n    long num_int = 1;\n    int i = 0;\n    while(number\
    \ >= num_int)\n    {\n        mini_roman += chars[number % 10];\n        number\
    \ /= 10;\n    }\n    while(number >= 1)\n    {\n        mini_roman += chars[number\
    \ % 10];\n        number /= 10;\n    }\n    mini_roman += chars[number];\n   \
    \ return mini_roman;\n}", "{\n\tlong temp = number;\n\tstring roman = \"\";\n\t\
    while(temp != 0)\n\t{\n\t\troman += (temp%10) + \"M\";\n\t\ttemp/=10;\n\t}\n\t\
    roman = roman.substr(0, roman.length()-1);\n\treturn roman;\n}\n/*", "{\n    unsigned\
    \ long long intVal = (unsigned long long) number;\n    string result;", "{\n \
    \   string roman = \"\";\n    string alphabet = \"mcdc\";\n    bool end = false;\n\
    \    long num = number;\n    long temp = 1;\n    \n    while(!end)\n    {\n  \
    \      end = true;\n        \n        //get remainder\n        temp = num % 10;\n\
    \        num /= 10;\n        \n        //add to string\n        for(int i = 0;\
    \ i < alphabet.size(); i++)\n        {\n            if(alphabet.at(i) == alphabet[alphabet.size()\
    \ - 1])\n                end = false;\n            roman += alphabet.at(i);\n\
    \        }\n        \n        //add remaining number\n        for(int i = alphabet.size()\
    \ - 1; i >= 0; i--)\n        {\n            roman += (alphabet.at(i) * temp);\n\
    \            temp /= 10;\n        }\n    }\n    return roman;\n}\n</code>\n<|/\
    \ a |>\n<| a dscore=0 tags=recursion,c++,roman |>\nMy solution is like that:\n\
    <code>\nstring getRoman(int number)\n{\n    vector<string> romanNumbers = getRomanNumbers(number);\n\
    \    string result = \"\";\n    int index = 0;\n    \n    for (string romanNumber\
    \ : romanNumbers) {\n        index = romanNumber.size();\n        result += romanNumber.substr(0,\
    \ index);\n        result += romanNumber.substr(index);\n    }\n    \n    return\
    \ result;\n}", "{\n\tstring result = \"\";\n\twhile(number)\n\t{\n\t\tint next_digit\
    \ = number % 10;\n\t\tresult += std.string(int_to_roman(next_digit));\n\t\tnumber\
    \ /= 10;\n\t}\n\treturn result;\n}", "{\n    // write your code in C# here\n \
    \   if (number == 0 || number == 1)\n        return \"x\";\n    \n    int roman[]\
    \ = {1000L, 900L, 500L, 400L, 100L, 90L, 50L, 40L, 10L, 9L, 5L, 4L, 1};\n    int\
    \ num = number;\n    int result = \"\";\n    \n    while (num > 0)\n    {\n  \
    \      int remaining = num % 10;\n        result += char.ToLower(roman[remaining]);\n\
    \        num /= 10;\n    }\n    \n    if (result == \"V\")\n        result = \"\
    v\";\n    else if (result == \"I\")\n        result = \"i\";\n    else if (result\
    \ == \"X\")\n        result = \"x\";\n    else if (result == \"L\")\n        result\
    \ = \"l\";\n    else if (result == \"C\")\n        result = \"c\";\n    else if\
    \ (result == \"D\")\n        result = \"d\";\n    else if (result == \"M\")\n\
    \        result = \"m\";\n    \n    if (result == \"M\")\n        result = \"\
    m\";\n    \n    return result.ToLower();\n}", "{\n    string result;\n    long\
    \ i = number;\n    int n = 1;\n    while (i != 0) {\n        int digit = i % 10;\n\
    \        result += std.typecons.chars[digit];\n        n += 1;\n        i = i\
    \ / 10;\n    }\n    result = result.substr(0, n - 1);\n    result += std.string.uppercase[result.length()];\n\
    \    return result;\n}\n</code>\n<|/ a dscore=0 |>\n<| a |>\nHere's a Python 3\
    \ solution:\n<code>\ndef int_to_roman(number: int) -> str:\n    \"\"\"\n    >>>\
    \ int_to_roman(19L)\n    'xix'\n    >>> int_to_roman(152L)\n    'clii'\n    >>>\
    \ int_to_roman(426L)\n    'cdxxvi'\n    \"\"\"\n    digits = \"M\"\n    roman_numerals\
    \ = []\n    while number > 0:\n        digit = number % 10\n        number //=\
    \ 10\n        if digit != 0:\n            digits = \"D\" + digits\n          \
    \  roman_numerals.append(digit)\n        else:\n            digits = \"C\" + digits\n\
    \            roman_numerals.append(digit)\n    return \"\".join(str(roman_numerals[i\
    \ - 1]) for i in range(1, len(roman_numerals)))", "{\n\tassert(number >= 0 &&\
    \ number <= 1000);\n\t\n\tstring result = \"\";\n\t\n\twhile(number > 1)\n\t{\n\
    \t\tresult += \"i\";\n\t\tnumber -= 1;\n\t}\n\t\n\treturn result;\n}", "{\n  \
    \  vector<int> converted;\n    vector<int> remainder;\n    string result = \"\
    error\";\n    long tmp = number;\n    \n    while(number >= 10000000000000000L\
    \ && remainder.size() == 0)\n    {\n        converted.push_back(0);\n        number\
    \ = number / 10000000000000000L;\n    }\n    \n    while(number >= 10000000000000L\
    \ && remainder.size() == 0)\n    {\n        converted.push_back(0);\n        number\
    \ = number / 10000000000000L;\n    }\n    \n    while(number >= 10000000000L \
    \ && remainder.size() == 0)\n    {\n        converted.push_back(0);\n        number\
    \ = number / 10000000000L;\n    }\n    \n    while(number >= 1000000000L  && remainder.size()\
    \ == 0)\n    {\n        converted.push_back(0);\n        number = number / 1000000000L;\n\
    \    }\n    \n    while(number >= 100000000L  && remainder.size() == 0)\n    {\n\
    \        converted.push_back(0);\n        number = number / 100000000L;\n    }\n\
    \    \n    while(number >= 10000000L  && remainder.size() == 0)\n    {\n     \
    \   converted.push_back(0);\n        number = number / 10000000L;\n    }\n   \
    \ \n    while(number >= 1000000L  && remainder.size() == 0)\n    {\n        converted.push_back(0);\n\
    \        number = number / 1000000L;\n    }\n    \n    while(number >= 100000L\
    \  && remainder.size() == 0)\n    {\n        converted.push_back(0);\n       \
    \ number = number / 100000L;\n    }\n    \n    while(number >= 10000L   && remainder.size()\
    \ == 0)\n    {\n        converted.push_back(0);\n        number = number / 10000L;\n\
    \    }\n    \n    while(number >= 1000L   && remainder.size() == 0)\n    {\n \
    \       converted.push_back(0);\n        number = number / 1000L;\n    }\n   \
    \ \n    while(number >= 100L    && remainder.size() == 0)\n    {\n        converted.push_back(0);\n\
    \        number = number / 100L;\n    }\n    \n    while(number >= 10L     &&\
    \ remainder.size() == 0)\n    {\n        converted.push_back(0);\n        number\
    \ = number / 10L;\n    }\n    \n    while(number >= 1L     && remainder.size()\
    \ == 0)\n    {\n        converted.push_back(0);\n        number = number / 1L;\n\
    \    }\n    \n    if(remainder.size() > 0)\n    {\n        string rem = int_to_mini_roman(remainder[0]);\n",
  "{\n    string roman = \"\";\n    int n = number;\n    long i = 7;\n    \n    while\
    \ (i) {\n        int p = n/i;\n        roman += int_to_mini_roman_digit(p);\n\
    \        i -= p;\n    }\n    roman += int_to_mini_roman_digit(n%10);\n    return\
    \ roman;\n}", "{\n    long result = number;", "{\n\tif (number == 0) return \"\
    0\";\n\tstring result = \"\";\n\tfor (int i = 0; i < 4; i++) {\n\t\tstring current_result\
    \ = mini_roman[number % 1000];\n\t\tnumber = number / 1000;\n\t\twhile (number\
    \ > 0) {\n\t\t\tcurrent_result += mini_roman[number % 100];\n\t\t\tnumber = number\
    \ / 100;\n\t\t}\n\t\tresult += current_result;\n\t}\n\treturn result;\n}", "{\n\
    \    string roman = \"\";\n    long n = (number + \"\");", "{\n    int[][] roman\
    \ = new int[][]{\n    {1000,\"M\",9,\"CM\"},\n    {900,\"D\",8,\"CD\"},\n    {500,\"\
    C\",7,\"XC\"},\n    {400,\"L\",6,\"XL\"},\n    {100,\"X\",5,\"IX\"},\n    {90,\"\
    V\",4,\"IV\"},\n    {50,\"I\",3,\"II\"},\n    {40,\"G\",2,\"III\"},\n    {10,\"\
    F\",1,\"IV\"},\n    {9,\"E\",0,\"II\"}\n    };", "{\n    string roman;", "{\n\
    \    int numeral[100]; // String array to hold the numeral values\n    int i=0,\
    \ j=0, c=0;\n    char roman[100]; // String array to hold the roman numeral equivalent\n\
    \    \n    // Fill in the numeral array\n    while (number > 0)\n    {\n     \
    \   // Add numerals from the array to the result\n        if (number % 10 > 0)\n\
    \        {\n            numeral[i++] = number % 10;\n        }\n        \n   \
    \     // Divide the number by 10\n        number /= 10;\n    }\n    \n    // Fill\
    \ the roman array\n    for (i=0; i<i; i++)\n    {\n        // if the numeral array\
    \ is full and the roman-array is full\n        if (i == numeral.length && c ==\
    \ roman.length)\n        {\n            break;\n        }\n        \n        //\
    \ if there are more numerals in the numeral array than there are roman-\n    \
    \    // characters in the roman-array, fill the roman-array with the remaining\
    \ \n        // numerals\n        if (i < numeral.length)\n        {\n        \
    \    c = c+roman[i-numeral.length];\n            roman[i-numeral.length] = '\\\
    0';\n        }\n        else\n        {\n            // if there is still more\
    \ numerals in the numeral array than there \n            // are roman-characters\
    \ in the roman-array, add the next numeral in the\n            // numeral array\
    \ to the last character in the roman-array\n            roman[c] = numeral[i++];\n\
    \            c = c+1;\n        }\n    }\n    \n    // Return the result as a string\n\
    \    return string(\"MCDXVI\", roman);\n}", "{\n    long romanNumber;\n    string\
    \ numeral;\n    \n    romanNumber = number;\n    numeral = \"\";\n    \n    while(romanNumber>0)\n\
    \    {\n        numeral += romanNumber%10 + 'x';\n        romanNumber /= 10;\n\
    \    }\n    numeral = numeral.toLower();\n    \n    return numeral;\n}", "{\n\
    \    int i = 1;\n    long rem = number % 1000;\n    long numeral = number;\n \
    \   while(true) {\n        if(numeral >= 1000 ) {\n            numeral = numeral\
    \ / 1000 ;\n            i += 1;\n        } else {\n            break;\n      \
    \  }\n    }\n    \n    while(true) {\n        if(numeral >= 100) {\n         \
    \   numeral = numeral / 100 ;\n            i += 1;\n        } else {\n       \
    \     break;\n        }\n    }\n    \n    while(true) {\n        if(numeral >=\
    \ 10) {\n            numeral = numeral / 10 ;\n            i += 1;\n        }\
    \ else {\n            break;\n        }\n    }\n    \n    while(true) {\n    \
    \    if(numeral == 0 ) {\n            break;\n        } else {\n            numeral\
    \ = numeral / 10 ;\n            i += 1;\n        }\n    }\n    \n    while(true)\
    \ {\n        if(numeral == 0 ) {\n            break;\n        } else {\n     \
    \       numeral = numeral % 10 ;\n            i -= 1;\n        }\n    }\n    \n\
    \    if(numeral == 0 ) {\n        numeral = 1 + '0';\n        i -= 1;\n    }\n\
    \    \n    string result = \"\";\n    while(true) {\n        if(numeral == '9'\
    \ ) {\n            break;\n        }\n        result += numeral;\n        numeral\
    \ += 1;\n    }\n    \n    rem = rem + i;\n    rem = rem + numeral;\n    \n   \
    \ return result + mini_roman_number(rem);\n}\n/* \n    Determine if the given\
    \ roman numeral is a valid one.\n    Restrictions: 1 <= num <= 1000 ", "{\n  \
    \  string roman = \"\";\n    \n    if(number < 1) return \"\";\n    if(number\
    \ == 1) return \"x\";\n    if(number % 100 == 0) return roman.substring(0, roman.length()-1)\
    \ + std.string(\"i\"); \n    if(number % 10 == 0) return roman.substring(0, roman.length()-1)\
    \ + std.string(\"i\"); \n    \n    int n1 = (int)(number / 100) % 10;\n    int\
    \ n2 = (int)(number / 10) % 10;\n    int n3 = (int)(number % 10);\n    \n    roman\
    \ += int_to_mini_roman(n1);\n    roman += int_to_mini_roman(n2);\n    roman +=\
    \ int_to_mini_roman(n3);\n    \n    return roman;\n}", "{\n    stringstream out;\n\
    \    int roman[6] = { 1000, 0, 500, 100, 50, 10 };\n    long temp;\n    temp =\
    \ number;\n    out << temp;\n    int counter = 0;\n    for(int i = 0; i < 6; i++)\n\
    \    {\n        temp /= roman[i];\n        while(temp > 0)\n        {\n      \
    \      out << (temp % 10 + counter);\n            temp /= 10;\n            counter++;\n\
    \        }\n    }\n    return out.str();\n}", "{\n\tstring roman;\n\tstring roman_num;\n\
    \troman = \"roman\";\n\troman_num = \"number\";\n\tstring roman_num1;\n\troman_num1\
    \ = \"roman_num\";\n\tint counter;\n\t\n\tfor (counter = 0; counter < 1000; counter++)\
    \ \n\t{\n\t\tstring roman_num2 = to_string(number % 1000); \n\t\tstring roman_num3\
    \ = to_string(number / 1000); \n\t\t\n\t\tif (roman_num3 == \"\") \n\t\t{\n\t\t\
    \tstring roman_num4 = roman_num2;\n\t\t} \n\t\telse \n\t\t{\n\t\t\tstring roman_num4\
    \ = to_string(roman_num3);\n\t\t}", "{\n    long digit;\n    string mini_roman\
    \ = \"\";\n    while (number >= 1000)\n    {\n        digit = number % 1000;\n\
    \        number /= 1000;\n        mini_roman += mini[digit];\n    }", "{\n   \
    \ string roman = \"\";\n    unsigned long long max_number = number;\n    bool\
    \ roman_nums[] = {false, false, false, false};\n    for(unsigned i=0;i<4;i++)\
    \ {\n        if(number >= 1000L) {\n            max_number = number;\n       \
    \     roman_nums[i] = true;\n            number -= 1000L;\n        }\n       \
    \ roman_nums[i] = (number >= 1000L);\n        roman+=int_to_roman(max_number);\n\
    \    }\n    if(roman_nums[0] && !roman_nums[1] && !roman_nums[2] && !roman_nums[3])\
    \ {\n        roman = \"x\";\n    } else if(!roman_nums[0] && roman_nums[1] &&\
    \ !roman_nums[2] && !roman_nums[3]) {\n        roman = \"xii\";\n    } else if(!roman_nums[0]\
    \ && !roman_nums[1] && roman_nums[2] && !roman_nums[3]) {\n        roman = \"\
    xiii\";\n    } else if(!roman_nums[0] && !roman_nums[1] && !roman_nums[2] && roman_nums[3])\
    \ {\n        roman = \"xiv\";\n    }\n    return roman;\n}", "{\n    int result\
    \ = 0, temp;\n    int max_value = 1000, roman_numeral;\n    string roman_numerals;",
  "{\n    long temp, temp2;\n    int i;\n    string result = \"\";\n    string roman\
    \ = number_to_roman(number);\n    temp = roman.find(\"i\");\n    temp2 = roman.find(\"\
    v\");\n    if (temp > 0 && temp2 > 0)\n    {\n        i = temp;\n    }\n    else\
    \ if (temp > 0)\n    {\n        i = temp2;\n    }\n    else\n    {\n        i\
    \ = temp;\n    }\n    for(i = temp+1; i < roman.length(); ++i)\n    {\n      \
    \  temp2 = roman.find(\"i\", i) + 1;\n        result += (roman[i]-roman.find(\"\
    i\", temp2))*10 + roman.find(\"v\", temp2);\n    }\n    return result;\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nThis may help you get started. Using C#. \n<code>\n\
    //First we need to import the necessary packages\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;", "{\n\t\
    string roman =\"\";\n\tint temp;\n\twhile (number>0)\n\t{\n\t\ttemp=number%1000;\n\
    \t\troman = mini_roman_table[temp] + roman;\n\t\tnumber/=1000;\n\t}\n\treverse(roman.begin(),roman.end());\n\
    \treturn roman;\n}\n/*\n    convert an integer into a decimal string of the specified\
    \ length.\n    \n    Parameters:\n    number - the integer to be converted\n \
    \   length - (optional) the desired length of the decimal string.\n    If the\
    \ optional length is omitted, a default of 12 is used.", "{\n    long numDigits\
    \ = to_integer(number);\n    string result = \"\";\n    int i;\n    for(i = 0;\
    \ i < numDigits; i++) {\n        int digit = (int)to_integer(number % 10);\n \
    \       int newDigit = digit - '0';\n        result += romans[newDigit];\n   \
    \     number /= 10;\n    }\n    return result;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=string,roman-numerals,c++ |>\nThis solution is pretty much straight\
    \ forward with no error checking.\n<code>\nstd::string int_to_roman(int num){\n\
    \    std::string s;\n    int sum = 0;\n    while(num > 0){\n        int digit\
    \ = num % 10;\n        s = romans[digit] + s;\n        num /= 10;\n        sum\
    \ += digit;\n    }\n    if(sum > 0)\n        s += romans[sum];\n    return s;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis does not work. Consider the case\
    \ `num` = `100`. In that case the loop would iterate `99` times and add `i` (which\
    \ would result in an empty string), but `i` would never be changed in that loop,\
    \ so the output would be `i`. To solve this problem, you need to keep track of\
    \ the running sum of the digits. This is done in the `sum` variable.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\n#include <iostream>\n#include <string>\n#include <sstream>",
  "{\n    int n = 0;\n    while ((number / ROMAN_BASE[n - 1]) > 0)\n    {\n      \
    \  n++;\n    }\n    string result = \"\";\n    while (n >= 0)\n    {\n       \
    \ result += ROMAN_BASE[n];\n        number -= ROMAN_BASE[n];\n        n--;\n \
    \   }\n    return result;\n}\n</code>\n<|/ a |>\n<| c |>\nThe `std.string` type\
    \ is a `char` array (it has a pointer to its first element), and as such should\
    \ be avoided in favor of character literals (`'0'` instead of `0`), just to be\
    \ sure.\n<|/ c |>\n<| c |>\nI do not have much experience with `std.string`, so\
    \ I just copied his implementation. Your answer doesn't seem to be relevant to\
    \ the question asked, so I did not fix the code myself. It would be better if\
    \ you do so.\n<|/ c |>\n<| c |>\nThe `std.string` type does not contain a pointer\
    \ to its first element, it is a `char` array. As such it should be avoided in\
    \ favor of character literals.\n<|/ c |>\n<| c |>\nYes, it should. I just don't\
    \ have the time to fix the code to make it correct, that's why I didn't do it.\n\
    <|/ c |>\n<| c |>\nYour solution returns \"IX\" rather than \"xix\"\n<|/ c |>\n\
    <| a tags=arrays,c,string dscore=5 |>\nHere's another simple solution without\
    \ using any functions.\n<code>\nchar *int_to_mini_roman(long number)\n{\n    long\
    \ numStr;\n    char str[20];\n    char *ptr;", "{\n    string roman =  \"\";\n\
    \    roman = \"I\";\n    int counter = 1;\n    bool tens = false;\n    if(number\
    \ >= 10)\n    {\n        tens = true;\n        number -= 10;\n    }\n    while(counter\
    \ <= number)\n    {\n        if(counter == 11)\n        {\n            counter\
    \ += 1;\n            roman += \"X\";\n        }\n        else if(counter == 0)\n\
    \        {\n            roman += \"V\";\n        }\n        else if(counter ==\
    \ 1)\n        {\n            roman += \"I\";\n        }\n        else\n      \
    \  {\n            int temp = counter - 1;\n            while(temp > 0)\n     \
    \       {\n                if(temp % 3 == 0)\n                {\n            \
    \        roman += \"IV\";\n                }\n                else if(temp % 3\
    \ == 1)\n                {\n                    roman += \"IX\";\n           \
    \     }\n                else if(temp % 3 == 2)\n                {\n         \
    \           roman += \"XL\";\n                }\n                temp -= 3;\n\
    \            }\n        }\n        counter++;\n    }\n    return roman;\n}", "{\n\
    \    string mini_roman = \"\";\n    long numer = number;\n    long roman = 0;\n\
    \    while (numer > 1000) {\n        numer /= 1000;\n        roman += numer %\
    \ 1000;\n        numer = numer / 1000;\n    }\n    while (numer > 0) {\n     \
    \   roman *= 10;\n        roman += (numer % 10);\n        numer = numer / 10;\n\
    \    }\n    mini_roman = mini_roman.insert(0, roman);\n    return mini_roman;\n\
    }", "{\n    string roman = \"\";\n    for(int i = 0; number > 0; ++i)\n    {\n\
    \        int remainder = number % 1000;\n        roman += (number / 1000) % 10\
    \ + string(\"m\"[remainder - 1]);\n        number /= 1000;\n    }\n    while(roman.back()\
    \ == '0' && roman.size() != 0)\n        roman.pop_back();\n    return roman;\n\
    }\n</code>\n<|/ a |>\n<| a tags=algorithm,number-theory,language-agnostic,roman-numerals,math\
    \ dscore=0 |>\nHere is an example that works in Python with the test cases provided\n\
    <code>\nnum = int(input(\"Enter a positive number : \"))\nroman = \"\"", "{\n\
    \    const int base[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\
    \ };\n    const long reverse[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9,\
    \ 5, 4, 1 };\n    string roman = \"\";", "{\n    string roman = \"xxxvi\";\n \
    \   long counter = number;", "{\n    assert(number >= 1 && number <= 1000);\n\
    \    string roman;\n    while(number >= 1000)\n    {\n        roman += int_to_mini_roman((number\
    \ % 1000L));\n        number /= 1000L;\n    }\n    roman += int_to_mini_roman(number);\n\
    \    return roman;\n}", "{\n\tint counter = 0;\n\tint num = 0;\n\tstring result\
    \ = \"\";\n\tint length = length(number);\n\twhile (counter < length) {\n\t\t\
    int remainder = number % 10;\n\t\tnumber /= 10;\n\t\tnum = remainder * 10 + num;\n\
    \t\tif (num > 1000)\n\t\t\tbreak;\n\t\tresult += string(\"0000\", num);\n\t\t\
    counter++;\n\t}\n\t\n\tif (number == 0)\n\t\tresult = \"\";\n\treturn result;\n\
    }", "{\n    int result = 0;\n    int digit;", "{\n    string roman = \"\";\n \
    \   long n = number;", "{\n    int roman = 0;\n    string roman_numeral = \"\"\
    ;\n    int value = number;\n    int counter = 0;\n    bool isNegative = false;\n\
    \    if(number < 0){\n        counter = 1;\n        number = -number;\n      \
    \  isNegative = true;\n    }\n    while(counter < value){\n        roman_numeral\
    \ += \"m\";\n        counter++;\n    }\n    value = number / 1000;\n    while(counter\
    \ < value){\n        roman_numeral += \"c\";\n        counter++;\n    }\n    value\
    \ = number / 100;\n    while(counter < value){\n        roman_numeral += \"d\"\
    ;\n        counter++;\n    }\n    value = number / 10;\n    while(counter < value){\n\
    \        roman_numeral += \"c\";\n        counter++;\n    }\n    value = number\
    \ / 1;\n    while(counter < value){\n        roman_numeral += \"c\";\n       \
    \ counter++;\n    }\n    if(number < 0){\n        roman_numeral += \"i\";\n  \
    \      counter = 1;\n        number = -number;\n        isNegative = true;\n \
    \   }\n    while(counter < value){\n        roman_numeral += \"v\";\n        counter++;\n\
    \    }\n    if(isNegative){\n        roman_numeral = roman_numeral.substr(0,1);\n\
    \    }\n    return roman_numeral;\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=c#,algorithm,c\
    \ |>\nHere is python code:\n<code>\ndef int_to_mini_roman(number):\n    roman_numeral\
    \ = \"\"", "{\n    if(number <= 5000)\n    {\n        return to_string(number\
    \ / 1000) + int_to_mini_roman((number % 1000L) / 100L);\n    }\n    else if(number\
    \ <= 9999)\n    {\n        if(number % 10000000L == 0)\n        {\n          \
    \  return to_string(number / 100000L) + int_to_mini_roman((number % 100000L) /\
    \ 100000L);\n        }\n        else\n        {\n            long numerator =\
    \ number % 10000000L;\n            long denominator = 10000000L;\n           \
    \ string romNum = int_to_mini_roman(numerator);\n            while(numerator >=\
    \ denominator)\n            {\n                numerator /= denominator;\n   \
    \             romNum += int_to_mini_roman(denominator);\n            }\n     \
    \       return romNum + to_string(numerator);\n        }\n    }\n    else\n  \
    \  {\n        long numerator = number % 100000000L;\n        long denominator\
    \ = 100000000L;\n        string romNum = int_to_mini_roman(numerator);\n     \
    \   while(numerator >= denominator)\n        {\n            numerator /= denominator;\n\
    \            romNum += int_to_mini_roman(denominator);\n        }\n        return\
    \ romNum + to_string(numerator);\n    }\n}", "{\n\tif (number < 0)\n\t\treturn\
    \ \"INVALID\";", "{\n    int a=0, b=0, i=0, x=0;\n    bool neg = false;\n    if(number\
    \ < 0)\n    {\n        neg = true;\n        number = -number;\n    }", "{\n  \
    \  // Initialization:\n    // Since this function will be called many times, we\
    \ keep a local copy of\n    // the string that we are going to return as the result.\n\
    \    string result = \"\";\n    \n    // Special case for the number 0:\n    //\
    \ In this case, just return an empty string:\n    if (number == 0) \n    {\n \
    \       return result;\n    }", "{\n\tstring roman_numeral = \"\";\n\tint i =\
    \ 1;\n\t\n\twhile (number >= i) { roman_numeral += int_to_roman_digit(number /\
    \ i); number %= i; i++; }\n\troman_numeral += int_to_roman_digit(number);\n\t\
    return roman_numeral;\n}", "{\n    int i = 0;\n    string str = \"\";\n    while\
    \ (number >= 1000) {\n        str = mini_roman_to_int(str) + int_to_mini_roman(number\
    \ / 1000L);\n        number = number % 1000L;\n        i++;\n    }\n    if (number\
    \ > 1000) {\n        str = mini_roman_to_int(str) + int_to_mini_roman(number);\n\
    \        i++;\n    }\n    string roman = string(\"M\") + i;\n    for (size_t i\
    \ = 0; i < roman.size(); i++)\n        roman[i] = char(str.at(i));\n    return\
    \ roman;\n}", "{\n    string roman = \"\";\n    if (number == 0)\n    {\n    \
    \    return roman;\n    }\n    \n    while (number >= 1000 || number == 0)\n \
    \   {\n        roman += \"M\";\n        number -= 1000;\n    }\n    \n    while\
    \ (number >= 500 || number == 0)\n    {\n        roman += \"CM\";\n        number\
    \ -= 500;\n    }\n    \n    while (number >= 100 || number == 0)\n    {\n    \
    \    roman += \"D\";\n        number -= 100;\n    }\n    \n    while (number >=\
    \ 50 || number == 0)\n    {\n        roman += \"CD\";\n        number -= 50;\n\
    \    }\n    \n    while (number >= 10 || number == 0)\n    {\n        roman +=\
    \ \"C\";\n        number -= 10;\n    }\n    \n    while (number >= 5 || number\
    \ == 0)\n    {\n        roman += \"X\";\n        number -= 5;\n    }\n    \n \
    \   while (number >= 1)\n    {\n        roman += \"L\";\n        number -= 1;\n\
    \    }\n    \n    while (number == 0)\n    {\n        roman += \"I\";\n    }\n\
    \    return roman;\n}\n</code>\n<|/ a |>\n<| c |>\nHow can you possibly do that?\
    \ This is basically a homework assignment, isn't it?\n<|/ c |>\n<| c |>\nYes it\
    \ is.  I actually wrote the code and it works fine but I'm pretty sure the professor\
    \ did not expect an answer on his own.  But hey, he never said anything about\
    \ expecting anything.  He just said the code is cool.\n<|/ c |>\n<| c |>\nI'm\
    \ pretty sure the professor had a more specific question in mind. Just ask the\
    \ question he has since this is not a generic \"how do i do this\" site. I don't\
    \ even know how to formulate it (as opposed to someone asking me what my \"answer\"\
    \ is).\n<|/ c |>\n<| c |>\nI suspect that he may have not been taught how to do\
    \ this before, but he's been using it since his first homework assignment in class\
    \ so he's probably just not experienced enough to know what's happening behind\
    \ the scenes.\n<|/ c |>\n<| c |>\n, he's been taught in class since the very first\
    \ homework assignment in the 80's.  And he was taught how to do this in C.  He's\
    \ just not taught it at the moment.  He might have a very different level of experience ",
  "{\n    string result = \"\";\n    \n    for(long i = 1; i <= number; i++)\n   \
    \ {\n        if(number == 0)\n            break;\n        char c = char((number\
    \ % 100));\n        number /= 100;\n        switch (c)\n        {\n          \
    \  case 'M':\n                result += char(c);\n                break;\n   \
    \         case 'D':\n            case 'C':\n            case 'L':\n          \
    \  case 'X':\n                result += char(c);\n                break;\n   \
    \         case ' ':\n            case 'I':\n            case 'V':\n          \
    \      result += char(c);\n                break;\n            default:\n    \
    \            if(c == 'M')\n                    result += \"m\";\n            \
    \    else\n                    result += char(c);\n                break;\n  \
    \      }\n    }\n    \n    return result;\n}\n/*", "{\n\tstring roman = \"\";\n\
    \tint counter = 0;\n\twhile (number > 0)\n\t{\n\t\tif (number % 10 == 0)\n\t\t\
    {\n\t\t\tif (counter != 0)\n\t\t\t{\n\t\t\t\troman += counter;\n\t\t\t\tcounter\
    \ = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\troman += number;\n\t\t\t\tnumber\
    \ = number / 10;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcounter += 1;\n\t\t\t\
    number /= 10;\n\t\t}\n\t}\n\treturn roman;\n}\n/*", "{\n    string result = \"\
    error!\";\n    \n    if(number > 1000L)\n    {\n        throw new Exception(\"\
    invalid integer argument\");\n    }\n    \n    switch(number)\n    {\n       \
    \ case 1L: result = \"i\"; break;\n        case 2L: result = \"ii\"; break;\n\
    \        case 3L: result = \"iii\"; break;\n        case 4L: result = \"iv\";\
    \ break;\n        case 5L: result = \"v\"; break;\n        case 6L: result = \"\
    vi\"; break;\n        case 7L: result = \"vii\"; break;\n        case 8L: result\
    \ = \"ix\"; break;\n        case 9L: result = \"x\"; break;\n        case 10L:\
    \ result = \"xi\"; break;\n        case 11L: result = \"xii\"; break;\n      \
    \  case 12L: result = \"xiii\"; break;\n        case 13L: result = \"xiv\"; break;\n\
    \        case 14L: result = \"xv\"; break;\n        case 15L: result = \"xvi\"\
    ; break;\n        case 16L: result = \"xvii\"; break;\n        case 17L: result\
    \ = \"xix\"; break;\n        case 18L: result = \"xx\"; break;\n        case 19L:\
    \ result = \"xxi\"; break;\n        case 20L: result = \"xxii\"; break;\n    \
    \    case 21L: result = \"xxiii\"; break;\n        case 22L: result = \"xxiv\"\
    ; break;\n        case 23L: result = \"xxv\"; break;\n        case 24L: result\
    \ = \"xxvi\"; break;\n        case 25L: result = \"xxvii\"; break;\n        case\
    \ 26L: result = \"xxix\"; break;\n        case 27L: result = \"xxx\"; break;\n\
    \        case 28L: result = \"xxxi\"; break;\n        case 29L: result = \"xxxii\"\
    ; break;\n        case 30L: result = \"xxxiii\"; break;\n        case 31L: result\
    \ = \"xxxiv\"; break;\n        case 32L: result = \"xxxv\"; break;\n        case\
    \ 33L: result = \"xxxvi\"; break;\n        case 34L: result = \"xxxvii\"; break;\n\
    \        case 35L: result = \"xxxix\"; break;\n        case 36L: result = \"xxy\"\
    ; break;\n        case 37L: result = \"xxyy\"; break;\n        case 38L: result\
    \ = \"xxyyi\"; break;\n        case 39L: result = \"xxyyii\"; break;\n       \
    \ case 40L: result = \"xxyyiii\"; break;\n        case 41L: result = \"xxyyiv\"\
    ; break;\n        case 42L: result = \"xxyyv\"; break;\n        case 43L: result\
    \ = \"xxyyvi\"; break;", "{\n    string result = \"\";\n    int tens = 1;\n  \
    \  int hundreds = 0;\n    int thousands = 0;\n    int i = 1;\n    int j;\n   \
    \ bool found;", "{\n    char[] c = new char[13];\n    c[0] = 'm';\n    c[1] =\
    \ 'c';\n    c[2] = 'l';\n    c[3] = 'x';\n    c[4] = 'c';\n    c[5] = 'd';\n \
    \   c[6] = 'i';\n    c[7] = 'x';\n    c[8] = 'l';\n    c[9] = 'i';\n    c[10]\
    \ = 'i';\n    c[11] = 'x';\n    c[12] = 'e';\n    \n    string mini_roman = \"\
    \";\n    int i = 1;\n    while(number > 0){\n        long remainder = number %\
    \ 10;\n        mini_roman += c[i];\n        number /= 10;\n        i++;\n    }\n\
    \    return mini_roman;\n}", "{\n  if(number < 1)\n    return \"0\";\n  if(number\
    \ < 10)\n    return char('0'+number, LOWERCASE);\n  string roman = string(\"MCMXCIV\"\
    ), roman_numeral;\n  while(number > roman.length())\n    roman = roman+roman;\n\
    \  int index = roman.find_first_not_of(roman.begin(), number);\n  roman_numeral\
    \ = \"x\";\n  if(index < roman.length())\n    roman_numeral += roman[index];\n\
    \  number = number - roman.length();\n  while(number > 0)\n  {\n    string roman_subscript\
    \ = char('0'+(number%10), UPPERCASE);\n    roman_numeral += roman_subscript;\n\
    \    number = number / 10;\n  }\n  return roman_numeral;\n}", "{\n    char[] miniRomanArray\
    \ = {'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I' };\n\
    \    return miniRomanArray[(number % 1000) + (number / 1000) % 10];\n}", "{\n\
    \    long roman = 0;\n    \n    if(number == 0)\n        return \"0\";\n    \n\
    \    if(number < 0 || number >= 1000)\n        return \"error\";", "{\n    if(number\
    \ < 0 || number > 1000)\n        return \"\";\n    \n    string result = \"\"\
    ;\n    long roman = number;\n    \n    while(roman > 100) {\n        roman /=\
    \ 100L;\n        result += \"c\";\n    }\n    \n    while(roman > 10) {\n    \
    \    roman /= 10;\n        result += \"x\";\n    }\n    \n    while(roman > 1)\
    \ {\n        roman /= 10;\n        result += \"i\";\n    }\n    \n    if(roman)\n\
    \        result += to_string(roman);\n    \n    result.shrink_to_fit();\n    return\
    \ result;\n}", "{\n    if(number == 0)\n        return \"0\";\n    string roman;\n\
    \    roman = mini_roman[number];\n    while(roman.length() < 4)\n        roman\
    \ = roman + \"x\";\n    return roman;\n}", "{\n    long num_decimals = number\
    \ % 1000;\n    number /= 1000;\n    long num_hundreds = number % 100;\n    number\
    \ /= 100;\n    string mini_roman;\n    mini_roman.clear();\n    mini_roman = int_to_mini_roman(num_hundreds)\
    \ + int_to_mini_roman(num_decimals);\n    mini_roman += int_to_mini_roman(number);\n\
    \    return mini_roman;\n}", "{\n    int remainder, i = 1;\n    string result\
    \ = \"\";\n    while (number > 0)\n    {\n        remainder = (int)(number % 100L);\n\
    \        result += mini_roman[i++];\n        number /= 100L;\n    }\n    if (remainder\
    \ > 0)\n        result += mini_roman[i++];\n    return result.lowercase();\n}\n\
    </code>\n<|/ a |>\n<| a tags=string,c++,roman-numerals,math dscore=3 |>\nHere\
    \ is my solution using c++17's range-based for loop:\n<code>\n#include <iostream>\n\
    #include <string>", "{\n    string result;\n    long remainder;\n    string roman;\n\
    \    long temp;\n    int romanDigits;\n    vector<string> romanNum = mini_roman_to_roman(number);",
  "{\n    string roman = \"\";\n    string mini_roman = \"iix\";\n    long factor;\n\
    \    int i, digit;\n    long num;", "{\n    static auto const roman_base = array::make(\"\
    IxxxVIII\");\n    static auto const roman_base_salary = array::make(\"xxxiii\"\
    );", "{\n    auto num = (int)number;\n    char buf[32];", "{\n    if(number <\
    \ 2L)\n        return string_of_integer(number);", "{\n    long num = number;\n\
    \    string result = \"\";\n    long tens = num % 10;\n    num /= 10;\n    long\
    \ units = 0;\n    long tens_multiple = 0;\n    while (num > 0) {\n        units\
    \ = num % 10;\n        num /= 10;\n        tens_multiple += units;\n        result\
    \ += string_from_long(units);\n        if (units > 0)\n            result += string_from_long(tens_multiple);\n\
    \    }\n    if (tens == 1)\n        return result + \"x\";\n    else if (tens\
    \ == 2)\n        return result + \"ix\";\n    else if (tens == 3)\n        return\
    \ result + \"xix\";\n    else if (tens == 4)\n        return result + \"lix\"\
    ;\n    else if (tens == 5)\n        return result + \"lxix\";\n    else if (tens\
    \ == 6)\n        return result + \"ixl\";\n    else if (tens == 7)\n        return\
    \ result + \"ixlix\";\n    else if (tens == 8)\n        return result + \"lixl\"\
    ;\n    else if (tens == 9)\n        return result + \"lxlix\";\n    else if (tens\
    \ == 0)\n        return result + \"i\";\n    else\n        return result + \"\
    i\";\n}", "{\n    string result = \"\";", "{\n    // todo: implement me\n    string\
    \ romn = \"\";\n    bool first = true;\n    int i = 0;\n    int j = 999;\n   \
    \ while (i != number) {\n        if (j > i) {\n            romn = romn + chars[i\
    \ % 1000];\n        }\n        if (i < number) {\n            romn = romn + chars[(number\
    \ % 1000) / 100];\n        }\n        romn = romn + chars[(number % 100) / 10];\n\
    \        romn = romn + chars[(number % 10) / 1];\n        first = false;\n   \
    \     number = number / 100;\n        i++;\n    }\n    if (first && i == 1) {\n\
    \        romn = chars[0];\n    }\n    return romn;\n}", "{\n    int num_digits\
    \ = math::floor_log2_round_up(number) + 1;\n    string num_roman = to_string(number);",
  "{\n    string roman = \"x\";\n    string mini_roman;\n    \n    int current_digit\
    \ = number % 10;\n    int current_power = number / 10;\n    \n    while (current_power\
    \ > 0)\n    {\n        int current_digit_power = current_digit * current_power;\n\
    \        int next_digit_power = current_power - 1;\n        \n        roman =\
    \ roman.insert(roman.length(), char((current_digit_power + next_digit_power) %\
    \ 10));\n        current_digit = (current_digit_power + next_digit_power) / 10;\n\
    \        current_power = next_digit_power;\n    }\n    \n    mini_roman = roman.insert(0,\
    \ char((current_digit + current_power) % 10));\n    \n    return mini_roman;\n\
    }\n</code>\n<|/ a |>\n<| a dscore=1 |>\n<code>\npublic String intToRoman(int n)\
    \ {\nString romanNum = \"I\";\nString romanNum1 = \"\";", "{\n    // assert(1\
    \ <= number && number <= 1000);\n    stringstream ss;\n    long tmp;\n    long\
    \ num;\n    string roman = \"\";\n    \n    if(number < 1 || number > 1000)\n\
    \        throw runtime_error(\"invalid input number\");\n    \n    tmp = number;\n\
    \    num = number;\n    while(number >= 1000)\n    {\n        num = (tmp - num%1000)/1000\
    \ + 1;\n        tmp -= num%1000;\n        roman += int_to_roman(num);\n    }\n\
    \    \n    if(tmp)\n        roman += int_to_roman(tmp);\n    \n    return roman;\n\
    }", "{\n    string roman = \"\";\n    long counter = 1;\n    while(counter <=\
    \ number) {\n        roman = roman(roman, counter, number, true);\n        counter++;\n\
    \    }\n    return roman;\n}", "{\n    char[] result;", "{\n    string result\
    \ = \"\";\n    long counter = 0;\n    long num = (long) number;", "{\n    string\
    \ roman = \"\";\n    string int_to_roman = \"\";\n    string mini_roman = \"\"\
    ;\n    long i = number;\n    \n    while(i != 0)\n    {\n        int d = i % 10;\n\
    \        roman += d + \"x\";\n        i = i / 10;\n    }", "{\n    long roman_value\
    \ = 0;\n    string result = \"x\";\n    while (number > 0)\n    {\n        roman_value\
    \ += (number % 10);\n        number /= 10;\n    }\n    \n    while (roman_value\
    \ >= 1)\n    {\n        string roman = roman_value_to_roman(roman_value);\n  \
    \      result += roman;\n        roman_value -= 1;\n    }\n    \n    result +=\
    \ \"x\";\n    return result;\n}\n/*", "{\n    string roman = \"\";\n    int roman_num_digits\
    \ = 0;\n    int roman_num_zeroes = 0;\n    int roman_num_leading_zeroes = 0;\n\
    \    int roman_num_negative = 0;\n    int roman_num_total = number;\n    int roman_num_large_enough;\n\
    \    string numerals = \"ix\";\n    string alphabet = \"abc\";\n    string result\
    \ = \"\";\n    \n    while(roman_num_total > 0)\n    {\n        roman_num_large_enough\
    \ = roman_num_total % 1000;\n        roman_num_total = roman_num_total / 1000;\n\
    \        roman_num_digits = roman_num_total % 10;\n        roman_num_leading_zeroes\
    \ = roman_num_digits + 1;\n        roman_num_total /= 10;\n        roman_num_zeroes\
    \ = roman_num_total % 10;\n        roman_num_negative = roman_num_total == 0 ?\
    \ 0 : 1;\n        roman_num_total = roman_num_total * 1000;\n        roman_num_total\
    \ += roman_num_large_enough;\n        roman_num_total += roman_num_negative;\n\
    \        roman_num_total += roman_num_leading_zeroes;\n        roman_num_total\
    \ += roman_num_zeroes;", "{\n    string result;\n    long temp;\n    temp  = number;\n\
    \    number /= 1000;\n    while (number > 0) {\n        result = mini_roman[number\
    \ % 1000] + result;\n        number /= 1000;\n    }\n    if (number > 0 && result\
    \ == \"x\") {\n        result = mini_roman[number % 1000];\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a |>\n<| a tags=algorithm,c |>\nThis works in O(1).\n\
    <code>\nchar *roman2int(char roman)\n{\n    static char int[37] = {'M','D','C','L','X','V','I','I','I','I','I'};\n\
    \    static char roman[37] = \"MCLXVII\";\n    int rnum = (int) (roman[0] - '0');\n\
    \    if (roman == 'I') {\n        return \"\";\n    }\n    int i;\n    for (i\
    \ = 1; i < 37; i++)\n        if ((roman[i] - '0') >= rnum)\n            return\
    \ \"\";\n    if (roman == 'X' || roman == 'L') {\n        int j = 0;\n       \
    \ for (j = i; j < 37; j++)\n            if ((roman[j] - '0') >= rnum)\n      \
    \          break;\n        if (j == 37)\n            return \"\";\n    }\n   \
    \ int k = 0;\n    char *p = &int[i * 3];\n    while (roman > int[k]) {\n     \
    \   p--;\n        k++;\n    }\n    *p = '\\0';\n    while (k > 0) {\n        *p\
    \ = int[k];\n        p--;\n        k--;\n    }\n    return &int[36];\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\nHere's a solution in Python that doesn't use recursion:\n\
    <code>\ndef int_to_roman(n):\n    roman_map = {\n        1000: 'M',\n        900:\
    \ 'CM',\n        500: 'D',\n        400: 'CD',\n        100: 'C',\n        90:\
    \ 'XC',\n        50: 'L',\n        40: 'XL',\n        10: 'X',\n        9: 'IX',\n\
    \        5: 'V',\n        4: 'IV',\n        1: 'I',\n    }", "{\n\t// TODO: implement\
    \ this function\n\tthrow new Not_Implemented(\"implement me!\");\n}\n*/\n}", "{\n\
    \    long i = 1;\n    string result = \"\";\n    while(number > 0)\n    {\n  \
    \      string s = to_string(number%100); //get the hundreds part\n        if(s\
    \ == \"\")\n        {\n            s = \"0\"; //if not, add \"0\" to s\n     \
    \   }\n        s = s.substr(s.length()-2); //remove the last two chars of the\
    \ hundreds part\n        result +=i_to_mini(s.c_str()); //add the hundreds part\
    \ to the result\n        number /= 100;\n        i += 1;\n    }\n    result =\
    \ i_to_mini(result.c_str()); //add the ones part\n    while(result != \"\")\n\
    \    {\n        result  = i_to_mini(result.c_str());\n    }\n    return result;\n\
    }", "{\n  long num_hundreds = number % 100L;\n  long num_tens = num_hundreds /\
    \ 10L;\n  long num_ones = num_tens / 10L;", "{\n    long remainder = number;\n\
    \    string result = \"\";\n    int i; \n    for(i=0; i < 1000; i++) {\n     \
    \   long n = remainder % i;\n        remainder = (remainder - n) / i;\n      \
    \  if(n != 0) {\n            result += (char)('M' + n % 10);\n        }\n    }\n\
    \    if(remainder != 0) {\n        result += (char)('M' + remainder);\n    }\n\
    \    \n    return result;\n}\n</code>\n<|/ a tags=roman-numerals,c |>\n<| c |>\n\
    Your code would fail with `int_to_mini_roman(9L)` since `9L % 1000 = 99`\n<|/\
    \ c |>\n<| a dscore=1 |>\nI agree with other comments. I wrote the below code\
    \ to solve the problem. It will work for numbers up to 999. Although, the problem\
    \ statement doesn't mention how you gonna handle numbers greater then 999. This\
    \ code will work up to 999 though.\n<code>\n#include <stdio.h>\n#include <stdlib.h>",
  "{\n    long roman_numeral[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1, 0 };\n    string result = \"\";\n    \n    for (int i = 0; i < ROMAN_NUMERAL_LENGTH;\
    \ i++) {\n        int digit = number % roman_numeral[i];\n        result += roman_numeral[digit];\n\
    \        number /= roman_numeral[i];\n    }\n    \n    return result;\n}\n</code>\n\
    <|/ a dscore=2 tags=roman-numerals,algorithm,c++ |>\n<| a |>\nHere is my solution:\
    \ \n<code>\n#include<iostream>\n#include<string>", "{\n\tlong tempNum = number;\n\
    \tstring result=\"\";\n\twhile(tempNum!=0){\n\t\tint index = numToBase(tempNum,1,10);\n\
    \t\ttempNum = numToBase(tempNum,10,10);\n\t\tif(index==0){\n\t\t\tresult = result\
    \ + \"i\";\n\t\t}else{\n\t\t\tresult = result + \"v\";\n\t\t\tresult = result\
    \ + index_to_roman[index];\n\t\t}\n\t}\n\treturn result;\n}", "{\n    long i =\
    \ 1;\n    string ret = \"\";\n    while(number > 0)\n    {\n        string roman\
    \ = to_string(number % 10);\n        number/=10;\n        if(roman.find(\"I\"\
    )!=string::npos)\n            roman.insert(0, \"i\");\n        if(roman.find(\"\
    V\")!=string::npos)\n            roman.insert(0, \"v\");\n        if(roman.find(\"\
    X\")!=string::npos)\n            roman.insert(0, \"x\");\n        if(roman.find(\"\
    L\")!=string::npos)\n            roman.insert(0, \"l\");\n        ret += roman;\n\
    \        i++;\n    }\n    return ret;\n}", "{\n    string  result = \"i\";\n \
    \   string suffix;", "{\n    if (number < 1 || number > 999)\n        return \"\
    Invalid\";", "{\n    string rom = \"I\";\n    while (number > 0) {\n        rom\
    \ = rom + std.string(std.math.int2char((number % 1000)));\n        number /= 1000;\n\
    \    }\n    while (rom.size() > 0) {\n        rom[rom.size() - 1] = tolower(rom[rom.size()\
    \ - 1]);\n    }\n    return rom;\n}", "{\n    string result;\n    int num;\n \
    \   \n    num = number;\n    \n    if (number == 0 || number == 1)\n        result\
    \ = char(number);\n    else\n    {\n        bool isDoubleZero = true;\n      \
    \  bool isDoubleOne = true;\n        bool isLastDigitZero = true;\n        bool\
    \ isLastDigitOne = true;\n        int lastDigitIndex;\n        int lastDigit;\n\
    \        int resultDigitCount = 0;\n        int temp;\n        int resultDigits[7];\n\
    \        \n        resultDigits[3] = char(num % 100); \n        resultDigits[2]\
    \ = char(num % 10);\n        \n        num = num /10;\n        resultDigits[4]\
    \ = char(num % 100);\n        resultDigits[5] = char(num % 10);\n        \n  \
    \      num = num /10;\n        resultDigits[6] = char(num % 100);\n        resultDigits[7]\
    \ = char(num % 10);\n        \n        for (int i = 7; i >= 0; i--)\n        {\n\
    \            temp = (resultDigits[i]-'0')*100+resultDigits[i+1]-'0';\n       \
    \     resultDigitCount++;\n            \n            if (temp == 10)\n       \
    \     {\n                isLastDigitZero = false;\n                resultDigitCount--;\n\
    \            }\n            \n            if (temp == 100)\n            {\n  \
    \              isLastDigitOne = false;\n                resultDigitCount--;\n\
    \            }\n            \n            if (temp == 11 && isLastDigitZero)\n\
    \            {\n                isDoubleZero = false;\n            }\n       \
    \     \n            if (temp != 11 && isLastDigitOne)\n            {\n       \
    \         isDoubleOne = false;\n            }\n        }\n        \n        switch\
    \ (resultDigitCount)\n        {\n            case 0:\n                result +=\
    \ \"z\";\n                break;\n            case 1:\n                result\
    \ += \"c\";\n                break;\n            case 2:\n                result\
    \ += \"v\";\n                break;\n            case 3:\n                result\
    \ += \"d\";\n                break;\n            case 4:\n                result\
    \ += \"m\";\n                break;\n            case 5:\n                result\
    \ += \"l\";\n                break;\n            case 6:\n                result\
    \ += \"s\";\n                break;\n            case 7:\n                result\
    \ += \"h\";\n                break;\n        }\n        \n        for (int i =\
    \ 0; i < resultDigitCount; i++)\n        {\n            if (resultDigits[i] ==\
    \ '0')\n            {\n                if (!isDoubleZero)\n                {\n\
    \                    if (isLastDigitOne)\n                    {\n            \
    \            isDoubleOne = false;\n                    }\n                   \
    \ \n                    result += \"c\";\n                    isDoubleZero = true;\n\
    \                }\n                \n                else if (isLastDigitZero)\n\
    \                {\n                    isDoubleZero = false;\n              \
    \      result += \"c\";\n                    isLastDigitZero = true;\n       \
    \         }\n            }\n            \n            else if (resultDigits[i]\
    \ == '1')\n            {\n                if (!isDouble", "{\n\tstring mini_roman\
    \ = \"\";\n\tchar letters[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\tlong numToUse\
    \ = number;", "{\n    long i = 0;\n    string s = \"\";\n    while(number >= (long)romanNumerals[i])\n\
    \    {\n        s += romanNumerals[i];\n        number -= (long)romanNumerals[i];\n\
    \        i++;\n    }\n    \n    while(number >= (long)romanNumerals[i])\n    {\n\
    \        number -= (long)romanNumerals[i];\n        i++;\n    }\n    s += romanNumerals[i];\n\
    \    \n    return s;\n}", "{\n    return roman[number];\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=0 |>\nHere's a simple solution with only basic string methods:\n\
    <code>\npublic string Roman(long n)\n{\n    var ints = n.ToString().Where(char.IsDigit).ToArray();",
  "{\n\tint num = (int)number;", "{\n    int remainder = 0;\n    string roman = \"\
    \";\n    int n = number;", "{\n    static char[] _digits = { 'i', 'x', 'c', 'd',\
    \ 'v' };\n    int i;\n    char[] mini_roman = new char[number];\n    mini_roman[0]\
    \ = '\\0';\n    if (number <= 0)\n        return \"\";\n    for (i = 1; i <= number\
    \ / 1000; i++) {\n        mini_roman[i] = 'm';\n    }\n    while (number >= 1000\
    \ && i > 0) {\n        mini_roman[--i] = 'k';\n    }\n    while (number >= 100)\
    \ {\n        mini_roman[--i] = 'c';\n        number -= 100;\n    }\n    while\
    \ (number >= 10) {\n        mini_roman[--i] = 'l';\n        number -= 10;\n  \
    \  }\n    while (number >= 1) {\n        mini_roman[--i] = _digits[number % 10];\n\
    \        number /= 10;\n    }\n    return string(mini_roman);\n}\n</code>\n<|/\
    \ a tags=c,arrays |>\n<| c |>\nI liked this answer but for me it failed at numbers\
    \ starting with 0, I changed the last loop to this: `while (number >= 10) {\n\
    \        mini_roman[--i] = _digits[number % 10];\n        number /= 10;\n    }\n\
    \    mini_roman[--i] = '0';`\n<|/ c |>\n<| c |>\nNice catch. Fixed it.\n<|/ c\
    \ |>\n<| c |>\nThank you for posting your answer! Please be sure to read [How\
    \ to Answer](https://stackoverflow.com/help/how-to-answer), including the links\
    \ at the bottom of the page, and try to provide a nice description of how your\
    \ code solves the problem, not just give the code.\n<|/ c |>\n<| c |>\nI changed\
    \ it again to include all changes. I believe this was the only change that was\
    \ needed. Should I remove the old answer?\n<|/ c |>\n<| c |>\nI suppose you can\
    \ remove it, I just wanted to give you a heads up. :)\n<|/ c |>\n<| a |>\n<code>",
  "{\n    string roman;\n    int   roman_value;", "{\n    long remainder = 0;\n  \
    \  string roman = \"\";\n    int digit;\n    string int_to_mini_roman(long number)\
    \ \n    {\n        string roman = \"\";\n        int digit;\n        string int_to_mini_roman(long\
    \ number) \n        {\n            while (number > 0)\n            {\n       \
    \         digit = number % 10;\n                roman = char_string[digit] + roman;\n\
    \                number /= 10;\n            }\n            return roman;\n   \
    \     }\n        return roman;\n    }\n}\n</code>\nThis code does not do exactly\
    \ what you want, but it works.  You will still have to figure out how to reverse\
    \ it.  Hope this helps!\n<|/ a tags=string,c++,roman-numerals,math |>\n<| c |>\n\
    I haven't tested it, but I wouldn't be surprised if it just added the leading\
    \ zeros.  That would mess things up anyway.  So you'd have to either reverse it\
    \ or remove them.  I'll do some testing in the meantime.  Sorry.\n<|/ c |>\n<|\
    \ c |>\nHi thank you for you answer, I'm still a little confused about what exactly\
    \ you did and what exactly you didn't... Could you please explain it?\n<|/ c |>\n\
    <| c |>\nI added some comments to my code.  It isn't very well documented, but\
    \ hopefully it will help you understand what's going on.  Good luck!\n<|/ c |>\n\
    <| c |>\nHi, thank you for the help, but I still don't understand it at all...\
    \ Could you please explain your code a little bit?\n<|/ c |>\n<| c |>\nI updated\
    \ the answer to provide you with a link to an example that I tried.  The comments\
    \ are in the code.  I hope this helps.\n<|/ c |>\n<| a |>\nHere's a quick solution\
    \ that only involves one loop in C++:\n<code>\nstd::string int_to_mini_roman(unsigned\
    \ long int num) {\n    std::string roman = \"\";\n    unsigned long int remainder\
    \ = num;\n    for(int i = 4; i <= 1; ++i) {\n        remainder /= 10;\n      \
    \  roman += char_string[remainder%10] + '0' * (i-1);\n        remainder /= 10;\n\
    \    }\n    return roman;\n}\n</code>\n<|/ a dscore=1 tags=string,c++,roman-numerals,math\
    \ |>\n<| c |>\nThanks, this looks really good, but I think it has to be modified\
    \ so that it works with the long ", "{\n    long base = 1;\n    string roman =\
    \ \"\";", "{\n    string roman;\n    int remainder;\n    long remainder_long;\n\
    \    long quotient;\n    long reminder;\n    bool negative;\n    int i = 0;\n\
    \    string roman_conversion = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"\
    L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n    string roman_numerals\
    \ = {\"M\", \"D\", \"C\", \"L\", \"X\"};", "{\n\tint roman = 0;\n\tstring romanString;\n\
    \t\n\twhile(number > 0)\n\t{\n\t\troman += (number % 100) * 1000;\n\t\tnumber\
    \ = number / 100;\n\t}\n\t\n\twhile(roman > 0)\n\t{\n\t\tromanString += int_to_roman(roman\
    \ % 1000);\n\t\troman = roman / 1000;\n\t}\n\t\n\treturn romanString;\n}", "{\n\
    \    int val = (int)number;\n    char result[] = \"\";\n    for(int i = intDigits[val]-1;\
    \ i >= 0; i--){\n        if(number % intDigits[i] == 0){\n            result +=\
    \ miniIntToRoman[i];\n            number = number/intDigits[i];\n        }else{\n\
    \            break;\n        }\n    }\n    if(number != 0){\n        result +=\
    \ miniIntToRoman[intDigits[val]-1];\n    }\n    return stringLowerCase(result);\n\
    }\n/*", "{\n  long roman = 0;\n  long decimal = 0;\n  int count = 0; \n  string\
    \ roman =null;\n  bool first = true;\n  int i = 0;", "{\n    // base case: when\
    \ num is 0, return an empty string\n    if(number == 0)\n        return \"\";",
  "{\n\tint x = number;\n\tstringstream result;\n\tresult << \"i\";\n\tfor (int i=1;\
    \ i<=x/100; i++)\n\t{\n\t\tif (x%100==0)\n\t\t{\n\t\t\tif (x%10==0)\n\t\t\t{\n\
    \t\t\t\tresult << \"v\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult << \"x\"\
    ;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult << \"c\";\n\t\t}\n\t}\n\twhile\
    \ (x > 0)\n\t{\n\t\tresult << int_to_roman(x%1000);\n\t\tx /= 1000;\n\t}\n\treturn\
    \ result.str();\n}", "{\n    // Write your code here\n    \n    string result\
    \ = \"\";\n    if (number == 0)\n        return result;\n    int num[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90};\n\
    \    int i = 0;\n    while (number > 0){\n        result = (num[i] % 10) + result;\n\
    \        number = number / 10;\n        i++;\n    }\n    \n    return result;\n\
    }", "{\n    long x = number;\n    string result = \"\";\n    while (x!=0)\n  \
    \  {\n        if (x%100>0)\n        {\n            result = result + \"M\";\n\
    \        }\n        else if (x%10>0)\n        {\n            result = result +\
    \ \"CM\";\n        }\n        else if (x%5>0)\n        {\n            result =\
    \ result + \"D\";\n        }\n        else if (x%4>0)\n        {\n           \
    \ result = result + \"CD\";\n        }\n        else if (x%3>0)\n        {\n \
    \           result = result + \"C\";\n        }\n        else if (x%2>0)\n   \
    \     {\n            result = result + \"X\";\n        }\n        else if (x%1>0)\n\
    \        {\n            result = result + \"L\";\n        }\n        else if (x%0>0)\n\
    \        {\n            result = result + \"XC\";\n        }\n        else\n \
    \       {\n            result = \"ERROR\";\n        }\n        x = x/100;\n  \
    \  }\n    return result;\n}\n</code>\n<|/ a dscore=3 |>\n<| a |>\nThe answer from\
    \ user618841 is great, but I had trouble with the fact that C++ doesn't have an\
    \ unsigned integer type. Here's a solution that's a bit more concise. \n<code>\n\
    function int int_to_mini_roman(unsigned long num)\n{\n    int ret=1;\n    while(num){ret*=10,num/=10;ret+=num%10}\n\
    \    return ret;\n}\n</code>\n<|/ a dscore=3 tags=algorithm,c++,roman-numerals,math\
    \ |>\n<| c |>\nThis is not really roman-numeral, it's just counting digits. You\
    \ could write it as `int ret=1;while(num){ret*=10,num/=10;ret+=num%10}return ret;`\
    \ if you wanted.\n<|/ c |>\n<| c |>\nSure, I thought I might make an edit to make\
    \ it more \"roman-numeral\". Thanks though.\n<|/ c |>\n<| a dscore=2 |>\nHere\
    \ is a solution written in python that doesn't use recursion.\n<code>\ndef int_to_mini_roman(num):\n\
    \    # Return 0 if the num is 0\n    if num == 0:\n        return '0'\n    else:\n\
    \        roman = 'I'\n        while num > 0:\n            if num % 100 == 0:\n\
    \                roman += 'M'\n            elif num % 10 == 0:\n             \
    \   roman += 'CM'\n            elif num % 5 == 0:\n                roman += 'D'\n\
    \            elif num % 4 == 0:\n                roman += 'CD'\n            elif\
    \ num % 3 == 0:\n                roman += 'C'\n            elif num % 2 == 0:\n\
    \                roman ", "{\n    string result=\"\";\n    long temp=number;\n\
    \    while(temp>0)\n    {\n        result+=(char)((temp%10)+'a');\n        temp=temp/10;\n\
    \    }\n    return tolower(result);\n}", "{\n\tstring mini_roman = \"\";\n\tlong\
    \ number = number;\n\tlong last = 0;\n\tlong i = 1;", "{\n    long base = 1000L;\n\
    \    int factor = 1;\n    string result = \"\";\n    int temp = 0;\n    \n   \
    \ while(number > base)\n    {\n        number /= base;\n        factor += 1;\n\
    \        base += 10;\n    }", "{\n  long x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15;",
  "{\n    string roman = \"\";\n    int base = 1;\n    while(number / base != 0) {\n\
    \        roman = roman.insert(0, (number/base%10) + 64);\n        base = base\
    \ * 10;\n    }\n    return roman;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
