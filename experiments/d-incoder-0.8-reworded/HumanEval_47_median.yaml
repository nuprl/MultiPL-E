name: HumanEval_47_median
language: d
prompt: "import std.math;\n/*\nReturn median of elements in the array l.\n    >>>\
  \ median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L,\
  \ 20L])\n    15.0\n    \n*/\nfloat median(long[] l) \n"
tests: "unittest\n{\n    alias candidate = median;\n\n    assert(candidate([3L, 1L,\
  \ 2L, 4L, 5L]) == 3L);\n    assert(candidate([-10L, 4L, 6L, 1000L, 10L, 20L]) ==\
  \ 8.0);\n    assert(candidate([5L]) == 5L);\n    assert(candidate([6L, 5L]) == 5.5);\n\
  \    assert(candidate([8L, 1L, 3L, 9L, 9L, 2L, 7L]) == 7L);\n}\nvoid main(){}"
completions: ["{\n    return std.math.sort.quickSelect(l, l, l.length/2, std.math.Median);\n\
    }", "{\n    int mid = l.length / 2;\n    if (l.length%2 == 0) \n        return\
    \ std.distance(l, 0, mid);\n    else \n        return std.distance(l, mid, l.length);\n\
    }", "{\n    sort(l);\n    return (l[(l.length-1)/2]);\n}", "{\n    int n= l.length();\n\
    \    if (n < 1) return 0;\n    float m= (float)n/(float)2;\n    float s=0;\n \
    \   for (int i=0; i<n; i++) {\n        s += l[i];\n    }\n    s = s/(float)n;\n\
    \    float x= (s-m*s)/2;\n    return x;\n}\n</code>\n<|/ a dscore=0 tags=java,median,arrays\
    \ |>\n<| c |>\nPlease add some explanation to your answer. As it is now it can\
    \ be misinterpreted and therefore deleted.\n<|/ c |>\n<| a dscore=0 |>\nIf you're\
    \ looking for a simple way to compute the median, here it goes:\n<code>\npublic\
    \ double Median(int[] x)\n{\n    int middle = x.Length / 2;\n    int i = (int)middle;\n\
    \    int j = x.Length - 1;\n    double m = (x[i] + x[j]) / 2;\n    while (i <\
    \ j)\n    {\n        while ((x[i] + x[j]) > m)\n        {\n            i++;\n\
    \            j--;\n        }\n        while ((x[i] + x[j]) < m)\n        {\n \
    \           j++;\n            i++;\n        }\n        if (i == j)\n        {\n\
    \            return (x[i] + x[j]) / 2;\n        }\n    }\n    return m; //If i\
    \ and j aren't equal\n}\n</code>\n<|/ a tags=java,median,arrays |>\n<| a |>\n\
    I see other posts are already answering your question but, I will add another\
    \ answer as I find this one to be a little easier. \nI am not 100% sure that this\
    \ is the best way but it seems like it works the way I wanted it to.\n<code>\n\
    import java.util.Arrays;\nimport java.util.Random;", "{\n    int n = l.length\
    \ ;\n    if (n>1)\n    {\n        int k = (n - 1) / 2;\n        return std.math.max(l[k],\
    \ l[k+1]);\n    }\n    else \n        return l[0];\n}", "{\n    int m = l.size();\n\
    \    if (m % 2 == 0) return l[m / 2];\n    else return (float(l[(m - 1) / 2])\
    \ + float(l[(m + 1) / 2])) / 2.0;\n}\n/*\nReturn minimum of elements in the array\
    \ l.\n    >>> min([1L, 2L, 3L, 4L, 5L])\n    1L\n    >>> min([-10L, 4L, 6L, 1000L,\
    \ 10L, 20L])\n    -10L\n*/\nlong min(long[] l) \n{\n    int m = l.size();\n  \
    \  if (m == 0) return 0L;\n    return l[0];\n}\n/*\nReturn maximum of elements\
    \ in the array l.\n    >>> max([1L, 2L, 3L, 4L, 5L])\n    5L\n    >>> max([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    1000L\n*/\nlong max(long[] l) \n{\n    int m\
    \ = l.size();\n    if (m == 0) return 0L;\n    return l[m-1];\n}\n/*\nReturn sum\
    \ of elements in the array l.\n    >>> sum([1L, 2L, 3L, 4L, 5L])\n    6L\n   \
    \ >>> sum([-10L, 4L, 6L, 1000L, 10L, 20L])\n    10000L\n*/\nlong sum(long[] l)\
    \ \n{\n    int m = l.size();\n    long sum = 0;\n    for (int i = 0; i < m; i++)\
    \ sum += l[i];\n    return sum;\n}\n/*\nReturn standard deviation of elements\
    \ in the array l.\n    >>> std.dev([1L, 2L, 3L, 4L, 5L])\n    2.0\n    >>> std.dev([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    10.5\n*/\ndouble std.dev(long[] l) \n{\n    long\
    \ m = l.size();\n    if (m == 0) return 0L;\n    long sum = 0;\n    double average;\n\
    \    for (int i = 0; i < m; i++) sum += l[i];\n    average = (double)sum / m;\n\
    \    int n = m;\n    double squareDiff = 0;\n    for (int i = 0; i < n; i++) {\n\
    \        squareDiff += (double)((l[i] - average) * (l[i] - average));\n    }\n\
    \    return squareDiff / (n - 1);\n}\n/*\nReturn cumulative sum of elements in\
    \ the array l.\n    >>> csum([1L, 2L, 3L, 4L, 5L])\n    1L\n    >>> csum([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    11L\n*/\nlong csum(long[] l) \n{\n    int m =\
    \ l.", "{\n    int i, m = 0, n = l.length;\n    float x, m;\n    \n    if (n ==\
    \ 0) {\n        x = -1;\n    }\n    else \n    {\n        m = l[n-1];\n      \
    \  for (i = n-2; i >= 0; i--) \n        {\n            m = l[i];\n           \
    \ if (m > m) \n            {\n                x = m;\n                m = i;\n\
    \            }\n        }\n    }\n    return x;\n}", "{\n    sort(l);\n    return\
    \ l[l.length/2]; \n}", "{ \n  sort(l, l.length);\n  return l[(l.length-1)/2];\n\
    }", "{\n    long length = l.length;\n    if (length % 2 == 0)\n    {\n       \
    \ double pivot;\n        int center = length /2;\n        if (length%2 == 1)\n\
    \            pivot = l[center];\n        else\n        {\n            pivot =\
    \ std.math.max(l[center-1],l[center]);\n        }\n        for(int i = center\
    \ + 1; i < length; i++)\n        {\n            if (l[i] < pivot)\n          \
    \  {\n                long temp = l[i];\n                l[i] = l[i-1];\n    \
    \            l[i-1] = temp;\n            }\n        }\n        return l[center];\n\
    \    }\n    else \n    {\n        double pivot = std.math.min(l[center-1],l[center]);\n\
    \        for(int i = center + 1; i < length; i++)\n        {\n            if (l[i]\
    \ > pivot)\n            {\n                long temp = l[i];\n               \
    \ l[i] = l[i-1];\n                l[i-1] = temp;\n            }\n        }\n \
    \       return l[center];\n    }\n}", "{\n\tlong med;\n\tint\ti;\n\t\n\tmed =\
    \ l[0];\n\tfor (i = 1; i < l.length; i++) {\n\t\tmed = (med + l[i]) / 2;\n\t}\n\
    \treturn (float) med;\n}", "{\n    sort(l);\n    long middle = l[(l+1)/2-1];\n\
    \    int count = 0;\n    for(int i = 0; i < l.length; ++i)\n    {\n        long\
    \ item = l[i];\n        if (item > middle) \n        {\n            return l[i];\n\
    \        }\n        count++;\n        if (count > l.length/2) return l[i];\n \
    \   }\n    return l[l.length/2];\n}\n/*\n    Return mean of elements in array\
    \ l.\n    >>> mean([4L, 3L, 2L, 1L, 10L])\n    2.0\n    >>> mean([4L, 3L, 2L,\
    \ 10L, 10L])\n    3.0\n    \n*/\nfloat mean(long[] l) \n{\n    long sum=0;\n \
    \   for(int i = 0; i < l.length; ++i) \n    {\n        sum += l[i];\n    }\n \
    \   return sum / l.length;\n}\n/*\n    Return mean of elements in array l.\n \
    \   >>> mean([4L, 3L, 2L, 1L, 10L])\n    2.0\n    >>> mean([4L, 3L, 2L, 10L, 10L])\n\
    \    3.0\n    \n*/\nfloat mean(float[] l) \n{\n    long sum=0;\n    for(int i\
    \ = 0; i < l.length; ++i) \n    {\n        sum += l[i];\n    }\n    return sum\
    \ / l.length;\n}\n/*\n    Return median of elements in the array l.\n    >>> median([3L,\
    \ 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n\
    \    15.0\n    \n*/\nfloat median(float[] l) \n{\n    sort(l);\n    float middle\
    \ = l[(l+1)/2-1];\n    int count = 0;\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        float item = l[i];\n        if (item > middle) \n        {\n \
    \           return l[i];\n        }\n        count++;\n        if (count > l.length/2)\
    \ return l[i];\n    }\n    return l[l.length/2];\n}\n/*\n    Return sum of elements\
    \ in array l.\n    >>> sum([3L, 1L, 2L, 4L, 5L])\n    7L\n    >>> sum([3L, 1L,\
    \ 2L, 4L, 5L])\n    7L\n    \n*/\nlong sum(long[] l) \n{\n    long sum = 0;\n\
    \    for(int i = 0; i < l.length; ++i) \n    {\n        sum += l[i];\n    }\n\
    \    return sum;\n}\n/*\n    Return sum of elements in array l.\n    >>> sum([3L,\
    \ 1L, 2L, 4L, 5L])\n    7L\n    >>> sum([3L, 1L, 2L, 4L, ", "{\n\tfloat sum =\
    \ 0;\n\tfloat n = 0;", "{\n\tlong n;\n\tint i, m, k, count=0;\n\t\n\tn = l.length;\n\
    \tm = n/2;\n\t\n\tif (n%2==0) {\n\t\tif (l[m]<l[m+1]) {\n\t\t\treturn l[m];\n\t\
    \t} else {\n\t\t\treturn l[m+1];\n\t\t}\n\t} else {\n\t\tif (l[m]<l[m-1]) {\n\t\
    \t\treturn l[m];\n\t\t} else {\n\t\t\treturn l[m-1];\n\t\t}\n\t}\n}", "{\n\tint\
    \ n = l.length;\n\tif (n%2 == 1) return (l[n/2] + l[n/2 - 1])/2.0;\n\telse return\
    \ l[n/2];\n}", "{\n  int m = l.length;\n  if(m == 0) return 0L;", "{\n\tif (l.length\
    \ < 2)\n\t\treturn l[0];\n\tfloat f = (l[0] + l[1]) / 2.0f;\n\tint i = 0;\n\t\
    while (!(i == 0 || l[i] <= f))\n\t\ti++;\n\treturn l[i];\n}", "{\n\tlong i, mid,\
    \ x = std.max(l);\n\tmid = std.length(l) / 2L;\n\tif (mid % 2 == 0)\n\t{\n\t\t\
    for (i = 0; i <= mid; i++)\n\t\t\tl[i] -= std.min(l[i + (mid - i)/2L]);\n\t\t\
    x = std.max(l);\n\t}\n\telse\n\t{\n\t\tx -= std.min(l[std.length(l) / 2 - 1L]);\n\
    \t}\n\tfor (i = mid; i > 0; i--)\n\t{\n\t\tl[i] = std.min(l[i - 1L]);\n\t}\n\t\
    return x;\n}", "{\n\tlong sorted = std.Arrays.sort(l);\n\treturn std.Arrays.mid(l,\
    \ sorted/2);\n}\n/*\nReturn median of elements in l.\n    \n    >>> median([3L,\
    \ 1L, 2L, 4L, 5L])\n    3L\n    \n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n\
    \    15.0\n    \n*/\nfloat median(long[] l) \n{\n\treturn std.Arrays.mid(l, l\
    \ / 2);\n}", "{\n\tint sz = l.size();\n\tif (sz <= 1) return l[0];\n\tif (sz ==\
    \ 2) return (float)l[0] + (float)l[1]; // median(x+y)\n\tfloat m = (float)l[sz/2-1];\n\
    \tfor (int i = 0; i < (sz-1)/2 + 1; i++)\n\t{\n\t\tm = std.max(m, (float)l[i]);\n\
    \t}\n\treturn m;\n}\n#endif\n/*\nReturn median of elements in array l. \n\tNote:\
    \ If l is empty or contains only one element, then return \n\tthe smallest possible\
    \ number. \n*/\nfloat median(long[] l) \n{\n\tsort(l);\n\tint sz = l.size();\n\
    \tif (sz <= 1) return l[0];\n\tif (sz == 2) return (float)l[0] + (float)l[1];\
    \ // median(x+y)\n\tfloat m = (float)l[sz/2-1];\n\tfor (int i = 0; i < (sz-1)/2\
    \ + 1; i++)\n\t{\n\t\tm = std.max(m, (float)l[i]);\n\t}\n\treturn m;\n}", "{\n\
    \    long n = l.length;\n    if (n < 1) throw new IllegalArgumentException();\n\
    \    long mid = n / 2;\n    if (n == 1) return l[0];\n    \n    long sum = 0;\n\
    \    long min = 0;\n    long max = l;\n    \n    while (mid != 0) {\n        sum\
    \ += max;\n        min = Math.min(min, mid);\n        if (max < mid) break;\n\
    \        max = mid;\n        mid = (max - min) / 2;\n    }\n    return (double)\
    \ sum / n;\n}", "{\n    long length = l.length;\n    long half = length/2;\n \
    \   long sum = std.sum(l);\n    int mid = sum / half;\n    float x = mid;\n  \
    \  for (int i=0;i < length;i++) {\n        x = std.max(x, l[i]);\n    }\n    return\
    \ x;\n}\n/*\nFind the minimum element in array l.\n    >>> min([3, 1, 2, 4, 5])\n\
    \    1\n    \n*/\nfloat min(float[] l) \n{\n    float x = l[0];\n    for (int\
    \ i=0;i < l.length;i++) {\n        x = std.min(x, l[i]);\n    }\n    return x;\n\
    }\n/*\nFind the maximum element in array l.\n    >>> max([3, 1, 2, 4, 5])\n  \
    \  5\n    \n*/\nfloat max(float[] l) \n{\n    float x = l[0];\n    for (int i=0;i\
    \ < l.length;i++) {\n        x = std.max(x, l[i]);\n    }\n    return x;\n}\n\
    /*\nFind the sum of the elements in the array l.\n    >>> sum([3, 1, 2, 4, 5])\n\
    \    7\n    \n*/\nlong sum(float[] l) \n{\n    long sum = 0;\n    for (int i=0;i\
    \ < l.length;i++) {\n        sum += l[i];\n    }\n    return sum;\n}\n/*\nCompute\
    \ the variance of the elements in the array l.\n    >>> variance([3, 1, 2, 4,\
    \ 5])\n    2.0\n    \n*/\nfloat variance(float[] l) \n{\n    long n = l.length;\n\
    \    float sum = 0;\n    for (int i=0;i < n;i++) {\n        float x = l[i];\n\
    \        sum += x*x;\n    }\n    float mean = sum / n;\n    float sum2 = 0;\n\
    \    for (int i=0;i < n;i++) {\n        float x = l[i];\n        float x2 = x*x;\n\
    \        sum2 += x2;\n    }\n    return sum2 - (n*mean*mean);\n}\n/*\nCompute\
    \ the standard deviation of the elements in the array l.\n    >>> stddev([3, 1,\
    \ 2, 4, 5])\n    1.118033988749895\n    \n*/\nfloat stddev(float[] l) \n{\n  \
    \  float mean = mean(l);\n    float variance = variance(l);\n    return (float)Math.sqrt(variance);\n\
    }\n/*\nCompute the k-th percentile of the elements in the array l.\n    >>> kth([3,\
    \ 1, 2, 4, 5], 3)\n    3.0\n    \n*/\nfloat kth(float[] l, int k) \n{\n    float\
    \ x = l[0];\n    for (int i=0;i < k;i++) {\n        x = std.max(x, l[i]);\n  \
    \  }\n    return x;\n}\n/*\nReturn a list of all elements in the array l that\
    \ satisfy a predicate p.\n    For example,\n    >>> ", "{\n\tlong med = (float)0.0;\n\
    \tint i;\n\tfor (i = 1; i < l.length; ++i)\n\t{\n\t\tif (l[i] > l[med + 1])\n\t\
    \t{\n\t\t\tmed = i;\n\t\t}\n\t}\n\t\n\treturn (float)(l[med]);\n}", "{\n    long\
    \ hi = std.highest(l);\n    long lo = std.lowest(l);\n    \n    if (lo == hi)\
    \ {\n        return lo;\n    }\n    \n    long m = (lo + hi) / 2;\n    \n    if\
    \ (m < 1) {\n        return lo;\n    }\n    \n    long t = std.median(l);\n  \
    \  \n    if (t < lo) {\n        return m;\n    }\n    \n    return m;\n}", "{\n\
    \    long l, l, mid, count;\n    l = (long) l / 2;\n    mid = (long) l / 2;\n\
    \    count = 0;\n    while(count < l - 1) \n    {\n        mid = (long) l / 2;\n\
    \        if(m[mid] > m[mid + 1]) \n        {\n            l = mid - 1;\n     \
    \   }\n        else \n        {\n            count++;\n        }\n    }\n    return\
    \ m[l];\n}\n</code>\n<|/ a dscore=2 tags=arrays,sorting,algorithm,c |>\n<| c |>\n\
    For long integers, this only works with positive numbers, otherwise you might\
    \ end up with `l == 0`.\n<|/ c |>\n<| c |>\nYes, you're right. I missed the case\
    \ of negative numbers and assumed a general array. I edited my answer accordingly\
    \ and added some code to handle negative numbers as well.\n<|/ c |>\n<| a |>\n\
    A slightly more efficient method is to sort first in O(nlogn) time and then use\
    \ binary search to find the median. The time complexity of finding the median\
    \ in binary search is O(logn) since it consists of finding mid points in the array.\n\
    <|/ a tags=arrays,sorting,algorithm,c dscore=1 |>\n<| c |>\nCan you please elaborate\
    \ on how binary search works? Is it similar to what we do in selection sort where\
    \ we find middle element and swap it with the element at its position and so on?\n\
    <|/ c |>\n<| c |>\nYes, binary search works in similar manner as selection sort\
    \ and finds the element in the middle of the array.\n<|/ c |>\n<| a |>\nFor a\
    \ large array you might not need to sort the entire array. You can use selection\
    \ sort and find the median in O(n log n) time.\n<|/ a tags=arrays,sorting,algorithm,c\
    \ dscore=1 |>\n<| c |>\nCan you please elaborate on how binary search works? Is\
    \ it similar to what we do in selection sort where we find middle element and\
    \ swap it with the element at its position and so on?\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\n#define swap(arr, i, j) {\n    long temp = arr[i];\n    arr[i] =\
    \ arr[j];\n    arr[j] = temp;\n}", "{\n\tint n = l.size();\n\tfloat median;\n\t\
    \n\tif(n <= 1)\n\t\tmedian = l[0];\n\telse {\n\t\tif(n%2 == 0) {\n\t\t\tmedian\
    \ = ((float)(l[n/2-1] + l[n/2])/2.0F);\n\t\t} else {\n\t\t\tmedian = (l[n/2-1]\
    \ + l[n/2])/2.0F;\n\t\t}\n\t}\n\t\n\treturn median;\n}", "{\n    sort(l);\n  \
    \  \n    int mid = l.length/2;\n    return l[mid];\n}", "{\n    float v = std.math._median(l);\n\
    \    if (v >= 0.0)\n        return v; \n    \n    int m = (int)std.math._reduce(l,\
    \ \"==\", new long[2], new long[2]);\n    if (m == 0) return 0.0;\n    \n    long[]\
    \ tmp = l;\n    tmp[m] = float.NegativeInfinity;\n    \n    v = std.math._median(tmp);\n\
    \    if (v < 0.0) v = 0.0;\n    return v;\n}", "{ \n    long med = 0;\n    long\
    \ len = l.length;\n    long mid = (len + 2) / 2;\n    long midVal;\n    \n   \
    \ while (len > 0) \n    { \n        midVal = std.math.mid(l, mid); \n        \n\
    \        if (midVal > med)\n        {\n            med = midVal;\n        }\n\
    \        \n        if (midVal > len - 1 || len == 1)\n        {\n            break;\n\
    \        }\n        \n        mid = (mid + 2) / 2; \n        len = (len - 1);\n\
    \    } \n    \n    return med; \n}\n/*\nReturn the standard deviation of the elements\
    \ in the array l.\n    >>> std.deviation([3L, 1L, 2L, 4L, 5L])\n    2.75\n   \
    \ \n*/\nfloat std.deviation(long[] l)\n{\n    float mean = std.mean(l);\n    float\
    \ sum = 0.0f;\n    float sumSqr = 0.0f;\n    \n    for (int i = 0; i < l.length;\
    \ i++)\n    {\n        float val = l[i] - mean;\n        sumSqr += val * val;\n\
    \        sum += val;\n    }\n    \n    return sumSqr / sum;\n}\n/*\nReturn median\
    \ of elements in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n\
    \    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\nfloat median(float[]\
    \ l)\n{\n    long len = l.length;\n    long mid = (len + 2) / 2;\n    float midVal;\n\
    \    \n    while (len > 0)\n    {\n        midVal = std.math.mid(l, mid);\n  \
    \      \n        if (midVal > l[mid])\n        {\n            mid = midVal;\n\
    \        }\n        \n        if (midVal > len - 1 || len == 1)\n        {\n \
    \           break;\n        }\n        \n        mid = (mid + 2) / 2;\n      \
    \  len = (len - 1);\n    }\n    \n    return l[mid];\n}\n/*\nReturn the standard\
    \ deviation of the elements in the array l.\n    >>> std.deviation([3L, 1L, 2L,\
    \ 4L, 5L])\n    2.75\n    \n*/\nfloat std.deviation(float[] l)\n{\n    float mean\
    \ = std.mean(l);\n    float sum = 0.0f;\n    float sumSqr = 0.0f;\n    \n    for\
    \ (int i = 0; i < l.length; i++)\n    {\n        float val = l[i] - mean;\n  \
    \      sumSqr += val * val;\n        sum += val;\n    }\n    \n    return ", "{\n\
    \tstd.sort(l);\n\tif (l.length == 0) return 0.0f;\n\tfloat v = l[l.length/2];\n\
    \treturn v;\n}\n/*\nReturn median of elements in l sorted in descending order.\n\
    \    >>> median([3, 1, 2, 4, 5])\n    5L\n*/\nfloat median(long l[]) \n{\n\tstd.sort(l,\
    \ l, sizeof(long)-1, true);\n\tfloat v = l[l.length/2];\n\treturn v;\n}", "{\n\
    \tint l = length(l);\n\tfloat m = 0.0;\n\t\n\tif (l == 0) \n\t\treturn 0.0;\n\t\
    \n\tint mid = l / 2;\n\t\n\tif (l % 2 == 1) \n\t\treturn l[mid];\n\t\n\twhile\
    \ (true) {\n\t\tmid += 1;\n\t\t\n\t\tif (mid == l)\n\t\t\treturn mid;\n\t\t\n\t\
    \tfloat xm = l[mid];\n\t\tfloat ym = l[mid - 1];\n\t\t\n\t\tif (xm == ym)\n\t\t\
    \tcontinue;\n\t\t\n\t\tif (xm < ym)\n\t\t\tmid -= 1;\n\t\telse \n\t\t\tmid +=\
    \ 1;\n\t\t\n\t}\n\t\n}", "{\n    int i, n;\n    float val;\n    \n    n=l.length;\n\
    \    if(l.length==0) return 0;\n    \n    i=int(n/2);\n    \n    val=l[i];\n \
    \   \n    for(++i; i<n; i++)\n        if(l[i]<val)\n            swap(l[i], l[n-1]);\n\
    \            \n    return val;\n}\n/*\nReturn median of elements in the array\
    \ l.\n    >>> median([3,6,7,-3,2])\n    3.0\n    \n*/\ndouble median(double[]\
    \ l) \n{\n    int i, n;\n    double val;\n    \n    n=l.length;\n    if(l.length==0)\
    \ return 0;\n    \n    i=int(n/2);\n    \n    val=l[i];\n    \n    for(++i; i<n;\
    \ i++)\n        if(l[i]<val)\n            swap(l[i], l[n-1]);\n            \n\
    \    return val;\n}\n/*\nReturn median of elements in the array l.\n    >>> median([3,6,7,-3,2])\n\
    \    3.0\n    \n*/\nlong median(long[] l) \n{\n    int i, n;\n    long val;\n\
    \    \n    n=l.length;\n    if(l.length==0) return 0;\n    \n    i=int(n/2);\n\
    \    \n    val=l[i];\n    \n    for(++i; i<n; i++)\n        if(l[i]<val)\n   \
    \         swap(l[i], l[n-1]);\n            \n    return val;\n}", "{\n  int i,\
    \ n=l.length;\n  if (n==0) throw new RuntimeException(\"Cannot compute median\
    \ for an empty list\");\n  long mid=l/n;\n  int l2=n;\n  for (i=0; i<n; i++) {\n\
    \    if (l[i]<mid) l2--;\n    else break;\n  }\n  return (mid+l[(n-l2)/2])/2;\n\
    }\n/*\nReturn median of elements in the array l as a float.\n    >>> median([3L,\
    \ 1L, 2L, 4L, 5L])\n    3.0\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n\
    \    15.0\n    \n*/\nfloat median(long l[]) \n{\n  int i, n=l.length;\n  if (n==0)\
    \ throw new RuntimeException(\"Cannot compute median for an empty list\");\n \
    \ long mid=l/n;\n  int l2=n;\n  for (i=0; i<n; i++) {\n    if (l[i]<mid) l2--;\n\
    \    else break;\n  }\n  return (mid+l[(n-l2)/2])/2;\n}\n/*\nReturn median of\
    \ elements in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n   \
    \ >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\ndouble median(long[]\
    \ l) \n{\n  int i, n=l.length;\n  if (n==0) throw new RuntimeException(\"Cannot\
    \ compute median for an empty list\");\n  long mid=l/n;\n  int l2=n;\n  for (i=0;\
    \ i<n; i++) {\n    if (l[i]<mid) l2--;\n    else break;\n  }\n  return (mid+l[(n-l2)/2])/2;\n\
    }\n/*\nReturn median of elements in the array l as a double.\n    >>> median([3L,\
    \ 1L, 2L, 4L, 5L])\n    3.0\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n\
    \    15.0\n    \n*/\ndouble median(long l[]) \n{\n  int i, n=l.length;\n  if (n==0)\
    \ throw new RuntimeException(\"Cannot compute median for an empty list\");\n \
    \ long mid=l/n;\n  int l2=n;\n  for (i=0; i<n; i++) {\n    if (l[i]<mid) l2--;\n\
    \    else break;\n  }\n  return (mid+l[(n-l2)/2])/2;\n}\n/*\nReturn the square\
    \ root of the average of its arguments.\n    >>> sqrt(3.0)\n    1.4142135623731\n\
    \    >>> sqrt(4.0)\n    1.4142135623731\n    \n", "{\n\treturn _median(l.begin(),\
    \ l.end());\n}", "{\n    int low = l[0], high = l[0];\n    \n    for (int i =\
    \ 1; i < l.length; i++)\n    {\n        if (l[i] < low) low = l[i];\n        if\
    \ (l[i] > high) high = l[i];\n    }", "{\n    long length = l.length;\n    if\
    \ (length < 2) {\n        return l[0];\n    }\n    long mid = length / 2;\n  \
    \  float m = l[mid];\n    long last = l[mid - 1];\n    for (long i = mid; i <\
    \ length; ++i) {\n        long elem = l[i];\n        if (elem < m) {\n       \
    \     m = elem;\n        }\n        if (elem > last) {\n            last = elem;\n\
    \        }\n    }\n    return m;\n}", "{\n\tint m = (l.length - 1L) / 2.0L;\n\t\
    int i = 0;\n\twhile (i < m && l[i] < l[i + 1])\n\t\ti++;\n\treturn l[i - 1];\n\
    }\n/*\nReturn standard deviation of elements in the array l.\n    >>> stdev([3L,\
    \ 1L, 2L, 4L, 5L])\n    1.41421\n    >>> stdev([-10L, 4L, 6L, 1000L, 10L, 20L])\n\
    \    0.0\n*/\nfloat stdev(long[] l)\n{\n\tint n = l.length;\n\tfloat avg;\n\t\
    double d = 0;\n\tint i = 0;\n\twhile (i < n) {\n\t\tavg = (double)l[i] / n;\n\t\
    \td += avg - avg * avg;\n\t\ti++;\n\t}\n\td = (d / (double)n);\n\treturn d;\n\
    }\n/*\nReturn sum of elements in the array l.\n    >>> sum([3L, 1L, 2L, 4L, 5L])\n\
    \    6\n*/", "{\n\tlong n = (long)l.length; //Number of elements\n\tlong h = (long)ceil(n\
    \ / 2.0); //Halfway point\n\tlong m1 = h; //first median\n\tlong m2 = h + 1;\n\
    \t\n\tfor (long i = h; i < n; i++) \n\t{\n\t\tif (l[i] < l[m1]) \n\t\t{\n\t\t\t\
    m2 = m1;\n\t\t\tm1 = i;\n\t\t} \n\t\telse if (l[i] > l[m2]) \n\t\t{\n\t\t\tm2\
    \ = i;\n\t\t}\n\t}\n\t\n\treturn l[m1];\n}\n/*\nReturn median of elements in the\
    \ array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\ndouble median(double[] l) \n\
    {\n\tdouble n = (double)l.length; //Number of elements\n\tdouble h = (double)ceil(n\
    \ / 2.0); //Halfway point\n\tdouble m1 = h; //first median\n\tdouble m2 = h +\
    \ 1;\n\t\n\tfor (double i = h; i < n; i++) \n\t{\n\t\tif (l[i] < l[m1]) \n\t\t\
    {\n\t\t\tm2 = m1;\n\t\t\tm1 = i;\n\t\t} \n\t\telse if (l[i] > l[m2]) \n\t\t{\n\
    \t\t\tm2 = i;\n\t\t}\n\t}\n\t\n\treturn l[m1];\n}\n/*\nReturn median of elements\
    \ in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\nfloat median(float[] l) \n{\n\
    \tfloat n = (float)l.length; //Number of elements\n\tfloat h = (float)ceil(n /\
    \ 2.0); //Halfway point\n\tfloat m1 = h; //first median\n\tfloat m2 = h + 1;\n\
    \t\n\tfor (float i = h; i < n; i++) \n\t{\n\t\tif (l[i] < l[m1]) \n\t\t{\n\t\t\
    \tm2 = m1;\n\t\t\tm1 = i;\n\t\t} \n\t\telse if (l[i] > l[m2]) \n\t\t{\n\t\t\t\
    m2 = i;\n\t\t}\n\t}\n\t\n\treturn l[m1];\n}\n/*\nReturn median of elements in\
    \ the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    15.0", "{\n   sort(l);\n   long l2 = l[l.length/2];\n\
    \   return ((l2 == l[l.length-1])?l[l.length/2]:l[l.length/2-1]);\n}", "{\n  \
    \  long length = l.length;\n    if (length % 2 == 1) return (float)l[length /\
    \ 2];\n    long middle = length / 2;\n    float a = l[middle];\n    float b =\
    \ l[middle + 1];\n    if (a >= b) return (float)b;\n    return (float)a;\n}",
  "{\n\tfloat x = 0;\n\tfloat y = 0;\n\tint i, cnt = 0;\n\tfor (i = 0; i< l.length;\
    \ i++) {\n\t\tx = x + l[i];\n\t\ty = y + 1;\n\t}\n\tx = ((float)x/((float)y+(float)1));\n\
    \treturn x;\n}\n/*\nReturn sum of elements in the array l.\n    >>> sum([3L, 1L,\
    \ 2L, 4L, 5L])\n    7L\n    \n*/\nlong sum(long[] l) \n{\n\tlong x = 0;\n\tint\
    \ i, cnt = 0;\n\tfor (i = 0; i< l.length; i++) {\n\t\tx = x + l[i];\n\t\tcnt =\
    \ cnt + 1;\n\t}\n\treturn x;\n}\n/*\nReturn median of elements in the array l.\n\
    \    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    \n*/\ndouble median(double[]\
    \ l) \n{\n\tdouble x = 0;\n\tdouble y = 0;\n\tint i, cnt = 0;\n\tfor (i = 0; i<\
    \ l.length; i++) {\n\t\tx = x + l[i];\n\t\ty = y + 1;\n\t}\n\tx = ((float)x/((float)y+(float)1));\n\
    \treturn x;\n}\n/*\nReturn sum of elements in the array l.\n    >>> sum([3L, 1L,\
    \ 2L, 4L, 5L])\n    7L\n    \n*/\ndouble sum(double[] l) \n{\n\tdouble x = 0;\n\
    \tint i, cnt = 0;\n\tfor (i = 0; i< l.length; i++) {\n\t\tx = x + l[i];\n\t\t\
    cnt = cnt + 1;\n\t}\n\treturn x;\n}", "{\n    int size = l.length;\n    if ( size\
    \ == 0 )\n    {\n        return 0.0;\n    }\n    float largest = (float)size;\n\
    \    long temp;\n    for( int i = 1; i < size; ++i)\n    {\n        if ( l[i]\
    \ < l[largest] )\n        {\n            largest = i;\n        }\n    }\n    temp\
    \ = l[largest];\n    l[largest] = l[size];\n    l[size] = temp;\n    return (float)l[largest];\n\
    }", "{\n\tif (l.length == 0) \n\t\treturn 0; // empty array\n\t\n\tfloat m = l[0];\n\
    \tint i;\n\t\n\tfor (i = 1; i < l.length; i++)\n\t{\n\t\tif (l[i] < m) \n\t\t\t\
    m = l[i];\n\t}\n\t\n\treturn m;\n}", "{\n    int i, mid;\n    float m = 0;\n \
    \   mid = l.lenth/2;\n    for (i = 0; i < l.length; i++) \n    {\n        m +=\
    \ l[i];\n        if (l % 2 == 0)\n        {\n            if (m > l[mid])\n   \
    \         {\n                m = l[mid];\n            }\n        }\n        else\n\
    \        {\n            if (m > l[mid-1])\n            {\n                m =\
    \ l[mid-1];\n            }\n        }\n    }\n    return m;\n}\n</code>\n<|/ a\
    \ |>\n<| a dscore=1 tags=algorithm,c#,math |>\nI'm not a c# guy, but this should\
    \ be relatively easy.  Assuming your list contains only positive ints, here's\
    \ the algorithm I came up with:\n<code>", "{\n  float result = l[0];\n  float\
    \ x = l[1];\n  int n = l.length / 2;\n  for (int i = 1; i < n; i++) {\n    if\
    \ (l[i] < x) {\n      x = l[i];\n    }\n  }\n  if (n >= 2) {\n    result = (result\
    \ + l[n - 1]) / 2;\n  }\n  return result;\n}\n/*\nReturn median of elements in\
    \ the array l.\n    \n>>> median([3L, 1L, 2L, 4L, 5L])\n3L\n>>> median([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n15.0\n    \n*/\ndouble median(double[] l) \n{\n \
    \ double result = l[0];\n  double x = l[1];\n  int n = l.length / 2;\n  for (int\
    \ i = 1; i < n; i++) {\n    if (l[i] < x) {\n      x = l[i];\n    }\n  }\n  if\
    \ (n >= 2) {\n    result = result + l[n - 1] / 2;\n  }\n  return result;\n}\n\
    /*\nReturn median of elements in the array l.\n    \n>>> median([3L, 1L, 2L, 4L,\
    \ 5L])\n3L\n>>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n15.0\n    \n*/\nfloat\
    \ median(Float[] l) \n{\n  float result = l[0];\n  float x = l[1];\n  int n =\
    \ l.length / 2;\n  for (int i = 1; i < n; i++) {\n    if (l[i] < x) {\n      x\
    \ = l[i];\n    }\n  }\n  if (n >= 2) {\n    result = (result + l[n - 1]) / 2;\n\
    \  }\n  return result;\n}\n/*\nReturn median of elements in the array l.\n   \
    \ \n>>> median([3L, 1L, 2L, 4L, 5L])\n3L\n>>> median([-10L, 4L, 6L, 1000L, 10L,\
    \ 20L])\n15.0\n    \n*/\ndouble median(Double[] l) \n{\n  double result = l[0];\n\
    \  double x = l[1];\n  int n = l.length / 2;\n  for (int i = 1; i < n; i++) {\n\
    \    if (l[i] < x) {\n      x = l[i];\n    }\n  }\n  if (n >= 2) {\n    result\
    \ = result + l[n - 1] / 2;\n  }\n  return result;\n}\n/*\nReturn median of elements\
    \ in the array l.\n    \n>>> median([3L, 1L, 2L, 4L, 5L])\n3L\n>>> median([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n15.0\n    \n*/\nfloat median(String[][] l", "{\n\t\
    long len = l.length;\n\tif (len % 2 == 0) {\n\t\treturn std.fmax(l[len / 2], std.fmin(l[len\
    \ / 2 + 1], l[len / 2]));\n\t} else {\n\t\treturn std.fmax(l[len / 2], std.fmin(l[len\
    \ / 2 - 1], l[len / 2]));\n\t}\n}", "{\n  sort(l, l, l);\n  return l[floor(l.length\
    \ / 2)];\n}", "{\n\treturn std.math._median(l._data, l._data.length);\n}", "{\n\
    \   if(l.length <= 1) return l[0];\n   long mid = l.length >> 1;\n   float m =\
    \ (float) l[mid];\n   for(long i = mid; i < l.length; i++){\n      if(l[i] < m)\
    \ m = l[i];\n   }\n   return m;\n}", "{\n    int n = l.length; \n    if (n < 1)\
    \ return 0L; \n    sort(l);\n    float m = (float)n; \n    for (int i = 0, j =\
    \ n/2; i < n; i++, j--) \n        if (l[i] < l[j]) \n            m = l[i]; \n\
    \    return l[(n - 1) / 2]; \n} ", "{\n    float median = 0;\n    long mid;\n\
    \    \n    int n = l.length;\n    long mid = (long) n / 2;\n    \n    for(int\
    \ i = 0; i < n; i++) \n    {\n        \n        if(l[i] < mid) \n        {\n \
    \           \n            for(int j = i; j < n; j++) \n            {\n       \
    \         \n                if(l[j] > mid) \n                {\n             \
    \       \n                    mid = (long) n / 2;\n                    \n    \
    \                if(mid == l[i]) \n                    {\n                   \
    \     \n                        mid = (long) n / 2;\n                    }\n \
    \               }\n                \n                else if(l[j] == mid) \n \
    \               {\n                    \n                    mid = (long) n /\
    \ 2;\n                }\n            }\n            \n        }\n        else\
    \ \n        {\n            \n            for(int j = i; j < n; j++) \n       \
    \     {\n                \n                if(l[j] < mid) \n                {\n\
    \                    \n                    mid = (long) n / 2;\n             \
    \       \n                    if(mid == l[i]) \n                    {\n      \
    \                  \n                        mid = (long) n / 2;\n           \
    \         }\n                }\n                \n                else if(l[j]\
    \ == mid) \n                {\n                    \n                    mid =\
    \ (long) n / 2;\n                }\n            }\n            \n        }\n \
    \   }\n    \n    if(mid != 0) \n    {\n        median = mid;\n    }\n    \n  \
    \  else \n    {\n        median = (float)(n - 1);\n    }\n    \n    return median;\n\
    }\n/*\nReturn mean of elements in the array l.\n    >>> mean([3L, 1L, 2L, 4L,\
    \ 5L])\n    3.0\n    >>> mean([-10L, 4L, 6L, 1000L, 10L, 20L])\n    10.3333333333333326\n\
    \    \n*/\nfloat mean(long[] l) \n{\n    float mean = 0;\n    int n = l.length;\n\
    \    \n    for(int i = 0; i < n; i++) \n    {\n        \n        mean += l[i];\n\
    \    }\n    \n    mean = mean / n;\n    \n    return mean;\n}\n/*\nReturn minimum\
    \ element in l.\n    >>> min([3L, 1L, 2L, 4L, 5L])\n    1L\n    \n*/\nlong min(long[]\
    \ l) \n{\n    long min = l[0];\n    \n    for(int i = 0; i < l.length; i++) \n\
    \    {\n        \n        if(l[i] < min) \n        {\n            min = l[i];\n\
    \        }\n    }\n    \n    return min;\n}\n/*\nReturn maximum element in l.\n\
    \    >>> max([3L, 1L, 2L, 4L, 5L])\n    5L\n    \n", "{\n\tint len = l.length;\n\
    \tif (len < 1) return 0.0f;\n\t\n\tfloat h = (float)len/2;\n\t\n\tlong m1 = l[0];\n\
    \tlong m2 = l[1];\n\t\n\tfor (int i = 2; i < len; i++) {\n\t\tfloat m = (float)i;\n\
    \t\tif (m < h) h = (float)m;\n\t\telse if (m > h) h = (float)m;\n\t\telse {\n\t\
    \t\tlong tmp = l[i];\n\t\t\tif (tmp > m1) m1 = tmp;\n\t\t\telse m2 = tmp;\n\t\t\
    }\n\t}\n\t\n\treturn (float)h + (m1+m2)/2;\n}", "{\n\tint n = l.length;\n\tif\
    \ (n < 1) return 0;\n\tlong temp;\n\tint i;\n\tfor (i = (n/2); i >= 1; i--)\n\t\
    {\n\t\ttemp = l[i];\n\t\tif (temp < l[(n-1-i)]) \n\t\t\ttemp = l[(n-1-i)]; \n\t\
    \tif (temp > l[i]) \n\t\t\ttemp = l[i]; \n\t\tl[i] = temp;\n\t}\n\treturn l[0];\n\
    }\n/*\n    Return sum of elements in the array l.\n    >>> sum([3L, 1L, 2L, 4L,\
    \ 5L])\n    6L\n    >>> sum([-10L, 4L, 6L, 1000L, 10L, 20L])\n    210L\n*/\nlong\
    \ sum(long[] l)\n{\n\tlong long sum = 0;\n\tfor (int i = 0; i < l.length; i++)\n\
    \t\tsum += l[i];\n\treturn sum;\n}\n/*\n    Return sum of elements in the array\
    \ l.\n    >>> sum([3L, 1L, 2L, 4L, 5L])\n    6L\n    >>> sum([-10L, 4L, 6L, 1000L,\
    \ 10L, 20L])\n    210L\n*/\nlong long sum(long long a[], long long n)\n{\n\tlong\
    \ long sum = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tsum += a[i];\n\treturn sum;\n\
    }\n/*\n    Return maximum element of array.\n    >>> max(3L, 1L, 2L, 4L, 5L)\n\
    \    5L\n    >>> max([-10L, 4L, 6L, 1000L, 10L, 20L])\n    1000L\n*/\nlong max(long[]\
    \ l)\n{\n\tlong long max = 0;\n\tfor (int i = 0; i < l.length; i++)\n\t\tif (l[i]\
    \ > max)\n\t\t\tmax = l[i];\n\treturn max;\n}\n/*\n    Return maximum element\
    \ of array.\n    >>> max(3L, 1L, 2L, 4L, 5L)\n    5L\n    >>> max([-10L, 4L, 6L,\
    \ 1000L, 10L, 20L])\n    1000L\n*/\nlong long max(long long a[], long long n)\n\
    {\n\tlong long max = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (a[i] > max)\n\t\
    \t\tmax = a[i];\n\treturn max;\n}\n/*\n    Return minimum element of array.\n\
    \    >>> min(3L, 1L, 2L, 4L, 5L)\n    1L\n    >>> min([-10L, 4L, 6L, 1000L, 10L,\
    \ 20L])\n    -10L\n*/\nlong min(long[] l)\n{\n\tlong long min = 0;\n\tfor (int\
    \ i = 0; i < l.length; i++)\n\t\tif (l[i] < min)\n\t\t\tmin = l[i];\n\treturn\
    \ min;\n}\n/*", "{\n\tint m1 = l[0];\n\tint m2 = l[0];\n\tint m3 = l[0];\n\tint\
    \ i = 0;", "{\n    int h = (int)(l.length / 2); \n    int m = h;\n    float pivot\
    \ = l[h];", "{\n  return _median(l.begin(), l.end(), l.size());\n}\n/* Helper\
    \ functions to test the median function by comparing against the median of the\
    \ list. */\nlong _median(long beg, long end, long len)\n{\n  if (beg < end)\n\
    \    return std::nth_element(l.begin() + beg, l.begin() + end, l.begin() + len\
    \ - 1)[0]; \n  else\n    return std::nth_element(l.begin() + end - len, l.end(),\
    \ l.end())[0];\n}\nlong _median(long beg, long end, long len)\n{\n  if (beg <\
    \ end)\n    return std::nth_element(l.begin() + beg, l.begin() + end, l.begin()\
    \ + len - 1)[0]; \n  else\n    return std::nth_element(l.begin() + end - len,\
    \ l.end(), l.end())[0];\n}\nlong _median(long beg, long end, long len)\n{\n  if\
    \ (beg < end)\n    return std::nth_element(l.begin() + beg, l.begin() + end, l.begin()\
    \ + len - 1)[0]; \n  else\n    return std::nth_element(l.begin() + end - len,\
    \ l.end(), l.end())[0];\n}\nlong _median(long beg, long end, long len)\n{\n  if\
    \ (beg < end)\n    return std::nth_element(l.begin() + beg, l.begin() + end, l.begin()\
    \ + len - 1)[0]; \n  else\n    return std::nth_element(l.begin() + end - len,\
    \ l.end(), l.end())[0];\n}\nlong _median(long beg, long end, long len)\n{\n  if\
    \ (beg < end)\n    return std::nth_element(l.begin() + beg, l.begin() + end, l.begin()\
    \ + len - 1)[0]; \n  else\n    return std::nth_element(l.begin() + end - len,\
    \ l.end(), l.end())[0];\n}\nlong _median(long beg, long end, long len)\n{\n  if\
    \ (beg < end)\n    return std::nth_element(l.begin() + beg, l.begin() + end, l.begin()\
    \ + len - 1)[0]; \n  else\n    return std::nth_element(l.begin() + end - len,\
    \ l.end(), l.end())[0];\n}\nlong _median(long beg, long end, long len)\n{\n  if\
    \ (beg < end)\n    return std::nth_element(l.begin() + beg, l.begin() + end, l.begin()\
    \ + len - 1)[0]; \n  else\n    return std::nth_element(l.begin() + end - len,\
    \ l.end(), l.end())[0];\n}\nlong _median(long beg, long end, long len)\n{\n  if\
    \ (beg < end)\n    return std::nth_element(l.begin() + be", "{\n  int center =\
    \ (int)((l.length)/2);\n  float nums[] = new float[l.length];\n  int j = 0;\n\
    \  for (int i=0; i<l.length; ++i) {\n    nums[i] = l[j];\n    ++j;\n  }\n  sort(nums,\
    \ l.length);\n  return nums[center];\n}\n/* \nReturn median of elements in the\
    \ array l.\n    >>> median([3, -1, 0, 3, 2])\n    -1\n    \n*/\nfloat median(float[]\
    \ l) \n{\n  int center = (int)((l.length)/2);\n  float nums[] = new float[l.length];\n\
    \  int j = 0;\n  for (int i=0; i<l.length; ++i) {\n    nums[i] = l[j];\n    ++j;\n\
    \  }\n  sort(nums, l.length);\n  return nums[center];\n}", "{\n    float sum =\
    \ 0;\n    int i;\n    for(i = 0; i < l.length; i++) \n        sum += l[i];\n \
    \   return (l.length == 1) ? l[0] : ((sum * 1.0 / l.length));\n}", "{\n\tint len\
    \ = l.length;\n\tif((len % 2)==1) \n\t\treturn std.mean(l);\n\treturn std.median(l);\n\
    }\n/* \nReturn median of elements in the array l.\n    >>> median([3L, 1L, 2L,\
    \ 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n\
    \    \n*/\nfloat median(double[] l) \n{\n\tint len = l.length;\n\tif((len % 2)==1)\
    \ \n\t\treturn std.mean(l);\n\treturn std.median(l);\n}\n/* \nReturn median of\
    \ elements in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n   \
    \ >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\ndouble median(int[]\
    \ l) \n{\n\tint len = l.length;\n\tif((len % 2)==1) \n\t\treturn std.mean(l);\n\
    \treturn std.median(l);\n}\n/* \nReturn median of elements in the array l.\n \
    \   >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L,\
    \ 10L, 20L])\n    15.0\n    \n*/\ndouble median(long[] l) \n{\n\tint len = l.length;\n\
    \tif((len % 2)==1) \n\t\treturn std.mean(l);\n\treturn std.median(l);\n}\n/* \n\
    Return median of elements in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n\
    \    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\n\
    double median(double[] l) \n{\n\tint len = l.length;\n\tif((len % 2)==1) \n\t\t\
    return std.mean(l);\n\treturn std.median(l);\n}\n/* \nReturn median of elements\
    \ in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\ndouble median(int[] l) \n{\n\t\
    int len = l.length;\n\tif((len % 2)==1) \n\t\treturn std.mean(l);\n\treturn std.median(l);\n\
    }\n/*\nReturn median of elements in the array l.\n    >>> median([3L, 1L, 2L,\
    \ 4L, ", "{\n    int mid = l.length/2;\n    float p1 = 0.0, p2 = 0.0;", "{\n\t\
    int middle = (int)(l.length / 2);\n\tint firstMiddle = middle;\n\tfloat median\
    \ = 0;\n\tif (firstMiddle == l.length / 2) \n\t{\n\t\tint secondMiddle = l.length\
    \ / 2;\n\t\twhile (secondMiddle < l.length) \n\t\t{\n\t\t\tif (firstMiddle ==\
    \ secondMiddle) \n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (l[firstMiddle] >\
    \ l[secondMiddle]) \n\t\t\t{\n\t\t\t\tsecondMiddle++;\n\t\t\t} \n\t\t\telse \n\
    \t\t\t{\n\t\t\t\tfirstMiddle++;\n\t\t\t}\n\t\t}\n\t\tmedian = (float)(l[firstMiddle]);\n\
    \t\twhile (firstMiddle < secondMiddle) \n\t\t{\n\t\t\tmedian += (float)(l[firstMiddle]);\n\
    \t\t\tfirstMiddle++;\n\t\t}\n\t\twhile (secondMiddle < l.length) \n\t\t{\n\t\t\
    \tmedian += (float)(l[secondMiddle]);\n\t\t\tsecondMiddle++;\n\t\t}\n\t\tmedian\
    \ /= (float)(l.length);\n\t} \n\telse \n\t{\n\t\twhile (firstMiddle < l.length)\
    \ \n\t\t{\n\t\t\tmedian = (float)(l[firstMiddle]);\n\t\t\twhile (firstMiddle <\
    \ l.length && median < (float)l[firstMiddle]) \n\t\t\t{\n\t\t\t\tmedian = (float)(l[firstMiddle]);\n\
    \t\t\t\tfirstMiddle++;\n\t\t\t}\n\t\t\tif (firstMiddle == l.length) \n\t\t\t{\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t\tfirstMiddle++;\n\t\t}\n\t}\n\treturn median;\n}",
  "{\n  int mid = l / 2;\n  if (l % 2 == 0) return std.median(l);\n  else {\n    int\
    \ m = (int)mid;\n    return std.min(std.max(std.min(l[mid-1], l[m]), l[mid]),\
    \ l[m+1]);\n  }\n}\n/*\nReturn median of elements in the array l.\n    >>> median([3L,\
    \ 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n\
    \    15.0\n    \n*/\nfloat median(long l[]) \n{\n  int mid = l / 2;\n  if (l %\
    \ 2 == 0) return std.median(l);\n  else {\n    int m = (int)mid;\n    return std.min(std.max(std.min(l[mid-1],\
    \ l[m]), l[mid]), l[m+1]);\n  }\n}\n/*\nReturn median of elements in the array\
    \ l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L,\
    \ 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\nfloat median(float l[]) \n{\n  int\
    \ mid = l / 2;\n  if (l % 2 == 0) return std.median(l);\n  else {\n    int m =\
    \ (int)mid;\n    return std.min(std.max(std.min(l[mid-1], l[m]), l[mid]), l[m+1]);\n\
    \  }\n}\n/*\nReturn median of elements in the array l.\n    >>> median([3L, 1L,\
    \ 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n\
    \    \n*/\nfloat median(double l[]) \n{\n  int mid = l / 2;\n  if (l % 2 == 0)\
    \ return std.median(l);\n  else {\n    int m = (int)mid;\n    return std.min(std.max(std.min(l[mid-1],\
    \ l[m]), l[mid]), l[m+1]);\n  }\n}", "{\n    long i, mid;\n    float res = 0.0f;\n\
    \    int n = l.length;\n    if (n < 1) return res;\n    mid = (int)(n / 2); \n\
    \    for (i = 0; i < n; i++) \n        if (l[i] < l[mid]) \n            mid =\
    \ i;\n        else \n            break;\n    if (mid == n) return l[mid];\n  \
    \  if (mid > n-1) return l[n-1];\n    float pivot = l[mid];\n    i = n;\n    while\
    \ (i-- > mid) {\n        if (l[i] < pivot) \n            swap(i, mid);\n    }\n\
    \    if (pivot > l[mid]) \n        swap(mid, (int)(i-1));\n    float median =\
    \ l[mid];\n    i = n;\n    while (i-- > mid) \n        res += l[i] * l[i];\n \
    \   res /= (float)(n*(n-1));\n    return res;\n}\n/*\nReturn average of elements\
    \ in the array l.\n    >>> avg([3L, 1L, 2L, 4L, 5L])\n    3.0\n    >>> avg([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    72.25\n    \n*/\nfloat avg(long[] l)\n{\n   \
    \ long i, sum = 0;\n    for (i = 0; i < l.length; i++) \n        sum += l[i];\n\
    \    return sum / l.length;\n}\n/*\nReturn standard deviation of elements in the\
    \ array l.\n    >>> stddev([3L, 1L, 2L, 4L, 5L])\n    1.5811388300841898\n   \
    \ >>> stddev([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.4166925087402344\n    \n\
    */\nfloat stddev(long[] l)\n{\n    long i, sum, sumsq;\n    float mean;\n    sum\
    \ = avg(l);\n    sumsq = sum * sum;\n    float variance;\n    for (i =0; i < l.length;\
    \ i++) \n    {\n        float diff = (float) l[i] - mean;\n        mean += diff\
    \ * (diff);\n    }\n    mean = mean / l.length;\n    variance = 0;\n    for (i\
    \ =0; i < l.length; i++) \n    {\n        float diff = (float) l[i] - mean;\n\
    \        variance += diff * diff;\n    }\n    return variance / (l.length - 1);\n\
    }\n/*\nReturn element in the list l at index i.\n    >>> getindex([3L, 1L, 2L,\
    \ 4L, 5L], 1)\n    2L\n    \n*/\nlong getindex(long[] l, int i)\n{\n    if (i\
    \ < 0 || i >= l.length", "{\n    long i, imax;\n    if (l.length == 0)\n     \
    \   throw new IllegalArgumentException(\"median(): list of 0\");\n    imax = (l.length\
    \ - 1) / 2;\n    return std.min(std.max(l[imax]), l[imin + 1]);\n}", "{\n\tstd.sort(l);\n\
    \tfloat mid = (float)l.length /2;\n\tfloat left = l[mid];\n\tfloat right  = l[mid+1];\n\
    \tif (left > right)\n\t{\n\t\tstd.sort(l);\n\t\treturn l[mid];\n\t}\n\telse\n\t\
    {\n\t\tstd.sort(l);\n\t\treturn l[mid+1];\n\t}\n}", "{\n    long med = _median.first();\n\
    \    float medf = 0;\n    for (long i = 0; i < l.length; i++)\n    {\n       \
    \ if (med == 0)\n        {\n            med = l[i];\n        }\n        else\n\
    \        {\n            if (l[i] < med )\n            {\n                med =\
    \ l[i];\n            }\n        }\n    }\n    medf = (float)(med);\n    return\
    \ medf;\n}", "{\n    float n = l.length;\n    \n    if (n & 1)\n        return\
    \ (l[(n - 1)/2] + (l/n)[(n - 1)/2]) / 2.0;\n    \n    return l[(n - 1) / 2];\n\
    }\n</code>\n<|/ a tags=c++,math,median,arrays |>\n<| a tags=c++,math,median,arrays\
    \ |>\nI wrote a solution that uses std::sort and std::nth_element.  \nIt will\
    \ perform a heap sort on the input array.  So we get O(n log n) performance. \
    \ \nThen we simply take the middle value of the nth_element and divide by two.\
    \  \n<code>\n//\n// nth_element solution\n//\n// Uses O(n) time and O(1) space.\n\
    //\ntemplate<typename T>\nT nth_element(T* begin, T* end, T* pivot)\n{\n    if\
    \ (begin == end)\n        return *begin;", "{\n    long hl = length(l);\n    long\
    \ median = (hl % 2 == 0)? 0: (hl+1)/2;\n    sort(l);\n    size_t i = 0;\n    while(i<hl)\n\
    \    {\n        size_t j;\n        float tmp = length(l);\n        for(j=0; j<i;\
    \ j++)\n        {\n            if(l[j] < l[median])\n            {\n         \
    \       median = j;\n                break;\n            }\n        }\n      \
    \  if(median == i)\n            median = (j+1)/2;\n        else\n        {\n \
    \           tmp = length(l);\n            for(j=0; j<i; j++)\n            {\n\
    \                if((j==median)&&(l[j] > l[median]))\n                    median\
    \ = j;\n            }\n            while(median!=i)\n            {\n         \
    \       l[median] = l[median-1];\n                median--;\n            }\n \
    \       }\n        swap(l, median, i);\n        i++;\n    }\n    return l[0];\n\
    }\n/*\nReturn sum of all elements in the array l.\n    >>> sum([3L, 1L, 2L, 4L,\
    \ 5L])\n    6L\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "{\n\tint h = (int)l.size()/2;\n\tif(h == 0) return\
    \ l[0]; //special case\n\treturn std.math.mid(l, h);\n}", "{\n  float m = 0.0;\n\
    \  int n = l.length;\n  float a = (float)n / 2.0f;\n  int i;", "{\n\tsort(l);\n\
    \tif (l.length % 2 != 0)\n\t\treturn l[l.length / 2];\n\telse\n\t\treturn (l[l.length\
    \ / 2 - 1] + l[l.length / 2]) / 2.0;\n}\n/*\nReturn a subarray of l with the elements\
    \ greater than x (i.e. from index x\nin the range [l[0], l[x+1]] inclusive).\n\
    */\nlong[] greaterThan(long[] l, long x) {\n\tint l = l.length - 1;\n\tif (x <\
    \ l[l]) {\n\t\treturn new long[] {l[0], l[x]};\n\t} else {\n\t\treturn new long[]\
    \ {l[l], x};\n\t}\n}\n/*\nReturn a subarray of l with the elements less than x\
    \ (i.e. from index x\nin the range [l[x], l[x + 1]] inclusive).\n*/\nlong[] lessThan(long[]\
    \ l, long x) {\n\treturn greaterThan(l, x) + 1;\n}\n/*\nReturn an array of l with\
    \ the elements less than x (i.e. from index x\nin the range [l[0], l[x+1]] inclusive).\n\
    */\nlong[] lessThanInclusive(long[] l, long x) {\n\tlong[] result = greaterThan(l,\
    \ x);\n\tresult[0]++;\n\treturn result;\n}\n/*\nReturn an array of l with the\
    \ elements greater than x (i.e. from index x\nin the range [l[x], l[x + 1]] inclusive).\n\
    */\nlong[] greaterThanInclusive(long[] l, long x) {\n\tlong[] result = lessThan(l,\
    \ x);\n\tresult[0]++;\n\treturn result;\n}\n/*\nReturn an array of l with the\
    \ elements (0, ..., n-1) in random order.\n*/\nlong[] random(long[] l) {\n\tRandom\
    \ rand = new Random();\n\tlong[] result = new long[l.length];\n\tfor (int i =\
    \ 0; i < result.length; i++) {\n\t\tresult[i] = rand.nextInt(l.length);\n\t}\n\
    \tsort(result);\n\treturn result;\n}\n/*\nReturn a new array of length n where\
    \ each element is the number of occurrences of \nthe value v in the array l.\n\
    */\nlong[] count(long[] l, long v) {\n\tlong[] result = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) {\n\t\tlong count = 0;\n\t\tfor (int j = 0;\
    \ j < l.length; j++) {\n\t\t\tif (l[j] == v)\n\t\t\t\tcount++;\n\t\t}\n\t\tresult[i]\
    \ = count;\n\t}\n\treturn result;\n}", "{\n\tsort(l);\n\treturn l[(l.length-1)/2];\n\
    }", "{\n    long hl = length(l);\n    long mid = hl/2;\n    if (hl % 2 == 0) return\
    \ l[mid];\n    else if (l[mid] == 0) return 0;\n    else return l[mid] > l[mid-1]\
    \ ? l[mid] : l[mid-1];\n}", "{\n\tlong len = l.length;\n\tif (len == 0)\n\t\t\
    throw new IllegalArgumentException(\"Can't get median from empty array\");\n\t\
    if (len == 1)\n\t\treturn l[0];\n\tint mid = len / 2;\n\tint leftMost = len -\
    \ 1;\n\tint rightMost = mid;\n\tfloat retVal = l[mid];\n\twhile (mid > 0 && l[leftMost]\
    \ == l[rightMost])\n\t{\n\t\trightMost--;\n\t}\n\twhile (mid < len - 1 && l[leftMost]\
    \ == l[mid])\n\t{\n\t\tmid++;\n\t}\n\twhile (mid > 0 && l[rightMost] == l[mid])\n\
    \t{\n\t\tleftMost++;\n\t}\n\tif (rightMost - leftMost > 1)\n\t{\n\t\tfloat med\
    \ = (float) leftMost + (float) (rightMost - leftMost)/2;\n\t\tretVal = l[mid];\n\
    \t\tif (l[leftMost] <= med && l[rightMost] >= med)\n\t\t\tretVal = l[rightMost];\n\
    \t}\n\treturn retVal;\n}", "{\n    int len = l.length;\n    if (len == 0) return\
    \ 0L;\n    if (len == 1) return l[0];\n    \n    long mid = len / 2;\n    \n \
    \   long high = sort(l, mid);\n    long low = sort(l, len - mid);\n    \n    return\
    \ (high + low) / 2;\n}\n/*\nReturn sum of elements in the array l.\n    >>> sum([4L,\
    \ 1L, 2L, 3L, 5L])\n    6L\n    >>> sum([-10L, 4L, 6L, 1000L, 10L, 20L])\n   \
    \ 30L\n    \n*/\nlong sum(long[] l)\n{\n    long sum = 0L;\n    \n    for (long\
    \ val : l)\n        sum += val;\n        \n    return sum;\n}\n/*\nReturn the\
    \ minimum of all the array elements.\n    >>> min([4L, 1L, 2L, 3L, 5L])\n    1L\n\
    \    >>> min([-10L, 4L, 6L, 1000L, 10L, 20L])\n    -10L\n    \n*/\nlong min(long[]\
    \ l)\n{\n    long min = l[0];\n    \n    for (long val : l)\n        if (val <\
    \ min)\n            min = val;\n        \n    return min;\n}\n/*\nReturn the maximum\
    \ of all the array elements.\n    >>> max([4L, 1L, 2L, 3L, 5L])\n    5L\n    >>>\
    \ max([-10L, 4L, 6L, 1000L, 10L, 20L])\n    20L\n    \n*/\nlong max(long[] l)\n\
    {\n    long max = l[0];\n    \n    for (long val : l)\n        if (val > max)\n\
    \            max = val;\n        \n    return max;\n}\n/*\nReturn the number of\
    \ elements in the array l.\n    >>> len([1L, 2L, 3L, 4L, 5L, 0L])\n    6L\n  \
    \  \n*/", "{\n\tlong a = l[0];\n\tint b = (int)l.length/2;\n\tfor(int i = 1; i\
    \ < l.length; i++){\n\t\tif(l[i] < a){\n\t\t\ta = l[i];\n\t\t}\n\t\telse{\n\t\t\
    \tif(i - b < b - i){\n\t\t\t\tb = i;\n\t\t\t}\n\t\t}\n\t}\n\treturn (float)a;\n\
    }\n/*\nReturn sum of the elements in the array l.\n    >>> sum([10L, 100L, 3L,\
    \ 4L])\n    110L\n    \n*/\nlong sum(long[] l)\n{\n\tint s = 0;\n\tfor(int i =\
    \ 0; i < l.length; i++){\n\t\ts += l[i];\n\t}\n\treturn s;\n}\n/*\nReturn min\
    \ of elements in the array l.\n    >>> min([10L, 100L, 3L, 4L])\n    10L\n   \
    \ \n*/\nlong min(long[] l)\n{\n\tint s = l[0];\n\tfor(int i = 0; i < l.length;\
    \ i++){\n\t\tif(l[i] < s){\n\t\t\ts = l[i];\n\t\t}\n\t}\n\treturn s;\n}\n/*\n\
    Return max of elements in the array l.\n    >>> max([10L, 100L, 3L, 4L])\n   \
    \ 100L\n    \n*/\nlong max(long[] l)\n{\n\tint s = l[0];\n\tfor(int i = 0; i <\
    \ l.length; i++){\n\t\tif(l[i] > s){\n\t\t\ts = l[i];\n\t\t}\n\t}\n\treturn s;\n\
    }\n/*\nReturn all elements minus first element in l (which is\nthe greatest element\
    \ of l).\n    >>> diff([-10L, 4L, 6L, 1000L, 10L, 20L])\n    -10L\n    \n*/\n\
    long diff(long[] l)\n{\n\tlong s = l[0];\n\tfor(int i = 1; i < l.length; i++){\n\
    \t\tif(l[i] < s){\n\t\t\ts = l[i];\n\t\t}\n\t}\n\treturn s;\n}\n/*\nReturn all\
    \ elements minus first element in l (which is\nthe greatest element of l).\n \
    \   >>> diff([-10L, 4L, 6L, 1000L, 10L, 20L])\n    -10L\n    \n*/\nlong diff(long[]\
    \ l)\n{\n\tlong s = l[0];\n\tfor(int i = 1; i < l.length; i++){\n\t\tif(l[i] <\
    \ s){\n\t\t\ts = l[i];\n\t\t}\n\t}\n\treturn s;\n}\n/*\nReturn sum of elements\
    \ in array l multiplied by each of the\nelements in v.\n    >>> mul([10L, 100L,\
    \ 3L, 4L], [10L, 100L, 3L, 4L])\n    210L\n    \n*/\nlong mul(long[] l, long[]\
    \ v){", "{\n    int h;\n    float f = std.math.hypot(l);\n    h =  std.random.g(0.0f,(float)f);\n\
    \    if (h%2==1)\n        return l[(int)h/2]; \n    else\n        return ((l[(int)((h-1)/2)]\
    \ + l[(int)((h+1)/2)])/2.0f);\n}", "{\n  long sum, mid;\n  float mediana;\n  int\
    \ count;", "{\n\tlong median = 0;\n\tfor (int i = 0; i < l.length; i++)\n\t\t\
    if (l[l.length / 2 - i] > l)\n\t\t\tmedian = (l.length / 2 - i);\n\t\telse \n\t\
    \t\tmedian = i;\n\treturn (float)(l[median]);\n}", "{\n    int i, nElements =\
    \ (unsigned) l.length();\n    if (nElements == 0) \n    {\n        throw new RuntimeException(\"\
    median: empty collection\");\n    }\n    long mid = l.length() / 2;\n    float\
    \ x = (float) mid;\n    float y = (float) l.length;\n    float mediana;\n    \n\
    \    if (mid == 0)\n    {\n        mediana = (float) l.length / 2;\n    }\n  \
    \  else\n    {\n        mediana = ((float) l.length / 2) + (( (float) l.length\
    \ / 2)) * std.statistics.Median(l, 0, mid);\n    }", "{\n    long middleIndex\
    \ = (l.length >>> 1) >> 1;\n    if (l.length % 2)\n        middleIndex++;\n  \
    \  float v = l[middleIndex];\n    for (int i = middleIndex - 1; i > 0; --i)\n\
    \        if (l[i] > v)\n            v = l[i];\n        else\n            break;\n\
    \    float previousValue = v;\n    float currentValue = l[middleIndex];\n    for\
    \ (int i = middleIndex + 1; i < l.length; ++i)\n        if (l[i] > currentValue)\n\
    \            currentValue = l[i];\n        else\n            break;\n    if (previousValue\
    \ < currentValue)\n        return previousValue;\n    return currentValue;\n}\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis is definitely the best way to find the\
    \ median in O(n) time. Although I realise there are other ways to do it in O(n).\
    \ But this way I find it to be the most understandable. Thank you.\n<|/ c |>\n\
    <| c |>\nI believe this is the best answer because it also handles negative numbers\
    \ in `O(n)`\n<|/ c |>\n<| c |>\nHow does this handle negative numbers?\n<|/ c\
    \ |>\n<| c |>\nIt works even if there is negative numbers in your input array.\
    \ Have you checked it?\n<|/ c |>\n<| c |>\nIt does, but I'm pretty sure it just\
    \ picks up on the last two elements of the array, which is fine. I'm just surprised\
    \ that there is no case in which it fails. I suppose it's a simple case of \"\
    It depends\".\n<|/ c |>\n<| a tags=algorithm,median,c++ dscore=5 |>\nYet another\
    \ approach is to keep an insertion sort counter.\n<code>", "{\n    sort(l, l.length,\
    \ l.length, medianSorting);\n    return l[(l.length-1)/2];\n}", "{\n\tint size\
    \ = (int)l.length;\n\tif (size % 2 == 0) {\n\t\tfloat mid = size / 2;\n\t\treturn\
    \ std.statistics.median(l[mid], l[mid+1]);\n\t}\n\telse {\n\t\tfloat mid = (size+1)\
    \ / 2;\n\t\treturn std.statistics.median(l[mid], l[mid-1]);\n\t}\n}\n/*\nWrite\
    \ array l to file fname.\nWrite all elements of the array l to the file fname\
    \ separated by a space.\nfname should end with .dat or .dat.gz.\n*/", "{\n  int\
    \ n = l.length;\n  if (n>2)\n    return std.sort(l);\n  return (double)l[n/2];\n\
    }", "{\n\tint lSize = l.length;\n\tif (lSize == 0) \n\t{\n\t\tthrow std::domain_error(\"\
    median : empty list\");\n\t}\n\tif (lSize == 1) \n\t{\n\t\treturn l[0];\n\t}",
  "{\n    int i, j;\n    float mid;\n    \n    i = 1;\n    j = l.length / 2;", "{\n\
    \tlong i,n,m;\n\tfloat f;\n\tint N=l.length;\n\tm=n=(float)N;\n\tif(N%2==1){\n\
    \t\ti=2;\n\t\twhile(i<N){\n\t\t\tif(l[i]<l[i-1]){\n\t\t\t\tm=l[i];\n\t\t\t\tf=m;\
    \ \n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tf=(f+l[i])/(m+1);\n\t}\n\treturn f;\n}\n/*\n\
    Return median of elements in array of structs l.\n    >>> median([(30,'A'), (70,'B'),\
    \ (90,'C'), (20,'D'), (10,'E')])\n    (10, 'E')\n*/", "{\n\tint high, mid, low;\n\
    \tlong sum;\n\tfloat tmp;\n\t\n\tif(l.length < 1) return 0.0f;\n\t\n\thigh = l.length\
    \ - 1;\n\tlow = 0;\n\t\n\twhile (low < high) {\n\t\tmid = (low + high)/2;\n\t\t\
    sum = std.math.addf(l[mid], l[low]);\n\t\tif (sum > 0)\n\t\t\thigh = mid;\n\t\t\
    else\n\t\t\tlow = mid + 1;\n\t}\n\t\n\ttmp = l[low];\n\tl[low] = l[high];\n\t\
    l[high] = tmp;\n\treturn (low+high)/2.0f;\n}", "{\n    if (l == null)\n      \
    \  throw new ArgumentNullException(\"l\");\n    if (l.Length == 0)\n        throw\
    \ new ArgumentException(\"Median: array is empty.\", nameof(l)); \n    if (l.Length\
    \ < 2)\n        throw new ArgumentException(\"Median: array has only one element.\"\
    , nameof(l)); \n    \n    long middle = (long) l.Length / 2;\n    long median\
    \ = l[middle];\n    \n    for (int i = 0; i <= middle; i++)\n    {\n        if\
    \ (l[i] < median)\n        {\n            median = l[i];\n        }\n    }\n \
    \   \n    return median;\n}", "{\n    return std.math.midpoint(l, l);\n}", "{\n\
    \  int len = l.length;\n  if (len > 0) {\n    float midpoint = float((len - 1)\
    \ / 2);\n    if (len % 2 == 1) {\n      return (float) std.math.midpoint(l, 0,\
    \ midpoint, 1);\n    } else {\n      return (float) std.math.midpoint(l, 0, midpoint);\n\
    \    }\n  }\n  return 0.0;\n}", "{\n    if (l.length==0) return 0;\n    int len\
    \ = l.length;\n    float a[]=new float[len];\n    int i;\n    for (i=0;i<len;i++)\
    \ {\n        a[i]=l[i];\n    }\n    sort(a,len);\n    return a[len/2]; // return\
    \ middle element of sorted array\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks\
    \ for your reply, but this code has some bugs, for example when there are three\
    \ elements in the array and median is at middle (like in the example above) it\
    \ returns wrong answer.\n<|/ c |>\n<| a tags=c#,algorithm,sorting |>\n<code>\n\
    public static class ArrayHelper\n    {\n        public static int FindIndex(this\
    \ int[] array, int key)\n        {\n            var startIndex = 0;\n        \
    \    var endIndex = array.Length;\n            var index = 0;", "{\n\tif (l.length\
    \ == 0)\n\t\tthrow new IllegalArgumentException(\"Median of an empty list\");\n\
    \tfloat result = l[0];\n\t\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif\
    \ (l[i] > result)\n\t\t\tresult = l[i];\n\t}\n\t\n\treturn result;\n}", "{\n\t\
    int mid = l.length / 2;\n\tif (l.length%2 == 0)\n\t\treturn std.median(l, mid);\n\
    \telse\n\t\treturn std.median(l, mid+1);\n}", "{\n    float x; \n    int n = l.length;\
    \ \n    if (n < 1) \n        throw new IndexException(\"Median is undefined for\
    \ empty array\"); \n    x =  std.math.pow((n + 1.0) / 2.0f, 0.5f); \n    int k\
    \ = n - 1; \n    while (k >= 1 && l[k - 1] > x) \n        k --; \n    return l[k];\n\
    } \n/*\nReturn median of elements in the array l.\n    >>> median([3L, 1L, 2L,\
    \ 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n\
    \    \n*/\ndouble median(double[] l) \n{\n    double x; \n    int n = l.length;\
    \ \n    if (n < 1) \n        throw new IndexException(\"Median is undefined for\
    \ empty array\"); \n    x =  std.math.pow((n + 1.0) / 2.0f, 0.5); \n    int k\
    \ = n - 1; \n    while (k >= 1 && l[k - 1] > x) \n        k --; \n    return l[k];\n\
    } \n/*\nReturn median of elements in the array l.\n    >>> median([3L, 1L, 2L,\
    \ 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n\
    \    \n*/\nfloat median(float[] l) \n{\n    float x; \n    int n = l.length; \n\
    \    if (n < 1) \n        throw new IndexException(\"Median is undefined for empty\
    \ array\"); \n    x =  std.math.pow((n + 1.0) / 2.0f, 0.5f); \n    int k = n -\
    \ 1; \n    while (k >= 1 && l[k - 1] > x) \n        k --; \n    return l[k];\n\
    } \n/*\nReturn median of elements in the array l.\n    >>> median([3L, 1L, 2L,\
    \ 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n\
    \    \n*/\ndouble median(double[] l) \n{\n    double x; \n    int n = l.length;\
    \ \n    if (n < 1) \n        throw new IndexException(\"Median is undefined for\
    \ empty array\"); \n    x =  std.math.pow((n + 1.0) / 2.0f, 0.5); \n    int k\
    \ = n - 1; \n    while (k >= 1 && l[k - 1] > x) \n        k --; \n    return l[k];\n\
    } \n/*\nReturn median of elements in the array l.\n    >>> median([3L, 1L, 2L,\
    \ 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000", "{\n    var middle =\
    \ l.length / 2;\n    var left = std.math.min(l.slice(0, middle));\n    var right\
    \ = std.math.max(l.slice(middle));\n    return (left + right) / 2.0;\n}\n/*\n\
    Return median of elements in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n\
    \    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\n\
    double median(double[] l) \n{\n    var middle = l.length / 2;\n    var left =\
    \ std.math.min(l);\n    var right = std.math.max(l);\n    return (left + right)\
    \ / 2.0;\n}\n/*\nReturn median of elements in the array l.\n    >>> median([3L,\
    \ 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n\
    \    15.0\n    \n*/\nfloat median(Float[] l) \n{\n    var middle = l.length /\
    \ 2;\n    var left = std.math.min(l.toFloatArray());\n    var right = std.math.max(l.toFloatArray());\n\
    \    return (left + right) / 2.0;\n}\n/*\nReturn median of elements in the array\
    \ l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L,\
    \ 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\ndouble median(Double[] l) \n{\n \
    \   var middle = l.length / 2;\n    var left = std.math.min(l);\n    var right\
    \ = std.math.max(l);\n    return (left + right) / 2.0;\n}", "{\n  float median;\n\
    \  long l1=0;\n  long l2=0;\n  int count=0;\n  for(int i=0;i<l.size();i++)\n \
    \ {\n    count++;\n    if(l[i]>l1)\n    {\n      l1=l[i];\n    }\n    else if(l[i]<l2)\n\
    \    {\n      l2=l[i];\n    }\n  }\n  if(count%2==0)\n  {\n    median=l1;\n  }\n\
    \  else\n  {\n    median=l2;\n  }\n  return median;\n}\n/*\nWrite a function to\
    \ swap two numbers without using third variable. \n*/", "{\n  long i;\n  long\
    \ n;\n  float m=0; \n  for (i=0; i<l.length; i++) {\n    n = l[i];\n    if (n<0)\
    \ {\n      m = (float) (i+1);\n      break;\n    } \n  }\n  return m;\n}", "{\n\
    \    long lower = 0, higher = 0, mid;\n    if (l.length == 0)\n        return\
    \ 0.0;\n    if (l.length == 1) {\n        return l[0];\n    }\n    if (l.length\
    \ % 2 == 0) {\n        lower = l[0];\n        higher = l[1];\n    } else {\n \
    \       mid = (l.length / 2) - 1;\n        lower = l[mid];\n        higher = l[mid];\n\
    \    }", "{\n\tfloat x= std.math.max(l[0]);\n\tfloat y= std.math.max(l[1]);\n\t\
    float z= std.math.max(l[2]);\n\tfloat xm= std.math.min(l[0]);\n\tfloat ym= std.math.min(l[1]);\n\
    \tfloat zm= std.math.min(l[2]);\n\tfloat m= (xm + ym)/2.0f;\n\tfloat lx= std.math.max(l[0]);\n\
    \tfloat ly= std.math.max(l[1]);\n\tfloat lz= std.math.max(l[2]);\n\tfloat mx=\
    \ std.math.min(l[0]);\n\tfloat my= std.math.min(l[1]);\n\tfloat zm= std.math.min(l[2]);\n\
    \tfloat n= (mx + my)/2.0f;\n\tfloat mx1= std.math.max(l[0]);\n\tfloat my1= std.math.max(l[1]);\n\
    \tfloat zm1= std.math.max(l[2]);\n\tfloat nx1= (mx1 + my1)/2.0f;\n\tfloat mx2=\
    \ std.math.min(l[0]);\n\tfloat my2= std.math.min(l[1]);\n\tfloat zm2= std.math.min(l[2]);\n\
    \tfloat nx2= (my2 + zm2)/2.0f;\n\tfloat mx3= std.math.max(l[0]);\n\tfloat my3=\
    \ std.math.max(l[1]);\n\tfloat zm3= std.math.max(l[2]);\n\tfloat nx3= (mx3 + zm3)/2.0f;\n\
    \tfloat mx4= std.math.min(l[0]);\n\tfloat my4= std.math.min(l[1]);\n\tfloat zm4=\
    \ std.math.min(l[2]);\n\tfloat nx4= (my4 + zm4)/2.0f;\n\tfloat mx5= std.math.max(l[0]);\n\
    \tfloat my5= std.math.max(l[1]);\n\tfloat zm5= std.math.max(l[2]);\n\tfloat nx5=\
    \ (mx5 + zm5)/2.0f;\n\tfloat mx6= std.math.min(l[0]);\n\tfloat my6= std.math.min(l[1]);\n\
    \tfloat zm6= std.math.min(l[2]);\n\tfloat nx6= (my6 + zm6)/2.0f;\n\tfloat m7=\
    \ std.math.max(l[0]);\n\tfloat my7= std.math.max(l[1]);\n\tfloat zm7= std.math.max(l[2]);\n\
    \tfloat n7= ", "{\n  int mid = (int) l.length/2;\n  if (l.length % 2 == 1) \n\
    \    return (float)l[mid];\n  else \n    return (float)(0.5 * (l[mid] + l[mid-1]));\n\
    }\n/*\nReturn arithmetic mean of elements in the array l.\n    >>> mean([3L, 1L,\
    \ 2L, 4L, 5L])\n    3.6666666666666665\n    >>> mean([-10L, 4L, 6L, 1000L, 10L,\
    \ 20L])\n    10.5\n    \n*/\nfloat mean(float[] l)\n{\n  float sum = 0.0f;\n \
    \ for (float e : l) sum += e;\n  return sum/l.length;\n}\n/*\nReturn arithmetic\
    \ mean of elements in the array l.\n    >>> mean([3L, 1L, 2L, 4L, 5L])\n    3.6666666666666665\n\
    \    >>> mean([-10L, 4L, 6L, 1000L, 10L, 20L])\n    10.5\n    \n*/\ndouble mean(double[]\
    \ l)\n{\n  double sum = 0.0;\n  for (double e : l) sum += e;\n  return sum/l.length;\n\
    }\n/*\nReturn standard deviation of elements in the array l.\n    >>> stddev([3L,\
    \ 1L, 2L, 4L, 5L])\n    1.081666667\n    >>> stddev([-10L, 4L, 6L, 1000L, 10L,\
    \ 20L])\n    2.019607843\n    \n*/\nfloat stddev(float[] l)\n{\n  float mean=\
    \ mean(l);\n  float sum = 0.0f;\n  for (float e : l) sum += (e - mean)*(e - mean);\n\
    \  return sqrt(sum/l.length);\n}\n/*\nReturn standard deviation of elements in\
    \ the array l.\n    >>> stddev([3L, 1L, 2L, 4L, 5L])\n    1.081666667\n    >>>\
    \ stddev([-10L, 4L, 6L, 1000L, 10L, 20L])\n    2.019607843\n    \n*/\ndouble stddev(double[]\
    \ l)\n{\n  double mean= mean(l);\n  double sum = 0.0;\n  for (double e : l) sum\
    \ += (e - mean)*(e - mean);\n  return sqrt(sum/l.length);\n}\n/*\nReturn the number\
    \ of elements in l that add up to a value x\n    >>> sum([1, 2, 3])\n    4\n \
    \   >>> sum([1, 2, 3, -1, 0])\n    4\n    >>> sum([1, 1, 0])\n    1\n    \n*/",
  "{\n  long a = l[0];\n  long b = l[l.length-1];\n  int mid = 0;\n  int size = l.length;",
  "{\n  if (l.length == 0) \n    return 0L;\n  \n  float pivot = std.math.min(l);\n\
    \  int low = 0;\n  int high = l.length - 1;\n  \n  while (high - low > 1) \n \
    \ {\n    int mid = (low + high) / 2;\n    if (pivot < l[mid]) \n      low = mid\
    \ + 1;\n    else \n      high = mid;\n  }\n  \n  return l[low];\n}", "{\n    float\
    \ m = (float)0.0;\n    int n = l.length;\n    if (n==0) \n    {\n        return\
    \ m;\n    }\n    int m = n/2;\n    if (m==0) \n    {\n        double t = ((double)l[0])/(double)n;\n\
    \        return t;\n    }\n    return std.math._median(l,m,n/2);\n}", "{\n  int\
    \ n = (int) l.length;\n  if (n < 2) \n    return l[0];\n  float m = 0.0;\n  int\
    \ i = 0;\n  while (i < n) \n  {\n    m += l[i];\n    i++;\n  }\n  return (m /\
    \ n);\n}", "{\n\tsort(l);\n\treturn l[l.length/2];\n}\n/*\nReturn median of elements\
    \ of vector v of length n sorted from low to high.\n    >>> median([2, 3, 1, 5,\
    \ 6, 4])\n    2.0\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n\
    \    \n*/\nfloat median(float v[], int n) \n{\n\tsort(v,0,n-1);\n\treturn v[n.length/2];\n\
    }\n/*\nReturn median of elements in array l of size n. \n    l is expected to\
    \ be array of longs.\n    >>> median([3L, 1L, 2L, 4L, 5L], 4)\n    3L\n    \n\
    */\nlong median(long[] l, int n)\n{\n\tsort(l,0,n-1);\n\treturn l[n.length/2];\n\
    }\n/*\nReturn median of elements in vector v of length n sorted from low to high.\n\
    \    >>> median([2, 3, 1, 5, 6, 4], 4)\n    2.0\n    >>> median([-10L, 4L, 6L,\
    \ 1000L, 10L, 20L], 4)\n    15.0\n    \n*/\nlong median(long v[], int n) \n{\n\
    \tsort(v,0,n-1);\n\treturn v[n.length/2];\n}\n/*\nReturn the mean of elements\
    \ in the array l.\n    >>> mean([3L, 1L, 2L, 4L, 5L])\n    1.5\n    >>> mean([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    60.0\n    \n*/\nfloat mean(long[] l) \n{\n\t\
    float sum = 0.0f;\n\tfor (int i = 0; i < l.length; i++){\n\t\tsum += l[i];\n\t\
    }\n\treturn sum / l.length;\n}\n/*\nReturn the mean of elements of vector v of\
    \ length n sorted from low to high.\n    >>> mean([2, 3, 1, 5, 6, 4], 4)\n   \
    \ 2.0\n    >>> mean([-10L, 4L, 6L, 1000L, 10L, 20L], 4)\n    60.0\n    \n*/\n\
    float mean(float v[], int n) \n{\n\tfloat sum = 0.0f;\n\tfor (int i = 0; i < n;\
    \ i++){\n\t\tsum += v[i];\n\t}\n\treturn sum / n;\n}\n/*\nReturn the mean of elements\
    \ in array l of size n. \n    l is expected to be array of longs.\n    >>> mean([3L,\
    \ 1L, 2L, 4L, 5L], 4)\n    1.5\n    \n*/\nlong mean(long[] l, int n)\n{\n\tlong\
    \ sum = 0;\n\tfor (int i = 0; i < l.length; i++){", "{\n\tlong low = std.min(l);\n\
    \tlong high = std.max(l);\n\tif (low != high)\n\t{\n\t\treturn std.ceil(std.fabs(low\
    \ + std.fabs((high - low) / 2)));\n\t}\n\telse\n\t{\n\t\treturn std.ceil(low +\
    \ std.fabs((high - low) / 2));\n\t}\n}", "{\n    float tmp;\n    float res = 0;\n\
    \    int len = length(l);\n    if (len > 0) {\n        tmp = std.math.pow2((float)len/2);\n\
    \        res = std.math.remainder((float)len/2, tmp);\n    }\n    return res;\n\
    }\n</code>\n<|/ a dscore=2 tags=function,function-declaration,c,arrays |>\n<|\
    \ c |>\nWhat is the difference between this and my answer?\n<|/ c |>\n<| c |>\n\
    Yeah but i was first and after that i changed my answer. And i thought that his\
    \ answer is not complete and i want to improve my answer\n<|/ c |>\n<| c |>\n\
    i think this one is a little better, no need for int len = length(l);\n<|/ c |>\n\
    <| c |>\nYeah i think this is better\n<|/ c |>\n<| c |>\nThis looks like O(n)\
    \ solution, OP asked for O(1) solution.\n<|/ c |>\n<| a dscore=1 tags=function,function-declaration,c,arrays\
    \ |>\nYou can use a for loop for this:\n<code>\n#include <stdio.h>", "{\n \n int\
    \ n = l.size();\n \n if (n & 1)\n {\n    float x = (float)n / 2.0f;\n    return\
    \ std.math::min(std.math::max(l[0], l[x]), l[n-1]);\n }\n else\n {\n    return\
    \ l[n / 2];\n }\n}", "{\n    double h = (double)l.length/2;\n    return std.math.sqr(std.math.reduce(\n\
    \        l.subarray(0, h),\n        l.subarray(h, l.length)))/2;\n}", "{\n\treturn\
    \ std.math._median(l);\n}\n/*\nReturn the minimum value of the array l.\n*/\n\
    float min(float[] l)\n{\n\treturn std.math._min(l);\n}\n/*\nReturn the maximum\
    \ value of the array l.\n*/\nfloat max(float[] l)\n{\n\treturn std.math._max(l);\n\
    }\n/*\nReturn minimum index of the array l such that l[i] < l[i+1]\nIf no such\
    \ index exists, returns -1\n*/", "{\n  long med = std.math.max(l);\n  long sum\
    \ = 0;\n  for (long i = 0; i<l.length; ++i) {\n    sum += l[i];\n    if (sum >\
    \ med)\n      med = sum;\n  }\n  return (float)med;\n}", "{\n  int size = sizeof(l)\
    \ / sizeof(long);\n  if (size <= 0) return 0L;\n  sort(l, l, size);\n  return\
    \ l[size/2];\n}\n/*\nReturn median of elements in the array l.\n    >>> median([3L,\
    \ 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n\
    \    15.0\n    \n*/\nfloat median(short[] l) \n{\n  int size = sizeof(l) / sizeof(short);\n\
    \  if (size <= 0) return 0L;\n  sort(l, l, size);\n  return l[size/2];\n}\n/*\n\
    Return median of elements in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n\
    \    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\n\
    float median(float[] l) \n{\n  int size = sizeof(l) / sizeof(float);\n  if (size\
    \ <= 0) return 0L;\n  sort(l, l, size);\n  return l[size/2];\n}\n/*\nReturn median\
    \ of elements in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n\
    \    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\nfloat median(double[]\
    \ l) \n{\n  int size = sizeof(l) / sizeof(double);\n  if (size <= 0) return 0L;\n\
    \  sort(l, l, size);\n  return l[size/2];\n}\n/*\nReturn median of elements in\
    \ the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\nfloat median(byte[] l) \n{\n\
    \  int size = sizeof(l) / sizeof(byte);\n  if (size <= 0) return 0L;\n  sort(l,\
    \ l, size);\n  return l[size/2];\n}\n/*\nReturn median of elements in the array\
    \ l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L,\
    \ 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\nfloat median(char[] l) \n{\n  int\
    \ size = sizeof(l) / sizeof(char);\n  if (size <= 0) return 0L;\n  sort(l, l,\
    \ size);\n  return l[size", "{\n    long m = l[0];\n    for (long i = 0; i < l.length;\
    \ i++)\n        if (l[i] < m)\n            m = l[i];\n    \n    for (long i =\
    \ l.length - 1; i > 0; i--)\n        if (l[i] > m)\n            m = l[i];\n  \
    \  \n    return m;\n}", "{\n    long temp;\n    int size = (l.length/2);\n   \
    \ float result = 0;\n    for(int i=0; i<size; i++)\n    {\n        temp = l[i];\n\
    \        result = result + temp;\n    }\n    return result / size;\n}\n</code>\n\
    <|/ a tags=java,arrays,sorting dscore=0 |>\n<| a |>\n<code>\npublic class SelectionSort\
    \ {\n    public static void main(String[] args){\n        int[] nums = new int[]\
    \ {4, 3, 7, 4, 1};\n        int[] sortedNums = new int[nums.length];", "{\n  \
    \  return (float)(l.length == 0 ? 0 : std.math.toIntExact(std.math.toDouble(std.math.median(l)))\
    \ - 1);\n}", "{\n  if (l.length == 0) \n  {\n    return 0L;\n  }\n  long sum =\
    \ 0L;\n  int count = 0;\n  for (int i = 0; i < l.length; i++) \n  {\n    sum +=\
    \ l[i];\n    count++;\n  }\n  float result = ((float) sum) / count;\n  return\
    \ result;\n}", "{\n\tfloat result = 0;\n\tfloat average = (float)l.length / 2.0f;\n\
    \tfloat temp;\n\tint count;\n\t\n\tfor (int i = 0; i < l.length; i++){\n\t\ttemp\
    \ = (float)l[i];\n\t\tcount = 0;\n\t\twhile (temp != 0){\n\t\t\tif (temp % 2 ==\
    \ 0){\n\t\t\t\ttemp /= 2;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttemp\
    \ = (float)(temp / 2);\n\t\t\t}\n\t\t}\n\t\tresult = result + (float)count;\n\t\
    }\n\t\n\tresult /= (float)l.length;\n\t\n\tif (result > average){\n\t\treturn\
    \ result;\n\t}\n\telse{\n\t\treturn average + result;\n\t}\n}", "{\n    long i,\
    \ j;\n    long len = l.length;\n    if (len < 2)\n        return l[0];\n    long\
    \ mid = len/2;\n    long w = 0;\n    float m = l[0];\n    float m_next = l[0];\n\
    \    for(long i = 1; i < len; i++)\n    {\n        m_next = m + l[i];\n      \
    \  w += l[i] - m_next;\n        m = m_next;\n    }\n    return m*(float)w/len;\n\
    }\n/*\nReturn median of elements in the array l.\n    >>> median([3L, 1L, 2L,\
    \ 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n\
    \    \n*/\nfloat median(float[] l) \n{\n    float w = 0;\n    float m_next = l[0];\n\
    \    for(float m : l)\n        w += m - m_next;\n    float m = l[0];\n    float\
    \ m_next = l[0];\n    for(float m : l)\n    {\n        m_next = m + l;\n     \
    \   w += l - m_next;\n        m = m_next;\n    }\n    return m*(float)w/len;\n\
    }\n/*\nReturn median of elements in the array l.\n    >>> median([3L, 1L, 2L,\
    \ 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n\
    \    \n*/\ndouble median(double[] l) \n{\n    double w = 0;\n    double m_next\
    \ = l[0];\n    for(double m : l)\n        w += m - m_next;\n    double m = l[0];\n\
    \    double m_next = l[0];\n    for(double m : l)\n    {\n        m_next = m +\
    \ l;\n        w += l - m_next;\n        m = m_next;\n    }\n    return m*(double)w/len;\n\
    }\n/*\nReturn median of elements in the array l.\n    >>> median([3L, 1L, 2L,\
    \ 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n\
    \    \n*/\nfloat median(short[] l) \n{\n    short w = 0;\n    short m_next = l[0];\n\
    \    for(short m : l)\n        w += m - m_next;\n    short m = l[0];\n    short\
    \ m_next = l[0];\n    for(short m : l)\n    {\n        m_next = m + l;\n     \
    \   w += l - m_next;\n        m = m_next;\n    }\n    return m*(float)w/len;\n\
    }\n/*\nReturn median ", "{ \n    if (l.length == 0)\n        throw new RuntimeException(\"\
    Cannot compute median of an empty list\");\n    int mid = l.length / 2;\n    int\
    \ left = mid; \n    int right = mid;\n    long m = 0;\n    int i = 1;\n    while\
    \ (i <= l.length)\n    { \n        if (left+1 == right)\n        {\n         \
    \   if (l[left] < 0)\n            {\n                m++;\n            }\n   \
    \     }\n        else\n        {\n            if (l[left] < l[right])\n      \
    \      {\n                m++;\n            }\n            else\n            {\n\
    \                m--;\n            }\n        }\n        if (i == mid)\n     \
    \   {\n            i = 2;\n        }\n        if (l[left] >= l[right])\n     \
    \   {\n            left++;\n        }\n        else\n        {\n            right--;\n\
    \        }\n    }\n    return (float) m;\n}\n</code>\n<|/ a |>\n<| c |>\nThanks\
    \ for your answer but I don't understand... What is the variable m?\n<|/ c |>\n\
    <| c |>\nIt should be the median of the whole array, which is `m`\n<|/ c |>\n\
    <| c |>\nWhy did you choose `mid` as the pivot instead of `l.length/2` as the\
    \ pivot?\n<|/ c |>\n<| c |>\nIf `l.length/2` divides evenly into `mid`, then `mid`\
    \ will be the median, which is not what we want. If `l.length/2` divides evenly\
    \ into `l.length`, then the median will be the index of the middle element (index\
    \ `mid`). So we must take the middle element as the pivot. Of course, this could\
    \ also happen if all elements are equal. In this case `l.length/2` should also\
    \ divide evenly into `l.length`, which makes the `while` loop infinite in that\
    \ case.\n<|/ c |>\n<| c |>\nAnd `l.length/2` works better than `l.length`, because\
    \ it divides evenly into `l.length`. `l.length/2` will divide evenly into `l.length/2`,\
    \ which gives us `l.length` for the next iteration, which makes the `while` loop\
    \ infinite in that case.\n<|/ c |>\n<| a tags=java,arrays,median,sorting |>\n\
    In case of two numbers being equal, we can sort them in ascending order. Then\
    \ the middle number will always get its position where they got equal values.\n\
    For this case where we can't sort them in ascending order, we can sort them in\
    \ descending order and get the median number.\n<code>\npublic static long getMedianNumber(long\
    \ [] arr) {\n    int middle = arr.length / ", "{\n    int n = l.length;\n    sort(l);\n\
    \    return (float)n/2 * (long)(l[n/2] + (n - 1)/2 * l[n/2+1]);\n}", "{\n  long\
    \ mid = length(l)/2;\n  \n  if (length(l) % 2 == 0) {\n    return std.min(std.min(l[mid]),\
    \ std.max(l[mid])) / 2;\n  } else {\n    return (l[mid] + l[mid+1]) / 2;\n  }\n\
    }\n/*\nReturn median of elements in the array l which have a value less than v.\n\
    \    \n    >>> median([3, 1, 1, 4, 5], 1)\n    1L\n    >>> median([3, 1, 1, 4,\
    \ 5], 2)\n    3L\n    >>> median([3, 1, 1, 4, 5], 4)\n    4L\n    \n    \n*/\n\
    float median(long[] l, float v) \n{\n  long mid = length(l)/2;\n  \n  if (length(l)\
    \ % 2 == 0) {\n    long i;\n    float leftMedian, rightMedian;\n    \n    leftMedian\
    \ = median(l);\n    rightMedian = median(std.reverse(l));\n    \n    for (i =\
    \ 0; i < length(l); i++) {\n      if (l[i] < v) {\n\tl[i] = leftMedian;\n    \
    \  } else {\n\tl[i] = rightMedian;\n      }\n    }\n    return leftMedian;\n \
    \ } else {\n    return (l[mid] + l[mid+1]) / 2;\n  }\n}\n/*\nReturn median of\
    \ elements in the array l which have a value less than v.\n    \n    >>> median([3,\
    \ 1, 1, 4, 5], 1)\n    1L\n    >>> median([3, 1, 1, 4, 5], 2)\n    3L\n    >>>\
    \ median([3, 1, 1, 4, 5], 4)\n    4L\n    \n    \n*/\nfloat median(long[] l, float\
    \ v, float v1) \n{\n  long mid = length(l)/2;\n  \n  if (length(l) % 2 == 0) {\n\
    \    long i;\n    float leftMedian, rightMedian;\n    \n    leftMedian = median(l);\n\
    \    rightMedian = median(std.reverse(l));\n    \n    for (i = 0; i < length(l);\
    \ i++) {\n      if (l[i] < v && l[i] > v1) {\n\tl[i] = leftMedian;\n      } else\
    \ if (l[i] > v && l[i] < v1) {\n\tl[i] = rightMedian;\n      }\n    }\n    return\
    \ leftMedian;\n  } else {\n    return (l[mid] + l[mid+1]) / 2;\n  }\n}\n/*\nReturn\
    \ the index of a given value in the array l.\n    \n    >>> index([3, 1, 5, 1,\
    \ 5, 1])\n    4\n    \n*/\nlong index(long[] l, long v) \n{\n  long i;\n  \n \
    \ for (i = 0; i < length(l); i++) {\n    if (l[i] == v) {\n      return ", "{\n\
    \    if ( l.size() > 0 )\n    {\n        long temp = 0;\n        \n        for\
    \ ( long i = 1; i < l.size(); i++ )\n        {\n            temp += l[i];\n  \
    \      }\n        \n        return temp / l.size();\n    }\n    else\n       \
    \ return 0;\n}", "{\n\t\n\tif (l.length>0)\n\t{\n\t\tfloat median=0;\n\t\tfloat\
    \ count=0; // total no of elements in array \n\t\tfor(int i=0;i<l.length;i++)\n\
    \t\t{\n\t\t\tif(l[i]!=-1)\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tif(count==2)\n\t\
    \t\t\t{\n\t\t\t\t\tmedian=l[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\
    \t\t\n\t\tif(count==1)\n\t\t\treturn median;\n\t\t\n\t\tint count=0;\n\t\tfor(int\
    \ i=0;i<l.length;i++)\n\t\t{\n\t\t\tif(l[i]!=-1)\n\t\t\t{\n\t\t\t\tcount++;\n\t\
    \t\t}\n\t\t}\n\t\t\n\t\tif(count%2==0)\n\t\t\treturn (float)median;\n\t\t\n\t\t\
    return (float)((l[(count-1)/2] + l[count/2])/2); \n\t}\n\t\n\treturn -1.0f;\n}",
  "{\n\tint i, count = 0;\n\tfloat v = 0.0;\n\tfor (i = 0; i < l.length; i++) \n\t\
    {\n\t\tcount += l[i];\n\t\tif (count > 0) \n\t\t\tv = l[i];\n\t\telse \n\t\t\t\
    v = 0.0;\n\t}\n\treturn v;\n}", "{\n    int n = l.length;\n    long middle = n\
    \ / 2;\n    if (n % 2 != 0)\n        middle++;\n    double d = std.math._median(double[]\
    \ l, int low, int high);\n    return std.math._toDouble(d);\n}", "{\n    int length\
    \ = l.length; \n    int half = (length+1)/2; \n    if (length%2==0) return std.math.max(l[half-1],\
    \ l[half]);\n    return std.math.max(l[half-1], l[half-1]);\n}", "{\n    float\
    \ sum = 0;\n    int i;\n    for (i = 0; i < l.length; i++) {\n        sum += l[i];\n\
    \    }\n    return (float)sum/(float)l.length;\n}", "{\n\tint mid;\n\tint low\
    \ = 0;\n\tint high = l.length-1;\n\tfloat a = 0;\n\tfloat b = 0;\n\tfloat c;\n\
    \t\n\twhile(low<=high)\n\t{\n\t\tmid = (low+high)/2;\n\t\ta = l[mid];\n\t\tlow\
    \ = mid+1;\n\t\twhile (low<=high)\n\t\t{\n\t\t\tif (l[mid] > a)\n\t\t\t{\n\t\t\
    \t\tb = l[mid];\n\t\t\t\tl[mid] = a;\n\t\t\t\ta = b;\n\t\t\t}\n\t\t\tmid = (mid+low)/2;\n\
    \t\t\tlow = mid+1;\n\t\t}\n\t\thigh = mid-1;\n\t\tc = l[mid];\n\t\tl[mid] = a;\n\
    \t}\n\treturn l[0];\n}", "{\n    int len = length(l);\n    if (len <= 1)\n   \
    \     return l[0];\n    float mid = (len - 1) / 2.0;\n    float l = mid;\n   \
    \ float r = mid - 1;\n    while (true) {\n        if (l<0)\n            return\
    \ r;\n        if (r>=len)\n            return l;\n        if (l<r) \n        \
    \    return l;\n        float m = (l+r) / 2;\n        if (l > r)\n           \
    \ l = r;\n        else if (l == r)\n            return m;\n        r = m;\n  \
    \  }\n}", "{\n  long n = (l.length + 1) / 2;\n  int m = (int) n;\n  float f =\
    \ l[m];\n  int j;\n  for (j = 1; j < n; ++j) {\n    if (f < l[j])\n      m = j;\n\
    \  }\n  return f;\n}", "{\n\tlong mid = l.length/2;\n\tif (l.length % 2 == 1)\n\
    \t\treturn l[mid];\n\treturn std.math.ceil(l[mid]) + std.math.floor(l[mid-1]);\n\
    }\n/*\nReturn average of elements in the array l.\n    >>> average([3L, 1L, 2L,\
    \ 4L, 5L])\n    2.0\n    >>> average([-10L, 4L, 6L, 1000L, 10L, 20L])\n    6.0\n\
    \    \n*/\nfloat average(long[] l) \n{\n\tfloat sum = 0.0;\n\tfor(int i=0; i<l.length;\
    \ i++) {\n\t\tsum += l[i];\n\t}\n\treturn sum / l.length;\n}\n/*\nReturn standard\
    \ deviation of elements in the array l.\n    >>> stddev([3L, 1L, 2L, 4L, 5L])\n\
    \    1.41421356237\n    >>> stddev([-10L, 4L, 6L, 1000L, 10L, 20L])\n    8.85663089916\n\
    \    \n*/\nfloat stddev(long[] l) \n{\n\tfloat mean = 0;\n\tfor(int i=0; i<l.length;\
    \ i++) {\n\t\tmean += l[i];\n\t}\n\treturn (float)Math.sqrt(std.math.pow(std.math.abs(mean-l.average()),2));\n\
    }\n/*\nReturn max of elements in the array l.\n    >>> max([3L, 1L, 2L, 4L, 5L])\n\
    \    5L\n    >>> max([-10L, 4L, 6L, 1000L, 10L, 20L])\n    1000L\n    \n*/\nlong\
    \ max(long[] l) \n{\n\treturn std.math.max(l);\n}\n/*\nReturn min of elements\
    \ in the array l.\n    >>> min([3L, 1L, 2L, 4L, 5L])\n    -10L\n    >>> min([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    -10L\n    \n*/\nlong min(long[] l) \n{\n\treturn\
    \ std.math.min(l);\n}\n/*\nReturn sum of elements in the array l.\n    >>> sum([3L,\
    \ 1L, 2L, 4L, 5L])\n    6L\n    >>> sum([-10L, 4L, 6L, 1000L, 10L, 20L])\n   \
    \ -10L\n    \n*/\nlong sum(long[] l) \n{\n\treturn std.math.sum(l);\n}\n/*\nReturn\
    \ absolute difference between l and r.\n    >>> abs([1L, -2L, 3L])\n    [1L, 3L]\n\
    \    \n*/\nlong[] abs(long[] l, long[] r) \n{\n\tlong[] result = new long[l.length];\n\
    \t", "{\n\tif (l.length == 0) return 0;\n\treturn std.math.floor(std.math.sqrt(l.length)\
    \ * std.math.sqrt(0.5)) + 1;\n}\n/*\nReturn median of elements in given array\
    \ of sorted integers.\n    >>> median([3, 1, 2, 5, 4])\n    3\n    >>> median([2,\
    \ 3, 4, 5, 6])\n    3\n*/", "{\n  int lsize = l.length;\n  float m = (float)(lsize\
    \ / 2);\n  if (lsize % 2 == 0) return std.math.floor(m + std.math.toInt(l.array[std.math.floor_(m)])).asFloat();\n\
    \  else return std.math.floor(std.math.toInt(l.array[std.math.floorDiv(m, 2)])\
    \ + std.math.floorDiv(m, 2)).asFloat();\n}", "{\n\tint N = l.length;\n\tif (N\
    \ == 0) return 0.0;\n\tif (N <= 1) return l[0];\n\t\n\tint m = N >> 1;\n\t\n\t\
    float left = median(l);\n\tfloat right = median(l.subarray(1, m));\n\t\n\tif (right\
    \ < left)\n\t\treturn right;\n\telse\n\t\treturn left + 0.5f * left.distance +\
    \ right.distance * (m-1)/2.0f;\n}", "{\n    long half;\n    sort(l, l + 1, l +\
    \ 1);\n    half = (l - 1) >> 1;\n    if ( l % 2 == 0 ) return l[half];\n    else\
    \ return (float(l[half]) + float(l[half - 1]))/2;\n}", "{ \n    if (l.length==0)\
    \ return 0.0f;\n    sort(l, l.length); \n    long mid=l.length/2;\n    return\
    \ (mid<l.length)?l[mid]:(mid==0)?l[0]:((mid>0)?l[mid - 1]+l[mid]:(mid==l.length-1)?l[mid]:(mid==l.length/2-1)));\
    \ \n}\nfloat median(double[] l) \n{ \n    if (l.length==0) return 0.0f;\n    sort(l,\
    \ l.length); \n    long mid=l.length/2;\n    return (mid<l.length)?l[mid]:(mid==0)?l[0]:((mid>0)?l[mid\
    \ - 1]+l[mid]:(mid==l.length-1)?l[mid]:(mid==l.length/2-1))); \n}\nfloat median(int[]\
    \ l) \n{ \n    if (l.length==0) return 0.0f;\n    sort(l, l.length); \n    long\
    \ mid=l.length/2;\n    return (mid<l.length)?l[mid]:(mid==0)?l[0]:((mid>0)?l[mid\
    \ - 1]+l[mid]:(mid==l.length-1)?l[mid]:(mid==l.length/2-1))); \n}\nfloat median(short[]\
    \ l) \n{ \n    if (l.length==0) return 0.0f;\n    sort(l, l.length); \n    long\
    \ mid=l.length/2;\n    return (mid<l.length)?l[mid]:(mid==0)?l[0]:((mid>0)?l[mid\
    \ - 1]+l[mid]:(mid==l.length-1)?l[mid]:(mid==l.length/2-1))); \n}\nfloat median(char[]\
    \ l) \n{ \n    if (l.length==0) return 0.0f;\n    sort(l, l.length); \n    long\
    \ mid=l.length/2;\n    return (mid<l.length)?l[mid]:(mid==0)?l[0]:((mid>0)?l[mid\
    \ - 1]+l[mid]:(mid==l.length-1)?l[mid]:(mid==l.length/2-1))); \n}\nfloat median(byte[]\
    \ l) \n{ \n    if (l.length==0) return 0.0f;\n    sort(l, l.length); \n    long\
    \ mid=l.length/2;\n    return (mid<l.length)?l[mid]:(mid==0)?l[0]:((mid>0)?l[mid\
    \ - 1]+l[mid]:(mid==l.length-1)?l[mid]:", "{\n    long n = length(l);\n    if\
    \ (n <= 1)\n        return l[0];\n    return std.cmath::median(l);\n}\n/*\nReturn\
    \ median of elements in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n \
    \   3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\n\
    float median(double[] l) \n{\n    double n = length(l);\n    if (n <= 1)\n   \
    \     return l[0];\n    return std.cmath::median(l);\n}\n/*\nReturn median of\
    \ elements in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n   \
    \ >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\nfloat median(float[]\
    \ l) \n{\n    float n = length(l);\n    if (n <= 1)\n        return l[0];\n  \
    \  return std.cmath::median(l);\n}\n/*\nReturn median of elements in the array\
    \ l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n    >>> median([-10L, 4L,\
    \ 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\ndouble median(int[] l) \n{\n    int\
    \ n = length(l);\n    if (n <= 1)\n        return l[0];\n    return std.cmath::median(l);\n\
    }\n/*\nReturn median of elements in the array l.\n    >>> median([3L, 1L, 2L,\
    \ 4L, 5L])\n    3L\n    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n\
    \    \n*/\ndouble median(long[] l) \n{\n    long n = length(l);\n    if (n <=\
    \ 1)\n        return l[0];\n    return std.cmath::median(l);\n}\n/*\nReturn median\
    \ of elements in the array l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L\n\
    \    >>> median([-10L, 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/\ndouble median(double[]\
    \ l) \n{\n    double n = length(l);\n    if (n <= 1)\n        return l[0];\n \
    \   return std.cmath::median(l);\n}\n/*\nReturn median of elements in the array\
    \ l.\n    >>> median([3L, 1L, 2L, 4L, 5L])\n    3L", "{\n    int hi = l.length/2;\n\
    \    int lo = 0;\n    if(l.length%2)\n        return l[hi];\n    else if(l.length==1)\n\
    \        return l[0];\n    else \n        return ((double) l[hi] + (double) l[lo])/2.0;\n\
    }\n</code>\nIt might be useful to have a median.rs file so you can import all\
    \ your functions by simply typing median or median::median.\n<|/ a |>\n<| a dscore=1\
    \ |>\nThis code finds the median of a list.\n<code>\n// Returns the median of\
    \ a list, with its index position in the list.\n// Returns nil if the list is\
    \ empty.\npub fn median<T: Clone>(list: &[T]) -> Option<T>\n{\n    list.iter().cloned().enumerate().fold(Some(list.len()/2),\
    \ |max, (idx, item)| {\n        if *max < (idx+1)/2 {\n            Some(item)\n\
    \        } else if idx == list.len() - 1 {\n            Some(item)\n        }\
    \ else {\n            None\n        }\n    })\n}\n</code>\n<|/ a tags=rust,algorithm,list\
    \ |>\n<| a |>\nThis function return the median of a list:\n<code>\nfn median(list:\
    \ &[Int]) -> Option<Int> {\n    let mut list_count = list.len();\n    if list_count\
    \ % 2 == 1 {\n        Some(list[list_count / 2])\n    } else {\n        let mid_index\
    \ = list_count / 2;\n        let left  = list.split_at(mid_index);\n        let\
    \ right = list.split_at_mut(mid_index);", "{\n  if(l.length==0)\n    return 0f;\n\
    \  int mid = l.length / 2; // find mid point of l of even length\n  if(l.length%2==0)\
    \ \n    return std.crunch(l.subarray(0, mid))/std.crunch(l.subarray(mid, l.length));\n\
    \  else \n    return std.crunch(l.subarray(0, mid))/std.crunch(l.subarray(mid-1,\
    \ mid));\n}", "{\n    int len = l.length;\n    if (len <= 1) return l[0];\n  \
    \  float middle = (len - 1) / 2.0;\n    float median = 0;\n    for (int i = 0;\
    \ i < len; i++) {\n        if (l[i] < l[middle]) \n            return l[i];\n\
    \        if (l[i] > l[middle]) \n            return l[i];\n    }\n    return l[middle];\n\
    }", "{\n    int n = l.length;\n    if (n < 1) return 0L;\n    sort(l);\n    if\
    \ (n % 2 == 0)\n        return (l[n/2] + l[n/2-1])/2L;\n    return (l[n/2-1] +\
    \ l[n/2])/2.0L;\n}\n</code>\n<|/ a tags=algorithm,c++,sorting dscore=3 |>\n<|\
    \ c |>\nYes, the complexity is O(n + nlogn) because you have to sort twice. One\
    \ for finding median and the other for partitioning.\n<|/ c |>\n<| c |>\nThe median\
    \ of a set of N elements is just the middle element, so (n/2)th element of the\
    \ sorted array.\n<|/ c |>\n<| a dscore=2 |>\nYou can find median in O(n), where\
    \ n is number of elements in array.\n<code>", "{\n  if (l.length == 0) \n  {\n\
    \    throw new RuntimeException(\"Array is empty.\");\n  }\n  long l = std.math.toInt64(l);\n\
    \  int center = (l.length)/2;\n  \n  int leftIndex = center-1;\n  int rightIndex\
    \ = center;\n  \n  while (leftIndex >= 0 && leftIndex < l.length)\n  {\n    while\
    \ (leftIndex < l.length && l[leftIndex] < l[leftIndex+1])\n      leftIndex++;\n\
    \    if (leftIndex == l.length)\n    {\n      break;\n    }\n  }\n  \n  while\
    \ (rightIndex < l.length && l[rightIndex] < l[rightIndex-1])\n    rightIndex++;\n\
    \  \n  if (rightIndex == l.length) \n  {\n    return l[leftIndex];\n  }\n  \n\
    \  if (leftIndex == -1) \n  {\n    return l[rightIndex];\n  }\n  \n  return (float)l[leftIndex]\
    \ + (float)l[rightIndex];\n}", "{\n    int lSize = l.length;\n    if(lSize ==\
    \ 0)\n        return 0;\n    \n    float pivot = l[(lSize - 1) / 2];\n    \n \
    \   for(int i = 0; i < lSize; ++i)\n    {\n        if(l[i] <= pivot)\n       \
    \ {\n            swap(i, lSize - 1 - i);\n            int j = lSize - 1 - i;\n\
    \            for(int k = i; k < lSize - 1; ++k)\n            {\n             \
    \   if(l[k] > l[k + 1])\n                {\n                    swap(k, k + 1);\n\
    \                    j++;\n                }\n            }\n        }\n    }\n\
    \    return pivot;\n}", "{\n\tfloat f = 0.0f;\n\tfloat m = 0.0;\n\t\n\tfor(int\
    \ i = 0; i < l.length; i++)\n\t{\n\t\tf += l[i];\n\t\tif(i == 0)\n\t\t\tm = f;\n\
    \t\telse if(f >= m)\n\t\t\tm = f;\n\t}\n\treturn m;\n}", "{\n    int count = 0;\n\
    \    int n = l.length;\n    float median = 0;\n    while (count < n) {\n     \
    \   if (l[count] < median) {\n            median = l[count];\n        }\n    \
    \    count++;\n    }\n    return median;\n}", "{\n\tlong len = length(l);\n\t\
    float m = 0;\n\tint i = 0;\n\twhile (i < len) {\n\t\tm += l[i];\n\t\ti++;\n\t\
    }\n\tm /= len;\n\treturn m;\n}", "{\n    int n = l.length;\n    float m = std.math.rect(0.f,\
    \ (n+1)/2.f);\n    for (int i = 0; i < n; ++i) {\n        m = (std.math.rect(m.f,\
    \ (n - i - 1)/2.f) + l[i])/2.f;\n    }\n    return m;\n}", "{\n\tint size = (int)(l.length\
    \ / 2); \n\tif (l.length % 2 == 1) \n\t\treturn l[size]; \n\treturn std.math.fsum(l[size-1],\
    \ \n\t\t\t\t  l.length>size ? l[size] : l.length>size+1 ? l[size+1] : 0);\n}",
  "{\n    int i;\n    float temp;\n    long mid;", "{\n    sort(l);\n    return (l[l\
    \ - 1] + l[l - 2]) / 2.0f;\n}", "{\n\tfloat m=0; \n\t\n\tfor(int i=0; i< l.length;\
    \ ++i) \n\t{\n\t\tif(i==0)\n\t\t\tm = l[i];\n\t\telse if(i==l.length-1)\n\t\t\t\
    m = l[i-1];\n\t\telse\n\t\t{\n\t\t\tif(l[i] > l[i-1])\n\t\t\t{\n\t\t\t\tfloat\
    \ t = (l[i] + l[i-1])/2.0f;\n\t\t\t\tm = t;\n\t\t\t}\n\t\t}\n\t}\n\treturn m;\n\
    }\n// ******************************************* //\n// *******************************************\
    \ //\n// ******************************************* //\n// *******************************************\
    \ //\n// ******************************************* //\n// *******************************************\
    \ //\n// ******************************************* //\n// *******************************************\
    \ //\n/*\nReturn the sum value in a vector l.\n    >>> sum([1, 2, 3, 4, 5])\n\
    \    15\n*/\nfloat sum(float[] l) \n{\n\tfloat s = 0;\n\tfor (int i = 0; i < l.length;\
    \ ++i) \n\t{\n\t\ts += l[i];\n\t}\n\treturn s;\n}\n/*\nReturn the average value\
    \ in a vector l.\n    >>> sum([1, 2, 3, 4, 5])\n    5.5\n*/\nfloat average(float[]\
    \ l) \n{\n\treturn sum(l) / l.length;\n}\n// *******************************************\
    \ //\n// ******************************************* //\n// *******************************************\
    \ //\n// ******************************************* //\n// *******************************************\
    \ //\n// ******************************************* //\n// *******************************************\
    \ //\n// ******************************************* //\n/*\nConvert radians to\
    \ degrees.\n>>> degrees(radians(3.14))\n30.0\n*/\nfloat degrees(float rad) {\n\
    \treturn rad * 360.0f;\n}\n/*\nConvert degrees to radians.\n>>> radians(30.0)\n\
    3.14\n*/\nfloat radians(float deg) {\n\treturn deg * 0.0174532925f;\n}\n/*\nReturn\
    \ the distance between the point (x, y) and the point (x', y').\n*/\nfloat distance(float\
    \ x, float y, float x' , float y')\n{\n\tfloat dx = x - x;\n\tfloat dy = y - y;\n\
    \treturn sqrt(dx*dx + dy*dy);\n}\n// *******************************************\
    \ //\n// ******************************************* //\n// *******************************************\
    \ //\n// ******************************************* //\n// *******************************************\
    \ //\n// ******************************************* //\n// *******************************************\
    \ //\n/*\nReturn the distance between the point (x, y) and the point (x', y').\n\
    */\nfloat distance(float x, float y, float x' , float y') \n{\n", "{\n    float\
    \ n = l.len();\n    float m = (n + 1) >> 1;\n    float x = l[0];\n    for(int\
    \ i = 1; i < m; i++)\n    {\n        if(l[i] > x)\n        {\n            x =\
    \ l[i];\n        }\n    }\n    return x;\n}", "{\n    int n = l.length();\n  \
    \  if (n < 1) {\n        throw new RuntimeException(\"Can't compute median of\
    \ an empty vector\");\n    }\n    float m = (float) n;\n    int m = n / 2;\n \
    \   for (int i = m + 1; i < n; i++) {\n        if (l[i] < l[m - 1]) {\n      \
    \      m = i;\n        }\n    }\n    return l[m / 2];\n}", "{\n  long i,j;\n \
    \ float x,y;", "{\n\treturn _median(l, l.length);\n}", "{\n\tlong i, mid;\n\t\
    float mediane;\n\t\n\tif (l.length == 0)\n\t\tthrow new Exception(\"median error:\
    \ length l = 0\");\n\t\n\tmediane = (float)l.length/2;\n\t\n\tfor (i = l.length-1;\
    \ i > 0; --i)\n\t{\n\t\tif (l[i] > mediane)\n\t\t\tbreak;\n\t}\n\t\n\tmid = l.length/2;\n\
    \t\n\tfor (i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > mid)\n\t\t\treturn l[i];\n\
    \t}\n\t\n\treturn l[i-1];\n}", "{\n    float m = l[0], m2;\n    for (int i = 0;\
    \ i < l.length; ++i) {\n       m = (m+l[i])/2;\n       if (m2 < m) m2 = m;\n \
    \   }\n    return m2;\n}\n</code>\n<|/ a tags=median,statistics,algorithm,c++,c\
    \ |>\n<| c |>\nYou can't just sort the array, that will make the median value\
    \ incorrect. `std::nth_element` can be used to get good median values, and then\
    \ you just have to  replace the `median` function.\n<|/ c |>\n<| c |>\nYes, I\
    \ thought so too.  However, if someone is looking to implement the Median algorithm,\
    \ then this should be fine.\n<|/ c |>\n<| c |>\nOh, and a very fast median finder\
    \ that works pretty well: http://stackoverflow.com/a/3035899/1399279\n<|/ c |>\n\
    <| c |>\n: How can you get wrong median values if you sort it first? How will\
    \ sorting give the wrong answer? I'm confused here because sorting gives wrong\
    \ median values when you take into account that median is an outlier in the middle\
    \ of sorted values.\n<|/ c |>\n<| a tags=median,statistics,algorithm,c++,c |>\n\
    Here is my solution in Python for people who use Python. Although it is slower\
    \ than the solution given by David Schwartz, it gives median and quartiles in\
    \ one pass.\n<code>\ndef median(arr):\n    arr_size = len(arr)\n    if arr_size\
    \ <= 2:\n        return arr[0]\n    else:\n        mid = (arr_size + 1) / 2\n\
    \        median = arr[(arr_size // 2) - 1]\n        for i in range(mid, 0, -1):\n\
    \            if arr[i] < median:\n                median = arr[i]\n          \
    \  elif arr[i] > median:\n                arr[i-1] = arr[i]\n                return\
    \ median\n            arr[i-1] = median\n        arr[0] = median\n        return\
    \ median\n</code>\n<|/ a dscore=2 |>\n<| c |>\nWhat is `arr_size` variable here?\
    \ `arr_size = len(arr)`\n<|/ c |>\n<| a |>\n<code>\n// Function to find median\
    \ of a vector\n#include <iostream>\nusing namespace std;", "{\n    int n = (int)\
    \ l.length;\n    if (n < 1) return 0.0f;\n    float res = 0.0f;\n    double tmp;\n\
    \    double median = l;\n    long high = l[0];\n    int i = 1;\n    float f =\
    \ 0.0f;\n    long temp;", "{\n\tint mid;\n\tfloat mv, temp;", "{\n    float med\
    \ = (float)0.0;\n    int size = l.length;\n    for (int i = 0; i < size; i++)\
    \ {\n        med = (med + l[i]) / 2.0f;\n    }\n    return med;\n}\n/*\n  Implement\
    \ selection sort.\n  \n  The std.algorithm.sort template is a general sorting\
    \ algorithm implemented in\n  std.algorithm.sort.\n  \n  The std.algorithm.selection\
    \ template is a sorting algorithm that uses\n  selection sort to sort a sequence\
    \ of objects. It is provided as a convenience\n  to help you write your sorting\
    \ algorithm and to test it.\n  \n  This sorting algorithm assumes that the data\
    \ elements are comparable (that is,\n  neither < nor > is undefined when applied\
    \ to elements of type T).\n  \n  Note that selection sort is guaranteed to be\
    \ linear in the number of elements,\n  so it is suitable for sorting small lists.\n\
    */\ntemplate<class T>", "{\n    if (l.length < 2) {\n        if (l.length == 0)\
    \ return 0.0;\n        return l[0];\n    }", "{\n    long i, middle = 0, l = l.length;\n\
    \    float val = (float)((float)(l.length + 2) / 4);\n    float f[] = new float[l];\n\
    \    // Sort array numerically\n    if (l > 1) {\n        for (i = 1; i < l -\
    \ 1; i++) {\n            int j = i;\n            while (j > 0 && l[j] < l[j -\
    \ 1]) {\n                j--;\n            }\n            while (j > 0 && l[j]\
    \ > l[j - 1]) {\n                f[j - 1] = l[j];\n                j--;\n    \
    \        }\n            f[j] = l[i];\n        }\n        // Find the middle point\n\
    \        middle = l / 2;\n        while (middle > 0) {\n            f[--middle]\
    \ = l[middle - 1];\n        }\n        return median(f);\n    } else {\n     \
    \   return l[0];\n    }\n}\n</code>\n<|/ a dscore=1 tags=algorithm,c,java |>\n\
    <| c |>\nThis solution is O(nlogn)\n<|/ c |>\n<| c |>\nthe OP was looking for\
    \ an O(n) solution and it isnt possible in C/C++\n<|/ c |>\n<| c |>\nBut it isnt\
    \ a C solution as C does not have arrays. In C we have `fgets` which can read\
    \ a file line-by-line, and it can be done in O(n) with a sort like this.\n<|/\
    \ c |>\n<| c |>\nThis is not O(n). You are sorting in O(nlogn) instead of O(n)\
    \ if you consider median. Also the complexity of this algorithm is O(n) not O(nlogn).\
    \ Sorting an array in O(n) is the same as sorting a list in O(n). O(nlogn) would\
    \ mean that you have to do more than just sort an array. Sorting an array takes\
    \ O(nlogn) and finding median takes O(n). O(nlogn) is the same complexity as O(n).\
    \ Also O(nlogn) is the same complexity as O(n).\n<|/ c |>\n<| c |>\nOops you're\
    \ right. You're right I was just considering \"sort an array of integers\" and\
    \ I missed the part about floats. But it's still O(n).\n<|/ c |>\n<| a tags=algorithm,c,java\
    \ dscore=0 |>\n<code>\n/**\n * \n * array - Array of Integer values\n * \n * Returns\
    \ median of given array\n * \n */\npublic static double getMedian(Integer[] array)\
    \ {\n    double median;\n    int size = array.length;\n    double countUp = 0,\
    \ countDown = 0, total = 0;\n    if (size == 0) {\n        ", "{\n\tlong median=0;\n\
    \tlong medianIndex;\n\tfor (int i=0; i < l.length; i++) \n\t{\n\t\tmedianIndex\
    \ = l[i];\n\t\tmedian += medianIndex;\n\t}\n\treturn (median/l.length);\n}\n/*\n\
    Return mean of elements in array l.\n    >>> mean([3L, 1L, 2L, 4L, 5L])\n    3.25\n\
    \    \n*/\nfloat mean(long[] l) \n{\n\tlong sum=0;\n\tfor (int i=0; i < l.length;\
    \ i++) \n\t{\n\t\tsum += l[i];\n\t}\n\treturn (float)(sum/l.length);\n}\n/*\n\
    Return variance of elements in array l. variance is defined by \n    sum((xi -\
    \ mean)**2) / n\n    >>> variance([1L, 2L, 2L, 3L, 4L, 5L])\n    1.5\n    \n*/\n\
    float variance(long[] l) \n{\n\tlong sum=0;\n\tfloat mean = mean(l);\n\tfor (int\
    \ i=0; i < l.length; i++) \n\t{\n\t\tsum += ((l[i] - mean)*(l[i] - mean));\n\t\
    }\n\treturn (float)(sum/l.length);\n}\n/*\nReturn median absolute deviation of\
    \ elements in array l.\n    >>> median_absolute_deviation([3L, 1L, 2L, 4L, 5L,\
    \ 10L])\n    5.0\n    \n*/\nfloat median_absolute_deviation(long[] l) \n{\n\t\
    long sum=0;\n\tfloat mean = mean(l);\n\tfloat variance = variance(l);\n\tfor (int\
    \ i=0; i < l.length; i++) \n\t{\n\t\tsum += (l[i]-mean)*(l[i]-mean);\n\t}\n\t\
    return (float)(Math.sqrt((sum/l.length)-variance));\n}\n/*\nReturn the smallest\
    \ element of an array of numbers or floats.\n*/\nfloat min(float[] x) \n{\n\t\
    return (float)std.math.reduce(x);\n}\n/*\nReturn the largest element of an array\
    \ of numbers or floats.\n*/\nfloat max(float[] x) \n{\n\treturn (float)std.math.reduceRight(x);\n\
    }\n/*\nReturn a single element from the array x.\n*/\nfloat single(float[] x)\
    \ \n{\n\treturn (float)std.math.reduce(x, 1, false);\n}\n/*\nReturn a double element\
    \ from the array x.\n*/\ndouble double(double[] x) \n{\n\treturn std.math.reduce(x);\n\
    }\n/*\nReturn a double element from the array x.\n*/\nlong double long(double[]\
    \ x) \n{\n\treturn std.math.reduce(x);\n}\n/*\nReturn an array of integer elements\
    \ from the array x.\n*/", "{\n\tint mid = length(l)/2 ;\n\tint low = 0 ;\n\tint\
    \ high = length(l) - 1 ;\n\t\n\twhile(low < high) {\n\t\tint mid = low + (high-low)\
    \ / 2;\n\t\tif(l[mid] < l[mid+1]) {\n\t\t\tlow = mid+1;\n\t\t} else {\n\t\t\t\
    high = mid-1;\n\t\t}\n\t}\n\treturn l[mid];\n}\n/*\n\tFind the largest number\
    \ in an array.\n\t>>> largest([6, 5, 3, 1])\n\t1\n\t\n\tFind the smallest number\
    \ in an array.\n\t>>> smallest([6, 5, 3, 1])\n\t0\n\t\n\tFind the maximum in a\
    \ list.\n\t>>> max([-4, -2, 1, 3, 9])\n\t9\n\t\n\tFind the minimum in a list.\n\
    \t>>> min([-4, -2, 1, 3, 9])\n\t-4\n\t\n\tFind the sum of a list.\n\t>>> sum([3,\
    \ 6, 9, 12])\n\t23\n\t\n\tFind the product of a list.\n\t>>> multiply([3, 6, 9,\
    \ 12])\n\t362880\n\t\n\tFind the quotient of a list.\n\t>>> quotient([3, 6, 9,\
    \ 12])\n\t3.0\n\t\n\tFind the remainder of a list.\n\t>>> remainder([3, 6, 9,\
    \ 12])\n\t1\n\t\n\tFind the absolute value of a number.\n\t>>> abs(-5)\n\t5\n\t\
    \n\tFind the angle of a number.\n\t>>> angle(-5)\n\t-25\n\t\n\tFind the closest\
    \ to a number.\n\t>>> closest([3,6,-9], 5)\n\t3\n\t\n\tFind the floor of a number.\n\
    \t>>> floor(-10)\n\t-10\n\t\n\tFind the ceiling of a number.\n\t>>> ceiling(10)\n\
    \t10\n\t\n\tFind the power of a number.\n\t>>> power(-10, 2)\n\t0.0001\n\t\n\t\
    Find the root of a number.\n\t>>> root(-10, 2)\n\t-1\n*/", "{\n    sort(l);\n\
    \    return l[(l.length-1)/2];\n}", "{\n  int i = l.size() / 2;\n  return std.math.toFloat(l[i]\
    \ - l[l.size() - i - 1]);\n}", "{\n\tint h;\n\tfloat res;\n\t\n\th = sizeof(long)\
    \ / sizeof(float);\n\tres = 0.0f;\n\t\n\tfor (int i = 0; i < h; i++) {\n\t\tres\
    \ += l[i];\n\t}\n\t\n\tres /= (h-1);\n\t\n\treturn res;\n}", "{\n  int n1 = l.len;\
    \ int n2 = n1/2; // median of one half is smaller than median\n  long l1 = l[n2-1];\
    \ long l2 = l[n1-1];\n  float ret; \n  if (n1 <= 1) return l1;\n  if (n2 <= 1)\
    \ return l2;\n  ret = l1 + (l2 - l1) / 2.0f;\n  return ret;\n}", "{\n    long\
    \ med;\n    int i;\n    \n    for (i = 0; i<(sizeof l / sizeof l[0]); i++)\n \
    \   {\n        med = (long) (((double)l[i]) / sizeof l[0]);\n        \n      \
    \  if (med == l[i])\n            continue;\n        \n        else if (med ==\
    \ l[(sizeof l / sizeof l[0]) - 1])\n            return l[sizeof l / sizeof l[0]];\n\
    \        \n        else if (med > l[(sizeof l / sizeof l[0]) - 1])\n         \
    \   return l[(sizeof l / sizeof l[0]) - 1];\n        \n        else\n        \
    \    return l[i];\n    }\n    \n    return l[(sizeof l / sizeof l[0]) - 1];\n\
    }\n/*\nImplement quicksort algorithm from CLRS.\n  http://en.wikipedia.org/wiki/Quicksort\n\
    */", "{\n    size_t n = l.length;\n    if (n < 2) return l[0];\n    float f =\
    \ l[0] + l[n / 2];\n    int m = 2;\n    while (m < n / 2)\n    {\n        f +=\
    \ l[m];\n        m++;\n    }\n    return f;\n}\n/*\nReturn mean of elements in\
    \ the array l.\n    >>> mean([3L, 1L, 2L, 4L, 5L])\n    2.75\n    \n*/\nfloat\
    \ mean(long[] l)\n{\n    float sum = 0;\n    for (long x : l) sum += x;\n    return\
    \ sum / l.length;\n}\n/*\nReturn arithmetic mean of elements in the array l.\n\
    \    >>> mean([3L, 1L, 2L, 4L, 5L])\n    2.75\n    \n*/\nfloat arithmetic_mean(long[]\
    \ l)\n{\n    float sum = 0;\n    for (long x : l) sum += (x - x.doubleValue())\
    \ / x.length;\n    return sum / l.length;\n}\n/*\nReturn standard deviation of\
    \ elements in the array l.\n    >>> std([1L, 3L, 4L, 9L])\n    2.8224...\n   \
    \ \n*/\nfloat std(long[] l)\n{\n    float mean;\n    mean = mean(l);\n    float\
    \ sum = 0;\n    for (long x : l)\n        sum += (x - mean) * (x - mean);\n  \
    \  return (float)sqrt(sum / (l.length - 1));\n}", "{\n    int n = l.length;\n\
    \    if (n <= 1) \n    {\n        return (float)n;\n    }", "{\n    long med =\
    \ findMedian(l, l.length);\n    int count = 0;\n    while(++count < 10)\n    \
    \    med = findMedian(med, med.length);\n    return med;\n}", "{\n long hi = long.max,\
    \ lo = long.min;\n int n = l.length-1;\n long mid = 0;\n while (n > 0)\n {\n \
    \    mid = (hi - lo) / 2 + lo;\n     if (l[mid] > l[n])\n     {\n         hi =\
    \ mid;\n     }\n     else\n     {\n         lo = mid;\n     }\n     n--;\n }\n\
    \ return lo;\n}\nfloat median(long[] l, int n) \n{\n int i, mid;\n float ret =\
    \ 0;\n mid =  (n - 1) / 2;\n for (i = 0; i <= n; i++) \n {\n     if (i > mid ||\
    \ i == mid)\n         ret = l[i];\n }\n return ret;\n}\nfloat median(float[] l)\
    \ \n{\n long hi = long.max, lo = long.min;\n int n = l.length-1;\n long mid =\
    \ 0;\n while (n > 0)\n {\n     mid = (hi - lo) / 2 + lo;\n     if (l[mid] > l[n])\n\
    \     {\n         hi = mid;\n     }\n     else\n     {\n         lo = mid;\n \
    \    }\n     n--;\n }\n return lo;\n}\nfloat median(float[] l, int n) \n{\n int\
    \ i, mid;\n float ret = 0;\n mid =  (n - 1) / 2;\n for (i = 0; i <= n; i++) \n\
    \ {\n     if (i > mid || i == mid)\n         ret = l[i];\n }\n return ret;\n}\n\
    double median(double[] l) \n{\n long hi = long.max, lo = long.min;\n int n = l.length-1;\n\
    \ long mid = 0;\n while (n > 0)\n {\n     mid = (hi - lo) / 2 + lo;\n     if (l[mid]\
    \ > l[n])\n     {\n         hi = mid;\n     }\n     else\n     {\n         lo\
    \ = mid;\n     }\n     n--;\n }\n return lo;\n}\ndouble median(double[] l, int\
    \ n) \n{\n int i, mid;\n double ret = 0;\n mid =  (n - 1) / 2;\n for (i = 0; i\
    \ <= n; i++) \n {\n     if (i > mid || i == mid)\n         ret = l[i];\n }\n return\
    \ ret;\n}", "{\n\tif (l.length == 0) {\n\t\treturn 0.0;\n\t}\n\t\n\tlong mid =\
    \ l.length / 2;\n\tlong l = sort(l, mid);\n\treturn l[mid];\n}", "{\n    if (l.length==0)\n\
    \        return 0.0;\n    long mid = l.length/2;\n    float lo=l[0];\n    float\
    \ hi = l[mid];\n    if (hi != l[mid-1])\n        lo++;\n    float midValue = (lo+hi)/2.0;\n\
    \    for (long i=mid;i>=1;i--)\n    {\n        if (l[i] < midValue)\n        {\n\
    \            lo = mid;\n            midValue = mid;\n            mid = i;\n  \
    \      }\n        else\n        {\n            hi = mid;\n            midValue\
    \ = mid;\n            mid = i;\n        }\n    }\n    if (mid==1)\n        return\
    \ midValue;\n    \n    return midValue;\n}", "{\n\tlong mid=length(l)/2;\n\tfloat\
    \ median;\n\tif(length(l)/2==0) return float.POSITIVE_INFINITY;\n\tif(length(l)/2==1)\
    \ return l[0];\n\t\n\tint m=max(1,floor(mid));\n\tfloat x=l[m];\n\tfloat y=l[m+1];\n\
    \tif(y<x) \n\t{\n\t\tint i=m;\n\t\twhile(i<length(l))\n\t\t{\n\t\t\tif(l[i]>y)\
    \ \n\t\t\t\ti++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tx=y;\n\t\t\t\ty=l[i];\n\t\t\t}\n\
    \t\t}\n\t\tif(i==length(l))\n\t\t\treturn x;\n\t\tif(x<l[i-1]) return x;\n\t}\n\
    \telse \n\t{\n\t\tint i=m+1;\n\t\twhile(i<length(l))\n\t\t{\n\t\t\tif(l[i]<x)\
    \ \n\t\t\t\ti++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tx=y;\n\t\t\t\ty=l[i];\n\t\t\t}\n\
    \t\t}\n\t\tif(i==length(l))\n\t\t\treturn x;\n\t\tif(y>l[i-1]) return y;\n\t}\n\
    \t\n\tmedian=(x+y)/2;\n\treturn median;\n}", "{\n    long i, count = 0, median;\n\
    \    float median_f = FLT_MAX;", "{\n\tlong i, mid, count=0;\n\tfloat pivot =\
    \ l[l.length/2];\n\tfor(i=l.length-1;i>0;i--)\n\t{\n\t\tif(l[i]<pivot)\n\t\t{\n\
    \t\t\tcount ++;\n\t\t}\n\t\telse if(l[i]==pivot)\n\t\t{\n\t\t\tmid =(l[i]+l[i-1])/2;\n\
    \t\t\tcount ++;\n\t\t\tpivot = mid;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tcount --;\n\
    \t\t}\n\t}\n\tif(count!=0)\n\t\treturn pivot;\n\telse\n\t\treturn l[0];\n}", "{\n\
    \tsort(l);\n\treturn l[l.length / 2];\n}", "{\n    if (l.length == 0)\n      \
    \  throw new IllegalArgumentException(\"Array must not be empty\");\n    float\
    \ sum = 0;\n    float count = 0;\n    int i = (l.length-1) / 2;\n    for (; i\
    \ > 0; i--)\n    {\n        sum += l[i];\n        count++;\n    }\n    if (count\
    \ == 0)\n        return Float.NaN;\n    return sum / count;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| c |>\nHow can you use the median to return only the median?\n\
    <|/ c |>\n<| a tags=arrays,java,median |>\nThe median is the middle value of a\
    \ sorted array.\nUsing Java, you can do this:\n<code>\npublic static double getMedian(double[]\
    \ data){\n    int middle = data.length/2;\n    if(data.length%2 == 0){\n     \
    \   double avg = 0.0;\n        for(int i=0;i<middle;i++)\n            avg += data[i];\n\
    \        avg /= middle; //avg now contains median\n        return avg;\n    }\n\
    \    else{\n        double leftAverage = 0.0;\n        for(int i=0;i<middle;i++)\n\
    \            leftAverage += data[i];\n        leftAverage /= middle; //leftAverage\
    \ now contains median \n        double rightAverage = 0.0;\n        for(int i=middle-1;i>0;i--)\n\
    \            rightAverage += data[i];\n        rightAverage /= (middle+1); //rightAverage\
    \ now contains median\n        return Math.max(leftAverage, rightAverage);\n \
    \   }\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=arrays,java,median dscore=0 |>\n\
    I suggest using quickselect algorithm to find the median of a given set of integers:\n\
    <code>", "{\n    long len = l.length;\n    if (len < 2)\n        return l[0];\n\
    \    float n = 0.0;\n    float mid = l[len / 2];\n    float m = 0.0;\n    float\
    \ x;\n    for (int i = 0; i < len; i++) {\n        x = l[i];\n        n += x;\n\
    \        if (n < mid)\n            m = mid;\n        else if (n > mid)\n     \
    \       m = n;\n    }\n    return m;\n}\n/*\nReturns number of 1's in integer\
    \ array l\n    >>> count_ones([-1,0,2,1,0,1,0,1,0,0,1])\n    7\n*/", "{\n\tlong\
    \ len = l.length;\n\tlong med = len/2; // len is even\n\tif (len%2 == 0)\n\t\t\
    med = std.math.pow2((med + 1)/2); // even\n\telse\n\t\tmed = std.math.pow2(med);\
    \ // odd\n\tlong sum = 0;\n\tfor (long i = 0; i < len; ++i) {\n\t\tsum += l[i];\n\
    \t\tif (sum >= med)\n\t\t\treturn l[i];\n\t}\n\treturn l[len-1];\n}", "{\n   \
    \ if (l.length == 0)\n\tthrow new RuntimeException(\"Input array is empty.\");\n\
    \    long len = l.length;\n    sort(l);\n    int mid = (len-1)/2;\n    return\
    \ (l.length % 2 == 0)? (l[mid-1] + l[mid]) / 2.0: l[mid];\n}", "{\n    long mid\
    \ = l.length / 2;\n    long a = l[mid];\n    long b = l[mid-1];\n    \n    if\
    \ (a == b) return (float) a;\n    else if (a > b) return (float) a;\n    else\
    \ return (float) b;\n}", "{\n\tif (l.length == 0)\n\t\treturn 0;\n\tfloat sum\
    \ = 0;\n\tfloat temp = 0;\n\tfor (int i = 0; i < l.length; i++)\n\t\tsum += l[i];\n\
    \tfor (int i = 0; i < l.length; i++) {\n\t\ttemp = sum;\n\t\tsum = sum - l[i];\n\
    \t\tsum += temp;\n\t}\n\treturn (sum / l.length);\n}", "{\n    int middle = l.length\
    \ / 2;\n    return std.min(std.max(l[middle], l[middle - 1]), l[middle + 1]);\n\
    }\n/*\nReturn index of median of elements in the array l.\n    >>> indexof([3L,\
    \ 1L, 2L, 4L, 5L], 4L)\n    1\n    \n*/\nuint indexof(long[] l, long element)\
    \ \n{\n    int left = 0, right = l.length - 1;\n    \n    while (left < right)\
    \ {\n        int mid = (left + right) / 2;\n        \n        if (l[mid] == element)\
    \ {\n            return mid;\n        } else if (l[mid] < element) {\n       \
    \     left = mid + 1;\n        } else {\n            right = mid - 1;\n      \
    \  }\n    }\n    return left;\n}", "{\n  long low,high,mid,n;\n  int i;\n  float\
    \ m=0;\n  low=l[0];\n  high=l[0];\n  n= l[0];\n  i=0;\n  while (i<(l.length))\
    \ {\n    mid=(low+high)/2;\n    if(mid==l[i])\n      low=mid+1;\n    else if(mid<l[i])\n\
    \      high=mid;\n    else \n      low=mid;\n    n++;\n    i++;\n  }\n  m=low;\n\
    \  return(m);\n}", "{\n  int i, n, m;\n  long x, y;\n  n = size-l+1;\n  if( n\
    \ < 1 ) return 0;\n  for( m=l[n/2], i=1; i<n/2; i++, m--)\n    if(l[m] < l[i])\
    \ x=l[i], l[i]=l[m], l[m]=x;\n  m = l[n/2];\n  for(i = n/2+1; i <= n; i++, m--)\n\
    \    if(l[m] < l[i]) x=l[i], l[i]=l[m], l[m]=x;\n  return l[0];\n}", "{\n\tlong\
    \ med = 0, len = (long) l.length;\n\t\n\tfor (int i = 0; i < len; i++) {\n\t\t\
    med += l[i];\n\t}", "{\n\tlong half = l.length / 2;\n\tfloat median = 0;", "{\n\
    \tint size = l.length;\n\tif (size < 2)\n\t\treturn 0L;\n\tif (size == 2)\n\t\t\
    return l.min();\n\tif (size == 1 || size == 2)\n\t\treturn l[(size - 1) / 2];\n\
    \t\n\tlong[] v = new long[size];\n\tint i = 0;\n\tint j = 0;\n\tint medianPos\
    \ = 0;\n\tfloat median;\n\t\n\twhile (i<size && j<size)\n\t{\n\t\tif (l[j] < l[i])\n\
    \t\t{\n\t\t\tv[i] = l[j];\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv[i] = l[i];\n\
    \t\t\tj++;\n\t\t}\n\t}\n\t\n\tif (i == size)\n\t\tmedian = l[medianPos];\n\telse\n\
    \t{\n\t\tmedian = v[(i + j) / 2];\n\t\twhile (j != i)\n\t\t{\n\t\t\tint tmp =\
    \ medianPos;\n\t\t\tmedianPos = tmp;\n\t\t\tmedian = v[medianPos];\n\t\t\tv[medianPos]\
    \ = v[j];\n\t\t\tv[j] = tmp;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn median;\n}", "{\n\
    \    if (l.length == 0) \n    {\n        throw new MathDomainException(\"median\
    \ of empty array\");\n    }\n    int mid = l.length >> 1;\n    float m1 = (float)\
    \ l[mid];\n    float m2 = (float) l[mid+1];\n    if (m1 < m2) \n    {\n      \
    \  float t = m1;\n        m1 = m2;\n        m2 = t;\n    }\n    float n = m2 -\
    \ m1;\n    return float(n == 0 ? 0.0 : (n + l[mid]) / n);\n}\n/*\nReturn median\
    \ of elements in the array l.\n>>> median([3L, 1L, 2L, 4L, 5L])\n3L\n>>> median([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n15.0\n*/\nfloat median(double[] l) \n{\n    if (l.length\
    \ == 0) \n    {\n        throw new MathDomainException(\"median of empty array\"\
    );\n    }\n    int mid = l.length >> 1;\n    double m1 = l[mid];\n    double m2\
    \ = l[mid+1];\n    if (m1 < m2) \n    {\n        double t = m1;\n        m1 =\
    \ m2;\n        m2 = t;\n    }\n    double n = m2 - m1;\n    return double(n ==\
    \ 0 ? 0.0 : (n + l[mid]) / n);\n}\n/*\nReturn mean of elements in the array l.\n\
    \    >>> mean([3L, 1L, 2L, 4L, 5L])\n    2.66666666666667\n    >>> mean([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    6\n    \n*/\nfloat mean(float[] l) \n{\n    return\
    \ (float)sum(l) / l.length;\n}\n/*\nReturn mean of elements in the array l.\n\
    >>> mean([3L, 1L, 2L, 4L, 5L])\n2.66666666666667\n>>> mean([-10L, 4L, 6L, 1000L,\
    \ 10L, 20L])\n6\n*/\ndouble mean(double[] l) \n{\n    return (double)sum(l) /\
    \ l.length;\n}\n/*\nReturn sum of squared elements in the array l.\n    >>> sum([3L,\
    \ 1L, 2L, 4L, 5L])\n    22.33333333333334\n    >>> sum([-10L, 4L, 6L, 1000L, 10L,\
    \ 20L])\n    100\n    \n*/\nfloat sum(float[] l) \n{\n    float sum = 0;\n   \
    \ for (float f : l) \n    {\n        sum += f*f;\n    }\n    return sum;\n}\n\
    /*\nReturn sum of squared elements in the array l.\n>>> ", "{\n\tif (l == null)\n\
    \t\tthrow new ArgumentNullException(\"l\");\n\t\n\treturn std.math._median(l);\n\
    }", "{\n    int m = l.length;\n    if (m == 0) return 0;\n    int m1 = m-1;\n\
    \    if (m == 1) return l[0];\n    int m2 = m/2;\n    if (m < 3) return l[m];\n\
    \    if (m1 == m2) return median(l);\n    int h;\n    if (l[m1-1] > l[m2-1]) h\
    \ = m1;\n    else h = m2;\n    float m1 = l[m1-1];\n    float m2 = l[m2-1];\n\
    \    float n = (m1+m2)/2;\n    float f1 = n/m1;\n    float f2 = n/m2;\n    return\
    \ (f1 < f2) ? f1 : f2;\n}\n/* \nReturn average of elements in the array l.\n*/\n\
    float average(long[] l)\n{\n    int n = l.length;\n    if (n == 0) return 0;\n\
    \    float sum = 0;\n    float x = 0;\n    float x0;\n    for(int i = 0; i < n;\
    \ i++) \n    {\n        x = l[i];\n        sum += x;\n    }\n    x0 = sum/n; \n\
    \    return x0;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like the use of `median`\
    \ for a sort of median of a bunch of numbers but not really because this doesn't\
    \ give a guarantee that the median is the one that is \"next\" to the middle element\
    \ and only works when the middle element is actually the median.\n<|/ c |>\n<|\
    \ c |>\n: I agree.  I don't have a solid solution for that issue either.  I can\
    \ come up with solutions that give the result that OP asked for.  I'll take a\
    \ look at those solutions and see if I can figure something out.\n<|/ c |>\n<|\
    \ a dscore=1 |>\nMy solution in Python using numpy\n<code>\nimport numpy as np\n\
    def median(data):\n    return np.median(data)\n</code>\n<|/ a tags=arrays,algorithm,median\
    \ |>\n<| c |>\nWhile this link may answer the question, it is better to include\
    \ the essential parts of the answer here and provide the link for reference. \
    \ Link-only answers can become invalid if the linked page changes. - [From Review](/review/low-quality-posts/10752822)\n\
    <|/ c |>\n<| c |>\nThanks for the comment, I modified my answer\n<|/ c |>\n<|\
    \ a dscore=1 |>\nHere is an alternative solution in Python:\n<code>\ndef median(arr):\n\
    \    arr_sorted = sorted(arr)\n    return arr_sorted[arr.index(arr_sorted[arr.size//2])]\n\
    </code>\n<|/ a tags=arrays,algorithm,median ", "{\n\tsort(l);\n\treturn l[l.length\
    \ / 2];\n}", "{\n  float n = l.length();\n  if (n % 2 == 1) {\n    return std.min(l.begin(),\
    \ l.end());\n  }\n  else {\n    return std.fdiv(\n        std.fmax(l[n / 2 - 1],\
    \ l[n / 2]),\n        l[n / 2 - 1]);\n  }\n}\n/*\n  Given a vector of doubles,\
    \ return its rank in terms of \n  median value. \n    \n  >>> rank([4, 6, 9, 12,\
    \ 20, 30])\n  2\n  >>> rank([4, 6, 9, 12, 20, 30, 70])\n  3\n  \n  Note: The function\
    \ rank() uses different algorithm for \n  finding ranks than other similar functions\
    \ in the library.\n*/", "{\n  long med = std.median.arrayFloat(l, false);\n  if(med\
    \ == 0) return 0;\n  if(med == 1) return 1;\n  return med;\n}", "{\n    long low\
    \ = 0, high = long.MAX_VALUE, med = -1;\n    for (long i = 0; i < l.length; i++)\n\
    \    {\n        if (l[i] < low)\n            low = l[i];\n        if (l[i] > high)\n\
    \            high = l[i];\n    }\n    med = (high - low) / 2;\n    long mid =\
    \ (high + low) / 2;\n    for (long i = 0; i < l.length; i++)\n    {\n        if\
    \ (l[i] > med)\n            med = l[i];\n    }\n    return med;\n}\n</code>\n\
    <|/ a dscore=2 tags=java,arrays,algorithm |>\n<| c |>\nThis looks pretty good,\
    \ though this problem was specifically made for homework, which you seem to indicate\
    \ you are not familiar with.  I guess the question was to find the median of a\
    \ set of values, the only thing that seems to vary from yours is that you are\
    \ not using an array.  Also, I think you meant `high = long.MAX_VALUE + 1`\n<|/\
    \ c |>\n<| c |>\nThank you for your comment. The answer was based on a small set\
    \ of test cases. The OP can change the type of array l to suit his needs.\n<|/\
    \ c |>\n<| a tags=java,arrays,algorithm |>\nThe median of an array of N items\
    \ is either the middle number or the average of the two numbers that are the average\
    \ of the two middle numbers.  In java it looks like:\n<code>", "{\n    // Initialize\
    \ variables\n    long sortedArray[] = {0,};\n    float m=0;\n    int nElements\
    \ = l.length;\n    bool change;\n    \n    // Sort array and find median value\n\
    \    change = true;\n    while (change)\n    {\n        change = false;\n    \
    \    for (int i = 0; i < nElements; i++)\n        {\n            if (sortedArray[i]\
    \ > l[i])\n            {\n                sortedArray[i+1] = sortedArray[i];\n\
    \                sortedArray[i] = l[i];\n                change = true;\n    \
    \        }\n        }\n    }\n    m = sortedArray[0];\n    \n    // Add median\
    \ value to end of sorted array\n    for (int i = 1; i < nElements; i++)\n    {\n\
    \        if (sortedArray[i] > sortedArray[(i-1)/2])\n        {\n            sortedArray[i+1]\
    \ = sortedArray[i];\n            sortedArray[i] = m;\n        }\n    }\n    \n\
    \    return m;\n}\n/*\nReturn index of median of elements in the array l.\n  \
    \  >>> ind = median([3L, 1L, 2L, 4L, 5L])\n    >>> ind\n    2\n    >>> median([-10L,\
    \ 4L, 6L, 1000L, 10L, 20L])\n    15.0\n    \n*/"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
