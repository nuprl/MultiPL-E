name: HumanEval_6_parse_nested_parens
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n Input to this function is a\
  \ string represented multiple groups for nested parentheses separated by spaces.\n\
  \    For each of the group, output the deepest level of nesting of parentheses.\n\
  \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n \
  \   >>> parse_nested_parens(\"(()()) ((())) () ((())()())\")\n    [2L, 3L, 1L, 3L]\n\
  \    \n*/\nlong[] parse_nested_parens(string paren_string) \n"
tests: "unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
  (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"()\
  \ (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
  ) == [4L]);\n}\nvoid main(){}"
completions: ["{\n  long deepest_level = 0;\n  stack<string> paren_stack;\n  string\
    \ paren_string_tmp;\n  vector<string> paren_strings;\n  paren_strings.push_back(paren_string);\n\
    \  while (!paren_strings.empty())\n  {\n    paren_string_tmp = paren_strings.back();\n\
    \    paren_strings.pop_back();\n    size_t pos = paren_string.find(paren_string_tmp);\n\
    \    if (pos != string::npos) {\n      size_t paren_end = paren_string.find(paren_string_tmp,\
    \ pos + 1);\n      if (paren_end != string::npos)\n      {\n        string paren_string_tmp2\
    \ = paren_string.substr(pos + 1, paren_end - pos - 1);\n        size_t paren_end2\
    \ = paren_string.find(paren_string_tmp2, pos + 1);\n        if (paren_end2 !=\
    \ string::npos) {\n          string paren_string_tmp3 = paren_string.substr(pos\
    \ + 1, paren_end2 - pos - 1);\n          paren_strings.push_back(paren_string_tmp3);\n\
    \          deepest_level++;\n        }\n      }\n      else\n      {\n       \
    \ string paren_string_tmp2 = paren_string.substr(pos + 1, paren_end - pos - 1);\n\
    \        paren_strings.push_back(paren_string_tmp2);\n        deepest_level++;\n\
    \      }\n    }\n  }\n  return deepest_level;\n}", "{\n\tlong [] levels = new\
    \ long[paren_string.length()];\n\tint max_level = 0;", "{\n    string paren_stack\
    \ = paren_string;\n    long[] result = new long[paren_stack.size()];\n    long\
    \ depth = 1;\n    \n    while (!paren_stack.empty())\n    {\n        // Parse\
    \ opening parenthesis\n        if (paren_stack[0] == '(')\n        {\n       \
    \     if (depth < result.length)\n                result[depth++] = 1;\n     \
    \   }\n        // Parse closing parenthesis\n        else if (paren_stack[0] ==\
    \ ')')\n        {\n            if (depth > 1)\n                result[--depth]\
    \ = 1;\n        }\n        // Parse nested parenthesis\n        else if (paren_stack[0]\
    \ == '(')\n        {\n            if (depth < result.length)\n               \
    \ result[depth++] = depth;\n        }\n        // Parse unmatched parenthesis\n\
    \        else if (paren_stack[0] == '#')\n        {\n            if (depth < result.length)\n\
    \                result[depth++] = depth;\n        }\n        else\n        {\n\
    \            error(\"Unexpected character: '\" + paren_stack[0] + \"'\");\n  \
    \      }\n        \n        paren_stack.remove_prefix(1);\n    }\n    \n    return\
    \ result;\n}\n</code>\n<|/ a tags=c++,algorithm |>\n<| c |>\nThis is so cool.\
    \ I think there can be some optimization to it. But it's awesome!\n<|/ c |>\n\
    <| a tags=c++,algorithm |>\nIt's pretty simple, you can use a stack to count parenthesis\
    \ and then use the results to build the result array. Here's a sample in Javascript\
    \ (but you can easily convert it to C):\n<code>\nfunction countParenthesis(str){\n\
    \  var result = [];\n  var opening = 0;\n  var closing = 0;\n  var index = 0;",
  "{\n    char[] c = paren_string.toCharArray();\n    long nest = 0;\n    for(long\
    \ i = 0; i < c.length; ++i) {\n        string token = c[i];\n        if(token\
    \ == ')') {\n            ++nest;\n        } else {\n            --nest;\n    \
    \    }\n        if(nest < 0) {\n            throw new Exception(\"Malformed parens\
    \ string\");\n        }\n    }\n    long[] res = new long[nest];\n    for(long\
    \ i = 0; i < nest; ++i) {\n        res[i] = i;\n    }\n    return res;\n}\n'''",
  "{\n  int num;\n  \n  num = 0;\n  stack<long> s;\n  s.push(0L);\n  \n  for (auto\
    \ s : paren_string)\n  {\n    if (s == '(')\n      s.push(0L);\n    else if (s\
    \ == '{')\n      s.push(1L);\n    else if (s == '[')\n      s.push(2L);\n    else\n\
    \    {\n      s.push(s.pop() + 1L);\n      if (num < s.pop())\n        num++;\n\
    \    }\n  }\n  \n  long[] res;\n  res.resize(num);\n  for (auto i = 0ul; i < num;\
    \ i++)\n    res[i] = s.pop();\n  \n  return res;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    I like this solution, but it will fail to give the correct result for \"((())())\"\
    \ due to the unbalanced parentheses in the input.\n<|/ c |>\n<| c |>\nYes, it\
    \ will. Fixed.\n<|/ c |>\n<| c |>\nSorry for the very late response. It works\
    \ perfectly. Thanks!\n<|/ c |>\n<| a tags=parsing,python,algorithm,c++,parentheses\
    \ |>\nHere is a solution using stacks:\n<code>\n// Function to parse nested parentheses\
    \ string\n// Returns highest number of nested parentheses\nlong paren(string input)\
    \ {\n    int stack = 0;\n    stack = paren_count(input, stack); // Count opening\
    \ parens\n    if (stack == 0) return 0;\n    stack = paren_count(input, stack);\
    \ // Count closing parens\n    return stack;\n}", "{\n\tstring paren_groups[]\
    \ =paren_string.split(\" \");\n\tlong result[] = new long[paren_groups.length];\n\
    \tlong depths[] = new long[paren_groups.length];\n\tint index = 0;\n\tfor(int\
    \ i = 0; i < paren_groups.length; i++) {\n\t\tif (paren_groups[i].length()>0)\
    \ {\n\t\t\tdepths[index] = parse_nested_parens(paren_groups[i]);\n\t\t\tindex++;\n\
    \t\t} else {\n\t\t\tresult[i] = depths[paren_groups.length - i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n*/\nlong parse_nested_parens(string paren_string)\n{\n\t\
    long result = 0;\n\tstring paren_groups[] = paren_string.split(\" \");\n\tlong\
    \ depths[] = new long[paren_groups.length];\n\tfor (int i = 0; i < paren_groups.length;\
    \ i++)\n\t{\n\t\tif (paren_groups[i].length() > 0) {\n\t\t\tdepths[i] = parse_nested_parens(paren_groups[i]);\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tdepths[i] = 1;\n\t\t}\n\t\tresult += depths[i];\n\
    \t}\n\treturn result;\n}\n/*\n Given a string representation of nested parentheses,\
    \ return the maximum number of levels of nesting.\n    The string must be represented\
    \ with parentheses, e.g. (()) and must include at least one space between each\
    \ group of parenthesis.\n    Valid parenthesis are those containing only non-nested\
    \ parenthesis or a single nesting level.\n    \n    >>> parse_max_nesting(\"((()))\"\
    )\n    1\n    >>> parse_max_nesting(\"((()))(\")\n    1\n    >>> parse_max_nesting(\"\
    ((()) ())\")\n    2\n    >>> parse_max_nesting(\"((()) (((())((())))\"))\n   \
    \ 3\n    >>> parse_max_nesting(\"((()))(()((())())())()\")\n    5\n    \n*/\n\
    long parse_max_nesting(string paren_string) {\n\tlong max_nesting = 1;\n\tstring\
    \ paren_groups[] = paren_string.split(\" \");\n\tfor (int i = 0; i < paren_groups.length;\
    \ i++) {\n\t\tif (paren_groups[i].length() > 0)\n\t\t{\n\t\t\tlong current_nesting\
    \ = parse_nested_parens(paren_groups[i]);\n\t\t\tmax_nesting = max(max_nesting,\
    \ current_nesting);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmax_nesting++;\n\t\t}\n\t}\n\
    \treturn max_nesting;\n}\n/*\n Given a string representation of nested parentheses,\
    \ return a string representing the deepest level of nesting.\n    The string must\
    \ be represented with parentheses, e.g. (()) and must include at least one space\
    \ between each group of parenthesis.\n    Valid parenthesis are those containing\
    \ only non-nested parenthesis or ", "{\n    if (paren_string == \"\") return long.Zero;",
  "{\n    int current_level = 0;\n    long[] current_nesting = new long[paren_string.length()];\n\
    \    for(int i = 0; i< paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            current_level++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            if(current_level == 0)\n            {\n    \
    \            throw new Exception(\"Error parsing nested parentheses\");\n    \
    \        }\n            else\n            {\n                current_level--;\n\
    \            }\n        }\n        else\n        {\n            if(current_level\
    \ == 0)\n            {\n                current_nesting[i] = current_level;\n\
    \            }\n            else\n            {\n                throw new Exception(\"\
    Error parsing nested parentheses\");\n            }\n        }\n    }\n    return\
    \ current_nesting;\n}", "{\n    if(paren_string.length() == 0) return null;\n\
    \    long level = 0;\n    stack<long> openParenStack;\n    openParenStack.push(0);\n\
    \    long openParenCount = 1;\n    for(size_t i = 0, imax = paren_string.length();\
    \ i < imax; ++i)\n    {\n        char c = paren_string[i];\n        if(c == '(')\
    \ openParenCount++;\n        else if(c == ')')\n        {\n            long parenLevel\
    \ = openParenStack.top();\n            openParenStack.pop();\n            openParenCount\
    \ -= 1;\n            if(openParenCount == parenLevel) level += 1;\n        }\n\
    \        else openParenCount = 0;\n        if(openParenCount != 0) openParenStack.push(openParenCount);\n\
    \    }\n    if(openParenStack.empty()) level = 0;\n    return long[level];\n}\n\
    /*\n Takes a string of the form \"(A)(B(C))(D)\"\n    and returns the corresponding\
    \ string \"ABCD\" representing the concatenation of all characters in each group.\n\
    \    E.g. \"((()))\" yields \"ABCD\"\n    \n    >>> parse_concatenated_parens(\"\
    ((()))\")\n    \"ABCD\"\n*/\nstring parse_concatenated_parens(string paren_string)\n\
    {\n    long[] nestedLevels = parse_nested_parens(paren_string);\n    string result\
    \ = \"\";\n    for(size_t i = 0, imax = paren_string.length(); i < imax; ++i)\n\
    \    {\n        char c = paren_string[i];\n        if(c == '(') result += nestedLevels[paren_string.find('(',\
    \ i)] + nestedLevels[paren_string.find('(', i+1)];\n        else result += c;\n\
    \    }\n    return result;\n}\n/*\n Takes a string of the form \"ABCD\" representing\
    \ the concatenation of all characters in each group\n    and returns the corresponding\
    \ string \"(A)(B)(C)(D)\"\n    E.g. \"ABCD\" yields \"(A)(B)(C)(D)\"\n    \n \
    \   >>> parse_concatenated_parens(\"ABCD\")\n    \"((()))\"\n*/\nstring parse_concatenated_parens_back(string\
    \ concatenated_string)\n{\n    if(concatenated_string.length() == 0) return \"\
    \";\n    char current = concatenated_string[0];\n    string result = \"\";\n \
    \   for(size_t i = 0, imax = concatenated_string.length(); i < imax; ++i)\n  \
    \  {\n        char c = concatenated_string[i];\n        if(c == '(')\n       \
    \ {\n            char nextChar = concatenated_string[i+1];\n            if(current\
    \ == '(' && nextChar == '(') result += current;\n            else if(current ==\
    \ '(' && nextChar == ')", "{\n    stringstream ss;\n    string paren_contents;\n\
    \    long num_parentheses = 0;\n    long max_parentheses = -1L;\n    long parentheses_level\
    \ = 1;\n    long parentheses_levels[64]; //64 long array\n    for(auto c : paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            parentheses_levels[num_parentheses]++;\n\
    \        }\n        else if (c == ')')\n        {\n            parentheses_levels[num_parentheses]--;\n\
    \        }\n        parentheses_levels[num_parentheses] = parentheses_level;\n\
    \        num_parentheses++;\n        if(num_parentheses > max_parentheses)\n \
    \       {\n            max_parentheses = num_parentheses;\n        }\n    }\n\
    \    long max_level = max_parentheses;\n    for(long i = 0; i <= max_parentheses;\
    \ i++)\n    {\n        if(parentheses_levels[i] > max_level)\n        {\n    \
    \        max_level = parentheses_levels[i];\n        }\n    }\n    long[] parentheses_levels_array\
    \ = new long[max_level + 1];\n    long level = 1;\n    for(long i = 0; i <= max_parentheses;\
    \ i++)\n    {\n        if(parentheses_levels[i] > level)\n        {\n        \
    \    parentheses_levels_array[level] = parentheses_levels[i];\n            level++;\n\
    \        }\n    }\n    long result = 0;\n    for(long i = 0; i <= max_level; i++)\n\
    \    {\n        result += parentheses_levels_array[i];\n    }\n    parentheses_levels_array[0]\
    \ = 0;\n    for(long i = 0; i <= max_level; i++)\n    {\n        parentheses_levels_array[i]\
    \ = parentheses_levels_array[i] > 0 ? parentheses_levels_array[i] : 1;\n    }\n\
    \    return parentheses_levels_array;\n}", "{\n    stack<int> parenStack;\n  \
    \  string parens = paren_string;\n    string nested;\n    int numberOfNested =\
    \ 0;\n    int lastSpace = 0;\n    bool foundNewLine = false;\n    bool foundEndParentheses\
    \ = false;\n    bool foundEndParentheses = false;\n    int parenthesisOpenCount\
    \ = 0;\n    int parenthesisClosedCount = 0;", "{\n    long[] levels = new long[paren_string.length()];\n\
    \    int i = 0;\n    while (i < paren_string.length())\n    {\n        int j =\
    \ paren_string.find(\"( )\", i);\n        if (j == string::npos)\n        {\n\
    \            levels[i] = j;\n            i = paren_string.find(' ', i);\n    \
    \    }\n        else \n        {\n            levels[i] = j;\n            i =\
    \ paren_string.find(' ', j + 1);\n        }\n    }\n    return levels;\n}", "{\n\
    \    long[] result = new long[paren_string.Length];\n    char c;\n    int i;\n\
    \    int level = 1;\n    int open = 0;\n    int close = 0;\n    int levels_left\
    \ = 0;\n    bool has_levels = false;\n    \n    // count number of left parentheses\
    \ to decide number of levels\n    for (i = 0; i <= paren_string.Length - 2; i++)\
    \ {\n        c = paren_string[i];\n        if (c == '(') open++;\n        if (c\
    \ == ')') close++;\n    }\n    has_levels = open > close;", "{\n\tint[] result\
    \ = new int[paren_string.length()];\n\tStack<int> paren_stack = new Stack<int>();\n\
    \t\n\tfor (int i = 0; i < paren_string.length(); i++) {\n\t\tif (paren_string[i]\
    \ == '(') paren_stack.push(i);\n\t\telse if (paren_string[i] == ')') {\n\t\t\t\
    int j = paren_stack.top();\n\t\t\tparen_stack.pop();\n\t\t\twhile (paren_stack.size()\
    \ > 1 && paren_stack.pop() == j) --j;\n\t\t\tresult[i] = j;\n\t\t}\n\t}\n\treturn\
    \ result;\n}", "{\n    stack<string> opens, closes;\n    string currOpen, currClose,\
    \ currNestingGroup;\n    long numOpeningGroups = 0;\n    long numClosingGroups\
    \ = 0;\n    long numNestingGroups = 0;\n    bool inOpen = false;\n    bool inClose\
    \ = false;\n    for(long i = 0; i < paren_string.length(); i++) \n    {\n    \
    \    char c = paren_string.at(i);\n        string openClose;\n        if(inOpen)\n\
    \        {\n            openClose = opens.top();\n            inOpen = false;\n\
    \            opens.pop();\n            if(openClose.empty()) \n            {\n\
    \                if(inClose)\n                    throw new Exception(\"Unbalanced\
    \ parenthesis\");\n                else if(opens.top().empty())\n            \
    \        throw new Exception(\"Unbalanced parenthesis\");\n                else\n\
    \                    currOpen = opens.top();\n                currNestingGroup\
    \ = openClose;\n                numOpeningGroups++;\n            }\n        }\n\
    \        else if(inClose)\n        {\n            openClose = closes.top();\n\
    \            inClose = false;\n            closes.pop();\n            currClose\
    \ = closes.top();\n            numClosingGroups++;\n        }\n        else \n\
    \        {\n            if(c == '(')\n                opens.push(currNestingGroup\
    \ = c + \"(\");\n            else if(inOpen)\n                throw new Exception(\"\
    Unbalanced parenthesis\");\n            else if(c == ')')\n            {\n   \
    \             opens.push(currNestingGroup = currNestingGroup + \")\");\n     \
    \           numNestingGroups++;\n                if(opens.top().empty())\n   \
    \                 throw new Exception(\"Unbalanced parenthesis\");\n         \
    \       else\n                    currNestingGroup = opens.top();\n          \
    \  }\n            else if(c == '(' || c == ')')\n            {\n             \
    \   opens.push(currNestingGroup + c);\n                numNestingGroups++;\n \
    \           }\n            else if(numOpeningGroups == 0 && c == ' ')\n      \
    \      {\n                inOpen = true;\n            }\n            else if(numOpeningGroups\
    \ > 0 && c == ' ')\n            {\n                inOpen = true;\n          \
    \  }\n            else if(numClosingGroups > 0 && c == ' ')\n            {\n \
    \               inClose = true;\n            }\n            else if(c == '(')\n\
    \            {\n                opens.push(currNestingGroup = c + \"(\");\n  \
    \              numOpeningGroups++;\n            }\n            else if(c == ')')\n\
    \            {\n                closes.push(currNestingGroup = currNestingGroup\
    \ + \")\");\n                numClosingGroup", "{\n\tstring s = paren_string;\n\
    \tlong[] levels = new long[paren_string.length()];\n\tint paren_level = 0;\n\t\
    for (int i = 0; i < paren_string.length(); i++) {\n\t\tif (s[i] == '(') {\n\t\t\
    \tif (paren_level < levels[paren_level]) {\n\t\t\t\tlevels[paren_level] = paren_level;\n\
    \t\t\t}\n\t\t\tparen_level++;\n\t\t}\n\t\telse if (s[i] == ')') {\n\t\t\tparen_level--;\n\
    \t\t}\n\t}\n\treturn levels;\n}\n/*\n Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    For each of\
    \ the group, output the deepest level of nesting of parentheses.\n    E.g. (()())\
    \ has maximum two levels of nesting while ((())) has three.", "{\n\tlong[] max_levels\
    \ = new long[paren_string.length()];\n\tlong[] levels = new long[paren_string.length()];\n\
    \tstack<long> stack = new stack<long>();", "{\n    int[] max_level = new int[paren_string.length()];\n\
    \    int[] number_of_open_braces = new int[paren_string.length()];\n    int level\
    \ = 0;\n    long max_level_value = 0;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        switch(paren_string[i]) {\n            case ')': \n        \
    \        if(level == max_level[i - number_of_open_braces[i]])\n              \
    \      max_level_value = level;\n                level--;\n                break;\n\
    \            case '(':\n                level++;\n                number_of_open_braces[i]++;\n\
    \                break;\n        }\n    }\n    max_level_value = max(max_level_value,\
    \ level);\n    return max_level_value;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=parsing,language-agnostic,parentheses,python,c#\
    \ |>\nI like Hamlet and Eric's solutions, but I've been working on a JavaScript\
    \ solution for some time now:\n<code>\nfunction parseParens(s) {\n  var len =\
    \ s.length;\n  var stack = [];\n  var res = [];", "{\n    long level = 0;\n  \
    \  long max_level = 0;\n    bool first_level_open = false;\n    bool second_level_open\
    \ = false;\n    bool last_level_open = false;\n    string token = \"\";\n    string\
    \ open = paren_string[0];\n    string close = paren_string[paren_string.length-1];\n\
    \    foreach(char c in paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            if(!first_level_open)\n            {\n                first_level_open\
    \ = true;\n                level++;\n            }\n        }\n        else if(c\
    \ == ')')\n        {\n            if(!second_level_open)\n            {\n    \
    \            second_level_open = true;\n                level--;\n           \
    \ }\n            else if(last_level_open)\n            {\n                level--;\n\
    \            }\n        }\n        else if(c == '(')\n        {\n            if(!last_level_open)\n\
    \            {\n                last_level_open = true;\n                level++;\n\
    \            }\n        }\n        else\n        {\n            if(!last_level_open)\n\
    \            {\n                last_level_open = true;\n                level++;\n\
    \            }\n        }\n        if(!first_level_open && !second_level_open\
    \ && level > max_level)\n        {\n            max_level = level;\n        }\n\
    \        if(!first_level_open && second_level_open && level > max_level)\n   \
    \     {\n            max_level = level;\n        }\n        token += c;\n    }\n\
    \    \n    return long[max_level, level];\n}", "{\n    long level = 0;\n    stack<int>\
    \ s;", "{\n  int size = paren_string.length();\n  long[] nlevels = new long[size];\n\
    \  nlevels[size - 1] = paren_string.length();\n  int i = size - 2;\n  while (i\
    \ >= 0) {\n    string paren = paren_string.substring(i, i + 1);\n    string next_paren\
    \ = paren_string.substring(i + 1, i + 2);\n    if (paren == \"(\") {\n      nlevels[i]\
    \ = parse_nested_parens(next_paren);\n    } else if (paren == \")\") {\n     \
    \ if (nlevels[i + 1] != parse_nested_parens(next_paren))\n        throw runtime_error(\"\
    unmatched \")\" in string{paren_string.c_str()});\n      nlevels[i] = nlevels[i\
    \ + 1];\n    } else {\n      throw runtime_error(\"unrecognized parentheses in\
    \ string{\" + paren_string.c_str()+\"}\");\n    }\n    i--;\n  }\n  return nlevels;\n\
    }", "{\n\tauto brackets = paren_string.find_first_of(\"()\");\n\tint cur_level\
    \ = 1;\n\tauto cur_end = paren_string.find(\")\", brackets);\n\tstring cur_group\
    \ = \"\";\n\tfor (auto i = brackets; i < paren_string.length(); ++i) {\n\t\tif\
    \ (paren_string[i] == '(') cur_level ++;\n\t\telse cur_level --;\n\t\tif (cur_level\
    \ == 0) cur_end = i;\n\t\tcur_group += paren_string[i];\n\t}\n\tassert(brackets\
    \ < paren_string.length());\n\tassert(cur_end != paren_string.length());\n\tauto\
    \ max_level = (paren_string.find_first_of(\")\", brackets) - brackets);\n\tlong[]\
    \ cur_levels = new long[max_level + 1];\n\tlong[] cur_groups = new long[max_level\
    \ + 1];\n\tcur_groups[max_level] = cur_group.length();\n\tcur_levels[max_level]\
    \ = cur_level;\n\tfor (auto i = brackets; i < paren_string.length(); ++i) {\n\t\
    \tif (paren_string[i] == '(') {\n\t\t\tcur_level ++;\n\t\t\tcur_group += paren_string[i];\n\
    \t\t}\n\t\telse if (paren_string[i] == ')') {\n\t\t\tcur_level --;\n\t\t}\n\t\t\
    else if (paren_string[i] == '(') {\n\t\t\tcur_level ++;\n\t\t}\n\t\telse if (paren_string[i]\
    \ == ')') {\n\t\t\tcur_level --;\n\t\t}\n\t\tcur_groups[cur_level] = cur_group.length();\n\
    \t\tcur_levels[cur_level] = cur_level;\n\t}\n\tassert(cur_groups[max_level] ==\
    \ cur_group.length());\n\treturn cur_levels;\n}", "{\n    string parens = \"()\"\
    ;\n    string stack = \"()\";\n    long n = 0;\n    \n    for(int i = 0; i !=\
    \ paren_string.length(); ++i) {\n        if(paren_string[i] == parens[0]) {\n\
    \            stack = stack + parens[0];\n        } else {\n            n = max(n,\
    \ stack.size());\n            stack = stack + parens[i];\n        }\n    }\n \
    \   \n    return Vector.<long>(n).map(stack -> stack.size());\n}", "{\n    \n\
    \    int[] levels = new int[paren_string.length()];\n    bool has_closed = false;\n\
    \    int  cur_level = 0;\n    long max_level = 0;\n    \n    int open = 0;\n \
    \   int close = 0;\n    int index = 0;\n    int parens = 0;\n    bool is_first\
    \ = true;\n    \n    for(int i = 0; i < paren_string.length(); i++, index++) {\n\
    \        char c = paren_string[index];\n        \n        // is closing a parenthesis\n\
    \        if(c == '(') {\n            open++;\n            \n            // has\
    \ this a closing parenthesis within previous parenthesises?\n            if(open\
    \ > 1 && close > 0) {\n                \n                levels[parens] += max_level;\n\
    \                \n                // is this the first parenthesis in this group\n\
    \                if(is_first) {\n                    max_level = parens;\n   \
    \             }\n            }\n            \n            // is this a new parenthesis\
    \ group?\n            if(open > 1) {\n                \n                parens++;\n\
    \            }\n            \n            open--;\n        }\n        \n     \
    \   // is this a closing parenthesis?\n        else if(c == ')') {\n         \
    \   close++;\n            \n            // has this a closing parenthesis within\
    \ previous parenthesises?\n            if(open > 1 && close > 0) {\n         \
    \       \n                levels[parens] += max_level;\n                \n   \
    \             // is this the last parenthesis in this group?\n               \
    \ if(parens == levels[parens] - 1) {\n                    max_level = parens -\
    \ 1;\n                }\n                \n            }\n            \n     \
    \       // is this a new parenthesis group?\n            if(close > 1) {\n   \
    \             \n                parens--;\n            }\n            \n     \
    \       close--;\n        }\n        \n        // is this a new parenthesis group?\n\
    \        else if(c == ' ') {\n            levels[parens] = 0;\n            \n\
    \            parens++;\n        }\n        \n        // is this another type of\
    \ parenthesis\n        else if(open == 0 && close == 0) {\n            levels[parens]++;\n\
    \        }\n        \n        // is this a close parenthesis?\n        else if(c\
    \ == '\\n') {\n            \n            // has this a closing parenthesis within\
    \ previous parenthesises?\n            if(open > 1 && close > 0) {\n         \
    \       \n                levels[parens] += max_level;\n                \n   \
    \             // is this the last parenthesis in this group?\n               \
    \ if(parens == levels[parens] - 1) {\n                    max_level = parens -\
    \ 1;\n                }\n                \n            }\n            \n     \
    \       // is this a new parenthesis group?\n            if(open > 1) {\n    \
    \            \n                parens++;\n            }\n            \n      \
    \      open--;\n            close--;", "{\n    long[] result = new long[paren_string.length()];\n\
    \    int level = 0;\n    int pos = 0;\n    while((pos = paren_string.IndexOf('(',\
    \ pos)) != -1)\n    {\n        int start = paren_string.IndexOf('(', pos);\n \
    \       int end = paren_string.IndexOf(')', pos);\n        if(end == -1)\n   \
    \         end = paren_string.Length;\n        string part = paren_string.Substring(start,\
    \ end - start);\n        result[level++] = long.Parse(part);\n        pos = end;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a tags=c#,algorithm,parsing\
    \ |>\nYou can do this with Regex. I've got an example of one solution here. I\
    \ recommend looking up the Regex reference for details about how to use it.\n\
    <|/ a dscore=0 |>\n<| c |>\nThis only seems to give one level of nesting. E.g.\
    \ (()) has only one level of nesting while ((())) has two.\n<|/ c |>\n<| c |>\n\
    Sorry - missed the second level.\n<|/ c |>\n<| a tags=c#,algorithm,parsing |>\n\
    I guess you need to build something like this:\n<code>\n    static void Main(string[]\
    \ args)\n    {\n        string input = \"((())()) ((())) () ((())()())\";\n  \
    \      List<String> tokens = input.Split(' ');", "{\n    long[] result = new long[paren_string.Length];\n\
    \    long prev_level = 0;\n    \n    bool in_paren = false;\n    for(char c: paren_string)\n\
    \    {\n        if(!in_paren)\n        {\n            in_paren = true;\n     \
    \       continue;\n        }\n        if(c == '(')\n        {\n            prev_level\
    \ = prev_level + 1;\n        }\n        else if(c == ')')\n        {\n       \
    \     prev_level = prev_level - 1;\n        }\n        else if(c == '\\\\')\n\
    \        {\n            prev_level -= 2;\n            prev_level = prev_level\
    \ % 4;\n            \n            // check for odd number of (\n            if(prev_level\
    \ == 0)\n            {\n                prev_level = 1;\n            }\n     \
    \   }\n        else\n        {\n            prev_level = 0;\n        }\n     \
    \   result[result.Length - prev_level] = result.Length - prev_level + 1;\n   \
    \ }\n    \n    return result.Take(result.Length - 1).ToArray();\n}\n</code>\n\
    Note that this is slightly more complicated than the one in \"Efficient parsing\
    \ of nested parentheses in C++\", and uses a slightly different algorithm that\
    \ works more efficiently than the one in \"Efficient parsing of nested parentheses\
    \ in C++\". For this code to work as is, the string to be parsed must be in the\
    \ following format: \n(...)\nWhere ... can be any sequence of '(', ')', '\\\\\
    ', or '()', with optional whitespace.\n<|/ a dscore=4 |>\n<| a dscore=3 tags=parsing,c#,parentheses,regex,nested\
    \ |>\nI wrote a parser for this type of thing for Ruby. I think it should be easy\
    \ to convert it back to C#, but here it is. I'm sure it can be simplified.\n<code>\n\
    # Parse a string and return the level of nesting.\n# An empty string returns zero.\n\
    # Nested parens are ignored.\n#\n# Example input strings:\n#   \"()\"\n#   \"\
    ( ( () ) )\"\n#   \"( ( () ) ( ) )\"\n#   \"( ( )) \"\n#   \"( ( ( ) ) ( ) )\"\
    \n#   \"( ( ( ) ) ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( (\
    \ ( ( ( ( ( ( ( ( ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) )\
    \ ) ) ) ) ) ) )\"\n# \n# Example output values:\n#   0\n#   1\n#   3\n#   4\n\
    #   0\n#   1\n", "{\n\tint max_levels = 0, levels = 0, current_level = 0;", "{\n\
    \    long total = 0;\n    for (string s : paren_string.split(\"\\\\s\")) {\n \
    \       for (string group : s.split(\"\\\\(\")) {\n            long level = parse_nested_parens(group);\n\
    \            total += level;\n        }\n        total += 1;\n    }\n    \n  \
    \  return total;\n}", "{\n  long level = 0;\n  long maxLevel = 0;\n  int paren_count\
    \ = 0;\n  int i = 0;\n  while(i<paren_string.length())\n  {\n    if(paren_string[i]=='(')\n\
    \      paren_count++;\n    else if(paren_string[i]==')')\n    {\n      paren_count--;\n\
    \      if(paren_count==0)\n        maxLevel = level;\n      level++;\n    }\n\
    \    i++;\n  }\n  long[] levels = new long[paren_count];\n  for(i=0; i<paren_count;\
    \ i++)\n    levels[i] = maxLevel;\n  return levels;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThe solution is very close to what i am looking for, thanks. However,\
    \ the answer you provided has issues, in that it doesn't give the correct output\
    \ if the input is \"(((())))\". For this input, your code outputs 2 instead of\
    \ 3 when it should output 3.\n<|/ c |>\n<| c |>\nIt is not hard to adjust this\
    \ code to meet your needs. Just use a counter `int paren_count` and initialize\
    \ it with `paren_count = 0;` inside `for`-loop of `parse_nested_parens`. Then\
    \ add another `if` statement to check `paren_count` before incrementing `i`.\n\
    <|/ c |>\n<| a |>\nThis is a problem from Project Euler. Here is the solution\
    \ I found. I did not see it at first. I found it by looking at this answer:\n\
    <code>\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\
    import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Set;\nimport\
    \ java.util.List;\nimport java.util.Map;\nimport java.util.Set;", "{\n    stack<string>\
    \ paren_stack;", "{\n\tstring s = paren_string;\n\tchar[] c = s.toCharArray();\n\
    \tlong n = s.length();\n\tlong[] result = new long[n];", "{\n    char[] parens_array\
    \ = paren_string.toCharArray();\n    long max_level = 0;\n    long cur_level =\
    \ 0;\n    for(char c: parens_array)\n    {\n        if(!(c == '(' || c == '['\
    \ || c == '{' || c == '{'))\n        {\n            cur_level--;\n        }\n\
    \        else if(c == '(')\n        {\n            cur_level++;\n        }\n \
    \       else if(c == '[') \n        {\n            cur_level++;\n        }\n \
    \       else if(c == '{')\n        {\n            cur_level++;\n        }\n  \
    \      else if(c == '}') \n        {\n            cur_level--;\n        }\n  \
    \      max_level = max(cur_level, max_level);\n    }\n    long[] result = new\
    \ long[max_level+1];\n    for(char c: parens_array)\n    {\n        if(!(c ==\
    \ '(' || c == '[' || c == '{' || c == '{'))\n        {\n            result[cur_level]\
    \ = cur_level;\n        }\n        else if(c == '(')\n        {\n            result[cur_level]\
    \ = cur_level;\n            cur_level++;\n        }\n        else if(c == '[')\
    \ \n        {\n            result[cur_level] = cur_level;\n            cur_level++;\n\
    \        }\n        else if(c == '{')\n        {\n            result[cur_level]\
    \ = cur_level;\n            cur_level++;\n        }\n        else if(c == '}')\
    \ \n        {\n            result[cur_level] = cur_level;\n            cur_level--;\n\
    \        }\n    }\n    return result ;\n}", "{\n  int open_bracket = 0, closed_bracket\
    \ = 0;\n  \n  stack<int> nesting;\n  stack<int> new_nesting;\n  \n  int max_depth\
    \ = 0;\n  \n  for(int i = 0; paren_string[i] != '\\0'; i++)\n  {\n    \n    if(paren_string[i]\
    \ == ')')\n    {\n      open_bracket--;\n      \n      if(open_bracket == 0 &&\
    \ new_nesting.size() == 0)\n      {\n        nesting.push(closed_bracket);\n \
    \       new_nesting.push(closed_bracket);\n        max_depth = nesting.size();\n\
    \      }\n      \n      closed_bracket++;\n      \n      if(nesting.size() > nesting.top())\n\
    \      {\n        int current_depth = nesting.size() - 1;\n        int parent_depth\
    \ = nesting.top() - 1;\n        \n        if(current_depth > max_depth)\n    \
    \    {\n          max_depth = current_depth;\n        }\n        \n        if(parent_depth\
    \ > max_depth)\n        {\n          max_depth = parent_depth;\n        }\n  \
    \      \n        if(parent_depth <= max_depth)\n        {\n          nesting.pop();\n\
    \          new_nesting.push(current_depth);\n        }\n      }\n    }\n    else\
    \ if(paren_string[i] == '(')\n    {\n      open_bracket++;\n      \n      if(open_bracket\
    \ == 0 && new_nesting.size() == 0)\n      {\n        nesting.push(closed_bracket);\n\
    \        new_nesting.push(closed_bracket);\n        max_depth = nesting.size();\n\
    \      }\n      \n      closed_bracket++;\n      \n      if(nesting.size() > nesting.top())\n\
    \      {\n        int current_depth = nesting.size() - 1;\n        int parent_depth\
    \ = nesting.top() - 1;\n        \n        if(current_depth > max_depth)\n    \
    \    {\n          max_depth = current_depth;\n        }\n        \n        if(parent_depth\
    \ > max_depth)\n        {\n          max_depth = parent_depth;\n        }\n  \
    \      \n        if(parent_depth <= max_depth)\n        {\n          nesting.pop();\n\
    \          new_nesting.push(current_depth);\n        }\n      }\n    }\n  }\n\
    \  \n  long[] result = new long[max_depth+1];\n  \n  for(int i = max_depth; i\
    \ >= 0; i--)\n  {\n    result[i] = new_nesting.size() - 1;\n  }\n  \n  return\
    \ result;\n}\n</code>\n<|/ a |>\n<| c |>\nThe code above is very simple and works\
    \ very well in most cases but there are two problems in some cases (such as \"\
    ((()\"))", "{\n    long n = paren_string.length();\n    long index = 0;\n    long[]\
    \ level = new long[n];\n    long[] count = new long[n];\n    level[0] = count[0]\
    \ = 1;\n    level[1] = 1;\n    long max_level = 0;\n    \n    // Find the deepest\
    \ level of nesting\n    while (index < n && paren_string[index] == ' ') {\n  \
    \      ++index;\n    }\n    while (index < n && paren_string[index] != ')') {\n\
    \        if (level[index] < count[index]) {\n            level[index] = count[index];\n\
    \            ++max_level;\n        }\n        ++index;\n    }\n    \n    // Compute\
    \ the output result\n    long[] result = new long[max_level];\n    long cur_level\
    \ = level[0];\n    for (long i = 1; i < max_level; ++i) {\n        long new_level\
    \ = level[i];\n        result[cur_level - 1] = result[cur_level - 1] + new_level;\n\
    \        cur_level = new_level;\n    }\n    \n    return result;\n}", "{\n  string\
    \ current_paren_string;\n  string paren_group;\n  long max_level = 0;\n  int paren_level\
    \ = 1;\n  int i;\n  for(i = 0; i < paren_string.length; ++i) {\n    current_paren_string\
    \ = paren_string.substr(i, 1);\n    paren_group = paren_string.substr(i, paren_string.length-1);\n\
    \    if(paren_group.length==0) {\n      max_level = max_level * paren_level;\n\
    \      paren_level = 1;\n      --i;\n    } else if(paren_group.equals(\")\"))\
    \ {\n      max_level = max_level * paren_level;\n      ++paren_level;\n    } else\
    \ {\n      if(current_paren_string.length() > 0) {\n        string tmp_string\
    \ = current_paren_string;\n        while(!tmp_string.equals(\"(\") && !tmp_string.equals(\"\
    )\")) {\n          tmp_string = tmp_string.substr(0, tmp_string.length()-1);\n\
    \        }\n        if(tmp_string.equals(\"(\"))\n          max_level = max_level\
    \ * paren_level;\n        else\n          max_level = max_level / paren_level;\n\
    \      }\n      paren_level = 1;\n    }\n  }\n  return new long[max_level+1];\n\
    }", "{\n    int[] levels = paren_string.find_parens(\"()\", paren_string);\n \
    \   long[] result = new long[levels.length];\n    for (int i = 0; i < levels.length;\
    \ i++)\n        result[i] = levels[i];\n    return result;\n}\n</code>\n<|/ a\
    \ dscore=4 tags=string,java,regex |>\n<| c |>\nThis does not answer the question\
    \ at all, it just uses another way to solve the problem and doesn't answer the\
    \ question at all. Also your solution is very similar to [this answer](http://stackoverflow.com/a/17875760/829571).\n\
    <|/ c |>\n<| c |>\nAm I missing something? This does not give the level of nesting\
    \ as asked by the OP. The level of nesting is only returned as a string. `[2,\
    \ 3, 1, 3]`.\n<|/ c |>\n<| c |>\nThe OP wrote \"for each of the group\" in the\
    \ question.\n<|/ c |>\n<| c |>\nI see what you mean. But then the question is\
    \ badly phrased. I think my solution is the best solution for this problem. I\
    \ think it solves the OP's problem as asked. The OP asked for \"output the deepest\
    \ level of nesting\". My solution does just that. \"output the deepest level of\
    \ nesting\".\n<|/ c |>\n<| c |>\nI'm sorry. I don't think this really answers\
    \ the question. The OP asked for \"for each of the group\".\n<|/ c |>\n<| a dscore=3\
    \ tags=string,java,regex |>\nI know this answer is already accepted, but I had\
    \ this exact question to solve and thought I'd post my solution anyways. I like\
    \ to use recursion and recursion is a nice feature that java can have.\n<code>\n\
    public static int getNestingLevel(String input){\n  if(input == null || input.length()\
    \ == 0)\n    return 0;", "{\n    stack<int> paren_levels;\n    paren_levels.push();",
  "{\n    string[] paren_groups = paren_string.split(\" \");\n    long[] levels_of_nesting\
    \ = new long[paren_groups.length];", "{\n    long[] levels = new long[paren_string.length()];\n\
    \    string s;\n    for(int i = 0; i < paren_string.length(); i++) \n    {\n \
    \       s = paren_string.substr(i, 1);\n        if(s == \")\")\n        {\n  \
    \          levels[i] = levels[i-1] + 1;\n        }\n        else if(s == \"(\"\
    )\n        {\n            levels[i] = 0;\n        }\n        else\n        {\n\
    \            levels[i] = levels[i-1];\n        }\n    }\n    return levels;\n}",
  "{\n    long[] result = new long[paren_string.Length];\n    int open = paren_string.IndexOf('(');\n\
    \    int close = paren_string.IndexOf(')');\n    int counter = 0;\n    for (int\
    \ i = 0; i < paren_string.Length; i++)\n    {\n        if (paren_string[i] ==\
    \ '(') \n        {\n            if (paren_string[open + counter] == ')') \n  \
    \          {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == ')') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == ')') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else\n            {\n                result[i] = open;\n\
    \                counter++;\n            }\n        }\n        else if (paren_string[i]\
    \ == ')') \n        {\n            if (paren_string[open + counter] == '(') \n\
    \            {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == '(') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == '(') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else\n            {\n                result[i] = open;\n\
    \                counter++;\n            }\n        }\n        else if (paren_string[i]\
    \ == ')') \n        {\n            if (paren_string[open + counter] == '(') \n\
    \            {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == '(') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else if (paren_string[open + counter] == '(') \n \
    \           {\n                result[i] = open;\n                counter++;\n\
    \            }\n            else\n            {\n                result[i] = open;\n\
    \                counter++;\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\nThe output is the maximum level of nesting for each group:\n<code>\n\
    public static long MaxNesting(string input)\n{\n    string result = null;\n  \
    \  long[] nesting_levels = ParseNestedParens(input);\n    for (int i = 0; i <\
    \ nesting_levels.Length; i++)\n    {\n        if (nesting_levels[i] > result)\
    \ result = nesting_levels[i];\n    }\n    return result;\n}\n</code>\nThe input\
    \ for the last example is:\n<code>\nstring input = \"(((()))())((((((((((()))()))))))))\"\
    ;\n</code>\nThe output of this function should be 6.\n<|/ a tags=c#,algorithm\
    \ |>\n<| c |>\nNice! Can you make some comments in your code?\n<|/ c |>\n<| c\
    \ |>\n", "{\n    long[] nestings = new long[paren_string.length()];\n    long\
    \ current_level;\n    for (long i = 0; i < paren_string.length(); ++i) {\n   \
    \     char c = paren_string[i];\n        if (c == '(' || c == '[') {\n       \
    \     current_level = i;\n        } else if (c == ')' || c == ']') {\n       \
    \     nestings[current_level] = max(nestings[current_level], i - current_level);\n\
    \        }\n    }\n    return nestings;\n}", "{\n    long[] paren_counts = new\
    \ long[paren_string.length()];\n    long max_count = 1;\n    \n    foreach(char\
    \ c in paren_string) {\n        int i = paren_string.indexOf(c, 0);\n        paren_counts[i]\
    \ = paren_counts[i] + 1;\n        if (paren_counts[i] > max_count) {\n       \
    \     max_count = paren_counts[i];\n        }\n    }\n    \n    long[] max_paren_level\
    \ = new long[max_count + 1];\n    foreach(int i in paren_counts) {\n        max_paren_level[i]\
    \ = max_paren_level[i - 1];\n    }\n    \n    foreach(long l in max_paren_level)\
    \ {\n        if (l == 0) {\n            l++;\n        }\n    }\n    \n    max_paren_level[max_count\
    \ + 1]++;\n    max_paren_level[max_count]++;\n    \n    foreach(long l in max_paren_level)\
    \ {\n        if (l == 0) {\n            l++;\n        }\n    }\n    \n    return\
    \ max_paren_level;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis is very similar\
    \ to the one above. I will try it out, thank you!\n<|/ c |>\n<| a tags=string,function,c#,recursion,parsing\
    \ |>\nHere is the answer, thank you for all suggestions and comments.\n<code>\n\
    public static long ParseString(string input)\n{\n    long output = 0;\n    Stack<long>\
    \ stack = new Stack<long>();\n    char[] parenthesis = new char[] { '(', ')' };\n\
    \    char[] brackets = new char[] { '{', '}' };", "{\n\t// parse nested parens\n\
    \tlong max_level = 0;\n\tchar[] parens = paren_string.toCharArray();\n\tint n_parens\
    \ = 0;\n\tfor (int i = 0; i < parens.length; ++i)\n\t{\n\t\tchar c = parens[i];\n\
    \t\tswitch(c)\n\t\t{\n\t\t\tcase '(':\n\t\t\t\t++n_parens;\n\t\t\t\tbreak;\n\t\
    \t\tcase ')':\n\t\t\t\t--n_parens;\n\t\t\t\tif (max_level < n_parens) max_level\
    \ = n_parens;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tlong[] results = new long[max_level\
    \ + 1];\n\tresults[0] = 0;\n\tfor (int i = 0; i < parens.length; ++i)\n\t{\n\t\
    \tchar c = parens[i];\n\t\tswitch(c)\n\t\t{\n\t\t\tcase '(':\n\t\t\t\t++results[results[0]];\n\
    \t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\t--results[results[0]];\n\t\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn results;\n}", "{\n    long[] res = new long[paren_string.length()];",
  "{\n    var level = 0;\n    var deepest_level = 0;\n    for(int i=0;i<paren_string.size();i++)\
    \ {\n        if (paren_string[i] == '(') {\n            level++;\n        }\n\
    \        else if (paren_string[i] == ')') {\n            level--;\n        }\n\
    \        if (level > deepest_level) {\n            deepest_level = level;\n  \
    \      }\n    }\n    return new long[] { deepest_level + 1 };\n}\n</code>\n<|/\
    \ a tags=java,algorithm dscore=1 |>\n<| c |>\nthanks. can you please give a small\
    \ code sample of the algorithm?\n<|/ c |>\n<| c |>\nI've added an example in Java.\n\
    <|/ c |>\n<| c |>\nthanks for all the help. one more question - what is the significance\
    \ of the last line of code?\n<|/ c |>\n<| c |>\nI've added comments to the last\
    \ line of code explaining the purpose.\n<|/ c |>\n<| a tags=java,algorithm dscore=0\
    \ |>\n<code>\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\
    import java.util.Map;", "{\n    int current_level = 0;\n    int nested_level =\
    \ paren_string.length();\n    long[] levels = new long[nested_level];\n    string\
    \ last_char_without_closing;\n    char open_parenthesis = '(';\n    \n    for(int\
    \ i = 0; i < levels.length; ++i)\n    {\n        last_char_without_closing = paren_string[i];\n\
    \        levels[i] = 0;\n    }\n    \n    for(int i = nested_level - 1; i >= 0;\
    \ --i)\n    {\n        int j = nested_level - 1 - i;\n        if (paren_string[j]\
    \ == '(')\n        {\n            levels[i] = levels[j] + 1;\n        }\n    \
    \    else if (paren_string[j] == ')')\n        {\n            if (levels[j] ==\
    \ current_level)\n            {\n                levels[j] = 0;\n            }\n\
    \            else\n            {\n                levels[j] = levels[j] - 1;\n\
    \            }\n        }\n        else if (paren_string[j] == ' ' && levels[j]\
    \ != 0)\n        {\n            levels[j] = 0;\n        }\n    }\n    \n    long[]\
    \ ret_levels = new long[levels.length];\n    for (int i = 0; i < levels.length;\
    \ ++i)\n    {\n        if (levels[i] > 0)\n        {\n            ret_levels[i]\
    \ = levels[i];\n        }\n        else\n        {\n            ret_levels[i]\
    \ = 0;\n        }\n    }\n    \n    return ret_levels;\n}\n</code>\n<|/ a dscore=1\
    \ tags=java,algorithm,c++,dynamic-programming |>\n<| a dscore=1 |>\nI know I'm\
    \ late to the party but I had a similar problem and this is how I solved it:\n\
    <code>\npublic static int maxNestings(String input) {\n    if (input == null ||\
    \ input.length() == 0)\n        return 0;", "{\n\tassert(paren_string.length()\
    \ >= 2);\n\tint level = 0;\n\tint max_level = paren_string.length();\n\tlong current_level;\n\
    \tint i = 0;\n\tstring current_opening = \"\";\n\tstring current_closing = \"\"\
    ;\n\tstring current_token = paren_string.substr(i, max_level - i);\n\tfor (; i\
    \ < max_level; ++i) \n\t{\n\t\tif (current_token == \")\") \n\t\t{\n\t\t\tassert(level\
    \ > 0);\n\t\t\tassert(level != current_level);\n\t\t\tcurrent_level--;\n\t\t\t\
    current_closing = \"\";\n\t\t}\n\t\telse if (current_token == \"(\") \n\t\t{\n\
    \t\t\tassert(level == 0);\n\t\t\tassert(level != current_level);\n\t\t\tcurrent_level++;\n\
    \t\t\tcurrent_opening = \"\";\n\t\t}\n\t\telse \n\t\t{\n\t\t\tassert(level !=\
    \ 0);\n\t\t\tassert(level == current_level);\n\t\t\tcurrent_closing += current_token;\n\
    \t\t}\n\t\tif (level == current_level) \n\t\t{\n\t\t\tassert(current_closing[0]\
    \ == current_opening[0]);\n\t\t\tcurrent_token = current_closing;\n\t\t\ti +=\
    \ current_closing.length();\n\t\t}\n\t\telse \n\t\t{\n\t\t\tcurrent_opening =\
    \ current_token;\n\t\t\ti += current_opening.length();\n\t\t\tcurrent_token =\
    \ paren_string.substr(i, max_level - i);\n\t\t}\n\t}\n\tassert(level == current_level);\n\
    \tassert(paren_string.length() == i);\n\tlong[] result = { 0 };\n\tfor (; i <\
    \ max_level; ++i)\n\t{\n\t\tlong opening = current_opening.length();\n\t\tcurrent_opening\
    \ = \"\";\n\t\tcurrent_closing = \"\";\n\t\tcurrent_token = paren_string.substr(i,\
    \ max_level - i);\n\t\tcurrent_level = 0;\n\t\tfor (; i < max_level; ++i) \n\t\
    \t{\n\t\t\tif (current_token == \")\") \n\t\t\t{\n\t\t\t\tassert(level > 0);\n\
    \t\t\t\tassert(level != current_level);\n\t\t\t\tcurrent_level--;\n\t\t\t\tcurrent_closing\
    \ = \"\";\n\t\t\t}\n\t\t\telse if (current_token == \"(\") \n\t\t\t{\n\t\t\t\t\
    assert(level == 0);\n\t\t\t\tassert(level != current_level);\n\t\t\t\tcurrent_level++;\n\
    \t\t\t\tcurrent_opening = \"\";\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tassert(level\
    \ != 0);\n\t\t\t\tassert(level == current_level);\n\t\t\t\tcurrent_closing +=\
    \ current_token;\n\t\t\t}\n\t\t\tif (level == current_level) \n\t\t\t{\n\t\t\t\
    \tassert(current_closing[0] == current_opening[0]);\n\t\t\t\tcurrent_token = current_closing;\n\
    \t\t\t\ti += current_closing.length();\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\t\
    current_opening = current_token;\n\t\t\t\ti += current_opening.length();\n\t\t\
    \t\tcurrent_token = paren_string.substr(i, max_level - i);\n\t\t\t}\n\t\t}\n\t\
    \tassert(level == current_level);\n\t\tassert(", "{\n    long level = 1;\n   \
    \ long max_level = 0;\n    long max_paren_level = 0;\n    long paren_count = 0;\n\
    \    vector<long> paren_levels(paren_string.length(), max_level);\n    map<long,\
    \ long> paren_to_max_level;\n    \n    for (long i = 0; i < paren_string.length();\
    \ ++i)\n    {\n        char ch = paren_string[i];\n        \n        if (ch ==\
    \ ')') // closing a parens\n        {\n            paren_levels[paren_count] =\
    \ level;\n            paren_count++;\n            \n            if (paren_count\
    \ > max_paren_level)\n                max_paren_level = paren_count;\n       \
    \     \n            if (paren_count == max_paren_level)\n            {\n     \
    \           if (paren_count > max_level)\n                    max_level = paren_count;\n\
    \                \n                // increment level to count next nested level\n\
    \                level++;\n            }\n        }\n        else if (ch == '(')\
    \ // opening another parens\n        {\n            level--;\n        }\n    \
    \    else if (ch == ' ')\n        {\n            if (paren_count == max_paren_level)\n\
    \            {\n                // We are at the deepest level\n             \
    \   paren_levels[paren_count] = level;\n            }\n        }\n    }\n    \n\
    \    long[] max_levels = { max_level };\n    \n    for (long i = 0; i < max_paren_level;\
    \ ++i)\n    {\n        long paren_level = paren_levels[i];\n        \n       \
    \ max_levels[max_paren_level - 1 - i] = paren_level;\n    }\n    \n    return\
    \ max_levels;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis was my first thought,\
    \ but I wonder how it handles nested parens which have different levels of nesting\
    \ (e.g. \"()()()\")\n<|/ c |>\n<| c |>\n: It will work, but as you can see, it\
    \ will be a lot more complicated. I'll try to write something more efficient.\n\
    <|/ c |>\n<| c |>\n: I've updated my answer with a more efficient version.\n<|/\
    \ c |>\n<| a |>\nA simple iterative function should do:\n<code>\ndef paren_levels(s):\n\
    \    level = 0\n    result = []\n    while s:\n        ch = s[0]\n        if ch\
    \ == ')':\n            level += 1\n            if level > len(result):\n     \
    \           result.append(level)\n        else:\n            if level == 0:\n\
    \                raise Exception('invalid input')\n            level -= 1\n  \
    \          \n        s, s = s[1:], s[1:]\n    return result\n</code>\n<|/ a tags=language-agnostic,recursion,algorithm\
    \ dscore=2 |>\n<| a tags=language-agnostic", "{\n    string s = paren_string;\n\
    \    Stack<long> stack;\n    stack.Push(0);\n    long current_level = 0;\n   \
    \ long level = 0;\n    long max_level = 0;\n    while (!stack.IsEmpty()) {\n \
    \       level = stack.Pop();\n        if (level > max_level) {\n            max_level\
    \ = level;\n        }\n        if (s.Length == 0) {\n            stack.Push(level);\n\
    \            break;\n        }\n        long count = 0;\n        long brackets\
    \ = 0;\n        string s_sub = s.Substring(0,s.Length-1);\n        while (s_sub.Length\
    \ > 0) {\n            char ch = s_sub[0];\n            if (ch == '(') brackets++;\n\
    \            if (ch == ')') brackets--;\n            s_sub = s_sub.Substring(1);\n\
    \            count++;\n        }\n        if (brackets == 0) current_level++;\n\
    \        if (brackets == 1 && level == 1) current_level--;\n        stack.Push(level\
    \ + brackets);\n        s = s.Substring(s.Length-1);\n    }\n    long max_count\
    \ = max_level + 1;\n    long[] ans = new long[max_count];\n    long current_pos\
    \ = 0;\n    stack.Push(current_level);\n    while(!stack.IsEmpty()) {\n      \
    \  level += stack.Pop();\n        ans[current_pos++] = level;\n    }\n    return\
    \ ans;\n}\n/*\n This function takes an array of numbers represented as a string\
    \ and\n    returns a new string that has all the numbers with the same value grouped\
    \ together.\n    E.g. for numbers \"1, 3, 7, 8, 2, 5, 9\" the function returns\
    \ \"1, 7, 8\"\n    Note that in case of repetition of value the function returns\
    \ only the last group of repetition.\n    \n    Example 1:\n    >>> split_into_groups(\"\
    1, 3, 7, 8, 2, 5, 9, 4, 1, 3\")\n    \"1, 7, 8, 2, 5, 9, 4, 1, 3\"\n    \n   \
    \ Example 2:\n    >>> split_into_groups(\"1, 2, 3, 4, 3, 2\")\n    \"1, 2, 3,\
    \ 4, 3, 2\"\n    \n    Example 3:\n    >>> split_into_groups(\"1, 2, 1, 2, 1,\
    \ 2\")\n    \"1, 2, 1, 2, 1, 2\"\n    \n*/\nstring split_into_groups(string number_group_string)\
    \ {\n    Stack<long> stack_levels = new Stack<long>();\n    stack_levels.Push(0);\n\
    \    stack_levels.Push(0);\n    string number_group = \"\";\n    string number_group_with_no_repetition_or_no_values\
    \ = \"\";\n    int current_pos = 0;\n    long level = 0;\n    long max_level =\
    \ 0;\n    while (!stack_levels.IsEmpty()) {\n        level = stack_levels.Pop();\n\
    \        if (level > max_level) {\n", "{\n    long current_level = 0;\n    long\
    \ last_level = 0;\n    long level_length = 0;\n    long level = 0;\n    string\
    \ sub_string;\n    stack<string> st;", "{\n\tlong max_level = 0;\n\tlong level\
    \ = 0;\n\tbool first_paren = true;\n\t\n\tfor(int i = 0; i < paren_string.length;\
    \ ++i)\n\t{\n\t\tchar c = paren_string[i];\n\t\t\n\t\tif(c == '(')\n\t\t\t++level;\n\
    \t\telse if(c == ')')\n\t\t\t--level;\n\t\telse if(c == ' ' && level == 0)\n\t\
    \t\tlevel = max_level;\n\t\telse if(c == ' ' && level > max_level)\n\t\t\tmax_level\
    \ = level;\n\t}\n\t\n\tlong[] result = new long[max_level+1];\n\tfor(int i = 0;\
    \ i < paren_string.length; ++i)\n\t{\n\t\tchar c = paren_string[i];\n\t\t\n\t\t\
    if(c == '(')\n\t\t\t++level;\n\t\telse if(c == ')')\n\t\t\t--level;\n\t\telse\
    \ if(c == ' ' && level == 0)\n\t\t\tlevel = max_level;\n\t\telse if(c == ' ' &&\
    \ level > max_level)\n\t\t{\n\t\t\tresult[i-1] = level;\n\t\t\tlevel = max_level;\n\
    \t\t}\n\t}\n\tresult[i-1] = max_level;\n\t\n\treturn result;\n}", "{\n\tstringstream\
    \ ss;\n\tvector<long> ret;\n\tlong max_level = 0;\n\tfor(auto c : paren_string)\n\
    \t{\n\t\tif(c == '(')\n\t\t{\n\t\t\tret.push_back(1);\n\t\t\tmax_level = max(max_level,\
    \ ret.back());\n\t\t}\n\t\telse if(c == ')')\n\t\t{\n\t\t\tret.push_back(0);\n\
    \t\t\tmax_level = max(max_level, ret.back());\n\t\t}\n\t\telse if(c == ',')\n\t\
    \t{\n\t\t\tret.push_back(1);\n\t\t\tmax_level = max(max_level, ret.back());\n\t\
    \t}\n\t}\n\tret.push_back(max_level);\n\treturn ret;\n}", "{\n\t// Recursive function\
    \ call stack.\n\tlong[] recursive_stack = new long[paren_string.length()];\n\t\
    int i, paren_count = 0;\n\t\n\t// Keep track of parentheses in string and keep\
    \ track of the count of each one.\n\tfor(i = 0; i < paren_string.length(); ++i)\n\
    \t{\n\t\tchar c = paren_string[i];\n\t\tif(c == '(') ++paren_count;\n\t\telse\
    \ if(c == ')') --paren_count;\n\t\trecursive_stack[paren_count] = i;\n\t}", "{\n\
    \    Stack stack = new Stack();\n    stack.Push(paren_string.Length);\n    long[]\
    \ levels = new long[paren_string.Length];", "{\n    var stack = new Stack<long[]>();\n\
    \    foreach (var group in paren_string.Split(' '))\n    {\n        if (group.length\
    \ == 0)\n        {\n            stack.Push(null); // push null to stack if it\
    \ has no nested parentheses\n        }\n        else if (group[0] == '(')\n  \
    \      {\n            stack.Push(parse_nested_parens(group));\n        }\n   \
    \     else if (group[0] == '{' || group[0] == '[')\n        {\n            stack.Push(parse_nested_brackets(group));\n\
    \        }\n        else\n        {\n            long level_of_parentheses = stack.Peek().Length;\n\
    \            stack.Push(new long[] { level_of_parentheses }); // push an array\
    \ with only one element to stack\n        }\n    }\n    return stack.Peek();\n\
    }", "{\n    Stack open_pars_stack = new Stack();\n    long nested_level = 1;\n\
    \    long level_stack[] = new long[MAX_LEVEL];\n    Arrays.fill(level_stack,0);\n\
    \    open_pars_stack.push(0);\n    \n    char[] par_string = paren_string.toCharArray();\n\
    \    for (int i = 0; i < par_string.length; i++)\n    {\n        switch (par_string[i])\n\
    \        {\n            case '(':\n                level_stack[open_pars_stack.getTop()]\
    \ = nested_level++;\n                open_pars_stack.push(level_stack.length -\
    \ 1);\n                break;\n            case ')':\n                level_stack[open_pars_stack.pop()]--;\n\
    \                break;\n        }\n    }", "{\n    string current_group = \"\"\
    ;\n    long current_group_nesting = 1;\n    long max_group_nesting = 1;\n    long[]\
    \ groups = new long[paren_string.length()];", "{\n    map<string, int> paren_depth;\n\
    \    vector<string> paren_strings = split(paren_string, \" \");\n    for (size_t\
    \ i = 0; i < paren_strings.size(); ++i) {\n        string str = paren_strings[i];\n\
    \        int depth = 0;\n        while (i < str.size()) {\n            if (str[i]\
    \ == '(')\n                ++depth;\n            if (str[i] == ')')\n        \
    \        --depth;\n            ++i;\n        }\n        paren_depth[str] = depth;\n\
    \    }", "{\n    string paren_string = paren_string.trim();\n    if (paren_string.length()\
    \ == 0) \n        return null;\n    long[] levels = new long[paren_string.length()];\n\
    \    \n    long[] level = 0;\n    int paren_level = 0;\n    long maxlevel = 0;\n\
    \    long levels[] = new long[paren_string.length()];\n    \n    for (int i =\
    \ 0; i < (int)paren_string.length(); i++) {\n        if (paren_string[i] == ')')\
    \ {\n            levels[paren_level] = levels[paren_level - 1];\n            levels[paren_level\
    \ - 1] = -1;\n            if (maxlevel < levels[paren_level - 1]) \n         \
    \       maxlevel = levels[paren_level - 1];\n            levels[paren_level] =\
    \ -1L;\n            levels[paren_level + 1] = maxlevel;\n            \n      \
    \      levels[paren_level] = maxlevel;\n            paren_level++;\n         \
    \   levels[paren_level] = -1L;\n        } else if (paren_string[i] == '(') {\n\
    \            if (paren_level == 0) \n                levels[paren_level] = -1L;\n\
    \            levels[paren_level] = maxlevel;\n            paren_level++;\n   \
    \     } else {\n            levels[paren_level] = maxlevel;\n        }\n    }\n\
    \    \n    for (int i = 0; i < paren_level; i++) {\n        levels[i] = -1L;\n\
    \    }\n    for (int i = 0; i < (int)paren_string.length(); i++) {\n        if\
    \ (paren_string[i] == ')') {\n            levels[levels[paren_level - 1]] = levels[levels[paren_level\
    \ - 1] - 1];\n            levels[levels[paren_level - 1] - 1] = -1L;\n       \
    \     levels[levels[paren_level - 1]] = -1L;\n        } else if (paren_string[i]\
    \ == '(') {\n            levels[levels[paren_level - 1]] = maxlevel;\n       \
    \     levels[levels[paren_level - 1] - 1] = -1L;\n        }\n    }\n    \n   \
    \ return levels;\n}", "{\n    var result = 0;\n    var stack = 0;", "{\n  stack<long>\
    \ s;\n  \n  for(auto c : paren_string) \n  {\n    switch(c) {\n    case '(':\n\
    \      s.push(0);\n      break;\n    case ')':\n      if (s.top() == 0) \n   \
    \   {\n        return long_array(0, 0L);\n      }\n      \n      s.pop();\n  \
    \    break;\n    case '\\n': \n      if (s.top() == 0) \n      {\n        return\
    \ long_array(0, 0L);\n      }\n      \n      s.pop();\n      s.push(0L);\n   \
    \   break;\n    case ' ':\n      if(s.top() == 0) \n      {\n        return long_array(0,\
    \ 0L);\n      }\n      \n      s.pop();\n      break;\n    default:\n      s.push(1L);\n\
    \      break;\n    }\n  }", "{\n    string[] nested_paren = paren_string.Split(new[]\
    \ { ' ' }, System.StringSplitOptions.RemoveEmptyEntries);\n    long[] levels =\
    \ new long[nested_paren.Length];\n    long max_level = 0;\n    for (int i = 0;\
    \ i < nested_paren.Length; i++) {\n        string paren_string = nested_paren[i];\n\
    \        long level = paren_string.Length;\n        if (paren_string.Contains(\"\
    (\") && paren_string.Contains(\")\")) {\n            level++;\n        }\n   \
    \     if (level > max_level) {\n            max_level = level;\n        }\n  \
    \      levels[i] = level;\n    }\n    return levels;\n}\n</code>\n<|/ a tags=c#,algorithm,string\
    \ |>\n<| c |>\nJust a heads-up: this won't work on languages that have parentheses\
    \ other than those that are legal in code blocks, for example Python or C/C++.\
    \ Although they are still valid in string literals (and are unbalanced).\n<|/\
    \ c |>\n<| c |>\nIt won't work if the nested parentheses are balanced.\n<|/ c\
    \ |>\n<| c |>\n: Your sample input doesn't show balanced parentheses, but it does\
    \ show unbalanced parentheses, e.g. `\"()\"`. The solution in this answer gives\
    \ an answer for `\"\"` too (which you say is incorrect).\n<|/ c |>\n<| a dscore=5\
    \ |>\nHere's another approach. I've implemented it in JavaScript. As per your\
    \ example:\n<code>\nfunction countNestedParens(expression) {\n    var openParens\
    \ = new Array(expression.length);\n    var closeParens = new Array(expression.length);\n\
    \    for (var i = 0, len = expression.length; i < len; i++) {\n        var parenCount\
    \ = 0;\n        for (var j = i + 1; j < len; j++) {\n            if (expression[j]\
    \ == '(') {\n                parenCount++;\n            } else if (expression[j]\
    \ == ')') {\n                parenCount--;\n            }\n        }\n       \
    \ if (parenCount == 0) {\n            openParens[i] = 0;\n        } else {\n \
    \           openParens[i] = parenCount;\n        }\n    }\n    return openParens;\n\
    }\n</code>\n<|/ a tags=c#,algorithm,string |>\n<| c |>\nYeah, that would work\
    \ fine too. I'm not sure why I added the C# tag; I thought the question was language\
    \ agnostic. I'd probably just use Python, where you could just use `string.count(\"\
    (\")`. I also added the [tag:algorithm] tag to get all the answers I was looking\
    \ for.\n<|/ c |>\n<| c |>\nAh, but what about the case where the input has two\
    \ parentheses and no opening parentheses? You would have to add one more iteration\
    \ to ", "{\n    stack<string> paren_stack;\n    stack<int> nesting_levels;\n \
    \   string curr_str = \"\";\n    long nest_level;\n    long cur_nest = 0;", "{\n\
    \    string stripped = paren_string.trim();\n    if(stripped.length() == 0) \n\
    \        throw new Exception(\"No parens\");\n    long[] levels = new long[stripped.length()];",
  "{\n    string token_str = paren_string;\n    \n    int[] levels = { 0, 0, 0 };\n\
    \    int[] index = 0;\n    string last_group_open = \"(\";\n    string last_group_close\
    \ = \")\";\n    bool is_first_group = true;\n    bool is_last_group = true;\n\
    \    bool last_is_open = false;\n    bool is_last_group_close = false;\n    bool\
    \ is_last_group_open = false;\n    string last_group;\n    \n    for(int i = 0;\
    \ i < token_str.size(); ++i)\n    {\n        if(token_str[i] == '(')\n       \
    \ {\n            if(is_first_group) levels[0]++;\n            else\n         \
    \   {\n                levels[1]++;\n            }\n            is_first_group\
    \ = false;\n        }\n        else if(token_str[i] == ')')\n        {\n     \
    \       if(is_last_group)\n            {\n                if(levels[1] > levels[0])\n\
    \                {\n                    levels[2] += levels[1] - levels[0];\n\
    \                }\n                else\n                {\n                \
    \    levels[1]--;\n                }\n            }\n            is_last_group\
    \ = false;\n        }\n        else if(token_str[i] == '\"')\n        {\n    \
    \        if(is_last_group)\n            {\n                last_is_open = true;\n\
    \                is_last_group_open = false;\n                is_last_group_close\
    \ = false;\n            }\n        }\n        else if(token_str[i] == '\"')\n\
    \        {\n            if(is_last_group)\n            {\n                last_is_open\
    \ = false;\n                is_last_group_open = true;\n                is_last_group_close\
    \ = false;\n            }\n        }\n        else if(token_str[i] == '\\\\')\n\
    \        {\n            token_str[i - 1] = '\\0';\n            token_str.insert(i,\
    \ token_str[i + 1]);\n            token_str.erase(i + 1, 1);\n        }\n    \
    \    else\n        {\n            if(last_is_open)\n            {\n          \
    \      last_is_open = false;\n                is_last_group_open = false;\n  \
    \          }\n        }\n    }\n    if(is_last_group)\n    {\n        if(levels[1]\
    \ > levels[0])\n        {\n            levels[2] += levels[1] - levels[0];\n \
    \       }\n        else\n        {\n            levels[1]--;\n        }\n    }\n\
    \    string result[] = new string[levels[2] + 1];\n    \n    for(int i = 0; i\
    \ < result.length; ++i)\n    {\n        result[i] = \"\";\n    }\n    \n    for(int\
    \ i = 0; i < token_str.size(); ++i)\n    {\n        if(token_str[i] == '(')\n\
    \        {\n            if(!is_first_group) index[levels[0]] = i;\n          \
    \  levels[0]++;\n        }\n        else if(token_str[i] == ')')\n        {\n\
    \            if(!is_last_group) index[levels[1]] = i;\n            levels[1]--;\n\
    \        }\n        else if(token_str[i] == '\"')\n        {\n            if(!is_last_",
  "{\n    Stack<long> paren_stack = new Stack<long>();\n    string input_string =\
    \ paren_string;\n    bool last_bracket = true;\n    long nesting_level = 0;\n\
    \    bool at_least_one_open = false;\n    long level = 0;\n    long[] levels =\
    \ new long[64];", "{\n    stack<pair<string, long>> paren_stack;\n    vector<pair<string,\
    \ long>> paren_groups;\n    string group_str;\n    long cur_level = 0;\n    long\
    \ cur_group = 0;\n    for(auto c : paren_string)\n    {\n        if(c != ' ' &&\
    \ c != '(' && c != ')')\n        {\n            group_str += c;\n        }\n \
    \       else\n        {\n            group_str = group_str.substr(0, group_str.size()-1);\n\
    \            cur_level = cur_level + 1;\n            paren_stack.emplace_back(group_str,\
    \ cur_level);\n            paren_groups.emplace_back(group_str, cur_group);\n\
    \            group_str = \"\";\n        }\n        if(c != ')')\n        {\n \
    \           cur_level = paren_stack.top().second;\n            cur_group = paren_stack.top().first\
    \ + (cur_group + 1);\n        }\n        else\n        {\n            paren_stack.pop();\n\
    \            paren_groups.pop();\n        }\n    }\n    \n    if(group_str.empty())\n\
    \    {\n        return paren_groups.size();\n    }\n    return -1;\n}\n</code>\n\
    <|/ a tags=string,c++,parsing |>\n<| c |>\nNice algorithm. Elegant and fast. Nicely\
    \ done.\n<|/ c |>\n<| a tags=string,c++,parsing |>\nA very simple recursive solution:\n\
    <code>\n#include <iostream>\n#include <string>\n#include <vector>", "{\n    int\
    \ paren_index = 0;\n    int paren_depth = 1;\n    bool parentheses_open = true;\n\
    \    bool opening_parenthese_closed = false;", "{\n    \n    /*\n    Example of\
    \ input:\n    (()()) ((())) () ((())()())\n    \n    Output will be a long array\
    \ containing the deepest level of nesting of each parentheses\n    \n    */\n\
    \    \n    char[] chars = paren_string.toCharArray();\n    long deepest_levels[]\
    \ = new long[chars.length];\n    deepest_levels[] = new long[chars.length];\n\
    \    long level = 0;\n    for (int i = 0; i < chars.length; i++) {\n        //\
    \ if parentheses match, increment level\n        if (chars[i] == '(') {\n    \
    \        deepest_levels[level]++;\n        }\n        // if parentheses match,\
    \ decrement level\n        else if (chars[i] == ')') {\n            deepest_levels[level]--;\n\
    \        }\n        // otherwise, level is 0\n        else {\n            level\
    \ = 0;\n        }\n    }\n    return deepest_levels;\n}\n</code>\n<|/ a |>\n<|\
    \ a |>\nI implemented a similar solution in Python.\n<code>\ndef parens_level(s):\n\
    \    level = 0\n    levels = [level]\n    \n    chars = s.toCharArray()\n    \n\
    \    for c in chars:\n        \n        if c == '(':\n            level += 1\n\
    \            levels.append(level)\n        \n        elif c == ')':\n        \
    \    level -= 1\n        \n        elif c == '\\n':\n            level = 0\n \
    \           levels.append(level)\n    \n    return levels", "{\n    long n = paren_string.length();\n\
    \    long[] result = new long[n];\n    stack<int> parens;\n    \n    for(int i\
    \ = 0; i < n; i++) {\n        char c = paren_string[i];\n        \n        //\
    \ Handle parentheses inside parentheses, e.g. ()()\n        if(parens.empty()\
    \ || c == '(' || c == ')') {\n            if(parens.empty()) {\n             \
    \   result[i] = 0;\n            } else {\n                long level = parens.top();\n\
    \                if(parens.empty() && c != '(' && c != ')') {\n              \
    \      result[i] = level;\n                } else {\n                    result[i]\
    \ = level + 1;\n                }\n            }\n            \n        // Handle\
    \ nested parentheses, e.g. ()()()\n        } else if(c != '(' && c != ')') {\n\
    \            parens.push(c);\n            \n        // Handle the case where a\
    \ bracket is closed without an opening one, e.g. ())\n        } else {\n     \
    \       char p = parens.top();\n            parens.pop();\n            result[i]\
    \ = parens.top();\n        }\n    }\n    \n    return result;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nthank you so much, this works perfectly.\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's a recursive approach to counting parentheses.\n<code>\npublic static\
    \ int countOpenParens(String str) {\n    return countOpenParens(str, 0);\n}",
  "{\n\tlong num_paren_group = 0;\n\tlong num_open = 0;\n\tlong num_closed = 0;\n\t\
    stringstream ss(paren_string);\n\tstring cur_paren;\n\twhile(ss.peek() != EOF)\n\
    \t{\n\t\tss >> cur_paren;\n\t\tswitch(cur_paren)\n\t\t{\n\t\t\tcase \")\":\n\t\
    \t\t\tnum_closed += 1;\n\t\t\t\tbreak;\n\t\t\tcase \"(\":\n\t\t\t\tnum_open +=\
    \ 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tif(num_paren_group\
    \ > num_open)\n\t\t{\n\t\t\tnum_paren_group -= num_open;\n\t\t}\n\t}\n\t\n\tlong\
    \ max_level = num_paren_group;\n\tlong levels[max_level];\n\tlong max_level_pos\
    \ = -1;\n\t\n\tlong i;\n\tfor(i = 0; i < num_paren_group; i++)\n\t{\n\t\tlevels[i]\
    \ = num_open;\n\t\tmax_level_pos = i;\n\t}\n\tfor(i = 0; i < num_paren_group;\
    \ i++)\n\t{\n\t\tswitch(cur_paren)\n\t\t{\n\t\t\tcase \")\":\n\t\t\t\tnum_closed\
    \ -= 1;\n\t\t\t\tbreak;\n\t\t\tcase \"(\":\n\t\t\t\tnum_open -= 1;\n\t\t\t\tbreak;\n\
    \t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tif(num_paren_group > num_open)\n\t\t\
    {\n\t\t\tmax_level = num_paren_group;\n\t\t}\n\t\telse if(num_paren_group < num_open)\n\
    \t\t{\n\t\t\tmax_level = num_open;\n\t\t}\n\t\tif(levels[i] > levels[max_level_pos])\n\
    \t\t{\n\t\t\tmax_level_pos = i;\n\t\t}\n\t\telse if(levels[i] > levels[max_level])\n\
    \t\t{\n\t\t\tmax_level = i;\n\t\t}\n\t}\n\t\n\tlong[] result = new long[max_level];\n\
    \t\n\tint pos = 0;\n\t\n\tfor(i = 0; i < max_level; i++)\n\t{\n\t\tpos += levels[i];\n\
    \t\tresult[pos] = i;\n\t}\n\t\n\treturn result;\n}", "{\n    char[] open_parens\
    \ = {')'};\n    long[] max_levels = new long[1];\n    char[] open_chars = {'('};\n\
    \    char[] close_chars = {')'};", "{\n\tassert(paren_string.length() == paren_string.Length()\
    \ && paren_string.Length() > 0);\n\t\n\tlong[] levels = new long[paren_string.Length()];\n\
    \t\n\tint current_level = 0;\n\tbool first_item = true;\n\tchar last_item_char\
    \ = paren_string[0];\n\tstring last_item = paren_string;\n\t\n\tforeach (char\
    \ c in paren_string.Substring(1))\n\t{\n\t\tassert(c == '(' || c == ')');\n\t\t\
    \n\t\tif (c == ')')\n\t\t{\n\t\t\tassert(current_level > 0);\n\t\t\t\n\t\t\t--current_level;\n\
    \t\t}\n\t\telse if (c == '(')\n\t\t{\n\t\t\tif (current_level == 0)\n\t\t\t{\n\
    \t\t\t\tlevels[level_index] = current_level;\n\t\t\t\tcurrent_level++;\n\t\t\t\
    }\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurrent_level++;\n\t\t\t}\n\t\t}\n\t\telse if\
    \ (last_item_char != c)\n\t\t{\n\t\t\tif (last_item.Length > 0)\n\t\t\t{\n\t\t\
    \t\tlevels[level_index] = current_level;\n\t\t\t}\n\t\t\t\n\t\t\tcurrent_level\
    \ = 0;\n\t\t\tfirst_item = false;\n\t\t\tlast_item_char = c;\n\t\t\tlast_item\
    \ = c;\n\t\t}\n\t}\n\t\n\tif (last_item.Length > 0)\n\t{\n\t\tlevels[level_index]\
    \ = current_level;\n\t}\n\t\n\treturn levels;\n}", "{\n    long[] result = new\
    \ long[paren_string.length()];\n    long[] levels = new long[paren_string.length()];\n\
    \    levels[0] = 1;\n    int pos = 1;\n    int level = 1;\n    string chars =\
    \ paren_string.substr(0, paren_string.length()-1);", "{\n    int level = 0; \n\
    \    int depth = 0; \n    long nested_paren_levels[]; \n    bool seen_paren =\
    \ true; ", "{\n    auto paren_pairs = paren_string.split(\"( )\");\n    long[]\
    \ levels = new long[paren_pairs.size()];\n    int index = 0;\n    for (auto pair\
    \ : paren_pairs) {\n        string group_str = pair;\n        int current_level\
    \ = 0;\n        bool is_last_pair = false;\n        for (index; index < (index+group_str.size());\
    \ ++index) {\n            if (group_str[index] == '(') ++current_level;\n    \
    \        else if (group_str[index] == ')') --current_level;\n            if (current_level\
    \ == 0 && is_last_pair) break;\n            if (current_level == 0 && !is_last_pair)\
    \ break;\n        }\n        if (current_level == 0) continue;\n        levels[index]\
    \ = current_level;\n        is_last_pair = index + group_str.size() == paren_pairs.size()\
    \ - 1;\n    }\n    return levels;\n}", "{\n    long max_level = 0;\n    long level\
    \ = 0;\n    long idx = 0;\n    string temp = \"\";\n    string[] levels = new\
    \ string[paren_string.size()];\n    levels[paren_string.size()] = \"\";", "{\n\
    \    char[] paren_chars = paren_string.toCharArray();\n    \n    int paren_count\
    \ = 0;\n    int paren_level = 0;\n    int paren_pos = 0;\n    long nest_level\
    \ = 0;", "{\n    // Parse input string\n    string token;\n    Stack<string> stack\
    \ = new Stack<string>();\n    long level = 0;\n    int token_count = 0;", "{\n\
    \    stack<long> paren_levels;\n    stack<long> paren_numbers;", "{\n    int i;\n\
    \    long max_level = 0;\n    long cur_level = 0;\n    int[] group = new int[paren_string.Length()];\n\
    \    for(i=0;i<paren_string.Length();i++)\n    {\n        group[i] = paren_string[i];\n\
    \        if(group[i]=='(')\n        {\n            cur_level++;\n            if(cur_level\
    \ > max_level)\n                max_level = cur_level;\n        }\n        else\
    \ if(group[i]==')')\n        {\n            cur_level--;\n        }\n    }\n \
    \   long[] levels = new long[max_level+1];\n    for(i=0;i<max_level+1;i++)\n \
    \   {\n        levels[i] = i;\n    }\n    levels[max_level] = paren_string.Length();\n\
    \    for(i=1;i<max_level;i++)\n    {\n        levels[i] += levels[i-1];\n    }\n\
    \    return levels;\n}", "{\n  Stack<long> paren_stack = new Stack<long>();\n\
    \  long cur = 0;", "{\n    if( paren_string.empty() )\n        return new[] {};\n\
    \    \n    int paren_len = paren_string.length();\n    long[] deepest_level =\
    \ new long[paren_len];\n    int deepest_level_index = 0;\n    int deepest_level_max\
    \ = 0;\n    for( int i = 1; i < paren_len; i++ ) {\n        string cur_char =\
    \ paren_string[i];\n        string prevChar = paren_string[i-1];\n        \n \
    \       //Check if last character is \")\"\n        if( cur_char == \"(\" || cur_char\
    \ == \"{\" || cur_char == \"[\" ) {\n            //If last character is \")\"\
    , move 1 level deeper\n            if( i == paren_len-1 ) deepest_level[deepest_level_index]\
    \ = 0;\n            else deepest_level[deepest_level_index]++;\n            deepest_level_max\
    \ = Math.max(deepest_level_max, deepest_level[deepest_level_index]);\n       \
    \     if( i == paren_len-1 ) deepest_level_index++;\n        }\n        else if(\
    \ cur_char == \")\" ) {\n            //If last character is \")\", move 1 level\
    \ deeper\n            if( i == paren_len-1 ) deepest_level[deepest_level_index]\
    \ = 0;\n            else deepest_level[deepest_level_index]--;\n            deepest_level_max\
    \ = Math.max(deepest_level_max, deepest_level[deepest_level_index]);\n       \
    \     if( i == paren_len-1 ) deepest_level_index++;\n        }\n        else if(\
    \ cur_char == \",\" ) {\n            //If last character is \",\", move 1 level\
    \ deeper\n            if( i == paren_len-1 ) deepest_level[deepest_level_index]\
    \ = 0;\n            else deepest_level[deepest_level_index]--;\n            deepest_level_max\
    \ = Math.max(deepest_level_max, deepest_level[deepest_level_index]);\n       \
    \     if( i == paren_len-1 ) deepest_level_index++;\n        }\n        else if(\
    \ cur_char == \"]\" ) {\n            //If last character is \"]\", move 1 level\
    \ deeper\n            if( i == paren_len-1 ) deepest_level[deepest_level_index]\
    \ = 0;\n            else deepest_level[deepest_level_index]--;\n            deepest_level_max\
    \ = Math.max(deepest_level_max, deepest_level[deepest_level_index]);\n       \
    \     if( i == paren_len-1 ) deepest_level_index++;\n        }\n        else if(\
    \ cur_char == \"}\" ) {\n            //If last character is \"}\", move 1 level\
    \ deeper\n            if( i == paren_len-1 ) ", "{\n\t\n\tlong[] level = new long[3];\n\
    \tlong current_level;\n\tstring paren_group;\n\t\n\t/*\n\t\tTo get the current\
    \ level of nesting of a group of parenthesis\n\t\twe need to go through all the\
    \ parenthesis string and count the parenthesis\n\t\tat each position. If number\
    \ of opening and closing parenthesis at that position\n\t\tis equal to opening\
    \ and closing parenthesis counter, increment level by one.\n\t\t\n\t\tFor example:\n\
    \t\t\n\t\t(\"()\") has maximum two level of nesting while (\"()(\") has three.\n\
    \t\t\n\t\tAlso we have to consider that if the last parenthesis is closing parenthesis\n\
    \t\twe should add 1 to level to show that we're at deepest level.\n\t\t\n\t\t\
    So, the steps are as follows:\n\t\t\n\t\t1) We need to go through all string and\
    \ count opening and closing parenthesis in each position.\n\t\t2) For each position,\
    \ if we have two equal opening and closing parenthesis, increment level by one\n\
    \t\t3) If last position is closing parenthesis, add 1 to level\n\t\t4) If last\
    \ position is not closing parenthesis, add 2 to level\n\t\t\n\t\tSo, at first\
    \ we initialize level and current_level to 0 and 1\n\t\t\n\t\tFor example at position\
    \ 3, level will be [2,1,1]\n\t\t\n\t\tAfter first step:\n\t\t\n\t\t   current_level\
    \ \t\tlevel = level\n\t\t   1\t\t\t\t\t\t[2L, 1L, 1L]\n\t\t   2\t\t\t\t\t\t[2L,\
    \ 1L, 2L]\n\t\t   3\t\t\t\t\t\t[3L, 1L, 2L]\n\t\t   4\t\t\t\t\t\t[3L, 1L, 3L]\n\
    \t\t   5\t\t\t\t\t\t[4L, 1L, 3L]\n\t\t   6\t\t\t\t\t\t[4L, 1L, 4L]\n\t\t\n\t\t\
    We increment level by one for every opening parenthesis encountered.\n\t\tSo,\
    \ if there are 4 opening parenthesis at the beginning of the string, level will\
    \ be [2,4,4]\n\t\t\n\t\tAfter second step:\n\t\t\n\t\t   current_level \t\tlevel\
    \ = level\n\t\t   1\t\t\t\t\t\t[2L, 4L, 4L]\n\t\t   2\t\t\t\t\t\t[2L, 4L, 5L]\n\
    \t\t   3\t\t\t\t\t\t[3L, 4L, 5L]\n\t\t   4\t\t\t\t\t\t[3L, 4L, 6L]\n\t\t   5\t\
    \t\t\t\t\t[4L, 4L, 6L]\n\t\t\n\t\tWe increment level by two for every opening\
    \ parenthesis encountered.\n\t\tSo, if there are 7 opening parenthesis at the\
    \ beginning of the string, level will be [2,7,7]\n\t\t\n\t\tAfter third step:\n\
    \t\t\n\t\t   ", "{\n\tlong nested_level = 0;\n\tlong result = 0;\n\tstring::const_iterator\
    \ start_it = paren_string.begin();\n\tstring::const_iterator paren_it = paren_string.begin();\n\
    \tstring::const_iterator end_it = paren_string.end();\n\twhile(start_it != end_it\
    \ && paren_it != end_it) {\n\t\tchar c = *paren_it;\n\t\tif (c == '(') ++nested_level;\n\
    \t\telse if (c == ')') --nested_level;\n\t\telse if (nested_level == 0) result\
    \ = std.math.max(result, std.typecons.distance(start_it, paren_it));\n\t\t++paren_it;\n\
    \t}\n\treturn result;\n}", "{\n    string left_paren, right_paren, paren_level;\n\
    \    long level_array;\n    long parent_counter = 0;\n    size_t number_of_paren;\n\
    \    size_t paren_counter = 0;\n    long[] levels = new long[MAX_LEVEL];\n   \
    \ paren_level = \"\";\n    number_of_paren = 0;", "{\n    size_t paren_length\
    \ = 0;\n    size_t max_level = 0;\n    string paren_string1 = \"\";\n    string\
    \ paren_string2 = \"\";\n    \n    size_t start_pos = 0;\n    size_t end_pos =\
    \ 0;\n    \n    for(size_t i = 0; i < paren_string.length(); i+=1) \n    {\n \
    \       char c = paren_string[i];\n        \n        if(paren_length == 0) \n\
    \        {\n            if(paren_string1 == \"(\" && paren_string2 == \")\") \n\
    \            {\n                start_pos = i;\n                end_pos = i;\n\
    \            }\n        }\n        else if(paren_string1 == \"(\" && paren_string2\
    \ == \")\" && c == ')') \n        {\n            paren_length++;\n        }\n\
    \        else if(paren_string1 == \"(\" && c == ')') \n        {\n           \
    \ paren_length--;\n        }\n        else if(paren_string1 == \")\" && c == ')')\
    \ \n        {\n            paren_length++;\n            \n            if(paren_length\
    \ == 0) \n            {\n                max_level = i-(start_pos-1);\n      \
    \      }\n        }\n        else if(c == '(')\n        {\n            paren_string1\
    \ += c;\n        }\n        else\n        {\n            paren_string2 += c;\n\
    \        }\n    }\n    \n    assert(paren_string1.length() == 0 && paren_string2.length()\
    \ == 0);\n    \n    return long[max_level];\n}\n</code>\nTo test the above function,\
    \ you can use this function in the following way:\n<code>\nimport std.array;\n\
    import std.conv;\nimport std.digest;\nimport std.range;\nimport std.algorithm;\n\
    import std.algorithm;\nimport std.random;\nimport std.stdio;", "{\n    long[]\
    \ groups = paren_string.split(\" \");\n    long[] deepest_nesting = new long[groups.length];",
  "{\n    stack<int> parens;\n    int paren_depth;\n    paren_depth = 0;\n    parens.push();\n\
    \    int cur_level = 0;", "{\n\tlong[] levels = new long[paren_string.size()];\n\
    \tlong current_level = 0;\n\tfor(int i = 0; i < paren_string.size(); i++) {\n\t\
    \tchar c = paren_string[i];\n\t\tif(c == '(') {\n\t\t\tlevels[i] = current_level;\n\
    \t\t\tcurrent_level++;\n\t\t} else if(c == ')') {\n\t\t\tcurrent_level--;\n\t\t\
    } else if(c == ' ') {\n\t\t\tlevels[i] = current_level;\n\t\t}\n\t}\n\treturn\
    \ levels;\n}", "{\n    string paren_string_with_groups = paren_string;\n    string[]\
    \ group_tokens = paren_string_with_groups.Split(new[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);",
  "{\n    long num_open = 0, num_close = 0, num_open_brace = 0, num_close_brace =\
    \ 0;\n    string paren_substring;\n    vector<string> paren_groups;\n    vector<long>\
    \ nesting_level;\n    char open_brace, close_brace;\n    for(int i = 0; i < paren_string.length();\
    \ ++i) {\n        open_brace = paren_string[i];\n        close_brace = paren_string[paren_string.length()\
    \ - 1];\n        paren_substring = \"\";\n        paren_substring = paren_string.substr(0,\
    \ i);\n        paren_substring = paren_substring;\n        paren_substring = paren_substring;\n\
    \        paren_substring = paren_substring;\n        if(open_brace == '(')\n \
    \           ++num_open_brace;\n        if(open_brace == '{')\n            ++num_open;\n\
    \        if(open_brace == '[')\n            ++num_open;\n        if(close_brace\
    \ == ')')\n            ++num_close_brace;\n        if(close_brace == '}')\n  \
    \          ++num_close;\n        if(close_brace == ']')\n            ++num_close;\n\
    \        if(open_brace == '{' && close_brace == '}')\n            ++num_close;\n\
    \        if(open_brace == '{' && close_brace == '[')\n            ++num_open;\n\
    \        if(open_brace == '(' && close_brace == ')')\n            ++num_close;\n\
    \        if(open_brace == '(' && close_brace == ']')\n            ++num_open;\n\
    \        if(open_brace == '[' && close_brace == ']')\n            ++num_open;\n\
    \        if(num_open < num_close && num_open < num_open_brace && num_open < num_close_brace)\
    \ {\n            nesting_level.push_back(num_close);\n            paren_groups.push_back(paren_substring);\n\
    \            paren_groups[paren_groups.size() - 1] += (char)open_brace;\n    \
    \    }\n    }\n    return nesting_level;\n}\n/*\n Input to this function is a\
    \ string represented nested parentheses separated by spaces.\n    For each of\
    \ the group, output the maximum level of nesting.\n    E.g. \"(()) has maximum\
    \ two levels of nesting while ((())) has three.", "{\n    string[] parens = paren_string.Split(\"\
    \ \");\n    long[] levels = new long[parens.Length];\n    long level = 0;\n  \
    \  bool inQuotes = false; // used to determine if we are inside a set of quotes\n\
    \    long index = 0;\n    long index2 = 0;\n    long index3 = 0;\n    \n    foreach(string\
    \ paren in parens)\n    {\n        if (paren == \"(\" || paren == \")\")\n   \
    \     {\n            level++;\n        }\n        else if (paren == \"[\" || paren\
    \ == \"]\")\n        {\n            levels[index2] = level;\n            index2++;\n\
    \        }\n        else if (paren == \"{\" || paren == \"}\")\n        {\n  \
    \          levels[index3] = level;\n            index3++;\n        }\n       \
    \ else if (paren == '\\'' && inQuotes == false)\n        {\n            inQuotes\
    \ = true;\n        }\n        else if (paren == '\\'' && inQuotes == true)\n \
    \       {\n            inQuotes = false;\n        }\n        else\n        {\n\
    \            throw new NotSupportedException(\"This is not a valid parenthesis\
    \ string: \" + paren);\n        }\n    }\n    \n    foreach(string paren in parens)\n\
    \    {\n        if (paren == \"(\" || paren == \")\")\n        {\n           \
    \ level--;\n        }\n        else if (paren == \"[\" || paren == \"]\")\n  \
    \      {\n            levels[index2] = level;\n            index2--;\n       \
    \ }\n        else if (paren == \"{\" || paren == \"}\")\n        {\n         \
    \   levels[index3] = level;\n            index3--;\n        }\n        else if\
    \ (paren == '\\'' && inQuotes == false)\n        {\n            inQuotes = true;\n\
    \        }\n        else if (paren == '\\'' && inQuotes == true)\n        {\n\
    \            inQuotes = false;\n        }\n        else\n        {\n         \
    \   throw new NotSupportedException(\"This is not a valid parenthesis string:\
    \ \" + paren);\n        }\n    }\n    return levels;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nthanks alot. i've had a look at the source code and i'll try to\
    \ understand it.\n<|/ c |>\n<| c |>\nhow would the c# function look like?\n<|/\
    \ c |>\n<| c |>\n: You would just copy the code into your program, changing `string`\
    \ into `char[]`, and adding a `using System;` at the top.\n<|/ c |>\n<| c |>\n\
    : You would probably want to write a test program that actually tests all the\
    \ corner cases, rather than just throwing an `UnsupportedException`.  That would\
    \ let you prove to yourself that your code works.  That would be a good learning\
    \ experience.  You'd also want to add some code to verify that the parentheses\
    \ work properly with expression", "{\n\tstring[] group_stack = new string[5];\n\
    \tlong[] paren_groups = new long[4];\n\tlong paren_level;\n\tint group_counter\
    \ = 0;\n\tint i;\n\tfor(i = 0; i < paren_string.Length; i++)\n\t{\n\t\tswitch\
    \ (paren_string[i])\n\t\t{\n\t\t\tcase ')':\n\t\t\t{\n\t\t\t\tgroup_counter--;\n\
    \t\t\t\tif (group_counter == 0)\n\t\t\t\t{\n\t\t\t\t\tgroup_level++;\n\t\t\t\t\
    }\n\t\t\t\tgroup_stack[group_level] = group_counter;\n\t\t\t\tgroup_stack[group_level+1]\
    \ = group_stack[group_level];\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t\
    {\n\t\t\t\tgroup_counter++;\n\t\t\t\tgroup_level++;\n\t\t\t\tgroup_stack[group_level]\
    \ = group_counter;\n\t\t\t\tgroup_stack[group_level+1] = group_stack[group_level];\n\
    \t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tgroup_level = 0;\n\tparen_level = 0;\n\t\
    for(i = 0; i < paren_string.Length; i++)\n\t{\n\t\tswitch (paren_string[i])\n\t\
    \t{\n\t\t\tcase ')':\n\t\t\t{\n\t\t\t\tparen_level--;\n\t\t\t\tif (paren_level\
    \ == -1)\n\t\t\t\t{\n\t\t\t\t\tparen_level--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\
    \t\t\tcase '(':\n\t\t\t{\n\t\t\t\tparen_level++;\n\t\t\t}\n\t\t\tbreak;\n\t\t\
    }\n\t}\n\tparen_level = 0;\n\tfor(i = 0; i < paren_string.Length; i++)\n\t{\n\t\
    \tswitch (paren_string[i])\n\t\t{\n\t\t\tcase ')':\n\t\t\t{\n\t\t\t\tparen_level--;\n\
    \t\t\t\tif (paren_level == -1)\n\t\t\t\t{\n\t\t\t\t\tparen_level--;\n\t\t\t\t\
    }\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase '(':\n\t\t\t{\n\t\t\t\tparen_level++;\n\t\
    \t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\tif (paren_groups[i]\
    \ != 0)\n\t\t{\n\t\t\tparen_groups[i] = paren_level;\n\t\t}\n\t}\n\treturn paren_groups;\n\
    }", "{\n    int level = 0;\n    Stack<long[]> stack = new Stack<long[]>();\n \
    \   for(int i = 0; i < paren_string.length(); i++)\n    {\n        char c = paren_string[i];\n\
    \        if(c == '(')\n        {\n            level++;\n        }\n        else\
    \ if(c == ')')\n        {\n            level--;\n        }\n        else if(level\
    \ > 0)\n        {\n            long[] stack_tmp = new long[] {i, level};\n   \
    \         while(level > 0)\n            {\n                stack.push(stack_tmp);\n\
    \                stack_tmp = stack.pop();\n                level--;\n        \
    \    }\n        }\n    }\n    long[] result = new long[stack.size()];\n    for(int\
    \ i = 0; i < result.length; i++)\n    {\n        result[i] = stack.pop();\n  \
    \  }\n    return result;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,string,regex,c#\
    \ |>\n<| c |>\nCan you explain why you think this would solve the problem described\
    \ in the question?\n<|/ c |>\n<| c |>\nI disagree with the \"not working\" part.\
    \ OP stated that the code works when he uses `@\"\\(([^()]+)\\)\";`. That means\
    \ the regexp will match the whole string. `parse_nested_parens()` is an adaptation\
    \ of https://stackoverflow.com/a/52564413/661786 which works in the same way but\
    \ is slightly different in some cases. He stated that OP is trying to understand\
    \ his code and asked for a regex that matches that same string. So I am just pointing\
    \ out that his solution doesn't work because the regexp he is using doesn't match\
    \ the entire string.\n<|/ c |>\n<| c |>\nNo, I think you're misinterpreting what\
    \ OP wants to do. He states that his method works with `\"((()())())\"` but fails\
    \ with `\"(()())\"`. He also states that his method \"doesn't work\", but his\
    \ code still produces a result of 3L, which I believe is the correct result. OP\
    \ says \"I need a regex that can match \"((()())())\" but only when \"(()())\"\
    \ is in the string\". He did not state that he only wanted it to match `((())`\
    \ but not `()`. To me, that's what OP wants to do.\n<|/ c |>\n<| c |>\n\"I need\
    \ a regex that can match \"((()())())\" but only when \"(()())\" is in the string\"\
    \ I thought OP was saying that he only wanted to match `((())` but not `()`. I\
    \ agree with you that OP", "{\n    int paren_start_index = 0;\n    int paren_end_index\
    \ = 0;\n    int paren_level = 0;\n    int previous_paren_level = 0;", "{\n\tstring[]\
    \ parens = paren_string.split(\" \");\n\tlong[] out = new long[parens.length];\n\
    \tlong max_level = 0;", "{\n    map<string, vector<string>> parens_to_level;\n\
    \    vector<string> parens;\n    stringstream ss(paren_string);\n    string paren;\n\
    \    while (getline(ss, paren, ' '))\n    {\n        if (paren.empty())\n    \
    \        continue;\n        parens.push_back(paren);\n        string current_level\
    \ = \"\";\n        for (string::iterator i = paren.begin(); i < paren.end(); ++i)\n\
    \        {\n            if (*i == '(')\n                current_level = current_level\
    \ + \"L\";\n            else if (*i == ')')\n            {\n                string\
    \ level_str = current_level.substr(0, current_level.size()-1);\n             \
    \   parens_to_level.insert(pair<string, vector<string> >(*i, level_str));\n  \
    \              current_level = level_str;\n            }\n        }\n    }\n \
    \   long max_level = 0;\n    long* level_array = new long[parens.size()];\n  \
    \  for (int i = 0; i < parens.size(); ++i)\n    {\n        string current_level\
    \ = parens_to_level.at(parens[i]);\n        level_array[i] = atoi(current_level.c_str());\n\
    \        if (level_array[i] > max_level)\n            max_level = level_array[i];\n\
    \    }\n    delete[] level_array;\n    return max_level;\n}", "{\n\tif (paren_string.length()\
    \ <= 0)\n\t{\n\t\tthrow new ArgumentException(\"Invalid paren string\");\n\t}\n\
    \tstack<int> paren_stack;\n\tlong[] max_levels_of_nesting = new long[paren_string.length()];\n\
    \tint curr_level = 0;\n\tfor (auto i = 0; i < paren_string.length(); i++)\n\t\
    {\n\t\tchar c = paren_string[i];\n\t\tswitch (c)\n\t\t{\n\t\t\tcase ')':\n\t\t\
    \t\t{\n\t\t\t\t\t--curr_level;\n\t\t\t\t\tif (curr_level == 0)\n\t\t\t\t\t{\n\t\
    \t\t\t\t\tparen_stack.push(curr_level);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\
    \t\t\tcase '(':\n\t\t\t\t{\n\t\t\t\t\t++curr_level;\n\t\t\t\t\tif (curr_level\
    \ == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tparen_stack.push(curr_level);\n\t\t\t\t\t}\n\
    \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\t\t{\n\t\t\
    \t\t\tint paren_nesting = paren_stack.top();\n\t\t\t\t\tif (paren_nesting > curr_level)\n\
    \t\t\t\t\t{\n\t\t\t\t\t\tmax_levels_of_nesting[i] = paren_nesting;\n\t\t\t\t\t\
    }\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmax_levels_of_nesting[i]\
    \ = curr_level;\n\t\t}\n\t}\n\treturn max_levels_of_nesting;\n}", "{\n    if(paren_string.length()\
    \ == 0)\n        return long.ZERO;\n    \n    long[] levels = long.ZERO;\n   \
    \ levels[0] = paren_string.length() - 1;\n    \n    int current = 0;\n    bool\
    \ has_close_brace = paren_string.charAt(current) == '(';\n    int close_brace_level\
    \ = paren_string.length() - 1;\n    bool has_open_brace = paren_string.charAt(current)\
    \ == ')';\n    int open_brace_level = 1;\n    int open_open_level = 1;\n    \n\
    \    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(has_close_brace)\n\
    \        {\n            open_brace_level--;\n            if(open_brace_level ==\
    \ 0)\n            {\n                levels[current] = close_brace_level;\n  \
    \              has_close_brace = false;\n                current++;\n        \
    \    }\n        }\n        else if(has_open_brace)\n        {\n            close_brace_level--;\n\
    \            if(close_brace_level == 0)\n            {\n                levels[current]\
    \ = open_brace_level;\n                has_open_brace = false;\n             \
    \   current++;\n            }\n        }\n        else if(paren_string.charAt(i)\
    \ == ')')\n        {\n            open_open_level--;\n            if(open_open_level\
    \ == 0)\n            {\n                levels[current] = open_open_level;\n \
    \               has_open_brace = true;\n                current++;\n         \
    \   }\n        }\n        else if(paren_string.charAt(i) == '(')\n        {\n\
    \            open_open_level++;\n            if(open_open_level == 0)\n      \
    \      {\n                levels[current] = open_open_level;\n               \
    \ has_close_brace = true;\n                current++;\n            }\n       \
    \ }\n    }", "{\n\tlong[] result = new long[paren_string.length()];\n\tint i,\
    \ j, level, paren_level;\n\tchar paren_char;\n\tstring temp_str;\n\t\n\tint count\
    \ = 0;\n\tbool parens_left = false;\n\tbool brackets_left = false;\n\t\n\tfor\
    \ (i=0; i<paren_string.length(); i++) {\n\t\tparen_char = paren_string[i];\n\t\
    \tparens_left = false;\n\t\tbrackets_left = false;\n\t\t\n\t\t// Paren level\n\
    \t\tif (paren_char == '(') parens_left = true;\n\t\tif (paren_char == ')') parens_left\
    \ = false;\n\t\t\n\t\t// Bracket level\n\t\tif (paren_char == '[') brackets_left\
    \ = true;\n\t\tif (paren_char == ']') brackets_left = false;\n\t\t\n\t\t// Handle\
    \ the parens\n\t\tif (parens_left && brackets_left) {\n\t\t\tresult[count] = parens_left;\n\
    \t\t\tparens_left = false;\n\t\t\tbrackets_left = false;\n\t\t\tcount++;\n\t\t\
    }\n\t\t\n\t\t// Handle brackets\n\t\tif (parens_left && !brackets_left) {\n\t\t\
    \tresult[count] = brackets_left;\n\t\t\tparens_left = false;\n\t\t\tbrackets_left\
    \ = false;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\t// Handle brackets\n\t\tif (!parens_left\
    \ && brackets_left) {\n\t\t\tresult[count] = brackets_left;\n\t\t\tparens_left\
    \ = false;\n\t\t\tbrackets_left = false;\n\t\t\tcount++;\n\t\t}\n\t\t\n\t}\n\t\
    return result;\n}\n/*\n    Function to compute the maximum depth of the parenthesis\
    \ and nested brackets.\n    \n    input (string) paren_string:\n        a string\
    \ represented multiple groups of parentheses separated by spaces.\n        \n\
    \    output (int) max_level:\n        Maximum level of nesting in the string.\n\
    */", "{\n\tassert(paren_string.length() != 0);", "{\n    long[] max_level;\n \
    \   string parens_pattern = \"\\\\((.+?)\\\\)\";\n    long paren_nesting_depth\
    \ = 0;", "{\n\tif (paren_string.length() == 0)\n\t\treturn long.empty;\n\t\n\t\
    long[] level = new long[paren_string.length()];\n\tlong max_level = 0;\n\t\n\t\
    for (int i = 0; i < level.length; i++)\n\t\tlevel[i] = 0;\n\t\n\tint open = 0;\n\
    \tint close = 0;\n\t\n\tfor (int i = 0; i < paren_string.length(); i++)\n\t{\n\
    \t\tchar c = paren_string[i];\n\t\t\n\t\tif (c == '(')\n\t\t{\n\t\t\topen++;\n\
    \t\t}\n\t\telse if (c == ')')\n\t\t{\n\t\t\tclose++;\n\t\t}\n\t\telse if (c ==\
    \ '\\0')\n\t\t\tbreak;\n\t\t\n\t\tlevel[i] = max(level[i], open);\n\t\tlevel[i]\
    \ = min(level[i], close);\n\t\t\n\t\tmax_level = max(max_level, level[i]);\n\t\
    }\n\t\n\treturn level;\n}\n/*\n Input to this function is a string represented\
    \ multiple groups for nested parentheses separated by spaces.\n    For each of\
    \ the group, output the deepest level of nesting of parentheses.\n    E.g. (()())\
    \ has maximum two levels of nesting while ((())) has three.", "{\n    // Find\
    \ parenthesis starting locations\n    int[] parens_starts = paren_string.find_parens_starts();\n\
    \    // Find starting locations of each parenthesis\n    int[] paren_starts =\
    \ find_paren_starts(parens_starts);\n    // Count depth of nesting of each parenthesis\n\
    \    long[] depths = count_nested_depths(paren_starts);\n    return depths;\n}",
  "{\n    long[] levels = { 0 };\n    bool is_first = true;\n    foreach (char c in\
    \ paren_string) {\n        if (c == '(') {\n            if (is_first) {\n    \
    \            levels[0]++;\n                is_first = false;\n            } else\
    \ {\n                levels[1]++;\n            }\n        } else if (c == ')')\
    \ {\n            if (is_first) {\n                levels[0]--;\n            }\
    \ else {\n                levels[1]--;\n            }\n        } else {\n    \
    \        assert(c == ' ');\n        }\n    }\n    return levels;\n}", "{\n   \
    \ if( !paren_string.endsWith( \")\" ) )\n        paren_string = paren_string +\
    \ \")\";\n    string opening_paren = paren_string.substr(0, paren_string.find_first_of(\"\
    ()\"));\n    string closing_paren = paren_string.substr(paren_string.find_last_of(\"\
    ()\") + 1, paren_string.length());", "{\n    long[] res = new long[paren_string.length()];\n\
    \    int cnt = 0;\n    \n    for(int i = 0; i < paren_string.length(); i++)\n\
    \    {\n        if(paren_string[i] == '(')\n        {\n            if(paren_string[i\
    \ + 1] == '(')\n            {\n                res[cnt++] = 2L;\n            }\n\
    \            else\n            {\n                res[cnt++] = 1L;\n         \
    \   }\n        }\n        else if(paren_string[i] == ')')\n        {\n       \
    \     if(paren_string[i + 1] == '(')\n            {\n                res[cnt++]\
    \ = 3;\n            }\n            else\n            {\n                res[cnt++]\
    \ = 2L;\n            }\n        }\n        else\n        {\n            res[cnt++]\
    \ = paren_string[i] + 1;\n        }\n    }\n    return res;\n}\n</code>\nThe above\
    \ function returns the result in a long[].\nTo test it:\n<code>\nimport std.string;\n\
    import std.array;\nimport std.stdio;\nimport std.typecons;\nimport std.math;\n\
    import std.conv;\n/*\n Input to this function is a string represented multiple\
    \ groups for nested parentheses separated by spaces.\n    For each of the group,\
    \ output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum\
    \ two levels of nesting while ((())) has three.", "{\n    string[] paren_groups\
    \ = paren_string.split(\" \");\n    long[] result = new long[paren_groups.length];\n\
    \    long max_level = 1;\n    for(int i=0; i < paren_groups.length; i++) {\n \
    \       // Remove first parenthesis (if present)\n        if(paren_groups[i].length()\
    \ > 0) {\n            paren_groups[i] = paren_groups[i].substring(1);\n      \
    \  }", "{\n    unordered_map<char, unordered_map<int, long>> paren_nest;\n   \
    \ int level = 0, level_max_nest = 0;\n    int opening_parens = 0, open_parens_level\
    \ = 0;\n    string current_level = paren_string;\n    unordered_map<char, int>\
    \ char_count;\n    unordered_map<int, long> nesting_counts;", "{\n    // TODO:\
    \ rewrite this to use stacks instead\n    string str = paren_string;\n    stack<string>\
    \ levelStack;\n    string curLevel;\n    string curStack = \"\";\n    long maxLevel\
    \ = 0;", "{\n\tauto paren = paren_string.find_first_of(\"()\");\n\tlong number_of_open_brackets\
    \ = 0;\n\tlong maximum_number_of_open_brackets = 0;\n\tlong paren_level = 0;\n\
    \tbool first_time_encountering_parens = false;", "{\n  long level = 0;\n  stack<string>\
    \ parenStack = new stack<string>();\n  stack<string> levelStack = new stack<string>();",
  "{\n    var max_level = 0;\n    var max_level_paren = 0;\n    long level = 0;\n\
    \    long paren = 0;\n    long levels_left_to_right = 0;\n    bool found_paren\
    \ = false;\n    bool found_left_paren = false;\n    bool found_right_paren = false;\n\
    \    for(int i=0; i<paren_string.length; ++i)\n    {\n        if (paren_string[i]\
    \ == '(')\n        {\n            if (level > max_level)\n            {\n    \
    \            max_level = level;\n                max_level_paren = paren;\n  \
    \          }\n            level++;\n            paren = 0;\n            found_paren\
    \ = true;\n        }\n        else if (paren_string[i] == ')')\n        {\n  \
    \          if (level == max_level)\n            {\n                levels_left_to_right\
    \ = paren;\n            }\n            level--;\n            found_paren = true;\n\
    \        }\n        else if (paren_string[i] == '(')\n        {\n            paren++;\n\
    \            found_left_paren = true;\n        }\n        else if (paren_string[i]\
    \ == ')')\n        {\n            paren--;\n            found_right_paren = true;\n\
    \        }\n        else\n        {\n            error(\"parse_nested_parens\"\
    , 0, \"Unexpected character %c in the paren string \\\"%s\\\"\", paren_string[i],\
    \ paren_string.c_str());\n        }\n    }", "{\n  // TODO: Rewrite this to handle\
    \ empty paren string\n  long count = 0; // Level of nesting of a pair of parentheses\n\
    \  long index = 0;\n  stack<int> open_paren;\n  stack<string> paren_strings;",
  "{\n    if (paren_string == \"\" || paren_string.length() == 0)\n    {\n       \
    \ return null;\n    }\n    Stack<long> nested_depths = new Stack<long>();\n  \
    \  long[] results = new long[paren_string.Length];\n    int i = 0;\n    while\
    \ (i < paren_string.Length)\n    {\n        char c = paren_string[i];\n      \
    \  switch (c)\n        {\n            case '(':\n                nested_depths.push(i);\n\
    \                break;\n            case ')':\n                nested_depths.pop();\n\
    \                break;\n            default:\n                results[i] = nested_depths.top();\n\
    \                nested_depths.pop();\n                results[i + 1] = nested_depths.top();\n\
    \                nested_depths.pop();\n                break;\n        }\n   \
    \     i += 1;\n    }\n    return results;\n}\n// end of function parse_nested_parens",
  "{\n\t// Write your code here.\n    int paren = 0;\n    int bracket = 0;\n    int\
    \ depth = 0;\n    long[] output = new long[paren_string.length()];\n    bool stack[paren_string.length()];\n\
    \    for (int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n            stack[paren] = true;\n        else if(paren_string[i] ==\
    \ ')')\n            stack[paren] = false;\n        else\n            stack[paren]\
    \ = false;", "{\n    long[] levels = new long[paren_string.size()];", "{\n\tlong[]\
    \ paren_vals = new long[paren_string.Length];\n\t\n\tint level_of_nesting = 0;",
  "{\n    long max_count = 0;\n    long current_count = 1;\n    long last_count =\
    \ 1;\n    long max_level = 0;\n    long level = -1;\n    long deepest_level =\
    \ 0;", "{\n\tint opening = paren_string.find_first_of('(', 0);\n\tint closing\
    \ = paren_string.find_first_of(')', opening);\n\tif (closing == -1L) return null;\n\
    \tlong[] depths = new long[closing - opening + 1];", "{\n  std.typecons.ListNode\
    \ parens = std.typecons.ListNode.fromString(paren_string);\n  long[] result =\
    \ new long[parens.count / 2];\n  long depth = 1;\n  for(auto el : parens)\n  {\n\
    \    if(!el.isNode() || el.isLeaf())\n    {\n      depth++;\n      continue;\n\
    \    }\n    string sub_str = el.value.stringValue();\n    std.typecons.ListNode\
    \ sub_parens = std.typecons.ListNode.fromString(sub_str);\n    for(auto sub_el\
    \ : sub_parens)\n    {\n      string sub_sub_str = sub_el.value.stringValue();\n\
    \      std.typecons.ListNode sub_sub_parens = std.typecons.ListNode.fromString(sub_sub_str);\n\
    \      long sub_sub_depth = sub_sub_parens.count / 2;\n      if(depth > sub_sub_depth)\n\
    \      {\n        depth = sub_sub_depth;\n      }\n    }\n  }\n  return result;\n\
    }", "{\n    long[] result = new long[paren_string.length()];", "{\n    string\
    \ s = paren_string;\n    long n = s.length();\n    long[] levels = new long[n];\n\
    \    \n    long level = 0;\n    long current = 0;\n    long next = 0;\n    int\
    \ open_brackets = 0;\n    int close_brackets = 0;\n    \n    stack<long> brackets_stack\
    \ = new stack<long>();\n    \n    for(int i = 0; i < n; i++) {\n        if(s.charAt(i)\
    \ == '(') open_brackets++;\n        else if(s.charAt(i) == ')') close_brackets++;\n\
    \        \n        if(open_brackets > 0 && close_brackets == 0) {\n          \
    \  levels[next] = level;\n            brackets_stack.push(next);\n           \
    \ level++;\n            open_brackets = 0;\n            close_brackets = 0;\n\
    \            next++;\n        }\n        else if(open_brackets == 0 && close_brackets\
    \ > 0) {\n            current = brackets_stack.top();\n            levels[current]\
    \ = level;\n            brackets_stack.pop();\n            level--;\n        \
    \    open_brackets = 0;\n            close_brackets = 0;\n        }\n        else\
    \ if(open_brackets == 0 && close_brackets == 0) {\n            levels[next] =\
    \ level;\n            level++;\n            next++;\n            open_brackets\
    \ = 0;\n            close_brackets = 0;\n        }\n    }\n    \n    return levels;\n\
    }\n</code>\n<|/ a dscore=1 tags=regex,c# |>\n<| c |>\nI checked and your code\
    \ worked for most examples, but failed for some others. I posted a sample of input\
    \ and output.\n<|/ c |>\n<| c |>\nThanks a lot that seems to work perfectly. Could\
    \ you explain the regex though a bit please? I am relatively new to using regex\
    \ and my understanding is a bit rusty.\n<|/ c |>\n<| c |>\nAwesome! I appreciate\
    \ the explanation as well.\n<|/ c |>\n<| c |>\nYes. I appreciate that. Thanks\
    \ again for the help! I am learning regexes and your explanation made everything\
    \ much easier to understand.\n<|/ c |>\n<| a dscore=0 |>\nFor a Regex that does\
    \ NOT use the non-capturing groups (?:) this is more efficient than others posted\
    \ here.  \n<code>\nvar input = \"((() ((((()())))(()))()()))\";", "{\n\tlong[]\
    \ result = new long[paren_string.length()];", "{\n\tchar[] paren_chars = paren_string.toCharArray();\n\
    \tArrayList paren_levels = new ArrayList();\n\tlong paren_count = 1;\n\tfor (int\
    \ i = 0; i < paren_chars.length; i++) {\n\t\tif (paren_chars[i] == '(') \n\t\t\
    \tparen_levels.add(paren_count);\n\t\telse if (paren_chars[i] == ')') {\n\t\t\t\
    if (paren_levels.lastElement() > 0) {\n\t\t\t\tparen_levels.remove(paren_levels.lastElement()\
    \ - 1);\n\t\t\t\tparen_count += paren_levels.lastElement();\n\t\t\t}\n\t\t\telse\
    \ {\n\t\t\t\tparen_levels.add(paren_count);\n\t\t\t}\n\t\t}\n\t\telse if (paren_chars[i]\
    \ == ' ') {\n\t\t\tparen_count = 1;\n\t\t\tparen_levels.clear();\n\t\t}\n\t}\n\
    \treturn paren_levels.getRange(0, paren_levels.size());\n}\n</code>\n<|/ a dscore=4\
    \ tags=java,algorithm,recursion |>\n<| c |>\nIt's a nice recursive solution, but\
    \ it does not handle cases like `((((())))`, where the level of nested parentheses\
    \ is `2`.\n<|/ c |>\n<| c |>\nIndeed. The OP didn't specify what should happen\
    \ with the string. I just thought it would be helpful to give an answer that at\
    \ least somewhat works.\n<|/ c |>\n<| c |>\nThe question is tagged 'java' so I\
    \ believe it would be helpful to give a java answer.\n<|/ c |>\n<| c |>\nI've\
    \ updated the answer. Hope it helps :)\n<|/ c |>\n<| c |>\nI believe that this\
    \ still does not handle cases like `(((())()))` where the number of nested parentheses\
    \ is `2`. It's still only handling the case where the level of nesting for a set\
    \ of parentheses is at most `n`, where `n` is the maximum nesting level of the\
    \ input.\n<|/ c |>\n<| a |>\nHere is an example of a recursive solution that counts\
    \ how many nested parentheses there are in a string. \nThe important thing is\
    \ to consider all the characters from the first to the current position of the\
    \ character. \nA recursive solution like this has the advantage of being able\
    \ to handle strings with multiple nested parentheses.\n<code>\nstatic int count_nested_parentheses(String\
    \ s) {\n    if (s.length() == 0) {\n        return 0;\n    }\n    if (s.charAt(0)\
    \ == '(') {\n        int left = count_nested_parentheses(s.substring(1));\n  \
    \      int right = count_nested_parentheses(s.substring(1));\n        return left\
    \ + right;\n    }\n    if (s.charAt(0) == ')') {\n        return count_nested_parentheses(s.substring(1));\n\
    \    }\n    return 1 + count_nested_parentheses(s.substring(1));\n}\n</code>\n\
    <|/ a tag", "{\n  string groups = paren_string;\n  groups = remove_outer_parens(groups);\n\
    \  groups = remove_double_backslashes(groups);\n  groups = remove_escapes(groups);\n\
    \  \n  long[] levels = count_levels(groups);\n  \n  return levels;\n}", "{\n \
    \   string temp_string = \"\";\n    long temp_int_max = 1;\n    long[] temp_long\
    \ = new long[paren_string.length()];\n    int i = 0;\n    int j = 0;\n    \n \
    \   //parse all groups of nested parenthesis\n    while (i < paren_string.length())\
    \ {\n        //check if this is a group ending parenthesis\n        if (paren_string[i]\
    \ == '(') {\n            int temp = i;\n            temp_string = paren_string.substr(i,\
    \ paren_string.length() - i);\n            //parse group ending parenthesis\n\
    \            while (i < paren_string.length() && !paren_string[i] == '(') {\n\
    \                temp_string = temp_string + paren_string.substr(i++, paren_string.length()\
    \ - i);\n            }\n            //append the number of the current group to\
    \ temp_int\n            int num_group = std.parseuint(temp_string);\n        \
    \    temp_int_max = std.max(temp_int_max, num_group);\n        }\n        //check\
    \ if this is a group starting parenthesis\n        else if (paren_string[i] ==\
    \ ')') {\n            temp_int++;\n            //get the current group starting\
    \ parenthesis\n            int temp_int = i;\n            //get the rest of the\
    \ group and append to temp_string\n            temp_string = paren_string.substr(i,\
    \ paren_string.length() - i);\n            //parse group ending parenthesis\n\
    \            while (i < paren_string.length() && !paren_string[i] == ')') {\n\
    \                temp_string = temp_string + paren_string.substr(i++, paren_string.length()\
    \ - i);\n            }\n            //append the number of the current group to\
    \ temp_int\n            int num_group = std.parseuint(temp_string);\n        \
    \    temp_int_max = std.max(temp_int_max, num_group);\n        }\n        //check\
    \ if this is a group ending parenthesis\n        else if (paren_string[i] == '\
    \ ') {\n            //get the current group ending parenthesis\n            int\
    \ temp_int = i;\n            //get the rest of the group and append to temp_string\n\
    \            temp_string = paren_string.substr(i, paren_string.length() - i);\n\
    \            //parse group ending parenthesis\n            while (i < paren_string.length()\
    \ && !paren_string[i] == ' ') {\n                temp_string = temp_string + paren_string.substr(i++,\
    \ paren_string.length() - i);\n            }\n            //append the number\
    \ of the current group to temp_int\n            int num_group = std.parseuint(temp_string);\n\
    \            temp_int_max = std.max(temp_int_max, num_group);\n        }\n   \
    \     //check if this is a group starting parenthesis\n        else if (paren_string[i]\
    \ == '-') {\n            //get the current group ending parenthesis\n        \
    \    int temp_int = i;\n            //get the rest of the group and append to\
    \ temp_string\n            temp_string = paren_string.substr(i, paren_string.length()\
    \ - i);\n            //parse group ending parenthesis", "{\n    long[] result\
    \ = {0}; //result will contain the deepest number of nesting levels.\n    auto\
    \ iter = paren_string.begin();\n    auto end = paren_string.end();\n    for (auto\
    \ i = iter; !i==end; i=iter+1) {\n        switch (*i) {\n            case '(':\n\
    \                ++i;\n                for (auto j = i; !j==end && paren_string[j]!=')';\
    \ j=j+1) {\n                    ++j;\n                }\n                result[result.length-1]\
    \ += (j==end ? 0 : 1);\n                iter=j;\n                break;\n    \
    \        case ')':\n                --i;\n                for (auto j = i; !j==end\
    \ && paren_string[j]!='('; j=j+1) {\n                    --j;\n              \
    \  }\n                result[result.length-1] += (j==end ? 0 : 1);\n         \
    \       iter=j;\n                break;\n            default:\n              \
    \  iter+=1;\n        }\n    }\n    return result;\n}", "{\n    long num_open =\
    \ 0, num_close = 0;\n    long num_levels = 0;\n    Stack<long> parenStack;\n \
    \   char[] chars = paren_string.toCharArray();\n    for (int i = 0, len = chars.length;\
    \ i < len; ++i) {\n        if (chars[i] == '(') \n            parenStack.push(num_open++);\n\
    \        else if (chars[i] == ')') \n            num_close += parenStack.pop();\n\
    \        else\n            num_levels += (parenStack.empty() ? 0 : parenStack.top());\n\
    \    }\n    if (parenStack.empty())\n        num_levels = 1;\n    if (num_open\
    \ != num_close)\n        num_levels = 1;\n    if (num_levels != 0)\n        num_levels--;\n\
    \    return newlong[num_levels];\n}", "{\n  int paren_level = 0;\n  int open_paren_counter\
    \ = 0;\n  long[] max_level_array = new long[paren_string.length()];\n  for(int\
    \ i = 0; i < paren_string.length(); i++) {\n    char c = paren_string[i];\n  \
    \  if(c == '(') {\n      open_paren_counter++;\n    } else if(c == ')') {\n  \
    \    open_paren_counter--;\n    } else if(c == ' ') {\n      if(open_paren_counter\
    \ == paren_level) {\n        max_level_array[i] = max_level_array[i - 1];\n  \
    \    } else {\n        max_level_array[i] = paren_level;\n      }\n      paren_level\
    \ = 0;\n    } else {\n      paren_level++;\n    }\n  }\n  return max_level_array;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis solution will not work for input\
    \ `((())())` since your code treats parenthesis as separate delimiters.\n<|/ c\
    \ |>\n<| a dscore=0 tags=string,regex,pattern-matching,java |>\nUsing a regex\
    \ and split\n<code>\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;",
  "{\n    List<long> level_stack = new List<long>();\n    long current_level = 0;",
  "{\n    long[] levels = new long[paren_string.length()];\n    int num_levels = 0;\n\
    \    bool in_parantheses;", "{\n    if( paren_string.length() == 0 )\n    {\n\
    \        return newlong[0];\n    }\n    string parens[] = paren_string.split('\
    \ ');\n    int max_level = 0;\n    long[] result = newlong[0];\n    for( int i\
    \ = 1; i < parens.length; ++i )\n    {\n        int level = parens.Length - i;\n\
    \        if( parens[i][0] == '(' )\n        {\n            int j = i;\n      \
    \      while( ( parens[j][ 0 ] != '(' && parens[j][ 0 ] != ')' ) && j < parens.length\
    \ )\n            {\n                ++j;\n            }\n            if( j ==\
    \ parens.length )\n            {\n                throw new Exception(\"Unbalanced\
    \ parentheses in \" + paren_string);\n            }\n            string substr\
    \ = parens[j];\n            if( substr.length() >= 2 )\n            {\n      \
    \          --j;\n                string left = substr;\n                string\
    \ right = substr.substr( 1, substr.Length - 2 );\n                if( left ==\
    \ right )\n                {\n                    throw new Exception(\"Unbalanced\
    \ parentheses in \" + paren_string);\n                }\n                if( left.Length\
    \ > right.Length )\n                {\n                    right = right.substr(\
    \ 0, left.Length - right.Length );\n                }\n                string\
    \ left_str = left.substr( 1, left.Length - 1 );\n                string right_str\
    \ = right.substr( 1, right.Length - 1 );\n                if( left_str == right_str\
    \ )\n                {\n                    throw new Exception(\"Unbalanced parentheses\
    \ in \" + paren_string);\n                }\n            }\n            if( level\
    \ > max_level )\n            {\n                result = newlong[0];\n       \
    \         max_level = level;\n            }\n            for( int k = 0; k < level;\
    \ ++k )\n            {\n                result = newlong[result.length + 1];\n\
    \            }\n            for( int k = 0; k < level; ++k )\n            {\n\
    \                result[ k ] = long.MaxValue;\n            }\n            result[\
    \ level ] = long.MaxValue;\n        }\n        else\n        {\n            int\
    \ j = i;\n            while( ( parens[j][ 0 ] != ')' && parens[j][ 0 ] != ')'\
    \ ) && j < parens.length )\n            {\n                ++j;\n            }\n\
    \            if( j == parens.length )\n            {\n                throw new\
    \ Exception(\"Unbalanced parentheses in \" + paren_string);\n            }\n \
    \           string substr = parens[j];\n            if( substr.length() >= 2 )\n\
    \            {\n                --j;\n                string left = substr;\n\
    \                string right = substr.substr( 1, substr.Length - 2 );\n     \
    \           if( left == right )\n                {\n                    throw\
    \ new Exception(\"Unbalanced parentheses in \" + paren_string);\n            \
    \    }", "{\n    long paren_max_depth = 0;\n    long depth = 0;\n    stack<int>\
    \ paren_depth_stack;\n    map<string, int> paren_nesting_map;\n    for(auto c\
    \ : paren_string) {\n        switch(c) {\n        case '(':\n            paren_depth_stack.push(depth);\n\
    \            depth += 1;\n            break;\n        case ')':\n            paren_depth_stack.push(depth);\n\
    \            long current_depth = paren_depth_stack.pop();\n            depth\
    \ -= 1;\n            if(current_depth > paren_max_depth) {\n                paren_max_depth\
    \ = current_depth;\n            }\n            break;\n        }\n    }\n    while(!paren_depth_stack.empty())\
    \ {\n        depth += 1;\n        paren_depth_stack.pop();\n    }\n    for(int\
    \ i = 0; i < paren_depth_stack.size(); i++) {\n        long current_depth = paren_depth_stack.top();\n\
    \        if(current_depth > paren_max_depth) {\n            paren_max_depth =\
    \ current_depth;\n        }\n    }\n    long[] result = new long[paren_max_depth];\n\
    \    for(int i = 0; i < paren_depth_stack.size(); i++) {\n        long current_depth\
    \ = paren_depth_stack.top();\n        result[current_depth] = i;\n        paren_depth_stack.pop();\n\
    \    }\n    \n    return result;\n}", "{\n\tlong[] results = new long[paren_string.Length];\n\
    \tStack<long> stack = new Stack<long>();\n\tlong level = 0;\n\tbool inside_group\
    \ = false;\n\tfor (int i = 0; i < paren_string.Length; ++i)\n\t{\n\t\tchar c =\
    \ paren_string[i];\n\t\tif ((c == '(' || c == '[') && inside_group == false)\n\
    \t\t{\n\t\t\tinside_group = true;\n\t\t\tstack.push(level);\n\t\t\t++level;\n\t\
    \t}\n\t\telse if ((c == ')' || c == ']') && inside_group == true)\n\t\t{\n\t\t\
    \tlevel = stack.pop();\n\t\t\t++level;\n\t\t\tinside_group = false;\n\t\t}\n\t\
    \telse if (inside_group == true)\n\t\t\t++level;\n\t\telse\n\t\t\tstack.Pop();\n\
    \t\tresults[i] = level;\n\t}\n\treturn results;\n}", "{\n    stack<int> paren_stack;\n\
    \    paren_stack.push(0)\n    long result = 0;\n    for(int i = 0; i < paren_string.length;\
    \ i ++)\n    {\n        // Handle opening paren\n        if(paren_string[i] ==\
    \ '(')\n        {\n            // If we had an opening paren already, pop off\
    \ the top and add the current one\n            if(paren_stack.top() > 0)\n   \
    \         {\n                result = result + paren_stack.top();\n          \
    \      paren_stack.pop();\n            }\n            paren_stack.push(i);\n \
    \       }\n        // Handle closing paren\n        else if(paren_string[i] ==\
    \ ')')\n        {\n            // If the number of opened parens are equal to\
    \ the deepest level of nesting\n            if(paren_stack.size() == result)\n\
    \            {\n                // If we are at the deepest level, pop off the\
    \ top and add it as the result\n                if(paren_stack.top() > 0)\n  \
    \              {\n                    result = result + paren_stack.top();\n \
    \                   paren_stack.pop();\n                }\n            }\n   \
    \         else\n            {\n                // We aren't at the deepest level\
    \ of nesting, recursively add our current paren level\n                result\
    \ = result + paren_stack.size();\n                paren_stack.push(i);\n     \
    \       }\n        }\n        // Handle space\n        else if(paren_string[i]\
    \ == ' ')\n        {\n            // Skip spaces\n        }\n        else\n  \
    \      {\n            throw new RuntimeException(\"Malformed nested parens.\"\
    );\n        }\n    }\n    // Get the result of the stack\n    return paren_stack.toArray();\n\
    }\n</code>\n<|/ a tags=string,java,parentheses,algorithm,recursion |>\n<| c |>\n\
    Nice solution. I would just add that if you have a string like `(  ((  )) (  (\
    \  ))  )  )  ) ( )  )` it will return `[8, 11, 14, 12, 9, 10, 13, 10, 11, 12,\
    \ 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11,\
    \ 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10,\
    \ 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13,\
    \ 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12,\
    \ 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11,\
    \ 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10,\
    \ 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13,\
    \ 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12, 13, 10, 11, 12,\
    \ 13, 10, 11, 12, ", "{\n    string temp_string;\n    long[] result;", "{\n  \
    \  map<string, long> max_nesting_level;\n    stack<string> paren_stack;\n    long\
    \ paren_count = 0;\n    for (auto c : paren_string) \n    {\n        switch (c)\
    \ \n        {\n            case '(':\n                paren_stack.push(c);\n \
    \               paren_count++;\n                break;\n            case ')':\n\
    \                if (!paren_stack.empty()) \n                {\n             \
    \       auto pop = paren_stack.top();\n                    auto count = paren_count;\n\
    \                    paren_stack.pop();\n                    if (!max_nesting_level.count(pop))\
    \ \n                    {\n                        max_nesting_level[pop] = count;\n\
    \                    } \n                    else \n                    {\n  \
    \                      if (max_nesting_level[pop] < count) \n                \
    \        {\n                            max_nesting_level[pop] = count;\n    \
    \                    }\n                    }\n                    paren_count--;\n\
    \                } \n                else \n                {\n              \
    \      throw runtime_error(\"unexpected '('\");\n                }\n         \
    \       break;\n            case ' ':\n                if (!paren_stack.empty())\
    \ \n                {\n                    auto pop = paren_stack.top();\n   \
    \                 auto count = paren_count;\n                    paren_stack.pop();\n\
    \                    if (!max_nesting_level.count(pop)) \n                   \
    \ {\n                        max_nesting_level[pop] = count;\n               \
    \     } \n                    else \n                    {\n                 \
    \       if (max_nesting_level[pop] < count) \n                        {\n    \
    \                        max_nesting_level[pop] = count;\n                   \
    \     }\n                    }\n                    paren_count--;\n         \
    \       }\n                break;\n            default:\n                if (paren_stack.empty())\
    \ \n                {\n                    max_nesting_level[c] = paren_count;\n\
    \                }\n                break;\n        }\n    }\n    return max_nesting_level.size();\n\
    }", "{\n  if(paren_string.length()==0)\n    return new long[] {};", "{\n    long\
    \ ret = 0;\n    foreach(char c in paren_string)\n    {\n        if(c == '(')\n\
    \            ++ret;\n        else if(c == ')')\n            --ret;\n    }", "{\n\
    \    var levels = paren_string.split(\" \");\n    long[] levels_deepest = new\
    \ long[levels.length];\n    int current = 0;\n    long[] result = new long[levels.length];\n\
    \    \n    while(current < levels.length)\n    {\n        string current_level\
    \ = levels[current];\n        int levels_level_length = current_level.length();\n\
    \        int levels_current_level_index = 0;\n        \n        while(levels_level_length\
    \ > 0 && current < levels.length)\n        {\n            string next_level =\
    \ levels[current];\n            levels_level_length = next_level.length();\n \
    \           levels_current_level_index++;\n            current++;\n        }\n\
    \        int levels_current_level_index_in_current_level = levels_current_level_index\
    \ - 1;\n        string next_level = levels[current];\n        \n        // We\
    \ will add the next level's nesting level to the result \n        // of the previous\
    \ level\n        if(levels_current_level_index_in_current_level != 0)\n      \
    \  {\n            int levels_current_level_index_in_next_level = levels_current_level_index_in_current_level;\n\
    \            string next_level_with_level = next_level.substring(0, next_level.length()\
    \ - levels_current_level_index_in_current_level);\n            levels_deepest[levels_current_level_index_in_next_level]\
    \ = new std.math.toInt64(next_level_with_level);\n            \n            current++;\n\
    \        }\n        \n        if(levels_level_length == 0)\n        {\n      \
    \      levels_deepest[levels_current_level_index_in_current_level] = new std.math.toInt64(current_level);\n\
    \            current++;\n        }\n    }\n    \n    for(int i = 0; i < levels_deepest.length;\
    \ i++)\n    {\n        result[i] = levels_deepest[i];\n    }\n    \n    return\
    \ result;\n}", "{\n    stack<int> nesting;\n    long current_nesting = 1;\n  \
    \  bool is_empty = false;\n    string temp_string;", "{\n    stringstream ss;\n\
    \    ss << paren_string;\n    string paren_string2 = ss.str();\n    paren_string2.pop_back();\n\
    \    long[] nest_level;\n    long *p_nest;\n    char *p_tok_string;\n    stringstream\
    \ ss2;\n    ss2 << paren_string2;\n    string paren_string3 = ss2.str();\n   \
    \ paren_string3.pop_back();", "{\n    string brackets = \"([{([\";\n    string\
    \ punct = \"[]})]\";\n    string open = \"\\\\((\";\n    string close = \"\\\\\
    ))\";\n    string closebracket = \"\\\\)\\\\)\\\\)\";\n    string openbracket\
    \ = \"\\\\((\";\n    string openbrace = \"\\\\{(\";\n    string closebrace = \"\
    \\\\})\";\n    string closebrace2 = \"\\\\})\";\n    string closebrace3 = \"\\\
    \\})\";\n    string closebrace4 = \"\\\\}}\";\n    string closebrace5 = \"\\\\\
    }}\";\n    string openbrace2 = \"\\\\{(\";\n    string openbrace3 = \"\\\\{{\"\
    ;\n    string openbrace4 = \"\\\\{\";\n    string openbrace5 = \"\\\\{\";\n  \
    \  string openbrace6 = \"\\\\{{\";\n    string openbrace7 = \"\\\\{\";\n    string\
    \ openbrace8 = \"\\\\{{\";\n    string closebracket = \"\\\\))\";\n    string\
    \ openbracket2 = \"\\\\({\";\n    string openbracket3 = \"\\\\{{\";\n    string\
    \ openbracket4 = \"\\\\{\";\n    string openbracket5 = \"\\\\{\";\n    string\
    \ openbracket6 = \"\\\\{{\";\n    string openbracket7 = \"\\\\{\";\n    string\
    \ openbracket8 = \"\\\\{{\";\n    string closebracket2 = \"\\\\))\";\n    string\
    \ openbracket2 = \"\\\\({\";\n    string openbracket3 = \"\\\\{{\";\n    string\
    \ openbracket4 = \"\\\\{\";\n    string openbracket5 = \"\\\\{\";\n    string\
    \ openbracket6 = \"\\\\{{\";\n    string openbracket7 = \"\\\\{\";\n    string\
    \ openbracket8 = \"\\\\{{\";\n    string closebracket3 = \"\\\\))\";\n    string\
    \ openbracket2 = \"\\\\({\";\n    string openbracket3 = \"\\\\{{\";\n    string\
    \ openbracket4 = \"\\\\{\";\n    string openbracket5 = \"\\\\{\";\n    string\
    \ openbracket6 = \"\\\\{{\";\n    string openbracket7 = \"\\\\{\";\n    string\
    \ openbracket8 = \"\\\\{{\";\n    string closebracket4 = \"\\\\))\";\n    string\
    \ openbracket2 = \"\\\\({\";\n    string openbracket3 = \"\\\\{{\";\n    string\
    \ openbracket4 = \"\\\\{\";\n    string openbracket5 = \"\\\\{\";\n    string\
    \ openbracket6 = \"\\\\{{\";\n    string openbracket", "{\n  long max = 0;\n \
    \ long n = 0;\n  long[] levels = new long[paren_string.length()];", "{\n    if(paren_string.length()\
    \ == 0)\n        return 0;\n    stack<int> paren_stack;\n    int paren_count =\
    \ 0;\n    for(int i = 0; i < paren_string.length(); i++)\n    {\n        if(paren_stack.empty())\n\
    \        {\n            if(paren_string[i] == '(')\n                paren_stack.push(i);\n\
    \        }\n        else\n        {\n            if(paren_string[i] == ')')\n\
    \            {\n                long parent_level_of_interest = paren_count;\n\
    \                while(!paren_stack.empty())\n                {\n            \
    \        int parent_index = paren_stack.top();\n                    paren_stack.pop();\n\
    \                    if(paren_count + 1 < parent_level_of_interest)\n        \
    \                break;\n                    paren_count += 1;\n             \
    \   }\n                paren_count += 1;\n            }\n            else\n  \
    \          {\n                if(paren_string[i] == '(')\n                   \
    \ paren_stack.push(i);\n                else if(paren_string[i] == ')')\n    \
    \            {\n                    long parent_level_of_interest = paren_count;\n\
    \                    while(!paren_stack.empty())\n                    {\n    \
    \                    int parent_index = paren_stack.top();\n                 \
    \       paren_stack.pop();\n                        if(paren_count + 1 < parent_level_of_interest)\n\
    \                            break;\n                        paren_count += 1;\n\
    \                    }\n                    paren_count += 1;\n              \
    \  }\n            }\n        }\n    }\n    long[] results = {paren_count};\n \
    \   while(!paren_stack.empty())\n    {\n        int parent_index = paren_stack.top();\n\
    \        paren_stack.pop();\n        results[parent_index] += 1;\n    }\n    return\
    \ results;\n}\n</code>\n<|/ a dscore=0 tags=java,parsing,c++,algorithm |>\n<|\
    \ c |>\nThe OP said the solution had to be in Java, so this doesn't really help\
    \ the OP.\n<|/ c |>\n<| c |>\nI see what you mean. I tried to write the code in\
    \ a way that would still be understandable. However I agree, that it's better\
    \ to point out the mistake and let the OP fix it instead of posting an unreadable\
    \ answer...\n<|/ c |>\n<| c |>\nThanks for the code. Really appreciate it. But\
    \ I was specifically looking for algorithmic solutions. I do understand the code.\
    \ But it just requires understanding what you are doing and not an implementation\
    \ in Java or a pseudo code. Thanks for the effort though.\n<|/ c |>\n<| c |>\n\
    No problem! I edited the post to add the Java solution. I'll add some explanation\
    \ later when I get home.\n<|/ c ", "{\n    long[] levels = new long[paren_string.length()];\n\
    \    int i = 0;\n    for(;i<paren_string.length();++i)\n    {\n        if(paren_string[i]\
    \ == '(')\n            ++levels[i];\n        if(paren_string[i] == ')')\n    \
    \        --levels[i];\n    }\n    long[] result = new long[paren_string.length()];\n\
    \    for(i=0;i<paren_string.length();++i)\n        result[i] = levels[i];\n  \
    \  return result;\n}\n</code>\n<|/ a |>\n<| c |>\nI really like the idea of using\
    \ std.typecons instead of manual recursion. I was just wondering whether there\
    \ is already a std.typecons implementation in some library that i could use.\n\
    <|/ c |>\n<| c |>\n: There are two std.typecons implementations, one in `boost`\
    \ called `typecons_iterator` and another in `std` called `typecons_range_iterator`.\
    \ Both are part of the `std` namespace.\n<|/ c |>\n<| a dscore=1 tags=functional-programming,parsing,c++\
    \ |>\nA recursive descent parser can produce this kind of data structure. The\
    \ problem is that it requires a stack frame to hold the nesting level. Which means\
    \ you can't use stack frames from other stack frames unless you manage to copy\
    \ the data or use global variables. A simple example would be\n<code>\n#include\
    \ <stdio.h>", "{\n    int i = 0;\n    long[] result = new long[paren_string.size()];\n\
    \    int open_brackets = 0;\n    \n    while (i<paren_string.size()) {\n     \
    \   if (paren_string[i] == '(') {\n            open_brackets++;\n        }\n \
    \       if (paren_string[i] == ')') {\n            open_brackets--;\n        }\n\
    \        result[i] = open_brackets;\n        i++;\n    }", "{\n    if(!paren_string.contains(\"\
    (\")) error(\"Need at least one opening parenthesis\");\n    if(paren_string.contains(\"\
    )\")) error(\"Need at least one closing parenthesis\");\n    stack<long[]> paren_levels\
    \ = new stack<long[]>(); //stack of groups to which open parentheses belong\n\
    \    long max_level = 1;\n    for(auto it = paren_string.rbegin(); it != paren_string.rend();\
    \ ++it) //for each pair of parenthesis separated by space\n    {\n        auto\
    \ left_open_paren = *it;\n        auto right_open_paren = paren_string.find('(',\
    \ it); //find first closing parenthesis\n        auto group_string = paren_string.subspan(left_open_paren,\
    \ right_open_paren); //create group string from left open parenthesis to left\
    \ closing parenthesis\n        if(!paren_levels.empty()) //if there is any group\
    \ stack\n        {\n            long[] new_level = paren_levels.pop(); //pop stack\
    \ group\n            if(new_level.length > max_level) //if we have encountered\
    \ a new maximum level\n            {\n                max_level = new_level.length;\n\
    \            }\n        }\n        if(!group_string.empty()) //if group string\
    \ is not empty\n        {\n            paren_levels.emplace(group_string.begin(),\
    \ group_string.end()); //push group string to stack\n        }\n    }\n    if(paren_levels.empty())\
    \ return new long[]{0};\n    return new long[]{max_level};\n}", "{\n    /*\n \
    \   Input is a string represented multiple groups for nested parentheses separated\
    \ by spaces.\n    For each of the group, output the deepest level of nesting of\
    \ parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((()))\
    \ has three.\n    */\n    long max_level = 0;\n    string paren_level = paren_string;\n\
    \    long level = 1;\n    string temp_string;\n    while(paren_level.size()>0)\n\
    \    {\n        bool found = false;\n        temp_string = \"\";\n        for(int\
    \ i=0;i<paren_level.size(); i++)\n        {\n            if(paren_level[i]=='(')\n\
    \                found = true;\n            else if(paren_level[i]==')')\n   \
    \         {\n                found = false;\n                break;\n        \
    \    }\n            temp_string += paren_level[i];\n        }\n        if(found\
    \ == true)\n            level++;\n        if(temp_string != \"\") \n         \
    \   paren_level += temp_string;\n        else\n            break;\n        if(level>max_level)\n\
    \        {\n            max_level = level;\n        }\n    }\n    if(max_level\
    \ == 0)\n        throw new runtime_error(\"Invalid input\");\n    long[] ans =\
    \ {max_level};\n    return ans;\n}", "{\n    long ret = 0;\n    int num_paras\
    \ = 0;\n    bool in_paras = false;\n    char paras_string[] = \"()\";", "{\n \
    \   string s = paren_string;\n    stack<int> parens_levels;\n    parens_levels.push(0);\
    \ \n    long max_level = 0;\n    for(int i = 1; i < s.length(); i++)\n    {\n\
    \        if (s[i] == '(')\n        {\n            parens_levels.push(parens_levels.size());\n\
    \            max_level = max(max_level, parens_levels.size());\n        }\n  \
    \      else if (s[i] == ')')\n        {\n            int level = parens_levels.pop();\n\
    \            if (level > max_level)\n                max_level = level;\n    \
    \    }\n    }\n    return max_level;\n}\n</code>\n<|/ a |>\n<| a tags=parentheses,algorithm,language-agnostic\
    \ |>\nYou can find this problem easier if you use parentheses as some kind of\
    \ stack (a tree data structure). The problem can be solved by searching the tree\
    \ until you hit an open parentheses pair. Here is a quick pseudo code:\n<code>\n\
    let paren_level = depth(root)\nlet open_count = 0\nwhile root != null\n    open_count\
    \ = open_count + 1\n    root = root.next\nfor i = 0 to open_count\n    paren_level\
    \ = paren_level - 1\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 tags=parentheses,algorithm,language-agnostic\
    \ |>\nHere's a JavaScript solution using recursion:", "{\n    long res = 0;\n\
    \    size_t level = 0;\n    size_t max_nest = 0;\n    for (auto c: str::crlf_toascii(paren_string))\n\
    \    {\n        switch (c) {\n        case '(':\n            if (level == 0) {\n\
    \                level++;\n            } else {\n                level--;\n  \
    \          }\n            break;\n        case ')':\n            if (level ==\
    \ 0) {\n                level++;\n            } else {\n                level--;\n\
    \            }\n            break;\n        case '\\n':\n            if (level\
    \ == 0) {\n                level++;\n            } else {\n                level--;\n\
    \            }\n            break;\n        default:\n            if (level >\
    \ max_nest) {\n                max_nest = level;\n            }\n            break;\n\
    \        }\n        res += level;\n    }\n    res--;\n    return long[res];\n\
    }\n/*\n Input: \n \n Output :\n \n \n This function solves the problem of finding\
    \ number of valid parenthesis expression of a given string. \n \n Valid Parenthesis\
    \ Expression : \n \n A valid parenthesis expression must have atleast one pair\
    \ of parentheses ( ), \n where each pair of parentheses is closed by another pair\
    \ of parentheses, \n i.e. either of the two pairs are balanced. \n \n Example:\
    \ Valid parenthesis expressions are :\n \n \"()\" and \"(()) \" are valid \n \"\
    ((()))\" and \"(()(()))\" are valid \n \"(())()\" and \"(()())\" are valid \n\
    \ \"(())(()\" and \"((()))\" are valid \n \"(()()()\" and \"(())()()\" are valid\
    \ \n \"()(()())\" and \"()(())()\" are valid \n \"(()(())()\" and \"((()(())))\"\
    \ are valid \n \"(())(()(()))\" and \"(())(()())\" are valid \n \"()(()(()()))\"\
    \ and \"(())(())()\" are valid \n \"(()(()())()\" and \"((()(())()))\" are valid\
    \ \n \"()(()(())())\" and \"(())(())()\" are valid \n \"(()(()(())))\" and \"\
    (())(())()\" are valid \n \"()(()(()(())))\" and \"(())(())()\" are valid \n \"\
    ()(()(()(())))\" and \"(())(())()\" are valid \n \"()(()(()(()(())))\" and \"\
    (())(())()\" are valid \n \"()(()(()(()(()(())))) and ()()()\" are valid \n \"\
    (()()(()(()(()(())))) and ()()()\" are valid \n \"()()()(()(()(()(()(())))) and\
    \ ()()()\" are valid \n \"()(()()(", "{\n    long[] max_levels = { 0, 0, 0 };\n\
    \    stack<int> paren_levels;\n    \n    for(auto c : paren_string) {\n      \
    \  if (c == '(') paren_levels.push(int.parse(\"\"));\n        else if (c == ')')\
    \ {\n            int current_level = paren_levels.pop();\n            if (max_levels[current_level]\
    \ > max_levels[max_levels.length - 1]) {\n                max_levels[current_level]\
    \ = max_levels[max_levels.length - 1];\n            }\n            \n        \
    \    max_levels[max_levels.length - 1] = current_level;\n        }\n    }", "{\n\
    \    int levels[paren_string.Length];\n    int pos = 0;\n    for(int i = 1; i\
    \ < paren_string.Length; i++) levels[i] = 0;\n    levels[paren_string.Length -\
    \ 1] = 1;\n    while(pos < paren_string.Length)\n    {\n        if(paren_string[pos]\
    \ == '(')\n        {\n            levels[paren_string.Length - 1]++;\n       \
    \ }\n        else if(paren_string[pos] == ')')\n        {\n            levels[paren_string.Length\
    \ - 1]--;\n        }\n        pos++;\n    }\n    long[] levelsArray;\n    if(paren_string.Length\
    \ == 0)\n    {\n        levelsArray = new long[0];\n    }\n    else\n    {\n \
    \       levelsArray = new long[paren_string.Length];\n        for(int i = 0; i\
    \ < paren_string.Length; i++)\n        {\n            levelsArray[i] = levels[i];\n\
    \        }\n    }\n    return levelsArray;\n}", "{\n    // Start with empty array\
    \ for storing max level of nested parenthesis\n    long[] max_level = new long[paren_string.length()];",
  "{\n    string s = paren_string;\n    string last_opening = \"\";\n    bool opening_found\
    \ = false;\n    string paren_level = \"\";\n    long[] levels;\n    bool nested_paren_found\
    \ = false;", "{\n    List<long> list = new List<long>();\n    string parens =\
    \ \"\";\n    bool inside_paranthesis = false;\n    bool last = false;\n    bool\
    \ start = false;\n    long level = 0;\n    int paren_counter = 1;", "{\n\tlong[]\
    \ results = new long[paren_string.Length];\n\tfor (int i=0; i<paren_string.Length;\
    \ i++) {\n\t\tchar c = paren_string[i];\n\t\tif (c == '(') {\n\t\t\tif (i<paren_string.Length-1)\n\
    \t\t\t\tresults[i+1]++;\n\t\t\telse\n\t\t\t\tresults[0]++;\n\t\t} else if (c ==\
    \ ')') {\n\t\t\tif (i>0) {\n\t\t\t\tresults[i-1]++;\n\t\t\t\tresults[i]--;\n\t\
    \t\t} else {\n\t\t\t\tresults[0]--;\n\t\t\t}\n\t\t} else {\n\t\t\tresults[i]--;\n\
    \t\t}\n\t}\n\treturn results;\n}\n/*\n    Input to this function is a string represented\
    \ for nesting \n    parentheses separated by spaces. Output all the \n    string\
    \ representations possible by repeating and \n    appending parentheses. \n  \
    \  E.g. \"(()()())\" has six possible string representations.\n\t\n    Note this\
    \ function is very slow on large inputs. The maximum complexity is O(N^2)\n\t\n\
    \t\n\t>>> parse_nested_parens(\"(()())\")\n\t[u'(()())', u'()(())', u'(())()',\
    \ u'()(())', u'(())', u'()(()', u'()()()', u'(()', u'()()', u'()()']\n\t>>> parse_nested_parens(\"\
    (())\")\n\t[u'(())', u'(()())', u'()()()', u'(()', u'()()', u'()()', u'()']\n\t\
    >>> parse_nested_parens(\"()()()()\")\n\t[u'()()()()', u'()()()', u'()()()', u'()()()',\
    \ u'()()()', u'()()']\n\t>>> parse_nested_parens(\"()()()\")\n\t[u'()()()', u'()()()',\
    \ u'()()()', u'()()', u'()()', u'()']\n\t>>> parse_nested_parens(\"()()\")\n\t\
    [u'()()', u'()()()', u'()()', u'()()', u'()()', u'()']\n\t>>> parse_nested_parens(\"\
    ()\")\n\t[u'()', u'()()', u'()()', u'()()', u'()()', u'()']\n\t>>> parse_nested_parens(\"\
    ()\")\n\t[u'()', u'()', u'()', u'()', u'()', u'()', u'']\n\t>>> parse_nested_parens(\"\
    ()\")\n\t[u'()', u'()', u'()', u'()', u'()', u'()', u'']\n\t>>> parse_nested_parens(\"\
    ()\")\n\t[u'()', u'()', u'()', u'()', u'()', u'()', u'']\n\t>>> parse_nested_parens(\"\
    ()\")\n\t[u'()', u'()', u'()', u'()', u'()', u'()', u'']\n\t>>> ", "{\n    long\
    \ max_level = 1;\n    long max_level2 = 0;\n    string paren_str = paren_string;\n\
    \    int depth = 0;\n    long temp;\n    int index = 0;\n    while(index < paren_str.Length)\n\
    \    {\n        char c = paren_str[index];\n        if(c == '(')\n        {\n\
    \            depth += 1;\n            if((temp = get_max_level(paren_string,index+1,depth,max_level))\
    \ == -1)\n                return null;\n            else\n                max_level\
    \ = temp;\n        }\n        else if(c == ')')\n        {\n            depth\
    \ -= 1;\n            if((temp = get_max_level(paren_string,index+1,depth,max_level))\
    \ == -1)\n                return null;\n            else\n                max_level\
    \ = temp;\n        }\n        index += 1;\n    }\n    long[] result = new long[max_level+1];\n\
    \    for(int i = 1; i <= max_level; i++)\n    {\n        result[i-1] = i;\n  \
    \  }\n    return result;\n}", "{\n    string s = paren_string;\n    s = s.substr(0,\
    \ s.length()-1);\n    size_t len = s.length();\n    size_t i;\n    long[] counts\
    \ = new long[len];\n    for(i=0; i < len; ++i)\n    {\n        // skip any parens\n\
    \        if(i == 0) \n        {\n            continue;\n        }\n        if(s[i]\
    \ == '(')\n        {\n            ++counts[len - 1 - i];\n        }\n        else\
    \ if(s[i] == ')')\n        {\n            counts[len - 1 - i] = 0;\n        }\n\
    \    }\n    for(i=0; i < len; ++i)\n    {\n        // skip any parens\n      \
    \  if(i == 0) \n        {\n            continue;\n        }\n        if(s[i] ==\
    \ '(')\n        {\n            ++counts[len - 1 - i];\n        }\n        else\
    \ if(s[i] == ')')\n        {\n            counts[len - 1 - i] = 0;\n        }\n\
    \    }\n    return counts;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for\
    \ posting your code! I wasn't sure how to deal with the brackets within the parens,\
    \ but I got it! I added another for loop to check for parens and increase the\
    \ count for that level of nesting! That was really helpful! I appreciate your\
    \ help.\n<|/ c |>\n<| c |>\nThanks, I missed your comments. I posted my complete\
    \ solution in the question itself. I hope it helps someone!\n<|/ c |>\n<| c |>\n\
    It's better to use `if (s.substr(i) == '(')` instead of `if (s[i] == '(')`\n<|/\
    \ c |>\n<| a |>\nHere is my solution that works in C# .Net and C++. I am not sure\
    \ about Python.\n<code>\n#include <iostream>\n#include <stack>\nusing namespace\
    \ std;", "{\n    long[] result = new long[paren_string.length()];\n    Stack<long>\
    \ stack = new Stack<long>();\n    int cur = 0;\n    long depth = 0;\n    string\
    \ curStr = paren_string;\n    for (int i = 0; i < paren_string.length(); ++i)\n\
    \    {\n        char c = paren_string[i];\n        if (c == '(')\n        {\n\
    \            if (stack.empty())\n            {\n                result[cur] =\
    \ i;\n                stack.push(i);\n            }\n            else\n      \
    \      {\n                long top = stack.peek();\n                long bottom\
    \ = top;\n                while (bottom < i)\n                {\n            \
    \        stack.pop();\n                    bottom = stack.peek();\n          \
    \      }\n                stack.pop();\n                result[cur] = i - bottom\
    \ + 1;\n                stack.push(top);\n            }\n        }\n        else\
    \ if (c == ')')\n        {\n            long top = stack.peek();\n           \
    \ long bottom = top;\n            while (bottom < i)\n            {\n        \
    \        stack.pop();\n                bottom = stack.peek();\n            }\n\
    \            stack.pop();\n            result[cur] = i - bottom + 1;\n       \
    \     stack.push(top);\n        }\n        else\n        {\n            stack.pop();\n\
    \        }\n    }\n    while (!stack.empty())\n    {\n        long top = stack.peek();\n\
    \        long bottom = top;\n        while (bottom < i)\n        {\n         \
    \   stack.pop();\n            bottom = stack.peek();\n        }\n        result[cur]\
    \ = i - bottom + 1;\n        stack.push(top);\n    }\n    return result;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nI actually think my code will break for nested parentheses\
    \ in the same string that are not in groups of three. I think your answer is better\
    \ because it also handles those cases. I would recommend accepting it as the answer\
    \ though since it actually works ;)\n<|/ c |>\n<| c |>\n- You are right, I missed\
    \ that case. I updated my answer to reflect the new specifications\n<|/ c |>\n\
    <| c |>\nNice solution! +1. One thing though: your `while` loop runs until `stack.empty()`\
    \ is true, but since you pop the stack each time you enter the loop, you can't\
    \ go back up to `i`. You might want to add a `break` inside the `if`-block.\n\
    <|/ c |>\n<| a dscore=2 |>\nMy solution uses recursion.  I start by taking the\
    \ first character off the string.\nThen I call this function and pass it whatever\
    \ I got left over, which is a string of only the parentheses I encountered.  \n\
    If the string is empty I add 1 to my answer as I consider that to be the number\
    \ of groups I am ", "{\n    if (paren_string.length() == 0)\n    {\n        return\
    \ empty_nested_paren_list();\n    }\n    \n    /*\n    Stack used to hold groups\
    \ of parentheses.\n    \n    We always insert an extra level of parentheses just\
    \ in case one is not found.\n    \n    In the case of ((())) we have:\n    \n\
    \    Paren Stack\n    (\n    Paren Stack\n    )\n    \n    In the case of ((()))\
    \ we have:\n    \n    Paren Stack\n    (\n    Paren Stack\n    )\n    \n    In\
    \ the case of (()()) we have:\n    \n    Paren Stack\n    (\n    Paren Stack\n\
    \    )\n    \n    In the case of (()()) we have:\n    \n    Paren Stack\n    (\n\
    \    Paren Stack\n    )\n    \n    In the case of ()(()) we have:\n    \n    Paren\
    \ Stack\n    (\n    Paren Stack\n    )\n    \n    In the case of () () () we have:\n\
    \    \n    Paren Stack\n    (\n    Paren Stack\n    )\n    \n    In the case of\
    \ () () () () () () () we have:\n    \n    Paren Stack\n    (\n    Paren Stack\n\
    \    )\n    \n    */\n    stack<string> paren_stack = new stack<string>();\n \
    \   \n    /*\n    Used to hold current level of nesting.\n    \n    We always\
    \ insert an extra level of nesting just in case one is not found.\n    \n    In\
    \ the case of (()()) we have:\n    \n    Nested Level\n    3\n    \n    In the\
    \ case of ((())) we have:\n    \n    Nested Level\n    2\n    \n    In the case\
    \ of (()()) we have:\n    \n    Nested Level\n    1\n    \n    In the case of\
    \ ()(()) we have:\n    \n    Nested Level\n    0\n    \n    In the case of ()(())\
    \ () () () () () () () () () () we have:\n    \n    Nested Level\n    0\n    \n\
    \    In the case of () () () () () () () () () () () () () () () () () () () ()\
    \ () () () () () () () () () () () () () () () () () () () () () () () () () ()\
    \ () () () () () () () () () () () () () () () () () () () () () () () () () ()\
    \ () () () () () () () () () () () () ", "{\n    int[] levels;\n    long[] output;",
  "{\n\t\n\tstring parens_str = paren_string;\n\tlong[] result = new long[parens_str.size()];",
  "{\n\tlong[] max_level = new long[paren_string.Length];\n\tmax_level[0] = 0;\n\t\
    for (int i = 1; i < paren_string.Length; ++i)\n\t{\n\t\tstring paren = paren_string[i];\n\
    \t\tint level = 1;\n\t\tfor (int j = 1; j < paren.Length; ++j)\n\t\t{\n\t\t\t\
    string open_paren = paren[j];\n\t\t\tstring close_paren = paren[j + 1];\n\t\t\t\
    long open_level = get_open_level_and_level(open_paren, close_paren);\n\t\t\tif\
    \ (open_level < max_level[i])\n\t\t\t\tmax_level[i] = open_level;\n\t\t}\n\t}\n\
    \treturn max_level;\n}", "{\n    long[] max_level = new long[paren_string.length()];\n\
    \    size_t cur_pos = 0;\n    size_t max_pos = 0;\n    size_t cur_depth = 0;\n\
    \    \n    for(size_t i=0; i<paren_string.length(); i++)\n    {\n        if(paren_string[i]\
    \ == '(')\n        {\n            cur_depth++;\n        }\n        else if(paren_string[i]\
    \ == ')')\n        {\n            cur_depth--;\n        }\n        else if(cur_depth\
    \ > 0)\n        {\n            max_level[max_pos] = cur_depth;\n            max_pos\
    \ = i;\n        }\n    }", "{\n  int level;\n  int i, n, k, max_level;\n  string\
    \ paren_string;", "{\n    long result = 0;\n    long level = 0;", "{\n    auto\
    \ s = paren_string;\n    long[] levels;\n    string level;", "{\n    long max=0;\n\
    \    stack<int> stack_of_parens;", "{\n\tstring[] tokens = lex(paren_string);\n\
    \tlong[] nest = new long[tokens.length];\n\tfor (int i = 0; i < tokens.length;\
    \ i++)\n\t{\n\t\tnest[i] = 1;\n\t\tint level = i;\n\t\twhile (level >= 0)\n\t\t\
    {\n\t\t\tlevel--;\n\t\t\tif (tokens[level] == '(')\n\t\t\t\tnest[i]++;\n\t\t\t\
    if (tokens[level] == ')')\n\t\t\t\tnest[i]--;\n\t\t\tif (nest[i] == 0)\n\t\t\t\
    \tbreak;\n\t\t}\n\t}\n\treturn nest;\n}", "{\n  int max_level = 0;\n  int open_parens\
    \ = 0;\n  int level = 0;\n  string[] parens = paren_string.split(\" \");\n  for\
    \ (int i = 0; i < parens.length; ++i) {\n    string paren = parens[i];\n    if\
    \ (paren == \"(\" || paren == \")\") {\n      if (open_parens > 0) {\n       \
    \ --open_parens;\n      }\n      else {\n        if (level > max_level) {\n  \
    \        max_level = level;\n        }\n        level++;\n      }\n    }\n   \
    \ else if (paren != \"\") {\n      open_parens++;\n      level = 1;\n    }\n \
    \ }\n  assert(level == 0);\n  return new long[max_level + 1];\n}", "{\n    stack<int>\
    \ stack;\n    long level = 0;\n    long max_level = 0;\n    foreach(char c in\
    \ paren_string)\n    {\n        switch(c)\n        {\n            case '(':\n\
    \                stack.push(c);\n                break;\n            case ')':\n\
    \                while(stack.top() != '(')\n                {\n              \
    \      max_level = max(max_level, level);\n                    level++;\n    \
    \            }\n                stack.pop();\n                break;\n       \
    \     default:\n                level++;\n                break;\n        }\n\
    \    }\n    max_level = max(max_level, level);\n    return long[max_level];\n\
    }\n</code>\n<|/ a |>\n<| a |>\nI've been struggling with this one for a while\
    \ and I finally came up with a solution:\n<code>\nstatic char[] stringToCharArray(string\
    \ s) {\n    if (s == null) throw new ArgumentNullException(\"s\");\n    var results\
    \ = new char[s.Length];\n    for (int i = 0; i < s.Length; i++) {\n        char\
    \ c = s[i];\n        switch (c) {\n            case '(':\n                ++i;\n\
    \                break;\n            case ')':\n                --i;\n       \
    \         break;\n            case '[':\n                ++i;\n              \
    \  break;\n            case ']':\n                --i;\n                break;\n\
    \            case '{':\n                ++i;\n                break;\n       \
    \     case '}':\n                --i;\n                break;\n            case\
    \ '<':\n                ++i;\n                break;\n            case '>':\n\
    \                --i;\n                break;\n            case '\"':\n      \
    \          ++i;\n                break;\n            case '\\'':\n           \
    \     --i;\n                break;\n            case '+':\n                ++i;\n\
    \                break;\n            case '-':\n                --i;\n       \
    \         break;\n        }\n        results[i - 1] = c;\n    }\n    return results.ToArray();\n\
    }\n</code>\n<|/ a dscore=2 tags=regex,c# |>\n<| a dscore=2 tags=regex,c# |>\n\
    I've had to deal with this problem for about a year now (I inherited some C# code\
    \ that handles parentheses differently than I thought it would).  I've done my\
    \ best to document the solution as best as I can.\n<code>\n// Create a \"Stack\"\
    \ class with properties for \"top\" and \"pop\"\npublic class Stack<T>\n{\n  \
    \  // Private data members\n    private StackNode<T> node = new StackNode<T>(null);",
  "{\n    long[] result = {0};", "{\n\tlong result = long.MaxValue;\n\tint num_levels\
    \ = 0;\n\tStack<long> stack = new Stack<long>();\n\tstack.Push(result);\n\tstring\
    \ group_counter = \"0\";\n\tbool has_error = false;\n\tforeach(char c in paren_string)\n\
    \t{\n\t\tstring next_group = group_counter.Insert(group_counter.Length(), \"0\"\
    );\n\t\tgroup_counter = next_group;\n\t\tlong group_index = 0;\n\t\tbool group_opened\
    \ = false;\n\t\tswitch(c)\n\t\t{\n\t\t\tcase '(':\n\t\t\t\tgroup_opened = true;\n\
    \t\t\t\tstack.Push(stack.Peek());\n\t\t\t\tstack.Push(group_index);\n\t\t\t\t\
    group_index++;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\twhile(!group_opened)\n\
    \t\t\t\t{\n\t\t\t\t\tstack.Pop(group_index);\n\t\t\t\t\tgroup_opened = true;\n\
    \t\t\t\t}\n\t\t\t\tlong level = stack.Pop();\n\t\t\t\twhile(!stack.Contains(level))\n\
    \t\t\t\t{\n\t\t\t\t\tstack.Pop(level);\n\t\t\t\t\tgroup_opened = false;\n\t\t\t\
    \t}\n\t\t\t\tif(level > num_levels)\n\t\t\t\t{\n\t\t\t\t\tnum_levels = level;\n\
    \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '1':\n\t\t\t\tif(stack.Contains(group_index))\n\
    \t\t\t\t{\n\t\t\t\t\tstack.Pop(group_index);\n\t\t\t\t\tgroup_opened = false;\n\
    \t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstack.Push(group_index);\n\t\t\t\
    \t\tgroup_index++;\n\t\t\t\t\tgroup_opened = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\
    \t\t\tcase '2':\n\t\t\t\tif(stack.Contains(group_index))\n\t\t\t\t{\n\t\t\t\t\t\
    stack.Pop(group_index);\n\t\t\t\t\tgroup_opened = false;\n\t\t\t\t}\n\t\t\t\t\
    else\n\t\t\t\t{\n\t\t\t\t\tstack.Push(group_index);\n\t\t\t\t\tgroup_index++;\n\
    \t\t\t\t\tgroup_opened = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '3':\n\t\
    \t\t\tif(stack.Contains(group_index))\n\t\t\t\t{\n\t\t\t\t\tstack.Pop(group_index);\n\
    \t\t\t\t\tgroup_opened = false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\
    stack.Push(group_index);\n\t\t\t\t\tgroup_index++;\n\t\t\t\t\tgroup_opened = true;\n\
    \t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\tif(stack.Contains(group_index))\n\
    \t\t\t\t{\n\t\t\t\t\tstack.Pop(group_index);\n\t\t\t\t\tgroup_opened = false;\n\
    \t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstack.Push(group_index);\n\t\t\t\
    \t\tgroup_index++;\n\t\t\t\t\tgroup_opened = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\
    \t\t\tcase '5':\n\t\t\t\tif(stack.Contains(group_index))\n\t\t\t\t{\n\t\t\t\t\t\
    stack.Pop(group_index);\n\t\t\t\t\tgroup_opened = false;\n\t\t\t\t}\n\t\t\t\t\
    else\n\t\t\t\t{\n\t\t\t\t\t", "{\n\tlong[] result;\n\tint[] open = {-1, -1};\n\
    \tint[] close = {-1, -1};\n\tint[] ind = {-1, -1};\n\tstring space;\n\tsize_t\
    \ len = 0;\n\tsize_t pos = 0;\n\tstring curr_char;\n\tint curr_char_idx = 0;\n\
    \tbool done = false;\n\tint char_idx = 0;", "{\n    stack<int> level_stack;\n\
    \    long[] levels = new long[paren_string.length()];", "{\n    // Start with\
    \ a list of paren groups of length 1 that have not yet been fully evaluated\n\
    \    var unevaluated_groups = new List<int>();\n    unevaluated_groups.append(0);\n\
    \    \n    // The deepest groups are the groups where all parent groups have been\
    \ fully evaluated\n    var deepest_groups = new List<int>();\n    \n    // The\
    \ deepest groups are the groups where all parent groups have been fully evaluated\n\
    \    // The deepest groups are the groups where all parent groups have been fully\
    \ evaluated\n    var deepest_groups = new List<int>();\n    \n    // The deepest\
    \ groups are the groups where all parent groups have been fully evaluated\n  \
    \  // The deepest groups are the groups where all parent groups have been fully\
    \ evaluated\n    // The deepest groups are the groups where all parent groups\
    \ have been fully evaluated\n    // The deepest groups are the groups where all\
    \ parent groups have been fully evaluated\n    var deepest_groups = new List<int>();\n\
    \    \n    int group_size = paren_string.Length - paren_string.Replace(\"(\",\
    \ \"\").Replace(\")\", \"\").Length;\n    string group_str = paren_string.Replace(\"\
    (\", \"\").Replace(\")\", \"\");\n    \n    // Start with a list of paren groups\
    \ of length 1 that have not yet been fully evaluated\n    var unevaluated_groups\
    \ = new List<int>();\n    unevaluated_groups.append(0);\n    \n    // The deepest\
    \ groups are the groups where all parent groups have been fully evaluated\n  \
    \  var deepest_groups = new List<int>();\n    \n    // The deepest groups are\
    \ the groups where all parent groups have been fully evaluated\n    // The deepest\
    \ groups are the groups where all parent groups have been fully evaluated\n  \
    \  var deepest_groups = new List<int>();\n    \n    // The deepest groups are\
    \ the groups where all parent groups have been fully evaluated\n    // The deepest\
    \ groups are the groups where all parent groups have been fully evaluated\n  \
    \  // The deepest groups are the groups where all parent groups have been fully\
    \ evaluated\n    var deepest_groups = new List<int>();\n    \n    int group_size\
    \ = paren_string.Length - paren_string.Replace(\"(\", \"\").Replace(\")\", \"\"\
    ).Length;\n    string group_str = paren_string.Replace(\"(\", \"\").Replace(\"\
    )\", \"\");\n    \n    // Start with a list of paren groups of length 1 that have\
    \ not yet been fully evaluated\n    var unevaluated_groups = new List<int>();\n\
    \    unevaluated_groups.append(0);\n", "{\n\tlong[] levels = new long[paren_string.Length];\n\
    \tbool paren_stack[paren_string.Length];\n\tint stack_index = 0, paren_count =\
    \ 0;\n\tstring paren_curr, next_curr;\n\tfor (uint i = 0; i < paren_string.Length;\
    \ ++i)\n\t{\n\t\tparen_curr = paren_string[i];\n\t\tnext_curr = paren_string[i\
    \ + 1];\n\t\tif (paren_curr == \"(\") paren_stack[stack_index++] = true;\n\t\t\
    if (paren_curr == \")\") paren_stack[stack_index++] = false;\n\t\tif (paren_stack[stack_index\
    \ - 1] == false && paren_curr == \" \")\n\t\t{\n\t\t\tif (paren_count == 0)\n\t\
    \t\t\tlevels[i] = paren_count;\n\t\t\t++paren_count;\n\t\t}\n\t\telse\n\t\t\t\
    paren_count = 0;\n\t}\n\tif (paren_count != 0) throw runtime_error(\"Invalid nested\
    \ parentheses\");\n\treturn levels;\n}", "{\n    long level = 1;\n    long levels[MAX_PARENTHESES]\
    \ = {0};\n    long level_sizes[MAX_PARENTHESES] = {0};\n    string curr_paren_string\
    \ = \"\";\n    long curr_paren_level = 0;\n    int i = 0;\n    for(i=0; i<paren_string.length();\
    \ i++) {\n        char c = paren_string[i];\n        switch (c) {\n          \
    \  case '(':\n                levels[curr_paren_level]++;\n                level_sizes[curr_paren_level]++;\n\
    \                curr_paren_level++;\n                break;\n            case\
    \ ')':\n                level_sizes[curr_paren_level]--;\n                curr_paren_level--;\n\
    \                if (curr_paren_level == -1) {\n                    curr_paren_string\
    \ = \"\";\n                    curr_paren_level = 0;\n                }\n    \
    \            break;\n            case ' ':\n                if (levels[curr_paren_level]\
    \ == 0) {\n                    curr_paren_string = \"\";\n                   \
    \ curr_paren_level = 0;\n                }\n                break;\n         \
    \   default:\n                curr_paren_string += c;\n        }\n    }\n    return\
    \ levels;\n}", "{\n    long level_of_nesting = 1;\n    bool is_open = true;\n\
    \    bool is_close = false;\n    long level = 0;\n    stack<long> paren_list =\
    \ new stack<long>();\n    paren_list.push(0);\n    while(paren_string.size() >\
    \ 0) {\n        string s = paren_string.substr(0, paren_string.size() - 1);\n\
    \        if(is_open) {\n            if(s == \"(\")\n                paren_list.push(level_of_nesting);\n\
    \            else if(s == \")\")\n                is_close = true;\n         \
    \   else if(s.empty() || s.front() == '(' || s.front() == ')') {\n           \
    \     is_open = false;\n                paren_list.pop();\n                if(!is_close)\n\
    \                    level_of_nesting--;\n            }\n            else\n  \
    \              level_of_nesting++;\n        }\n        else if(is_close && !s.empty()\
    \ && s.front() == '(')\n            level_of_nesting--;\n        else if(is_close\
    \ && s.front() == ')')\n            level_of_nesting--;\n        else if(s.empty()\
    \ || s.front() == '(' || s.front() == ')') {\n            if(!is_close)\n    \
    \            is_open = false;\n        }\n        else {\n            level_of_nesting--;\n\
    \        }\n        \n        if(!is_close)\n            paren_list.push(level_of_nesting);\n\
    \        \n        paren_string = paren_string.substr(paren_string.size() - 1);\n\
    \    }\n    \n    long[] res = new long[paren_list.size()];\n    int idx = 0;\n\
    \    while(!paren_list.empty()) {\n        res[idx++] = paren_list.pop();\n  \
    \  }\n    return res;\n}", "{\n    string parens_str = paren_string;\n    char\
    \ c;\n    long paren_level = 0;\n    for(size_t i = 0; i < parens_str.size();\
    \ ++i)\n    {\n        c = parens_str[i];\n        if(c == ')')\n        {\n \
    \           paren_level--;\n        }\n        else if(c == '(')\n        {\n\
    \            paren_level++;\n        }\n        else if(c == ',')\n        {\n\
    \            paren_level = paren_level == 0 ? 1 : paren_level;\n        }\n  \
    \  }\n    if(paren_level > 0)\n    {\n        return fail(paren_string);\n   \
    \ }\n    \n    long[] nesting = new long[parens_str.size()];\n    string paren_group;\n\
    \    for(size_t i = 0; i < parens_str.size(); ++i)\n    {\n        c = parens_str[i];\n\
    \        if(c == ')')\n        {\n            paren_group = \"\";\n        }\n\
    \        else if(c == '(')\n        {\n            paren_group += \"(\" + paren_level\
    \ + \")\";\n        }\n        else\n        {\n            paren_group += c;\n\
    \        }\n        nesting[i] = paren_level;\n    }\n    return nesting;\n}",
  "{\n    int[] num_groups = new int[paren_string.Length];\n    int[] max_levels =\
    \ new int[paren_string.Length];\n    int cur_level = 0;\n    int open_paren =\
    \ 0;\n    long[] levels = new long[paren_string.Length];\n    int i, j;\n    int\
    \ cur_max_level = -1;\n    for(i=0; i<paren_string.Length; ++i)\n    {\n     \
    \   if(paren_string[i]=='(')\n        {\n            open_paren+=1;\n        \
    \    \n            if(num_groups[i]==0)\n            {\n                num_groups[i]\
    \ = 1;\n                cur_level = 1;\n            }\n            else\n    \
    \        {\n                num_groups[i]++;\n            }\n        }\n     \
    \   else if(paren_string[i]==')')\n        {\n            open_paren-=1;\n   \
    \         if(open_paren==0)\n            {\n                cur_level-=1;\n  \
    \          }\n            if(cur_level<0)\n            {\n                throw\
    \ new ArgumentException(\"Unexpected closing bracket\");\n            }\n    \
    \        if(cur_level>cur_max_level)\n            {\n                cur_max_level\
    \ = cur_level;\n            }\n            if(num_groups[i]>0)\n            {\n\
    \                num_groups[i]--;\n            }\n            else\n         \
    \   {\n                throw new ArgumentException(\"Parentheses do not match\"\
    );\n            }\n        }\n        else\n        {\n            if(num_groups[i]==0)\n\
    \            {\n                throw new ArgumentException(\"Missing opening\
    \ bracket\");\n            }\n            if(open_paren>0)\n            {\n  \
    \              throw new ArgumentException(\"Unexpected opening bracket\");\n\
    \            }\n            if(num_groups[i]>0)\n            {\n             \
    \   throw new ArgumentException(\"Parentheses do not match\");\n            }\n\
    \            cur_level++;\n        }\n    }\n    if(open_paren!=0) throw new ArgumentException(\"\
    Unexpected closing bracket\");\n    if(cur_max_level!=paren_string.Length) throw\
    \ new ArgumentException(\"Incorrect number of nested brackets\");\n    for(i=0;\
    \ i<paren_string.Length; ++i)\n    {\n        if(num_groups[i]==0)\n        {\n\
    \            num_groups[i] = 1;\n        }\n        else\n        {\n        \
    \    num_groups[i]--;\n        }\n        levels[i] = num_groups[i]>0?num_groups[i]:-1;\n\
    \    }\n    return levels;\n}\n/*\n This function takes in a string and returns\
    \ a string with spaces inserted to make the string match the original string exactly.\n\
    \    It will throw an ArgumentException if there are extra spaces.", "{\n    long[]\
    \ result = new long[paren_string.length()];\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        char c = paren_string[i];\n        if (c == '(' || c ==\
    \ ')')\n            result[i] = 0;\n        else if (c == '(')\n            result[i]\
    \ = 1;\n        else if (c == ')')\n            result[i] = 0;\n        else\n\
    \        {\n            if (result[i] > 0)\n            {\n                int\
    \ j = i - 1;\n                while (j >= 0)\n                {\n            \
    \        if (paren_string[j] == ')')\n                    {\n                \
    \        result[i] = 0;\n                        break;\n                    }\n\
    \                    if (paren_string[j] == '(')\n                        result[i]++;\n\
    \                    j--;\n                }\n            }\n        }\n    }\n\
    \    return result;\n}", "{\n\tstring paren_list_string = paren_string.strip();\n\
    \    long[] paren_list_sizes = paren_list_string.split(' ').map((string x)->{return\
    \ x.length();});\n    long paren_list_sum = 0;\n    for (long i : paren_list_sizes)\n\
    \        paren_list_sum += i;\n    \n    long[] max_paren_list_sizes = paren_list_sizes.map((long\
    \ x)->{return x;});\n    long max_paren_list_sum = 0;\n    for (long i : max_paren_list_sizes)\n\
    \        max_paren_list_sum += i;", "{\n\tint i = 0;\n\tlong[] results = new long[paren_string.length()];\n\
    \tstring paren_chars[] = paren_string.ToCharArray();\n\tfor (int j = 0; j < paren_chars.Length;\
    \ j++) {\n\t\tstring paren_char = paren_chars[j];\n\t\tif (paren_char.ToUpper()\
    \ == \"(\") {\n\t\t\tresults[i] = 1;\n\t\t} else if (paren_char.ToUpper() == \"\
    (\") {\n\t\t\tresults[i] = 0;\n\t\t} else {\n\t\t\tresults[i] = 0;\n\t\t}\n\t\t\
    i++;\n\t}\n\treturn results;\n}", "{\n    char[] parens = paren_string.toCharArray();\n\
    \    int paren_count = 1;\n    long max_nesting = 1;\n    bool is_open = true;\n\
    \    bool is_close_paren = true;\n    long open_paren_level = 1;\n    long[] nesting_levels\
    \ = new long[paren_count];", "{\n\tint n = paren_string.length();\n\tint level\
    \ = 0;\n\tint open_count = 0;\n\tint[] result = new int[n];\n\tfor (int i = 0;\
    \ i < n; i++) {\n\t\tchar c = paren_string[i];\n\t\tif (open_count > 0) {\n\t\t\
    \tif (c == ')' && open_count == level) {\n\t\t\t\topen_count--;\n\t\t\t}\n\t\t\
    \telse {\n\t\t\t\topen_count = 1;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (c ==\
    \ '(') {\n\t\t\t\topen_count++;\n\t\t\t\tlevel++;\n\t\t\t}\n\t\t\telse if (c ==\
    \ ')') {\n\t\t\t\topen_count--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\topen_count = 1;\n\
    \t\t\t\tlevel = 1;\n\t\t\t}\n\t\t}\n\t\tresult[i - 1] = level;\n\t}\n\treturn\
    \ result;\n}", "{\n    map<int, long> level_nesting;\n    int level = 1;\n   \
    \ int index = 0;\n    int open_brackets = 0;\n    for(int i = 0; i <= paren_string.length();\
    \ i++)\n    {\n        if(paren_string[i] == '(')\n            open_brackets++;\n\
    \        else if(paren_string[i] == ')')\n        {\n            if(open_brackets\
    \ == level) // found the deepest level of nesting\n            {\n           \
    \     if(!level_nesting.count(level))\n                    level_nesting[level]\
    \ = index;\n                level++;\n                open_brackets = 0;\n   \
    \         }\n            else\n                open_brackets--;\n        }\n \
    \       else\n            open_brackets = 0;\n    }\n    long[] deepest_level_nesting\
    \ = new long[level_nesting.size()];\n    for(int i = 0; i < deepest_level_nesting.size();\
    \ i++)\n        deepest_level_nesting[i] = level_nesting[i];\n    return deepest_level_nesting;\n\
    }\n</code>\n<|/ a tags=java,string,algorithm,arrays |>\n<| a dscore=0 |>\n<code>\n\
    public static int count_parentheses(String str) {\n    if (str == null || str.isEmpty())\
    \ {\n        return 0;\n    }\n    int count = 0;\n    for (int i = 0; i < str.length();\
    \ i++) {\n        char ch = str.charAt(i);\n        if (ch == '(') {\n       \
    \     count++;\n        } else if (ch == ')') {\n            count--;\n      \
    \  }\n        if (count == 0)\n            break;\n    }\n    return count;\n\
    }\n</code>\n<|/ a tags=java,string,algorithm,arrays |>\n<| c |>\nA simple loop\
    \ is enough.\n<|/ c |>\n<| c |>\nThis code doesn't work.\n<|/ c |>\n<| a |>\n\
    <code>\n public int countParenthesis(String str){\n    char[] strArray = str.toCharArray();\n\
    \    int parenCount = 0;\n    int stack = 0;\n    for(int i = 0; i < strArray.length;\
    \ i++){\n        if(strArray[i] == '('){\n            stack++;\n        }\n  \
    \      else if(strArray[i] == ')'){\n            stack--;\n        }\n       \
    \ else if(stack > 0){\n            parenCount++;\n        }\n    }\n    return\
    \ parenCount;\n}\n</code>\n<|/ a dscore=0 tags=java,string,algorithm,arrays |>\n\
    <| c |>\nThis code doesn't work.\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic static\
    \ int countParenthesis(String str) {\n    int count = 0;\n    int i = 0;\n   \
    \ while (i<str.length()) {\n        if (str.charAt(i) == '('", "{\n    string\
    \ curr_pos = paren_string;\n    string curr_group = paren_string;\n    long curr_level\
    \ = 1;\n    long total_level = 0;\n    int open_parentheses = 0;\n    long curr_level_count\
    \ = 0;", "{\n\tlong result = 0;\n\tfor (int i = 0; i < paren_string.length; i\
    \ += 1)\n\t{\n\t\tif (paren_string[i] == '(')\n\t\t\tresult++;\n\t\telse if (paren_string[i]\
    \ == ')')\n\t\t\tresult--;\n\t}\n\treturn result;\n}", "{\n    long[] max_levels\
    \ = new long[paren_string.length()];\n    for (int i = 0; i < paren_string.length();\
    \ i++) \n    {\n        // Get current character\n        char ch = paren_string[i];\n\
    \        \n        // Open an new level\n        if (ch == '(')\n            max_levels[i]\
    \ = 1;\n        else\n        {\n            // Get existing level\n         \
    \   long level = max_levels[i];\n            \n            // Close an existed\
    \ level\n            if (ch == ')')\n                max_levels[i] = --level;\n\
    \            else\n            {\n                // Add new level\n         \
    \       long new_level = max_levels[i] + 1;\n                max_levels[i] = new_level;\n\
    \            }\n        }\n    }\n    return max_levels;\n}\n</code>\n<|/ a dscore=0\
    \ tags=algorithm,depth-first-search,language-agnostic |>\n<| c |>\nThe idea is\
    \ to not modify the input string since it may contain other groups of the same\
    \ size.\n<|/ c |>\n<| c |>\nI guess it also depends on the interpretation of the\
    \ input: e.g. `((())())` is not a valid input. On the other hand `((())(()))`\
    \ does have only one level of nesting. I am not able to fully understand what\
    \ you mean by \"maximum depth\" is greater than the actual nesting level (since\
    \ `((())(()))` has three levels).\n<|/ c |>\n<| c |>\nI guess I should rephrase\
    \ the question: what is the maximum level of nesting in the given input?\n<|/\
    \ c |>\n<| c |>\nThe input can be nested parentheses of different size. For example:\
    \ `((())(()))`. I am not sure how do you mean `((())(()))` has three levels of\
    \ nesting?\n<|/ c |>\n<| c |>\nThe input can be nested parentheses of different\
    \ size. For example: `((())(()))`. I am not sure how do you mean `((())(()))`\
    \ has three levels of nesting? Do you mean each input `((())(()))` has three levels\
    \ of nesting? If so, I would say that it is three levels of nesting. I guess I'm\
    \ confused of what you mean.\n<|/ c |>\n<| a tags=algorithm,depth-first-search,language-agnostic\
    \ dscore=0 |>\nWe can use a stack. As we pop a parentheses, we push its level.\
    \ As we pop a parentheses, we push its level. As we pop a parentheses, we push\
    \ its level. As we pop a parentheses, we push its level. As we pop a parentheses,\
    \ we push its level. As we pop a parentheses, we push its ", "{\n    stack<int>\
    \ stack;\n    long[] results;\n    stack<int> parens_stack;\n    parens_stack.push(0)\n\
    \    int count_parens = 0;\n    string buffer = \"\";\n    int pos = 0;\n    while(!paren_string.empty())\
    \ \n    {\n        char c = paren_string.at(pos);\n        pos++;\n        if(c\
    \ == '(') {\n            stack.push(count_parens);\n            parens_stack.push(count_parens);\n\
    \        }\n        if(c == ')') \n        {\n            count_parens = stack.pop();\n\
    \            long parens = parens_stack.pop();\n            if(parens > 0 && parens\
    \ == count_parens) {\n                results[count_parens-1]++;\n           \
    \     buffer = \"\";\n            }\n            else if((parens == 0) || (parens\
    \ == count_parens) || (parens == count_parens - 1)) \n            {\n        \
    \        if(buffer != \"\") {\n                    results[count_parens-1] +=\
    \ buffer.size();\n                }\n                buffer = \"\";\n        \
    \    }\n        }\n        if(c == ' ') {\n            buffer += paren_string.at(pos);\n\
    \        }\n    }\n    if(buffer != \"\") {\n        results[count_parens-1] +=\
    \ buffer.size();\n    }\n    return results;\n}", "{\n    if (paren_string ==\
    \ null || paren_string.length() == 0)\n        return null;", "{\n    map<string,\
    \ long> paren_string_to_max_level;\n    \n    // First pass: count how many groups\
    \ in the paren_string\n    string paren_string_with_groups = \"(\" + paren_string\
    \ + \")\";\n    size_t paren_string_count = 1;\n    map<string, size_t> paren_string_to_paren_string_group;\n\
    \    while(paren_string_with_groups.length())\n    {\n        auto it = paren_string_to_paren_string_group.find(paren_string_with_groups);\n\
    \        if(it == paren_string_to_paren_string_group.end())\n        {\n     \
    \       paren_string_to_paren_string_group[paren_string_with_groups] = paren_string_count;\n\
    \            paren_string_to_max_level[paren_string_with_groups] = 0;\n      \
    \      paren_string_count++;\n        }\n        else\n        {\n           \
    \ paren_string_to_max_level[paren_string_with_groups] = max(paren_string_to_max_level[paren_string_with_groups],\
    \ it->second);\n        }", "{\n    stack<int> paren_levels;\n    long[] max_level_of_nesting\
    \ = new long[paren_string.length()];\n    for(int i = 0; i < paren_string.length();\
    \ i++)\n    {\n        if(paren_string[i] == '(')\n        {\n            paren_levels.push(i);\n\
    \        }\n        else if(paren_string[i] == ')')\n        {\n            long\
    \ levels_of_nesting = paren_levels.pop();\n            if((max_level_of_nesting[levels_of_nesting]\
    \ <= max_level_of_nesting[levels_of_nesting - 1]))\n                max_level_of_nesting[levels_of_nesting]\
    \ = max_level_of_nesting[levels_of_nesting - 1];\n        }\n    }\n    return\
    \ max_level_of_nesting;\n}\n</code>\n<|/ a dscore=4 |>\n<| a |>\nI wrote a JavaScript\
    \ implementation of the longest nested parentheses algorithm, in response to the\
    \ question \"Given a string of characters, how many parentheses are there?\".\
    \ The answer is 7. It works by first counting how many nested parentheses are\
    \ at each position, from right to left. Then it compares the two counts, and stops\
    \ when they are equal, or when the difference is exactly 1.\nThe JavaScript code\
    \ below shows the recursive function, and the test case:", "{\n\tlong maxlevel\
    \ = 0;\n\tlong[] maxlevels = new long[paren_string.length()];\n\tfor(int i = 0;\
    \ i < paren_string.length(); ++i)\n\t{\n\t\tif(paren_string[i] == '(')\n\t\t{\n\
    \t\t\t++maxlevel;\n\t\t}\n\t\telse if(paren_string[i] == ')')\n\t\t{\n\t\t\tif(maxlevel\
    \ > 0)\n\t\t\t{\n\t\t\t\t--maxlevel;\n\t\t\t}\n\t\t}\n\t\telse if(paren_string[i]\
    \ == ',')\n\t\t{\n\t\t\tif(maxlevel > 0)\n\t\t\t{\n\t\t\t\tmaxlevel = std.min(maxlevel,\
    \ maxlevels[i - 1] + 1);\n\t\t\t\tmaxlevels[i - 1]++;\n\t\t\t}\n\t\t}\n\t}\n\t\
    return maxlevels;\n}", "{\n\tlong curlevel = 0;\n\tlong maxlevel = 0;\n\tList<long>\
    \ results = new List<long>();\n\tchar? opening_brace = '(';\n\tfor (char ch in\
    \ paren_string)\n\t{\n\t\tresults.Add(curlevel);\n\t\tlong count = results.Last()\
    \ - results.First() + 1;\n\t\tif (ch == opening_brace) \n\t\t{\n\t\t\tcurlevel++;\n\
    \t\t}\n\t\telse if (ch == closing_brace)\n\t\t{\n\t\t\tcurlevel--;\n\t\t}\n\t\t\
    if (maxlevel < curlevel) \n\t\t{\n\t\t\tmaxlevel = curlevel;\n\t\t}\n\t}\n\treturn\
    \ results.ToArray();\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
