name: HumanEval_98_count_upper
language: d
prompt: "import std.math;\n/*\n\n    Given a string s, count the number of uppercase\
  \ vowels in even indices.\n    \n    For example:\n    >>> count_upper(\"aBCdEf\"\
  )\n    1L\n    >>> count_upper(\"abcdefg\")\n    0L\n    >>> count_upper(\"dBBE\"\
  )\n    0L\n    \n*/\nlong count_upper(string s) \n"
tests: "unittest\n{\n    alias candidate = count_upper;\n\n    assert(candidate(\"\
  aBCdEf\") == 1L);\n    assert(candidate(\"abcdefg\") == 0L);\n    assert(candidate(\"\
  dBBE\") == 0L);\n    assert(candidate(\"B\") == 0L);\n    assert(candidate(\"U\"\
  ) == 1L);\n    assert(candidate(\"\") == 0L);\n    assert(candidate(\"EEEE\") ==\
  \ 2L);\n}\nvoid main(){}"
completions: ["{\n    long vowels = 0;\n    for(int i = 0; i < s.length; ++i)\n  \
    \  {\n        if((s[i] >= 'A') && (s[i] <= 'Z'))\n            vowels += 1;\n \
    \   }\n    return vowels;\n}", "{\n    long n = 0;\n    for (int i = 0; i < s.length;\
    \ ++i)\n    {\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] ==\
    \ 'o' || s[i] == 'u')\n            ++n;\n    }\n    return n;\n}", "{\n    long\
    \ counter = 0;\n    for (int i = 0; (i < s.length()); i++)\n    {\n        int\
    \ codepoint = s.codePointAt(i);\n        if (codepoint >= 'A' && codepoint <=\
    \ 'Z')\n        {\n            counter += codepoint - 'A' + 1L;\n        }\n \
    \   }\n    return counter;\n}", "{\n    int n = s.length();\n    long nupper =\
    \ 0;\n    for (int i=0;i<n;i++)\n    {\n        if (isupper(s[i]))\n         \
    \   nupper += 2;\n    }\n    return nupper;\n}", "{\n    int i;\n    long count=0;\n\
    \    for(i=0;i<s.length();i++) {\n        if ((s[i] >= 'a' && s[i] <= 'z') ||\
    \ (s[i] >= 'A' && s[i] <= 'Z')) {\n            count++;\n        }\n    }\n  \
    \  return count;\n}", "{\n    long result = 0;\n    for(int i=0;i<s.length()-2;i+=2)\n\
    \    {\n        if(s[i] >= 'A' && s[i] <= 'Z' && s[i+1] >= 'A' && s[i+1] <= 'Z')\n\
    \        {\n            result++;\n        }\n    }\n    return result;\n}\n/*\n\
    \    \n    Write a function that will take a number as input, and return the number\
    \ in the form of a string.\n    For example:\n    \n    >>> to_str1(10)\n    \"\
    1010\"\n    >>> to_str1(10)\n    \"1010\"\n    >>> to_str2(15)\n    \"1111\"\n\
    \    >>> to_str2(15)\n    \"1111\"\n    >>> to_str1(7)\n    \"0007\"\n    >>>\
    \ to_str1(7)\n    \"0007\"\n    >>> to_str2(5)\n    \"0105\"\n    >>> to_str2(5)\n\
    \    \"0105\"\n    \n*/\nstring to_str1(long num)\n{\n    if(num >= 0 && num <=9)\n\
    \    {\n        return string(num, '0');\n    }\n    else\n    {\n        return\
    \ string(num - 10, '0');\n    }\n}\nstring to_str2(long num)\n{\n    if(num >=\
    \ 0 && num <=9)\n    {\n        return string(num, '1');\n    }\n    else\n  \
    \  {\n        return string(num - 10, '1');\n    }\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nWhy are you returning strings from the `to_str1` and `to_str2`\
    \ functions? Just `return to_string(num)` would be the way to go. Also, `to_str1`\
    \ should be named `to_binary_str1`; that's what it's doing, as far as I can tell.\n\
    <|/ c |>\n<| c |>\nI did not realize the naming was so important.  Thanks for\
    \ pointing that out.  I also agree that to_str1 and to_str2 should be named to_binary_str1\
    \ and to_binary_str2.  I tried to make a generic function that could be passed\
    \ any number or combination of integers, longs, and strings and still get consistent\
    \ output for each (to_binary_str1, to_binary_str2, to_binary_str3)  Thanks for\
    \ the feedback\n<|/ c |>\n<| a dscore=0 tags=c++ |>\nA generic algorithm for counting\
    \ number of uppercase characters (upper or lower case) in string is very straightforward.\
    \ Using this algorithm, we have the below mentioned functions:", "{\n    long\
    \ result = 0;\n    for(int i=0; i<s.length(); i++) {\n        if(s[i] >= 'A' &&\
    \ s[i] <= 'Z')\n            result += ((s[i] >= 'a' && s[i] <= 'z') ? 1 : 0);\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=string,c++ |>\n<| c |>\nThanks\
    \ for your answer. Your solution works for lowercase letters too, but doesn't\
    \ work for capital letters. It gives the wrong result for \"Baby\". Can you please\
    \ help me solve this problem too? Thanks!\n<|/ c |>\n<| c |>\n: This code works\
    \ for me. Which version of g++ are you using?\n<|/ c |>\n<| c |>\nOh, sorry. I\
    \ am using Visual Studio 2012. My mistake. Your code works fine. Thanks!\n<|/\
    \ c |>\n<| c |>\n: It does not work on \"Baby\", it gives 0.\n<|/ c |>\n<| c |>\n\
    : That's because your answer is correct and should be accepted instead of mine.\
    \ You have no idea how stupid that is. I only had a look at the first few lines\
    \ of the OP's code (I was not even aware that `isalpha` was a thing), but then\
    \ I thought about it again and I think I have got it right.\n<|/ c |>\n<| a tags=string,c++\
    \ |>\nThis should work:\n<code>", "{\n\tauto vowel_count = 0L;\n\tauto it = s.begin();\n\
    \tauto end_it = s.end();\n\tfor (; it != end_it; ++it) {\n\t\tif (*it >= 'A' &&\
    \ *it <= 'Z') {\n\t\t\tif (*it >= 'a' && *it <= 'z') {\n\t\t\t\t++vowel_count;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn vowel_count;\n}", "{\n\tlong count = 0;\n\tforeach(unsigned\
    \ c, s) {\n\t\tif(c=='a')\n\t\t\tcount++;\n\t\telse if(c=='e')\n\t\t\tcount++;\n\
    \t\telse if(c=='i')\n\t\t\tcount++;\n\t\telse if(c=='o')\n\t\t\tcount++;\n\t\t\
    else if(c=='u')\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n*/\n<|/ file source=github\
    \ dstars=1 |>\n<| c |>\nThanks Rob! The original code works when I use \"string\"\
    \ instead of \"char[]\" but I wanted to see if I could do it using a char[]. Sorry\
    \ for the confusion but I have been stuck on this for a long time.\n<|/ c |>\n\
    <| c |>\nNo worries! I've added some comments to explain what it's doing.\n<|/\
    \ c |>\n<| a |>\nHere's an example using STL algorithms.\n<code>", "{\n\tint i;\n\
    \tlong n = 0;\n\tfor(i = 0; i<s.size();i++)\n\t{\n\t\tchar c = s[i];\n\t\tif(c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\t\t\tn++;\n\t}\n\t\
    return n;\n}\n/*", "{\n    int i = 0;\n    bool isVowel = false;\n    for(; i\
    \ < s.size() && isVowel == false; ++i)\n    {\n        if(s[i] == 'A' || s[i]\
    \ == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')\n        {\n          \
    \  isVowel = true;\n        }\n        else\n        {\n            isVowel =\
    \ false;\n        }\n    }\n    return 0L;\n}", "{\n  long total = 0L;\n  for\
    \ (long i = 0; i < s.length(); i++)\n  {\n    // if i is even, then it must be\
    \ a vowel\n    if (((i + 1) % 2) == 0)\n    {\n      if (s[i] == 'A' || s[i] ==\
    \ 'a' || s[i] == 'E' || s[i] == 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O'\
    \ || s[i] == 'o' || s[i] == 'U' || s[i] == 'u')\n      {\n        total = total\
    \ + 1L;\n      }\n    }\n  }\n  return total;\n}", "{\n    if (s.length() == 0)\n\
    \        return 0;\n    int count = 0;\n    char c = s[0];\n    for (int i = 1;\
    \ i < s.length(); i++)\n    {\n        c = toupper(c);\n        if (isupper(c))\n\
    \            count++;\n    }\n    return count;\n}\n</cell>\n<cell>\n// A function\
    \ to convert a sentence into a vector\n// where each word is represented by a\
    \ vector of size k.\n// Each of the word is represented by a row in a vector where\
    \ each element is a word.", "{\n    int i;\n    long count = 1;\n    for (i =\
    \ 1; i < s.length(); ++i)\n    {\n        if (s[i] == 'A' || s[i] == 'a' || s[i]\
    \ == 'E' || s[i] == 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i] ==\
    \ 'o' || s[i] == 'U' || s[i] == 'u')\n            ++count;\n    }\n    return\
    \ count;\n}", "{\n\tmap<string, long> m;\n\tmap<string, long>::iterator it;\n\t\
    string aux;\n\tfor(it=m.begin(); it!=m.end(); ++it)\n\t{\n\t\taux=it->first;\n\
    \t\tlong count=0;\n\t\tfor(int i=0; i<s.length(); ++i)\n\t\t\tif(s[i]==aux[i])\
    \ count+=1;\n\t\tif(count%2==0) it->second+=1;\n\t}\n\treturn m[s];\n}", "{\n\
    \  int len = s.length();\n  long count = 0L;\n  for (int i = 0; i < len; i +=\
    \ 2) \n  {\n    if (isupper(s.c_str()[i])) \n    {\n      count++;\n    }\n  }\n\
    \  return count;\n}\n</code>\n<|/ a tags=c++,c dscore=2 |>\n<| c |>\nNote that\
    \ `s.c_str()` is `const`, so calling `s.c_str()` repeatedly is probably a bad\
    \ idea.\n<|/ c |>\n<| c |>\n: Yes, indeed!\n<|/ c |>\n<| c |>\n: thanks so much,\
    \ i just found it and edited my answer at the same time\n<|/ c |>\n<| a tags=c++,c\
    \ dscore=2 |>\n<code>\n#include <iostream>\n#include <string>\n#include <cctype>",
  "{\n    int\ti;\n    long\tcount;\n    \n    count = 0;\n    for (i = 0; i <= length(s)\
    \ - 2; i++)\n    {\n    \tif (s[i] != s[i]) count ++;\n    \tif (s[i + 1] == s[i\
    \ + 1]) count ++;\n    \tif (s[i + 2] == s[i + 2]) count ++;\n    }\n    \n  \
    \  return count;\n}\n/*", "{\n    \n    int i;\n    long count = 0L;\n    \n \
    \   for (i = 0 ; i < s.size() ; i++)\n        if (s[i] == 'a' || s[i] == 'e' ||\
    \ s[i] == 'i' || s[i] == 'o' || s[i] == 'u')\n            count++;\n    \n   \
    \ return count;\n}", "{\n\tlong result;\n\tforeach(char c in s) {\n\t\tif(c ==\
    \ 'a' || c == 'A') result += 1;\n\t\tif(c == 'e' || c == 'E') result += 1;\n\t\
    \tif(c == 'i' || c == 'I') result += 1;\n\t\tif(c == 'o' || c == 'O') result +=\
    \ 1;\n\t\tif(c == 'u' || c == 'U') result += 1;\n\t}\n\treturn result;\n}", "{\n\
    \t\n\tsize_t i = 1;\n\tsize_t j = 0;\n\tsize_t vowels = length(s) / 2;\n\t\n\t\
    for (size_t k = 0; k < length(s); ++k) {\n\t\t\n\t\tchar c = s[k];\n\t\t\n\t\t\
    if (c < 'A' || c > 'Z')\n\t\t\tbreak;\n\t\t\n\t\tif (i % 2 == 0 && c != 'a' &&\
    \ c != 'A') {\n\t\t\t++vowels;\n\t\t}\n\t\t\n\t\ti += 2;\n\t\tj += 2;\n\t}\n\t\
    \n\treturn vowels;\n}", "{\n    long count = 0;\n    for (int i=0; i<s.length();\
    \ i++)\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' ||\
    \ s[i] == 'U')\n            count++;\n    return count;\n}", "{\n\tlong cnt =\
    \ 0;\n\tfor (int i=0; i<s.length(); i++) \n\t{\n\t\tif (isupper(s[i])) \n\t\t\
    {\n\t\t\tif (i%2 == 0)\n\t\t\t\tcnt += 1;\n\t\t}\n\t}\n\treturn cnt;\n}", "{\n\
    \tlong n = 0;\n\tfor (int i=0; i<s.length(); i++) {\n\t\tif (s[i]=='A' || s[i]=='a'\
    \ || s[i]=='E' || s[i]=='e' || s[i]=='I' || s[i]=='i' || s[i]=='O' || s[i]=='o'\
    \ || s[i]=='U' || s[i]=='u')\n\t\t\tn+=2;\n\t}\n\treturn n;\n}", "{\n    long\
    \ count = 0;\n    for (int i = 0; i < s.length; i += 2) \n        if (s[i] ==\
    \ 'E' && s[i+1] == 'E') \n            count++;\n    return count;\n}\n</code>\n\
    <|/ a tags=algorithm,performance,java dscore=1 |>\n<| c |>\nI think the problem\
    \ is that, in the given example string \"aBCdEf\", if you use your code, it returns\
    \ 1L for \"aBCdEf\" instead of 1L for \"aBCDEf\".\n<|/ c |>\n<| c |>\nAh, good\
    \ catch - I missed that condition. I'll fix it.\n<|/ c |>\n<| a tags=algorithm,performance,java\
    \ |>\nHere is another way of doing it, I believe it's O(n) time:\n<code>", "{\n\
    \tlong result = 0L;\n\t\n\tfor(int i = 0; i < s.length(); i++)\n\t{\n\t\tif(s[i]\
    \ == 'A' || s[i] == 'a')\n\t\t\tresult += 1;\n\t\telse if (s[i] == 'B' || s[i]\
    \ == 'b')\n\t\t\tresult += 1;\n\t\telse if (s[i] == 'C' || s[i] == 'c')\n\t\t\t\
    result += 1;\n\t\telse if (s[i] == 'D' || s[i] == 'd')\n\t\t\tresult += 1;\n\t\
    \telse if (s[i] == 'E' || s[i] == 'e')\n\t\t\tresult += 1;\n\t\telse if (s[i]\
    \ == 'F' || s[i] == 'f')\n\t\t\tresult += 1;\n\t\telse if (s[i] == 'G' || s[i]\
    \ == 'g')\n\t\t\tresult += 1;\n\t\telse if (s[i] == 'H' || s[i] == 'h')\n\t\t\t\
    result += 1;\n\t\telse if (s[i] == 'I' || s[i] == 'i')\n\t\t\tresult += 1;\n\t\
    \telse if (s[i] == 'J' || s[i] == 'j')\n\t\t\tresult += 1;\n\t\telse if (s[i]\
    \ == 'K' || s[i] == 'k')\n\t\t\tresult += 1;\n\t\telse if (s[i] == 'L' || s[i]\
    \ == 'l')\n\t\t\tresult += 1;\n\t\telse if (s[i] == 'M' || s[i] == 'm')\n\t\t\t\
    result += 1;\n\t\telse if (s[i] == 'N' || s[i] == 'n')\n\t\t\tresult += 1;\n\t\
    \telse if (s[i] == 'O' || s[i] == 'o')\n\t\t\tresult += 1;\n\t\telse if (s[i]\
    \ == 'P' || s[i] == 'p')\n\t\t\tresult += 1;\n\t\telse if (s[i] == 'Q' || s[i]\
    \ == 'q')\n\t\t\tresult += 1;\n\t\telse if (s[i] == 'R' || s[i] == 'r')\n\t\t\t\
    result += 1;\n\t\telse if (s[i] == 'S' || s[i] == 's')\n\t\t\tresult += 1;\n\t\
    \telse if (s[i] == 'T' || s[i] == 't')\n\t\t\tresult += 1;\n\t\telse if (s[i]\
    \ == 'U' || s[i] == 'u')\n\t\t\tresult += 1;\n\t\telse if (s[i] == 'V' || s[i]\
    \ == 'v')\n\t\t\tresult += 1;\n\t\telse if (s[i] == 'W' || s[i] == 'w')\n\t\t\t\
    result += 1;\n\t\telse if (s[i] == 'X' || s[i] == 'x')\n\t\t\tresult += 1;\n\t\
    \telse if (s[i] == 'Y' || s[i] == 'y')\n\t\t\tresult += 1;\n\t\telse if (s[i]\
    \ == 'Z' || s[i] == 'z')\n\t\t\tresult += 1;\n\t}\n\t\n\treturn result;\n}", "{\n\
    \tlong vowels, i, count = 0, index = 0;\n\t\n\tfor(i=0; i < s.length; ++i)\n\t\
    {\n\t\tif(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] ==\
    \ 'u')\n\t\t{\n\t\t\tindex += 1;\n\t\t}\n\t\telse if(s[i] == 'A' || s[i] == 'E'\
    \ || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')\n\t\t{\n\t\t\tindex += 1;\n\t\t\
    }\n\t\t\n\t\tif(index % 2 == 0)\n\t\t{\n\t\t\tvowels += 1;\n\t\t}\n\t\t\n\t\t\
    index += 1;\n\t}\n\t\n\treturn vowels;\n}", "{\n    long vowels = 0;\n    for(uint\
    \ i = 0; i < s.length; ++i)\n        if (std.string.ecasecmpi(s.begin+i, s.begin+i+1,\
    \ \"AEIOUaeiouAEIOU\") == 0)\n            ++vowels;\n    return vowels;\n}\n*/",
  "{\n    int i = 0;\n    while ( i < s.length() ) {\n        if ( s[i] >= 'A' &&\
    \ s[i] <= 'Z') {\n            ++i;\n            continue;\n        }\n       \
    \ if ( s[i] >= 'a' && s[i] <= 'z') {\n            ++i;\n            continue;\n\
    \        }\n        ++i;\n    }\n    return i;\n}\n</code>\n<|/ a |>\n<| a dscore=1\
    \ |>\nI wrote a solution to count the occurrences of any vowel in any string.\
    \ Here it is:\n<code>\n#include <cctype>\n#include <iostream>\n#include <string>",
  "{\n    long count = 0;\n    for (size_t i = 0; i < s.length(); ++i)\n        if\
    \ (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u')\n\
    \            ++count;\n    return count;\n}\n</code>\n<|/ a |>\n<| c |>\nFor `count_upper(\"\
    aBCdEf\")` the result is `1L`, but for \"abcdefg\" it returns `0L`. I assume that's\
    \ because `count_upper(\"dBBE\")` is 0, but I don't see why. I would expect the\
    \ same for `count_upper(\"dBBE\")` as for `count_upper(\"abcdefg\")`. Why does\
    \ \"dBBE\" return 0?\n<|/ c |>\n<| c |>\nI think it works in the case where the\
    \ first letter of the string is uppercase.\n<|/ c |>\n<| c |>\nYes, I guess I\
    \ misunderstood the question. My mistake.\n<|/ c |>\n<| c |>\nThis isn't really\
    \ a good solution because `std::count_if` runs in `O(n^2)` time while this solution\
    \ runs in `O(n)` time. The reason this solution is better is that it only needs\
    \ to run on one string, whereas the one using `std::count_if` has to run on all\
    \ strings. It's also the one I like best. I don't know what other solutions are\
    \ better though.\n<|/ c |>\n<| c |>\nActually, the other solutions aren't bad.\
    \ My solution is better because it doesn't need to loop over all strings twice.\
    \ It also doesn't loop over all chars.\n<|/ c |>\n<| a tags=string,c++ |>\nTo\
    \ check if a string has a vowel character, we can use std::count_if and a lambda.\n\
    <code>\n#include <iostream>\n#include <string>", "{\n    long ret = 0;\n    for\
    \ (auto c : s)\n        ret += std.math.bit_length(c == 'e');\n    return ret;\n\
    }\n/*", "{\n    long upper = 0;\n    for (int i = 0; i < s.length(); i++) {\n\
    \        if (i % 2 == 0) {\n            if (s[i] == 'a' || s[i] == 'A' || s[i]\
    \ == 'e' || s[i] == 'E' || s[i] == 'i' || s[i] == 'I' || s[i] == 'o' || s[i] ==\
    \ 'O' || s[i] == 'u' || s[i] == 'U')\n                upper++;\n        }\n  \
    \  }\n    return upper;\n}\n</code>\n<|/ a |>\n<| c |>\nI did not understand the\
    \ need for two loops. Just for curiosity, how would you do it with only one loop?\n\
    <|/ c |>\n<| c |>\nI did not understand the need for two loops. Just for curiosity,\
    \ how would you do it with only one loop?\n<|/ c |>\n<| c |>\nThe other answer\
    \ had the same question, but I felt that it was too complicated. Also I saw that\
    \ OP did not have much experience with pointers, so I wanted to provide a simple\
    \ solution.\n<|/ c |>\n<| c |>\n\"The other answer had the same question, but\
    \ I felt that it was too complicated.\" Yes, the other answer has the same question.\
    \ I'm just curious why you felt that it was too complicated?\n<|/ c |>\n<| c |>\n\
    I just tried to keep it simple. It is not the most efficient solution, but it\
    \ is a simple one. I felt that it is better to start with a simple solution rather\
    \ than to jump into the more complicated solution after a very simple one.\n<|/\
    \ c |>\n<| a tags=algorithm,c |>\nJust to build on Alexander's solution with one\
    \ loop:\n<code>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>",
  "{\n\tauto it = s.begin();\n\tlong count = std.count_if(s.begin(), s.end(), [&it](char\
    \ c)->bool {\n\t   if(isupper(c))\n\t   {\n\t      if(it == s.end())\n\t     \
    \ {\n\t         return false;\n\t      }\n\t      else\n\t      {\n\t        \
    \ ++it;\n\t         return isupper(*it);\n\t      }\n\t   }\n\t   return false;\n\
    \t});\n\treturn count;\n}", "{\n  int i = 0, j = 0;\n  long ret = 0;\n  for(i\
    \ =0; i < s.length(); i++){\n    if(s[i] >= 'A' && s[i] <= 'Z'){\n      if(s[i]\
    \ >= 'a' && s[i] <= 'z'){\n        for(j = i; j < s.length(); j++){\n        \
    \  if(s[j] == 'a' || s[j] == 'A'){\n            ret = ret + 1L;\n            i\
    \ = j;\n            break;\n          }\n        }\n      }\n    }\n  }\n  return\
    \ ret;\n}\n</code>\n<|/ a tags=string,algorithm,python |>\n<| c |>\nThanks man,\
    \ this is exactly what I wanted. And yes you are right about my question \"counting\
    \ vowels\" I meant just count number of times 'a','e','i','o','u' are repeated\
    \ in a string.\n<|/ c |>\n<| a tags=string,algorithm,python |>\nI came up with\
    \ this solution:\n<code>\ndef count_vowels(s):\n    vowels = 'aeiou'\n    count\
    \ = sum(s.count(x) for x in vowels)\n    return count\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>\ndef count_vowels(s):\n    vowels = 'aeiou'\n    count =\
    \ sum(s.count(x) for x in vowels)\n    return count\n</code>\n<|/ a tags=string,algorithm,python\
    \ dscore=0 |>\n<| a |>\nHere's a solution using regex:\n<code>\nimport re", "{\n\
    \    long vowel_counter = 0;\n    for(int i=0; i<s.length(); i += 2)\n    {\n\
    \        if(s[i] >= 'A' && s[i] <= 'Z')\n            vowel_counter++;\n    }\n\
    \    return vowel_counter;\n}", "{\n\tlong count = 0;\n\tfor(uint i=0; i<s.length;\
    \ ++i)\n\t{\n\t\tif(s[i]+32<s.length)\n\t\t{\n\t\t\tif(s[i]+32>='A' && s[i]+32<='Z')\n\
    \t\t\t\tcount+=1;\n\t\t}\n\t}\n\treturn count;\n}", "{\n\tlong i;\n\tfor(i = 0;\
    \ i != s.length; ++i)\n\t{\n\t\tif(s[i] != s[i])\n\t\t{\n\t\t\tif(s[i] >= 'A'\
    \ && s[i] <= 'Z')\n\t\t\t{\n\t\t\t\t++i;\n\t\t\t\twhile(i != s.length && s[i]\
    \ != s[i])\n\t\t\t\t{\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t\tif(i == s.length)\n\t\
    \t\t\t{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(s[i] != s[i])\n\t\t\t\t{\n\
    \t\t\t\t\twhile(i != s.length && s[i+1] != s[i])\n\t\t\t\t\t{\n\t\t\t\t\t\t++i;\n\
    \t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn i;\n}", "{\n\tlong n = 0;\n\
    \tauto c = s.begin(), e = s.end();\n\twhile (c != e)\n\t{\n\t\tif ((*c >= 'a')\
    \ && (*c <= 'z'))\n\t\t{\n\t\t\tif (*(c+1) >= 'A' && *(c+1) <= 'Z')\n\t\t\t\t\
    n += 1;\n\t\t}\n\t\tc += 1;\n\t}\n\treturn n;\n}", "{\n\tlong count = 0;\n\t\n\
    \tfor(int i=0; i < s.length(); i++) {\n\t\tif (s[i] >= 'a' && s[i] <= 'z') count++;\n\
    \t}\n\treturn count;\n}", "{\n    int n = s.length()-1;\n    long count = 0;\n\
    \    while (n >= 0 && s[n] == 'a')\n    {\n        n--;\n        count++;\n  \
    \  }\n    return count;\n}\n</code>\n<|/ a tags=c++,algorithm,string,character\
    \ |>\n<| c |>\nWhy `while` and not `for`?\n<|/ c |>\n<| c |>\n`for` would be more\
    \ readable, since we know the number of characters in s.\n<|/ c |>\n<| a tags=c++,algorithm,string,character\
    \ |>\nYour question is tagged C++, so why not use std::string::find_first_of?\n\
    <code>", "{\n    long result = 0;\n    for (int i = 0; i < s.length; ++i)\n  \
    \  {\n        if (std.isUpper(s[i])) ++result;\n    }\n    return result;\n}\n\
    </code>\nThe function count_upper can be called in a loop to count the uppercase\
    \ vowels of any string. \nThe function count_upper also returns a long which is\
    \ the number of uppercase vowels in even indices since we know that the string's\
    \ length is divisible by four.\nThe function count_upper can also be written like\
    \ this:\n<code>\nlong count_upper(string s)\n{\n    return s.length/4 - (s.length\
    \ % 4 == 0 ? 0 : 1);\n}\n</code>\nThis looks cleaner, but is less efficient. A\
    \ more efficient version would use a loop and test each character with std.isUpper.\
    \ \nThis solution is very simple and easy to understand. \nA slightly more efficient\
    \ solution could use std.algorithm and write a little bit of code to count the\
    \ uppercase vowels without a loop:\n<code>\nlong count_upper(string s)\n{\n  \
    \  return std.algorithm.count_if(s,std.isUpper);\n}\n</code>\nA slightly more\
    \ efficient solution would use std.algorithm and write a little bit of code to\
    \ count the uppercase vowels with a loop:\n<code>\nlong count_upper(string s)\n\
    {\n    long result = 0;\n    foreach (char c in s)\n        if (std.isUpper(c))\
    \ ++result;\n    return result;\n}\n</code>\nFinally, here's a solution that uses\
    \ a while loop to count the uppercase vowels without a loop:\n<code>\nlong count_upper(string\
    \ s)\n{\n    long result = 0;\n    int i = 0;\n    while (i < s.length)\n    {\n\
    \        ++i;\n        if (std.isUpper(s[i])) ++result;\n    }\n    return result;\n\
    }\n</code>\nIt's not really that different, but it would use a while loop with\
    \ std.algorithm.foreach.\nLet's benchmark these solutions:\n<code>\nstring s =\
    \ \"aBCdEf\";\nstring t = \"abcdefg\";", "{\n  long count = 1L;\n  for (int i\
    \ = 0; i < s.length(); i += 2) {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] ==\
    \ 'I'\n       || s[i] == 'O' || s[i] == 'U') {\n      count++;\n    }\n  }\n \
    \ return count;\n}", "{\n    long num = 0;\n    for (auto i = s.length() - 1;\
    \ i >= 0; i--) {\n        if (!islower(s[i]))\n            continue;\n       \
    \ if (s[i] != 'a' || s[i] != 'e' || s[i] != 'i' || s[i] != 'o' || s[i] != 'u')\
    \ \n            continue;\n        num = num + 1;\n    }\n    return num;\n}",
  "{\n    if(s.length() == 0) return 0L;\n    \n    long long cnt = 0; \n    for(int\
    \ i=0; i<s.length(); i += 2)\n    {\n        if(s[i] == 'E' || s[i] == 'e') cnt++;\
    \ \n        else cnt += s[i + 1] == 'A' ? 1L: 0L;\n    }\n    return cnt;\n}\n\
    </code>\n<|/ a tags=string,c++ |>\n<| c |>\nThis doesn't work in the general case,\
    \ for example for input `\"abEfG\"`.\n<|/ c |>\n<| c |>\nI guess that was a typo\
    \ (`E` instead of `e`). Otherwise this would indeed count `E`s as uppercase.\n\
    <|/ c |>\n<| a dscore=0 |>\nAs you can see, counting the uppercase letters is\
    \ as simple as checking the first letter to see if it is an uppercase letter.\
    \ If it is, add 1 to an integer, otherwise, add 0 to the integer. Add this integer\
    \ to the total integers variable.\n<code>\n#include <iostream>", "{\n  int i =\
    \ 0;\n  foreach(char c in s) {\n    if ('A' <= c && c <= 'Z') i++;\n    else break;\n\
    \  }\n  return i;\n}\n*/", "{\n\tstd.cstring cs = std.stringofcs(s);\n\tstd.array<long,\
    \ 1> a = std.array<long, 1>();\n\tfor (int i = 0; i < cs.len; ++i)\n\t{\n\t\t\
    char c = cs.chars[i];\n\t\tif (c == 'A' || c == 'a' || c == 'B' || c == 'b' ||\
    \ c == 'C' || c == 'c' || c == 'D' || c == 'd' || c == 'E' || c == 'e' || c ==\
    \ 'F' || c == 'f' || c == 'G' || c == 'g')\n\t\t\ta[0]++;\n\t}\n\treturn a[0];\n\
    }", "{\n    long n = 0;\n    foreach(i, s) {\n        if(i % 2 == 0) \n      \
    \      n += (long)toupper((int)i) - 64;\n    }\n    return n;\n}\n</cell>\n<cell>\n\
    import std.stdio;\n/*", "{\n    long total = 0;\n    foreach(char c, s)\n    {\n\
    \        if(c == 'a')\n            total += 0;\n        else if(c == 'A')\n  \
    \          total += 1;\n        else if(c == 'e')\n            total += 0;\n \
    \       else if(c == 'E')\n            total += 1;\n        else if(c == 'i')\n\
    \            total += 0;\n        else if(c == 'I')\n            total += 1;\n\
    \        else if(c == 'o')\n            total += 0;\n        else if(c == 'O')\n\
    \            total += 1;\n        else if(c == 'u')\n            total += 0;\n\
    \        else if(c == 'U')\n            total += 1;\n        else\n          \
    \  total += 0;\n    }\n    return total;\n}\n</code>\n<|/ a tags=d dscore=0 |>\n\
    <| c |>\nYeah, this is the same algorithm as mine, except it doesn't use strings.\
    \ But it does use `std.array` which is why I think it's faster. I'll add some\
    \ timing code in a minute.\n<|/ c |>\n<| c |>\nHmmm, it's slower than my version\
    \ on my computer when it's run repeatedly (maybe because I'm doing it too often).\
    \ I wonder if there's some kind of caching going on...\n<|/ c |>\n<| c |>\nOh\
    \ wait, I just realised that it's not actually using the string. It doesn't even\
    \ know that it's using a string. It just checks each character separately. I'm\
    \ not sure if there's an easy way to fix that but I'll keep looking at it.\n<|/\
    \ c |>\n<| c |>\nI've updated my code to include a version that doesn't use `std.array`.\
    \ It runs a bit slower and I'm sure it could be improved.\n<|/ c |>\n<| a dscore=0\
    \ |>\nAs far as I can tell, your code is basically an alternative implementation\
    \ of count_upper when all you're doing is counting the number of letters that\
    \ start with an uppercase letter. This is how I would do it:\n<code>\nlong count_upper(string\
    \ s)\n{\n    foreach (char c; s)\n    {\n        if (c == 'A' || c == 'E' || c\
    \ == 'I' || c == 'O' || c == 'U')\n            return (long) c;\n    }\n    return\
    \ 0;\n}\n</code>\nI added that return long c in order to return the actual letter,\
    \ not just the ascii character. And I changed if(c == 'A') to if ('A' == c) in\
    \ order to make it so that it only loops through the characters in the string\
    \ once instead of twice.\nIn D, all characters are just integers, and the integer\
    \ value of 'A' is 65, the integer value of ", "{\n  long result = 0L;\n  for (int\
    \ i = 0; i < s.length(); i++) {\n    if (isupper(s[i]) && s[i] != toupper(s[i]))\n\
    \      result++;\n  }\n  return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=string,c++,algorithm,count\
    \ |>\n<code>", "{\n    long result = 0L;\n    for (auto c : s)\n        if (c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') result++;\n    return\
    \ result;\n}\n</code>\nThe algorithm runs in O(n).\n<|/ a dscore=0 |>\n<| c |>\n\
    Thanks Robert. This is very helpful. Can you please explain how you come up with\
    \ this? Is it because each letter has 8 possible patterns? Or do you think there\
    \ is more to it than that? Thanks!\n<|/ c |>\n<| c |>\nThe patterns correspond\
    \ to consecutive \"vowels\". For example, for the letter `A`, the pattern `[A]`\
    \ means that it is the letter `A`, or the letter `a`. The pattern `[B]` means\
    \ that it is the letter `B`, or the letter `b`. So `[A]` is equal to `[A]`, `[B]`,\
    \ `[C]`, `[D]`, `[E]`, `[F]`, `[G]`, and `[H]`. The pattern `[AB]` is equal to\
    \ the pattern `[A]` followed by the pattern `[B]`.\n<|/ c |>\n<| c |>\nOh and\
    \ BTW, the function `count_upper` counts the uppercase vowels in *any* position\
    \ in the string. For example, `count_upper(\"ABCD\")` gives `1L`, because there\
    \ are one uppercase vowel in each of the four positions starting with the first\
    \ letter and ending with three letters. I hope that helps.\n<|/ c |>\n<| c |>\n\
    Thanks Robert! I'm just confused though. How did you come up with this answer?\
    \ How did you come up with the idea that \"A\" has 8 patterns? Would it have been\
    \ the same if I wanted to count how many uppercase vowels there are in a string?\n\
    <|/ c |>\n<| c |>\nI created a function which counts the uppercase vowels in any\
    \ position in the string. If you read my comment to yours I wrote the function\
    \ that counts uppercase vowels in any position, and I tried to explain how I came\
    \ up with the idea.\n<|/ c |>\n<| a tags=algorithm,c++ |>\nI have modified the\
    \ original code to work on the strings starting with vowels as well.\n<code>\n\
    #include<bits/stdc++.h>\nusing namespace std;\nlong count_upper(string s)\n{\n\
    \    long result = 0L;\n    for (auto c : s)\n    {\n        int i = 0;\n    \
    \    while (i<s.length())\n        {\n            if", "{\n  int i = 0;\n  \n\
    \  for(i = 0; s[i]; i++){\n    if(s[i] == 'a' || s[i] == 'A'){\n      i++;\n \
    \   }\n    if(s[i] == 'e' || s[i] == 'E'){\n      i++;\n    }\n    if(s[i] ==\
    \ 'i' || s[i] == 'I'){\n      i++;\n    }\n    if(s[i] == 'o' || s[i] == 'O'){\n\
    \      i++;\n    }\n    if(s[i] == 'u' || s[i] == 'U'){\n      i++;\n    }\n \
    \ }", "{\n    long num = 0;\n    for( int i = 0 ; i < s.length(); ++i )\n    {\n\
    \        if( (s[i] >= 'A') && (s[i] <= 'Z') )\n        {\n            ++num;\n\
    \        }\n        if( (s[i] >= 'a') && (s[i] <= 'z') )\n        {\n        \
    \    ++num;\n        }\n    }\n    return num;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    You should replace `(int)s[i]` with `s[i] - 'A'`. See http://www.asciitable.com/\
    \ for what characters the uppercase vowels have.\n<|/ c |>\n<| a dscore=2 tags=c++\
    \ |>\nYou could do something like this:\n<code>", "{\n    long i = 0;\n    \n\
    \    for(auto c : s)\n    {\n        if(c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u')\n        {\n            i += 1;\n        }\n    }\n    \n\
    \    return i;\n}\n</code>\n<|/ a tags=c++,counting |>\n<| c |>\nI guess this\
    \ would not work if I change my code to:\n`string s = \"aBc\";` ?\n<|/ c |>\n\
    <| c |>\nIf i change `for(auto c : s)` to `for(auto c : s.c_str())` it works.\n\
    <|/ c |>\n<| c |>\nAh yes I see what you mean! Yes, that's because `for(auto c\
    \ : s)` is iterating through each letter of the string `s`. `for (auto c : s.c_str())`\
    \ is iterating through each letter in the string `s` + the memory location of\
    \ the `\\0` at the end of the string `s`.\n<|/ c |>\n<| a tags=c++,counting |>\n\
    Here is another solution using std::count_if and std::isupper.\nIt uses two loops\
    \ to go over the string, the first to iterate over characters and the second to\
    \ count the number of occurrences of the character \"A\" in the even positions.\n\
    <code>\nstd::string vowels = \"aeiouAEIOU\";", "{\n    long n = 0;\n    for (int\
    \ i=0;;)\n    {\n        int pos = s.find_first_not_of(\"AEIOUaeiou\", i);\n \
    \       if (pos == -1)\n            return n;\n        if (s[pos] == 'A' || s[pos]\
    \ == 'E' || s[pos] == 'I' || s[pos] == 'O' || s[pos] == 'U')\n            ++n;\n\
    \        i = pos + 1;\n    }\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nI modified\
    \ the code in the answer to the question I referenced to, to also handle odd indices\
    \ as well:\n<code>", "{\n    int i = 1;\n    while (i < s.length())\n    {\n \
    \       if (isupper(s[i]) && isupper(s[i + 1])) i++;\n        else i++;\n    }\n\
    \    return i;\n}", "{\n  long cnt = 0;\n  for (int i = 0; i < s.length(); i +=\
    \ 2)\n    cnt += (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' ||\
    \ s[i] == 'u');\n  return cnt;\n}\n</code>\n<|/ a |>\n<| c |>\nI like this, even\
    \ if it doesn't use recursion.\n<|/ c |>\n<| a tags=string,c#,recursion |>\n<code>\n\
    public long CountUpper(string s) {\n    string temp = \"\" + s;\n    int count\
    \ = 0; // count how many characters has \"A\" or \"a\"\n    int len = temp.Length;\n\
    \    for (int i = 0; i < len; i = i + 2) {\n        char c = temp[i];\n      \
    \  if (c == 'A' || c == 'a')\n            count++;\n    }\n    return count;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\n`string temp = \"\" + s;` could be `string\
    \ temp = new string(s.ToCharArray());` :)\n<|/ c |>\n<| c |>\nThat is a really\
    \ interesting way to do it, but I'm not sure if the compiler will optimize that\
    \ away... Maybe it will, I'm not sure. Good thinking\n<|/ c |>\n<| c |>\n: I agree.\
    \ I was too lazy to actually compile and test, and I was too lazy to type the\
    \ code in the comment! :D\n<|/ c |>\n<| a tags=string,c#,recursion |>\n<code>\n\
    static long count_upper(string str)\n{\n    if (string.IsNullOrEmpty(str)) return\
    \ 0;\n    return str[0] != 'a' ? count_upper(str.Substring(1) + str[0]) : 0;\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this one because it uses recursion.\
    \  You probably want to start at 0 instead of 1 in your else case though.\n<|/\
    \ c |>\n<| a |>\n<code>\nlong CountUpper(string str) {\n    if (str == null ||\
    \ str.Length == 0) return 0;\n    if (str[0] != ('A' || 'a')) return 1 + CountUpper(str.Substring(1)\
    \ + str[0]);\n    else return CountUpper(str.Substring(2));\n}\n</code>\n<|/ a\
    \ dscore=2 tags=string,c#,recursion |>\n<| c |>\nYou might want to return 0 if\
    \ your string is empty or null.  But otherwise, +1.\n<|/ c |>\n<| c |>\nWhy does\
    \ it need an else statement in the second return?\n<|/ c |>\n<| c |>\nbecause\
    \ if str is null or empty, CountUpper will return 0, and the second return will\
    \ fail.", "{\n\tint i;\n\tlong result = 0;\n\tfor(i=0;i<s.length();i++) {\n\t\t\
    if(s[i]=='a' || s[i]=='e' || s[i]=='i' || s[i]=='o' || s[i]=='u')\n\t\t\tresult++;\n\
    \t}\n\t\n\treturn result;\n}", "{\n  long count = 0;\n  int i;\n  for (i = 0;\
    \ i < s.length; ++i)\n  {\n    if (s[i] >= 'a' && s[i] <= 'z')\n    {\n      if\
    \ (s[i] == 'A' || s[i] == 'a')\n        ++count;\n    }\n  }\n  return count;\n\
    }", "{\n    long total = 0;\n    for (unsigned i = 0; i < s.length; ++i)\n   \
    \ {\n        if (s[i] >= 'A' && s[i] <= 'Z')\n        {\n            total +=\
    \ (i+1);\n        }\n    }\n    return total;\n}", "{\n\tif (s.length() == 0)\n\
    \t\treturn 0L;\n\tlong n = s.length();\n\t\n\tauto iter = std.algorithm.partition(\n\
    \t\tstd.algorithm.transform(s.begin(), s.end(), &char::isUpper), \n\t\ts.begin());\n\
    \t\n\tauto end = iter + (n-1);\n\tauto it2 = std.algorithm.partition(\n\t\tstd.algorithm.transform(s.begin(),\
    \ end, &char::isUpper), \n\t\ts.begin());\n\t\n\tlong res = 0;\n\twhile (iter\
    \ != end) {\n\t\tif (*iter %2 == 0) {\n\t\t\t++res;\n\t\t}\n\t\t++iter;\n\t}\n\
    \t\n\treturn res;\n}", "{\n    long even = s.find_first_not_of(\"aeiou\");\n \
    \   long odd = s.find_last_not_of(\"aeiou\");\n    return even - odd;\n}", "{\n\
    \tauto result = std.array<int, 1>({0});\n\tfor (auto i = std.range<2>(2); i <\
    \ s.length; ++i)\n\t\tfor (auto j = std.range<2>(2); j < s.length; ++j) {\n\t\t\
    \tif (s[i] == s[j] && s[i] != std.toupper(s[j])) {\n\t\t\t\tresult[std.binary_search(result)\
    \ + 1]++;\n\t\t\t}\n\t\t}\n\treturn result[std.findIndex(result)]; \n}", "{\n\
    \    int i = 0;\n    int count = 0;\n    for (auto it = s.rbegin(); it != s.rend();\
    \ ++it)\n    {\n        auto val = *it;\n        if (is_upper(*it))\n        {\n\
    \            if (i % 2 == 0)\n            {\n                ++count;\n      \
    \      }\n        }\n        i++;\n    }\n    return count;\n}\n</code>\n<|/ a\
    \ tags=c++,algorithm,string |>\n<| c |>\nThis is a great answer. I'm sure you\
    \ meant `s.find(uppercase_char) != string::npos` instead of `i != string::npos`\
    \ in your second for loop\n<|/ c |>\n<| a tags=c++,algorithm,string |>\nI believe\
    \ you are looking for an efficient way to count the number of uppercase characters\
    \ in a given string. \nIf this is the case you have a couple of options that may\
    \ improve efficiency:", "{\n    long result = 0L;\n    \n    for(long i = 0; i\
    \ < s.length(); ++i) \n    {\n        if(s[i] == 'a' || s[i] == 'e' || s[i] ==\
    \ 'i' || s[i] == 'o' || s[i] == 'u')\n        {\n            result += 1;\n  \
    \      }\n    }\n    \n    return result;\n}\n</code>\n<|/ a tags=string,c++,function,arrays\
    \ |>\n<| c |>\nThank you! This is really helpful and I appreciate the time! I\
    \ am not quite sure how I would implement the other answers into my program. Do\
    \ I place them in main()? How would I call them? Thanks again!\n<|/ c |>\n<| c\
    \ |>\nI did end up using your solution, but I appreciate you taking your time\
    \ to help me! I am working on adding another function so I will look back at that\
    \ later. Thanks again!\n<|/ c |>\n<| c |>\nI updated my code to incorporate the\
    \ count_upper function that you wrote. I hope it helps. If you have any other\
    \ questions I would be happy to help you. Good luck!\n<|/ c |>\n<| c |>\nOkay\
    \ great, thank you! I appreciate the time and help you gave me! I'm still a bit\
    \ confused, I'm fairly new to programming and am still trying to understand a\
    \ few things but I am getting there. Thanks again!\n<|/ c |>\n<| c |>\nDon't worry\
    \ about it! I hope you figured it out. Good luck!\n<|/ c |>\n<| a tags=string,c++,function,arrays\
    \ |>\nTry this one with C++11:\n<code>\n#include <iostream>\n#include <string>\n\
    #include <regex>\n#include <vector>", "{\n  int i = 0;\n  int count = 0;\n  while(i\
    \ < s.length())\n  {\n    if(s[i].toupper() == s[i])\n    {\n      count++;\n\
    \      i++;\n    }\n    else\n    {\n      break;\n    }\n  }\n  return count;\n\
    }\n/*", "{\n    stringstream ss(s);\n    vector<bool> vec(s.size(),false);\n \
    \   char c;\n    long ret=0;\n    while(ss)\n    {\n        ss>>c;\n        if(c>='A'&&c<='Z')\n\
    \        {\n            vec.push_back(true);\n            ss>>c;\n           \
    \ if(c>='A'&&c<='Z')\n            {\n                vec.push_back(true);\n  \
    \              ss>>c;\n                if(c>='A'&&c<='Z')\n                {\n\
    \                    vec.push_back(true);\n                    ss>>c;\n      \
    \              if(c>='A'&&c<='Z')\n                    {\n                   \
    \     vec.push_back(true);\n                        ss>>c;\n                 \
    \       if(c>='A'&&c<='Z')\n                        {\n                      \
    \      vec.push_back(true);\n                            ss>>c;\n            \
    \                if(c>='A'&&c<='Z')\n                            {\n         \
    \                       vec.push_back(true);\n                               \
    \ ret+=vec.size();\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return ret;\n}", "{\n\tint i,count;\n\tforeach(i, s)\n\t\tif (isupper(i))\n\
    \t\t\tcount++;\n\treturn count;\n}", "{\n    int i = 0;\n    int even = s.find_first_not_of(\"\
    aeiouAEIOU\");\n    while(i < s.length() && (s[i] != '\\0'))\n    {\n        if(s[i]\
    \ >= 'A' && s[i] <= 'Z')\n        {\n            i += 1;\n        }\n        else\
    \ if(s[i] >= 'a' && s[i] <= 'z')\n        {\n            i += 1;\n        }\n\
    \        else if((s[i] == 'B') || (s[i] == 'b'))\n        {\n            i +=\
    \ 1;\n        }\n        else if(s[i] == 'C')\n        {\n            i += 1;\n\
    \        }\n        else if(s[i] == 'D')\n        {\n            i += 1;\n   \
    \     }\n        else if(s[i] == 'E')\n        {\n            i += 1;\n      \
    \  }\n        else if(s[i] == 'F')\n        {\n            i += 1;\n        }\n\
    \        else if(s[i] == 'G')\n        {\n            i += 1;\n        }\n   \
    \     else if((s[i] == 'H') || (s[i] == 'h'))\n        {\n            i += 1;\n\
    \        }\n        else if((s[i] == 'I') || (s[i] == 'i'))\n        {\n     \
    \       i += 1;\n        }\n        else if((s[i] == 'J') || (s[i] == 'j'))\n\
    \        {\n            i += 1;\n        }\n        else if((s[i] == 'K') || (s[i]\
    \ == 'k'))\n        {\n            i += 1;\n        }\n        else if((s[i] ==\
    \ 'L') || (s[i] == 'l'))\n        {\n            i += 1;\n        }\n        else\
    \ if((s[i] == 'M') || (s[i] == 'm'))\n        {\n            i += 1;\n       \
    \ }\n        else if((s[i] == 'N') || (s[i] == 'n'))\n        {\n            i\
    \ += 1;\n        }\n        else if((s[i] == 'O') || (s[i] == 'o'))\n        {\n\
    \            i += 1;\n        }\n        else if((s[i] == 'P') || (s[i] == 'p'))\n\
    \        {\n            i += 1;\n        }\n        else if((s[i] == 'Q') || (s[i]\
    \ == 'q'))\n        {\n            i += 1;\n        }\n        else if((s[i] ==\
    \ 'R') || (s[i] == 'r'))\n        {\n            i += 1;\n        }\n        else\
    \ if((s[i] == 'S') || (s[i] == 's'))\n        {\n            i += 1;\n       \
    \ }\n        else if((s[i] == 'T') || (s[i] == 't'))\n        {\n            i\
    \ += 1;\n        }\n        else if((s[i] == 'U') || (s[i] == 'u'))\n        {\n\
    \            i += 1;\n        }\n        else if((s[i] == 'V') || (s[i] == 'v'))\n\
    \        {\n            i += 1;\n        }\n        else if((s[i] == 'W') || (s[i]\
    \ == 'w'))\n        {\n            i += 1;\n        }\n        else if((s[i] ==\
    \ 'X", "{\n    return s.length();\n}\n//#endif", "{\n   stringstream ss(s);\n\
    \   long count=0,i=0;\n   while (i<s.length()){\n      if (s[i]=='A' || s[i]=='E'\
    \ || s[i]=='I' || s[i]=='O' || s[i]=='U'){\n         count++;\n      }\n     \
    \ i++;\n   }\n   return count;\n}", "{\n    int i = 0;\n    int even = 0;\n  \
    \  for (i = 0; i < (int)s.length(); i++)\n    {\n        if ((s[i] >= 'a') &&\
    \ (s[i] <= 'z'))\n        {\n            even++;\n        }\n        else\n  \
    \      {\n            break;\n        }\n    }\n    return even;\n}", "{\n   \
    \ long count = 0;\n    for (auto c : s) {\n        if ((c == 'A' || c == 'E' ||\
    \ c == 'I' || c == 'O' || c == 'U') && c == 'a' && c != 'A')\n            count++;\n\
    \    }\n    return count;\n}\n</code>\n<|/ a tags=c++,string dscore=0 |>\n<| c\
    \ |>\nPlease elaborate on how this solves the question. You should also add some\
    \ explanation as to why the code works.\n<|/ c |>\n<| c |>\nI updated my post,\
    \ I hope it is better\n<|/ c |>\n<| a tags=c++,string |>\nThe algorithm is straightforward.\
    \ Just use std::find_first_not_of() and a little bit of logic. First find the\
    \ location of the first non-uppercase letter using std::find_first_of(), then\
    \ find the end of the word using std::find_last_of(), then use std::find_first_not_of()\
    \ to find the first character in the word that is not an uppercase letter.\n<code>\n\
    auto pos = s.find_first_of(' ');\nauto endOfWord = s.find_last_of(' ');", "{\n\
    \tforeach(x, s)\n\t\tif(x is upper) \n\t\t\tx++;\n\treturn length;\n}", "{\n \
    \ long result = 0;\n  map<char, long> map;\n  map['a'] = 0;\n  map['b'] = 0;\n\
    \  map['c'] = 0;\n  map['d'] = 0;\n  map['e'] = 0;\n  map['f'] = 0;\n  map['g']\
    \ = 0;\n  map['a'] = 0;\n  map['b'] = 0;\n  map['c'] = 0;\n  map['d'] = 0;\n \
    \ map['e'] = 0;\n  map['f'] = 0;\n  map['g'] = 0;", "{\n    long count = 0L;\n\
    \    for(int i = 0; i < s.length(); i++)\n    {\n        if (s[i] == 'A' || s[i]\
    \ == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')\n        {\n          \
    \  count++;\n        }\n    }\n    return count;\n}", "{\n    return length(s.chars)\
    \ * (s.chars.even? 0L : 1L);\n}", "{\n    long result = 0;\n    for (int i = 0;i\
    \ < s.size();i += 2) {\n        auto c = s[i];\n        if (c >= 'A' && c <= 'Z')\n\
    \            result += 1L;\n    }\n    return result;\n}", "{\n\tint cnt = 0;\n\
    \tfor (int i = 0; i < s.length; ++i) \n\t\tif (s[i] != s[i]) \n\t\t\t++cnt;\n\t\
    return cnt;\n}\n    \n/** \n * A simple test program.\n */", "{\n    long count\
    \ = 0;\n    for (int i = s.length() - 1; i >= 0; i--)\n    {\n        char c =\
    \ s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n\
    \            count++;\n    }\n    return count;\n}", "{\n    long cnt=0;\n   \
    \ for(int i=0;i<s.length();i++)\n        if(s[i]=='A'&&(i&1)==0)\n           \
    \ cnt++;\n    return cnt;\n}\n</code>\nAnd of course to make it efficient, we\
    \ have to go one step further and replace the \"A bit test with a bitwise and\"\
    :\n<code>\n/*", "{\n    int vowels = 0;\n    for (int i=0; i<s.length(); ++i)\
    \ {\n        int c = s[i];\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' &&\
    \ c <= 'Z')) {\n            ++vowels;\n        }\n    }\n    return vowels;\n\
    }\n</code>\n<|/ a tags=c++,c++11 |>\n<| a tags=c++,c++11 dscore=1 |>\n<code>\n\
    std::string s = \"abA\";\nauto pos = s.find(\"abA\");\nif (pos != std::string::npos)\n\
    {\n    auto first = s.begin() + pos;\n    auto last = s.end() - 1;", "{\n    string::iterator\
    \ i;\n    long count = 0L;\n    for(i = s.begin(); i != s.end(); ++i) \n    {\n\
    \        if(*i != 'a') \n            count += 1;\n        else \n        {\n \
    \           i += (i % 2 == 0 ? 1 : 2);\n            if(*i == 'e' || *i == 'i'\
    \ || *i == 'o' || *i == 'u')\n                count += 1;\n        }\n    }\n\
    \    return count;\n}", "{\n\tmap<int, int> m;\n\tfor (int i = 0; i < s.length();\
    \ i++) {\n\t\tif (std.isUpper(s[i], std.locate_start())) m[(std.locate_end()-std.locate_start())-1]++;\n\
    \t}\n\tmap<int, int>::iterator it;\n\tfor (it = m.begin(); it != m.end(); it++)\
    \ \n\t\tif (it->second % 2 == 0) return (it->second + 1);\n\treturn 0;\n}\n/*",
  "{\n    long n = 0;\n    for (auto c: s) {\n        if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            n += 1;\n        }\n    }\n\
    \    return n;\n}", "{\n    long result = 0;\n    string vowels = \"AEIOUaeiou\"\
    ;\n    for(string::iterator it = s.begin(); it != s.end(); ++it) \n    {\n   \
    \     if(vowels.find(*it) != string::npos) \n        {\n            if(*it ==\
    \ 'e') \n            {\n                result += 2L;\n            } \n      \
    \      else if(*it == 'i') \n            {\n                result += 2L;\n  \
    \          }\n            else if(*it == 'o') \n            {\n              \
    \  result += 2L;\n            }\n            else if(*it == 'u') \n          \
    \  {\n                result += 2L;\n            }\n        }\n    }\n    return\
    \ result;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nUsing string::find\
    \ function\n<code>\nstring str = \"aBCdEf\";", "{\n  long result = 0;\n  for (int\
    \ i = 0; i < s.length(); i++) {\n    bool is_vowel = false;\n    for (int j =\
    \ 0; j < s.length(); j++) {\n      if (i!=j && s[i]==s[j] && s[i]+'A'-'a'==s[j]+'A'-'a')\
    \ {\n        is_vowel = true;\n        break;\n      }\n    }\n    if (is_vowel)\
    \ result++;\n  }\n  return result;\n}", "{\n\tlong result = 0;\n\tfor (ssize_t\
    \ i=0; i<s.length(); i++) {\n\t\tif (s[i] == 'a' || s[i] == 'e' || s[i] == 'i'\
    \ || s[i] == 'o' || s[i] == 'u')\n\t\t\tresult++;\n\t}\n\t\n\treturn result;\n\
    }", "{\n    string vowels = \"AEIOUaeiou\";\n    foreach(char c, s)\n        if\
    \ (std.strings.find(vowels, c) != -1)\n            return std.count(vowels, c)\
    \ - 1;\n    return 0;\n}\n</cell>\n<code language=dyalog-kernel>\n?count_upper\n\
    </cell>\n<code language=dyalog-kernel>\ncount_upper(\"aBCdEf\")\n</cell>\n<code\
    \ language=dyalog-kernel>\ncount_upper(\"abcdefg\")\n</cell>\n<code language=dyalog-kernel>\n\
    count_upper(\"dBBE\")\n</cell>\n<code language=dyalog-kernel>\ncount_upper(\"\
    dBBE\")\n</cell>\n<code language=dyalog-kernel>\ncount_upper(\"dBBE\")\n</cell>\n\
    <code language=dyalog-kernel>\ncount_upper(\"dBBE\")\n</cell>\n<code language=dyalog-kernel>\n\
    count_upper(\"dBBE\")\n</cell>\n<text>\nA word beginning with vowels\n(This is\
    \ a bit trickier than usual).", "{\n    int i;\n    long count = 0;", "{\n\tsize_t\
    \ i, n = s.length();\n\tlong counter = 0;\n\tchar c;\n\tfor (i = 0; i < n; i++)\n\
    \t{\n\t\tc = s[i];\n\t\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))\n\
    \t\t{\n\t\t\tif (c >= 'A' && c <= 'Z')\n\t\t\t{\n\t\t\t\tif (s[i] >= 'a' && s[i]\
    \ <= 'z')\n\t\t\t\t\tcounter++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (s[i]\
    \ >= 'A' && s[i] <= 'Z')\n\t\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ counter;\n}", "{\n    int i;\n    for(i = 0; s[i] != '\\0'; i++){\n        if(isupper(s[i])){\n\
    \            if(s[i] == 'A' && s[i+1] == 'a')\n                return 1L;\n  \
    \          if(s[i] == 'B' && s[i+1] == 'b')\n                return 1L;\n    \
    \        if(s[i] == 'C' && s[i+1] == 'c')\n                return 1L;\n      \
    \      if(s[i] == 'D' && s[i+1] == 'd')\n                return 1L;\n        \
    \    if(s[i] == 'E' && s[i+1] == 'e')\n                return 1L;\n          \
    \  if(s[i] == 'F' && s[i+1] == 'f')\n                return 1L;\n            if(s[i]\
    \ == 'G' && s[i+1] == 'g')\n                return 1L;\n        }\n    }\n   \
    \ return 0L;\n}", "{\n    long n = 0;\n    for (long i = 0; i < s.length; i+=2)\n\
    \        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i]\
    \ == 'U')\n            n++;\n    return n;\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nI like this one because it is easy to understand and understands why it\
    \ works. It also uses standard functions and only uses standard libraries.\n<|/\
    \ c |>\n<| a tags=c,algorithm,string |>\n<code>\n#include <stdio.h>\n#include\
    \ <string.h>", "{\n\tlong count=0;\n\tfor (int i=0; i<s.length(); i++)\n\t{\n\t\
    \tif (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')\n\
    \t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n/* end of function definitions\
    \ */\n/*", "{\n    long vowel = 0;\n    for (int i = 0; i < s.length(); i++)\n\
    \        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i]\
    \ == 'u')\n            vowel++;\n    return vowel;\n}", "{\n    long count = 0;\n\
    \    for (int i = 0; i < s.length(); ++i) {\n        if (s[i] == 'A' || s[i] ==\
    \ 'a' || s[i] == 'E' || s[i] == 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O'\
    \ || s[i] == 'o' || s[i] == 'U' || s[i] == 'u') {\n            ++count;\n    \
    \    }\n    }\n    return count;\n}", "{\n\tlong count = 1;\n\tfor (int i = 0;\
    \ i < s.length(); i++) {\n\t\tif (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' ||\
    \ s[i] == 'o' || s[i] == 'u')\n\t\t\tcount++;\n\t}\n\treturn count;\n}", "{\n\t\
    long result = 0;\n\tint len = s.length();\n\tfor (int i = 0; i < len; i++) \n\t\
    {\n\t\tif (s[i] == 'A' && s[i+1] == 'C' && s[i+2] == 'E' && s[i+3] == 'G') \n\t\
    \t{\n\t\t\tresult ++;\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n\tfor(size_t\
    \ i = 0; i < s.length(); i++)\n\t\tif(s[i] == 'A' || s[i] == 'E' || s[i] == 'I'\
    \ || s[i] == 'O' || s[i] == 'U')\n\t\t{\n\t\t\tlong result = (s[i] == 'A') ? 1L\
    \ : 0L;\n\t\t\tif(s[i - 1] == 'A')\n\t\t\t\tresult += 1L;\n\t\t\tif(s[i - 1] ==\
    \ 'E')\n\t\t\t\tresult += 1L;\n\t\t\tif(s[i - 1] == 'I')\n\t\t\t\tresult += 1L;\n\
    \t\t\tif(s[i - 1] == 'O')\n\t\t\t\tresult += 1L;\n\t\t\tif(s[i - 1] == 'U')\n\t\
    \t\t\tresult += 1L;\n\t\t\treturn result;\n\t\t}\n\treturn 0L;\n}", "{\n  long\
    \ vowels = 0L;\n  for(long i = 0; i < s.length; i += 2)\n  {\n    if(s[i] == 'A'\
    \ || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')\n      vowels++;\n\
    \  }\n  return vowels;\n}\n/*\n  \n    Write an implementation for the function\
    \ count_down in C++.\n    \n    Note: Avoid using standard library functions such\
    \ as <cctype>\n    \n    Example:\n    \n    For example, given the string \"\
    ABCDEFG\"\n    The letters A through E are counted from index 0 \n    and the\
    \ letters F through G are counted from index 3.\n    \n    count_down(\"ABCDEFG\"\
    ) -> 0", "{\n    long count = 0; \n    for(int i = 0; i < s.length(); i++)\n \
    \   {\n        if(s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' ||\
    \ s[i] == 'U')\n        {\n            count++;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a tags=algorithm,c++ dscore=1 |>\n<| c |>\nThank you\
    \ for this answer. I will give it a try and come back.\n<|/ c |>\n<| a dscore=1\
    \ |>\nA simpler version using functional programming:\n<code>\nlong count_upper(string\
    \ s) \n{\n   long n = s.length();\n   long count = 0;\n   for (char c: s) \n \
    \     if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') \n       \
    \  ++count;\n   return count;\n}\n</code>\n<|/ a tags=algorithm,c++ |>\n<| a tags=algorithm,c++\
    \ |>\nThis approach is simple, easy to read, and maintainable.\n<code>\nlong count_upper(string\
    \ s) {\n    long count = 0;\n    for (size_t i = 0, size = s.length(); i < size;\
    \ ++i) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') {\n            ++count;\n        }\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=algorithm,c++ |>\nYou can use\
    \ stl algorithms to solve this:\n<code>\nusing namespace std;\n#include <algorithm>",
  "{\n    long i, count, vowels;\n    string vowels = \"aeiouy\";\n    for(i = 0;\
    \ i < s.length(); i++)\n    {\n        if(s[i] == vowels[0])\n        {\n    \
    \        count++;\n        }\n        else if(s[i] == vowels[1])\n        {\n\
    \            count++;\n        }\n        else if(s[i] == vowels[2])\n       \
    \ {\n            count++;\n        }\n        else if(s[i] == vowels[3])\n   \
    \     {\n            count++;\n        }\n        else if(s[i] == vowels[4])\n\
    \        {\n            count++;\n        }\n        else if(s[i] == vowels[5])\n\
    \        {\n            count++;\n        }\n        else if(s[i] == vowels[6])\n\
    \        {\n            count++;\n        }\n        else if(s[i] == vowels[7])\n\
    \        {\n            count++;\n        }\n        else if(s[i] == vowels[8])\n\
    \        {\n            count++;\n        }\n        else if(s[i] == vowels[9])\n\
    \        {\n            count++;\n        }\n        else if(s[i] == vowels[10])\n\
    \        {\n            count++;\n        }\n        else if(s[i] == vowels[11])\n\
    \        {\n            count++;\n        }\n        else if(s[i] == vowels[12])\n\
    \        {\n            count++;\n        }\n        else if(s[i] == vowels[13])\n\
    \        {\n            count++;\n        }\n        else if(s[i] == vowels[14])\n\
    \        {\n            count++;\n        }\n        else if(s[i] == vowels[15])\n\
    \        {\n            count++;\n        }\n    }\n    return count;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThe question is unclear in that regard, but you might also\
    \ want to consider using a lookup table rather than multiple `if` statements\n\
    <|/ c |>\n<| c |>\nthank you so much for your help !\n<|/ c |>\n<| a tags=string,algorithm\
    \ dscore=1 |>\nI wrote a solution that uses dynamic programming, as you had mentioned.\n\
    The trick is to make the first two rows and the last row to be zero. Then, instead\
    \ of checking whether s[i]:vowel[vowel] return s[i+1]:vowel[vowel], check if the\
    \ letter at position i in the string is a vowel, and return the value of the lookup\
    \ table for that letter.\n<code>\ndef count_upper(string):\n    vowels = \"aeiou\"\
    \n    table = [0 for _ in range(len(string))]\n    table[0] = 1 # The first row\
    \ is one\n    table[len(string)-1] = 1 # Last  row is one", "{\n  // convert s\
    \ to lowercase and remove all vowels\n  s = tolower(s);\n  transform(s.begin(),\
    \ s.end(), s.begin(), ::tolower);\n  transform(s.begin(), s.begin() + s.length(),\
    \ s.begin() + s.length() - 1, ::toupper);", "{\n\tint[] counter = new int[256];\n\
    \tfor (int i = 0; i < s.length(); i++)\n\t{\n\t\tcounter[(int)s[i]] ++;\n\t}",
  "{\n\tlong n = 0;\n\tforeach(char c, s) {\n\t\tif(is_upper(c)) {\n\t\t\tif(c % 2\
    \ == 0) n++;\n\t\t}\n\t}\n\treturn n;\n}", "{\n    long long count = 0;\n    int\
    \ j = 0;\n    \n    for (int i = 0; i < s.length; ++i)\n    {\n        string\
    \ str = s.substr(i, j);\n        if (std.string.isUpper(str))\n        {\n   \
    \         count++;\n        }\n        j++;\n    }\n    return count;\n}", "{\n\
    \    long vowels = 0;\n    long i;\n    \n    for (i=0; i<s.length; ++i)\n   \
    \ {\n        if (isupper(s[i]))\n            vowels++;\n        if (islower(s[i]))\n\
    \            vowels -= 2;\n    }\n    \n    return vowels;\n}", "{\n    long long\
    \ ans = 0L;\n    for (int i = 1; i < s.length(); ++i) {\n        if (s[i] >= 'a'\
    \ && s[i] <= 'z') {\n            ans += 1;\n            i += 2;\n        }\n \
    \   }\n    return ans;\n}", "{\n    return s.find_first_not_of(\"AEIOUaeiou\"\
    , 0L);\n}", "{\n\tauto upperChars = [&]() {\n\t\tauto first = s.begin(), last\
    \ = s.end();\n\t\t\n\t\twhile (first != last) {\n\t\t\tauto currentChar = *first;\n\
    \t\t\tauto nextChar = first == last ? currentChar\n\t\t\t\t\t: next(first, currentChar);\n\
    \t\t\tif (isUpper(*nextChar)) {\n\t\t\t\t++first;\n\t\t\t} else {\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t\treturn first;\n\t};\n\t\n\treturn sum(filter([](auto c) {\n\
    \t\treturn isUpper(c);\n\t}, upperChars()));\n}", "{\n    long count = 0;\n  \
    \  for (int i = 0; i < s.length; ++i)\n    {\n        if (s[i] >= 'A' && s[i]\
    \ <= 'Z')\n        {\n            if (i % 2 == 0)\n            {\n           \
    \     count += 1;\n            }\n        }\n    }\n    return count;\n}", "{\n\
    \    long count = 0; \n    for(int i = 0; i < s.length(); i++) {\n        if(s[i]\
    \ >= 'a' && s[i] <= 'z') {\n            if(((i + 1) % 2) == 0) {\n           \
    \     count++;\n            }\n        }\n    }\n    return count;\n}", "{\n\t\
    size_t count = 0;\n\t\n\tforeach(char c, s) {\n\t\tif (isupper(c)) \n\t\t\tcount++;\n\
    \t}\n\t\n\treturn count;\n}", "{\n    auto n = s.length();\n    auto vowels =\
    \ \"AEIOUaeiou\";", "{\n    long c = 0;\n    for (int i = 0; i < s.length; i +=\
    \ 2)\n    {\n        if ((s[i] >= 'A' && s[i] <= 'Z') || (s[i] >= 'a' && s[i]\
    \ <= 'z'))\n        {\n            c++;\n        }\n    }\n    return c;\n}\n\
    </code>\n<|/ a |>\n<| a |>\nThis is a solution that doesn't use recursion and\
    \ only uses string manipulation.\n<code>", "{\n\tlong result = 0;\n\tsize_t i;\n\
    \tfor(i = 0; i < s.size() - 1; i += 2)\n\t\tif (s.charAt(i) == 'A' || s.charAt(i)\
    \ == 'a')\n\t\t\tresult ++;\n\tfor(i = 0; i < s.size() - 1; i += 2)\n\t\tif (s.charAt(i)\
    \ == 'E' || s.charAt(i) == 'e')\n\t\t\tresult ++;\n\tfor(i = 0; i < s.size() -\
    \ 1; i += 2)\n\t\tif (s.charAt(i) == 'I' || s.charAt(i) == 'i')\n\t\t\tresult\
    \ ++;\n\tfor(i = 0; i < s.size() - 1; i += 2)\n\t\tif (s.charAt(i) == 'O' || s.charAt(i)\
    \ == 'o')\n\t\t\tresult ++;\n\tfor(i = 0; i < s.size() - 1; i += 2)\n\t\tif (s.charAt(i)\
    \ == 'U' || s.charAt(i) == 'u')\n\t\t\tresult ++;\n\tfor(i = 0; i < s.size() -\
    \ 1; i += 2)\n\t\tif (s.charAt(i) == 'C' || s.charAt(i) == 'c')\n\t\t\tresult\
    \ ++;\n\tfor(i = 0; i < s.size() - 1; i += 2)\n\t\tif (s.charAt(i) == 'G' || s.charAt(i)\
    \ == 'g')\n\t\t\tresult ++;\n\treturn result;\n}", "{\n  int even_index = 0;\n\
    \  long vowels = 0;\n  for(int i = 0; i < s.length(); i++) {\n    if(s[i] != '\
    \ ') \n      vowels++;\n    if(i % 2 == 0) {\n      even_index++;\n    }\n  }\n\
    \  for(int i = 1; i <= even_index; i++) {\n    vowels += (s[i-1] == 'A') || (s[i-1]\
    \ == 'E') || (s[i-1] == 'I') || (s[i-1] == 'O') || (s[i-1] == 'U');\n  }\n  return\
    \ vowels;\n}", "{\n    long vowels = 0;\n    for (long i = 0; i < s.length; ++i)\n\
    \        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i]\
    \ == 'U')\n            ++vowels;\n    return vowels;\n}", "{\n    int i,n=s.length();\n\
    \    map<int, int> m;\n    for(i=0;i<n;++i) {\n        long v = std.toupper(s[i],\
    \ m[s[i]-'a']);\n        if (v != 0) {\n            m[s[i]-'a'] += 1;\n      \
    \  }\n    }\n    return m[0];\n}", "{\n    auto s_iter = s.rbegin();\n    for\
    \ (auto s_end = s.rend(); s_iter != s_end; ++s_iter) {\n        if ((*s_iter >=\
    \ 'A') && (*s_iter <= 'Z')) {\n            auto i = s_iter - s.begin();\n    \
    \        if ((i % 2) == 0)\n                return 1L;\n        }\n    }\n   \
    \ return 0L;\n}", "{\n    long result = 0;\n    \n    foreach(char ch, s)\n  \
    \  {\n        if((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z'))\n     \
    \   {\n            result += 1;\n        }\n    }\n    \n    return result;\n\
    }\n</code>\n<|/ a tags=string,c++ dscore=3 |>\n<| a tags=string,c++ dscore=2 |>\n\
    I did this in java(using StringTokenizer)\n<code>\nimport java.io.BufferedReader;\n\
    import java.io.IOException;\nimport java.io.InputStreamReader;", "{\n    long\
    \ res = 0;\n    for (auto c : s) {\n        if (c.isUpper() && c != 'A') {\n \
    \           res = res + 1L;\n        }\n    }\n    return res;\n}\n</code>\n<|/\
    \ a dscore=2 tags=string,c++,algorithm |>\n<| c |>\nThanks, I like your use of\
    \ lambda - makes it easier to read. I also like using map - makes it easier to\
    \ use an index in a for loop.\n<|/ c |>\n<| c |>\nIt's a shame you chose to answer\
    \ your own question; not only is it a great answer, but it was also a great learning\
    \ opportunity for me!\n<|/ c |>\n<| c |>\nOh yeah, it makes sense - I actually\
    \ had it written a while ago but forgot about it. Oh well, glad to hear it helped\
    \ - I love learning new things. :)\n<|/ c |>\n<| a tags=string,c++,algorithm |>\n\
    Here is my solution - it uses a map to keep track of every occurrence of a character\
    \ (even index) and a std::set to keep track of the characters appearing before\
    \ the current character (odd index):\n<code>\n#include<iostream>\n#include<map>\n\
    #include<set>\nusing namespace std;", "{\n    long v = 0;\n    for (int i = 0;\
    \ i < s.length; ++i)\n    {\n        bool c = s[i] == 'a';\n        if (c) { ++v;\
    \ }\n        c = s[i] == 'A';\n        if (c) { ++v; }\n        c = s[i] == 'e';\n\
    \        if (c) { ++v; }\n        c = s[i] == 'E';\n        if (c) { ++v; }\n\
    \        c = s[i] == 'i';\n        if (c) { ++v; }\n        c = s[i] == 'I';\n\
    \        if (c) { ++v; }\n        c = s[i] == 'o';\n        if (c) { ++v; }\n\
    \        c = s[i] == 'O';\n        if (c) { ++v; }\n        c = s[i] == 'u';\n\
    \        if (c) { ++v; }\n        c = s[i] == 'U';\n        if (c) { ++v; }\n\
    \        c = s[i] == 'A';\n        if (c) { ++v; }\n        c = s[i] == 'a';\n\
    \        if (c) { ++v; }\n        c = s[i] == 'E';\n        if (c) { ++v; }\n\
    \        c = s[i] == 'e';\n        if (c) { ++v; }\n        c = s[i] == 'I';\n\
    \        if (c) { ++v; }\n        c = s[i] == 'i';\n        if (c) { ++v; }\n\
    \        c = s[i] == 'O';\n        if (c) { ++v; }\n        c = s[i] == 'o';\n\
    \        if (c) { ++v; }\n        c = s[i] == 'U';\n        if (c) { ++v; }\n\
    \        c = s[i] == 'u';\n        if (c) { ++v; }\n        c = s[i] == 'a';\n\
    \        if (c) { ++v; }\n        c = s[i] == 'A';\n        if (c) { ++v; }\n\
    \        c = s[i] == 'a';\n        if (c) { ++v; }\n        c = s[i] == 'e';\n\
    \        if (c) { ++v; }\n        c = s[i] == 'e';\n        if (c) { ++v; }\n\
    \        c = s[i] == 'I';\n        if (c) { ++v; }\n        c = s[i] == 'i';\n\
    \        if (c) { ++v; }\n        c = s[i] == 'O';\n        if (c) { ++v; }\n\
    \        c = s[i] == 'o';\n        if (c) { ++v; }\n        c = s[i] == 'U';\n\
    \        if (c) { ++v; }\n        c = s[i] == 'u';\n        if (c) { ++v; }\n\
    \    }\n    return v;\n}\n</code>\n<|/ a tags=c++,string,algorithm,pattern-matching,optimization\
    \ |>\n<| c |>\nI guess the problem with this is that it's O(n^2) time complexity\
    \ and that would be a problem in most cases. There might be a more clever way\
    \ to do this though I guess.\n<|/ c |>\n<| c |>\nYou're right, I didn't consider\
    \ that and made my answer O(n^2) ", "{\n    int n = s.length();\n    \n    int\
    \ count[26] = {0};\n    \n    for (int i = 0; i < n; ++i)\n    {\n        string\
    \ char = s.substr(i, 1);\n        \n        if (char.equals(\"a\") || char.equals(\"\
    e\") || char.equals(\"i\") || char.equals(\"o\") || char.equals(\"u\"))\n    \
    \        count[(int)char.charAt(0)]++;\n    }\n    \n    int result = 0;\n   \
    \ for (int i = 0; i < 26; ++i)\n        if (count[i] % 2 == 0)\n            result\
    \ += count[i];\n    \n    return result;\n}", "{\n\tlong res = 0;\n\tint i = 0;",
  "{\n    auto it = find_if(s.begin(), s.end(), isupper);\n    return distance(s.begin(),\
    \ it);\n}", "{\n    long cnt=0;\n    string vowels = \"aeiouAEIOU\";\n    for(auto\
    \ i=0; i!=s.length(); i++) {\n        if(s[i] >= 'a' && s[i] <= 'z') {\n     \
    \       if(vowels[s[i]-'a'] == vowels[s[i]-'A'])\n                cnt += 2;\n\
    \        }\n    }\n    return cnt;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThank\
    \ you for the solution. I will definitely try it out. I just wanted to know if\
    \ there is a better (faster) way since I am quite new to programming. Thanks again!\n\
    <|/ c |>\n<| c |>\nThis is definitely an improvement, however the main issue is\
    \ just that. Counting all uppercase vowels, without considering lowercase ones,\
    \ which can be done with a simple `for` loop and an `if` check.\n<|/ c |>\n<|\
    \ c |>\nWell, if you really want to solve this with high performance, you would\
    \ probably better use a lookup table. But, if you really want to solve it this\
    \ way, I edited my post to show you how you can use a for-loop to check for uppercase\
    \ vowels *without* considering lowercase ones.\n<|/ c |>\n<| a dscore=0 tags=c++,string,for-loop,character\
    \ |>\nYou can use this code.\n<code>\n#include <iostream>\n#include <cstdio>\n\
    #include <string>\n#include <algorithm>\n#include <cctype>", "{\n    long count=0L,i;\n\
    \    for(i=0;i<s.length();i++) {\n        if(s[i]==('a' || 'A')) {\n         \
    \   count++;\n        }\n    }\n    return count;\n}", "{\n\tint i;\n\tint count_upper\
    \ = 0;", "{\n    long vowels = 0;\n    \n    for (long i = 0; i < s.length; ++i)\n\
    \    {\n        char ch = s[i];\n        if (ch == ' ' || ch == '\\t' || ch ==\
    \ '\\n')\n        {\n            continue;\n        }\n        if (char.IsUpper(ch)\
    \ && i % 2 == 0)\n        {\n            ++vowels;\n        }\n    }\n    return\
    \ vowels;\n}", "{\n\tlong count = 0L;\n\tfor (int i = 0; i < s.length(); i++)\n\
    \t{\n\t\tif (std.isUpper(s[i]))\n\t\t\tcount++;\n\t\tif (i % 2 == 0)\n\t\t\tcount++;\n\
    \t}\n\treturn count;\n}", "{\n\tlong n = 0L;\n\tchar c;\n\tfor (auto itr = s.cbegin();\
    \ itr != s.cend(); ++itr)\n\t{\n\t\tc = *itr;\n\t\tif ('a' <= c && c <= 'z')\n\
    \t\t{\n\t\t\tif ('A' <= c && c <= 'Z')\n\t\t\t{\n\t\t\t\tn += 1L;\n\t\t\t}\n\t\
    \t}\n\t}\n\treturn n;\n}", "{\n\tauto const n = s.length();\n\tauto const l  =\
    \ s.length();\n\tlong ret = 0;\n\tfor(auto i=0; i<l; i++) {\n\t\tif(s[i]==='a'\
    \ || s[i]==='A') {\n\t\t\tif(i%2==0) ret++;\n\t\t} else if(s[i]==='d' || s[i]==='D')\
    \ {\n\t\t\tif(i%2==1) ret++;\n\t\t}\n\t}\n\treturn ret;\n}\n/*", "{\n    int i;\n\
    \    int vowels = 0;\n    \n    for (i = 0; i <= s.length - 2; i += 2)\n     \
    \   if (s.charAt(i) == 'e' && s.charAt(i+1) == 'E')\n            vowels++;\n \
    \           \n    return vowels;\n}", "{\n\tlong count = 1;\n\tfor (int i = 0;\
    \ i <= s.length(); i++)\n\t{\n\t\tif (s[i] == 'A')\n\t\t\tcount++;\n\t\tif (s[i]\
    \ == 'a')\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n/*", "{\n\tlong i = 0;\n\t\
    while (s[i] == 'A' || s[i] == 'a') \n\t{\n\t\ti++;\n\t}\n\twhile (s[i] == 'E'\
    \ || s[i] == 'e') \n\t{\n\t\ti++;\n\t}\n\twhile (s[i] == 'I' || s[i] == 'i') \n\
    \t{\n\t\ti++;\n\t}\n\twhile (s[i] == 'O' || s[i] == 'o') \n\t{\n\t\ti++;\n\t}\n\
    \twhile (s[i] == 'U' || s[i] == 'u') \n\t{\n\t\ti++;\n\t}\n\treturn i;\n}\n/*\
    \ \n\tReturns the number of uppercase vowels in all input strings. \n\t\n\tFor\
    \ example: \n\t>>> count_upper_all(\"aBCdEf\")\n\t1L\n\t>>> count_upper_all(\"\
    abcdefg\")\n\t0L\n\t>>> count_upper_all(\"dBBE\")\n\t0L\n*/\nlong count_upper_all(string\
    \ s) \n{\n\tlong i = 0;\n\twhile (s[i] == 'A' || s[i] == 'a') \n\t{\n\t\ti++;\n\
    \t}\n\twhile (s[i] == 'E' || s[i] == 'e') \n\t{\n\t\ti++;\n\t}\n\twhile (s[i]\
    \ == 'I' || s[i] == 'i') \n\t{\n\t\ti++;\n\t}\n\twhile (s[i] == 'O' || s[i] ==\
    \ 'o') \n\t{\n\t\ti++;\n\t}\n\twhile (s[i] == 'U' || s[i] == 'u') \n\t{\n\t\t\
    i++;\n\t}\n\treturn i;\n}\n/* \n\tReturns the number of lowercase vowels in all\
    \ input strings. \n\t\n\tFor example: \n\t>>> count_lower_all(\"aBCdEf\")\n\t\
    1L\n\t>>> count_lower_all(\"abcdefg\")\n\t0L\n\t>>> count_lower_all(\"dBBE\")\n\
    \t0L\n*/\nlong count_lower_all(string s) \n{\n\tlong i = 0;\n\twhile (s[i] !=\
    \ 'a' && s[i] != 'A' && s[i] != 'E' && s[i] != 'e' && s[i] != 'I' && s[i] != 'i'\
    \ && s[i] != 'O' && s[i] != 'o' && s[i] != 'U' && s[i] != 'u') \n\t{\n\t\ti++;\n\
    \t}\n\treturn i;\n}\n/* \n\tReturns the number of consonants in all input strings.\
    \ \n\t\n\tFor example: \n\t>>> count_cons_all(\"aBCdEf\")\n\t1L\n\t>>> count_cons_all(\"\
    abcdefg\")\n\t0L\n\t>>> count_cons_all(\"dBBE\")\n\t0L\n*/\nlong count_cons_all(string\
    \ s) \n{\n\tlong i = 0;\n\twhile (s[i] != 'a' && ", "{\n    foreach(idx, e) if\
    \ (idx % 2 == 0) return s.indexOf(e) != -1;\n    return 0;\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=c++,string,count |>\nThe easiest way is to iterate through\
    \ the string from beginning to end, counting every time the character is capital.\n\
    <|/ a dscore=0 |>\n<| c |>\nWhat is the easiest way?\n<|/ c |>\n<| c |>\nDo you\
    \ have a c++ compiler available for you?  This is not a trivial problem to solve.\
    \  I would start by looking at the STL and algorithms library as suggested by\
    \ other answers.\n<|/ c |>\n<| a dscore=0 |>\nFor counting the number of uppercase\
    \ letters you can use following function:\n<code>", "{\n    // TODO: Optimize\
    \ this part using O(n) instead of O(n*n)\n    long long result = 0;\n    for (int\
    \ i = 0; i < s.length; ++i)\n        if (s[i] == 'a' || s[i] == 'e' || s[i] ==\
    \ 'i' || s[i] == 'o' || s[i] == 'u')\n            result += 1;\n    return result;\n\
    }", "{\n\tstatic long result = 0;\n\t\n\tint i;\n\tfor (i = 0; i<s.length(); i++)\
    \ {\n\t\tif (s[i] >= 'A' && s[i] <= 'Z') {\n\t\t\tresult += s[i];\n\t\t}\n\t}\n\
    \t\n\treturn result;\n}", "{\n    int N = s.length();\n    long count = 0;\n \
    \   for(int i = 0; i < N; i = i+2) {\n        if (s[i] == 'E' && s[i+1] == 'B')\n\
    \            count++;\n    }\n    return count;\n}", "{\n    int len = s.length();\n\
    \    long count = 0;\n    for (int i = 0; i < len; i++)\n    {\n        if (s[i]\
    \ >= 'a' && s[i] <= 'z')\n            count++;\n        else if (s[i] >= 'A' &&\
    \ s[i] <= 'Z')\n            count++;\n    }\n    return count;\n}\n/* end file\
    \ */", "{\n    long counter = 0;\n    for (int i = 0; i < s.length; i++) \n  \
    \  {\n        if (s[i] == 'A' || s[i] == 'a') \n        {\n            counter\
    \ += 1;\n        }\n        else if (s[i] == 'B' || s[i] == 'b') \n        {\n\
    \            counter += 2;\n        }\n        else if (s[i] == 'C' || s[i] ==\
    \ 'c') \n        {\n            counter += 3;\n        }\n        else if (s[i]\
    \ == 'D' || s[i] == 'd') \n        {\n            counter += 4;\n        }\n \
    \       else if (s[i] == 'E' || s[i] == 'e') \n        {\n            counter\
    \ += 5;\n        }\n        else if (s[i] == 'F' || s[i] == 'f') \n        {\n\
    \            counter += 6;\n        }\n        else if (s[i] == 'G' || s[i] ==\
    \ 'g') \n        {\n            counter += 7;\n        }\n        else if (s[i]\
    \ == 'H' || s[i] == 'h') \n        {\n            counter += 8;\n        }\n \
    \       else if (s[i] == 'I' || s[i] == 'i') \n        {\n            counter\
    \ += 9;\n        }\n        else if (s[i] == 'J' || s[i] == 'j') \n        {\n\
    \            counter += 10;\n        }\n        else if (s[i] == 'K' || s[i] ==\
    \ 'k') \n        {\n            counter += 11;\n        }\n        else if (s[i]\
    \ == 'L' || s[i] == 'l') \n        {\n            counter += 12;\n        }\n\
    \        else if (s[i] == 'M' || s[i] == 'm') \n        {\n            counter\
    \ += 13;\n        }\n        else if (s[i] == 'N' || s[i] == 'n') \n        {\n\
    \            counter += 14;\n        }\n        else if (s[i] == 'O' || s[i] ==\
    \ 'o') \n        {\n            counter += 15;\n        }\n        else if (s[i]\
    \ == 'P' || s[i] == 'p') \n        {\n            counter += 16;\n        }\n\
    \        else if (s[i] == 'Q' || s[i] == 'q') \n        {\n            counter\
    \ += 17;\n        }\n        else if (s[i] == 'R' || s[i] == 'r') \n        {\n\
    \            counter += 18;\n        }\n        else if (s[i] == 'S' || s[i] ==\
    \ 's') \n        {\n            counter += 19;\n        }\n        else if (s[i]\
    \ == 'T' || s[i] == 't') \n        {\n            counter += 20;\n        }\n\
    \        else if (s[i] == 'U' || s[i] == 'u') \n        {\n            counter\
    \ += 21;\n        }\n        else if (s[i] == 'V' || s[i] == 'v') \n        {\n\
    \            counter += 22;\n        }\n        else if (s[i] == 'W' || s[i] ==\
    \ 'w') \n        {\n            counter += 23;\n        }\n        else if (s[i]\
    \ == 'X' || s[i] == 'x') \n        {\n            counter += 24;\n        }\n\
    \        else if (s[i] == 'Y' || s[i] == 'y') \n        {\n            counter\
    \ += 25;\n        }\n        else if (s[i] == 'Z' || s[i] == 'z') \n        {\n\
    \            counter ", "{\n    long result = 0;\n    \n    foreach (i, char)\
    \ {\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            result += (s[i] - 'A'\
    \ + 1)/2;\n    }\n    \n    return result;\n}", "{\n  int n = s.length();\n  if\
    \ (n % 2 == 0) \n    return 0; //no uppercase vowels \n  long result = 0;\n  for\
    \ (int i = 0; i < n; i+=2)\n  {\n    if (s[i] == 'A' || s[i] == 'E' || s[i] ==\
    \ 'I' || s[i] == 'O' || s[i] == 'U') \n      result +=1;\n  }\n  return result;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThe `i <= n` test is probably a bug (it should\
    \ be `i < n`). Also, the `if (s[i] == 'A')` branch is redundant. The `else` branch\
    \ is OK though.\n<|/ c |>\n<| c |>\nIt was a typo, thanks for pointing it out.\
    \ Though, one question remains, why does the loop run till `i+=2` and not till\
    \ `i++`? Why can't we do `i<n` inside the loop?\n<|/ c |>\n<| c |>\nWell, `i++`\
    \ doesn't do anything, because `i` is incremented by 2 every time, so it never\
    \ reaches `n`. `i+=2` increments `i` by 2 every time, so it never reaches `n`.\
    \ So you loop from 0 to n-1, and stop when `i+2` is out of bounds.\n<|/ c |>\n\
    <| c |>\nI updated my answer with an explanation about what happens in the code\
    \ you posted\n<|/ c |>\n<| c |>\nThanks, it's much clear now!\n<|/ c |>\n<| a\
    \ tags=if-statement,loops,c++ |>\nFirst of all, why are you doing this in the\
    \ first place?\nSecond, you should avoid using the switch statement. It is often\
    \ hard to read. I would write this using std::map.\n<code>\n#include <map>", "{\n\
    \    long count = 0; \n    int i = 0;\n    for (auto &c : s)\n    {\n        if\
    \ (c >= 'A' && c <= 'Z')\n        {\n            if ((c & 1) == 1)\n         \
    \   {\n                count ++;\n            }\n        }\n        i += 1;\n\
    \    }\n    return count;\n}", "{\n\tlong ret = 0L;\n\tint i = s.length();\n\t\
    while (--i >= 0) {\n\t\tif (isupper(s[i]) && (i % 2) == 0) {\n\t\t\tret++;\n\t\
    \t}\n\t}\n\treturn ret;\n}\n/*\n    Find the first instance of the string sub\
    \ in s.\n*/\nstring find_substring(string s, string sub)\n{\n\tfor (int i = 0;\
    \ i < s.length(); i++) {\n\t\tif (s[i] == sub[0]) {\n\t\t\tfor (int j = 0; j <\
    \ sub.length(); j++) {\n\t\t\t\tif (s[i+j] != sub[j]) {\n\t\t\t\t\treturn \"\"\
    ;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn s[i];\n\t\t}\n\t}\n\treturn \"\";\n}\n/*\n\
    \    Given a string s, find the first occurrence of \"abc\" in s.\n    \n    For\
    \ example:\n    >>> first_of(\"abc\", \"abc\")\n    1\n    >>> first_of(\"abc\"\
    , \"bcd\")\n    1\n*/", "{\n    string::iterator it = s.begin();\n    for(;it!=s.end();it++)\n\
    \        if(!isupper(*it))\n            return 0;\n    \n    return 1L;\n}", "{\n\
    \    long res = 0;\n    for (int i = 0; i <= s.length(); ++i)\n    {\n       \
    \ if ((s[i] >= 'A') && (s[i] <= 'Z'))\n        {\n            if (i % 2 == 0)\n\
    \                res += 1;\n        }\n    }\n    return res;\n}", "{\n    size_t\
    \ i = 0;\n    size_t j = 0;\n    size_t nUpper = 0;", "{\n    int i,count=0;\n\
    \    for(i=0;i<s.length();i++){\n        if(s[i]==s[s[i]]&&s[i]!='_')\n      \
    \      count++;\n    }\n    return count;\n}\n/*", "{\n    long result = 0;\n\
    \    foreach (char c in s) \n    {\n        if (isupper(c)) result += 2L;\n  \
    \  }\n    return result;\n}", "{\n\tauto s = to_lower_copy(s);\n\t\n\tfor(int\
    \ i=0; i<s.length(); i++) {\n\t\tif (s[i] >= 'A' && s[i] <= 'Z') {\n\t\t\tif (s[i]\
    \ >= 'a' && s[i] <= 'z') {\n\t\t\t\treturn (s[i] - 'A') % 2 == 0L ? 1L : 0L;\n\
    \t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0L;\n}\n/*\n    \n    Sales_data", "{\n  int\
    \ i = 0;\n  \n  while (i < s.size()) {\n    if (isupper(s[i])) {\n      i++;\n\
    \    } else {\n      return 1L;\n    }\n  }\n  \n  return 0L;\n}\n// Test:\n/*",
  "{\n\tlong count = 0L;\n\tauto ls = s.to_lower();\n\tfor (auto i : ls)\n\t{\n\t\t\
    if (i & std.ranges::equalto(std.ranges::uppercase))\n\t\t\t++count;\n\t}\n\treturn\
    \ count;\n}", "{\n    return count_if(s.begin(), s.end(), [](char c){return ((c\
    \ >= 'A') && (c <= 'Z') && (isupper(c)));});\n}\n</code>\n<|/ a tags=c++ |>\n\
    <| a tags=c++ dscore=0 |>\nHere's an iterative implementation:\n<code>\n#include\
    \ <iostream>\n#include <string>", "{\n    for(auto c : s)\n    {\n        if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        {\n       \
    \     if (c % 2L)\n            {\n                auto pos = std.find(s, \"B\"\
    );\n                if (pos == string::npos)\n                    throw runtime_error(\"\
    count_upper: B not found\");\n                s = &s[pos - 1];\n             \
    \   --c;\n            }\n        }\n    }\n    \n    return std.find(s, s.at(0))\
    \ - std.find(s, s[0]) + 1;\n}", "{\n    long result = 0;\n    for (auto c : s)\
    \ {\n        if (std.string::toupper(c) == c) result += 1;\n    }\n    return\
    \ result;\n}\n</code>\nI guess you can easily implement this in Java as well,\
    \ by creating a method which iterates over the chars, checks if the char is uppercase\
    \ and adds a 1 to a counter.\n<|/ a dscore=1 |>\n<| c |>\nIt also has the nice\
    \ property of being able to treat all characters as uppercase to begin with, which\
    \ is a nice property in some circumstances.\n<|/ c |>\n<| c |>\n, yes, that's\
    \ also a nice property. Depending on what you're doing, a switch may be more efficient,\
    \ but in most cases I would consider a lookup table to be more efficient.\n<|/\
    \ c |>\n<| a dscore=0 |>\nHere is a function that takes a string and returns the\
    \ number of uppercase vowels in the string:\n<code>\nfunction countUpper(s) {\n\
    \  // create an empty array to store the count of vowels\n  var count = [];",
  "{\n    long upper = 0;\n    for (int i=0; i<s.length(); i++)\n    {\n        if\
    \ (s[i] == 'A' || s[i] == 'a') \n        {\n            upper++;\n        }\n\
    \    }\n    return upper;\n}\n/*", "{\n    map<char, long> m;\n    for(auto c\
    \ : s) m[c]++;\n    long res = 0;\n    for(auto c: m) if(m[c]%2 == 0) res++;\n\
    \    return res;\n}\n</code>\nThe function count_upper has time complexity O(n),\
    \ but this isn't a big deal. Also, I think it's easier to understand than a solution\
    \ with the string class (which would require an additional for loop to iterate\
    \ over every character in the string).\n<|/ a tags=string,c++,algorithm |>\n<|\
    \ c |>\n`count_upper` is O(n), but your solution has a quadratic complexity. Still\
    \ +1!\n<|/ c |>\n<| c |>\nThis is wrong. `count_upper` has a time complexity of\
    \ O(n). Your solution is O(n^2).\n<|/ c |>\n<| c |>\nSorry, I didn't notice that\
    \ OP said the time complexity was *proportional* to string length. Now that I'm\
    \ thinking of it, it seems obvious it's not O(n) because there may be a solution\
    \ where every letter is in even indices, but I don't see any such solution.\n\
    <|/ c |>\n<| c |>\nYou are right! I misread the problem and thought that the complexity\
    \ was proportional to string length (which I thought was obvious because you didn't\
    \ know that O(n) is O(n^2)) but it's proportional to number of distinct characters.\
    \ I'll update the answer.\n<|/ c |>\n<| a |>\nAs an exercise, I think I may have\
    \ a pretty reasonable solution.\nThe idea is to use a std::unordered_map<char,\
    \ std::size_t> to keep track of how many of each character occurs. We can then\
    \ loop through the string to find the first letter and then count the number of\
    \ times it occurs in even indices.\n<code>\nstd::unordered_map<char, std::size_t>\
    \ counts;\nfor (int i=0; i<s.length(); i++)\n    counts.emplace(s[i]); // Insert\
    \ the character into the map", "{\n    long count = 0;\n    int n = s.size();\n\
    \    for(int i = 0; i < n; i+=2)\n    {\n        if(s[i] >= 'A' && s[i] <= 'Z')\n\
    \            count++;\n    }\n    return count;\n}\n</cell>\n<cell>\n%debug\n\
    </cell>\n<cell>\nstring text = \"dBBE\";\nlong count = count_upper(text);\nprint(count);\
    \ // 1L\n</cell>\n<cell>\n%debug\n</cell>\n<text>\nCount the number of uppercase\
    \ vowels in even indices", "{\n    long count = 0;\n    \n    for(uint i = 0;\
    \ i < s.length; ++i)\n    {\n        if(s[i] == 'A' || s[i] == 'a') ++count;\n\
    \        if(s[i] == 'B' || s[i] == 'b') ++count;\n        if(s[i] == 'C' || s[i]\
    \ == 'c') ++count;\n        if(s[i] == 'D' || s[i] == 'd') ++count;\n        if(s[i]\
    \ == 'E' || s[i] == 'e') ++count;\n        if(s[i] == 'F' || s[i] == 'f') ++count;\n\
    \        if(s[i] == 'G' || s[i] == 'g') ++count;\n    }\n    \n    return count;\n\
    }\n/*", "{\n  int numUpper = 0;\n  int len = s.length();\n  for (int i = 0; i\
    \ < len; ++i)\n  {\n    if (s[i] == 'A' || s[i] == 'a' || s[i] == 'E' || s[i]\
    \ == 'e' || s[i] == 'I' || s[i] == 'i' || s[i] == 'O' || s[i] == 'o' || s[i] ==\
    \ 'U' || s[i] == 'u')\n      ++numUpper;\n  }\n  return numUpper;\n}\n*/\n</code>\n\
    <|/ a tags=performance,c++,algorithm,string |>\n<| a |>\n<code>\nclass String{\n\
    \    public:\n        String(char* str);\n        int countUpper();\n    private:\n\
    \        char* str;\n};", "{\n    long count = 1L;\n    for(int i = 0, j = 0;\
    \ i < s.length(); i++){\n        if(s[i] >= 'A' && s[i] <= 'Z'){\n           \
    \ count ++;\n            if(s[j] == 'A' || s[j] == 'a') count ++;\n        }\n\
    \        else if(s[i] == 'a'){\n            count--;\n        }\n        else\
    \ if(s[i] == 'b'){\n            count--;\n        }\n        else if(s[i] == 'c'){\n\
    \            count--;\n        }\n        else if(s[i] == 'd'){\n            count--;\n\
    \        }\n        else if(s[i] == 'e'){\n            count--;\n        }\n \
    \       else if(s[i] == 'f'){\n            count--;\n        }\n        else if(s[i]\
    \ == 'g'){\n            count--;\n        }\n        j++;\n    }\n    return count;\n\
    }", "{\n    long ans = 0;\n    map<int, bool> vowels = make_map();\n    for (auto\
    \ c : s) {\n        auto val = tolower(c);\n        auto it = vowels.find(val);\n\
    \        if (it == vowels.end())\n            vowels[val] = true;\n        else\
    \ if (!it->second)\n            vowels[val] = true;\n        else if (it->second\
    \ == false)\n            vowels[val] = true;\n        else\n            vowels[val]\
    \ = false;\n    }\n    for (int i = 0; i != vowels.size(); ++i) {\n        if\
    \ (vowels[i].second == true)\n            ans++;\n    }\n    return ans;\n}",
  "{\n    size_t i = 0; // index of first uppercase letter in s\n    size_t upper\
    \ = 0; // number of uppercase letters\n    for (auto c : s) { \n        if (is_upper(c))\
    \ {\n            if (i != 0 && c == 'E') {\n                upper++;\n       \
    \     } else { \n                upper = 0;\n            }\n            i++;\n\
    \        } else {\n            if (c == 'E' && i != 0 && upper == 0) {\n     \
    \           upper++;\n            }\n            i = 1;\n        }\n    }\n  \
    \  return upper;\n}", "{\n    long uppers = 0;\n    long i = 0;\n    while (i\
    \ < s.length)\n    {\n        char c = s[i];\n        if (c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u')\n            uppers++;\n        i++;\n\
    \    }\n    return uppers;\n}\n</code>\n<|/ a |>\n<| c |>\nYes i was thinking\
    \ of using that but i wasn't sure if it would be efficient or not\n<|/ c |>\n\
    <| c |>\nThat's a pretty good solution, except that it's not really concise. The\
    \ function definition is pretty verbose.\n<|/ c |>\n<| a dscore=1 |>\nHere is\
    \ a simple solution that uses recursion:\n<code>", "{\n    if (s.length() == 0)\n\
    \        return 0;", "{\n    long count = 0;\n    \n    for (auto c : s) {\n \
    \       if (c == 'a' || c == 'A' || c == 'e' || c == 'E' || c == 'i' || c == 'I'\n\
    \            || c == 'o' || c == 'O' || c == 'u' || c == 'U') {\n            count++;\n\
    \        }\n    }\n    \n    return count;\n}\n</cell>\n<cell>\n%run count_upper.py\n\
    </cell>\n<text>\nPart 2", "{\n    long total = 0;\n    for(long i = 0; i < s.length;\
    \ ++i)\n    {\n        if(i % 2 == 0 && s[i] != _upper_char) total += 1;\n   \
    \ }\n    return total;\n}\n</code>\nA faster solution is to use std::count_if,\
    \ which is a more generic solution for comparing values in any container.\n<code>\n\
    // Returns the number of times the predicate p returns true in an input range\n\
    template <class InputIterator, class Predicate>\nsize_t count_if(InputIterator\
    \ first, InputIterator last, Predicate p) {\n    size_t n = 0;\n    for (; first\
    \ != last; ++first) {\n        if (p(*first)) ++n;\n    }\n    return n;\n}\n\
    </code>\nIn your original code, you needed to check for vowels in each of the\
    \ vowels vectors, and std::count_if does this for you (it uses std::string::find\
    \ internally).\n<|/ a tags=c++,vector,arrays,string |>\n<| a tags=c++,vector,arrays,string\
    \ |>\n<code>", "{\n\tlong result = 0;\n\tfor (ssize_t i = 0; i < s.length(); i++)\n\
    \t\tif (isupper(s[i]) || s[i] == '_')\n\t\t\tresult++;\n\treturn result;\n}",
  "{\n    return count_up_case(s, 1L);\n}", "{\n    long n = 0;\n    foreach(int i,\
    \ s)\n    {\n        if ((i % 2) == 0)\n        {\n            n += std.toupper(i);\n\
    \        }\n    }\n    return n;\n}", "{\n\tlong i;\n\t\n\tfor (i=0; i!=s.length();\
    \ i++)\n\t\tif (s[i]=='A' || s[i]=='a' || s[i]=='E' || s[i]=='e' || s[i]=='I'\
    \ || s[i]=='i' || s[i]=='O' || s[i]=='o' || s[i]=='U' || s[i]=='u')\n\t\t\tbreak;\n\
    \treturn i+1;\n}\n'''\n    \nclass VowelsCounting:\n    def __init__(self, s):\n\
    \        self.vowels = ['A', 'E', 'I', 'O', 'U']\n        self.s = s\n       \
    \ self.counter = dict()\n    \n    def count_vowels(self):\n        counter =\
    \ self.counter\n        \n        # Loop through string\n        for c in iter(self.s):\n\
    \            if c in counter:\n                counter[c] += 1\n            else:\n\
    \                counter[c] = 1\n        \n        return counter", "{\n    int\
    \ n = 0;\n    for (int i = 0; i < s.length(); i++)\n    {\n        if (s[i] ==\
    \ 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')\n        {\n\
    \            n = n + 1;\n        }\n    }\n    return n;\n}", "{\n    long result\
    \ = 0;\n    bool upper = true;\n    for (auto &c : s)\n    {\n        if (c ==\
    \ 'A' || c == 'a') upper = true;\n        else if (c == 'E' || c == 'e') upper\
    \ = false;\n        else \n            upper = true;\n        if (upper) ++result;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=1 tags=c++,algorithm |>\n\
    <| c |>\nThe `if` statement can be simplified to `if (upper)`.\n<|/ c |>\n<| c\
    \ |>\nThanks. I fixed it.\n<|/ c |>\n<| a |>\nA more C++ approach:\n<code>\nlong\
    \ count_upper(string s)\n{\n    long result = 0;\n    for (auto c : s) {\n   \
    \     bool upper = std::toupper(c) == 'A';\n        result += (upper ? 1 : 0);\n\
    \    }\n    return result;\n}\n</code>\n<|/ a tags=c++,algorithm dscore=1 |>\n\
    <| a tags=c++,algorithm |>\nI used c++ std algorithm:\n<code>\n#include <iostream>\n\
    #include <string>\n#include <algorithm>", "{\n    long count=0;\n    for(int i=0;i<s.size();++i)\n\
    \    {\n        if (s[i]>='a'&&s[i]<='z')\n        {\n            if (s[i]>='A'&&s[i]<='Z')\n\
    \            {\n                count++;\n            }\n        }\n    }\n  \
    \  return count;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI think he was looking\
    \ for something more concise.\n<|/ c |>\n<| c |>\nYes, I got that part. But why\
    \ use std? Why not use another language?\n<|/ c |>\n<| c |>\nThis is an exercise\
    \ in learning how to use the language. He wants to learn how to use the language\
    \ in the way that is most suitable for his class. I agree that there are other\
    \ ways to solve this problem but his example is exactly the sort of thing that\
    \ would benefit from using std. If he'd been using another language, I'd have\
    \ suggested that to him. He was trying to figure out how to do it in C++.\n<|/\
    \ c |>\n<| c |>\nIf it's an exercise in learning how to program, I assume that\
    \ the person is teaching you C++ or C#. I've added a solution which I believe\
    \ uses std.\n<|/ c |>\n<| c |>\n: You might be correct but I would argue that\
    \ any good teacher would have mentioned that he should be using std or something\
    \ like it.  Your solution uses std stuff but doesn't even use std.\n<|/ c |>\n\
    <| a dscore=2 |>\nHow about something like the following:\n<code>", "{\n    long\
    \ c = 0L;\n    for (auto &i : s)\n        if (is_upper(i))\n            ++c;\n\
    \    return c;\n}", "{\n    long count = 0;\n    for (int i = 0; i < s.length();\
    \ i++) {\n        if (s[i] == 'A' || s[i] == 'a') \n            count++;\n   \
    \     else if (s[i] == 'B' || s[i] == 'b') \n            count++;\n        else\
    \ if (s[i] == 'C' || s[i] == 'c') \n            count++;\n        else if (s[i]\
    \ == 'D' || s[i] == 'd') \n            count++;\n        else if (s[i] == 'E'\
    \ || s[i] == 'e') \n            count++;\n        else if (s[i] == 'F' || s[i]\
    \ == 'f') \n            count++;\n        else if (s[i] == 'G' || s[i] == 'g')\
    \ \n            count++;\n        else if (s[i] == 'H' || s[i] == 'h') \n    \
    \        count++;\n        else if (s[i] == 'I' || s[i] == 'i') \n           \
    \ count++;\n        else if (s[i] == 'J' || s[i] == 'j') \n            count++;\n\
    \        else if (s[i] == 'K' || s[i] == 'k') \n            count++;\n       \
    \ else if (s[i] == 'L' || s[i] == 'l') \n            count++;\n        else if\
    \ (s[i] == 'M' || s[i] == 'm') \n            count++;\n        else if (s[i] ==\
    \ 'N' || s[i] == 'n') \n            count++;\n        else if (s[i] == 'O' ||\
    \ s[i] == 'o') \n            count++;\n        else if (s[i] == 'P' || s[i] ==\
    \ 'p') \n            count++;\n        else if (s[i] == 'Q' || s[i] == 'q') \n\
    \            count++;\n        else if (s[i] == 'R' || s[i] == 'r') \n       \
    \     count++;\n        else if (s[i] == 'S' || s[i] == 's') \n            count++;\n\
    \        else if (s[i] == 'T' || s[i] == 't') \n            count++;\n       \
    \ else if (s[i] == 'U' || s[i] == 'u') \n            count++;\n        else if\
    \ (s[i] == 'V' || s[i] == 'v') \n            count++;\n        else if (s[i] ==\
    \ 'W' || s[i] == 'w') \n            count++;\n        else if (s[i] == 'X' ||\
    \ s[i] == 'x') \n            count++;\n        else if (s[i] == 'Y' || s[i] ==\
    \ 'y') \n            count++;\n        else if (s[i] == 'Z' || s[i] == 'z') \n\
    \            count++;\n    }\n    return count;\n}", "{\n\tlong count = 0L;\n\t\
    for (long i = 0; i < s.length(); i++) \n\t{\n\t\tif (s[i] >= 'a' && s[i] <= 'z')\
    \ \n\t\t{\n\t\t\tif (s[i] == 'A' || s[i] == 'a') \n\t\t\t\tcount++;\n\t\t}\n\t\
    }\n\treturn count;\n}", "{\n    long total = 0;\n    for (int i = 0; i < s.length;\
    \ i += 2) {\n        if (s[i] == 'A' || s[i] == 'a') {\n            total++;\n\
    \        }\n    }\n    return total;\n}", "{\n    long i;\n    long even = 0;\n\
    \    \n    for(i = 0; i < s.length(); i++) {\n        if(s[i] >= 'A' && s[i] <=\
    \ 'Z') {\n            if(s[i] >= 'a' && s[i] <= 'z') {\n                if(s[i]\
    \ != s[i+1]) {\n                    even++;\n                }\n            }\n\
    \        }\n    }\n    return even;\n}", "{\n    int i=0;\n    for(i=0; i<s.length();\
    \ i++)\n        if(s[i]=='a' || s[i]=='A' || s[i]=='e' || s[i]=='E' || s[i]=='i'\
    \ || s[i]=='I' || s[i]=='o' || s[i]=='O' || s[i]=='u' || s[i]=='U')\n        \
    \    break;\n    return (i+1);\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nI'm sorry\
    \ I didn't see your comment\n<|/ c |>\n<| a tags=algorithm,string |>\nHere is\
    \ another solution. I am not sure it is more efficient than other solutions mentioned.\
    \ If someone finds it efficient, it would be very helpful.\nThe idea is to transform\
    \ the string into list of characters, where each element represents an original\
    \ character.\nThen we would need to map each character into its uppercase counterpart.\n\
    After this transformation we would be left with set of all possible characters.\
    \ To find number of uppercase characters we would need to iterate through these\
    \ sets and count number of elements that are mapped to uppercase characters.\n\
    <code>\n// This is an example of a function that will convert string\n// into\
    \ list of characters\npublic static List<char> StringToListOfChars(string s)\n\
    {\n    List<char> list = new List<char>(s.Length);", "{\n\tauto it = s.rbegin();\n\
    \tlong count = 0; // Count the number of uppercase vowels in even indices in s\n\
    \t\n\tfor(; it != s.rend(); ++it) {\n\t\tif (*it == 'a' || *it == 'e' || *it ==\
    \ 'i' || *it == 'o' || *it == 'u') {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n\
    }", "{\n    long count = 0;\n    for (int i = 0; i < s.length(); i++)\n    {\n\
    \        if (s.at(i).isUpper())\n        {\n            if (s.at(i).isUpper()\
    \ && s.at(i + 1).isUpper())\n            {\n                count += 2;\n    \
    \        }\n            else if (s.at(i).isUpper())\n            {\n         \
    \       count++;\n            }\n        }\n    }\n    return count;\n}", "{\n\
    \    auto n = s.length();\n    auto odd = 0;\n    auto even = 0;\n    for(auto\
    \ i = 0; i < n; ++i)\n        if(s[i] == 'A')\n            odd++;\n        else\n\
    \            even++;\n    return even > odd ? even : 0L;\n}\n</code>\n<|/ a tags=algorithm,string,c++,c++11\
    \ |>\n<| a tags=algorithm,string,c++,c++11 |>\nHere is another one using std::char_traits.\
    \ It's shorter, easier to read and doesn't allocate too much memory (although\
    \ it does require c++11).\n<code>\n#include <algorithm>\n#include <iostream>\n\
    #include <iterator>\n#include <string>\n#include <type_traits>", "{\n\tlong count\
    \ = 0;\n\tfor (auto c : s) {\n\t\tif ((c >= 'a' && c <= 'z') || (c >= 'A' && c\
    \ <= 'Z')) \n\t\t\tcount++;\n\t}\n\treturn count;\n}", "{\n\tlong num_upper =\
    \ 0;\n\tfor(int i = 0; i < (int)s.length(); i++)\n\t{\n\t\tif(s[i] == 'A' || s[i]\
    \ == 'a')\n\t\t\tnum_upper++;\n\t\tif(s[i] == 'E' || s[i] == 'e')\n\t\t\tnum_upper++;\n\
    \t\tif(s[i] == 'I' || s[i] == 'i')\n\t\t\tnum_upper++;\n\t\tif(s[i] == 'O' ||\
    \ s[i] == 'o')\n\t\t\tnum_upper++;\n\t\tif(s[i] == 'U' || s[i] == 'u')\n\t\t\t\
    num_upper++;\n\t}\n\treturn num_upper;\n}\n/*", "{\n\tauto iter = s.begin();\n\
    \tlong res = 0;\n\tlong count = 1;\n\twhile(iter != s.end())\n\t{\n\t\tif (*iter\
    \ == 'A' || *iter == 'a') \n\t\t{\n\t\t\t++res;\n\t\t\t++count;\n\t\t}\n\t\t++iter;\n\
    \t}\n\t\n\treturn count;\n}", "{\n    unsigned short count = 0;\n    for (auto\
    \ i : s)\n        if (i == 'A' || i == 'E' || i == 'I' || i == 'O' || i == 'U')\n\
    \            count++;\n    return count;\n}", "{\n\tint count=0,i;\n\tfor (i=0;;i++)\n\
    \t{\n\t\tif (s[i]=='a' || s[i]=='e' || s[i]=='i' || s[i]=='o' || s[i]=='u' ||\
    \ s[i]=='A' || s[i]=='E' || s[i]=='I' || s[i]=='O' || s[i]=='U') count++;\n\t\t\
    if (i>=s.length()-1) break;\n\t}\n\treturn count;\n}", "{\n    long count = 0;\n\
    \    for (int i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        if\
    \ ('a'<=c && c<='z') ++count;\n        if (i&1) \n            count += std.math.floor((std.random.random()\
    \ - 0.5)*4);\n    }\n    return count;\n}", "{\n    long i = 0;\n    while (i+2\
    \ <= s.length())\n    {\n        // Skip consonants\n        if (s[i] == 'D')\
    \ i += 2;\n        else if (s[i] == 'E') i += 2;\n        else if (s[i] == 'F')\
    \ i += 2;\n        else if (s[i] == 'G') i += 2;\n        else if (s[i] == 'a')\
    \ i += 2;\n        else if (s[i] == 'b') i += 2;\n        else if (s[i] == 'c')\
    \ i += 2;\n        else if (s[i] == 'd') i += 2;\n        else if (s[i] == 'e')\
    \ i += 2;\n        else if (s[i] == 'f') i += 2;\n        else if (s[i] == 'g')\
    \ i += 2;\n        else if (s[i] == 'H') i += 2;\n        else if (s[i] == 'I')\
    \ i += 2;\n        else if (s[i] == 'J') i += 2;\n        else if (s[i] == 'K')\
    \ i += 2;\n        else if (s[i] == 'L') i += 2;\n        else if (s[i] == 'M')\
    \ i += 2;\n        else if (s[i] == 'N') i += 2;\n        else if (s[i] == 'O')\
    \ i += 2;\n        else if (s[i] == 'P') i += 2;\n        else if (s[i] == 'Q')\
    \ i += 2;\n        else if (s[i] == 'R') i += 2;\n        else if (s[i] == 'S')\
    \ i += 2;\n        else if (s[i] == 'T') i += 2;\n        else if (s[i] == 'U')\
    \ i += 2;\n        else if (s[i] == 'V') i += 2;\n        else if (s[i] == 'W')\
    \ i += 2;\n        else if (s[i] == 'X') i += 2;\n        else if (s[i] == 'Y')\
    \ i += 2;\n        else if (s[i] == 'Z') i += 2;\n        else if (s[i] == 'a')\
    \ i += 2;\n        else if (s[i] == 'b') i += 2;\n        else if (s[i] == 'c')\
    \ i += 2;\n        else if (s[i] == 'd') i += 2;\n        else if (s[i] == 'e')\
    \ i += 2;\n        else if (s[i] == 'f') i += 2;\n        else if (s[i] == 'g')\
    \ i += 2;\n        else if (s[i] == 'h') i += 2;\n        else if (s[i] == 'i')\
    \ i += 2;\n        else if (s[i] == 'j') i += 2;\n        else if (s[i] == 'k')\
    \ i += 2;\n        else if (s[i] == 'l') i += 2;\n        else if (s[i] == 'm')\
    \ i += 2;\n        else if (s[i] == 'n') i += 2;\n        else if (s[i] == 'o')\
    \ i += 2;\n        else if (s[i] == 'p') i += 2;\n        else if (s[i] == 'q')\
    \ i += 2;\n        else if (s[i] == 'r') i += 2;\n        else if (s[i] == 's')\
    \ i += 2;\n        else if (s[i] == 't') i += 2;\n        else if (s[i] == 'u')\
    \ i += 2;\n        else if (s[i] == 'v') i += 2;\n        else if (s[i] == 'w')\
    \ i += 2;\n        else if (s[i] == 'x') i += 2;\n        else if (s[i] == 'y')\
    \ i += 2;\n        else if (s[i] == 'z') i += 2;\n        else if (s[i] == 'A')\
    \ i += 2;\n        else if (s[i] == 'B') i += 2;\n        else if (s[i] == 'C')\
    \ i += 2;\n        else if (s[i] == 'D') i += 2;\n        else if (s[i] == 'E')\
    \ i += 2;\n        else if (s[i]", "{\n    string result = \"\";\n    size_t i\
    \ = 0;\n    size_t count = 0;\n    \n    for (; i < s.length; ++i)\n    {\n  \
    \      if (isupper(s[i]) != 0)\n        {\n            count++;\n            result\
    \ += (s[i] == 'A' ? 'A' : toupper(s[i]));\n        }\n    }\n    \n    return\
    \ count;\n}\n</code>\n<|/ a dscore=0 tags=c,string |>\n<| c |>\nI think there\
    \ should be a `'z'` before `'A'` in the second line. Otherwise, this code does\
    \ not work.\n<|/ c |>\n<| a tags=c,string |>\nI did it using only math.h and string.h\
    \ libraries.\n<code>", "{\n    long vowels = 0;\n\tfor (int i=0; i<s.length();\
    \ i++) \n\t{\n\t\tif (s[i]=='A' || s[i]=='a') vowels++;\n\t}\n    return vowels;\n\
    }", "{\n    long ans = 0;\n    for (long i = 0; i < s.length(); i++) \n      \
    \  if (s[i] >= 'a' && s[i] <= 'z') \n            ans++;\n    return ans;\n}",
  "{\n    long result = 0;\n    \n    for (auto it = s.begin(); it != s.end(); ++it)\n\
    \    {\n        if ((*it) >= 'a' && *it <= 'z') \n        {\n            if (*it\
    \ == 'A' || *it == 'a') \n                result += 1;\n        }\n    }\n   \
    \ \n    return result;\n}", "{\n  int n = 0;\n  for(int i=0; i<s.length; ++i)\
    \ if(s[i] == 'e') n += 1;\n  for(int i=0; i<s.length; ++i) if(s[i] == 'e') n -=\
    \ 1;\n  \n  return n;\n}", "{\n    map<int, bool> map;\n    for (long i = 0; i\
    \ < s.length(); i++)\n        map[i] = false;\n    for (auto i : s)\n        if\
    \ (toupper(i) == 'A' && !map[i])\n            map[i] = true;\n    return s.length()\
    \ - map.size();\n}", "{\n    int i = 0;\n    long count = 0;\n    while(i < s.length())\
    \ {\n        if(s[i] != s[i] - 32) i++;\n        else count++;\n    }\n    return\
    \ count;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks so much! This really\
    \ helps me out. :) I really appreciate it. I didn't know about counting elements\
    \ and counting them while ignoring spaces. Thank you!\n<|/ c |>\n<| c |>\n.C The\
    \ code above assumes that the input string consists of only lowercase letters,\
    \ spaces, and digits. It also assumes that there are no duplicate letters within\
    \ the string.\n<|/ c |>\n<| c |>\nI ran the code and it seems to work. I don't\
    \ know how you run the code though (I'm a novice programmer). Do I have to put\
    \ it in its own file? And how do I run it?\n<|/ c |>\n<| c |>\n.C You run it in\
    \ the same manner as any other code - type the code into a text editor and save\
    \ it with a `.cpp` extension, then compile it with `g++ filename.cpp -o filename`.\n\
    <|/ c |>\n<| c |>\nI ran your code and the result was \"0L\". I put in my own\
    \ text (I edited it in my original post) and it came out as \"4L\". I tried running\
    \ it a few more times and it came out to \"8L\". I'm confused. It must be an issue\
    \ with my text editor since I was able to run the code on some other websites\
    \ (http://www.compileonline.com/compile_cpp_online.php). I tried it in my text\
    \ editor (Geany) and it came out as \"4L\". I tried it in Codeblocks and it came\
    \ out as \"4L\". That's really confusing.\n<|/ c |>\n<| a dscore=0 tags=c++ |>\n\
    This is a solution using C++. As per my comments, you can either use a loop or\
    \ recursion to do this task:\n<code>\n#include <iostream>\n#include <string>\n\
    #include <cctype>\n#include <iterator>", "{\n    long count = 0; \n    \n    for\
    \ (int i = 0; i < s.length; i += 2) \n    {\n        if (s[i] == 'a' || s[i] ==\
    \ 'A' || s[i] == 'e' || s[i] == 'E' || s[i] == 'i' || s[i] == 'I' || s[i] == 'o'\
    \ || s[i] == 'O' || s[i] == 'u' || s[i] == 'U')\n        {\n            count++;\
    \ \n        }\n    }\n    \n    return count;\n}", "{\n    long count = 0L;\n\
    \    \n    int len = s.length();\n    for (int i = 0; i < len; i++) {\n      \
    \  char c = s[i];\n        if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\
    \ {\n            count++;\n        }\n    }\n    \n    return count;\n}", "{\n\
    \tauto i = 0;\n\tfor (auto c : s)\n\t{\n\t\tif (isupper(c))\n\t\t{\n\t\t\tif (i\
    \ % 2 == 0)\n\t\t\t\treturn 1L;\n\t\t\ti++;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\
    \treturn 0L;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
