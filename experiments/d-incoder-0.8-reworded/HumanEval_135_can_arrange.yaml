name: HumanEval_135_can_arrange
language: d
prompt: "import std.math;\n/*\nCreate a function which returns the largest index of\
  \ an element which\n    is not greater than or equal to the element immediately\
  \ preceding it. If\n    no such element exists then return -1. The given array will\
  \ not contain\n    duplicate values.\n\n    Examples:\n    >>> can_arrange([1L,\
  \ 2L, 4L, 3L, 5L])\n    3L\n    >>> can_arrange([1L, 2L, 3L])\n    -1L\n    \n*/\n\
  long can_arrange(long[] arr) \n"
tests: "unittest\n{\n    alias candidate = can_arrange;\n\n    assert(candidate([1L,\
  \ 2L, 4L, 3L, 5L]) == 3L);\n    assert(candidate([1L, 2L, 4L, 5L]) == -1L);\n  \
  \  assert(candidate([1L, 4L, 2L, 5L, 6L, 7L, 8L, 9L, 10L]) == 2L);\n    assert(candidate([4L,\
  \ 8L, 5L, 7L, 3L]) == 4L);\n    assert(candidate([]) == -1L);\n}\nvoid main(){}"
completions: ["{\n    long res = -1;\n    \n    if(arr[0] != -1) res = arr[0]+1;\n\
    \    \n    for(int i = 0; i < arr.length-1; ++i){\n        if(arr[i] < arr[i+1]){\n\
    \            break;\n        }\n        res = arr[i];\n    }\n    \n    return\
    \ res;\n}\n</code>\n<|/ a tags=algorithm,c++ dscore=1 |>\n<| a tags=algorithm,c++\
    \ dscore=1 |>\nI recently had to solve this problem and came up with this Python\
    \ solution:\n<code>\ndef canArrange(nums):\n    \"\"\"\n    >>> canArrange([1,2,4,3,5,1])\n\
    \    0\n    >>> canArrange([1,2,3,4,5,1])\n    1\n    >>> canArrange([1,3,2,4,5,1])\n\
    \    4\n    >>> canArrange([1,3,2,4,5,6,7,8,9])\n    5\n    \"\"\"\n    \n   \
    \ # Create a map of all the values already seen.\n    seen = {num: False for num\
    \ in nums}", "{\n    long idx = 0;\n    for (long i = 0, imax = arr.length - 1;\
    \ i < imax; ++i) \n    {\n        if (arr[i] <= arr[i + 1]) \n        {\n    \
    \        idx = i;\n            break;\n        }\n    }", "{\n\tlong  curr = -1L;\n\
    \tlong l = 1;\n\tfor (int i = 0; i < arr.length; i++) {\n\t\tif (curr == -1 ||\
    \ arr[i] <= arr[curr])\n\t\t\tcurr = i;\n\t}\n\t\n\tif (curr != -1L) {\n\t\t\n\
    \t\t\n\t\t\n\t\t\n\t\treturn arr[curr];\n\t\t\n\t}\n\t\n\t\n\treturn -1L;\n\t\n\
    }\n/*\nCreate a function which returns the smallest index of an element which\n\
    \    is not less than or equal to the element immediately preceding it. If\n \
    \   no such element exists then return -1. The given array will not contain\n\
    \    duplicate values.", "{\n\tlong l = arr.length-1;\n\tfor (int i = 0; i < l;\
    \ ++i) {\n\t\tif (arr[i] < arr[i-1]) break;\n\t}\n\tif (i == l) {\n\t\treturn\
    \ -1;\n\t}\n\treturn i;\n}\n/*\nCreate a function which returns the index of the\
    \ element in the given\n    array which has a value greater than the value of\
    \ the element being\n    found. If no such element is found then return -1.\n\
    \    \n    Examples:\n    >>> can_bruteforce([1L, 2L, 4L, 3L, 5L])\n    4L\n \
    \   >>> can_bruteforce([1L, 2L, 3L])\n    -1L\n*/\nlong can_bruteforce(long[]\
    \ arr) \n{\n\tlong l = arr.length-1;\n\tfor (int i = 0; i <= l; ++i) {\n\t\tif\
    \ (arr[i] < arr[i+1]) return i;\n\t}\n\treturn -1;\n}", "{\n    long max_idx =\
    \ 0;\n    long idx = 0;\n    long prev_idx = 0;\n    for(idx=0; idx < arr.length-1;\
    \ idx++) {\n        if(arr[idx] > arr[prev_idx]) {\n            max_idx = idx;\n\
    \        }\n        prev_idx = idx;\n    }\n    return max_idx;\n}", "{\n    int\
    \ i;\n    long max_index;\n    long max_value = arr[0];\n    max_index = 0;\n\
    \    for(i = 0; i < arr.length; i++) \n    {\n        if(max_value < arr[i]) \n\
    \        {\n            max_value = arr[i];\n            max_index = i;\n    \
    \    }\n    }\n    if(max_index > 0) \n    {\n        return max_index;\n    }\n\
    \    else \n    {\n        return -1;\n    }\n}\n</code>\n<|/ a |>\n<| c |>\n\
    The only answer that explains the algorithm clearly and in a way that does not\
    \ confuse beginners. It doesn't matter what language you use. Thank you sir. My\
    \ first programming language was Java and it was a complete nightmare to figure\
    \ out how to do this.\n<|/ c |>\n<| c |>\nGreat code, but I believe there is an\
    \ error on the second line of the `can_arrange` function.  The `max_value` variable\
    \ should be initialized to `arr[0]`.\n<|/ c |>\n<| a dscore=3 |>\n<code>\n#include\
    \ <stdio.h>\n#include <stdlib.h>", "{\n\tlong result = -1;\n\t\n\tfor (long i\
    \ = 0; i < arr.length - 1; i++) \n\t{\n\t\tif (arr[i] <= arr[i + 1]) \n\t\t\t\
    result = i;\n\t}\n\t\n\treturn result;\n}", "{\n    long res = -1;\n    if (arr.length\
    \ == 0) return 0;\n    long prev = arr[0];\n    long max = arr[0];\n    for (int\
    \ i = 1; i < arr.length; i++) {\n        if (arr[i] <= prev) {\n            res\
    \ = i;\n            prev = arr[i];\n        }\n        if (arr[i] > max) {\n \
    \           max = arr[i];\n            res = i;\n        }\n    }\n    return\
    \ res;\n}\n</code>\n<|/ a tags=arrays,c++,algorithm dscore=0 |>\n<| a |>\nI used\
    \ this logic and it worked for me\n<code>", "{\n    long maxIndex = -1;\n    long\
    \ i1 = arr.length - 1;\n    long i2 = 1;\n    while (i1 >= i2) \n    {\n     \
    \   long i = (i1 + i2)/2;\n        if (arr[i] <= arr[i1]) \n            i1 = i;\n\
    \        else \n            i2 = i;\n    }\n    if (i2 > maxIndex) \n        maxIndex\
    \ = i2;\n    return maxIndex;\n}", "{\n  long first = std.max(arr[0]);\n  long\
    \ last = std.max(arr[arr.length-1]);", "{\n\tlong max = arr[0];\n\tlong min =\
    \ arr[0];\n\tint i;\n\tfor (i = 1; i < arr.length; ++i)\n\t{\n\t\tif (max < arr[i])\n\
    \t\t{\n\t\t\tmax = arr[i];\n\t\t}\n\t\telse if (arr[i] < min)\n\t\t{\n\t\t\tmin\
    \ = arr[i];\n\t\t}\n\t}\n\treturn max < arr[i-1] ? i : -1;\n}", "{\n    long ans\
    \ = -1;\n    \n    for (int i = arr.length-1; i >= 0; i--) \n    {\n        if\
    \ (arr[i] < arr[i-1]) \n        {\n            ans = i;\n            break;\n\
    \        }\n    }", "{\n   long i,max;\n   max=arr[0];\n   for (i=1; i<arr.length;\
    \ ++i)\n   {\n      if (arr[i]>=max)\n      {\n         max=arr[i];\n      }\n\
    \   }\n   return (arr[i]<max)?-1:i;\n}", "{\n\tint n = arr.length;\n\tlong low\
    \ = arr[0];\n\tlong max = arr[n - 1];\n\tint i= 0;", "{\n  long maxIndex = std.math.maxIndex(\
    \ arr );\n  return std.math.indexWhere( arr == maxIndex ? 1 : 0, arr );\n}", "{\n\
    \    long maxIndex = -1;\n    long index = 0;\n    for(int i=0; i<arr.length;\
    \ i++) {\n        while(arr[i] > arr[index]) {\n            index++;\n       \
    \ }\n        if(index == arr.length || arr[i] < arr[index]) {\n            return\
    \ -1;\n        }\n        if(maxIndex < index) {\n            maxIndex = index;\n\
    \        }\n        index++;\n    }\n    return maxIndex;\n}\n</code>\n<|/ a |>\n\
    <| c |>\nThe question was to find the smallest index of any given number which\
    \ is not greater than or equal to the number at that index. Your solution is only\
    \ finding the largest index (which is not the same as the smallest index).\n<|/\
    \ c |>\n<| c |>\nOh wait. Your solution actually works as expected (but only in\
    \ certain cases). Having said that, I find it a bit strange and inefficient to\
    \ use an index variable. Is there a way to use the 'i' variable you used (for\
    \ loop) or is there a more efficient way of doing this?\n<|/ c |>\n<| c |>\nI\
    \ realized I misread your solution. Sorry for that. I'll give it a try now to\
    \ see if it works.\n<|/ c |>\n<| c |>\nI've updated my answer. Instead of using\
    \ the index variable, I've used the i variable for the outer loop.\n<|/ c |>\n\
    <| c |>\nI believe it's correct and does work. Just tested it. However, the code\
    \ is far from efficient. A better solution would be to remove the index variable\
    \ and replace it with the i variable. My solution would be to use a single loop.\n\
    <|/ c |>\n<| a tags=arrays,algorithm,java |>\nA solution using streams. First,\
    \ we sort the array and then get the first non-repeated value. Then we get the\
    \ index of the first repeated value.\n<code>", "{\n    long idx = 0;\n    long\
    \ maxIdx = 0;\n    long prevIdx = 0;\n    long curIdx = 0;\n    for(curIdx = 1;\
    \ curIdx < arr.length; curIdx++)\n    {\n        if(arr[curIdx] <= arr[prevIdx])\n\
    \        {\n            idx = prevIdx;\n            prevIdx = curIdx;\n      \
    \  }\n        else\n        {\n            idx = curIdx;\n            maxIdx =\
    \ prevIdx;\n        }\n    }\n    return maxIdx;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\nJust in case someone finds this useful, here's a solution using std.algorithm\n\
    <code>\nimport std.algorithm;", "{\n    long low = arr[0];\n    long high = arr[0];\n\
    \    for(int i = 1; i < arr.length; i++){\n        if(arr[i] >= high){\n     \
    \       high = arr[i];\n        }\n        if(low > arr[i]){\n            low\
    \ = arr[i];\n        }\n    }\n    return low;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\n<code>\nfunction get_maxIndex(A) {\n  var maxIndex = 0;\n  for(var\
    \ i = 1; i < A.length; i++){\n    if(A[i] > A[maxIndex]){\n      maxIndex = i;\n\
    \    }\n  }\n  return maxIndex;\n}\n</code>\n<|/ a tags=algorithm,c++ |>\n<| c\
    \ |>\nPlease explain your code.\n<|/ c |>\n<| a |>\n<code>\nfunction arrayMaxIndex(arr)\
    \ {\nlet maxIndex = 0;\nlet maxIndexValue = 0;\nlet index = arr.length - 1;\n\
    while (index >= 0) {\n   if (arr[index] > maxIndexValue) {\n      maxIndexValue\
    \ = arr[index];\n      maxIndex = index;\n   }\n   index--;\n}\nreturn maxIndex\n\
    </code>\n}\n<|/ a dscore=0 tags=algorithm,c++ |>\n<| a dscore=0 |>\n<code>\n \
    \   \n    \n    #include<iostream>\n    #include<conio.h>\n    using namespace\
    \ std;\n    int main()\n    {\n        int a,b;\n        int n;\n        cin>>n;\n\
    \        int arr[n];\n        cout<<\"Enter the numbers : \";\n        for(int\
    \ i=0;i<n;i++)\n        {\n            cin>>arr[i];\n        }\n        cout<<\"\
    Maximum Index = \"<<arr[n-1];\n        return 0;\n    }\n</code>\n<|/ a tags=algorithm,c++\
    \ |>\n<| a |>\n<code>\n#include<iostream>\nusing namespace std;", "{\n    long\
    \ result = 0;\n    for (int i = 0; i < arr.length; ++i)\n    {\n        if (arr[i]\
    \ <= result) \n        {\n            if (result != -1)\n                result\
    \ = -1;\n            return i;\n        }\n    }\n    return result;\n}\n/*\n\
    Create a function which returns the smallest index of an element which\n    is\
    \ not less than or equal to the element immediately preceding it. If\n    no such\
    \ element exists then return -1. The given array will not contain\n    duplicate\
    \ values.", "{\n    if(arr.length == 0) return -1;\n    long result = 1;\n   \
    \ for(int i = 0; i < arr.length - 1; ++i)\n        if(arr[i] >= arr[i + 1])\n\
    \            result = max(result, i);\n    return result;\n}\n'''", "{\n    long\
    \ maxElem = arr[arr.length-1];\n    long index = 0;\n    for(int i = 1; i < arr.length;\
    \ i++)\n    {\n        if(arr[i] < maxElem)\n            index = i;\n        else\n\
    \            break;\n    }\n    if(index == arr.length)\n        index = -1;\n\
    \    return index;\n}", "{\n    long len = arr.Length;\n    int minpos = -1;\n\
    \    for (int i = 0; i < len; ++i)\n    {\n        int j;\n        for (j = i\
    \ + 1; j < len; ++j)\n        {\n            if (std.math.rem(arr[i], arr[j])\
    \ <= 0)\n            {\n                minpos = i;\n                break;\n\
    \            }\n        }\n    }\n    return minpos;\n}\n</code>\n<|/ a tags=c#,arrays\
    \ dscore=0 |>\n<| a tags=c#,arrays dscore=0 |>\nHere you go\n<code>\nstatic int\
    \ maxElement(int[] numbers)\n{\n    int maxIndex = 0;\n    int maxValue = 0;\n\
    \    for (int i = 0; i < numbers.Length; i++)\n    {\n        if (numbers[i] >\
    \ maxValue)\n        {\n            maxValue = numbers[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    return maxIndex;\n}\n</code>\n<|/ a |>\n<| a dscore=0\
    \ |>\nYou just need to find the first index of the largest number in the array.\
    \ \n<code>", "{\n\tlong maxElem = arr[0];\n\tlong maxIdx = 0;\n\tlong prevElem\
    \ = arr[0];\n\tfor(long i = 1; i < arr.length; i++)\n\t{\n\t\tif(arr[i] >= prevElem)\n\
    \t\t{\n\t\t\tmaxElem = arr[i];\n\t\t\tmaxIdx = i;\n\t\t}\n\t\tprevElem = arr[i];\n\
    \t}\n\treturn maxIdx;\n}\n/*\nCreate a function which returns a bool indicating\
    \ if a given sequence of\n    numbers can be arranged in a way that produces the\
    \ following sequence:\n    \n    2,3,5,1,4,6,8", "{\n    long i, largest=arr[0],\
    \ maxIdx = -1, index;\n    for(i=0;i<arr.length; i++){\n        if(arr[i]>=largest){\n\
    \            index = i;\n            largest = arr[i];\n        }\n    }\n   \
    \ \n    while(index!=0){\n        if(arr[index-1]>largest){\n            largest\
    \ = arr[index-1];\n            maxIdx = index-1;\n        }\n        index--;\n\
    \    }\n    return maxIdx;\n}\n</code>\n<|/ a tags=arrays,indexing,sorting,java\
    \ |>\n<| a dscore=0 tags=arrays,indexing,sorting,java |>\n<code>\npublic int maxIndex(int[]\
    \ A){\n    int maxIndex = 0;\n    int curMax = A[0];\n    for(int i=1;i<A.length;i++){\n\
    \        if(A[i]>curMax){\n            curMax = A[i];\n            maxIndex =\
    \ i;\n        }\n    }\n    return maxIndex;\n}\n</code>\n<|/ a |>\n<| a tags=arrays,indexing,sorting,java\
    \ |>\n<code>\n public static int maxIndex(int[] arr) {\n        int maxIndex =\
    \ -1;\n        int maxElement = arr[0];\n        for (int i = 0; i < arr.length;\
    \ i++) {\n            if (arr[i] > maxElement) {\n                maxIndex = i;\n\
    \                maxElement = arr[i];\n            }\n        }\n        return\
    \ maxIndex;\n    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nCould you add an explanation\
    \ as to how your answer solves the problem?\n<|/ c |>\n<| c |>\nI used a for loop\
    \ to iterate through the array and every time I find a greater number I set the\
    \ max index to the current index and max element to the current number in the\
    \ array. After the for loop I simply returned the value of the max index\n<|/\
    \ c |>\n<| c |>\nPlease edit your answer and add this information in, then delete\
    \ this comment.\n<|/ c |>\n<| c |>\nPlease add all such information in an edit\
    \ of your question not in a comment\n<|/ c |>\n<| a tags=arrays,indexing,sorting,java\
    \ |>\n<code>\npublic int maxIndex(int[] arr) {\n        int maxIndex = -1;\n \
    \       int maxElement = arr[0];\n        for (int i = 0; i < arr.length; i++)\
    \ {\n            if (arr[i] > maxElement) {\n                maxIndex = i;\n \
    \               maxElement = arr[i];\n            }\n        }\n        return\
    \ maxIndex;\n    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nPlease add all such information\
    \ in an edit of your question not in a comment\n<|/", "{\n\tint min_index = arr.length\
    \ - 1;\n\tlong min_val = arr[0];\n\tfor(int i = 1; i < arr.length; ++i)\n\t{\n\
    \t\tif(arr[i] <= min_val)\n\t\t{\n\t\t\tmin_index = i;\n\t\t\tmin_val = arr[i];\n\
    \t\t}\n\t}\n\tif(min_index == 0)\n\t{\n\t\treturn -1;\n\t}\n\tlong max_val = arr[min_index];\n\
    \tfor(int i = min_index - 1; i >= 0; --i)\n\t{\n\t\tif(arr[i] >= max_val)\n\t\t\
    {\n\t\t\treturn i;\n\t\t}\n\t\tmax_val = arr[i];\n\t}\n\treturn -1;\n}", "{\n\
    \    int n = arr.length;\n    long maxIndex = -1;\n    int minIndex = -1;\n  \
    \  for (int i = 0; i < n; ++i) {\n        if (arr[i] <= arr[minIndex]) {\n   \
    \         minIndex = i;\n        }\n        if (arr[i] >= arr[maxIndex]) {\n \
    \           maxIndex = i;\n        }\n    }\n    return maxIndex;\n}", "{\n\t\
    long maxIndex = 0;\n\tfor (int i = 0; i < arr.length; i++)\n\t{\n\t\tif (arr[i]\
    \ > arr[maxIndex])\n\t\t\tmaxIndex = i;\n\t}", "{\n    int max_index = 0;\n  \
    \  int max_value = arr[0];", "{\n\tlong i=0, largest = -1;\n\tfor (; arr[i] !=\
    \ 0; i++ )\n\t\tif ( arr[i] > largest )\n\t\t\tlargest = arr[i];\n\tif ( i < arr.length\
    \ )\n\t\treturn -1;\n\tlargest = 0;\n\tfor ( i = 1; i < arr.length; i++ )\n\t\t\
    if ( arr[i] > largest )\n\t\t\tlargest = arr[i];\n\treturn largest;\n}", "{\n\t\
    long max = -1;\n\tlong max_idx = -1;", "{\n\tif (arr.length < 2)\n\t\treturn -1L;\n\
    \tlong maxIndex = -1L;\n\tlong index = -1L;\n\tfor (int i = 1; i < arr.length;\
    \ ++i) {\n\t\tif (std.math.max(arr[i-1], arr[i]) > maxIndex) {\n\t\t\tmaxIndex\
    \ = std.math.max(arr[i-1], arr[i]);\n\t\t\tindex = i;\n\t\t}\n\t}\n\treturn index;\n\
    }", "{\n    long max_index = -1;\n    int n = arr.length;", "{\n  int i;\n  long\
    \ max = arr[0];\n  for (i = 1; i < arr.length; ++i) {\n    if (arr[i] <= max)\
    \ continue;\n    max = i;\n  }\n  return max;\n}\n</code>\n<|/ a dscore=3 |>\n\
    <| a tags=time-complexity,arrays,algorithm,sorting dscore=3 |>\nIf the data is\
    \ sorted (like it is) then you can do it in O(n log n).\nFirst, find the position\
    \ of the largest value that is less than or equal to its current position. \n\
    If the largest value is greater than or equal to the current position, find the\
    \ position of the smallest value that is greater than or equal to the largest\
    \ value. \nIf the smallest value is greater than or equal to the largest value,\
    \ then the largest value is in between them, so the smallest value is between\
    \ the current position and the current position plus the length of the array.\
    \ \nIf there is no such value, then there is no such position.\n<|/ a |>\n<| a\
    \ |>\nYou can do this in O(n) time and O(1) space.\nAssume the array is sorted\
    \ in non-decreasing order.\nFind the largest value smaller than the current one.\
    \ Let's call this value maxVal.\nFind the smallest value greater than maxVal.\
    \ Let's call this value minVal.\nThe smallest and largest values exist if minVal\
    \ <= maxVal\n<code>", "{\n\t// Complete this function...\n\tlong high = 0;\n\t\
    int n = arr.length;\n\tfor (int i = 0; i < n-1; ++i)\n\t{\n\t\tif (arr[i] >= arr[high])\n\
    \t\t\thigh = i;\n\t}\n\tif (high < 0)\n\t\treturn -1;\n\treturn high;\n}\n/* The\
    \ Solution 2\n    import std.array;\n    import std.array;\n    import std.collection;\n\
    \    import std.random;\n    import std.algorithm; \n    import std.math;\n  \
    \  import std.random;\n    import std.algorithm;\n    import std.math;\n    \n\
    \    \n    \n    class Solution2 {\n        \n        public var largestIndex:\
    \ Long;\n        public var secondLargestIndex: Long;\n        public var largest2Index:\
    \ Long;\n        \n        constructor(n: Long) {\n            this.largestIndex\
    \ = n;\n            this.secondLargestIndex = n;\n            this.largest2Index\
    \ = n;\n        }\n        \n        public function CanArrangeIt(arr: LongArray):\
    \ Long {\n            return can_arrange(arr);\n        }\n    }\n*/", "{\n  long\
    \ result = -1;\n  long current = arr[arr.length-1];\n  for (long i = 1; i < arr.length;\
    \ ++i) \n  {\n    if (arr[i] >= current) \n    {\n      if (result == -1) \n \
    \     {\n        result = i;\n      }\n      else if (result > i) \n      {\n\
    \        result = i;\n      }\n    }\n    current = arr[i];\n  }\n  return result;\n\
    }\n</code>\nAnd here is the equivalent in Java:\n<code>\nimport java.util.*;",
  "{\n\tif (arr.length == 0)\n\t\treturn -1;\n\t\n\tlong maxI = arr[0];\n\t\n\tfor\
    \ (int i = 1; i < arr.length; ++i)\n\t{\n\t\tif (arr[i] > maxI)\n\t\t\tmaxI =\
    \ arr[i];\n\t}\n\t\n\treturn maxI;\n}", "{\n    if (arr.length < 1)\n    {\n \
    \       return -1;\n    }\n    long last = arr[0];\n    long lastIndex = -1;\n\
    \    for (int i = 1; i < arr.length; i++)\n    {\n        if (arr[i] <= last)\n\
    \        {\n            last = arr[i];\n            lastIndex = i;\n        }\n\
    \    }\n    return lastIndex;\n}\n</code>\n<|/ a tags=algorithm,sorting,python,arrays\
    \ dscore=3 |>\n<| c |>\nThis solution fails with: `a=[2,3,3,4,1]` returns `-1`\n\
    <|/ c |>\n<| a tags=algorithm,sorting,python,arrays dscore=2 |>\n<code>\ndef kth_smallest(L,\
    \ k):\n    i = 0\n    while i+1 < len(L) and L[i] <= L[i+1]:\n        i += 1\n\
    \    L = L[i:]\n    return L[k-1]", "{\n\tlong index = 0;\n\tlong maxval = arr[0];\n\
    \tlong max = arr[0];\n\tfor (int i = 1; i < arr.length; i++) {\n\t\tif (arr[i]\
    \ < max) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tindex = i;\n\t\t\tmax =\
    \ arr[i];\n\t\t}\n\t}\n\treturn index;\n}\n/*\nCreate a function which returns\
    \ the smallest index of an element which\n    is not less than or equal to the\
    \ element immediately preceding it. If\n    no such element exists then return\
    \ -1. The given array will not contain\n    duplicate values.", "{\n\tint left\
    \ = -1;\n\tint right = 0;\n\tint i;\n\t\n\tfor (i = 0; i < arr.length; ++i)\n\t\
    {\n\t\tif (arr[i] < arr[left])\n\t\t{\n\t\t\tleft = i;\n\t\t}\n\t\t\n\t\tif (arr[i]\
    \ >= arr[right])\n\t\t{\n\t\t\tright = i;\n\t\t}\n\t}\n\t\n\treturn right;\n}",
  "{\n\tlong max = arr[0];\n\tfor (int i = 1; i < arr.length; ++i) {\n\t\tif (arr[i]\
    \ <= max) {\n\t\t\treturn -1;\n\t\t}\n\t\tmax = arr[i];\n\t}\n\treturn max;\n}",
  "{\n    int lo, hi;\n    lo = 0;\n    hi = arr.length - 1;\n    while(lo <= hi)\
    \ {\n        long mid = (lo + hi) / 2;\n        if(arr[mid] == arr[lo]) {\n  \
    \          lo++;\n        } else if (arr[mid] < arr[lo]) {\n            lo = mid\
    \ + 1;\n        } else {\n            hi = mid - 1;\n        }\n    }\n    if(lo\
    \ >= hi)\n        return -1;\n    return lo;\n}\n</code>\n<|/ a tags=sorting,algorithm,c#\
    \ |>\n<| c |>\nThe first solution is not very fast, so I think it is not a good\
    \ choice. About the second solution - it is similar to my own, but I don't understand\
    \ why it is so slow. Can you please elaborate? The algorithm should run in linear\
    \ time - O(n log n).\n<|/ c |>\n<| c |>\n: It's actually O(n log n) in the worst\
    \ case, which happens when the array is sorted, but in practice it's actually\
    \ O(n). See [here](http://cs.stackexchange.com/questions/7370/algorithm-for-quick-sort-which-would-break-on-arrays-not-sorted)\
    \ for an explanation of why.\n<|/ c |>\n<| c |>\n: Thanks for sharing the link,\
    \ I've learned something new!\n<|/ c |>\n<| a dscore=0 |>\n<code>\npublic int\
    \ FindLargestUnsortedElement(List<int> array) \n{\n    if (array == null) return\
    \ -1;", "{\n\tlong largest, small, temp;\n\tbool flag=true;\n\tfor(int i=0; i<arr.length-1;\
    \ i++)\n\t{\n\t\tlargest = arr[i];\n\t\tsmall = arr[i+1];\n\t\tif((largest > small)\
    \ && (!flag))\n\t\t{\n\t\t\tflag=true;\n\t\t\ttemp = largest;\n\t\t\tlargest =\
    \ small;\n\t\t\tsmall = temp;\n\t\t}\n\t\telse if (largest < small)\n\t\t{\n\t\
    \t\tflag=true;\n\t\t\ttemp = largest;\n\t\t\tlargest = small;\n\t\t\tsmall = temp;\n\
    \t\t}\n\t}\n\tif(flag) return -1;\n\treturn largest;\n}\n/*\nCreate a function\
    \ which returns the smallest index of an element which\n    is not less than or\
    \ equal to the element immediately following it. If\n    no such element exists\
    \ then return -1. The given array will not contain\n    duplicate values.", "{\n\
    \    long min = arr[0];\n    long max = arr[0];\n    long index = 0;\n    for\
    \ (long i = 1; i < arr.length; i++) \n    {\n        if (arr[i] < min) min = arr[i];\n\
    \        if (arr[i] > max) max = arr[i];\n        if (max != max) return -1L;\n\
    \        index = i;\n    }\n    return index;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nNot sure why you used a hash table instead of just looking at one element\
    \ at a time. The hash table makes sense if you need to search through multiple\
    \ elements but in this case you are only looking for one element. Also, a hash\
    \ table is more expensive to search than an array, so I'm not sure how this will\
    \ scale for larger lists.\n<|/ c |>\n<| c |>\n, Hash table is just an example...\
    \ you can use any data structure to store your data, in fact, some data structures\
    \ such as binary tree or avl tree will be faster for this case too. I'm just trying\
    \ to show a working example of how to use functions to solve a problem, so OP\
    \ can understand the basic idea of how it works.\n<|/ c |>\n<| a |>\nThis is your\
    \ solution but for sorted array.\n<code>\nlong findFirstNotLess(int a[], int n)\
    \ {\n    int index = -1;\n    for (int i = 0; i < n; i++) {\n        if(a[i]<a[i+1])\
    \ {\n            index = i;\n            break;\n        }\n    }\n    return\
    \ index;\n}\n</code>\n<|/ a tags=arrays,java,arraylist,data-structures dscore=1\
    \ |>\n<| c |>\nThis works only for sorted arrays, otherwise it will return -1\
    \ even if there's an item that is not less than the current element.\n<|/ c |>\n\
    <| a tags=arrays,java,arraylist,data-structures |>\nThis can be done using binary\
    \ search and O(logn) time complexity.\n<code>\nimport java.util.Arrays;", "{\n\
    \    long i = 0;\n    for(; i < arr.length; ++i)\n        if(arr[i] <= arr[i-1])\n\
    \            break;\n    return i;\n}", "{\n    long largest = -1, largest_index\
    \ = 0;\n    foreach (long x, arr) {\n        if (largest == -1L || x < arr[largest\
    \ + 1]) {\n            largest = largest_index;\n            largest_index = x;\n\
    \        }\n    }\n    return largest_index;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a |>\n<code>\nfunction canArrange(a) {\n    var max = 0;\n    for (var i =\
    \ 0; i < a.length; i++) {\n        var n = a[i];\n        for (var j = 0; j <\
    \ i; j++) {\n            if (a[j] <= n) break;\n        }\n        if (j == i)\
    \ max++;\n    }\n    return max;\n}", "{\n    long min;\n    long max = arr.length\
    \ - 1;", "{\n    long lower = -1;\n    long upper = -1;\n    for(int i = 0; i\
    \ < arr.length; i++){\n        if(arr[i] > upper && lower == -1){\n          \
    \  lower = i;\n        }else if(arr[i] < lower && upper == -1){\n            upper\
    \ = i;\n        }\n    }\n    return upper;\n}\n</code>\n<|/ a dscore=0 |>\n<|\
    \ c |>\nThank you for the helpful response. I appreciate it. I am not able to\
    \ run the code, as I am a beginner. So, I am getting these errors: \nerror: cannot\
    \ find symbol\n  if(arr[i] > upper && lower == -1){\n^\n  symbol:   variable upper\n\
    \  location: class ArraySearch\nerror: cannot find symbol\n  else if(arr[i] <\
    \ lower && upper == -1){\n^\n  symbol:   variable upper\n  location: class ArraySearch\n\
    error: cannot find symbol\n  return upper;\n  ^\n  symbol:   variable upper\n\
    \  location: class ArraySearch\n<|/ c |>\n<| c |>\nI have added my code above\
    \ in my original post. Thanks.\n<|/ c |>\n<| c |>\nWhat version of Java are you\
    \ using?  I got `cannot find symbol` errors when trying to compile the code you\
    \ had posted, since it contained references to things which were not in the Java\
    \ language.  I fixed the errors by adding a `long` at the beginning of the `can_arrange`\
    \ method.  Does this fix the problem?\n<|/ c |>\n<| c |>\nApologies for my ignorance.\
    \ I am using JDK 11. I have added a long in front of the can_arrange method. But,\
    \ I still get the same errors: error: cannot find symbol\n  if(arr[i] > upper\
    \ && lower == -1){\n  ^\n  symbol:   variable upper\n  location: class ArraySearch\n\
    error: cannot find symbol\n  else if(arr[i] < lower && upper == -1){\n  ^\n  symbol:\
    \   variable upper\n  location: class ArraySearch\nerror: cannot find symbol\n\
    \  return upper;\n  ^\n  symbol:   variable upper\n  location: class ArraySearch\n\
    <|/ c |>\n<| c |>\nAh, sorry - I was missing a return statement at the end of\
    \ the `can_arrange` method\n<|/ c |>\n<| a tags=arrays,java |>\n<code>\nimport\
    \ java.util.*;\nimport java.io.*;\nimport static java.lang.System.*;\nclass ArraySearch\
    \ \n{\n    public static void main(String[] args) throws IOException\n    {\n\
    \        long timeTaken = System.nan", "{\n    long last = arr[0];\n    long maxIdx\
    \ = 1;", "{\n    return can_arrange_(arr, 0, arr.length-1);\n}", "{\n    long\
    \ maxInd = -1, last;\n    \n    forall(arr[i])\n    {\n        if(arr[i] <= last)\n\
    \        {\n            last = arr[i];\n            maxInd = i;\n        }\n \
    \   }\n    \n    return maxInd;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\nHere\
    \ is my solution:\n<code>\nstatic int largestNotGreaterOrEqualThan(int[] arr)\
    \ {\n    int res = Integer.MIN_VALUE;\n    boolean exist = false;\n    for (int\
    \ i : arr) {\n        if (i < res) {\n            res = i;\n            exist\
    \ = true;\n        }\n    }\n    if (exist) {\n        return -1;\n    }\n   \
    \ return res;\n}\n</code>\n<|/ a dscore=1 tags=arrays,algorithm |>\n<| a dscore=1\
    \ |>\nIf I'm getting this right, the answer is in the last line of your code:\n\
    <code>\nif (arr[i] <= last) {\n    last = arr[i];\n    maxInd = i;\n}\n</code>\n\
    If arr[i] < last, it means that the first number in your array is less than last\
    \ (hence the condition is always satisfied). So you could just change it to:\n\
    <code>\nif (arr[i] < last) {\n    last = arr[i];\n    maxInd = i;\n}\n</code>\n\
    And since last is set to a number which is smaller than any number in your array,\
    \ it means that if that number is equal to the current max, then it means that\
    \ maxInd is indeed the index of the element that is the largest, so you can just\
    \ return maxInd.\n<|/ a tags=arrays,algorithm |>\n<| a tags=arrays,algorithm |>\n\
    <code>\n#include <iostream>\n#include <stdio.h>\nusing namespace std;", "{\n\t\
    int left = 0;\n\tint right = 0;\n\tint largest = -1;", "{\n  long result = -1;\n\
    \  long cur = arr[0];\n  for(int i = 0; i < arr.length - 1; i++)\n  {\n    if(arr[i]\
    \ >= cur)\n    {\n      result = i;\n      cur = arr[i];\n    }\n  }\n  return\
    \ result;\n}\n// vim: set ts=2 sts=2 sw=2 expandtab:\n/*\n  Template for \"Large\
    \ Linear Algebra\" problems (in SICONOS_GLOBAL_LINEAR_ALGEBRA_EXAMPLES)\n  This\
    \ example is similar to the one in SICONOS_GLOBAL_LINEAR_ALGEBRA_EXAMPLES, except\n\
    \  that it uses \"double\" and not \"float\".\n  \n  This example follows the\
    \ pattern:\n  \n      1 - load a problem \n      2 - call to function load_unbounded_mla\
    \ to fill the problem with data\n      3 - call to function print_solution to\
    \ print the solution (if requested)\n      4 - call to function test_error to\
    \ test the error at the end of the iterations\n      5 - call to function free_problem_data\
    \ to free memory allocated in 2\n      6 - exit\n      \n  NOTE: The following\
    \ files must be created first:\n    - SiconosGraph.proto\n    - SiconosGraph.v\n\
    \    - SiconosGraph.bc\n    - SiconosVector.proto\n    - SiconosVector.v\n   \
    \ - SiconosVector.bc\n  \n  Copyright notice:\n  This code is a \"translation\
    \ from the examples of Professor Dr.\n  Abraham Mathews Stewart, University of\
    \ Texas at Austin\n  Derived from his MATLAB code at\n  http://www.mathworks.com/matlabcentral/fileexchange/6543-matlab-big-linear-algebra-toolbox",
  "{\n    long maxIndex = -1L;\n    long currentIndex = arr.length-1;", "{\n    int\
    \ i = 0;\n    int j = arr.length - 1;\n    while (i < j) {\n        while (i <\
    \ arr.length && arr[i] < arr[j]) {\n            ++i;\n        }\n        while\
    \ (i < arr.length && arr[i] >= arr[j]) {\n            --j;\n        }\n      \
    \  if (i < j) {\n            return j;\n        }\n    }\n    return -1;\n}",
  "{\n\tint max_index;\n\tfor (int i = 0; i < arr.length; i++){\n\t\tmax_index = 0;\n\
    \t\tfor (int j = i; j < arr.length; j++){\n\t\t\tif (arr[j] >= arr[j - 1])\n\t\
    \t\t\tmax_index = j;\n\t\t}\n\t\tif (max_index != i)\n\t\t\treturn max_index;\n\
    \t}\n\treturn -1;\n}\n'''", "{\n    long low = 0;\n    long high = sizeof(arr)\
    \ / sizeof(arr[0]);\n    while (high > low)\n    {\n        long mid = (low+high)/2;\n\
    \        if (arr[mid] > mid)\n            high = mid;\n        else if (arr[mid]\
    \ < mid)\n            low = mid;\n        else\n            return mid;\n    }\n\
    \    if (arr[low] < low)\n        return low;\n    else\n        return -1;\n\
    }\n</code>\n<|/ a |>\n<| c |>\nI like your first solution for small arrays, and\
    \ it works fine when there are no repeated elements.\n<|/ c |>\n<| c |>\nYes I\
    \ realised after posting that there were some edge cases where this wouldn't work\
    \ as expected.  But I thought I'd fix the code anyway.  Thanks.\n<|/ c |>\n<|\
    \ a |>\nIf you don't want to use STL functions like max_element or max_element\
    \ you can create your own max_index_of\n<code>\nlong max_index_of( const std::vector<int>&\
    \ v )\n{\n    long n = v.size();\n    if (n <= 1) {\n        return -1;\n    }\n\
    \    std::vector<int>::iterator it_low = std::lower_bound(v.begin(), v.end(),\
    \ 0),\n                                     it_high = std::upper_bound(v.begin(),\
    \ v.end(), 0);\n    if (it_low == v.end() || it_high == v.end()) {\n        return\
    \ -1;\n    }\n    return std::max(it_high - 1, it_low - 1);\n}\n</code>\n<|/ a\
    \ tags=indexing,c++,algorithm,stl dscore=2 |>\n<| a dscore=2 tags=indexing,c++,algorithm,stl\
    \ |>\nIf you don't want to use STL functions like max_element or max_element you\
    \ can create your own max_index_of\n<code>\nlong max_index_of( const std::vector<int>&\
    \ v )\n{\n    long n = v.size();\n    if (n <= 1) {\n        return -1;\n    }\n\
    \    std::vector<int>::iterator it_low = std::lower_bound(v.begin(), v.end(),\
    \ 0),\n                                     it_high = std::upper_bound(v.begin(),\
    \ v.end(), 0);\n    if (it_low == v.end() || it_high == v.end()) {\n        return\
    \ -1;\n    }\n    return std::max(it_high - 1, it_low - 1);\n}\n</code>\n<|/ a\
    \ |>\n<| a |>\nIf i understand your question correctly, you are looking for the\
    \ \"position\" of the first element which is greater or equal to the element you\
    \ are looking for.\nIn that case, you can do it with binary search easily:\n<code>\n\
    template <class Iterator>\nstd::size_t find_element_index(Iterator ", "{\n   \
    \ long res = -1;\n    long max = arr[0];\n    for (int i = 1; i < arr.length;\
    \ i++) \n    {\n        if (arr[i] <= max) \n        {\n            res = -1;\n\
    \            break;\n        }\n        if (arr[i] > max) \n        {\n      \
    \      res = i;\n            max = arr[i];\n        }\n    }\n    return res;\n\
    }", "{\n    long result = 0;\n    for (int i = 1; i < arr.length; i++) {\n   \
    \     if (arr[i] < arr[result]) {\n            result = i;\n        }\n    }\n\
    \    return result < 0 ? -1 : result;\n}\n</code>\n<|/ a tags=java,arrays dscore=0\
    \ |>\n<| c |>\nYes this can be done in O(n) time complexity. But your solution\
    \ has O(n^2) time complexity.\n<|/ c |>\n<| c |>\nYes I agree it can be done in\
    \ O(n) but this requires that you know the input array and if you don't you can\
    \ still use this method which is O(n) anyway. The complexity of the method is\
    \ the same as the other ones except they each return an int instead of long.\n\
    <|/ c |>\n<| a dscore=0 tags=java,arrays |>\nUse a Map to store all values which\
    \ have appeared before and return the last value in the map. \n<code>\npublic\
    \ static void main(String[] args) {", "{\n\tint i;\n\tlong retval = -1L;\n\t\n\
    \tfor(i = 0; i< arr.length; i++) {\n\t\tif(arr[i] < arr[(i+1)]) {\n\t\t\tbreak;\n\
    \t\t}\n\t}\n\t\n\tif(i < arr.length) {\n\t\tretval = i;\n\t}\n\t\n\treturn retval;\n\
    }\n/*\nCreate a function which returns the smallest index of an element which\n\
    \    is not less than or equal to the element immediately following it. If\n \
    \   no such element exists then return -1. The given array will not contain\n\
    \    duplicate values.", "{\n    int max_i = arr.length-1;\n    int min_i = max_i;\n\
    \    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > arr[min_i])\n\
    \        {\n            min_i = i;\n        }\n        if(arr[i] < arr[max_i])\n\
    \        {\n            max_i = i;\n        }\n    }\n    return (max_i + min_i)\
    \ - 1;\n}\n</code>\n<|/ a |>\n<| c |>\nI doubt this will work in the general case,\
    \ as for arr = [1L, 2L, 3L] the max index should be 2, right? But the above algorithm\
    \ returns 3 in that case.\n<|/ c |>\n<| c |>\nNope, `1L` is the highest index\
    \ not greater than `1L`; `3L` is the highest *smaller* index not greater than\
    \ `3L`. [See here](http://en.wikipedia.org/wiki/Binary_search_algorithm)\n<|/\
    \ c |>\n<| c |>\nI guess you're right. I got confused by \"return the highest\
    \ index of an element not greater than or equal to the element immediately preceding\
    \ it\". Thanks for pointing that out.\n<|/ c |>\n<| a |>\nThis answer is based\
    \ on an assumption of inconsistent input (no duplicates) and the order of the\
    \ elements in the array.\nThe algorithm works by finding the smallest element\
    \ in the array that is larger than the largest element in the array. It then swaps\
    \ the two elements in the array. Finally we search the array for the next smallest\
    \ element. It repeats until no smaller elements are left in the array.\n<code>",
  "{\n    long res = 0;\n    for(int i = 0; i < arr.length; i++) {\n        if(arr[i]\
    \ <= arr[i-1]) \n            res = i;\n    }\n    return res;\n}\n</code>\nThe\
    \ solution was simple: start with the first element and see if we find a number\
    \ greater than or equal to it. If so we know we can keep checking this number\
    \ as long as the number is less than the element before it. If we haven't found\
    \ anything greater than or equal to the element before it then we're done.\nIf\
    \ we're still stuck then it means that we don't have that last number in the array\
    \ and we need to return -1.\n<|/ a tags=algorithm,arrays,sorting |>\n<| c |>\n\
    Yeah, I came up with the same solution but was wondering how it could be done\
    \ without any extra space in memory. I guess it's just that I have very little\
    \ experience with algorithms. Thanks :)\n<|/ c |>\n<| c |>\n: Actually it's more\
    \ like O(n) space usage than O(n) extra space, since the input doesn't have any\
    \ extra space to allocate.\n<|/ c |>\n<| c |>\n: That is what I was thinking,\
    \ but just wanted to make sure.\n<|/ c |>\n<| c |>\nWhat does \"more like O(n)\
    \ space usage\" even mean? I don't see how it can be more like O(n) space usage\
    \ when you have an algorithm that can potentially use O(1) space.\n<|/ c |>\n\
    <| c |>\n: I don't think that is the case. I'm still struggling to see how you\
    \ would end up with O(1) space usage when you're allowed to use O(1) space.\n\
    <|/ c |>\n<| a |>\nIf it is allowed to sort then you may use binary search:\n\
    <code>\nlong binarySearch(long[] array, long number){\n    int lo = 0, hi = array.length-1;\n\
    \    while(lo <= hi){\n        int mid = (lo + hi)/2;\n        if(array[mid] ==\
    \ number) return mid;\n        if(array[mid] < number) lo = mid +1;\n        else\
    \ if(array[mid] > number) hi = mid -1;\n    }\n    return -1;\n}\n</code>\n<|/\
    \ a dscore=1 tags=algorithm,arrays,sorting |>\n<| a |>\nThis would be the approach\
    \ that i would choose if i had to choose an algorithm for this:\nThe idea is to\
    \ sort the array in O(nlogn) time, then find the last number that is smaller than\
    \ the one passed in the parameter, which is O(1)\n<|/ a tags=algorithm,arrays,sorting\
    \ dscore=0 |>\n<| c |>\nThis would work assuming that the array is sorted. But\
    \ that doesn't necessarily mean that the OP has any requirement to ", "{\n   \
    \ long max = arr[0];\n    long prevIdx = 0;\n    for (long i = 1; i < arr.length;\
    \ ++i) \n    {\n        if (arr[i] > max) \n        {\n            max = arr[i];\n\
    \            prevIdx = i;\n        }\n    }\n    if (prevIdx == arr.length-1)\
    \ \n    {\n        return arr.length-1;\n    }\n    else \n    {\n        return\
    \ -1;\n    }\n}", "{\n  long largest = arr[0];\n  \n  for(int i = 1; i < arr.length;\
    \ i++)\n  {\n    if(arr[i] >= largest)\n    {\n      largest = arr[i];\n    }\n\
    \  }\n  \n  return largest;\n}", "{\n\tif (arr.length == 0)\n\t\treturn -1;",
  "{\n    long res = -1L;\n    int i = 0;\n    for(i = 1; i < arr.length; ++i)\n \
    \       if(arr[i] >= arr[i-1])\n            res = i;\n    return res;\n}\n</code>\n\
    <|/ a dscore=2 tags=algorithm,java,sorting,arrays |>\n<| c |>\nThis is O(n) but\
    \ it's still O(n^2).  I believe the `O(n^2)` has to do with the fact that you\
    \ have to go through all the `n` elements and count how many `i` elements are\
    \ greater than `i-1` which is `O(n)`, then you have to compare `n` elements to\
    \ figure out which is largest.  If you add that time to the time it takes to sort\
    \ the entire array then it's still `O(n^2)`.\n<|/ c |>\n<| c |>\nThe first point\
    \ is true, however the second point is not true at all. An array is sorted if\
    \ and only if `0 <= x < x < x` for all `x < arr.length` where `arr.length` is\
    \ the last index of the array.\n<|/ c |>\n<| a dscore=2 |>\nYes, you can do it\
    \ with a single array traversal, O(n) time.\nThe idea is to do a binary search\
    \ to see if the element you're searching for is greater than or less than the\
    \ one immediately preceding it. \nIf it's less than or equal to it, then you know\
    \ that the element you're looking for is at the beginning, otherwise you know\
    \ that the element you're looking for is at the end.\nHere's some pseudocode:\n\
    <code>\nif target > arr[index] then\n  if index < n then index += arr[index] -\
    \ target\n  else return -1\nelse\n  if index = 0 then index = n - 1\n  else if\
    \ index = n then index = 0\n  else index = index - 1\nreturn index\n</code>\n\
    <|/ a tags=algorithm,java,sorting,arrays |>\n<| c |>\nThis algorithm is O(n),\
    \ but doesn't do the job correctly, it returns -1 instead of 1 when target is\
    \ found. You should add \"if target < arr[index] then\" at the beginning.\n<|/\
    \ c |>\n<| c |>\nThat's right, and it's also O(n^2). I don't see how it's O(n),\
    \ though.\n<|/ c |>\n<| c |>\n, that's why I said \"pseudocode\" ;-) I suppose\
    \ it's O(n) because of the indexing and the comparison check. Still, this algorithm\
    \ is definitely not O(n^2).\n<|/ c |>\n<| c |>\n, I know this is an old question,\
    \ but I believe it's O(n). What I meant is that it does two comparison", "{\n\
    \  long max = -1, pos = 0, n = arr.length;\n  if (n == 0) return -1;\n  if (n\
    \ <= 1) return n;\n  while (n--) {\n    if (arr[pos] >= arr[pos + 1]) {\n    \
    \  pos = pos+1;\n    } else {\n      if (pos == max) {\n        max = pos;\n \
    \     } else {\n        max = -1;\n        break;\n      }\n    }\n  }\n  return\
    \ max;\n}\n</code>\n<|/ a tags=c++,arrays,java,algorithm |>\n<| c |>\nCan you\
    \ please elaborate on how this works? I'm sorry I don't understand how it works.\n\
    <|/ c |>\n<| c |>\nThe code uses a for loop to go through the array and at each\
    \ iteration checks if the current position was greater than or equal to the previous\
    \ position. If so, it increments the position and continues with other elements.\
    \ The if statement at the end checks if the current position is greater than the\
    \ last max position which is also a sign that there are no more elements.\n<|/\
    \ c |>\n<| c |>\nI've updated my answer to make it more clear. Hope it helps.\n\
    <|/ c |>\n<| a tags=c++,arrays,java,algorithm dscore=0 |>\nA simple Java solution\
    \ would be this:\n<code>\n    public int largestElement(int[] arr) {\n       \
    \ int max = Integer.MIN_VALUE;\n        int maxIndex = 0;\n        for(int i =\
    \ 0; i < arr.length; i++) {\n            if(arr[i] > max) {\n                max\
    \ = arr[i];\n                maxIndex = i;\n            }\n        }\n       \
    \ return maxIndex;\n    }\n</code>\n<|/ a |>\n<| c |>\n`Arrays.stream()` is already\
    \ available in the core JDK, so this can be done more efficiently: `int maxIndex\
    \ = Arrays.stream(arr).max().getAsInt();`\n<|/ c |>\n<| c |>\n`max` will equal\
    \ `Integer.MIN_VALUE` if the list is empty.\n<|/ c |>\n<| a dscore=0 |>\nHere\
    \ is a solution in Python:\n<code>\ndef largestElement(a):\n    largest = a.sort()\n\
    \    largest.sort()\n    if largest == a:\n        return -1\n    return largest[-1]\n\
    </code>\nIt works by sorting the list, then comparing that list to the sorted\
    \ list. If they are the same length, the list was already sorted. If they were\
    \ not the same length, then the list was not sorted. If they are not the same\
    \ length, we know that the list is sorted from largest to smallest, and we should\
    \ return the element at position len(a).\n<|/ a tags=c++,arrays,java,algorithm\
    \ |>\n<| a tags=c++,arrays,java,algorithm |>\nHere is Java 8 way ", "{\n    long\
    \ max = arr[0], i = 1;\n    while(i<arr.length && max<arr[i++])\n        max =\
    \ arr[i];\n    while(i < arr.length)\n        if (max>arr[i++])\n            max\
    \ = -1;\n    return max;\n}\n</code>\n<|/ a dscore=2 tags=arrays,c,sorting |>\n\
    <| c |>\nHow can this be done in C? Can you show me how to do it? I have to use\
    \ no libraries and I'm not allowed to use recursion.\n<|/ c |>\n<| c |>\n- I've\
    \ updated my answer to show how this can be done in C.\n<|/ c |>\n<| c |>\n- If\
    \ your question is about how to implement the algorithm, I'll leave it to you\
    \ to work out how to do it. If your question is about finding the highest value\
    \ in an array, that's a little more straightforward (although you can do it with\
    \ recursion as well).\n<|/ c |>\n<| c |>\nMy problem is that I don't know how\
    \ to implement the algorithm. Can you show me how I should go about doing that?\
    \ I don't understand your example code. Where does it go wrong?\n<|/ c |>\n<|\
    \ c |>\nOk I understand it now. Your solution will work, but I can't use recursion.\
    \ Is this a problem?\n<|/ c |>\n<| a |>\n<code>", "{\n\tlong maxindex = -1L;\n\
    \tlong i = 0;\n\tfor (; i < arr.length; i++) {\n\t\tif (maxindex < arr[i]) {\n\
    \t\t\tmaxindex = arr[i];\n\t\t}\n\t}\n\treturn maxindex;\n}", "{\n    long max\
    \ = arr[0];\n    for(int i = 1; i < arr.length; i++) \n    {\n        if(arr[i]\
    \ < max) \n        {\n            max = arr[i];\n        }\n    }\n    return\
    \ max;\n}", "{\n    if(arr.length == 0)\n        return -1;\n    long ans = arr[0];\n\
    \    for(int i = 1; i < arr.length; i++) {\n        if(arr[i] <= ans)\n      \
    \      return -1;\n        ans = arr[i];\n    }\n    return ans;\n}\n</code>\n\
    <|/ a dscore=0 tags=c++,sorting |>\n<| c |>\nThank you for your answer! Could\
    \ you please explain how do you calculate the biggest non-duplicated value in\
    \ a subarray? I am having trouble on calculating it.\n<|/ c |>\n<| c |>\nJust\
    \ realized I misunderstood the question, I thought you were looking for an O(n^2)\
    \ solution, where n is the array length. My apologies for the misunderstanding,\
    \ I hope this edit solves your problem.\n<|/ c |>\n<| a |>\nI used a hash map\
    \ to store the previous value. The code below is written in Java and has O(n)\
    \ complexity.\n<code>\npublic class MaxSubArray {\n    public static void main(String[]\
    \ args) {\n        int[] arr = {1, 2, 4, 3, 5};\n        int largest = findLargestNonDup(arr);\n\
    \        System.out.println(largest);\n    }", "{\n    int i, j, max = arr[0];\n\
    \    for (i = 1; i < arr.size(); ++i)\n    {\n        for (j = i; j < arr.size();\
    \ ++j)\n        {\n            if (arr[i] < arr[j])\n            {\n         \
    \       max = j;\n                break;\n            }\n        }\n    }\n  \
    \  return max;\n}\n/*\nCreate a function which returns the smallest index of an\
    \ element which\n    is not less than or equal to the element immediately preceding\
    \ it. If\n    no such element exists then return -1. The given array will not\
    \ contain\n    duplicate values.", "{\n    if(arr.length <= 0)\n        throw\
    \ new IllegalArgumentException(\"Array must have at least one element\");\n  \
    \  long l=arr[arr.length-1];\n    long r = arr[0];\n    int i;\n    for(i = 1;\
    \ i < arr.length; i++)\n    {\n        if(arr[i] >= r)\n        {\n          \
    \  l = Math.max(r, l);\n            r = arr[i];\n        }\n    }\n    return\
    \ l;\n}\n</code>\n<|/ a tags=java dscore=0 |>\n<| c |>\nThe question specifically\
    \ asked for the *largest* index.\n<|/ c |>\n<| c |>\nYes, but a minor change to\
    \ my answer should take care of that.\n<|/ c |>\n<| c |>\nBut that doesn't solve\
    \ the problem of finding the largest index.\n<|/ c |>\n<| c |>\nHmmm ... now I\
    \ think about it ... it might actually be a better approach than my original answer\
    \ ... I'll edit in a second to see if that gives what he's looking for.\n<|/ c\
    \ |>\n<| c |>\nLooks like he's got it solved :-)\n<|/ c |>\n<| a dscore=0 |>\n\
    I solved this problem by using a Java stream to iterate the array and get both\
    \ the max and min values, then iterate the original array again to see if any\
    \ values are within the range between min and max.\n<code>\npublic static long\
    \ largestIndex(long[] arr) {\n    return Arrays.stream(arr).max(Comparator.naturalOrder()).orElse(-1L);\n\
    }\n</code>\n<|/ a tags=java |>\n<| a |>\nI have just wrote this code to solve\
    \ this problem in O(n), I hope it will help you\n<code>\npublic long largestIndex(int[]\
    \ arr){\n    long maximum = Integer.MIN_VALUE;\n    for(int i=0;i<arr.length;i++){\n\
    \        if((arr[i]>maximum)||(maximum==Integer.MIN_VALUE))\n            maximum=arr[i];\n\
    \    }\n    for(int i=0;i<arr.length;i++){\n        if(maximum>arr[i])\n     \
    \       return i+1;\n    }\n    return -1;\n}\n</code>\n<|/ a dscore=0 tags=java\
    \ |>\n<| a dscore=0 tags=java |>\nThis should work:\n<code>\npublic static int\
    \ largestIndex(long[] arr) {\n    Arrays.sort(arr);\n    for(int i = 0; i < arr.length\
    \ - 1; i++) {\n        if(arr[i] >= arr[i + 1]) {\n            return i + 1;\n\
    \        }\n    }\n    return -1;\n}\n</code>\n<|/ a |>\n<| c |>\nThis is a much\
    \ better algorithm than that of mine", "{\n    int i = 0, j = 0;\n    long max\
    \ = arr[0];\n    for (i = 0; i < arr.length; ++i) {\n        if (arr[i] > max)\
    \ {\n            max = arr[i];\n            j = 1;\n        } else if (arr[i]\
    \ == max) {\n            j++;\n        }\n    }\n    return j > 0 ? j : -1;\n}",
  "{\n    return std.maxIndexNonZero(arr) - 1;\n}\n/*\nCreate a function which returns\
    \ the second largest index of an element which\n    is not greater than or equal\
    \ to the element immediately preceding it. If\n    no such element exists then\
    \ return -1. The given array will not contain\n    duplicate values.", "{\n\t\
    long max = -1, maxidx = -1;\n\tfor (int i = 1; i < arr.length; ++i) {\n\t\tlong\
    \ cur_max = std.maxiarr[arr[i]], cur_idx = i;\n\t\tfor (int j = 0; j < i; ++j)\
    \ {\n\t\t\tif (std.is_geq(arr[j], cur_max)) {\n\t\t\t\tcur_max = std.maxiarr[arr[j]];\n\
    \t\t\t\tcur_idx = j;\n\t\t\t}\n\t\t}\n\t\tif (max == -1)\n\t\t\tmax = cur_max;\n\
    \t\telse if (max != cur_max)\n\t\t\treturn -1;\n\t\tmaxidx = cur_idx;\n\t}\n\t\
    return maxidx;\n}", "{\n  int i, j;\n  long max = -1;\n  int k = 0;", "{\n   \
    \ if (arr.length == 1)\n        return arr[0];\n    long mid = arr.length / 2;\n\
    \    int lo = 1;\n    int hi = mid;\n    while (lo < hi) {\n        int mid =\
    \ (lo + hi) / 2;\n        if (arr[mid] <= arr[mid - 1])\n            lo = mid\
    \ + 1;\n        else\n            hi = mid;\n    }\n    return lo > 0 ? mid :\
    \ -1;\n}\n</code>\n<|/ a dscore=4 |>\n<| a dscore=2 tags=arrays,sorting |>\nHere\
    \ is a javascript solution that works with very large arrays and also keeps a\
    \ running average of all the elements:\n<code>\nfunction findMaxConsecutive(array)\
    \ {\n  let max = 0;\n  let count = 0;\n  array.sort((a,b) => b - a);\n  const\
    \ length = array.length;\n  const runningAverage = 0;\n  for (let i = 0; i < length;\
    \ i++) {\n    runningAverage += array[i];\n    if (max < array[i]) {\n      max\
    \ = array[i];\n    }\n    if (i + 1 < length && max < array[i+1]) {\n      count++;\n\
    \    }\n  }\n  if(count > 0 && max > runningAverage) {\n    return max;\n  }\n\
    \  return -1;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\nfunction findMaxConsecutive(arr)\
    \ {\n  var maxArr = [];\n  var max = [];\n  for (var i = 1; i < arr.length; i++)\
    \ {\n     if (arr[i] == arr[i-1]) {\n       maxArr.push(arr[i]);\n     }\n   \
    \  else if (arr[i] > maxArr[0]) {\n       max = maxArr;\n       maxArr = [];\n\
    \     }\n  }\n  return max;\n}\n</code>\n<|/ a tags=arrays,sorting dscore=2 |>\n\
    <| a dscore=2 |>\n<code>\nfunction findMaxConsecutive(arr) {\n    let max = 0\n\
    \    let consecutive = 0\n    for (let i = 0; i < arr.length; i++) {\n       \
    \ if (arr[i] > max) {\n            max = arr[i]\n        }\n        else if (arr[i]\
    \ == max) {\n            consecutive++\n        }\n        else {\n          \
    \  if (consecutive > 0) {\n                max = arr[i]\n                consecutive\
    \ = 0\n            }\n        }\n    }\n    if (consecutive > 0) {\n        return\
    \ max\n    }\n    return -1\n}\n</code>\n<|/ a tags=arrays,sorting |>\n<| a |>\n\
    <code>\n/**\n * find the highest number in an array such that n-1 consecutive\
    \ numbers are not greater than it.\n * {Array<number>} array\n * {number}\n */\n\
    function findMaxConsecutive(array) {\n    let result = [];\n    const low = [];\n\
    \    const high = [];\n    array.sort((a, b) => b - a);", "{\n\tlong lo = arr[0];\n\
    \tlong hi = arr[arr.length-1];", "{\n    long result = -1L;\n    int size = arr.length;\n\
    \    for(int i = 1; i < size; i++)\n    {\n        if(arr[i] <= arr[result])\n\
    \        {\n            result = i;\n        }\n    }\n    return result;\n}\n\
    </code>\n<|/ a tags=arrays,c++,algorithm |>\n<| a |>\nI came up with a simple\
    \ algorithm that does not depend on extra data structures:\n<code>\ndef max_idx(arr):\n\
    \  for i in range(1, len(arr)):\n    if arr[i] < arr[i - 1]:\n      return i\n\
    \  return -1\n</code>\n<|/ a tags=arrays,c++,algorithm dscore=0 |>\n<| a tags=arrays,c++,algorithm\
    \ |>\nYou can use std::max_element for this:\n<code>\n#include <algorithm>\n#include\
    \ <iostream>", "{\n    int len = arr.length;\n    long max_idx = -1;\n    for(int\
    \ i=0; i < len-1; ++i)\n    {\n        if(arr[i] > arr[i+1])\n        {\n    \
    \        max_idx = i;\n        }\n    }\n    return max_idx;\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nPlease don't post answers to obviously duplicate questions. Instead,\
    \ flag the question as a duplicate.\n<|/ c |>\n<| c |>\nHi, and welcome to SO.\
    \ I see that you're a member of SO, but please do take some time to review your\
    \ post. You've got some code there, but it doesn't really answer the question.\
    \ Also, it's considered bad practice to use \"thanks\" as your only way of saying\
    \ \"thanks\", and I hope you see that.\n<|/ c |>\n<| c |>\nYes, you are absolutely\
    \ right that code is not an answer but a comment. I thought this was an answer\
    \ because there was no other answer that suggested an algorithm that worked in\
    \ O(n). But you are right that some of us were wrong, and I edited my post.\n\
    <|/ c |>\n<| c |>\nAlthough this isn't an answer, I think it is still relevant\
    \ and useful in some situations. The \"if arr[i]-arr[i+1] ==0\" should be added\
    \ and made \"if arr[i] < arr[i+1]\", otherwise it will not work if you have a\
    \ duplicate.  For example, if arr contained [1L, 2L, 3L, 3L], the code would return\
    \ 1, when it should be 2.\n<|/ c |>\n<| c |>\nI think your edit is a valid improvement\
    \ to improve the post, but please don't edit posts to add tags like \"java\" that\
    \ aren't relevant to a post about a language. Thanks!\n<|/ c |>\n<| a tags=arrays,java\
    \ |>\nHere is my version of finding largest number in an array:\n<code>\nclass\
    \ FindLargestInArray{", "{\n\tlong i, maxIndex = -1L;\n\t\n\tfor (i = 0; i < arr.length;\
    \ i++) {\n\t\tif(i == 0) {\n\t\t\tif(arr[i] >= arr[i + 1]) {\n\t\t\t\tmaxIndex\
    \ = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse if(arr[i] >= arr[i - 1]) {\n\t\
    \t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tmaxIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\
    \t\n\treturn maxIndex;\n}", "{\n\tlong maxIndex = -1;\n\tlong x = arr[0];\n\t\
    for (int i = 1; i < arr.length; i++)\n\t{\n\t\tif (arr[i] >= x)\n\t\t{\n\t\t\t\
    maxIndex = i;\n\t\t}\n\t}\n\treturn maxIndex;\n}\n/*\nCreate a function which\
    \ returns the smallest index of an element which\n    is not less than or equal\
    \ to the element immediately preceding it. If\n    no such element exists then\
    \ return -1. The given array will not contain\n    duplicate values.", "{\n  \
    \  long i = std.length(arr)-1;\n    for (; i > 0; --i) \n        if (std.is_ge(arr[i-1],arr[i]))\
    \ return i;\n    return -1;\n}", "{\n    int low = 0, high = arr.length - 1;\n\
    \    long largest = -1;\n    \n    while (low < high)\n    {\n        long mid\
    \ = low + (high - low) / 2;\n        long midValue = arr[mid];\n        if (midValue\
    \ >= arr[low])\n        {\n            low = mid + 1;\n        }\n        else\
    \ if (midValue <= arr[high])\n        {\n            high = mid - 1;\n       \
    \ }\n        else\n        {\n            largest = mid - 1;\n            break;\n\
    \        }\n    }\n    \n    return largest;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=1 tags=algorithm,arrays |>\nUsing dynamic programming with memoization\
    \ to find out where you can put an element and how many of them are there you\
    \ can put in that location.\n<code>\npublic static void main(String[] args) {\n\
    \    long minMax(int[] nums) {\n        int[] memo = new int[nums.length];\n \
    \       Arrays.fill(memo, -1);\n        int maxLen = -1;\n        int minLen =\
    \ Integer.MAX_VALUE;", "{\n\tint start = 0;\n\tlong maxIndex = -1;\n\tfor (int\
    \ i = 0; i < arr.length; i++) \n\t{\n\t\tif (arr[i] > arr[start])\n\t\t{\n\t\t\
    \tmaxIndex = i;\n\t\t}\n\t}\n\treturn maxIndex;\n}", "{\n    long cur = 0;\n \
    \   long max = arr[cur];\n    int i;\n    for (i = cur + 1; i < arr.length; i++)\
    \ {\n        if (arr[i] > max) {\n            max = arr[i];\n            cur =\
    \ i;\n        }\n    }\n    return cur;\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't\
    \ return what you stated you wanted, but it's a good start. You'd probably want\
    \ to return -1 if there is no such element. That's what `findLastIndex` does.\n\
    <|/ c |>\n<| c |>\nYou were right. I should have returned -1 if there was no such\
    \ element. That's why I added the line `return -1;`. I will edit the answer now.\
    \ Thanks.\n<|/ c |>\n<| c |>\nYour function does exactly what I was looking for\
    \ but unfortunately it still uses sort which isn't allowed.\n<|/ c |>\n<| c |>\n\
    Yes it does, you just need to write some lines of code to reverse the order of\
    \ the elements and then use your function as shown in the answer. Anyway this\
    \ question is a duplicate of http://stackoverflow.com/questions/4959040/find-the-last-item-that-meets-a-given-condition-in-an-array.\
    \ Maybe that helps.\n<|/ c |>\n<| c |>\nI was actually looking to see if there\
    \ was a way to do it without sorting. I'll have to try your solution\n<|/ c |>\n\
    <| a tags=algorithm,java |>\n<code>\nclass LastIndexOf\n{\n    public static void\
    \ main(String args[])\n    {\n        int[] input = new int[] {0, 1, 2, 3, 4,\
    \ 7, 9};\n        System.out.println(lastIndexOf(input, 7));\n    }", "{\n   \
    \ long max = arr[0];\n    long min = (long)arr.length;\n    \n    for(int i=1;\
    \ i<arr.length; i++)\n    {\n        if(arr[i] >= arr[min])\n            min =\
    \ i;\n        else if(arr[i] <= arr[max])\n            max = i;\n    }\n    \n\
    \    return max;\n}\n/*\nCreate a function which returns the largest index of\
    \ an element which\n    is greater than or equal to the element immediately preceding\
    \ it. If\n    no such element exists then return -1. The given array will not\
    \ contain\n    duplicate values.", "{\n    if(arr.length == 0) return -1;\n  \
    \  long first = arr[0];\n    long last  = arr[0];\n    long i     = arr.length\
    \ - 1;\n    \n    for(;;) {\n        if(arr[i] < first) {\n            if(i ==\
    \ 0) return -1;\n            else i--;\n        } else {\n            if(arr[i]\
    \ >= last) return i;\n            else return -1;\n        }\n    }\n}\n</code>\n\
    <|/ a tags=sorting,c++,algorithm |>\n<| c |>\nThis is a nice algorithm and I like\
    \ the idea of sorting and keeping the first element.  But a better algorithm would\
    \ be to sort the list then find the first unsorted element (if the list is not\
    \ empty) and return the index of that element.  In a case like you propose you\
    \ would still have to do another sort of the entire list, though.\n<|/ c |>\n\
    <| c |>\n: Yes, I agree. Also, I did not do a single sort, but use three pointers.\
    \ First, the two pointers that go through the array in order, then the third that\
    \ goes through the array in reverse order (to find the first unsorted element).\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\nlong first_notgreater(long *arr, int n) {\n\
    \    if(!n) return -1;\n    long first = arr[0];\n    long largest = first;\n\
    \    int pos = n;", "{\n\tlong ans = -1;\n\tlong minVal = arr[0];\n\tint pos =\
    \ 1;\n\t\n\tfor (long i = 1; (i < arr.Length) && (pos > 0); ++i)\n\t{\n\t\tif\
    \ (arr[i] <= minVal)\n\t\t\tans = i;\n\t\telse if (arr[i] < minVal)\n\t\t\tminVal\
    \ = arr[pos];\n\t\telse\n\t\t\tpos = 0;\n\t}\n\treturn ans;\n}", "{\n  long ans\
    \ = -1;\n  long max;\n  int n;\n  int i = 0;\n  while (i < arr.length) \n  {\n\
    \    max = arr[i];\n    n = i;\n    while (n < arr.length) \n    {\n      if (max\
    \ >= arr[n]) \n      {\n        max = arr[n];\n        n = n;\n      } \n    \
    \  n++;\n    }\n    if (max != arr[i]) \n    {\n      if (ans < 0) \n      {\n\
    \        ans = max;\n      } \n      else \n      {\n        if (max < ans) \n\
    \        {\n          ans = max;\n        }\n      }\n    }\n    i++;\n  }\n \
    \ return ans;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\n//Write a function\
    \ that takes in an array of integers. \n//The function returns the index of the\
    \ first negative integer. ", "{\n    long ans = -1;\n    long curr = 0;\n    for(int\
    \ i = 0; i < arr.length; i++){\n        if(arr[i] > arr[curr]){\n            curr++;\n\
    \            ans = arr[i] > arr[curr] ? arr[curr] : ans;\n        } else {\n \
    \           ans = arr[i] > arr[curr] ? ans : -1;\n        }\n    }\n    return\
    \ ans;\n}\n</code>\n<|/ a |>\n<| c |>\nWhile this may answer the question, you\
    \ should [edit] your answer to explain *why* this code is correct and should be\
    \ used.\n<|/ c |>\n<| a tags=algorithm |>\nYou can use this in Java as well: \n\
    <code>\nstatic boolean canArrange(int[] arr){", "{\n    long maxIndex = -1;\n\
    \    long lastIndex = -1;\n    foreach(long element, arr)\n    {\n        lastIndex\
    \ = element;\n        if(lastIndex >=0)\n        {\n            if(element >=\
    \ arr[lastIndex])\n            {\n                maxIndex = lastIndex;\n    \
    \            break;\n            }\n        }\n        else\n        {\n     \
    \       break;\n        }\n    }\n    return maxIndex;\n}\n/*\nCreate a function\
    \ which returns a boolean indicating whether\n    there are any pairs of values\
    \ where the first value is equal to the second\n    value unless the first value\
    \ is less than the second value. The given array\n    will not contain duplicate\
    \ values.", "{\n\tfor (int i = 0; i < arr.size(); i++)\n\t{\n\t\tif (arr[i] >\
    \ arr[i-1])\n\t\t{\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n/*\nCreate a\
    \ function which returns the index of the element greater than or\n    equal to\
    \ the specified element. If there is no such element then\n    return -1. The\
    \ given array will not contain duplicate values.", "{\n    int i;\n    for (i\
    \ = 0; i < arr.length-1; ++i)\n    {\n        if (arr[i] <= arr[i + 1])\n    \
    \        return i;\n    }\n    return -1;\n}", "{\n\tlong i;\n\tint j;\n\t\n\t\
    for (i = 1; i < arr.length - 1; i++) \n\t{\n\t\tif (arr[i] < arr[i-1]) \n\t\t\t\
    break;\n\t}\n\t\n\tfor (j = i; j < arr.length; j++) \n\t{\n\t\tif (arr[j] < arr[i-1])\
    \ \n\t\t\tbreak;\n\t}", "{\n\tint ans = -1;\n\t\n\tfor (int i = 0; i < arr.length;\
    \ i++) {\n\t\tif (arr[i] <= arr[i + 1]) {\n\t\t\tif (arr[i] > ans) {\n\t\t\t\t\
    ans = arr[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = -1;\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t}\n\t}\n\t\n\treturn ans;\n}", "{\n\tlong prev;\n\tfor (int i = 0; i <\
    \ arr.length; i++) \n\t{\n\t\tif (arr[i] > arr[prev]) \n\t\t{\n\t\t\tprev = i;\n\
    \t\t}\n\t}\n\treturn prev;\n}", "{\n\tlong maxIndex = -1;\n\tlong previous = arr[0];\n\
    \tfor (long i=1; i<arr.length; i++){\n\t\tif (arr[i] > previous){\n\t\t\tmaxIndex\
    \ = i;\n\t\t}\n\t\tprevious = arr[i];\n\t}\n\treturn maxIndex;\n}", "{\n  int\
    \ i, j, max;\n  max = -1;", "{\n  long i = 0;\n  long maxIdx = 0;\n  for(; i <\
    \ arr.length; i++){\n    if (arr[i] >= arr[i-1]){\n      maxIdx = i;\n      break;\n\
    \    }\n  }\n  return maxIdx;\n}\n</code>\n<|/ a tags=arrays,algorithm,java,sorting\
    \ |>\n<| c |>\nThank you for writing a detailed answer to my question. I was stuck\
    \ on that problem for a while and didn't think about how I would go about solving\
    \ it. I'm going to try to implement this tonight and will update with my results.\
    \ Thank you for taking the time to write this out for me!\n<|/ c |>\n<| a tags=arrays,algorithm,java,sorting\
    \ dscore=0 |>\nI'm going to assume you have the following methods in your class:\n\
    <code>\npublic boolean compare(long aLong, int index) {\n    return false;\n}",
  "{\n    return std.math._lastIndexOf(arr, arr[0], arr[0]);\n}", "{\n    long i,j,max;\n\
    \    for(i = 1; i < arr.length; i++)\n    {\n        for(j = i-1; j > -1; j--)\n\
    \        {\n            if(arr[i] <= arr[j])\n            {\n                max\
    \ = arr[j];\n                arr[j] = arr[i];\n                arr[i] = max;\n\
    \                break;\n            }\n        }\n    }\n    return arr[arr.length-1];\n\
    }", "{\n    int i, j;\n    long min;\n    \n    min = arr[0];\n    i = 1;\n  \
    \  for (j = 1; j < arr.length; ++j) {\n        if (min > arr[j]) {\n         \
    \   min = arr[j];\n            i = j;\n        }\n    }\n    return i;\n}\n/*\n\
    Create a function which returns the largest index of an element which\n    is\
    \ not greater than or equal to the element immediately preceding it. If\n    no\
    \ such element exists then return -1. Do not use the standard library sort\n \
    \   function - it is too slow. Use the following algorithm instead:", "{\n   \
    \ /*\n        O(n)\n        \n    */\n    long ans = -1;\n    for(int i = 0; i\
    \ < arr.length; i++) \n    {\n        if(arr[i] <= arr[i-1])\n        {\n    \
    \        ans = arr[i];\n            break;\n        }\n    }\n    return ans;\n\
    }", "{\n    if (arr.length == 0)\n        return -1;\n    int i;\n    long firstElem\
    \ = arr[0];\n    long maxElem = firstElem;\n    for(i=1; i<arr.length; ++i) {\n\
    \        if (arr[i] >= firstElem) {\n            maxElem = arr[i];\n        }\
    \ else {\n            if (maxElem < firstElem) {\n                return -1;\n\
    \            } else if (maxElem == firstElem) {\n                return i;\n \
    \           }\n        }\n    }\n    return i;\n}", "{\n    long curr = -1, l\
    \ = 0, r = arr.length-1;\n    while (l < r) {\n        long mid = (l + r)/2;\n\
    \        if (curr <= arr[mid]) {\n            l = mid + 1;\n        }\n      \
    \  else {\n            r = mid - 1;\n        }\n        curr = arr[mid];\n   \
    \ }\n    return curr;\n}\n</code>\n<|/ a |>\n<| c |>\n`if (curr <= arr[mid]) l\
    \ = mid + 1;` is more efficient as `l = (mid + r) / 2;`\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>\npackage com.example.util;", "{\n    long result = 0;\n    long index\
    \ = 0;\n    for(int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] <=\
    \ arr[index])\n        {\n            index = i;\n        }\n    }\n    if (index\
    \ != 0)\n    {\n        result = arr[index];\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=sorting,arrays,c dscore=1 |>\n<| c |>\nI used the code by Jasen but\
    \ for some reason the code was not working for me. I am not able to understand\
    \ why so thought of taking the help of other people and here I am.\n<|/ c |>\n\
    <| c |>\nI posted it here: https://ideone.com/l9QhcM - it's too much to post on\
    \ ideone. Can you tell me if you can execute the code in there or not? If it works,\
    \ you can then compare with your code.\n<|/ c |>\n<| c |>\nThe idea is that the\
    \ element to its left is greater than the element to the right and if that is\
    \ also not greater than the element to the left. Then the element to the left\
    \ is greater than the element to the right and if that is also not greater than\
    \ the element to the left. So, I think we would need a loop for that.\n<|/ c |>\n\
    <| c |>\nYes, I think we need a loop for that.\n<|/ c |>\n<| c |>\nI modified\
    \ my code to solve the problem. Can you please check whether it is correct.\n\
    <|/ c |>\n<| a |>\n<code>\n#include <stdio.h>\n#include <stdlib.h>", "{\n    long\
    \ lo = 0;\n    long hi = arr.length - 1;\n    \n    while(lo < hi) {\n       \
    \ long mid = (lo + hi) / 2;\n        if(arr[mid] <= arr[lo])\n            lo =\
    \ mid;\n        else\n            hi = mid;\n    }\n    return lo;\n}\n/*\nCreate\
    \ a function which returns the smallest index of an element which\n    is not\
    \ less than or equal to the element immediately preceding it. If\n    no such\
    \ element exists then return -1. The given array will not contain\n    duplicate\
    \ values.", "{\n  if(arr.length==0) return -1;", "{\n\tlong ans = -1L;\n\tbool\
    \ found = false;\n\tlong prev_max = arr[0];\n\tfor(int i = 1; i < arr.length;\
    \ i++)\n\t{\n\t\tif(arr[i] > prev_max)\n\t\t{\n\t\t\tfound = true;\n\t\t\tans\
    \ = i;\n\t\t}\n\t\tprev_max = arr[i];\n\t}\n\tif(!found)\n\t\tans = -1L;\n\treturn\
    \ ans;\n}", "{\n\tlong maxElem = arr[0];\n\tlong maxIndex = -1;\n\tint i;\n\t\n\
    \tfor (i = 1; i < arr.length; i++)\n\t{\n\t\tif (maxElem <= arr[i])\n\t\t\tmaxIndex\
    \ = i;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn maxIndex;\n}", "{\n\tlong last =\
    \ arr[0];\n\tint j = 0;\n\tfor (long i = 1; i < arr.length; ++i)\n\t{\n\t\tif\
    \ (arr[i] <= last)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlast =\
    \ arr[j];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn j;\n}", "{\n\tif (arr.length < 2)\
    \ return -1;", "{\n    long index = -1, pos = -1, temp;\n    for(size_t i = 0;\
    \ i < arr.size(); i++)\n    {\n        if(arr[i] <= arr[pos])\n        {\n   \
    \         pos = i;\n        }\n        else if(arr[i] < arr[pos])\n        {\n\
    \            temp = arr[i];\n            arr[i] = arr[pos];\n            arr[pos]\
    \ = temp;\n            index = i;\n        }\n    }\n    return index;\n}\n</code>\n\
    And of course it can be optimized more:\n<code>\n#include <stdio.h>", "{\n\tlong\
    \ index = -1;\n\tfor (int i = 0; i < arr.length; i++) \n\t{\n\t\tif (arr[i] <=\
    \ arr[index])\n\t\t{\n\t\t\tindex = i;\n\t\t}\n\t}\n\treturn index;\n}\n/*\nCreate\
    \ a function which returns the largest index of an element which\n    is not greater\
    \ than the element immediately preceding it. If\n    no such element exists then\
    \ return -1. The given array will not contain\n    duplicate values.", "{\n  \
    \  long max = 0;\n    int size = arr.length;\n    for (int i = 0; i < size; i++)\
    \ {\n        if (max < arr[i] && arr[i] < arr[i + 1])\n            max = arr[i];\n\
    \    }\n    return max;\n}", "{\n    int i = 0, j;\n    long maxIndex = -1;\n\
    \    for (; i < arr.length - 1; i++) {\n        for (j = i + 1; j < arr.length;\
    \ j++) {\n            if (arr[j] > arr[i]) {\n                maxIndex = max(maxIndex,\
    \ j - 1);\n            }\n        }\n    }\n    return maxIndex;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nThe algorithm is O(n^2) and the array is not sorted.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nI hope this code snippet helps you solve your problem\
    \ in O(n) time complexity and O(1) space complexity\n<code>\ndef largestIndex(arr):\n\
    \    maxIndex = None\n    index = 0\n    while index < len(arr):\n        if arr[index]\
    \ > arr[index + 1]:\n            maxIndex = index\n        index += 1\n    return\
    \ maxIndex", "{\n\tlong  i,j;", "{\n\tlong maxIndex = 0;\n\tint i = 0;\n\twhile(i\
    \ < arr.length) {\n\t\tif (arr[i] >= arr[maxIndex]) {\n\t\t\tmaxIndex = i;\n\t\
    \t}\n\t\ti++;\n\t}\n\treturn maxIndex;\n}\n/*\nCreate a function which returns\
    \ the largest index of an element which\n    is not greater than or equal to the\
    \ element immediately preceding it. If\n    no such element exists then return\
    \ -1. The given array will not contain\n    duplicate values.", "{\n    long result\
    \ = -1L;\n    for (int i = 0; i < arr.length-1; i++) {\n        if (arr[i] >=\
    \ arr[i + 1]) {\n            if (result == -1L) {\n                result = i;\n\
    \            } else if (arr[i] == arr[i + 1]) {\n                result = -1;\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    long maxIndex\
    \ = -1;\n    long minIndex = 0;\n    for(int i = 0; i < arr.length; i++) {\n \
    \       if(arr[i] > arr[minIndex]) {\n            minIndex = i;\n        }\n \
    \       if(arr[i] < arr[maxIndex]) {\n            maxIndex = i;\n        }\n \
    \   }\n    return maxIndex;\n}", "{\n\tlong max_idx = -1;\n\tlong max_val = arr[0];\n\
    \t\n\tfor (int i = 1; i < arr.length; i++) \n\t{\n\t\tif (arr[i] >= max_val) \n\
    \t\t{\n\t\t\tmax_idx = i;\n\t\t\tmax_val = arr[i];\n\t\t}\n\t}\n\t\n\treturn max_idx;\n\
    }", "{\n\tlong maxI = 0;\n\tlong max = 0;\n\tfor (int i = 0; i < arr.length -\
    \ 1; i++)\n\t{\n\t\tif (arr[i] < arr[maxI])\n\t\t\tmaxI = i;\n\t\telse if (arr[i]\
    \ > arr[maxI])\n\t\t\tmax = arr[i];\n\t}", "{\n    int i = (int)(arr.length-1);\n\
    \    long max = -1;\n    while (i>=0){\n        if (arr[i] <= arr[i-1]){\n   \
    \         max = arr[i-1];\n        }\n        else{\n            break;\n    \
    \    }\n        i--;\n    }\n    return max;\n}\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=java,algorithm,sorting dscore=0 |>\n<code>\nimport java.util.Arrays;",
  "{\n  int n = arr.length;\n  int i;\n  long max_i;\n  int count = 0;\n  long largest_i\
    \ = -1;", "{\n\t\n\tlong maxIndex = -1;\n\tfor(int i=0; i < arr.length; i++)\n\
    \t{\n\t\t\n\t\tif(arr[i]>maxIndex)\n\t\t{\n\t\t\tmaxIndex = arr[i];\n\t\t}\n\t\
    \t\n\t\tif(arr[i]==maxIndex)\n\t\t{\n\t\t\t\n\t\t}\n\t}\n\treturn maxIndex;\n}",
  "{\n    long maxind;\n    for(int i = 0; i < arr.length; i++){\n        int j;\n\
    \        if(arr[i] <= arr[i + 1]){\n            for(j = i; j < arr.length; j++){\n\
    \                if(arr[j] == arr[i]){\n                    return -1L;\n    \
    \            }\n            }\n        }else{\n            for(j = i; j < arr.length;\
    \ j++){\n                if(arr[j] > arr[i]){\n                    maxind = j;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return maxind;\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\n/*\n\
    \ * Copyright 2013 Amit Agarwal\n *\n * Licensed under the Apache License, Version\
    \ 2.0 (the \"License\");\n * you may not use this file except in compliance with\
    \ the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n\
    \ *\n * Unless required by applicable law or agreed to in writing, software\n\
    \ * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT\
    \ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the\
    \ License for the specific language governing permissions and\n * limitations\
    \ under the License.\n */", "{\n\tint j = 0;\n\tlong maxIndex = -1;\n\tfor (long\
    \ i = 1, max = arr[0]; i <= max; i++)\n\t{\n\t\tif (arr[i] > max)\n\t\t{\n\t\t\
    \tmaxIndex = i;\n\t\t\tmax = arr[i];\n\t\t}\n\t\tif (arr[i] == max)\n\t\t{\n\t\
    \t\tj++;\n\t\t}\n\t}\n\tif (j > 0)\n\t{\n\t\treturn maxIndex;\n\t}\n\telse\n\t\
    {\n\t\treturn -1;\n\t}\n}\n/*\nCreate a function which returns the largest index\
    \ of an element which\n    is not greater than or equal to the element immediately\
    \ preceding it. If\n    no such element exists then return -1. The given array\
    \ will not contain\n    duplicate values.", "{\n    long  largest, smallest, mid,\
    \ temp;\n    smallest = arr[0];\n    smallest = std.math.min(smallest, arr[1]);\n\
    \    smallest = std.math.min(smallest, arr[2]);\n    smallest = std.math.min(smallest,\
    \ arr[3]);\n    smallest = std.math.min(smallest, arr[4]);\n    smallest = std.math.min(smallest,\
    \ arr[5]);\n    smallest = std.math.min(smallest, arr[6]);\n    smallest = std.math.min(smallest,\
    \ arr[7]);\n    smallest = std.math.min(smallest, arr[8]);\n    smallest = std.math.min(smallest,\
    \ arr[9]);\n    smallest = std.math.min(smallest, arr[10]);\n    smallest = std.math.min(smallest,\
    \ arr[11]);\n    smallest = std.math.min(smallest, arr[12]);\n    smallest = std.math.min(smallest,\
    \ arr[13]);\n    smallest = std.math.min(smallest, arr[14]);\n    smallest = std.math.min(smallest,\
    \ arr[15]);\n    smallest = std.math.min(smallest, arr[16]);\n    smallest = std.math.min(smallest,\
    \ arr[17]);\n    smallest = std.math.min(smallest, arr[18]);\n    smallest = std.math.min(smallest,\
    \ arr[19]);\n    smallest = std.math.min(smallest, arr[20]);\n    smallest = std.math.min(smallest,\
    \ arr[21]);\n    smallest = std.math.min(smallest, arr[22]);\n    smallest = std.math.min(smallest,\
    \ arr[23]);\n    smallest = std.math.min(smallest, arr[24]);\n    smallest = std.math.min(smallest,\
    \ arr[25]);\n    smallest = std.math.min(smallest, arr[26]);\n    smallest = std.math.min(smallest,\
    \ arr[27]);\n    smallest = std.math.min(smallest, arr[28]);\n    smallest = std.math.min(smallest,\
    \ arr[29]);\n    smallest = std.math.min(smallest, arr[30]);\n    smallest = std.math.min(smallest,\
    \ arr[31]);\n    largest = std.math.max(smallest, arr[32]);\n    largest = std.math.max(largest,\
    \ arr[33]);\n    largest = std.math.max(largest, arr[34]);\n    largest = std.math.max(largest,\
    \ arr[35]);\n    largest = std.math.max(largest, arr[36]);\n    largest = std.math.max(largest,\
    \ arr[37]);\n    largest = std.math.max(largest, ", "{\n\tint len = arr.length;\n\
    \tint k = 0;\n\tint max = -1L;\n\tint cur = 0;\n\tfor (int i = 1; i < len; i++)\
    \ {\n\t\tif (arr[i] > arr[cur]) \n\t\t{\n\t\t\tmax = i;\n\t\t\tk = cur;\n\t\t\
    }\n\t\tcur = i;\n\t}\n\tif (max > -1) {\n\t\treturn max;\n\t} else {\n\t\treturn\
    \ -1;\n\t}\n}\n/*\nCreate a function which takes an array and two indexes in the\
    \ array and\n    returns the difference between the two indexes as an integer\
    \ value.\n    The given array will not contain duplicate values.", "{\n\tlong\
    \ retval = -1;\n\t\n\tfor (int i = 0; i < arr.length; i++){\n\t\tif (i > 0){\n\
    \t\t\tif (arr[i] >= arr[i-1]){\n\t\t\t\tretval = i;\n\t\t\t\tbreak;\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn retval;\n}", "{\n    long max_i = -1;\n    \n    for (int\
    \ i = 0; i < (arr.length - 1); i++) {\n        if (arr[i] >= arr[i+1]) \n    \
    \        continue;\n        \n        max_i = i;\n        break;\n    }\n    \n\
    \    return max_i;\n}", "{\n    if (arr.length == 0) return -1;\n    long min\
    \ = arr[0], max = arr[arr.length-1];\n    for(long i=0; i<arr.length; i++) \n\
    \    {\n        if (arr[i] > max) max = arr[i];\n        if (arr[i] < min) min\
    \ = arr[i];\n    }\n    return arr.length - 1;\n}\n</cell>\n<cell>\nimport std.math;\n\
    /*\nCreate a function which returns the smallest index of an element which\n \
    \   is not less than or equal to the element immediately following it. If\n  \
    \  no such element exists then return -1. The given array will not contain\n \
    \   duplicate values.", "{\n  long i;\n  long max = 0;\n  for (i = 1; i < arr.length;\
    \ ++i) {\n    if (arr[i] < arr[max]) {\n      max = i;\n    }\n  }\n  return max\
    \ == 0 ? -1 : (max == arr.length - 1 ? arr.length - 1 : max);\n}\n</code>\n<|/\
    \ a tags=c#,algorithm dscore=0 |>\n<| c |>\nI thought of that, but I wanted to\
    \ see if someone could come up with a solution that didn't require a for loop\n\
    <|/ c |>\n<| c |>\n: I added a C# solution. Maybe it's more readable.\n<|/ c |>\n\
    <| c |>\nHmm, this does not seem to meet the requirement that it does *not* require\
    \ a for loop. I can't think of a way to do this without a for loop.\n<|/ c |>\n\
    <| a tags=c#,algorithm dscore=0 |>\nI think it's easy to see that if you have\
    \ a range of numbers, any number greater than the largest number in the range\
    \ will have the next number be greater than the largest.  So a solution that avoids\
    \ a for loop would be something like:\n<code>", "{\n    long ans = -1;\n    long\
    \ i = 0;", "{\n\tif (arr.length < 1) return -1;\n\tint maxIndex = 0;\n\tfor (int\
    \ i = 0; i < arr.length; i++) \n\t{\n\t\tint left = arr[i];\n\t\tif (i == 0) \n\
    \t\t\tmaxIndex = left;\n\t\telse \n\t\t{\n\t\t\tif (std.math.max(left, arr[i -\
    \ 1]) < std.math.min(left, arr[i - 1])) \n\t\t\t\treturn -1L;\n\t\t\tmaxIndex\
    \ = std.math.max(maxIndex, std.math.max(left, arr[i - 1]));\n\t\t}\n\t}\n\treturn\
    \ maxIndex;\n}\n\"\"\")\n        return libclangclang_wrapper.libclangclangclang_create(0,\
    \ self.cindex.NULL, None, 1, None, None)", "{\n    // write your code in C# here\n\
    \    int max = 0;\n    int n = arr.Length;\n    for (int i = 0; i < n - 1; i++)\n\
    \    {\n        if (arr[i] >= arr[i + 1])\n        {\n            max = i;\n \
    \           break;\n        }\n        else\n        {\n            if (i == n\
    \ - 2)\n            {\n                max = i;\n                break;\n    \
    \        }\n            else\n            {\n                if (arr[i + 1] <=\
    \ arr[max])\n                {\n                    max = i + 1;\n           \
    \     }\n            }\n        }\n    }\n    return max;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>\nimport java.util.Scanner;", "{\n\tlong i = 0;\n\
    \    long n = arr.length;\n    long max = arr[0];\n    long index = -1;\n    for(i=1;\
    \ i < n; i++){\n        if(arr[i] <= max){\n            index = i;\n         \
    \   max = arr[i];\n        }\n    }\n    return index;\n}\n/*\nCreate a function\
    \ which returns the largest index of an element which\n    is not greater than\
    \ or equal to the element immediately preceding it. If\n    no such element exists\
    \ then return -1. The given array will not contain\n    duplicate values.", "{\n\
    \tlong i, j;\n\tfor(i = 1; i < arr.length; i++) \n\t{\n\t\tfor(j = i; j > 0; j--)\
    \ \n\t\t{\n\t\t\tif(arr[j] >= arr[j-1]) return j;\n\t\t}\n\t}\n\treturn -1L;\n\
    }", "{\n    long max_val = arr[0];\n    long max_idx = -1;\n    for (long i =\
    \ 0; i < arr.length; i++) {\n        long value = arr[i];\n        if ((value\
    \ - max_val) < (arr[i+1] - max_val)) {\n            long j = i + 1;\n        \
    \    while (j<arr.length && arr[j] == arr[i]+1) {\n                j++;\n    \
    \        }\n            max_idx = j;\n            max_val = value;\n        }\n\
    \    }\n    return max_idx;\n}", "{\n  long max_index = 0;\n  for (long i = 0;\
    \ i < arr.length - 1; i++) {\n    if (arr[i] <= arr[i + 1]) {\n      max_index\
    \ = i;\n    } else {\n      return -1L;\n    }\n  }\n  return max_index;\n}\n\
    </code>\n<|/ a tags=java dscore=0 |>\n<| a tags=java |>\n<code>\npublic class\
    \ Solution {\n    static int findFirstMissingPositive(int arr[], int k) {\n  \
    \      int n = arr.length;\n        int first = arr[0];\n        for (int i =\
    \ 1; i < n; i++) {\n            int val = arr[i];\n            if (val - first\
    \ >= k) {\n                return first;\n            }\n            first = val;\n\
    \        }\n        return first;\n    }\n}\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=java dscore=0 |>\n<code>\npublic class Solution {\n    public static void\
    \ main(String[] args) {\n        int arr[] = {-1, 2, 4, 3, 5};\n        int k\
    \ = 1;\n        System.out.println(missingPositive(arr, k));\n    }\n    static\
    \ int missingPositive(int arr[], int k) {\n        int n = arr.length;\n     \
    \   int first = arr[0];\n        for (int i = 1; i < n; i++) {\n            int\
    \ val = arr[i];\n            if (val - first >= k) {\n                return first;\n\
    \            }\n            first = val;\n        }\n        return first;\n \
    \   }\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\npublic class Solution {\n    public\
    \ static void main(String[] args) {\n        int arr[] = {-1, 2, 4, 3, 5};\n \
    \       int k = 1;\n        System.out.println(missingPositive(arr, k));\n   \
    \ }\n    static int missingPositive(int arr[], int k) {\n        int n = arr.length;\n\
    \        int first = arr[0];\n        for (int i = 1; i < n; i++) {\n        \
    \    int val = arr[i];\n            if (val - first >= k) {\n                return\
    \ first;\n            }\n            first = val;\n        }\n        return first;\n\
    \    }\n}\n</code>\n<|/ a dscore=0 tags=java |>\n<| a tags=java |>\n<code>\npackage\
    \ com.company;", "{\n\tint left = 0;\n\tint right = arr.length-1;", "{\n    int\
    \ i = 1;\n    int j = 1;\n    int k = 0;\n    int count = 0;\n    while (i < arr.length\
    \ && j >= 0) {\n        if (arr[i] <= arr[j]) {\n            j = k++;\n      \
    \  }\n        else if (j > count) {\n            count = j;\n            k = j\
    \ + 1;\n        }\n        else {\n            i = j;\n            j = k++;\n\
    \        }\n    }\n    return count > 0 ? count : -1;\n}\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. `can_arrange([1L, 3L, 3L, 2L])` returns 2 when\
    \ it should be 1. The correct answer is 3.\n<|/ c |>\n<| c |>\nI've updated my\
    \ answer. I've also posted an explanation about the algorithm.\n<|/ c |>\n<| a\
    \ tags=algorithm,java,arrays dscore=0 |>\nFor fun, here's a very straightforward\
    \ solution that just looks for the lowest index that is greater than all elements\
    \ in the array.\n<code>\npublic static int findLowerIndex(int[] arr) {\n    int\
    \ low = Integer.MAX_VALUE;\n    int high = Integer.MIN_VALUE;\n    for (int i=0;\
    \ i<arr.length; i++) {\n        int v = arr[i];\n        low -= v;\n        high\
    \ += v;\n    }\n    int lowIndex = low;\n    while (lowIndex < arr.length && arr[lowIndex]\
    \ == arr[lowIndex+1]) {\n        lowIndex++;\n    }\n    return lowIndex;\n}\n\
    </code>\n<|/ a |>\n<| a tags=algorithm,java,arrays |>\nThis algorithm also has\
    \ linear time complexity, which is optimal because the maximum possible value\
    \ of an index will be the number of elements in the array. \nThe trick is to get\
    \ the maximum possible value in a single iteration of loop. Here is what I did:\n\
    <code>", "{\n\tlong first = std.min.arr[arr];\n\tlong last = std.max.arr[arr];\n\
    \t\n\tif (first != last)\n\t\treturn last;\n\t\n\treturn -1;\n}", "{\n    long\
    \ maxPos = 0;\n    long maxVal = arr[0];\n    for (int i = 1; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] <= maxVal)\n        {\n            maxVal =\
    \ arr[i];\n            maxPos = i;\n        }\n    }\n    return maxPos;\n}\n\
    </code>\n<|/ a tags=arrays,algorithm,language-agnostic dscore=0 |>\n<| a |>\n\
    Okay, so since it seems like you're just looking to write a function that does\
    \ this in Java, here's a sample code (without importing any extra packages) that\
    \ uses your example input and your output functions (which I called canArrange):\n\
    <code>\npublic static boolean canArrange(int[] array) {\n  long maxPos = canArrange(array);\n\
    \  if(maxPos == -1) return false;\n  return true;\n}", "{\n\tlong result = -1;\n\
    \tfor (int i = 0; i < arr.length; i++)\n\t{\n\t\tfor (int j = i; j < arr.length;\
    \ j++)\n\t\t{\n\t\t\tif (arr[i] < arr[j] && result < j) result = j;\n\t\t}\n\t\
    }\n\treturn result;\n}", "{\n\tif (arr.length==0)\n\t\treturn -1L;\n\tlong max=arr[0];\n\
    \tfor (int i=1; i<arr.length; i++) \n\t\tif (arr[i]>=max)\n\t\t\tmax=arr[i];\n\
    \tint k=0;\n\tfor (int i=0; i<arr.length; i++) \n\t{\n\t\tif (arr[i]!=max)\n\t\
    \t{\n\t\t\tarr[k++]=arr[i];\n\t\t\tif (i==arr.length-1)\n\t\t\t\tbreak;\n\t\t\
    }\n\t}\n\treturn k;\n}\n\"\"\"\ncpp.add_function('can_arrange', can_arrange)",
  "{\n\tlong index = 0;\n\tlong first = 1;\n\tfor (int i = 1; i < arr.length; i++)\
    \ {\n\t\tif (arr[i] > arr[first]) first = i;\n\t}\n\tif (first != arr.length -\
    \ 1) {\n\t\tindex = first;\n\t}\n\treturn index;\n}", "{\n    bool flag = false;\n\
    \    long maxValue = -1;\n    for(int i = 0; i < arr.length; ++i)\n    {\n   \
    \     if(arr[i] <= arr[(i + 1) % arr.length])\n        {\n            if(!flag)\n\
    \            {\n                maxValue = arr[i];\n                flag = true;\n\
    \            }\n        }\n        else\n        {\n            flag = false;\n\
    \        }\n    }\n    return maxValue;\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\nIt can be solved in O(n) time complexity:\n<code>\ndef longest_increasing_subsequence(nums):\n\
    \    \"\"\"\n    Find the longest increasing subsequence in a sequence of numbers\n\
    \    >>> longest_increasing_subsequence([5,3,6,8,4,8,4,6,7,9])\n    [8, 4, 6]\n\
    \    \"\"\"\n    sorted_nums = sorted(nums)\n    longest_increasing_subsequence\
    \ = []\n    longest_increasing_subsequence_length = 1\n    for i in range(len(sorted_nums)):\n\
    \        if sorted_nums[i] < longest_increasing_subsequence[-1]:\n           \
    \ longest_increasing_subsequence_length += 1\n        else:\n            longest_increasing_subsequence_length\
    \ = 1\n        longest_increasing_subsequence.append(sorted_nums[i])\n       \
    \ if longest_increasing_subsequence_length > len(longest_increasing_subsequence):\n\
    \            break\n    return longest_increasing_subsequence\n</code>\n<|/ a\
    \ tags=algorithm,dynamic-programming,c++,c# |>\n<| a dscore=0 |>\nC++ solution\
    \ with O(n^2) complexity:\n<code>\n#include <vector>\n#include <iostream>\nusing\
    \ namespace std;", "{\n    long maxIdx = 0;\n    \n    for(int i = 1; i < arr.length;\
    \ i++)\n    {\n        if(arr[i] > arr[maxIdx])\n            maxIdx = i;\n   \
    \ }\n    \n    if(maxIdx == 0)\n        return -1;\n    \n    return maxIdx;\n\
    }\n</code>\n<|/ a dscore=2 tags=c++,c++11,algorithm,arrays |>\n<| c |>\nCan you\
    \ please elaborate on the reason for downvote?\n<|/ c |>\n<| c |>\nI think you\
    \ should consider putting the first two conditions as `if` statements, and the\
    \ second two conditions as `else if`. Then the loop can be cleaned up a bit with\
    \ something like `for( int i = 0; i < (arr.length - 1); i++ ) { if(arr[i] <= arr[i+1])\
    \ maxIdx = i; }`\n<|/ c |>\n<| c |>\n, thank you, but my solution doesn't require\
    \ any conditional checks since I am checking if next element is greater than the\
    \ previous one. Also `if` condition can be avoided by directly checking the next\
    \ element's `<=` condition.\n<|/ c |>\n<| c |>\nOh I see, I was thinking you could\
    \ reuse your code. Makes sense.\n<|/ c |>\n<| c |>\nThis is great code, but my\
    \ code isn't working properly. I think it's because you're using int for maxIdx,\
    \ but I'm using a long type instead. I get some numbers that aren't even the correct\
    \ maxIdx, so it's not working\n<|/ c |>\n<| a tags=c++,c++11,algorithm,arrays\
    \ |>\nI believe this is a simple problem: given a sorted array and a target element,\
    \ find the index of the element larger than the target, or -1 if no such element\
    \ exists.\n<code>", "{\n    long largest = arr[0];\n    long current = arr[0];\n\
    \    for (int i = 1; i < arr.length; i++) {\n        if (arr[i] > current) {\n\
    \            largest = current;\n            current = arr[i];\n        } else\
    \ if (arr[i] < current) {\n            if (largest != current)\n             \
    \   return largest;\n        }\n    }\n    return largest;\n}\n</code>\n<|/ a\
    \ tags=algorithm |>\n<| c |>\nThis looks amazing, i will try implementing it and\
    \ report back. Thank you!\n<|/ c |>\n<| a |>\nThis is actually the Highest Common\
    \ Ancestor Problem and can be solved in O(n) time (where n is the number of elements).\n\
    The idea is to take every element and compare it with every other element to find\
    \ the one that has the greatest common ancestor.\nThe algorithm can be summarized\
    \ as follows: ", "{\n\tlong i;\n\tlong largest_i  = -1;\n\tlong largest_val =\
    \ -1;\n\t\n\tfor(i = 0; i<arr.length; ++i){\n\t\tif(arr[i] <= largest_val){\n\t\
    \t\tlargest_i = i;\n\t\t\tlargest_val = arr[i];\n\t\t}\n\t}\n\t\n\tif(largest_val\
    \ == -1){\n\t\treturn -1L;\n\t}\n\t\n\tfor(i = largest_i-1; i>=0; i--){\n\t\t\
    if(i!=largest_i && arr[i]<=largest_val){\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tif(i==0){\n\
    \t\treturn -1L;\n\t}\n\t\n\treturn i;\n}", "{\n    long result=-1;\n    for(int\
    \ i=0;i<arr.length-1;i++)\n    {\n        if((arr[i]>arr[i+1]))\n        {\n \
    \           result=arr[i+1];\n        }\n    }\n    return result;\n}\n</code>\n\
    <|/ a tags=algorithm,arrays |>\n<| c |>\nWhile this code may answer the question,\
    \ providing additional context regarding *why* and/or *how* this code answers\
    \ the question improves its long-term value.\n<|/ c |>\n<| a tags=algorithm,arrays\
    \ |>\n<code>", "{\n  int max = -1;\n  long cur = arr[0];\n  for (int i = 1; i\
    \ < arr.length; ++i) {\n    if (arr[i] <= cur) {\n      ++max;\n    } else {\n\
    \      if (max != -1)\n        return max;\n      else\n        max = i;\n   \
    \   cur = arr[i];\n    }\n  }\n  return max;\n}", "{\n    long maxIndex = -1;\n\
    \    \n    for(long i=1;i<arr.length;i++)\n    {\n        if(arr[i-1] <= arr[i])\n\
    \        {\n            maxIndex = i;\n            break;\n        }\n    }\n\
    \    \n    return maxIndex;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work. Consider `arr = [4,3,2,1,2]`\n<|/ c |>\n<| c |>\nI actually tested the\
    \ code before posting it and it works fine. The function returns 3 for arr = [4,3,2,1,2]\
    \ and -1 for arr = [4,3,2,1]. I've also updated the code to avoid the problem.\
    \ Thank you for pointing it out :)\n<|/ c |>\n<| c |>\nHm, I wonder if OP would\
    \ like `arr = [4,3,2,2,3]` to be returned as `-1L`... And I wonder how it is possible\
    \ that `arr = [4,3,2,3]` returns `3L`... :)\n<|/ c |>\n<| c |>\nI guess I assumed\
    \ that since arr only contains unique elements we shouldn't have to worry about\
    \ duplicates in that case. Updated the code to avoid that too. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| a tags=c,algorithm |>\n<code>\n#include <stdio.h>\n#include\
    \ <stdlib.h>\n#include <string.h>", "{\n    long res = -1;", "{\n    long max\
    \ = -1L;\n    long maxIndex = 0;\n    for(long i = 0; i < arr.length; i++){\n\
    \        if(arr[i] > arr[maxIndex]){\n            max = arr[i];\n            maxIndex\
    \ = i;\n        }\n    }\n    return maxIndex;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=1 |>\n<code>\nimport java.util.ArrayList;\nimport java.util.Collections;\n\
    import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;",
  "{\n    int low = 0;\n    int high = arr.length - 1;\n    int mid;\n    while(low\
    \ <= high) {\n        mid = low + (high - low)/2;\n        if(arr[mid] <= arr[mid-1])\
    \ {\n            low = mid+1;\n        }\n        else {\n            high = mid-1;\n\
    \        }\n    }\n    return high;\n}\n'''", "{\n    long maxIndex = -1;\n  \
    \  int i = 0;", "{\n\tlong maxIndex = -1;\n\tfor(long i=1; i<arr.length; ++i)\n\
    \t{\n\t\tif(arr[i] >= arr[i-1])\n\t\t{\n\t\t\tmaxIndex = i;\n\t\t\tbreak;\n\t\t\
    }\n\t}\n\treturn maxIndex;\n}", "{\n    long largest = -1L;\n    long previousIndex\
    \ = 0;\n    for(int i = 0; i < arr.length - 1; i++)\n    {\n        if(arr[i]\
    \ > arr[previousIndex])\n        {\n            largest = arr[i];\n        }\n\
    \        else\n        {\n            previousIndex = i;\n        }\n    }\n \
    \   return largest;\n}\n</code>\nOutput:\n<code>\n1\n2\n3\n4\n5\n-1\n</code>\n\
    <|/ a dscore=1 tags=java |>\n<| c |>\nThanks for the help! I realized I needed\
    \ something that checks if a number is equal to it's previous number.\n<|/ c |>\n\
    <| c |>\nThanks for the help! I realized I needed something that checks if a number\
    \ is equal to it's previous number. Can you help me with this? I would appreciate\
    \ it.\n<|/ c |>\n<| c |>\nI updated my answer to include your solution. Hope it\
    \ helps.\n<|/ c |>\n<| a dscore=1 tags=java |>\n<code>", "{\n  int i = 1; // current\
    \ index\n  int j = arr.length - 1; // ending index\n  while (j >0) {\n    if (arr[i]\
    \ >= arr[j]) {\n      j--;\n    }\n    else {\n      i++;\n    }\n  }\n  return\
    \ j;\n}", "{\n    long maxIdx = -1, minIdx = arr.length() - 1;", "{\n    long\
    \ maxIndex = -1;\n    for (long i = 0; i < arr.length; ++i) {\n        if (arr[i]\
    \ >= arr[i + 1])\n            return -1;\n        else if (arr[i] > maxIndex)\
    \ {\n            maxIndex = arr[i];\n        }\n    }\n    return maxIndex;\n\
    }\n// End of function can_arrange\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 tags=arrays,java,sorting,algorithm,c\
    \ |>\n<code>\nstatic int largestNotGreaterThan(List<Integer> list, int k) {\n\
    \        int n = list.size();\n        if (k == n) {\n            return list.get(k);\n\
    \        }\n        int k1 = list.indexOf(k);\n        int k2 = k1 + 1;\n    \
    \    int max = 0;\n        int max = Math.max(max, largestNotGreaterThan(list.subList(k1,\
    \ k2), k2));\n        max = Math.max(max, largestNotGreaterThan(list.subList(k2,\
    \ n), n));\n        return max;\n    }\n</code>\n<|/ a |>\n<| a dscore=0 tags=arrays,java,sorting,algorithm,c\
    \ |>\nWe can find maximum in the subarray with linear complexity by comparing\
    \ each number with maximum number in the subarray. Following is a simple example\
    \ with O(n) complexity\n<code>\nstatic int findMax(int[] arr) {\n    int max =\
    \ Integer.MIN_VALUE;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i]\
    \ > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nBut it has a linear complexity too.\n<|/ c |>\n<|\
    \ c |>\nYes but the loop can be replaced with a single array scan\n<|/ c |>\n\
    <| c |>\nIn a single loop it is obvious that it will do `O(n)` comparisons but\
    \ in multiple loops it might be `O(n^2)`.\n<|/ c |>\n<| c |>\nI believe you are\
    \ right. The complexity of the above solution is `O(n^2)`\n<|/ c |>\n<| c |>\n\
    `findMax` has `O(n)` complexity. It is not surprising since it is doing `O(n)`\
    \ number of comparisons.\n<|/ c |>\n<| a dscore=0 |>\nWe can find the maximum\
    \ in the subarray with a single loop by comparing each number with the maximum\
    \ number in the subarray. Following is a simple example with O(n) complexity\n\
    <code>\nstatic int findMax(int[] arr) {\n    int max = Integer.MIN_VALUE;\n  \
    \  for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > max) {\n", "{\n\
    \    int i;\n    long ret = -1;\n    \n    for (i=1; i<arr.length; i++)\n    {\n\
    \        if (arr[i-1] >= arr[i])\n        {\n            if (ret >= 0)\n     \
    \       {\n                return -1;\n            }\n            else\n     \
    \       {\n                ret = i;\n            }\n        }\n    }\n    return\
    \ ret;\n}", "{\n    long maxium = arr[arr.length-1];", "{\n    long result = -1;\n\
    \    long largestIndex = 0;\n    for (int i = 0; i < arr.length; ++i)\n    {\n\
    \        if (arr[i] <= arr[largestIndex])\n        {\n            if (result ==\
    \ -1)\n            {\n                result = i;\n            }\n           \
    \ if (i == 0)\n            {\n                largestIndex = i;\n            }\n\
    \        }\n        else\n        {\n            largestIndex = i;\n        }\n\
    \    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\nlong largest(int[]\
    \ array){\n    if (array == null || array.length == 0)\n        return -1;\n \
    \   int largest = array[0];\n    for(int i = 1; i < array.length; i++){\n    \
    \    if(array[i] > largest){\n            largest = array[i];\n        }\n   \
    \ }\n    return largest;\n}\n</code>\n<|/ a tags=algorithm,arrays,java,sorting\
    \ dscore=0 |>\n<| c |>\nWhile this code may answer the question, providing additional\
    \ context regarding why and/or how this code answers the question improves its\
    \ long-term value.\n<|/ c |>\n<| a tags=algorithm,arrays,java,sorting dscore=0\
    \ |>\nThis problem is known as selection algorithm. Here is the pseudocode for\
    \ it:\n<code>\nAlgorithm Selection (A,n,k):\n  1) Pick an element as pivot from\
    \ A[n]\n  2) Make new array of size n-1 and copy the elements to it\n  3) Pick\
    \ min element from new array\n  4) Move the pivot element to that position\n \
    \ 5) Go to step 3 until k-1 elements are moved and kth element is the pivot\n\
    </code>\n<|/ a |>\n<| c |>\nThe pseudocode is not valid Java - it will not compile.\
    \ Please correct it.\n<|/ c |>\n<| c |>\nI think this can be done in O(n) time\
    \ and O(1) space. This is a selection algorithm and I think this can be done in\
    \ O(n) time with O(n) extra space. Correct me if I'm wrong.\n<|/ c |>\n<| c |>\n\
    Yes, this can be done in O(n) time with O(n) extra space - this is called a QuickSelect\
    \ algorithm. See Wikipedia for details and pseudocode.\n<|/ c |>\n<| a dscore=0\
    \ |>\nJava Implementation for Selection Algorithm and Best case in O(n log n)\n\
    <code>\nimport java.util.Scanner;\nclass selection_algorithm\n{\n    private static\
    \ int n;\n    private static int[] arr;\n    private static int[] selection_arr;",
  "{\n    long largest = Long.MIN_VALUE;\n    long idx = 0;\n    for(int i = 0; i\
    \ < arr.length; i++) {\n        if (arr[i] > largest)\n            largest = arr[i];\n\
    \        else if (arr[i] == largest) {\n            idx++;\n        }\n    }\n\
    \    return idx;\n}\n</code>\n<|/ a |>\n<| c |>\nOh, this is very interesting.\
    \ How does that work? Can you please elaborate a little on this?\n<|/ c |>\n<|\
    \ c |>\nThis does work for finding the first index, but how does it return the\
    \ next index? It doesn't make sense to me. Could you please help me understand\
    \ this algorithm?\n<|/ c |>\n<| c |>\nThe algorithm returns the next index if\
    \ it is greater than the current largest.  The largest index will be one greater\
    \ than the current largest.  This algorithm is designed to find the first non-matching\
    \ element.  If your array contains several non-matching elements, this will return\
    \ the index of the first element that does not match.\n<|/ c |>\n<| c |>\nThanks\
    \ for your help with this.\n<|/ c |>\n<| a tags=sorting,algorithm,arrays |>\n\
    Here is my solution in C#\n<code>\nusing System;\nusing System.Collections.Generic;\n\
    using System.Linq;", "{\n    long ans = -1;\n    \n    foreach(int i, arr)\n \
    \   {\n        if(i <= ans)\n        {\n            ans = i;\n        }\n    }\n\
    \    \n    return ans;\n}", "{\n    long max = -1L;\n    long currentIndex = arr.length\
    \ - 1L;", "{\n    // write your code in C# 6.0 with .NET 4.5 (Mono)\n    int currentIdx\
    \ = arr.Length - 1;\n    for (int i = 0; i <= arr.Length; i++)\n    {\n      \
    \  if (arr[i] >= arr[currentIdx])\n        {\n            currentIdx--;\n    \
    \    }\n        else\n        {\n            return i;\n        }\n    }\n   \
    \ return -1;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nCan you explain the logic\
    \ behind this? What does it do? And why would you want to do this?\n<|/ c |>\n\
    <| c |>\nI've added a comment in the code. It's quite simple though.\n<|/ c |>\n\
    <| c |>\n: Thanks. Just what I was looking for.\n<|/ c |>\n<| a tags=c#,algorithm\
    \ |>\nI thought of doing this in JavaScript but i got confused after I realized\
    \ that there is a simple logic to do this.\n<code>\nfunction arrange(arr){\nvar\
    \ a = [];\nvar maxVal = arr.length-1;", "{\n\tlong result = 0;\n\tfor (int i =\
    \ 0; i < arr.length-1; i++) \n\t{\n\t\tif (arr[i] > arr[i+1]) \n\t\t{\n\t\t\t\
    result = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (result > -1) \n\t{\n\t\treturn result;\n\
    \t}\n\telse \n\t{\n\t\treturn -1L;\n\t}\n}", "{\n\t// Complete the implementation\
    \ here\n\tlong max = arr[0];\n\tfor (long i = 1; i < arr.length; ++i) {\n\t\t\
    if (arr[i] > max) {\n\t\t\tmax = arr[i];\n\t\t}\n\t}\n\treturn max;\n}", "{\n\t\
    long index = std.array.max(arr);\n\tfor (int i = 0; i < arr.length - 1; i++) {\n\
    \t\tif (arr[i] >= arr[i + 1]) {\n\t\t\tindex = -1;\n\t\t}\n\t}\n\treturn index;\n\
    }\n/*\nCreate a function which returns the smallest index of an element which\n\
    \    is not less than or equal to the element immediately preceding it. If\n \
    \   no such element exists then return -1. The given array will not contain\n\
    \    duplicate values.", "{\n    long max = arr[0];\n    for (int i = 1; i < arr.size();\
    \ ++i)\n        if (max < arr[i])\n            max = arr[i];\n    for (int i =\
    \ 1; i < arr.size(); ++i)\n        if (max >= arr[i])\n            return max;\n\
    \    return -1;\n}", "{\n    long max = std.math.max(arr[1..$]);\n    for(int\
    \ i = 1; (i < $) ; i++) {\n        if(arr[i] <= max) \n            max = arr[i];\n\
    \    }\n    return max;\n}\n</cell>\n<cell>\n%kata T138_Number_of_Non_increasing_Arrangements_I",
  "{\n    long largest = Long.MAX_VALUE;\n    for(int i = 0; i < arr.length; i++){\n\
    \        if (arr[i] < arr[largest]){\n            largest = i;\n        }\n  \
    \  }\n    return largest;\n}\n</code>\nThe second one uses generics:\n<code>\n\
    import std.math;\nimport std.array;", "{\n    long maxIndex = -1;\n    long minIndex\
    \ = -1;\n    for(int i = 1; i < arr.length; i++) {\n        if(arr[i] > arr[i-1])\
    \ {\n            maxIndex = i;\n            break;\n        }\n    }\n    for(int\
    \ i = arr.length-1; i >= 0; i--) {\n        if(arr[i] > arr[maxIndex]) {\n   \
    \         minIndex = i;\n            break;\n        }\n    }\n    return maxIndex;\n\
    }", "{\n    int i, j, maxVal, minVal;\n    long maxValIndex;\n    \n    for(i\
    \ = 0; i < arr.length; i++)\n    {\n        for(j = i + 1; j < arr.length; j++)\n\
    \        {\n            if(arr[i] <= arr[j])\n                break;\n       \
    \ }\n        \n        if(j == arr.length)\n        {\n            return i;\n\
    \        }\n    }\n    \n    return -1;\n}\n</code>\n<|/ a dscore=0 tags=sorting,arrays,java\
    \ |>\n<| a |>\nIn case you have a lot of elements and a lot of duplicates, you\
    \ can use the following approach.\n<code>\nlong maxIndexOfElement(long[] array,\
    \ long element) \n{\n    long result = -1;\n    int indexOfElement = -1;", "{\n\
    \    long res = -1;\n    for(long i=0; i<arr.length; i++) {\n        if(arr[i]<arr[i-1])\n\
    \            res = i;\n    }\n    return res;\n}\n</code>\n<|/ a dscore=1 |>\n\
    <| c |>\nThis looks great.  But I'm having trouble understanding the return statement\
    \ at the end.  Can you please explain it a little bit?\n<|/ c |>\n<| c |>\nThe\
    \ return statement at the end return the index of the last element which is not\
    \ greater than its predecessor, -1 in this case. If the array is empty the function\
    \ returns -1.\n<|/ c |>\n<| c |>\nThat is awesome!  I'm going to be using this\
    \ on a problem that's asking to sort an array of N elements with the constraints\
    \ 0 <= N <= 10^6, and I hope that it's fast!\n<|/ c |>\n<| c |>\nNice work, just\
    \ for me to understand: can you explain why you use the `res` variable and why\
    \ you set it to `-1`?\n<|/ c |>\n<| c |>\nThe reason for using -1 is that this\
    \ is the value of the first element not greater than its predecessor (i.e. the\
    \ first element will be placed at the end of our sorted list). If the array is\
    \ empty the function will return -1.\n<|/ c |>\n<| a tags=c++,sorting,arrays,algorithm\
    \ |>\n<code>\n#include <iostream>\n#include <algorithm>\nusing namespace std;",
  "{\n    long iMax = 0;\n    for(int i = 0; i < arr.length; i++){\n        if(arr[i]\
    \ >= arr[iMax]){\n            iMax = i;\n        }\n    }\n    return iMax;\n\
    }\n</code>\n<|/ a tags=arrays,java |>\n<| c |>\nThank you for such an elaborate\
    \ solution. I am new to Java and trying to learn things.\n<|/ c |>\n<| c |>\n\
    I added a version that does not use recursion but uses a loop. Hope this helps.\n\
    <|/ c |>\n<| c |>\nThank you for adding such a comprehensive solution. I was able\
    \ to learn a lot from your code. I will take time to study it carefully.\n<|/\
    \ c |>\n<| c |>\nThanks. If the solution helped feel free to upvote or mark the\
    \ solution as accepted.\n<|/ c |>\n<| c |>\nI upvoted but StackOverflow won't\
    \ let me since I have less than 15 reputation. I am still learning. Thanks for\
    \ the help though!\n<|/ c |>\n<| a tags=arrays,java |>\nHere is how I would do\
    \ it:\n<code>\npackage com.company;", "{\n    long maxIndex = 0;\n    long maxValue\
    \ = arr[0];\n    for(int i = 1; i < arr.length; ++i)\n    {\n        if(arr[i]\
    \ <= maxValue)\n            maxIndex = i;\n        else if(arr[i] > maxValue)\n\
    \        {\n            maxValue = arr[i];\n            maxIndex = i;\n      \
    \  }\n    }\n    return maxIndex;\n}\n\"\"\"", "{\n    if(arr.length == 0)\n \
    \       return -1L;", "{\n    long prevMin = arr[0];\n    long ans = -1;\n   \
    \ for(long i = 1; i < arr.length; i++) {\n        if(arr[i] < prevMin)\n     \
    \       return -1;\n        if(arr[i] >= prevMin) {\n            ans = i;\n  \
    \          prevMin = arr[i];\n        }\n    }\n    return ans;\n}\n</code>\n\
    <|/ a dscore=2 tags=c++,c,algorithm,sorting |>\n<| c |>\nI didn't downvote, but\
    \ this doesn't work if the first element is less than the greatest element in\
    \ the array; this gives -1 instead of 0.\n<|/ c |>\n<| c |>\nYeah, I was going\
    \ to delete my answer, but it's pretty much the same as this one.\n<|/ c |>\n\
    <| c |>\nThanks, I've edited the answer to handle that case.\n<|/ c |>\n<| a dscore=2\
    \ tags=c++,c,algorithm,sorting |>\n<code>\npublic static int canArrange(int[]\
    \ arr) {\n   int max = Integer.MIN_VALUE;\n   int res = -1;\n   for (int i = 0;\
    \ i < arr.length; i++) {\n       int curr = arr[i];\n       for (int j = 0; j\
    \ < i; j++) {\n           if (arr[j] >= curr) {\n               if (curr > max)\n\
    \                   max = curr;\n               res = j;\n               break;\n\
    \           }\n       }\n   }\n   return res;\n}\n</code>\n<|/ a |>\n<| a tags=c++,c,algorithm,sorting\
    \ |>\nOne more approach could be to use min-heap data structure and perform following\
    \ operations using it.\n<code>\nif(arr[0] < heap.Pop())\n  System.out.println(\"\
    -1\");\nelse\n  System.out.println(heap.Pop());\n</code>\nand if heap.Pop() returns\
    \ -1 that means there is no such element which is greater than arr[0]. Here heap\
    \ is a min-heap data structure of type int.\n<|/ a dscore=1 |>\n<| a tags=c++,c,algorithm,sorting\
    \ dscore=1 |>\nMy C++ implementation:\n<code>", "{\n\tlong min = std.min(arr);\n\
    \tlong max = std.max(arr);\n\t\n\tlong result = -1;", "{\n    long res = -1;\n\
    \    \n    for(int i = 0; i < arr.length; ++i)\n    {\n        if(res == -1 ||\
    \ arr[i] <= arr[res])\n        {\n            res = i;\n        }\n    }", "{\n\
    \    // write your code in C# here\n    long largestIndex = -1;\n    long currentIndex\
    \ = 0;\n    long max = arr[0];\n    bool isInside = false;\n    \n    for (int\
    \ i = 0; i < arr.Length; i++) \n    {\n        if (arr[i] > max) \n        {\n\
    \            max = arr[i];\n            currentIndex = i;\n        }\n       \
    \ else if (arr[i] == max)\n        {\n            isInside = true;\n        }\n\
    \        else if (arr[i] == arr[i-1] && i != currentIndex)\n        {\n      \
    \      largestIndex = currentIndex;\n            max = arr[i-1];\n        }\n\
    \    }\n    \n    if(!isInside)\n    {\n        largestIndex = -1;\n    }\n  \
    \  return largestIndex;\n}\n</code>\nThe above code is tested and works.\nYou\
    \ can test it here: https://dotnetfiddle.net/IUJ7L8\n<|/ a dscore=0 tags=algorithm,c#\
    \ |>\n<| c |>\nThe code doesn't compile when `i` is greater than `arr.Length`.\n\
    <|/ c |>\n<| c |>\nyes, I made a mistake when testing it. Corrected. It should\
    \ work now.\n<|/ c |>\n<| c |>\nI'm sorry, but your code is still incorrect. See\
    \ the updated answer.\n<|/ c |>\n<| c |>\nIt will compile now.\n<|/ c |>\n<| c\
    \ |>\nYour code has a bug that doesn't allow to reach the end of the array without\
    \ throwing an exception. The correct solution will throw an exception when the\
    \ last element is in the array.\n<|/ c |>\n<| a tags=algorithm,c# |>\n<code>\n\
    \    public int FindLargest(int[] numbers)\n    {\n        int largest = numbers[0];\n\
    \        int index = numbers.Length;", "{\n\tlong[] a = new long[arr.length];\n\
    \tint i0 = 0; \n\tint i1 = arr.length-1;\n\tint max = -1;\n\twhile(true) {\n\t\
    \tif(i0 >= i1) {\n\t\t\treturn max;\n\t\t}\n\t\tif(a[i0] <= arr[i1]) {\n\t\t\t\
    max = max == -1 ? i0 : max;\n\t\t\ti0++;\n\t\t}\n\t\telse {\n\t\t\tmax = max ==\
    \ -1 ? i1 : max;\n\t\t\ti1--;\n\t\t}\n\t}\n}", "{\n    long min = arr[0], max\
    \ = arr[0];\n    for (long i = 1; i < arr.length; ++i) {\n        if (arr[i] >\
    \ max) {\n            max = arr[i];\n        } else if (arr[i] < min) {\n    \
    \        min = arr[i];\n        }\n    }\n    \n    return -1L if min == max;\n\
    }\n/**\n * A function that returns the largest index of an element which\n   \
    \ is not greater than or equal to the element immediately preceding it. If\n \
    \   no such element exists then return -1. The given array will not contain\n\
    \    duplicate values.\n */\nlong can_arrange(long[] arr, int start, int end)\
    \ \n{\n    long min = arr[0], max = arr[0];\n    for (long i = start; i < end;\
    \ ++i) {\n        if (arr[i] > max) {\n            max = arr[i];\n        } else\
    \ if (arr[i] < min) {\n            min = arr[i];\n        }\n    }\n    \n   \
    \ return -1L if min == max;\n}\n/**\n * A function that returns the largest index\
    \ of an element which\n    is not greater than or equal to the element immediately\
    \ preceding it. If\n    no such element exists then return -1. The given array\
    \ will not contain\n    duplicate values.\n */\nlong can_arrange(long[] arr, int\
    \ start, int end, long pivot) \n{\n    long min = arr[0], max = arr[0];\n    for\
    \ (long i = start; i < end; ++i) {\n        if (arr[i] > max) {\n            max\
    \ = arr[i];\n        } else if (arr[i] < min) {\n            min = arr[i];\n \
    \       }\n    }\n    \n    return -1L if min == max;\n}", "{\n    if (arr.length\
    \ == 0) return -1;\n    long min = arr[0];\n    long maxIndex = arr.length - 1;\n\
    \    for (int i = 1; i < arr.length; i++) \n    {\n        if (arr[i] < min) min\
    \ = arr[i];\n        else if (arr[i] > arr[maxIndex]) maxIndex = i;\n    }\n \
    \   return maxIndex;\n}\n</code>\n<|/ a tags=c,c++,algorithm |>\n<| c |>\nOh wow,\
    \ you beat me to the punch on that one. You really ought to compare the performance\
    \ of the two approaches. Also you should mention that this won't work with negative\
    \ numbers as well. :)\n<|/ c |>\n<| c |>\nI knew there had to be a quicker way\
    \ to do this using modulus and division.  I've added my own version of this method.\n\
    <|/ c |>\n<| c |>\nI don't think it will work with negative numbers either, unless\
    \ you add one more check to the algorithm. :)\n<|/ c |>\n<| c |>\nYes, I assumed\
    \ that he could make the check as he wanted it to work. :)\n<|/ c |>\n<| c |>\n\
    Actually, I think the way you have it won't work for negative numbers. Try it\
    \ out. :)\n<|/ c |>\n<| a tags=c,c++,algorithm |>\nYou could probably use std::max_element()\
    \ to find out the max element in a range of elements.\n<|/ a dscore=0 |>\n<| c\
    \ |>\nThe problem is I don't have a range of elements.  I can only know the position\
    \ of the maximum element.\n<|/ c |>\n<| c |>\nWhat does \"I can't have a range\
    \ of elements\" mean? You have a sequence of elements. I assume you have the position\
    \ of each element in the array?\n<|/ c |>\n<| c |>\nNo, I only have a position.\
    \  I can find the maximum element in the array, but I can't find the position\
    \ of that element.\n<|/ c |>\n<| c |>\nWell if that is really the case then I\
    \ suggest you just try an [std::map](http://www.cplusplus.com/reference/stl/map/)\
    \ instead of an array.\n<|/ c |>\n<| c |>\nHow is that better than a dynamic array?\n\
    <|/ c |>\n<| a tags=c,c++,algorithm |>\nYou can use a binary search on the array,\
    \ using array.length as your mid-point of the search. This will give you the location\
    \ where your element is greater than the one immediately before; you then have\
    \ your position in that array.\n<|/ a dscore=0 |>\n<| a tags=c,c++,algorithm dscore=0\
    \ |>\nYou can use a ", "{\n    if(arr.length == 0)\n        return -1;\n    int\
    \ max = arr[0];\n    int minIndex = arr.length - 1;\n    for(int i = 1; i < arr.length;\
    \ ++i)\n    {\n        if(arr[i] > max)\n            max = arr[i];\n        if(arr[i]\
    \ < min)\n        {\n            minIndex = i;\n            min = arr[i];\n  \
    \      }\n    }\n    return minIndex;\n}\n</code>\n<|/ a |>\n<| a tags=java |>\n\
    <code>\n// return -1 if array is empty\npublic static int canArrange(int[] arr)\
    \ {\n    int n = arr.length;\n    if(n==0) return -1;\n    int min = arr[0];\n\
    \    int max = arr[0];\n    for(int i = 1; i<n; i++){\n        if(max<arr[i]){\n\
    \            max = arr[i];\n        }\n        if(min>arr[i]){\n            min\
    \ = arr[i];\n        }\n    }\n    if(max<=min) return -1;\n    return min;\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| a tags=java |>\nHere is a version that works\
    \ for empty arrays and zero length arrays:\n<code>\npublic class Arrange\n{\n\
    \    public static int canArrange(int[] arr) {\n        if (arr.length > 0 &&\
    \ arr.length == arr.length) {\n            for (int i = 0; i < arr.length; i++)\
    \ {\n                if (arr[i] > arr[i - 1])\n                    return i;\n\
    \            }\n        }\n        return -1;\n    }", "{\n    if (arr.length\
    \ == 0) return -1L;\n    int n = arr.length;\n    long max = 0;\n    int first\
    \ = 0;\n    int last = n;", "{\n\tlong result = 0;\n\tfor (long i = 1; i < arr.length;\
    \ i++) {\n\t\tif (arr[i] >= arr[i-1]) continue;\n\t\t\n\t\tif (result < i) {\n\
    \t\t\tresult = i;\n\t\t}\n\t}\n\t\n\treturn result;\n}\n/*\nCreate a function\
    \ which returns the smallest index of an element which\n    is not less than or\
    \ equal to the element immediately preceding it. If\n    no such element exists\
    \ then return -1. The given array will not contain\n    duplicate values.", "{\n\
    \    long max = arr[0];\n    for (int i = 1; i < arr.length; i++) {\n        if\
    \ (arr[i] <= max)\n            max = Math.max(arr[i], max);\n        else\n  \
    \          return -1L;\n    }\n    return max;\n}\n</code>\n<|/ a tags=algorithm,c#,arrays\
    \ |>\n<| c |>\nThis is not optimal for unordered lists. Can you provide an example\
    \ with ordered lists?\n<|/ c |>\n<| c |>\nI think I wrote that in the comments.\
    \ My apologies.\n<|/ c |>\n<| a dscore=0 |>\nA simple solution without sorting:\n\
    <code>\npublic long FindIndexLargestUngreaterThan(IEnumerable<long> values)\n\
    {\n    long largestIndex = 0;\n    long largestValue = default(ulong);", "{\n\
    \    int first = 0;\n    int last = -1;\n    for (long i = 1; (i < arr.Length)\
    \ && (arr[i] > arr[i-1]); i++) {\n        first = i;\n    }\n    for (long i =\
    \ arr.Length - 1; i > 0; i--) {\n        if (arr[i] <= arr[first]) {\n       \
    \     last = i;\n            break;\n        }\n    }\n    return last;\n}", "{\n\
    \tif (arr.length < 2L) return -1L;", "{\n\tlong maxIndex = -1;\n\tfor (int i =\
    \ 0; i < arr.length; i++)\n\t{\n\t\tlong curIndex = 0;\n\t\twhile (curIndex <\
    \ i)\n\t\t{\n\t\t\tcurIndex++;\n\t\t\tif (std.math.isGreaterOrEqual(arr[curIndex],\
    \ arr[i - curIndex]))\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (maxIndex\
    \ == -1)\n\t\t{\n\t\t\tmaxIndex = i - curIndex - 1;\n\t\t}\n\t\telse\n\t\t{\n\t\
    \t\tif (std.math.isGreaterOrEqual(arr[curIndex], arr[maxIndex]))\n\t\t\t{\n\t\t\
    \t\tmaxIndex = i - curIndex - 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn maxIndex;\n}",
  "{\n    long maxIndex = 0;\n    long i = 0;\n    long count = 1;\n    while (i <=\
    \ arr.length-1) {\n        if (arr[i] <= arr[i+1]) {\n            count++;\n \
    \       } else {\n            maxIndex = arr[i];\n            i = i + 2;\n   \
    \         count = 1;\n        }\n        i++;\n    }\n    return maxIndex;\n}",
  "{\n\tlong ans = -1L;\n\tint i;\n\tfor (i = 1; i < arr.length; ++i) \n\t{\n\t\t\
    if (arr[i] >= arr[i-1]) \n\t\t{\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\
    return ans;\n}", "{\n\tlong left=-1;\n\tlong right=-1;\n\tlong leftMax=arr[0];\n\
    \tlong rightMax=arr[arr.length-1];\n\tfor (int i=1; i<arr.length; i++)\n\t{\n\t\
    \tif (arr[i-1]>rightMax)\n\t\t{\n\t\t\trightMax=arr[i-1];\n\t\t\tright=i;\n\t\t\
    }\n\t\telse if (arr[i]>leftMax)\n\t\t{\n\t\t\tleftMax=arr[i];\n\t\t\tleft=i;\n\
    \t\t}\n\t}\n\treturn (left>right?left:right);\n}\n/*\nCreate a function which\
    \ returns the largest index of an element which\n    is not greater than or equal\
    \ to the element immediately preceding it. If\n    no such element exists then\
    \ return -1. The given array will not contain\n    duplicate values."]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
