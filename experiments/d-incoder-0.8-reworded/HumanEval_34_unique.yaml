name: HumanEval_34_unique
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique elements\
  \ in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
  \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n"
tests: "unittest\n{\n    alias candidate = unique;\n\n    assert(candidate([5L, 3L,\
  \ 5L, 2L, 3L, 3L, 9L, 0L, 123L]) == [0L, 2L, 3L, 5L, 9L, 123L]);\n}\nvoid main(){}"
completions: ["{\n    int result = 0;\n    long x = 0;\n    long y = 0;\n    \n  \
    \  for (int i = 0; i < l.length; i++){\n        x = l[i];\n        if (result\
    \ == 0){\n            y = x;\n            result = 1;\n        }\n        else\
    \ if (x == y){\n            result++;\n        }\n    }\n    \n    long[] tmp\
    \ = new long[result];\n    int k = 0;\n    \n    for (int i = 0; i < l.length;\
    \ i++){\n        x = l[i];\n        if (result == 0){\n            y = x;\n  \
    \      }\n        else if (x == y){\n            tmp[k] = x;\n            k++;\n\
    \            result++;\n        }\n    }\n    \n    return tmp;\n}\n</code>\n\
    <|/ a |>\n<| c |>\nIt would be great if you can add comments to explain the code\
    \ snippet you gave.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "{\n    long[] r = unique(l,0,l.length-1);\n\
    \    return r;\n}\n/*\n Return sorted unique elements in an array, between start\
    \ and stop\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L], 0, 3)\n   \
    \ [0L, 2L, 3L, 5L, 9L, 123L]\n*/\nlong[] unique(long[] l, int start, int stop)\n\
    {\n    int i,j,m,n = stop-start;\n    long[] r  = new long[(n>0 ? n : 1)];\n \
    \   long[] h = new long[10000];\n    \n    m=findIndex(h,l);\n    \n    for(i=0;i<m;i++)\
    \ {\n        h[l.charCodeAt(i)-'a']++;\n    }\n    \n    for(i=m+1;i<n;i++) {\n\
    \        h[l.charCodeAt(i)-'a']--;\n    }\n    \n    for(i=start,j=0;j<n;i++,j++)\
    \ {\n        r[j]=h[l.charCodeAt(i)-'a'];\n    }\n    \n    return r;\n}\n/*\n\
    \ Return unique elements in an array\n \n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    [5L, 3L, 2L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l)\
    \ \n{\n    return unique(l, 0, l.length-1);\n}\n/*\n Return unique elements in\
    \ an array, between start and stop\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L], 0, 3)\n    [5L, 2L, 9L, 123L]\n*/\nlong[] unique(long[] l, int start,\
    \ int stop)\n{\n    int i,j,m,n = stop-start;\n    long[] r  = new long[(n>0 ?\
    \ n : 1)];\n    long[] h = new long[10000];\n    \n    m=findIndex(h,l);\n   \
    \ \n    for(i=0;i<m;i++) {\n        h[l.charCodeAt(i)-'a']++;\n    }\n    \n \
    \   for(i=m+1;i<n;i++) {\n        h[l.charCodeAt(i)-'a']--;\n    }\n    \n   \
    \ for(i=start,j=0;j<n;i++,j++) {\n        r[j]=h[l.charCodeAt(i)-'a'];\n    }\n\
    \    \n    return r;\n}\n/*\n Return unique elements in an array\n \n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [", "{\n    long[] unique = new long[l.length];",
  "{\n    long[] r = {0L};\n    int c = 1;\n    for(int i=1; i<l.length; i++) {\n\
    \        if(l[i] != l[i-1]) {\n            r[c] = l[i];\n            c++;\n  \
    \      }\n    }\n    return r;\n}", "{\n    int u;\n    bool found = false;\n\
    \    int[] id = new int[l.length];\n    long last = l[0];\n    id[0] = l[0];\n\
    \    for (u = 1; u < l.length; ++u) \n    {\n        if (l[u] == last) \n    \
    \    {\n            found = true;\n            while (id[u] != l[u]) \n      \
    \      {\n                id[u] = id[id[u - 1]];\n            }\n        } \n\
    \        else \n        {\n            id[u] = l[u];\n        }\n        last\
    \ = l[u];\n    }\n    if (!found) \n    {\n        // remove unique element at\
    \ front of array\n        id[id.length - 1] = l[0];\n    }\n    else \n    {\n\
    \        // remove unique element at end of array\n        for (u = 1; u < id.length\
    \ - 1; ++u) \n        {\n            id[u] = id[id[u + 1]];\n        }\n    }\n\
    \    // return sorted array\n    return id.toLongArray();\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\n+1 for the link to Jon Skeet's article about the sort of things\
    \ that you can do with the library I linked to above.\n<|/ c |>\n<| c |>\nWhat\
    \ is the point of `id.length` and the `id[u + 1]` when you're doing a binary search\
    \ on `id`? And how about `id.length - 1` and `id[u]`?\n<|/ c |>\n<| c |>\nIt is\
    \ a binary search on the sorted id array.\n<|/ c |>\n<| c |>\n, what about `id[u]`\
    \ and `id[u + 1]`? They are both accessing the last element in the array. Can\
    \ you explain why you did these operations?\n<|/ c |>\n<| c |>\nWhy would you\
    \ do this? To keep track of the index. And to use in the search loop.\n<|/ c |>\n\
    <| a dscore=5 tags=java,sorting,unique,arrays |>\nJust a little enhancement to\
    \ what Jon Skeet had posted:\n<code>\npublic static int[] unique(int[] unq) {\n\
    \    Arrays.sort(unq);\n    int size = unq.length;\n    int[] ret = new int[size];\n\
    \    int j = 0;\n    for (int i = 0; i < size; i++) {\n        if (i == 0 || unq[i]\
    \ != unq[i - 1]) {\n            ret[j] = unq[i];\n            j++;\n        }\n\
    \    }\n    return ret;\n}\n</code>\n<|/ a |>\n<| a |>\n<code>\nimport java.util.ArrayList;\n\
    import java.util.Arrays;", "{\n    Arrays.sort(l);\n    int n = l.length;\n  \
    \  long[] ret = new long[n];\n    for (int i = 0; i < n; ++i) {\n        ret[i]\
    \ = l[i];\n    }\n    return ret;\n}", "{\n\tvar results = new long[l.length];\n\
    \tArrays.sort(l);\n\tfor (int i = 1; i < l.length; i++) \n\t{\n\t\tif (l[i] ==\
    \ l[i - 1]) \n\t\t\tresults[i] = results[i - 1];\n\t\telse\n\t\t\tresults[i] =\
    \ l[i];\n\t}\n\treturn results;\n}", "{\n\tvar f = new long[l.length];\n\tvar\
    \ g = new long[l.length];\n\tvar h = new long[l.length];\n\t\n\tlong[] ret = new\
    \ long[l.length];\n\tlong[] l1 = new long[l.length];\n\t\n\tvar i = 0; var j =\
    \ 0; var k = 0; var l1 = new long[l.length];\n\tvar len = 0;\n\t\n\t\n\twhile\
    \ (i < l.length && l[i] != null)\n\t{\n\t\tif (f[(int)l[i]] == null)\n\t\t{\n\t\
    \t\tf[(int)l[i]] = true;\n\t\t\tl1[j++] = l[i];\n\t\t\tlen++;\n\t\t}\n\t\ti++;\n\
    \t}\n\t\n\ti = j;\n\t\n\twhile (i < l.length && l1[j] != null)\n\t{\n\t\tif (l[i]\
    \ == l1[(int)l1[j]])\n\t\t{\n\t\t\tk++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret[k++]\
    \ = l1[j++];\n\t\t\tf[l1[j]] = false;\n\t\t\tl1[j++] = l[i];\n\t\t\tlen++;\n\t\
    \t}\n\t\ti++;\n\t}\n\t\n\ti = j;\n\t\n\twhile (i < l.length)\n\t{\n\t\tret[k++]\
    \ = l[i];\n\t\ti++;\n\t}\n\t\n\twhile (h.length > 0)\n\t{\n\t\tk = 0;\n\t\t\n\t\
    \twhile (k < ret.length)\n\t\t{\n\t\t\tk = ret[k];\n\t\t}\n\t\t\n\t\tret[k++]\
    \ = h.pop();\n\t}\n\t\n\treturn ret;\n}\n/*\nReturn sorted unique elements in\
    \ an array\n\t\n\t\n*/\nlong[] unique(long[] l, int l1) \n{\n\tvar f = new long[l1];\n\
    \tvar g = new long[l1];\n\tvar h = new long[l1];\n\t\n\tlong[] ret = new long[l1];\n\
    \tlong[] l1 = new long[l1];\n\t\n\tvar i = 0; var j = 0; var k = 0; var l1 = new\
    \ long[l1];\n\tvar len = 0;\n\t\n\t\n\twhile (i < l1 && l[i] != null)\n\t{\n\t\
    \tif (f[(int)l[i]] == null)\n\t\t{\n\t\t\tf[(int)l[i]] = true;\n\t\t\tl1[j++]\
    \ = l[i];\n\t\t\tlen++;\n\t\t}\n\t\ti++;\n\t}\n\t\n\ti = j;\n\t\n\twhile (i <\
    \ l1 && l1[j] != null)\n\t{\n\t\tif (l[i] == l1[(int)l1[j]])\n\t\t{\n\t\t\tk++;\n\
    \t\t}\n\t\telse\n\t\t{\n\t\t\tret[k++] = l1[j++];\n\t\t\tf[l1[j]] = false;\n\t\
    \t\tl1[j++] = l[i];\n\t\t\tlen++;", "{\n\tlong[] r = new long[l.length];\n\tfor\
    \ (int i = 0; i < l.length; ++i) {\n\t\tfor (int j = i + 1; j < l.length; ++j)\
    \ {\n\t\t\tif (l[i] < l[j]) break;\n\t\t}\n\t\tr[i] = l[i];\n\t}\n\tfor (int i\
    \ = l.length - 1; i >= 0; --i) {\n\t\tfor (int j = i + 1; j < l.length; ++j) {\n\
    \t\t\tif (r[i] < r[j]) break;\n\t\t}\n\t\tswap(r,i,j);\n\t}\n\treturn r;\n}",
  "{\n  var l2 = l.copy();\n  std.sort(l2, l.length());\n  long[] u = new long[std.min(l.length(),\
    \ 10)];\n  std.unique(l2, u, 0, u.length, l.length());\n  return u;\n}", "{\n\t\
    // Your code here\n\t\n\tlong[] a = new long[l.getLength()+1];\n\tfor(int i =\
    \ 0; i < l.getLength(); i++)\n\t\ta[i+1] = l[i];\n\tfor(int i = 0; i < a.getLength();\
    \ i++)\n\t{\n\t\tfor(int j = i+1; j < a.getLength(); j++)\n\t\t{\n\t\t\tlong l\
    \ = a[i];\n\t\t\tlong r = a[j];\n\t\t\tif(r != l && l != 0)\n\t\t\t\tbreak;\n\t\
    \t}\n\t\tif(j < a.getLength())\n\t\t\tbreak;\n\t}\n\t\n\treturn a;\n}", "{\n \
    \ var ans = new long[l.length];\n  var l1 = l.length;\n  var i = -1, j;\n  while(++i\
    \ < l1)\n    for(j = i + 1; i < l1 && l[i] < l[j]; ++i)\n      ans[j] = l[i];\n\
    \  return ans;\n}\n/*\nCompare two arrays and return the number of different elements\n\
    \    >>> compare([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L], [0L, 2L, 3L, 5L, 9L,\
    \ 123L])\n    1\n    \n    \n*/", "{\n\tlong count = 1;\n\tlong maxCount = 1;\n\
    \tlong[] u = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) {\n\t\t\
    if(l[i] != l[maxCount]) {\n\t\t\tu[count++] = l[i];\n\t\t}\n\t\telse {\n\t\t\t\
    maxCount++;\n\t\t}\n\t}\n\treturn u;\n}", "{\n    int n = l.length, i;\n    long[]\
    \ l1;\n    l1 = new long[n];\n    i = 0;\n    foreach(int j : l)\n        l1[i++]\
    \ = j;\n    l1.sort(std.ascending);\n    return l1;\n}", "{\n\tlong[] n = new\
    \ long[l.length];\n\tint i = 0;\n\tfor (; i < n.length; i++)\n\t{\n\t\tif (l[i]\
    \ > l[i + 1])\n\t\t\tbreak;\n\t\tn[i] = l[i];\n\t}\n\tfor (; i < n.length; i++)\n\
    \t\tn[i] = l[--l.length];\n\treturn n;\n}", "{\n    if(l.length==0)\n        return\
    \ l;\n    \n    long[] a = sort(l);\n    long[] aux = new long[a.length];\n  \
    \  \n    int i=0;\n    for(int j=0; j<a.length; j++)\n    {\n        while(a[i]==a[j])\n\
    \        {\n            i++;\n        }\n        aux[j]=a[i];\n        \n    \
    \    if(i<a.length-1)\n            i++;\n        else\n            break;\n  \
    \  }\n    \n    return aux;\n}", "{\n\tlong[] result = std.Array.toArray(std.Array.toSet(l));\n\
    \treturn result;\n}\n/*\nReturn sorted unique elements in a vector\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(std.vector< long >& l) \n{\n\tlong[] result = std.Array.toArray(std.Array.toSet(l));\n\
    \treturn result;\n}\n/*\nReturn the number of unique elements in a vector\n  \
    \  >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    4\n    \n*/\nsize_t\
    \ uniqueSize(std.vector< long >& l) \n{\n\treturn std.Array.getSize(unique(l));\
    \ \n}\n/*\nReturn number of unique elements in an array\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    4\n    \n*/\nsize_t uniqueSize(long[] l)\
    \ \n{\n\treturn std.Array.getSize(unique(l)); \n}\n/*\nCompare two elements for\
    \ sorting\n    \n*/", "{\n    if(l == null || l.length < 1) return l;\n    \n\
    \    // sort\n    Arrays.sort(l);\n    \n    // find starts\n    int[] starts\
    \ = new int[l.length];\n    for(int i = 1; i < l.length; i++) {\n        starts[l[i]\
    \ - l[i - 1]] = i;\n    }", "{\n    long[] result = new long[l.length];\n    long\
    \ tmp = 0;\n    for (int i = 0; i < l.length; ++i)\n    {\n        int j = 0;\n\
    \        for (; j < i; ++j)\n            if (l[j] == l[i])\n                break;\n\
    \        if (j < i)\n            result[i] = l[j];\n        else\n           \
    \ ++result[i];\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a tags=arrays,java\
    \ |>\nThis can be done in O(n log n) time using an auxiliary sorted list containing\
    \ all the unique elements. I chose to use a linked list for the auxiliary list,\
    \ since the original list size can be assumed to be less than 32K (32K being the\
    \ default array size).\n<code>\npublic static int[] removeDuplicates(int[] nums)\
    \ {\n    int[] aux = new LinkedList<Integer>();\n    boolean isAlreadyInAux =\
    \ false;\n    for (int num : nums) {\n        if (isAlreadyInAux) {\n        \
    \    aux.addLast(num);\n        } else {\n            isAlreadyInAux = true;\n\
    \            aux.addFirst(num);\n        }\n    }\n    // Copy to output array\n\
    \    int[] result = new int[aux.size()];\n    for (int i = 0; i < aux.size();\
    \ i++)\n        result[i] = aux.pollLast();\n    return result;\n}\n</code>\n\
    Time complexity: O(n log n)\n<|/ a dscore=1 |>\n<| c |>\nYou probably meant `O(n*logn)`,\
    \ otherwise it will take O(n^2) time. Also, your code can not be O(1) without\
    \ additional memory (which would be very expensive).\n<|/ c |>\n<| c |>\nIt would\
    \ be O(n log n) if the sorted list were sorted, which is not possible in general.\n\
    <|/ c |>\n<| a dscore=0 |>\nThe best way that I know is to copy the array to a\
    \ new array and then use a simple loop to compare the new array to the original,\
    \ removing duplicates.  This will take O(n^2) time.\n<code>", "{\n    int N =\
    \ l.length;\n    long[] u = new long[N];\n    for (int i = 0; i < N; i++) \n \
    \   {\n        u[i] = l[i];\n    }\n    for (int i = 0; i < N; i++)\n    {\n \
    \       for (int j = i + 1; j < N; j++)\n        {\n            if (u[j] < u[i])\
    \ \n            {\n                long temp = u[i];\n                u[i] = u[j];\n\
    \                u[j] = temp;\n            }\n        }\n    }\n    return u;\n\
    }", "{\n\tlong key = l[0];\n\tlong[] result = new long[l.length];\n\tfor (int\
    \ i=1; i < l.length; ++i)\n\t{\n\t\tif (key < l[i]) \n\t\t\tkey = l[i];\n\t}\n\
    \tfor (int i=1; i < l.length; ++i)\n\t{\n\t\tif (key < l[i])\n\t\t{\n\t\t\tresult[i-1]\
    \ = l[i];\n\t\t\tkey = l[i];\n\t\t}\n\t}\n\tfor (int i=1; i < l.length; ++i)\n\
    \t\tresult[i] = l[i-1];\n\treturn result;\n}\n/*\nReturn a sorted array from elements\
    \ in another array\n\t>>> sort([5, 4, 5, 3])\n\t[3, 4, 5, 5]\n\t\n*/\nlong[] sort(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i=0; i < l.length;\
    \ ++i)\n\t{\n\t\tresult[i] = l[i];\n\t}\n\tArrays.sort(result);\n\treturn result;\n\
    }\n/*\nReturn sum of elements in an array\n    >>> sum([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    55L\n    \n*/\nlong sum(long[] l)\n{\n\tlong s = 0;\n\t\
    for (int i=0; i < l.length; ++i)\n\t{\n\t\ts += l[i];\n\t}\n\treturn s;\n}\n/*\n\
    Return average of elements in an array\n    >>> average([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    5.0\n    \n*/\ndouble average(long[] l)\n{\n\treturn sum(l)\
    \ / l.length;\n}\n/*\nReturn median of elements in an array\n    >>> median([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    5.0\n    \n*/\ndouble median(long[]\
    \ l)\n{\n\tif (l.length%2 != 0)\n\t\treturn median(l);\n\tArrays.sort(l);\n\t\
    int center = l.length/2;\n\treturn (double)l[center-1] + (double)l[center];\n\
    }\n/*\nReturn mode(s) of elements in an array\n    >>> mode([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L])\n    [3, 5]\n    \n*/\nlong[] mode(long[] l)\n{\n\tlong max_count\
    \ = 0L;\n\tlong[] count = new long[l.length];\n\tlong[] mode = new long[l.length];\n\
    \tint pos = 0;\n\tfor (int i=0; i < l.length; ++i)\n\t{\n\t\tcount[i] = l[i];\n\
    \t\tif (count[i] > max_count)\n\t\t{\n\t\t\tmax_count = count[i];\n\t\t\tmode",
  "{\n    long[] result = new long[l.length];\n    int pos = 0;\n    bool hasDuplicate\
    \ = false;\n    for (int i=0; i<l.length; i++)\n    {\n        if (hasDuplicate)\n\
    \        {\n            if (l[i] == result[pos])\n            {\n            \
    \    hasDuplicate = false;\n            }\n        }\n        else\n        {\n\
    \            if (l[i] == 0)\n            {\n                hasDuplicate = true;\n\
    \                result[pos] = l[i];\n            }\n        }\n        if (pos\
    \ == result.length-1)\n        {\n            result[pos] = l[i];\n        }\n\
    \        else\n        {\n            if (hasDuplicate)\n            {\n     \
    \           result[pos] = l[i];\n            }\n            else\n           \
    \ {\n                pos++;\n            }\n        }\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=c#,linq |>\n<| c |>\nThat's a lot of code. Is there a shorter\
    \ way?\n<|/ c |>\n<| c |>\nNo, I think it's OK, there isn't a shorter way. Although\
    \ you can reduce some of it by using `Select` instead of `Where` and use `Contains`\
    \ instead of `==`.\n<|/ c |>\n<| c |>\nOk I reduced it, it still needs some optimizing\
    \ though :). Still not a lot of code. Do you think the `distinct` function can\
    \ be faster?\n<|/ c |>\n<| c |>\nThanks, I've changed it to use Select instead\
    \ of Where, Contains and ==\n<|/ c |>\n<| c |>\nThis code will remove duplicates\
    \ from the list while keeping the order of the list intact. In the question, only\
    \ the non-duplicate elements are kept in the final list.\n<|/ c |>\n<| a tags=c#,linq\
    \ |>\nThis can be done with one line of LINQ code...\n<code>\nvar nonDupsOnly\
    \ = from item in myList\n                   group item by item into g\n      \
    \             select g.First();\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis will\
    \ keep original order of the elements.\n<|/ c |>\n<| c |>\nIt was a question asked\
    \ to me in an interview. I was thinking how could I do it in one line. Thats why\
    \ I posted this question here\n<|/ c |>\n<| c |>\nI guess the interviewer was\
    \ probably expecting something else.\n<|/ c |>\n<| a tags=c#,linq dscore=0 |>\n\
    <code>\npublic static void Main(string[] args)\n{\n    int[] myList = new int[]\
    \ { 0, 5, 3, 4, 2, 7, 1, 9, 2, 5, 3, 6, ", "{\n  int n = l.length;\n  long[] result\
    \ = new long[n];\n  int j = 0;\n  for(int i = 0; i < n; ++i) {\n    if(j == 0\
    \ || l[i] == result[n - 1]) \n      result[j++] = l[i]; \n    else\n      while(j\
    \ < n && l[i] < result[j]) \n        result[j++] = result[j - 1];\n  }\n  return\
    \ result;\n}", "{\n        List<long> u = new List<long>()\n        for (long\
    \ element : l) {\n            if (!u.contains(element)) {\n                u.add(element);\n\
    \            }\n        }\n        return u.toArray();\n}\n/*\nReturn sorted unique\
    \ elements in a vector\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(vector<long> v) \n{\n\
    \        List<long> u = new List<long>()\n        for (long element : v) {\n \
    \           if (!u.contains(element)) {\n                u.add(element);\n   \
    \         }\n        }\n        return u.toArray();\n}\n/*\nReturn sorted unique\
    \ elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long* l) \n{\n      \
    \  List<long> u = new List<long>()\n        for (long element : l) {\n       \
    \     if (!u.contains(element)) {\n                u.add(element);\n         \
    \   }\n        }\n        return u.toArray();\n}\n/*\nReturn sorted unique elements\
    \ in a vector\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(vector<long> v) \n{\n       \
    \ List<long> u = new List<long>()\n        for (long element : v) {\n        \
    \    if (!u.contains(element)) {\n                u.add(element);\n          \
    \  }\n        }\n        return u.toArray();\n}\n/*\nReturn sorted unique elements\
    \ in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long** l) \n{\n        List<long>\
    \ u = new List<long>()\n        for (long element : *l) {\n            if (!u.contains(element))\
    \ {\n                u.add(element);\n            }\n        }\n        return\
    \ u.toArray();\n}\n/*\nReturn sorted unique elements in a vector\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(vector<long>* v) \n{\n", "{\n\tvar x = new HashSet[long]();\n\t\
    foreach(i, l) \n\t\tif(!x.add(i))\n\t\t\tyield i;\n}", "{\n\tlong[] r; \n\tsort(l);\n\
    \tr= new long[l.length];\n\tint i;\n\tint j;\n\tfor (i=0,j=0; i< l.length; i++,j++)\
    \ \n\t{\n\t\tif(i==j)\n\t\t{\n\t\t\tr[j]=l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\
    if((l[i]!=l[j])&(l[i]!=long.MAX_VALUE))\n\t\t\t{\n\t\t\t\tr[j]=l[i];\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn r;\n}", "{\n    long[] u = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++) \n    {\n        long v = l[i];\n        u[v] = i;\n\
    \    }\n    Arrays.sort(u);\n    return u;\n}\n</code>\n<|/ a dscore=1 tags=algorithm,unique,arrays,java,sorting\
    \ |>\n<| c |>\nThis was very helpful.\n<|/ c |>\n<| c |>\nWhat is the complexity\
    \ of this algorithm?\n<|/ c |>\n<| a dscore=1 |>\nThe best answer is using HashSet.\
    \ \n<code>\npublic static void main(String[] args) {", "{\n\tif (l == null) return\
    \ null;\n\tlong[] a = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\
    \ {\n\t\tlong val = l[i];\n\t\tfor (int j = i + 1; j < l.length; j++) {\n\t\t\t\
    if (l[j] == val)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j - i > 1) {\n\t\t\tArrays.sort(a);\n\
    \t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\ta[i - k - 1] = a[k];\n\t\t\t}\n\t\
    \t}\n\t\ta[i] = val;\n\t}\n\treturn a;\n}", "{\n    bool isDuplicated = false;\n\
    \    long current = 0;\n    long next = 1;\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        current = l[i];\n    \
    \    isDuplicated = false;\n        for(int j = 0; j < result.length; j++) \n\
    \        {\n            if(current == result[j]) \n            {\n           \
    \     isDuplicated = true;\n                break;\n            }\n        }\n\
    \        if(!isDuplicated)\n            result[result.length] = current;\n   \
    \ }\n    return result;\n}\n/*\nReturn sorted unique elements in an array\n  \
    \  >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L,\
    \ 123L]\n    \n*/\nlong[] unique(long[] l, long value)\n{\n    bool isDuplicated\
    \ = false;\n    long current = 0;\n    long next = 1;\n    long[] result = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n        current\
    \ = l[i];\n        isDuplicated = false;\n        for(int j = 0; j < result.length;\
    \ j++) \n        {\n            if(current == result[j])\n            {\n    \
    \            isDuplicated = true;\n                break;\n            }\n   \
    \     }\n        if(!isDuplicated)\n            result[result.length] = current;\n\
    \    }\n    for(int j = 0; j < result.length; j++) \n    {\n        if(result[j]\
    \ == value)\n            result[j] = value;\n    }\n    return result;\n}\n/*\n\
    Return sorted unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L,\
    \ 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, long value, int length)\n{\n    bool isDuplicated = false;\n    long current\
    \ = 0;\n    long next = 1;\n    long[] result = new long[length];\n    for(int\
    \ i = 0; i < l.length; i++) \n    {\n        current = l[i];\n        isDuplicated\
    \ = false;\n        for(int j = 0; j < result.length; j++) \n        {\n     \
    \       if(current == result[j])\n            {\n                isDuplicated\
    \ = true;\n                break;\n            }\n        }\n        if(!isDuplicated)\n\
    \            result[result.length] = current;\n    }\n    for(int j = 0; j < result.length;\
    \ j++) \n    {\n        if(result[j] == value)\n            result[j] = value;\n\
    \    }\n    return result;\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nWhy are you\
    \ making `length` an optional parameter?\n<|/ c |>\n<| c |>\nI did not think it\
    \ was necessary, it seemed redundant. `", "{\n\tif (l.length == 0) return l;\n\
    \tlong[] u = new long[l.length];\n\tu[0] = l[0];\n\tfor (long i = 1, j = 1; i\
    \ < l.length; i++, j++) {\n\t\tif (l[j] != l[i]) {\n\t\t\tu[i] = l[i];\n\t\t}\n\
    \t}\n\treturn u;\n}", "{\n    long[] n = new long[l.length];\n    for (int i=0;\
    \ i<n.length; i++) n[i] = l[i];\n    Arrays.sort(n);\n    return n;\n}\n</code>\n\
    <|/ a tags=java,arrays |>\n<| c |>\nThank you for this code snippet, which might\
    \ provide some limited, immediate help.  A proper explanation [would greatly improve](//meta.stackexchange.com/q/114762)\
    \ its long-term value by showing *why* this is a good solution to the problem,\
    \ and would make it more useful to future readers with other, similar questions.\
    \  Please [edit] your answer to add some explanation, including the assumptions\
    \ you've made.\n<|/ c |>\n<| a tags=java,arrays |>\n<code>\npublic static int[]\
    \ uniqueSort(int[] arr) {", "{\n    long l = l[0];\n    long x = l;\n    int pos\
    \ = 1;\n    int i = 0;\n    long[] arr = new long[1000];", "{\n    var sorted\
    \ = std.array.sortRange(l, l, std.ascending);\n    return std.array.sortRange(sorted,\
    \ sorted, std.ascending)\n}", "{\n    long n = 0;\n    long uniqueCount = 0;\n\
    \    long[] u = new long[l.length];\n    for(int i = 0; i < (int)l.length; i++)\n\
    \    {\n        if(l[i] != 0L) \n        {\n            n++;\n            u[i]\
    \ = l[i];\n            uniqueCount++;\n        }\n    }\n    uniqueCount = getUniqueCount(l,\
    \ uniqueCount);\n    \n    //if n is even and uniqueCount is even then array is\
    \ empty\n    if (n % 2 == 0 && uniqueCount % 2 == 0) return l;\n    \n    //if\
    \ n is odd and uniqueCount is odd, then just cons null to end of array\n    if\
    \ (n % 2 == 1 && uniqueCount % 2 == 1)\n        return cons(null, (long[])u);\n\
    \    \n    //create new array to hold the sorted unique values\n    long[] r =\
    \ new long[uniqueCount];\n    \n    //copy unique values into new array\n    for(int\
    \ i = 0; i < (int)l.length; i++)\n    {\n        if(l[i] != 0L)\n            r[i\
    \ - (int)uniqueCount] = l[i];\n    }\n    \n    return r;\n}", "{\n    int result[]\
    \ = new int[256];\n    int i;\n    for(int j = 0; j < l.length; ++j)\n    {\n\
    \        result[l[j]] = 1;\n    }\n    for(int j = 0; j < 256; ++j)\n    {\n \
    \       if(result[j] == 0)\n        {\n            result[j] = j;\n        }\n\
    \    }\n    long final[] = new long[256];\n    for(int i = 0; i < 256; ++i)\n\
    \    {\n        if(result[i] == 0)\n        {\n            final[i] = i;\n   \
    \     }\n    }\n    int count = 0;\n    for(int i = 0; i < l.length; ++i)\n  \
    \  {\n        if(result[l[i]] != 0)\n        {\n            final[l[i]] = result[count];\n\
    \            ++count;\n        }\n    }\n    long[] l2 = new long[count];\n  \
    \  System.arraycopy(final, 0, l2, 0, count);\n    return l2;\n}\n</code>\n<|/\
    \ a dscore=3 |>\n<| c |>\nThe above method returns the same array as the original\
    \ one. If we use the first method then we could get the unique elements from the\
    \ returned array but we wouldn't be able to get the original array. \nFor example,\
    \ \n    >>> a = [1, 3, 2, 2, 3, 1]\n    >>> unique(a)\n    >>> [1, 3, 2]\n   \
    \ >>> a\n    >>> [1, 3, 2, 2, 3, 1]\n<|/ c |>\n<| c |>\n, i was working on some\
    \ kind of solution, now its updated. Thanks!\n<|/ c |>\n<| c |>\n, sorry, forgot\
    \ to remove the original array... now its working... Thanks\n<|/ c |>\n<| c |>\n\
    Thanks for posting your solution.\n<|/ c |>\n<| a |>\nI got some help from here,\
    \ I came up with a more concise and efficient solution to remove duplicates from\
    \ an array. \n<code>\nprivate <T> void removeDuplicates(T[] array){\n    Set<T>\
    \ uniqueSet = new LinkedHashSet<T>();\n    uniqueSet.addAll(Arrays.asList(array));\n\
    \    uniqueSet.stream().forEach((element) -> {\n        array.indexOf(element)\
    \ == -1 ? array.remove(element) : null;\n    });\n}\n</code>\n<|/ a dscore=3 tags=java,arrays\
    \ |>\n<| c |>\nIt is a very good answer. But, there is a small issue. `indexOf`\
    \ returns `-1` if the value is not found. So, `uniqueSet.remove` may throw an\
    \ `ArrayIndexOutOfBoundsException`. To fix that, I have added a check `if(uniqueSet.contains(element))`\
    \ before removing it.\n<|/ c |>\n<| a dscore=3 |>\nHere is a quick solution that\
    \ uses Java 8 streams:\n", "{\n    long[] result = new long[l.length];\n    int\
    \ n = 0;\n    for (int i = 0; i < l.length; i++) {\n        if (l[i] != l) {\n\
    \            result[n++] = l[i];\n        }\n    }\n    sort(result, 0, n);\n\
    \    \n    return l;\n}", "{\n\tlong temp;\n\tint[] ix = new int[l.length];\n\t\
    for (int i=0; i < l.length; i++)\n\t\tix[i] = i;\n\tArrays.sort(ix);\n\tlong[]\
    \ ret = new long[ix.length];\n\tfor (int i=0; i < ix.length; i++)\n\t\tret[i]\
    \ = l[ix[i]];\n\treturn ret;\n}\n/*\nReturn sorted unique elements in an array\n\
    \t>>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\t[123L, 0L, 2L, 3L, 5L,\
    \ 9L]\n\t\n*/\nlong[] unique(long l[])\n{\n\tlong temp;\n\tint[] ix = new int[l.length];\n\
    \tfor (int i=0; i < l.length; i++)\n\t\tix[i] = i;\n\tArrays.sort(ix);\n\tlong[]\
    \ ret = new long[ix.length];\n\tfor (int i=0; i < ix.length; i++)\n\t\tret[i]\
    \ = l[ix[i]];\n\treturn ret;\n}\n/*\nReturn sorted unique elements in an array\n\
    \t>>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\t[123L, 0L, 2L, 3L, 5L,\
    \ 9L]\n\t\n*/\nlong[] unique(long l[], long x)\n{\n\tlong temp;\n\tint[] ix =\
    \ new int[l.length];\n\tfor (int i=0; i < l.length; i++)\n\t\tix[i] = i;\n\tArrays.sort(ix);\n\
    \tlong[] ret = new long[ix.length];\n\tfor (int i=0; i < ix.length; i++)\n\t{\n\
    \t\tif (ix[i]==x) return ret;\n\t\tret[i] = l[ix[i]];\n\t}\n\treturn ret;\n}",
  "{\n  int j = 0;\n  int k;\n  int len = l.length;\n  int n = l.length/2;\n  int\
    \ *a = new int[n];", "{\n    int n = l.length;\n    if (n < 1) \n        return\
    \ l;\n    long[] ns = new long[n]; \n    int i = 0;\n    for(long e : l)\n   \
    \ {\n        if (ns[i++] == e)\n            continue;\n        ns[i] = e;\n  \
    \  }\n    return ns;\n}\n/*\nReturn sorted unique elements in a list\n    >>>\
    \ unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] unique(long[] l) \n{\n    int n = l.length;\n    if (n < 1)\
    \ \n        return l;\n    long[] ns = new long[n]; \n    int i = 0;\n    for(long\
    \ e : l)\n    {\n        if (ns[i++] == e)\n            continue;\n        ns[i]\
    \ = e;\n    }\n    return ns;\n}\n/*\nReturn sorted unique elements in a list\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n{\n    int n = l.length;\n  \
    \  if (n < 1) \n        return l;\n    long[] ns = new long[n]; \n    int i =\
    \ 0;\n    for(long e : l)\n    {\n        if (ns[i++] == e)\n            continue;\n\
    \        ns[i] = e;\n    }\n    return ns;\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n{\n    int n = l.length;\n\
    \    if (n < 1) \n        return l;\n    long[] ns = new long[n]; \n    int i\
    \ = 0;\n    for(long e : l)\n    {\n        if (ns[i++] == e)\n            continue;\n\
    \        ns[i] = e;\n    }\n    return ns;\n}\n/*\nReturn sorted unique elements\
    \ in a list\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l) \n{\n    int n = l.length;\n\
    \    if (n < 1) \n        return l;\n    long[] ns = new long[n]; \n    int i\
    \ = 0;\n    for(long e : l)\n    {\n        if (ns[i++] == e)\n            continue",
  "{\n  long[] res = new long[l.length];\n  int j = 0;\n  long k = 0;\n  for(int i\
    \ = 0; i < l.length; i++)\n  {\n    while(j < l.length && k > l[j] && l[j] !=\
    \ k)\n      j++;\n    res[i] = l[j];\n    j++;\n    k = res[i];\n  }\n  return\
    \ res;\n}\n/* Sort an array\n */", "{\n    long[] l2 = new long[l.length];\n \
    \   for(int i = 0; i < l.length; i++) \n        l2[i] = l[i];\n    l2.sort();\n\
    \    return l2;\n}\n/*\nReturn sorted unique elements in a vector \n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(std.vector.i32 l) \n{\n    long[] l2 = new long[l.length];\n   \
    \ for(int i = 0; i < l.length; i++) \n        l2[i] = l[i];\n    l2.sort();\n\
    \    return l2;\n}\n/*\nReturn sorted unique elements in a array\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(std.array.i32 l) \n{\n    long[] l2 = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++) \n        l2[i] = l[i];\n    l2.sort();\n    return\
    \ l2;\n}\n/*\nReturn sorted unique elements in a map\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(std.map<std.pair<long, long>, long> m) \n{\n    long[] l2 = new long[m.size()];\n\
    \    foreach(std.pair<long, long> p, m) \n        l2[p.first] = p.second;\n  \
    \  l2.sort();\n    return l2;\n}\n/*\nReturn sorted unique elements in a map \n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(std.pair<std.pair<long, long>, long> m) \n\
    {\n    long[] l2 = new long[m.first];\n    foreach(long l, m.second) \n      \
    \  l2[l] = l;\n    l2.sort();\n    return l2;\n}\n/*\nReturn sorted unique elements\
    \ in a vector\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123", "{\n  long temp;\n  long[] u = new long[l.length];", "{\n\
    \    int i = 0;\n    long[] r = new long[l.length];\n    while (i<l.length)\n\
    \    {\n        while (i<l.length && l[i]==l[++i]){}\n        r[--i] = l[i];\n\
    \    }\n    Arrays.sort(r);\n    return r;\n}\n</code>\n<|/ a tags=arrays,c#,sorting,unique\
    \ |>\n<| c |>\nYour `unique` function doesn't preserve the order of the original\
    \ array, it just returns a new array of the unique elements.\n<|/ c |>\n<| c |>\n\
    You are right, but I thought the asker wanted it sorted. Edited my answer\n<|/\
    \ c |>\n<| a dscore=2 |>\nAs of C# 7 you can use the unique method from System.Linq\
    \ to do the same thing:\n<code>\nvar unique = new int[] {5, 3, 2, 2, 3, 3};\n\
    var sorted = unique.OrderBy(i => i); // {2,2,3,5,3,5}\n</code>\nThe unique method\
    \ also preserves the order of the original array.\n<|/ a tags=arrays,c#,sorting,unique\
    \ |>\n<| a tags=arrays,c#,sorting,unique dscore=2 |>\nThis should do it:\n<code>\n\
    private static int[] GetUnique(int[] input)\n{\n    Array.Sort(input);", "{\n\
    \    long[] d = new long[l[0].hashCode()+1];\n    int j = 0;\n    for (int i =\
    \ 1; i < l.length; i++)\n    {\n        if (l[i] == l[i - 1])\n            continue;\n\
    \        d[l.hashCode(l[i]) % d.length] = l[i];\n    }\n    return d.reverse();\n\
    }", "{\n    long[] u = new long[l.length];\n    for (int i = 0; i < l.length;\
    \ i++) \n    {\n        u[i] = l[i];\n        for (int j = i+1; j < l.length;\
    \ j++)\n            if (l[i] == l[j]) \n            {\n                long v\
    \ = u[j];\n                u[j] = u[i];\n                u[i] = v;\n         \
    \   }\n    }\n    return u;\n}\n</code>\n<|/ a dscore=1 |>\n<| a |>\nHere is another\
    \ option:\n<code>\npublic static long[] unique(long[] values) {\n    // Get a\
    \ list of all unique elements\n    List<Long> uniqueValues = Arrays.stream(values)\n\
    \            .distinct()\n            .boxed()\n            .collect(Collectors.toList());",
  "{\n  long count=0;\n  for (long element : l) {\n    if (!contains(count, element))\
    \ {\n      ++count;\n      yield element;\n    }\n  }\n}\n/*\nReturn a list of\
    \ the unique elements in an array\n    \n>>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L])\n[0L, 2L, 3L, 5L, 9L, 123L]\n*/\nList<int> unique(int[] l) \n{\n\
    \  List<int> res = new List<int>();\n  for (int element : l) {\n    if (!contains(res,\
    \ element)) {\n      res.Add(element);\n    }\n  }\n  return res;\n}", "{\n  int\
    \ u;\n  long[] uarr = l.clone();\n  Arrays.sort(uarr);\n  for(long i=0; i<uarr.length;\
    \ i++)\n  {\n    u = i+1;\n    while(u < uarr.length)\n    {\n      if(uarr[i]\
    \ == uarr[u])\n      {\n        u++;\n      }\n      else\n      {\n        break;\n\
    \      }\n    }\n    uarr[u] = i;\n  }\n  return uarr;\n}", "{\n\treturn unique(l,\
    \ false);\n}", "{\n\tvar set = new HashSet<long>();\n\t\n\tforeach (var x in l)\
    \ \n\t{\n\t\tif (!set.contains(x))\n\t\t\tset.add(x);\n\t}\n\t\n\treturn set.sortedArray();\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L,\
    \ 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(long[] l, long[] u) \n{\n\tvar set = new HashSet<long>();\n\t\n\tforeach\
    \ (var x in l) \n\t{\n\t\tif (!set.contains(x)) \n\t\t\tset.add(x, u);\n\t}\n\t\
    \n\treturn set.sortedArray();\n}\n/*\nReturn unique elements in an array\n   \
    \ >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L,\
    \ 123L]\n    \n*/\nlong[] unique(long[] l, long[] u, long[] a) \n{\n\tvar set\
    \ = new HashSet<long>();\n\t\n\tforeach (var x in l) \n\t{\n\t\tif (!set.contains(x,\
    \ a)) \n\t\t\tset.add(x, u, a);\n\t}\n\t\n\treturn set.sortedArray();\n}\n/*\n\
    Return unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l,\
    \ long[] u, long[] a, long[] b) \n{\n\tvar set = new HashSet<long>();\n\t\n\t\
    foreach (var x in l) \n\t{\n\t\tif (!set.contains(x, a, b)) \n\t\t\tset.add(x,\
    \ u, a, b);\n\t}\n\t\n\treturn set.sortedArray();\n}\n/*\nReturn sorted unique\
    \ elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long[] u, long[]\
    \ a, long[] b, long[] c) \n{\n\tvar set = new HashSet<long>();\n\t\n\tforeach\
    \ (var x in l) \n\t{\n\t\tif (!set.contains(x, a, b, c)) \n\t\t\tset.add(x, u,\
    \ a, b, c);\n\t}\n\t\n\treturn set.sortedArray();\n}\n/*\nReturn sorted unique\
    \ elements in an array\n    >>> ", "{\n  long[] res = new long[l.length];\n  for(int\
    \ i=0;i<l.length;i++) {\n    if(res[l[i]] == null) { res[l[i]]=l[i]; }\n  }\n\
    \  return res;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis would be better if\
    \ you could provide some explanation for what the OP was doing and why your solution\
    \ would work.\n<|/ c |>\n<| c |>\n`unique` is O(n), so you might get better performance\
    \ from something like: `long[] unique = new long[l.length];\n  for(int i=0;i<l.length;i++)\
    \ {\n    if(unique[l[i]] == null) { unique[l[i]]=l[i]; }\n  }\n  return unique;`\n\
    <|/ c |>\n<| c |>\n: Yes, you're right. I've edited my answer with some comments.\n\
    <|/ c |>\n<| c |>\nThanks, this answer is much more comprehensive than mine --\
    \ I upvoted it and was going to add my own version as an alternative.\n<|/ c |>\n\
    <| a tags=arrays,c# |>\nHere is a quick way to do this with LINQ:\n<code>\nvar\
    \ sortedList = new[] {1,2,3,4,5,1,2,3}.OrderBy(x => x).Distinct().ToList();\n\
    </code>\n<|/ a dscore=0 |>\n<| c |>\nIt's actually O(n), so this might be a bad\
    \ idea.\n<|/ c |>\n<| c |>\n, The performance is O(n), because the Distinct method\
    \ iterates over the entire list to collect distinct elements. A simple foreach\
    \ loop will give you O(n) performance.\n<|/ c |>\n<| c |>\n: It's O(n), but not\
    \ in the best case. Distinct has O(n) performance, foreach has O(n^2). Sorting\
    \ the list will have O(n*log n) performance, Distinct will have O(n).\n<|/ c |>\n\
    <| c |>\n, It doesn't have to be `O(n*log n)` when implemented as a hashset, which\
    \ is typically implemented as an array or hashtable.  O(n) can still be achieved\
    \ with a sorted array or a hashtable.  In the best case it can be achieved in\
    \ O(n), in the worst case it's O(n^2).  However, if n << m, n <= log m, then O(n)\
    \ performance will almost always be better than O(n^2)\n<|/ c |>\n<| a |>\nA generic\
    \ way of doing this would be\n<code>\npublic static class ", "{\n  var res = new\
    \ long[l.length];\n  for(int i = 0; i < l.length; i++) \n  {\n    for(int j =\
    \ 0; j < i; j++) \n    {\n      if(l[i] < l[j]) \n      {\n        long a = l[i];\n\
    \        l[i] = l[j];\n        l[j] = a;\n      }\n    }\n  }\n  return l;\n}\n\
    </code>\n<|/ a tags=arrays,c#,unique dscore=1 |>\n<| c |>\nIt also removes duplicate\
    \ numbers. That's not what the OP is after. This code doesn't work.\n<|/ c |>\n\
    <| c |>\nIt's true, but if the task is to find unique values it is more elegant\
    \ than the code I provided.\n<|/ c |>\n<| c |>\nThat code has worst performance\
    \ than the one I provided for the same problem in terms of execution time !\n\
    <|/ c |>\n<| c |>\nYes, you are right. Sorry for my mistake. I edited my post\
    \ and fixed it. My first answer had wrong code, my second is more efficient.\n\
    <|/ c |>\n<| a dscore=1 |>\nI've had luck with this in C#:\n<code>\nvar numbers\
    \ = new List<int>(new int[] { 1, 5, 3, 1, 5, 3 });\nnumbers.RemoveAll(x => numbers.Where(y\
    \ => y == x).Count() == 1);\nConsole.WriteLine(string.Join(\", \", numbers.ToArray()));\n\
    </code>\n<|/ a tags=arrays,c#,unique |>\n<| a tags=arrays,c#,unique dscore=1 |>\n\
    <code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;",
  "{\n   long[] sorted = sort(l);\n   int size = sorted.length-1;\n   long[] res =\
    \ new long[size];\n   int j = 0;\n   for(int i=0; i<size; i++) {\n       if(sorted[i]\
    \ == sorted[i+1]) {\n           res[j] = sorted[i];\n           j++;\n       }\n\
    \   }\n   return res;\n}\n</code>\n<|/ a tags=java |>\n<| a tags=java |>\n<code>\n\
    public class UniqueLongArray\n{\n    public static long[] unique(long[] arr)\n\
    \    {\n        long[] a = new long[arr.length];\n        long lastVal = arr[0];\n\
    \        for(int i = 0; i < arr.length; i++)\n        {\n            if((arr[i]\
    \ != lastVal) && (arr[i] != arr[i+1]))\n            {\n                a[i] =\
    \ arr[i];\n                lastVal = arr[i];\n            }\n        }\n     \
    \   return a;\n    }\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI believe\
    \ this is an old question but this might be helpful for other people finding this\
    \ page.\n<code>\nimport java.util.Arrays;\npublic class UniqueArray {\n    public\
    \ static long[] unique(long[] arr) {\n        // TODO Auto-generated method stub\n\
    \        long[] sorted = Arrays.sort(arr);\n        int size = sorted.length-1;\n\
    \        long[] res = new long[size];\n        int j = 0;\n        for(int i=0;\
    \ i<size; i++) {\n            if(sorted[i] == sorted[i+1]) {\n               \
    \ res[j] = sorted[i];\n                j++;\n            }\n        }\n      \
    \  return res;\n    }\n    public static void main(String[] args) {\n        long[]\
    \ longArr = new long[]{9, 4, 2, 3, 10, 10, 4, 3};\n        System.out.println(Arrays.toString(unique(longArr)));\n\
    \    }\n}\n</code>\n<|/ a tags=java |>\n<| a |>\nI took answer from Sakharov and\
    \ modified it to make it more efficient. Here is my code:\n<code>\npublic static\
    \ long[] unique(long[] arr) {\n        long[] sorted = new long[arr.length];\n\
    \        int j = 0;\n        long lastVal = arr[0];\n        for (int i = 0; i\
    \ < arr.length; i++) {\n            if (arr[i] != lastVal) {\n               \
    \ sorted[j] = arr[i];\n                lastVal = arr[i];\n                j++;\n\
    \            }\n        }\n        long[] res = new long[j];\n        for (int\
    \ i = 0; i < j; i++) {\n            res[i] = sorted[i];\n        }\n        return\
    \ res;\n    }\n</code>\n<|/ a dscore=2 tags=java |>\n<| a |>\nThe easiest way\
    \ is to use HashSet:\n<code>\npublic static long[] unique(long[] a){\n    HashSet",
  "{\n    return std.algorithm.sortDetailed(l, std.typecons.Comparer.toComparable);\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L,\
    \ 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(long[] l, Comparator c)\n{\n    return std.algorithm.sortDetailed(l,\
    \ c);\n}\n/*\nReturn unique elements in a range [start, end[\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L], 0, 10)\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] unique(long[] l, int start, int end)\n{\n    return std.algorithm.sortDetailed(l,\
    \ std.typecons.Comparer.toComparable(start, end));\n}\n/*\nReturn unique elements\
    \ in a range [start, end[\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L],\
    \ 0, 10)\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int\
    \ start, int end, Comparator c)\n{\n    return std.algorithm.sortDetailed(l, std.typecons.Comparer.toComparable(start,\
    \ end), c);\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L], 0, 10)\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] uniqueDetailed(long[] l, Comparator c)\n{\n    return std.algorithm.sortDetailed(l,\
    \ c);\n}\n/*\nReturn unique elements in a range [start, end[\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L], 0, 10)\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] uniqueDetailed(long[] l, int start, int end)\n{\n    return\
    \ std.algorithm.sortDetailed(l, std.typecons.Comparer.toComparable(start, end));\n\
    }\n/*\nReturn unique elements in a range [start, end[\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L], 0, 10)\n    [0L, 2L, 3L, 5L, 9L, ", "{\n\tstd.sort(l);\n\
    \tlong[] u = new long[l[l.length-1]];\n\tfor(int i=1; i<l[l.length-1]; i++)\n\t\
    {\n\t\tif(i!=l[l.length-1])\n\t\t{\n\t\t\tif(l[i]==l[l[i]-1])\n\t\t\t\tu[l[i]]\
    \ = l[i]+1;\n\t\t\telse\n\t\t\t\tu[l[i]] = l[l[i]-1]+1;\n\t\t}\n\t\telse\n\t\t\
    \tu[l[i]] = l[i];\n\t}\n\treturn u;\n}\n/*\nReturn sorted unique elements in an\
    \ array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
    \ 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long h) \n{\n\tstd.sort(l);\n\
    \tlong[] u = new long[l[l.length-1]];\n\tfor(int i=1; i<l[l.length-1]; i++)\n\t\
    {\n\t\tif(i!=l[l.length-1])\n\t\t{\n\t\t\tif(l[i]==h && l[i]==l[l[i]-1])\n\t\t\
    \t\tu[l[i]] = l[i]+1;\n\t\t\telse\n\t\t\t\tu[l[i]] = l[l[i]-1]+1;\n\t\t}\n\t\t\
    else\n\t\t\tu[l[i]] = l[i];\n\t}\n\treturn u;\n}", "{\n    long[] u = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) {\n        u[i] = l[i];\n        for(int\
    \ j = i+1; j < l.length; j++) {\n            if (u[j] == l[i]) {\n           \
    \     l[i] = l[j];\n                u[i] = l[i];\n            }\n        }\n \
    \   }\n    return u;\n}", "{\n\tlong[] r = new long[l.length];\n\tfor (int i =\
    \ 0; i < l.length; i++) {\n\t\tif (!isUnique(l, r, i)) {\n\t\t\treturn r;\n\t\t\
    }\n\t}\n\treturn r;\n}", "{\n\t// Write your code here\n\tlong[] u = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tfor (int j = i + 1; j < l.length;\
    \ ++j)\n\t\t{\n\t\t\tif (l[i] == l[j])\n\t\t\t{\n\t\t\t\tu[i] = l[i];\n\t\t\t\t\
    j = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < u.length; ++i)\n\t{\n\t\tfor\
    \ (int j = i + 1; j < u.length; ++j)\n\t\t{\n\t\t\tif (u[i] > u[j])\n\t\t\t{\n\
    \t\t\t\tlong tmp = u[i];\n\t\t\t\tu[i] = u[j];\n\t\t\t\tu[j] = tmp;\n\t\t\t}\n\
    \t\t}\n\t}\n\treturn u;\n}\n</code>\n<|/ a tags=java,algorithm,sorting,arrays\
    \ |>\n<| a dscore=0 tags=java,algorithm,sorting,arrays |>\nThis is not a solution\
    \ in any language, but you might like to take a look at this\n<|/ a |>\n<| a dscore=0\
    \ |>\nI wrote a solution in python which works correctly for any type of data\
    \ without creating a new array.\n<code>\narr = [2,3,5,1,4,2,6,7,3,5,3,8,9]\narr.sort()\n\
    arr_copy=arr[:]\nfor num in arr:\n    if arr.count(num)>1:\n        arr.remove(num)\n\
    \        arr_copy.append(num)\nprint arr\nprint arr_copy\n</code>\n<|/ a tags=java,algorithm,sorting,arrays\
    \ |>\n<| a dscore=0 |>\nI guess this could be a possible solution:\n<code>\npublic\
    \ class Sorting {", "{\n\tlong tmp;\n\tlong[] u = new long[l.length];\n\tfor (int\
    \ i = 0; i < u.length; i++) {\n\t\ttmp = l[i];\n\t\tfor (int j = i + 1; j < u.length;\
    \ j++) {\n\t\t\tif (tmp == l[j]) {\n\t\t\t\tl[j] = tmp;\n\t\t\t\tbreak;\n\t\t\t\
    }\n\t\t}\n\t\tu[i] = tmp;\n\t}\n\treturn u;\n}", "{\n  long result[] = new long[l[l.length-1]];\
    \ \n  \n  for(int i = 1; i < l.length; i++) {\n    if(l[i] == l[i-1]) \n     \
    \ continue;\n    result[i-1] = l[i]; \n  }\n  \n  return result; \n}", "{\n  \
    \  long[] result = new long[l.length];\n    for(int i = 1; i < l.length; i++)\
    \ \n    { \n        boolean swap = true;\n        int j = 0;\n        for(; j\
    \ < i; j++)\n        {\n            if(l[j] > l[j+1]) \n            {\n      \
    \          swap = false;\n                break;\n            }\n        }\n \
    \       if(swap) \n        { \n            for(int k = i; k < l.length; k++) \n\
    \            { \n                result[k] = l[k]; \n            } \n        }\n\
    \    } \n    return result; \n}\n</code>\n<|/ a |>\n<| a dscore=2 |>\n<code>\n\
    \  import java.util.Arrays;", "{\n    long[] u = new long[l.length];\n    for(int\
    \ i=0; i<u.length; i++) \n        u[i] = l[i];\n    sort(u, l.length, long.class,\
    \ true);\n    return u;\n}\n</code>\nI took these algorithms from: http://www.algolist.net/Algorithms/Sorting/Unique\n\
    <|/ a tags=unique,sorting,c# |>\n<| c |>\nThe \"return u\" line is a bit misleading,\
    \ as it is really the unique part of the algorithm. Really, you just need to \"\
    return l;\".\n<|/ c |>\n<| c |>\n\"return l\" does not work; it just removes duplicates\
    \ from the original array.  I needed to do this after a sorting operation.\n<|/\
    \ c |>\n<| a tags=unique,sorting,c# |>\nHere is my solution that removes duplicates\
    \ from an array and sorts it without using any loops, recursions or arrays.\n\
    <code>\npublic static int[] SortAndRemoveDuplicates(int[] input)\n{\n    int[]\
    \ result = new int[input.Length];\n    int i = 0, k = 0;\n    while (i < input.Length)\n\
    \    {\n        while (i + 1 < input.Length && input[i] == input[i + 1])\n   \
    \     {\n            i++;\n        }\n        if (i == input.Length)\n       \
    \     break;\n        result[k] = input[i];\n        i++;\n        k++;\n    }\n\
    \    if (result.Length > 1)\n    {\n        for (int j = 0; j < result.Length\
    \ - 1; j++)\n        {\n            if (result[j + 1] > result[j])\n         \
    \   {\n                Array temp = result[j];\n                result[j] = result[j\
    \ + 1];\n                result[j + 1] = temp;\n            }\n        }\n   \
    \ }\n    return result;\n}\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis fails to\
    \ sort a list of strings by length. Strings get sorted by their ordinal value,\
    \ not their string length.\n<|/ c |>\n<| a dscore=4 |>\n<code>\nvar uniqueList\
    \ = new List<int>();\nvar uniqueList2 = new List<int>();", "{\n    \n    int[]\
    \ f = new int[l.length];\n    long[] res = new long[l.length];\n    int j = 0;\n\
    \    for (int i = 0; i < l.length; ++i)\n    {\n        if (f[i] != 0)\n     \
    \   {\n            res[j] = l[i];\n            j++;\n        }\n        f[l[i]]++;\n\
    \    }\n    return res;\n}", "{\n\t// O(N log N) approach\n\t\n\t// Build sorted\
    \ set for original array\n\tlong [] ls = new long[l.length];\n\tls = sort(l);\n\
    \t\n\t// Create array to hold unique elements\n\tlong [] u = new long[ls.length];\n\
    \t\n\t// Keep track of unique element\n\tlong uniqueCount = 0;\n\t\n\t// Loop\
    \ over original array to find unique elements and store them\n\tfor (int i=0;\
    \ i < ls.length; i++)\n\t{\n\t\tfor (int j=i+1 ; j < ls.length; j++)\n\t\t{\n\t\
    \t\tif (ls[i] == ls[j])\n\t\t\t{\n\t\t\t\tls[j] = -1; // To mark duplicate elements\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// If all elements are marked as duplicates,\
    \ increment unique counter\n\t\tif (ls[i] == -1)\n\t\t{\n\t\t\tuniqueCount++;\n\
    \t\t\t\n\t\t\t// Push unique element into array for return purpose\n\t\t\tu[uniqueCount-1]\
    \ = ls[i];\n\t\t}\n\t}\n\t\n\t// Return unique elements from array\n\treturn u;\n\
    }", "{\n    long[] n = new long[l.length];\n    for (int i=0; i < n.length; i++)\
    \ \n\tn[i] = l[i];\n    Arrays.sort(n);\n    return n;\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI agree that this is a better approach than using Lists. However,\
    \ it would be nice to know how to do this with Lists.\n<|/ c |>\n<| c |>\n: How\
    \ about using Arrays.sort() with the compare() function?\n<|/ c |>\n<| c |>\n\
    You mean like this: `Arrays.sort(l, new Comparator<Long>() { public int compare(Long\
    \ o1, Long o2) { ... } });` ?\n<|/ c |>\n<| c |>\n: Yes, it would be cleaner with\
    \ `Arrays.sort()`. I wasn't sure if `compare()` is overloaded or something because\
    \ I haven't seen it used much anywhere (I usually use my own Comparators).\n<|/\
    \ c |>\n<| a tags=java,list,arrays |>\nI came here because I was looking for the\
    \ shortest possible solution to sort a List and I didn't want to use Guava's Ordering\
    \ or Comparator. Here is my solution:\n<code>\nList<Integer> list = Arrays.asList(12,\
    \ 3, 6, 1, 15, 94, 8);\nInteger[] array = list.toArray(new Integer[list.size()]);\n\
    Arrays.sort(array);\nlist = Arrays.asList(array);\nSystem.out.println(list);\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nArrays.asList() returns a fixed-size list\
    \ so it's no better than any other solution\n<|/ c |>\n<| c |>\nWhy do you convert\
    \ a list to a fixed-size array? That is useless.\n<|/ c |>\n<| c |>\n.kowshik\
    \  It's not useless, it's just one more line of code\n<|/ c |>\n<| a |>\nYou can\
    \ use the method sort.\n<code>\nArrays.sort(a);\n</code>\n<|/ a dscore=5 tags=java,list,arrays\
    \ |>\n<| a |>\nI came across a similar problem and ended up writing a custom method\
    \ to solve it (see below). The method can take any type of List including arrays\
    \ and Lists of custom objects.\nThe custom sort method will always return a sorted\
    \ List of the same type as the passed List but can be used for any list type with\
    \ any number of elements. \nThe return type of the custom method is a List< T\
    \ > so that it can contain any type of List< T >.\n<code>\npublic static <T> List<\
    \ T > customSort(List< T > list", "{\n    long[] result = new long[l.length];\n\
    \    int j = 0;\n    for (int i = 0; i < l.length; i++) {\n        while (j <\
    \ l.length && l[i] == l[j]) {\n            j++;\n        }\n        result[i]\
    \ = l[j];\n    }\n    \n    return result;\n}", "{\n\tlong[] u = new long[l.length];\n\
    \tbool first = true;\n\tfor (int i = 0; i < l.length; ++i)\n\t\tif (l[i] != 0L)\n\
    \t\t{\n\t\t\tif (!first)\n\t\t\t{\n\t\t\t\tu[i - 1] = l[i];\n\t\t\t}\n\t\t\telse\n\
    \t\t\t{\n\t\t\t\tu[i] = l[i];\n\t\t\t}\n\t\t\tfirst = false;\n\t\t}\n\treturn\
    \ u;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\ndouble[]\
    \ unique(double[] l) \n{\n\tdouble[] u = new double[l.length];\n\tbool first =\
    \ true;\n\tfor (int i = 0; i < l.length; ++i)\n\t\tif (l[i] != 0)\n\t\t{\n\t\t\
    \tif (!first)\n\t\t\t{\n\t\t\t\tu[i - 1] = l[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\
    {\n\t\t\t\tu[i] = l[i];\n\t\t\t}\n\t\t\tfirst = false;\n\t\t}\n\treturn u;\n}\n\
    /*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nfloat[] unique(float[]\
    \ l) \n{\n\tfloat[] u = new float[l.length];\n\tbool first = true;\n\tfor (int\
    \ i = 0; i < l.length; ++i)\n\t\tif (l[i] != 0.0f)\n\t\t{\n\t\t\tif (!first)\n\
    \t\t\t{\n\t\t\t\tu[i - 1] = l[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tu[i]\
    \ = l[i];\n\t\t\t}\n\t\t\tfirst = false;\n\t\t}\n\treturn u;\n}\n/*\nReturn sorted\
    \ unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/", "{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i) \n\t\tres[i] = l[i];\n\tint i = res.length,\
    \ j = 0;\n\twhile (i > 0 && j > 0) {\n\t\tif (res[j] == res[--i]) {\n\t\t\tres[j]\
    \ = l[i];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn res;\n}\n/*\nReturn unique items in\
    \ an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
    \ 3L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int d) { \n\tlong[] res = new\
    \ long[d.length];\n\tfor (int i = 0; i < l.length; ++i) \n\t\tres[i] = l[i];\n\
    \tint i = res.length, j = 0;\n\twhile (i > 0 && j > 0) {\n\t\tif (res[j] == res[--i])\
    \ {\n\t\t\tres[j] = l[i];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn res;\n}", "{\n\tlong[]\
    \ u;\n\tbool found = false;\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tlong\
    \ lh = l[i];\n\t\tfor (int j = i + 1; j < l.length; j++)\n\t\t{\n\t\t\tif (lh\
    \ == l[j])\n\t\t\t{\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\
    \tif (found)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tu = new long[l.length\
    \ + 1];\n\t\t\tint index = 0;\n\t\t\tfor (int j = 0; j < l.length; j++)\n\t\t\t\
    {\n\t\t\t\tu[index++] = l[j];\n\t\t\t}\n\t\t\tl = new long[index];\n\t\t\tSystem.arraycopy(l,\
    \ 0, u, 0, l.length);\n\t\t\tl = u;\n\t\t\tfound = false;\n\t\t}\n\t}\n\treturn\
    \ l;\n}", "{\n\tlong[] u = new long[l[l.length-1]];\n\tint j = 0;\n\tint i;\n\t\
    for(i = 0; i < l[l.length-1]; i++)\n\t{\n\t\twhile(j<l[i]) u[j++] = l[i];\n\t\t\
    u[j-1]--;\n\t}\n\treturn u;\n}", "{\n\t// TODO: Optimize this by storing the result\
    \ in an\n\t// array and using linear search to find unique elements\n\tint n =\
    \ l.length;\n\tlong[] a = new long[n];\n\tlong temp;\n\tfor (int i = 0; i < n;\
    \ i++) {\n\t\ttemp = l[i];\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tif (temp\
    \ > l[j]) {\n\t\t\t\ta[i] = l[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ a;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/", "{\n\
    \  long[] out = new long[l.length];\n  long[] prev = new long[l.length];\n  \n\
    \  prev[0] = 0;\n  for (int i = 1; i < l.length; i++)\n  {\n    long x = l[i];\n\
    \    int j = -1;\n    for (j=0; j < i; j++)\n    {\n      long y = l[j];\n   \
    \   if (prev[j] == x)\n        continue;\n      else if (prev[j] > x)\n      {\n\
    \        prev[j] = x;\n        out[j] = y;\n        break;\n      }\n    }\n \
    \   if (j == i)\n      out[i] = x;\n  }\n  return out;\n}\n\"\"\"\n</cell>\n<cell>\n\
    !cd ~/facs-seq_test/; python -m SimpleHTTPServer 9191\n</cell>\n<cell>\nimport\
    \ ipywidgets as widgets\nwidgets.interact(lambda col : unique(l=col), col=lnames[:4])\n\
    </cell>\n<text>\nEjemplo: Sacar una lista de valores \xEDmpares en un rango dado.\n\
    Para esto podemos usar la funci\xF3n range(), y usar un for, para que el c\xF3\
    digo de la funci\xF3n se ejecute una sola vez para cada valor del rango. \nSi\
    \ no convierte la funci\xF3n range en una funci\xF3n que se ejecute una sola vez\
    \ por cada valor del rango entonces podemos utilizar el c\xF3digo a continuaci\xF3\
    n para hacer una sola vez de la lista de valores \xEDmpares.", "{\n    long[]\
    \ res;\n    \n    res = l;\n    long last = res[0];\n    int index = 0;\n    for(int\
    \ i = 1; i < l.length; i++)\n    {\n        if(l[i] == last)\n        {\n    \
    \        res[index++] = l[i];\n        }\n        else\n        {\n          \
    \  last = l[i];\n        }\n    }\n    \n    return res;\n}", "{\n    long[] u\
    \ = new long[l.length];\n    for(int i = 1; i < l.length; ++i)\n    {\n      \
    \  if(l[i] < l[i-1])\n            u[i] = l[i];\n        else\n            for(int\
    \ j = 0; j < i; ++j)\n                if(l[j] < l[i])\n                    u[i]\
    \ = l[j];\n    }\n    return u;\n}\n/*\nReturn sorted unique elements in an array\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long tol) \n{\n    long[] u = new\
    \ long[l.length];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < l[i-1])\n            u[i] = l[i];\n        else\n            for(int j = 0;\
    \ j < i; ++j)\n                if(l[j] < l[i])\n                    u[i] = l[j];\n\
    \    }\n    return u;\n}\n/*\nReturn sorted unique elements in an array\n    >>>\
    \ unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] unique(long[] l, long tol, long equal) \n{\n    long[] u = new\
    \ long[l.length];\n    for(int i = 1; i < l.length; ++i)\n    {\n        if(l[i]\
    \ < l[i-1])\n            u[i] = l[i];\n        else\n            for(int j = 0;\
    \ j < i; ++j)\n                if(l[j] < l[i])\n                    u[i] = l[j];\n\
    \    }\n    return u;\n}\n/*\nReturn sorted unique elements in an array\n    >>>\
    \ unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] unique(long[] l, long tol, long equal, long strict) \n{\n  \
    \  long[] u = new long[l.length];\n    for(int i = 1; i < l.length; ++i)\n   \
    \ {\n        if(l[i] < l[i-1])\n            u[i] = l[i];\n        else\n     \
    \       for(int j = 0; j < i; ++j)\n                if(l[j] < l[i])\n        \
    \            u[i] = l[j];\n    }\n    return u;\n}\n/*\nReturn sorted unique elements\
    \ in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5", "{\n\tlong[] u = new long[l.length];\n\tfor(int i = 0; i < u.length;\
    \ i++)\n\t\tu[i] = i;\n\tArrays.sort(u);\n\tArrays.parallelSort(u);\n\treturn\
    \ u;\n}", "{\n\t// Return sorted unique elements in an array\n\tlong temp = 0;\n\
    \tint i=0;\n\twhile (i<l.length){\n\t\tif (l[i] != temp){\n\t\t\ttemp=l[i];\n\t\
    \t\ti++;\n\t\t}\n\t\telse{\n\t\t\ti++;\n\t\t}\n\t}\n\treturn new long[i+1];\n}",
  "{\n    long u = 0;\n    for (int i = 0; i < l.length; i++)\n        if (l[i] ==\
    \ u)\n            continue;\n        else if (l[i] < u)\n            l[i], u =\
    \ u;\n        else\n            u++;\n    return l;\n}\n/*\nReturn sorted unique\
    \ elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 9L, 123L]\n    \n*/", "{\n    long[] a = new long[l.length];\n\
    \    for (int i = 0; i < l.length; i++) \n        a[i] = l[i];\n    Arrays.sort(a);\n\
    \    long[] b = new long[l.length];\n    for (int i = 0; i < l.length; i++) \n\
    \        b[l.length-1-i] = a[i];\n    return b;\n}\n</code>\n<|/ a tags=arrays,c#\
    \ dscore=0 |>\n<| a tags=arrays,c# |>\n<code>\nvar input = new int[] { 2, -1,\
    \ 4, 3, -1, -3 };\nvar output = input.OrderByDescending(x => x).Skip(1).Take(3).ToArray();\n\
    </code>\n<|/ a dscore=0 |>\n<| a tags=arrays,c# |>\n<code>", "{\n\tlong[] u =\
    \ new long[l.length];\n\tArrays.sort(l);\n\tfor (int i = 0; i < l.length; i++)\
    \ \n\t\tu[l.length - 1 - i] = l[i];\n\treturn u;\n}", "{\n    var result = new\
    \ long[l.length];\n    var j = 0;\n    for (var i=0; i< l.length; i++)\n    {\n\
    \        while (j<result.length && l[i]==result[j])\n        {\n            j++;\n\
    \        }\n        if (j<result.length)\n        {\n            result[j] = l[i];\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements in\
    \ an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
    \ 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(float[] l) \n{\n    var result =\
    \ new long[l.length];\n    var j = 0;\n    for (var i=0; i< l.length; i++)\n \
    \   {\n        while (j<result.length && l[i]==result[j])\n        {\n       \
    \     j++;\n        }\n        if (j<result.length)\n        {\n            result[j]\
    \ = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique elements\
    \ in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(double[] l) \n{\n    var result\
    \ = new long[l.length];\n    var j = 0;\n    for (var i=0; i< l.length; i++)\n\
    \    {\n        while (j<result.length && l[i]==result[j])\n        {\n      \
    \      j++;\n        }\n        if (j<result.length)\n        {\n            result[j]\
    \ = l[i];\n        }\n    }\n    return result;\n}", "{\n    long h=0;\n    long\
    \ t = 0;\n    long[] u = new long[l.length];\n    for (int i=0; i<l.length; i++)\n\
    \    {\n        if (l[i]>t)\n        {\n            u = swap(u, i, h);\n     \
    \       h = t;\n            t += l[i];\n        }\n    }\n    u = swap(u, l.length,\
    \ h);\n    return u;\n}", "{\n    if (l.length == 0)\n        return l;\n    long[]\
    \ res = new long[l.length];\n    boolean[] used = new boolean[l.length];\n   \
    \ int j = 0;\n    for (int i = 0; i < l.length; ++i)\n    {\n        if (!used[i])\n\
    \        {\n            res[j] = l[i];\n            used[i] = true;\n        \
    \    j++;\n        }\n    }\n    return res;\n}\n/*\nGiven a sorted integer array\
    \ and an element, find the index of a given element\n    ex: [1,2,3] and 3 returns\
    \ 0\n    ex: [1,2,3] and 4 returns 3\n    ex: [1,2,3] and 0 returns -1\n    ex:\
    \ [1,2,3] and -1 returns -1\n    ex: [] and 0 returns -1\n    ex: [] and -1 returns\
    \ -1\n    ex: [] and 10 returns -1\n*/", "{\nlong[] n = new long[l.length];\n\
    for (int i = 0; i < n.length; i++)\n{\n    bool contains = false;\n    for (int\
    \ j = 0; j < l.length; j++)\n    {\n        if (l[j] == n[i])\n        {\n   \
    \         contains = true;\n        }\n    }\n    if (!contains)\n    {\n    \
    \    n[i] = l[i];\n    }\n}\nreturn n;\n}\n/*\nReturn sorted unique elements in\
    \ an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
    \ 3L, 5L, 9L, 123L]\n    \n*/", "{\n  int len = l.length;\n  long[] u = new long[len];",
  "{\n\tlong temp;\n\tlong[] ret = new long[l.length];\n\tsort(l,0,l.length-1,true);\n\
    \ttemp = l[0];\n\tret[0] = temp;\n\tfor (int i = 1; i < l.length; i++) \n\t{\n\
    \t\tif (l[i] != temp) {\n\t\t\ttemp = l[i];\n\t\t\tret[i] = temp;\n\t\t}\n\t}\n\
    \treturn ret;\n}", "{\n    Arrays.sort(l);\n    int i = 0;\n    long[] ret = new\
    \ long[l.length];\n    while (i < l.length)\n    {\n        if (l[i] != l[i-1])\n\
    \        {\n            ret[i++] = l[i++];\n        }\n    }\n    return ret;\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L,\
    \ 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/", "{\n\
    \  long[] res = new long[l.length];\n  long temp;\n  int j = 0;\n  int j2 = 0;\n\
    \  int i;\n  for(i = 0; i < l.length; i++) \n  {\n    temp = l[i];\n    if(res[j]\
    \ != temp) \n    {\n      res[j2] = temp;\n      j2++;\n    }\n    j++;\n  }\n\
    \  return res;\n}\n</code>\n<|/ a dscore=3 tags=java,sorting,arrays |>\n<| c |>\n\
    The array is sorted in the question\n<|/ c |>\n<| c |>\nThis code is O(n^2), which\
    \ is terrible in most scenarios. It can be improved to O(n*log n), but it can't\
    \ be done in Java without using an external library.\n<|/ c |>\n<| c |>\nIf you\
    \ do want to do it yourself in Java, you could just use a simple `HashSet` for\
    \ the job, then reverse the resulting array. It is a bit less efficient, but you\
    \ get the sorted output without having to use external libraries.\n<|/ c |>\n\
    <| c |>\nI totally agree! :) Just pointed out a better way to sort it in O(nlogn)\
    \ time.\n<|/ c |>\n<| c |>\n: Yeah, this works but still complexity is n^2. Why\
    \ do people like to implement a complicated algorithm when it is simple to achieve\
    \ the required output in just 2 lines of code!\n<|/ c |>\n<| a |>\nI wanted to\
    \ see if I could do this in Java without using a library and came up with this:\n\
    <code>\nlong[] foo(long[] arr) {\n    List<Long> longList = new ArrayList<Long>(Arrays.asList(arr));\n\
    \    Collections.sort(longList);\n    long[] result = new long[arr.length];\n\
    \    int i = 0;\n    while (i < arr.length) {\n        result[arr.length - 1 -\
    \ i] = longList.remove(i);\n        i++;\n    }\n    return result;\n}\n</code>\n\
    It's basically a one-liner that uses Collections.sort to sort the list, and then\
    \ removes each element from the list, using Arrays.copyOfRange to create a new\
    \ array.\nI tested it against the example from the question, and it seems to work\
    \ fine.\n<|/ a dscore=2 tags=java,sorting,arrays |>\n<| c |>\nI like this solution,\
    \ although it doesn't work if the array contains duplicated values.\n<|/ c |>\n\
    <| a tags=java,sorting,arrays |>\nThe question explicitly says that one cannot\
    \ use libraries, and that the solution should preferably be one line with no external\
    \ libraries.  However, this solution ", "{\n    sort(l);\n    return unique(l);\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L,\
    \ 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(TArrayI l) \n{\n    long[] res = new long[l.length];\n    for(int i =\
    \ 0; i < l.length; i++) \n    {\n        long u = l[i];\n        for(int j = 0;\
    \ j < i; j++) \n        {\n            if(u < l[j])\n            {\n         \
    \       res = union(res, l[j]);\n            }\n        }\n        if(!contains(res,\
    \ u)) \n        {\n            res[i] = u;\n        }\n    }\n    return res;\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L,\
    \ 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(int[] l) \n{\n    sort(l);\n    return unique(l);\n}\n/*\nReturn sorted\
    \ unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(TArrayI l) \n\
    {\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; i++)\
    \ \n    {\n        int u = l[i];\n        for(int j = 0; j < i; j++) \n      \
    \  {\n            if(u < l[j])\n            {\n                res = union(res,\
    \ l[j]);\n            }\n        }\n        if(!contains(res, u)) \n        {\n\
    \            res[i] = u;\n        }\n    }\n    return res;\n}\n/*\nReturn sorted\
    \ unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(float[] l) \n\
    {\n    sort(l);\n    return unique(l);\n}\n/*\nReturn sorted unique elements in\
    \ an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L,\
    \ 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(TArrayF l) \n{\n    long[] res =\
    \ new long[l.", "{\n  // create an empty hashmap\n  hashmap <long,long> hmap =\
    \ new hashmap();\n  // for each element\n  for (int i=0; i<l.length; i++) {\n\
    \    // if the hashmap does not contain this element\n    if (!hmap.containsKey(l[i]))\
    \ {\n      // add the element to the hashmap\n      hmap.put(l[i], l[i]);\n  \
    \  }\n  }\n  // return a list of unique elements in the hashmap\n  return hmap.getKeys();\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThat is what I thought too, but I don't\
    \ have enough memory on machine where I will be running it, so I decided to use\
    \ TreeSet to find unique elements. And since TreeSet is using hashtable internally\
    \ to store its elements, it seems good idea to me as long as it works.\n<|/ c\
    \ |>\n<| a tags=stl,set,c++,unique |>\nYou could use a std::unordered_set to store\
    \ unique elements. \nBut since you're looking for unique elements in sorted array\
    \ or any other ordered container, you could use a hash table that stores unique\
    \ elements indexed by their first element. \nThen you could use std::set or std::multiset\
    \ or std::map to find the unique elements in the set or multiset.\n<|/ a dscore=1\
    \ |>\n<| c |>\nI implemented this idea, and it is working fine, but it is using\
    \ more memory than my solution. I will post my implementation as soon as I get\
    \ home.\n<|/ c |>\n<| c |>\nCould you share your solution? It would help to test\
    \ it.\n<|/ c |>\n<| c |>\nYeah, sure, I will post it soon.\n<|/ c |>\n<| c |>\n\
    Could you share your solution? It would be helpful to test it.\n<|/ c |>\n<| c\
    \ |>\nUnfortunatelly I can't, as I don't have enough memory to test it. And I\
    \ cannot post the code. I will post the solution as soon as I can.\n<|/ c |>\n\
    <| a |>\n<code>\n// C++ program to remove duplicates in an array", "{\n    long\
    \ temp;\n    long[] unique = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        for(int j = i+1; j < l.length; j++) \n        {\n    \
    \        if (l[i] == l[j]) \n            {\n                temp = l[i];\n   \
    \             l[i] = l[j];\n                l[j] = temp;\n            }\n    \
    \    }\n        unique[i] = l[i];\n    }\n    for(int i = 0; i < l.length; i++)\
    \ \n        unique[l.length - 1 - i] = l[i];\n    return unique;\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nA single pass through the data might be faster, but\
    \ a linked list with sorting should be faster.\n<|/ c |>\n<| c |>\nThat depends\
    \ on the number of elements. I didn't bother with the extra loop, but you're right\
    \ it might help with bigger inputs.\n<|/ c |>\n<| a |>\nI prefer an O(n) solution\
    \ which I described in this article:\nhttp://blog.stephencleary.com/2009/08/sorting-algorithms.html\n\
    This is my O(n) solution. It runs in O(n) time, which is better for bigger inputs.\n\
    <code>\npublic class OddEvenSorter<T>\n{\nprivate class AvlTreeNode<T>\n{\n  \
    \  public int key; // the element to sort on\n    public AvlTreeNode<T> left;\
    \ //left subtree\n    public AvlTreeNode<T> right; //right subtree\n    public\
    \ AvlTreeNode(int key) {\n        this.key = key;\n    }\n}", "{\n\tif (l == null)\n\
    \t\treturn null;\n\tif (l.length == 0)\n\t\treturn l;\n\tif (l.length == 1)\n\t\
    \treturn l;", "{\n        long[] u = new long[l.length];\n        long seen;\n\
    \        \n        for (int i = 0; i < (int)u.length; ++i) {\n               \
    \ seen = l[i];\n                for (int j = i; j < u.length; ++j) {\n       \
    \                 if (l[j] == seen) {\n                                u[j + 1]\
    \ = seen;\n                                break;\n                        }\n\
    \                }\n        }\n        return u;\n}", "{\n  int n = l.length;\n\
    \  long[] rt = new long[n];\n  int i;\n  for(i=0; i < n; ++i) {\n    int r = std.math.compare(l[i],\
    \ l[i+1]);\n    if(r == 0) {\n      rt[i] = l[i];\n    } else if(r < 0) {\n  \
    \    rt[i] = l[i+1];\n    } else {\n      rt[i+1] = l[i];\n    }\n  }\n  return\
    \ rt;\n}\n</code>\n<|/ a dscore=1 tags=sorting,algorithm,java,arrays |>\n<| a\
    \ |>\n<code>\nclass ArraySort\n{\n    public static int[] sort(int[] arr){\n \
    \       if(arr == null || arr.length == 0)\n            return arr;", "{\n\tint\
    \ n = l.length;\n\tlong[] result = new long[n];\n\t\n\tfor (int i = 0; i < n;\
    \ i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (l[i] == l[j]) {\n\t\t\t\
    \tfor (int k = 0; k < i; k++)\n\t\t\t\t\tresult[k] = l[k];\n\t\t\t\tbreak;\n\t\
    \t\t}\n\t\t}\n\t}\n\t\n\treturn result;\n}", "{\n  int i, j, count = 0;\n  for\
    \ (i = 0; i < l.length; i++)\n    for (j = i + 1; j < l.length; j++)\n      if\
    \ (l[i] == l[j])\n        count++;\n  if (count > 0)\n    l.sort(std.typecons.Less.F_LT_G);\n\
    \  l.length = count;\n  return l;\n}", "{\n    var d = new SortedSet[dv.type];\n\
    \    foreach (var x in l) \n        { \n            if (!dv.contains(x, d))\n\
    \                d.add(x);\n        }\n    return d.data;\n}\n/*\nReturn sorted\
    \ unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/", "{\n    int N=0;\n    long[]\
    \ tmp = new long[l[l].__len__()];\n    for(int i=0; i<l[l].__len__(); i++) {\n\
    \        tmp[++N] = l[l][i];\n    }\n    Arrays.sort(tmp, new Comparator<long>(){\n\
    \        public int compare(long[] o1, long[] o2) {\n            return Long.compare(o1[1],\
    \ o2[1]);\n        }\n    });\n    for(int i=0; i<l[l].__len__(); i++) {\n   \
    \     l[l][i] = tmp[--N];\n    }\n    return l;\n}\n</code>\n<|/ a dscore=2 tags=c#,arrays,linq,sorting\
    \ |>\n<| c |>\nThis is a correct answer to the question, but it's probably not\
    \ a good approach to the problem in general.  The sorting algorithm is O(nlogn)\
    \ but your code is O(n^2).  A better approach would be to sort the array in O(n)\
    \ time and then use a HashSet to find all unique elements.  It's also O(n) time\
    \ if there are many duplicate elements, and O(n) space if there are not.  See\
    \ my answer below for details.\n<|/ c |>\n<| a |>\n<code>\npublic static class\
    \ ArrayHelper\n{\n    /// <summary>\n    /// Returns a unique set of elements\n\
    \    /// </summary>\n    /// <typeparam name=\"T\"></typeparam>\n    /// <param\
    \ name=\"a\">Input array of elements to find the unique elements of</param>\n\
    \    /// <returns></returns>\n    public static IEnumerable<T> Unique<T>(this\
    \ T[] a)\n    {\n        return a.Distinct<T>();\n    }", "{\n    var result =\
    \ new long[l.length];\n    var set = new HashSet<long>();\n    foreach (var i\
    \ in l)\n    {\n        if (!set.contains(i))\n        {\n            result[set.size]\
    \ = i;\n            set.add(i);\n        }\n    }\n    return result;\n}", "{\n\
    \    var result = new long[l.Length];\n    long u = 0;\n    var i = 0;\n    int\
    \ j = 0;\n    for(int n = l.Length - 1; n >= 0; n--)\n    {\n        if(u == l[n])\n\
    \        {\n            for(; j < i; ++j)\n                result[j] = l[j];\n\
    \            i = j + 1;\n        }\n        else\n        {\n            u=l[n];\n\
    \            for(; j < i; ++j)\n            {\n                if(u == l[j])\n\
    \                {\n                    for(; j < i; ++j)\n                  \
    \      result[j+1] = result[j];\n                    result[j] = u;\n        \
    \            i = j + 1;\n                    break;\n                }\n     \
    \       }\n        }\n    }\n    for(; j < i; ++j)\n        result[j] = l[i];\n\
    \    return result;\n}\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks, I got\
    \ this far myself and am aware of how to do it, but I wanted to know if there\
    \ was a more performant way that I had overlooked, as I thought it would be a\
    \ lot faster to use a hashmap or something.\n<|/ c |>\n<| c |>\nYou can write\
    \ your own hashmap data structure, or use HashSet.\n<|/ c |>\n<| c |>\nI assume\
    \ you mean the code I have posted here? I looked through the source for HashSet\
    \ and it just seemed like an overkill for my situation. I just wanted to make\
    \ sure I wasn't missing anything that would make this approach faster than the\
    \ alternatives.\n<|/ c |>\n<| a |>\nI like how I read your problem, but I think\
    \ your solution is not optimized. Here is my solution:\n<code>\npublic static\
    \ long[] Unique(long[] nums)\n    {\n        long[] temp = new long[nums.Length];\n\
    \        long tempArray[] = new long[nums.Length];\n        int i = 0;\n     \
    \   foreach (long num in nums)\n        {\n            bool isUnique = true;\n\
    \            for (int j = 0; j < i; j++)\n            {\n                if (num\
    \ == temp[j])\n                {\n                    isUnique = false;\n    \
    \                break;\n                }\n            }\n            if (isUnique)\n\
    \            {\n                tempArray[i] = num;\n                i++;\n  \
    \          }\n        }\n        temp = new long[i];\n        for (int j = 0;\
    \ j < i; j++)\n        {\n            temp[j] = tempArray[j];\n        }\n   \
    \     return temp;\n    }\n</code>\n<|/ a dscore=0 tags=arrays,c#,sorting |>\n\
    <| c |>\nThank you for your solution. I tried it and your solution works. However\
    \ I was thinking about it and I wonder how you would do this without creating\
    \ a new array. I was ", "{\n    if (l.length == 0) \n        throw new UnsupportedOperationException();\n\
    \    int n = l.length;\n    if (n == 1) \n        return l;\n    long[] res =\
    \ new long[n];\n    std.sort(l);\n    int i = 0;\n    for (int j = 0; j < n; ++j)\
    \ {\n        while (i < n && l[i] == l[j]) {\n            ++i;\n        }\n  \
    \      if (i < n) {\n            res[j] = l[i];\n            ++i;\n        }\n\
    \    }\n    return res;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=arrays,c++,algorithm\
    \ dscore=2 |>\nThe algorithm would be:\n<code>\nsort(input_array,input_array+array_length);",
  "{\n    int i, j, cnt = 0;\n    long[] out = new long[l.length];", "{\n    long[]\
    \ u = new long[l.length];\n    sort(l);\n    for (int i = 0; i < u.length; i++)\n\
    \        u[i] = l[i];\n    \n    for (int i = 1; i < u.length; i++)\n        if\
    \ (u[i-1] != u[i])\n            l[l.length-1] = u[i];\n    \n    return l;\n}",
  "{\n    long[] u;\n    u = l.clone();\n    long[] u2 = new long[u.length];\n   \
    \ Arrays.sort(u2);\n    for(int i=0; i<u.length; i++) \n        if(u[i]!=u2[i])\
    \ \n        {\n            u2[i] = u2[i];\n        }\n    return u2;\n}", "{\n\
    \tint i = 0, j = 0;\n\tlong[] t = new long[l.length];\n\twhile(j < l.length){\n\
    \t\twhile(i < l.length && l[i] == l[j]){\n\t\t\tt[j++] = l[i++];\n\t\t}\n\t\t\
    while(i < l.length && l[i] < l[j]){\n\t\t\tt[j++] = l[i++];\n\t\t}\n\t}\n\tt =\
    \ unique(t);\n\treturn t;\n}", "{\n\tlong[] ans = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tint index = 0;\n\t\twhile(index == 0 &&\
    \ index < ans.length)\n\t\t{\n\t\t\t//printf(\"i: %d, index: %d, ans[%d]: %d,\
    \ l[%d]: %d\\n\", i, index, ans[index], ans[index], l[i], l[i]);\n\t\t\tif(ans[index]\
    \ == l[i]) \n\t\t\t{\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\t\
    ans[index] = l[i];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i\
    \ < ans.length; i++) \n\t{\n\t\tprintf(\"ans[%d]: %d\\n\", i, ans[i]);\n\t}\n\t\
    return ans;\n}", "{\n    long[] ans = new long[l.length];\n    \n    // O(log\
    \ N), sort, then remove duplicates\n    Arrays.sort(l);\n    \n    for (int i\
    \ = 0; i < l.length; i++)\n    {\n        long l = l[i];\n        for (int j =\
    \ i + 1; j < l.length; j++)\n        {\n            if (l[j] == l)\n         \
    \   {\n                ans[j] = l;\n                j--;\n            }\n    \
    \    }\n    }\n    return ans;\n}", "{\n    long[] a = new long[l[l.length -1]\
    \ + 1];\n    for(int i = 0; i < a.length; i++) a[i]=l[i];\n    for(int i = 1;\
    \ i < a.length; i++) \n    {\n        long cur = a[i];\n        for(int j = i;\
    \ j < a.length; j++) \n        {\n            if(a[j] < cur) \n            {\n\
    \                long temp = a[j];\n                a[j] = cur;\n            \
    \    cur = temp;\n            }\n        }\n    }\n    return a;\n}\n</code>\n\
    <|/ a tags=sorting,algorithm,c#,.net |>\n<| c |>\nThis algorithm is unstable.\
    \ The following input will produce different outputs depending on how you use\
    \ it: ", "{\n    long[] res = new long[l.length];\n    for (int i = 0; i < l.length;\
    \ i++) \n    {\n        for (int j = i+1; j < l.length; j++) \n        {\n   \
    \         if (l[i] == l[j]) \n            {\n                long aux = l[i];\n\
    \                l[i] = l[j];\n                l[j] = aux;\n            }\n  \
    \      }\n    }\n    return res;\n}\n</code>\n<|/ a dscore=5 |>\n<| a |>\nI wrote\
    \ a method called unique that does this:\n<code>\npublic static <T> List<T> unique(final\
    \ List<T> list) {\n    Set<T> set = new HashSet<T>(list);\n    return new ArrayList<T>(set);\n\
    }\n</code>\nTest:\n<code>\nList<Integer> list = new ArrayList<Integer>();\nlist.addAll(Arrays.asList(new\
    \ Integer[]{1, 2, 1, 3, 3, 4, 4}));", "{\n    Map<long, int> res = new HashMap<long,\
    \ int>();\n    for (int i = 0; i < l.length; i++) {\n        long c = l[i];\n\
    \        res.put(c, i == 0 ? 1 : res.get(c) + 1);\n    }\n    long[] r = new long[res.size()];\n\
    \    int j = 0;\n    for (long c : res.keySet()) {\n        r[j++] = c;\n    }\n\
    \    return r;\n}", "{\n    long[] r = long.dup(l);\n    var hash = new std.array<long,2>();\n\
    \    std.sort(r);\n    \n    foreach (long v in r) {\n        if (hash.contains(v))\n\
    \            continue;\n        hash.add(v,0);\n    }\n    return hash;\n}", "{\n\
    \    long[] u = new long[l.length];\n    for (int i = 0; i < u.length; i++)\n\
    \    {\n        for (int j = i + 1; j < u.length; j++)\n        {\n          \
    \  if (l[i] == l[j])\n            {\n                u[i] = l[i];\n          \
    \      break;\n            }\n        }\n    }\n    return u;\n}", "{\n    int\
    \ j = 0;\n    long current = l[0];\n    long[] u = new long[l.length];\n    int\
    \ index = 0;\n    for(long e : l)\n    {\n        if(e != current)\n        {\n\
    \            u[index] = current;\n            j++;\n            current = e;\n\
    \            index++;\n        }\n    }\n    u[index] = current;\n    return u;\n\
    }", "{\n\tlong[] result = new long[l.length];\n\tArrays.sort(l);\n\tfor (int i\
    \ = 0; i < l.length; i++)\n\t\tresult[i] = l[i];\n\treturn result;\n}", "{\n \
    \   var ans = new long[l.Length];\n    var n = 0;\n    for(var i=0,j=0;i<l.Length;++i)\n\
    \    {\n        bool found = false;\n        for(var k=0; k<n; ++k)\n        {\n\
    \            if(l[i] == ans[k])\n            {\n                found = true;\n\
    \                break;\n            }\n        }\n        if(!found)\n      \
    \  {\n            ans[n] = l[i];\n            ++n;\n        }\n    }\n    return\
    \ ans;\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere is my solution:\n\
    <code>\npublic class Unique\n{\n    public static IEnumerable<T> Uniq<T>(IEnumerable<T>\
    \ source)\n    {\n        var seen = new HashSet<T>();\n        return source.Where(item\
    \ => seen.Add(item));\n    }", "{\n    if(l==null || l.length==0)\n        return\
    \ l;\n    long[] a=l.clone();\n    sort(a,0,a.length-1);\n    long[] a=null;\n\
    \    for(long i: l)\n        if(a.indexOf(i)<0)\n            a.add(i);\n    return\
    \ a;\n}", "{\n    long[] ans = null;\n    sort(l);\n    int i = 0;\n    foreach(long\
    \ x in l)\n    {\n        if(ans[i] == x)\n            i++;\n        else\n  \
    \          ans[i] = x;\n    }\n    return ans;\n}\n/*\nReturn sorted unique elements\
    \ in a vector\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(std::vector<long> v)\n{\n   \
    \ return unique(v.begin(), v.end());\n}", "{\n    var u = new long[l.length];\n\
    \    var hash = new std.typecons.HashedSet[long]();\n    for (int i = 0; i < l.length;\
    \ i++) {\n        if (!hash.contains(l[i]))\n        {\n            hash.add(l[i]);\n\
    \            u[i] = l[i];\n        }\n    }\n    return u;\n}", "{\n    if (l\
    \ == null) throw new IllegalArgumentException();\n    long[] lc = new long[l.length];\n\
    \    for (int i = 0; i < l.length; i++)\n        lc[i] = l[i];\n    Arrays.sort(lc);\n\
    \    return lc;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, Comparator<long> cmp) \n{\n    if (l == null) throw new\
    \ IllegalArgumentException();\n    if (cmp == null) cmp = (Comparator<long>)Long.compare;\n\
    \    long[] lc = new long[l.length];\n    for (int i = 0; i < l.length; i++)\n\
    \        lc[i] = l[i];\n    Arrays.sort(lc, cmp);\n    return lc;\n}\n/*\nReturn\
    \ sorted unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, IComparator<long> cmp) \n{\n    if (l == null) throw new IllegalArgumentException();\n\
    \    if (cmp == null) cmp = (IComparator<long>)Long.compare;\n    long[] lc =\
    \ new long[l.length];\n    for (int i = 0; i < l.length; i++)\n        lc[i] =\
    \ l[i];\n    Arrays.sort(lc, cmp);\n    return lc;\n}\n/*\nReturn sorted unique\
    \ elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, ISorted<long>\
    \ cmp) \n{\n    if (l == null) throw new IllegalArgumentException();\n    if (cmp\
    \ == null) cmp = (ISorted<long>)Long.compare;\n    long[] lc = new long[l.length];\n\
    \    for (int i = 0; i < l.length; i++)\n        lc[i] = l[i];\n    Arrays.sort(lc,\
    \ cmp);\n    return lc;\n}\n/*\nReturn sorted unique elements in an array\n  \
    \  >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L,\
    \ 123L]\n    \n*/\nlong[] unique(long[] l, Comparator<", "{\n    long[] result\
    \ = new long[l.length];\n    int i = 0; \n    while (i < l.length) \n    {\n \
    \      long v = l[i];\n       for (++i; i < l.length && v == l[i]; ++i) \n   \
    \    {\n           v = l[i];\n       }\n       result[i] = v;\n    }\n    \n \
    \   int j = 0;\n    while (j < result.length) \n    {\n        if (result[j] ==\
    \ 0) \n            continue;\n        for (int k = j+1; k < result.length && result[k]\
    \ == 0; ++k) \n        {\n           result[k] = result[k-1];\n        }\n   \
    \     --result[j];\n    }\n    return result;\n}\n/*\n  Return sorted unique elements\
    \ in an array\n  Remove duplicates\n    \n*/\nlong[] unique(long[] l, Comparator<long[]>\
    \ comparator) \n{\n    long[] result = new long[l.length];\n    int i = 0; \n\
    \    while (i < l.length) \n    {\n       long v = l[i];\n       for (++i; i <\
    \ l.length && v == l[i]; ++i) \n       {\n           v = l[i];\n       }\n   \
    \    result[i] = v;\n    }\n    \n    int j = 0;\n    while (j < result.length)\
    \ \n    {\n        if (result[j] == 0) \n            continue;\n        for (int\
    \ k = j+1; k < result.length && result[k] == 0; ++k) \n        {\n           result[k]\
    \ = result[k-1];\n        }\n        --result[j];\n    }\n    Arrays.sort(result,\
    \ new Comparator<long[]>() {\n        @Override \n        public int compare(long[]\
    \ o1, long[] o2) \n        {\n            return comparator.compare(o1, o2);\n\
    \        }\n    });\n    return result;\n}\n/*\n  Return sorted unique elements\
    \ in an array\n  Sort by comparator function\n    \n*/\nlong[] unique(long[] l,\
    \ Comparator<long[]> comparator) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0; \n    while (i < l.length) \n    {\n       long v = l[i];\n  \
    \     for (++i; i < l.length && v == l[i]; ++i) \n       {\n           v = l[i];\n\
    \       }\n       result[i] = v;\n    }\n    \n    int j = 0;\n    while (j <\
    \ result.length) \n    {\n        if (result[j] == 0) \n            continue;\n\
    \        for (int k = j+1; k < result.length && result[k] == 0; ++k) \n      \
    \  {\n           result[k] = result[k-1];\n        }\n        --result[j];\n \
    \   }\n    Arrays.sort(result, new Comparator<long[]>() {\n        @Override \n",
  "{\n  long[] x = l;\n  long[] y = new long[x.length];\n  for(int i = 0; i < x.length;\
    \ i++)\n    for(int j = 0; j < x.length; j++)\n      if (x[j] == x[i])\n     \
    \   y[j++] = x[j];\n  return y;\n}\n/*\nReturn sorted unique elements in an array\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int min, int max) \n{\n  long[]\
    \ x = l;\n  long[] y = new long[x.length];\n  for(int i = 0; i < x.length; i++)\n\
    \    for(int j = min + (i - min) % x.length; j < min + ((max - i) + x.length)\
    \ % x.length; j++)\n      if (x[j] == x[i])\n        y[j++] = x[j];\n  return\
    \ y;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(long[] l, int min, int max, int sort) {\n  int cmp;\n  long[] x = l;\n\
    \  long[] y = new long[x.length];\n  for(int i = 0; i < x.length; i++)\n    for(int\
    \ j = min + (i - min) % x.length; j < min + ((max - i) + x.length) % x.length;\
    \ j++)\n      if (x[j] == x[i])\n        y[j++] = x[j];\n  if (sort == 0)\n  \
    \  return y;\n  cmp = sort;\n  if(sort < 0)\n    cmp = -cmp;\n  Arrays.sort(y,\
    \ new LongComparator(cmp));\n  return y;\n}", "{\n    long[] u;\n    long k;",
  "{\n    long[] u = new long[l.length];\n    int j = 0;\n    for (int i = 0; i <\
    \ l.length; i++) {\n        if (u[j] == l[i]) {\n            j++;\n        }\n\
    \        u[j] = l[i];\n    }\n    return u;\n}\n</code>\n<|/ a |>\n<| a tags=c#,.net,arrays\
    \ dscore=1 |>\nI came up with a simple solution in C#. It is a variation of the\
    \ answer by Mike D. but in C# and using LINQ.\nThe code below uses this method\
    \ to create a hashset (as required by the question) and uses Linq to remove duplicates\
    \ from the hashset (as required by the question).\n<code>\n    private static\
    \ HashSet<string> GetUniqueStrings(string[] input)\n    {\n        var uniques\
    \ = input.Select(str => new { str = str }).Distinct().Select(x => x.str).ToArray();\n\
    \        return new HashSet<string>(uniques);\n    }\n</code>\n<|/ a |>\n<| a\
    \ |>\nHere is a simple way to do it: \n<code>", "{\n\tlong[] u = new long[l[l]];\n\
    \tint[] pos = new int[l[l]];", "{\n    long[] a = new long[l[l.length-1]];\n \
    \   int a_index = 0;\n    for(int i = 1; i < l.length; i++)\n    {\n        if(a[a_index]\
    \ == l[i])\n            continue;\n        a[a_index] = l[i];\n        a_index++;\n\
    \    }\n    return a;\n}", "{\n    long[] u=l.clone();\n    Arrays.sort(u);\n\
    \    return u;\n}\n/* \n Given a list of strings, return them in alphabetical\
    \ order\n \n >>> alphaOrder([\"alpha\", \"beta\", \"gamma\"])\n [\"alpha\", \"\
    beta\", \"gamma\"]\n \n */\nString[] alphaOrder(String[] l) \n{\n    Arrays.sort(l);\n\
    \    return l;\n}\n/*\n Given a list of strings, return them in numerical order\n\
    \ \n >>> numOrder([\"12\", \"2\", \"10\"])\n [10, 2, 12]\n \n */", "{\n    Set<long>\
    \ set = new HashSet<long>(l);\n    return set.toArray(new long[set.size()]);\n\
    }", "{\n  Arrays.sort(l);\n  long[] u = new long[l.length];\n  for (int i = 0;\
    \ i < l.length; ++i)\n    u[l[i]] = true;\n  Arrays.sort(u);\n  return u;\n}\n\
    </code>\n<|/ a |>\n<| c |>\nI didn't know you were allowed to write code inside\
    \ `std.algorithm` - that's a really neat idea!\n<|/ c |>\n<| a dscore=1 |>\n<code>\n\
    import std.algorithm;", "{\n\tint k = 0;\n\tint i, j;\n\tlong[] ans = new long[l.length];",
  "{\n    Arrays.sort(l);\n    long[] u = new long[l.length];\n    long h;\n    for(int\
    \ i=0; i<l.length; ++i)\n    {\n        h = l[i];\n        while(i != u.length-1\
    \ && h == u[i++])\n            ;\n        u[i] = h;\n    }\n    return u;\n}",
  "{\n\tvar sorted = l;\n\tstd.sort(sorted);\n\tlong last = sorted[0];\n\tlong[] result\
    \ = new long[std.partition(sorted, \"==\", last)];\n\tfor(int i=1; i < result.length;\
    \ ++i)\n\t{\n\t\tif(sorted[i]==last)\n\t\t\tcontinue;\n\t\t\n\t\tresult[--i-1]\
    \ = sorted[i];\n\t}\n\treturn result;\n}", "{\n\tlong[] u;\n\tint i, j;\n\tint\
    \ N=l.length;\n\tlong[] s=new long[N];\n\tu=new long[N];\n\tfor(i=0;i<N;++i) \n\
    \t{\n\t\tfor(j=0;j<N;++j) \n\t\t{\n\t\t\tif (l[i]==l[j]) \n\t\t\t\ts[l[j]]++;\n\
    \t\t\telse \n\t\t\t{\n\t\t\t\ts[l[i]]=1;\n\t\t\t\tu[i]=l[i];\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<N;++i) \n\t\tif (u[i]==i) \n\t\t\tu[i]=-1;\n\t\
    return u;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    double[] unique(double[] d)\n{\n\tdouble[] u;\n\tint i, j;\n\tint N=d.length;\n\
    \tdouble[] s=new double[N];\n\tu=new double[N];\n\tfor(i=0;i<N;++i) \n\t{\n\t\t\
    for(j=0;j<N;++j) \n\t\t{\n\t\t\tif (d[i]==d[j]) \n\t\t\t\ts[d[j]]++;\n\t\t\telse\
    \ \n\t\t\t{\n\t\t\t\ts[d[i]]=1;\n\t\t\t\tu[i]=d[i];\n\t\t\t\tbreak;\n\t\t\t}\n\
    \t\t}\n\t}\n\tfor(i=0;i<N;++i) \n\t\tif (u[i]==i) \n\t\t\tu[i]=-1;\n\treturn u;\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L,\
    \ 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/", "{\n\t\
    long a1 = l[0], a2 = l[1], a3 = l[2];\n\tlong b1 = l[3], b2 = l[4], b3 = l[5];\n\
    \tlong c1 = l[6], c2 = l[7], c3 = l[8];\n\tlong d1 = l[9], d2 = l[10], d3 = l[11];\n\
    \tlong e1 = l[12], e2 = l[13], e3 = l[14];\n\tlong f1 = l[15], f2 = l[16], f3\
    \ = l[17];\n\tlong g1 = l[18], g2 = l[19], g3 = l[20];\n\tlong h1 = l[21], h2\
    \ = l[22], h3 = l[23];\n\tlong i1 = l[24], i2 = l[25], i3 = l[26];\n\tlong j1\
    \ = l[27], j2 = l[28], j3 = l[29];\n\tlong k1 = l[30], k2 = l[31], k3 = l[32];\n\
    \tlong l1 = l[33], l2 = l[34], l3 = l[35];\n\t\n\tlong[] x = new long[35];\n\t\
    x[0] = a1; x[1] = a1; x[2] = a1; x[3] = a1; x[4] = a1; x[5] = a1;\n\tx[6] = a1;\
    \ x[7] = a2; x[8] = a2; x[9] = a2; x[10] = a2; x[11] = a2;\n\tx[12] = a2; x[13]\
    \ = a3; x[14] = a3; x[15] = a3; x[16] = a3; x[17] = a3;\n\tx[18] = a3; x[19] =\
    \ a4; x[20] = a4; x[21] = a4; x[22] = a4; x[23] = a4;\n\tx[24] = a4; x[25] = a5;\
    \ x[26] = a5; x[27] = a5; x[28] = a5; x[29] = a5;\n\tx[30] = a5; x[31] = a6; x[32]\
    \ = a6; x[33] = a6; x[34] = a6; x[35] = a6;\n\t\n\tlong[] p = new long[35];\n\t\
    p[0] = b1; p[1] = b1; p[2] = b1; p[3] = b1; p[4] = b1; p[5] = b1;\n\tp[6] = b1;\
    \ p[7] = b2; p[8] = b2; p[9] = b2; p[10] = b2; p[11] = b2;\n\tp[12] = b2", "{\n\
    \    int i, n, found = 0;\n    long[] res;\n    res = new (nothrow) long[l.length];\n\
    \    if (res == null) return null;\n    n = l[0];\n    res[0] = n;\n    for(i\
    \ = 1; i < l; i++) {\n        if (l[i] == n) continue;\n        res[i] = n;\n\
    \        n = l[i];\n        found = 1;\n    }\n    if (found == 0) return null;\n\
    \    return res;\n}\n/*\n>>> std.sort(longs)\n[5, 2, 3, 4, 9, 5, 3, 123]\n*/",
  "{\n\tlong[] x = sort(l);\n\tlong[] y = x;\n\tlong xc = 1, yc = 0;\n\tfor(int i\
    \ = 0; i < x.length; ++i) {\n\t\twhile(xc > x[i]) \n\t\t{\n\t\t\tint xi = i;\n\
    \t\t\twhile(xc > x[xi]) \n\t\t\t\txi = xi;\n\t\t\t\n\t\t\twhile(yc > y[xi]) \n\
    \t\t\t\tyc = yc;\n\t\t\t\n\t\t\tif(xi == yi) \n\t\t\t\tbreak;\n\t\t\t\n\t\t\t\
    yi = xi;\n\t\t\twhile(yc > y[yi]) \n\t\t\t\tyc = yc;\n\t\t}\n\t\t\n\t\tif(yc >\
    \ y[i]) {\n\t\t\tlong[] temp = new long[x.length];\n\t\t\tSystem.arraycopy(x,\
    \ 0, temp, 0, i);\n\t\t\tSystem.arraycopy(x, i, temp, i, x.length - i);\n\t\t\t\
    System.arraycopy(y, 0, temp, i, x.length - i);\n\t\t\tx = temp;\n\t\t\ty = temp;\n\
    \t\t\txc = 1;\n\t\t\tyc = 0;\n\t\t}\n\t\telse \n\t\t\tyc++;\n\t}\n\t\n\treturn\
    \ x;\n}", "{\n\tHashSet<long> hs;\n\ths.addAll(l);\n\treturn hs.toArray();\n}\n\
    /*\n    Return indices of unique elements in an array\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [1, 4, 0, 2, 6, 3, 8, 5, 9, 12]\n    \n\
    */\nlong[] uniqueIndices(long[] l)\n{\n\tHashSet<long> hs;\n\ths.addAll(l);\n\t\
    long[] res = new long[hs.size()];\n\tIterator<long> it = hs.iterator();\n\tint\
    \ i = 0;\n\twhile(it.hasNext()) {\n\t\tres[i++] = it.next();\n\t}\n\treturn res;\n\
    }", "{\n    long[] h=new long[l.length];\n    for(int i=0; i<l.length; i++)\n\
    \        h[l[i]]++;\n    long[] u=new long[l.length];\n    for(int i=0; i<l.length;\
    \ i++)\n        u[(h[l[i]]-1)]++;\n    \n    Arrays.sort(u);\n    for(int i=0;\
    \ i<l.length; i++)\n        l[i]=u[l[i]-1];\n    return l;\n}\n</code>\n<|/ a\
    \ tags=algorithm,sorting,arrays |>\n<| c |>\nI think your solution is better.\
    \ Thanks.\n<|/ c |>\n<| c |>\nIt seems good, but when I tried with your input\
    \ \"[5, 3, 3, 5, 2, 3]\", the result was \"[3, 3, 5, 2, 5, 3]\"\n<|/ c |>\n<|\
    \ c |>\nI'm sorry but I don't understand your comment. Are you using my code?\
    \ Or your own implementation? And how did you try the code? Just by copy&paste\
    \ it in your IDE and run it? Or did you modify the code? And what IDE did you\
    \ use?\n<|/ c |>\n<| c |>\nNope, your solution doesn't work if you run it on arrays\
    \ like [4, 1, 2, 4, 1], it returns [4, 1, 2, 4].\n<|/ c |>\n<| c |>\nIt returns\
    \ [4, 1, 2, 4]. Are you sure that you copied my code and run it? I have not changed\
    \ any code! It works correctly for me on any input array. How did you try it?\
    \ Using a code editor (such as Eclipse) or by running the code directly from the\
    \ console?\n<|/ c |>\n<| a tags=algorithm,sorting,arrays |>\nYou can use hashmap\
    \ to remove duplicate elements.\n<code>\n    int[] arr = {1, 4, 4, 3, 2, 2, 1};\n\
    \    List<Integer> list = new ArrayList<Integer>();\n    for(int i=0;i<arr.length;i++)\n\
    \    {\n        if(!list.contains(arr[i]))\n            list.add(arr[i]);\n  \
    \  }\n    list.stream().distinct().forEach(i->{\n        System.out.println(arr[i]);\n\
    \    });\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI hope this answer help you.\n\
    <|/ c |>\n<| c |>\n`List<Integer> list = new ArrayList<>();` won't compile, you\
    \ should use generics.\n<|/ c |>\n<| c |>\nYeah I missed to add generics while\
    \ writing the answer\n<|/ c |>\n<| a tags=algorithm,sorting,arrays |>\nThis is\
    \ one way to implement it. Time complexity is O", "{\n  // Sort and remove duplicates\n\
    \  long[] res = new long[uniqueCount(l)];\n  sort(l);\n  uniqueSort(l, res, 0,\
    \ res.length-1);\n  return res;\n}\n// Unsorted version\nlong[] unique(long[]\
    \ l, long[] reuse) \n{\n  // Sort and remove duplicates\n  long[] res = new long[uniqueCount(l)];\n\
    \  sort(l);\n  uniqueSort(l, res, 0, res.length-1, reuse);\n  return res;\n}\n\
    // Unsorted version with reuse", "{\n    long i=0, j=0, unique[] = new long[l.length];\
    \ \n    for(; i != l.length; i++) \n    {\n        for(j = 0; j != unique.length\
    \ - 1; j++) \n        {\n            if(l[i] == unique[j]) {\n               \
    \ j++; \n                if(j == unique.length) \n                {\n        \
    \            unique[j] = l[i]; \n                    break; \n               \
    \ } \n            }\n        }\n    }\n    return unique; \n} \n</code>\n<|/ a\
    \ |>\n<| c |>\nWhat do you mean? The return statement returns an array with the\
    \ unique numbers.\n<|/ c |>\n<| c |>\n`long[] unique(long[] l) \n{\n    long i=0,\
    \ j=0, unique[] = new long[l.length]; \n    for(; i != l.length; i++) \n    {\n\
    \        for(j = 0; j != unique.length - 1; j++) \n        {\n            if(l[i]\
    \ == unique[j]) {\n                j++; \n                if(j == unique.length)\
    \ \n                {\n                    unique[j] = l[i]; \n              \
    \      break; \n                } \n            }\n        }\n    }\n    return\
    \ unique; \n}`", "{\n    long[] r = new long[l.length];\n    sort(l);\n    for\
    \ (int i = 0; i < l.length; ++i) r[i] = l[i];\n    sort(r);\n    return r;\n}",
  "{\n    // Sort the array\n    Arrays.sort(l);\n    \n    // Unique elements\n \
    \   long[] ls = new long[l[l.length-1]];\n    int i = 0;\n    for (long e: l)\n\
    \    {\n        if (ls[e] == 0L)\n        {\n            ls[e] = 1;\n        \
    \    i++;\n        }\n        else\n        {\n            ls[e] += 1;\n     \
    \   }\n    }\n    \n    // Return unique elements\n    long[] result = new long[i\
    \ % ls.length];\n    for(int i = 0; i < ls.length; i++)\n    {\n        result[i%ls.length]\
    \ = ls[i];\n    }\n    return result;\n}\n</code>\n<|/ a |>\n<| a dscore=2 tags=arrays,java,sorting\
    \ |>\nI solved it this way:\n<code>\npublic static void main(String[] args) {\n\
    \    long[] array = {1L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L};\n    long[] sortedArray\
    \ = array;\n    Arrays.sort(array);\n    long lastElement = array[0];\n    boolean\
    \ hasRepeated = false;\n    Set<Long> elements = new HashSet<>();\n    for (int\
    \ i = 0; i < array.length; i++)\n    {\n        if (elements.add(array[i]))\n\
    \        {\n            lastElement = array[i];\n        }\n        else\n   \
    \     {\n            hasRepeated = true;\n        }\n    }\n    sortedArray[0]\
    \ = lastElement;\n    sortedArray = new long[array.length];\n    for(int i = 0;\
    \ i < array.length; i++)\n    {\n        sortedArray[i] = array[i];\n    }\n \
    \   if (!hasRepeated)\n    {\n        sortedArray = uniqueSort(sortedArray);\n\
    \    }\n    for(int i = 0; i < sortedArray.length; i++)\n    {\n        System.out.println(sortedArray[i]);\n\
    \    }\n}", "{\n    int n = l.length;\n    long[] a = std.arrayRange(0, n);\n\
    \    a.sort(std.lessThan);\n    long[] b = new long[n];\n    for(int i = 0; i\
    \ < n; ++i)\n    {\n        b[i] = a[i];\n    }\n    return b;\n}\n</code>\n<|/\
    \ a tags=arrays,c#,unique |>\n<| a dscore=2 |>\n<code>\npublic static int[] GetUnique(int[]\
    \ values)\n    {\n        // Find the unique values.\n        HashSet<int> uniqueValues\
    \ = new HashSet<int>();\n        foreach (int value in values)\n        {\n  \
    \          if (uniqueValues.Add(value))\n            {\n                continue;\n\
    \            }\n            else\n            {\n                break;\n    \
    \        }\n        }\n        // Return the unique values.\n        return uniqueValues.ToArray();\n\
    \    }\n</code>\n<|/ a tags=arrays,c#,unique |>\n<| c |>\nCan you explain why\
    \ this answer is correct? Please edit your answer by editing it. Code only answers\
    \ are generally not well received.\n<|/ c |>\n<| c |>\nI tested this and it doesn't\
    \ work. It seems to return values which are not unique, for example `int[] values\
    \ = new int[] { 6, 3, 3, 3, 6, 6, 6, 6 }`\n<|/ c |>\n<| c |>\n: It does not work\
    \ because duplicate values aren't allowed in the HashSet. See the second answer\
    \ on this question: http://stackoverflow.com/questions/16162426/c-sharp-unique-numbers-in-array\n\
    <|/ c |>\n<| a dscore=2 |>\nIf your C# version is prior to 4.0 (I didn't think\
    \ it was 4.0 as it was a couple of years since I looked at it) then you can also\
    \ try this:\n<code>\nvar distinctArray = arry\n            .GroupBy(x => x)\n\
    \            .OrderBy(x => x.Key)\n            .SelectMany(x => x.Take(1));\n\
    </code>\n<|/ a tags=arrays,c#,unique |>\n<| c |>\nThis does not work if your array\
    \ has duplicate values. The Take method will remove all duplicates.\n<|/ c |>\n\
    <| a tags=arrays,c#,unique dscore=1 |>\nFor those who prefer LINQ:\n<code>\npublic\
    \ static int[] GetUnique(int[] values)\n{\n    return values.Distinct().ToArray();\n\
    }\n</code>\n<|/ a |>\n<| a tags=arrays,c#,unique |>\n<code>\npublic IEnumerable<int>\
    \ Unique(int[] array)\n    {\n        List<int> list = new List<int>(array);\n\
    \        ", "{\n  if(l.length == 0) return l;\n  int n = l.length;\n  int i=1;\n\
    \  long[] a = new long[n];\n  while(i<n) {\n    if(l[i-1] == l[i])\n      i++;\n\
    \    else\n      a[i++] = l[i];\n  }\n  return a;\n}\n/*\nReturn unique elements\
    \ from an array\n    >>> unique([2L, 5L, 5L, 7L, 9L, 0L])\n    [5L, 7L, 9L]\n\
    \    \n*/\nlong[] unique(long[] l, int start, int end) \n{\n  if(l.length == 0)\
    \ return l;\n  if(start == end) return l;\n  int n = end - start + 1;\n  long[]\
    \ a = new long[n];\n  int i=0;\n  while(i<n) {\n    if(l[start+i] == l[end+i])\n\
    \      i++;\n    else\n      a[i++] = l[start+i];\n  }\n  return a;\n}\n/*\nReturn\
    \ unique elements from an array\n    >>> unique([2L, 5L, 5L, 7L, 9L, 0L, 123L])\n\
    \    [5L, 7L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int start, int end,\
    \ long val) \n{\n  if(l.length == 0) return l;\n  if(start == end) return l;\n\
    \  int n = end - start + 1;\n  long[] a = new long[n];\n  int i=0;\n  while(i<n)\
    \ {\n    if(l[start+i] == val)\n      i++;\n    else\n      a[i++] = l[start+i];\n\
    \  }\n  return a;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/",
  "{\n    long[] u = new long[l.length];\n    int j = 0;\n    for (int i=0; i < l.length;\
    \ i++) {\n        if (j != i && l[j] == l[i]) {\n            u[i] = l[j++];\n\
    \        } else {\n            u[i] = l[i];\n        }\n    }\n    return u;\n\
    }", "{\n    long result = long.MinValue;\n    long last = long.MaxValue;\n   \
    \ for (long i : l)\n    {\n        if (i == last)\n        {\n            continue;\n\
    \        }\n        else if (i > last)\n        {\n            result = i;\n \
    \           last = i;\n        }\n    }\n    long[] r = new long[l.length];\n\
    \    for (int i = 0; i < r.length; i++)\n    {\n        r[i] = (long)i;\n    }\n\
    \    return r;\n}\n</code>\n<|/ a tags=sorting,arrays,c# |>\n<| c |>\nJust beware:\
    \ If the original array is sorted, this will sort it *in place*. Depending on\
    \ the algorithm, this may or may not be a problem: it depends on the algorithm!\n\
    <|/ c |>\n<| a tags=sorting,arrays,c# dscore=2 |>\nThe simplest way would be to\
    \ use LINQ:\n<code>", "{\n\tlong tmp;\n\tint i, j, count;\n\tlong[] result = new\
    \ long[l.length];\n\tfor (i = 0; i < l.length; i++) \n\t{\n\t\ttmp = l[i];\n\t\
    \tcount = 0;\n\t\tfor (j = i; j < l.length; j++)\n\t\t{\n\t\t\tif (l[j] == tmp)\
    \ \n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (count ==\
    \ 1) \n\t\t{\n\t\t\tresult[i] = tmp;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tfor (j =\
    \ i; j < l.length; j++)\n\t\t\t{\n\t\t\t\tresult[j] = l[j];\n\t\t\t}\n\t\t}\n\t\
    }\n\tsort(result);\n\treturn result;\n}", "{\n    long[] u = new long[l.length];\n\
    \    for (int i = 0; i < u.length; ++i) \n        u[i] = l[i];\n    usort(u, l.length,\
    \ (x, y) => \n        x.compareTo((long) y) == 0 ? x : ((long) y).compareTo((long)\
    \ x) == 0 ? y : -1);\n    return u;\n}\n</code>\n<|/ a tags=c++,arrays |>\n<|\
    \ c |>\nwhy are you casting everything to `long`? `int` should be sufficient.\n\
    <|/ c |>\n<| c |>\n`int` is sufficient for arrays of length `<2^31-1`. It's less\
    \ space efficient than `long`. Casting is needed when you don't know what type\
    \ the array holds (because you can't use `sizeof` on array variables). So the\
    \ OP needs a function that can sort any `int[]` of any length.\n<|/ c |>\n<| c\
    \ |>\nYes, the casting is not needed - but why do you think it is needed? Casting\
    \ does not do anything useful when comparing types other than between same type\
    \ and same width.\n<|/ c |>\n<| c |>\nIf you don't know what type the array holds\
    \ then you can't use `sizeof`. Hence the `int[]`.\n<|/ c |>\n<| a tags=c++,arrays\
    \ dscore=0 |>\nHere's my take on it:\n<code>\n#include <iostream>\n#include <algorithm>\n\
    using namespace std;", "{\n    long[] a = l; \n    a.sort();\n    long[] b = new\
    \ long[a.length];\n    int k = 0;\n    for (int i = 0; i < a.length; i++)\n  \
    \  {\n        if (b[k] == a[i])\n            continue;\n        b[k++] = a[i];\n\
    \    }\n    return b;\n}\n</code>\nFor completeness I posted this answer to the\
    \ following question:\nHow do I sort an array in Java?\n<|/ a tags=java,sorting\
    \ |>\n<| a dscore=1 tags=java,sorting |>\nI think this is a simple one. \n<code>\n\
    import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\
    import java.util.stream.Collectors;\nimport java.util.stream.Stream;", "{\n  \
    \  List<long> result = new List<long>();\n    long[] sorted = l.ToArray();\n \
    \   Arrays.sort(sorted);\n    for (int i = 0; i < sorted.Length; i++) {\n    \
    \    if (!result.Contains(sorted[i]))\n            result.Add(sorted[i]);\n  \
    \  }\n    return result.ToArray();\n}", "{\n\tlong[] res = new long[l.length];\n\
    \tint[] noDupe = new int[l.length];\n\tint[] noDupe2 = new int[l.length];\n\t\
    for (int i = 0; i < l.length; i++)\n\t{\n\t\tnoDupe[i] = 0;\n\t\tnoDupe2[i] =\
    \ 0;\n\t}\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (noDupe[l[i]] ==\
    \ 0)\n\t\t{\n\t\t\tres[noDupe[l[i]]] = l[i];\n\t\t\tnoDupe[l[i]]++;\n\t\t}\n\t\
    \telse\n\t\t{\n\t\t\tnoDupe2[l[i]]++;\n\t\t}\n\t}\n\tint[] noDupe3 = new int[noDupe.length];\n\
    \tfor (int i = 0; i < noDupe.length; i++)\n\t{\n\t\tif (noDupe2[i] == noDupe[i])\n\
    \t\t{\n\t\t\tnoDupe3[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnoDupe3[i] = noDupe2[i];\n\
    \t\t}\n\t}\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (noDupe3[l[i]] ==\
    \ noDupe[l[i]])\n\t\t{\n\t\t\tnoDupe3[l[i]]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\
    res[noDupe[l[i]]] = l[i];\n\t\t\tnoDupe[l[i]]++;\n\t\t}\n\t}\n\treturn res;\n}",
  "{\n    long[] result = new long[l.length];\n    int j = 0;\n    int i = 0;\n  \
    \  for(; i < l.length; ++i) \n    {\n        if(result[j] == l[i]) \n        \
    \    continue;\n        result[j] = l[i];\n        ++j;\n    }\n    return result.subarray(0,\
    \ j);\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis code is very interesting,\
    \ and I think it is very easy to understand. However, for me it seems to miss\
    \ some important details. For example, in your second loop, you set the `j` variable\
    \ to `i` and then compare with `l[i]`. But if you have an array of size 10, the\
    \ condition would be `l[i] < 10`, where `l` is the array. How can you avoid this?\
    \ Maybe the algorithm can be changed to avoid this?\n<|/ c |>\n<| c |>\nTo be\
    \ honest, I wrote this just before I saw this comment. I'm pretty sure this doesn't\
    \ work as intended, but I don't have time to test it now. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nThis is by far the best solution I've seen here\
    \ so far, even for large arrays.\n<|/ c |>\n<| c |>\nI haven't used the std lib\
    \ for years, I've never come across this algorithm before, thank you for sharing!\n\
    <|/ c |>\n<| c |>\nThis was a very helpful answer, and should be the top answer.\
    \ Thanks.\n<|/ c |>\n<| a |>\nHere is an interesting solution, using an additional\
    \ variable:\n<code>", "{\n    long[] res = new long[l];\n    long last = 0;\n\
    \    int i = 0;\n    foreach(i, l) \n    {\n        if(l == i) \n        {\n \
    \           res[i - 1] = l;\n        }\n        else\n        {\n            if(last\
    \ < l) \n            {\n                res[i - 1] = l;\n            }\n     \
    \       else\n            {\n                res[i - 1] = last;\n            }\n\
    \            last = l;\n        }\n    }\n    return res;\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI wonder whether I really need the std.array. The std.array is\
    \ actually quite useful (it allows me to use the foreach loop). Unfortunately\
    \ it does require the unsafe keyword which I don't really want to use (as far\
    \ as I understand I shouldn't have to use unsafe for something that isn't really\
    \ unsafe). In fact I am already using the std.array (for other purposes). I can\
    \ easily replace it with the std.array of the other solution and get rid of the\
    \ unsafe keyword.\n<|/ c |>\n<| a dscore=2 |>\n<code>\npublic static IEnumerable<T>\
    \ Unique<T>(this IEnumerable<T> source)\n{\n    var seen = new HashSet<T>();\n\
    \    return source.Where(e => seen.Add(e));\n}\n</code>\n<|/ a tags=c#,linq,unique\
    \ |>\n<| a tags=c#,linq,unique |>\n<code>", "{\n\tlong[] result = new long[l.length];\n\
    \tint j = 0;\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\twhile (j < result.length\
    \ && l[i] == result[j])\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tresult[j] = l[i];\n\t}\n\
    \tArrays.sort(result);\n\treturn result;\n}", "{\n    int m = l.length;\n    long[]\
    \ u = new long[m];\n    int j = 0;\n    int k = -1;\n    for (int i=0; i<m; i++)\n\
    \    {\n        if (u[j] == l[i])\n        {\n            k = i;\n        }\n\
    \        else\n        {\n            if (k != -1)\n            {\n          \
    \      u[k] = l[i];\n                j++;\n                k = -1;\n         \
    \   }\n        }\n    }\n    return u;\n}", "{\n    long[] result = new long[l.length];\n\
    \    \n    for (int i = 0; i < l.length; ++i)\n    {\n        int j = 0;\n   \
    \     while (j < result.length && l[i] != result[j])\n            ++j;\n     \
    \   result[j++] = l[i];\n    }\n    \n    return Arrays.sort(result);\n}\n</code>\n\
    <|/ a tags=sorting,arrays,java,algorithm |>\n<| a dscore=2 tags=sorting,arrays,java,algorithm\
    \ |>\nHere's my implementation:\n<code>\n/**\n * Return sorted unique elements\
    \ in an array\n *\n * <T> data type\n * array data\n * sorted unique elements\
    \ in an array\n */\npublic static <T> T[] unique(T[] array) {\n    Arrays.sort(array);\n\
    \    List<T> list = new ArrayList<>(Arrays.asList(array));\n    Collections.sort(list);\n\
    \    return list.toArray(new T[list.size()]);\n}\n</code>\n<|/ a |>\n<| a tags=sorting,arrays,java,algorithm\
    \ |>\n<code>\npublic static <T> void ArraySort(T[] A) {\nArrays.sort(A);\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 tags=sorting,arrays,java,algorithm |>\n\
    You can use Arrays.sort method.\n<|/ a |>\n<| c |>\nNote that this would sort\
    \ in the reverse order compared to the OP's requirement. The OP's question states:\
    \ _sort it in a way that each repetition of the same element appears before the\
    \ next repetition_ instead of _sort it in order of the element_.\n<|/ c |>\n<|\
    \ c |>\nYes, you are right, i wrote that before he edited his post to make it\
    \ more clear.\n<|/ c |>\n<| a dscore=1 tags=sorting,arrays,java,algorithm |>\n\
    Use HashSet\n<code>\npublic static void main(String[] args) {\n    int[] array\
    \ = {1,2,1,3,3,4,4,5};\n    int[] unique = new int[array.length];\n    HashSet<Integer>\
    \ set = new HashSet<Integer>();\n    for(int i=0; i<array.length; i++)\n     \
    \   if(!set.contains(array[i]))\n            set.add(i);\n    for(int i=0; i<array.length;\
    \ i++)\n        unique[i] = set.contains(array[i]) ? array[i] : array[i];\n  \
    \  System.out.println(Arrays.toString(unique));\n}\n</code>\n<|/ a |>\n<| a tags=sorting,arrays,java,algorithm\
    \ |>\n<code>\nimport java.util.*;", "{\n    long[] result = new long[l[0].CompareTo(l[1])];\
    \ \n    int i = 0; \n    for(int k=1; k<l.length; k++)\n    {\n        while(result.Contains(l[i]))\n\
    \        {\n            i++; \n        }\n        result[result.length] = l[i];\
    \ \n        i++; \n    }\n    return Arrays.copyOfRange(result,1,result.length);\
    \ \n}\n</code>\n<|/ a |>\n<| a dscore=0 |>\nUsing a custom comparer (based on\
    \ ArrayList's compareTo implementation) for a sorted ArrayList is probably the\
    \ most efficient way to do this, but if you do want to write your own solution\
    \ that's also doable.  The key is to first convert the input list to a LinkedList,\
    \ which can have O(1) random access, since the entire array is always accessed\
    \ at once.  Then, use a merge algorithm to sort the list by iterating from the\
    \ beginning to the end.  Here's the code to do this:\n<code>\npublic static <T>\
    \ List<T> mergeSort(List<T> input)\n{\n    // First convert the input to a LinkedList,\
    \ which is fast-access\n    LinkedList<T> list = new LinkedList<T>(input);", "{\n\
    \    long[] result = new long[l.length];\n    int j = 0;\n    int i;\n    for(i\
    \ = 0; i < l.length; i++) \n    {\n        while(j > 0 && l[j] == l[j-1]) \n \
    \       {\n            j--;\n        }\n        result[j] = l[i];\n        j++;\n\
    \    }\n    result.length = j;\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, int left, int\
    \ right) \n{\n    long[] result = new long[right-left+1];\n    int j = 0;\n  \
    \  int i;\n    for(i = left; i < right; i++) \n    {\n        while(j > 0 && l[j]\
    \ == l[j-1]) \n        {\n            j--;\n        }\n        result[j] = l[i];\n\
    \        j++;\n    }\n    result.length = j;\n    return result;\n}\n/*\nReturn\
    \ sorted unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[]\
    \ l, int left, int right, int fromIndex) \n{\n    long[] result = new long[right-left+1];\n\
    \    int j = 0;\n    int i;\n    for(i = left; i < right; i++) \n    {\n     \
    \   while(j > 0 && l[j] == l[j-1]) \n        {\n            j--;\n        }\n\
    \        result[j] = l[i];\n        j++;\n    }\n    result.length = j;\n    return\
    \ result;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L,\
    \ 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\n\
    long[] unique(long[] l, int left, int right, int fromIndex, int toIndex) \n{\n\
    \    long[] result = new long[right-left+1];\n    int j = 0;\n    int i;\n   \
    \ for(i = left; i < right; i++) \n    {\n        while(j > 0 && l[j] == l[j-1])\
    \ \n        {\n            j--;\n        }\n        result[j] = l[i];\n      \
    \  j++;\n    }\n    result.length = j;\n    return result;\n}\n/*\nReturn sorted\
    \ unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9", "{\n\
    \  Arrays.sort(l);\n  int n = l.length;\n  long[] result = new long[n];\n  for(int\
    \ i = 0; i < n; ++i) {\n    if(i != l[i]) \n      result[i] = l[i];\n  }\n  return\
    \ result;\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nIt is not necessary to sort\
    \ - it is sufficient to have a `HashSet` of seen elements.\n<|/ c |>\n<| c |>\n\
    Yes you are right but as for me it is easier to understand when it is sorted.\n\
    <|/ c |>\n<| c |>\nTrue. I was speaking from the point of view of OP's \"this\
    \ algorithm is not very efficient\". HashSet is probably the best implementation\
    \ for this.\n<|/ c |>\n<| a tags=arrays,sorting,c# |>\nI would use Linq.  Here\
    \ is an example:\n<code>", "{\n\tstd.sort(l);\n\t\n\tlong u;\n\t\n\tfor (int i\
    \ = 0; i < l.size(); i++)\n\t{\n\t\tif (l[i] == l[l.size() - 1 - i])\n\t\t{\n\t\
    \t\tl[l.size() - 1 - i] = 0;\n\t\t\tl = l;\n\t\t}\n\t\t\n\t\tu = l[i];\n\t\tfor\
    \ (int j = i; j < l.size(); j++)\n\t\t\tif (l[j] != u)\n\t\t\t\tl[j] = 0;\n\t\
    }\n\t\n\treturn l;\n}", "{\n    long count = 0; \n    long[] u = new long[l.length];\n\
    \    for (int i = 0; i < l.length; i++) \n    {\n        u[count++] = l[i]; \n\
    \    }\n    sort(u, count);\n    return u;\n}\n// Returns sorted unique elements\
    \ in an array\nlong[] unique(long[] l, int count) \n{\n    long[] u = new long[count];\n\
    \    int j = 0;\n    for (int i = 0; i < l.length; i++) \n    {\n        u[j++]\
    \ = l[i]; \n    }\n    sort(u, j);\n    return u;\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThis is not an answer to the question. Maybe it should be a comment\
    \ on the question?\n<|/ c |>\n<| c |>\nI agree it should be a comment but its\
    \ not an answer - it is just the code - i think it is useful and may be of help\
    \ to someone else in the future (as I did) so it is an answer\n<|/ c |>\n<| a\
    \ tags=algorithm,arrays,sorting,java,unique |>\nAs someone said the best solution\
    \ is O(n). But you can optimize the unique function so that its O(nlogn). I did\
    \ it by converting my original array to a map, then sort it by the key, then I\
    \ got rid of duplicate values by checking if the value is already in that map\
    \ or not.\n<|/ a dscore=0 |>\n<| c |>\nPlease edit your answer and add your solution\
    \ as an edit, so you can properly format it. Also, please include some code to\
    \ show how you solved it.\n<|/ c |>\n<| c |>\ni wrote it here in comments, but\
    \ it took too long to write so i posted it as answer. you can find it on [my website](http://dalexandermusz.wordpress.com/2011/05/06/java-implementation-of-n-log-log-unique-elements-algorithm/)\n\
    <|/ c |>\n<| c |>\nIt would be better to post the code as part of the answer,\
    \ and then link to the source.\n<|/ c |>\n<| a tags=algorithm,arrays,sorting,java,unique\
    \ dscore=0 |>\nHere is my solution in Python. It uses the fact that Python sets\
    \ preserve their unique members, so we get unique elements automatically by just\
    \ removing duplicates.\n<code>\ndef unique(l):\n    s = set()\n    return list(s)\n\
    </code>\n<|/ a |>\n<| c |>\nYour code is incorrect as it removes duplicates from\
    \ `l`, but the question wants the unique elements *from* `l`.\n<|/ c |>", "{\n\
    \  long[] result = new long[l.length];\n  long previous = 0;\n  for (long e :\
    \ l) \n  {\n    if (e == previous)\n    {\n      continue;\n    }\n    previous\
    \ = e;\n    long i = binarySearch(result, e);\n    if (i < 0)\n    {\n      i\
    \ = 0;\n    }\n    result[i] = e;\n  }\n  return result;\n}", "{\n  return sort(l);\n\
    }", "{\n    long[] ans = l.clone();\n    \n    for(int i = 0; i < ans.length;\
    \ i++)\n    {\n        for(int j = i+1; j < ans.length; j++)\n        {\n    \
    \        if(ans[i] > ans[j])\n            {\n                long tmp = ans[i];\n\
    \                ans[i] = ans[j];\n                ans[j] = tmp;\n           \
    \ }\n        }\n    }\n    return ans;\n}\n</code>\nThe code is tested and works\
    \ fine.\n<|/ a dscore=1 |>\n<| a |>\n<code>\n#include <iostream>\nusing namespace\
    \ std;", "{\n    int i = 1;\n    int j = 0;\n    long[] u = new long[l[l]];\n\
    \    while (i < l) {\n        while (j == i) {\n            j = i;\n         \
    \   i += 1;\n        }\n        if (l[i] != l[j]) {\n            u[l[i]] = l[j];\n\
    \            while (j < l) {\n                l[j] = l[j + 1];\n             \
    \   j += 1;\n            }\n            j = 1;\n        }\n        i += 1;\n \
    \   }\n    return u;\n}", "{\n    long[] r = new long[l.length];\n    std.arraycopy(l,\
    \ 0, r, 0, l.length);\n    std.sort(r);\n    return r;\n}", "{\n    long[] a =\
    \ new long[l.length];\n    long counter = 0;\n    int pos = 0;", "{\n  long[]\
    \ u;\n  int i, j, i2;", "{\n    long[] a = l;\n    Arrays.sort(a);\n    return\
    \ a;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/", "{\n\
    \    return unique(l,false);\n}\n/*\nReturn sorted unique elements in an array\n\
    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n[0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] unique(long[] l,bool ascending)\n{\n    List<long> ls = new\
    \ ArrayList<long>();\n    for (long i : l)\n    {\n        if (ls.contains(i))\
    \ {\n            continue;\n        }\n        ls.add(i);\n    }\n    if (ascending)\n\
    \        return ls.toArray(new long[(int)ls.size()]);\n    else\n        return\
    \ ls.descendingCopy().toArray(new long[(int)ls.size()]);\n}\n/*\nReturn sorted\
    \ unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l,int\
    \ len)\n{\n    return unique(l,false,len);\n}\n/*\nReturn sorted unique elements\
    \ in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l,bool ascending,int len)\n\
    {\n    List<long> ls = new ArrayList<long>();\n    for (long i : l)\n    {\n \
    \       if (ls.contains(i)) {\n            continue;\n        }\n        ls.add(i);\n\
    \    }\n    if (ascending)\n        return ls.toArray(new long[(int)ls.size()]);\n\
    \    else\n        return ls.descendingCopy().toArray(new long[(int)ls.size()]);\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L,\
    \ 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(long[] l,int len,int maxlen)\n{\n    return unique(l,false,len,maxlen);\n\
    }\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L, 5L,\
    \ 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[]\
    \ unique(long[] l,bool ascending,int len,int maxlen)\n{\n    List<long> ls = new\
    \ ArrayList<", "{\n    long x = l[0];\n    long[] v = new long[l[l].count()+1];\n\
    \    for (int i = 0; i < l[l].count(); i++) \n    {\n        long y = l[i];\n\
    \        if (x != y) \n        {\n            v[i] = x;\n            x = y;\n\
    \        }\n    }\n    v[l[l].count()] = x;\n    return v;\n}\n// returns true\
    \ if all elements of v are in l", "{\n    long[] u = new long[l.length];\n   \
    \ long[] l1 = sort(l);\n    long[] l2 = sort(u);\n    sort(l1, l2);\n    return\
    \ u;\n}", "{\n  return sort(l, (a => a == null), \n            (a1 => a1 == null\
    \ ? 1 : a1 > a1 ? 1 : -1));\n}", "{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    foreach (long x in l)\n    {\n        for (int j = i; j <\
    \ l.length; j++)\n        {\n            if (l[j] == x)\n                break;\n\
    \        }\n        if (j < l.length)\n            result[i++] = x;\n    }\n \
    \   return result;\n}", "{\n\tlong[] result = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++) {\n\t\tlong current = l[i];\n\t\tfor (int j = 0; j\
    \ < i; j++) {\n\t\t\tif (l[j] == current) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\
    \t}\n\t\t}\n\t\tresult[i] = current;\n\t}\n\treturn result;\n}", "{\n\tlong oldval\
    \ = -1L, newval = 0L;\n\tlong lastval = -1L;\n\tbool swap = false;\n\tfor (int\
    \ i = 0; i < l.length; ++i) \n\t{\n\t\tif (l[i] != oldval) \n\t\t{\n\t\t\tswap\
    \ = false;\n\t\t\tnewval = l[i];\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif (l[i] == lastval)\
    \ \n\t\t\t{\n\t\t\t\tswap = true;\n\t\t\t\tnewval = lastval + l[i];\n\t\t\t}\n\
    \t\t\telse\n\t\t\t{\n\t\t\t\tlastval = newval;\n\t\t\t}\n\t\t}\n\t\toldval = newval;\n\
    \t}\n\tif (swap == false) \n\t{\n\t\treturn l;\n\t}\n\tlong[] out = new long[l];\n\
    \tout[0] = oldval;\n\tfor (int i = 1; i < l.length; ++i) \n\t{\n\t\tout[i] = l[i\
    \ - 1];\n\t}\n\treturn out;\n}", "{\n    long[] r = new long[l.length];\n    int\
    \ j = 0;\n    for (int i=0; i<l.length; ++i) {\n        while (r[j] != l[i])\n\
    \            j++;\n        r[j++] = l[i];\n    }\n    return r;\n}\n/*\nReturn\
    \ the number of occurrences of x in l\n    \n>>> x = [1,2,2,2,3,5,6,7,8,8,9,7,3,5,6,7]\n\
    >>> count(x, 2)\n4\n    \n*/", "{\n    int last, mid, i, j;\n    long count =\
    \ 1;\n    \n    last = l.length - 1;\n    mid = last/2;\n    \n    while (count\
    \ < mid && last >= 0) \n    {\n        i = l[last];\n        j = l[mid];\n   \
    \     \n        if (i != j) \n        {\n            if (count < mid) \n     \
    \       {\n                l[last] = l[mid];\n            }\n            else\n\
    \            {\n                l[mid] = l[last];\n            }\n           \
    \ last--;\n            \n            mid--;\n            \n            if (count\
    \ < mid) \n            {\n                count++;\n            }\n          \
    \  else\n            {\n                count = 1;\n            }\n        }\n\
    \        \n        if (last >= 0) \n        {\n            i = l[last];\n    \
    \        j = l[mid];\n            \n            if (i != j) \n            {\n\
    \                if (count < mid) \n                {\n                    l[last]\
    \ = l[mid];\n                }\n                else\n                {\n    \
    \                l[mid] = l[last];\n                }\n                last--;\n\
    \                \n                mid--;\n                \n                if\
    \ (count < mid) \n                {\n                    count++;\n          \
    \      }\n                else\n                {\n                    count =\
    \ 1;\n                }\n            }\n        }\n    }\n    \n    return l;\n\
    }", "{\n    long result = 0;\n    foreach(int item, l)\n    {\n        if(item\
    \ != result)\n        {\n            result = item;\n        }\n    }\n    return\
    \ newArrayWith(result, l);\n}", "{\n    long[] r = new long[l.length];\n    long[]\
    \ a = new long[l[l.length-1]];\n    long u = 0;\n    bool flag = false;\n    for(int\
    \ i = 0; i < l.length; i++){\n        if(u < l[i]){\n            u=l[i];\n   \
    \         flag = false;\n        }\n        else{\n            for(int j = 0;\
    \ j < a.length; j++){\n                if(a[j] < u){\n                    flag\
    \ = true;\n                    break;\n                }\n            }\n    \
    \        if(flag == false){\n                r[i] = l[i];\n            }\n   \
    \     }\n    }\n    return r;\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nNice idea,\
    \ but if one has a long list of unique numbers, sorting them will take O(n log\
    \ n) instead of O(n).\n<|/ c |>\n<| c |>\nThe unique method has two nested for\
    \ loops, both of which will require O(n log n), therefore the total is O(n log\
    \ n), however it also runs in O(n) time.\n<|/ c |>\n<| c |>\nthe unique method\
    \ does in fact have a nested for loop, it does it three times. However I see now\
    \ that it is unecessary and I see why that is. However, still I do not think that\
    \ it is O(n log n).\n<|/ c |>\n<| c |>\nOh, you're right. I misread the algorithm,\
    \ sorry. However, I think there is still a O(n) solution for finding the unique\
    \ numbers in the array.\n<|/ c |>\n<| a tags=sorting,algorithm,java |>\n<code>\n\
    class LongComparator\n{\n   public int compare(Long a, Long b)\n   {\n       if\
    \ (a==b)\n       {\n           return 0;\n       }\n       if (a==null)\n    \
    \   {\n           return 1;\n       }\n       if (b==null)\n       {\n       \
    \    return -1;\n       }\n       return Long.compare(a, b);\n   }\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nIt would be better to use a comparator which returns\
    \ `Long.compare(lhs, rhs)`.\n<|/ c |>\n<| c |>\nThis isn't O(n). For a long list,\
    \ there are 2^32 different numbers, so it would be O(2^32), which is way too slow.\n\
    <|/ c |>\n<| c |>\nAh, I thought you meant sort... I thought you were just trying\
    \ to remove the duplicates.\n<|/ c |>\n<| c ", "{\n\tlong result = 0;\n\t\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tlong tmpResult = l[i];\n\t\t\n\t\
    \tfor (int j = i + 1; j < l.length; j++) \n\t\t{\n\t\t\tif (l[j] == tmpResult)\n\
    \t\t\t{\n\t\t\t\tj = l.length;\n\t\t\t}\n\t\t\t\n\t\t\tif (l[j] != tmpResult)\
    \ \n\t\t\t{\n\t\t\t\tl[j - i - 1] = tmpResult;\n\t\t\t\tresult = tmpResult;\n\t\
    \t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn l;\n}", "{\n  var ans = Array[int](l);\n\
    \  var h = new HashSet[int](l);\n  for(i <- 0 until l) \n    if(h.add(l[i]))\n\
    \      ans[l[i]] = 1;\n  return ans;\n}", "{\n\t// find unique elements\n\tlong[]\
    \ result = new long[l.length];\n\tfor(int i=0; i<l.length; ++i) {\n\t\tfor(int\
    \ j=i+1; j<l.length; ++j) {\n\t\t\tif(l[i] == l[j])\n\t\t\t\tbreak;\n\t\t}\n\t\
    \tif(j==l.length)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn\
    \ the number of items in an array\n    >>> count(5L)\n    1\n    \n*/", "{\n \
    \   \n    if(l.length==0) return l;\n    \n    long first = l[0];\n    \n    for(int\
    \ i=0; i<l.length; i++) \n    {\n        if(l[i]!=first)\n        {\n        \
    \    long last = l[i];\n            for(int j=i; j<l.length; j++) \n         \
    \   {\n                l[j]=last;\n            }\n            break;\n       \
    \ }\n    }\n    return l;\n}", "{\n    long[] u = new long[l[l.length-1]];\n \
    \   int j = 0;\n    for (int i=0; i < l.length; i++)\n    {\n        if (u[j]\
    \ == l[i])\n            continue;\n        u[j] = l[i];\n        j++;\n    }\n\
    \    return u;\n}", "{\nlong[] rd = new long[l.length];\nfor(int i = 0; i < l.length;\
    \ i++) \n{\n    if(l[i] != i) \n    {\n        rd[l[i]] = l[i];\n    }\n}\nreturn\
    \ rd;\n}\n/*\nReturn sorted unique elements in an array\n>>> unique([5L, 3L, 5L,\
    \ 2L, 3L, 3L, 9L, 0L, 123L])\n[123L, 0L, 2L, 3L, 5L, 9L]\n*/\nlong[] unique(long[][]\
    \ rd)\n{\nlong[] l = new long[rd.length];\nfor(int i = 0; i < rd.length; i++)\
    \ \n{\n    l[i] = rd[i][0];\n}\nreturn l;\n}\n/*\nReturn sorted unique elements\
    \ in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long[] rd)\n{\nlong[]\
    \ ld = new long[l.length];\nfor(int i = 0; i < l.length; i++) \n{\n    if(l[i]\
    \ != i) \n    {\n        ld[l[i]] = l[i];\n    }\n}\nlong[] rdo = new long[rd.length];\n\
    for(int i = 0; i < rd.length; i++) \n{\n    rdo[i] = rd[i];\n}\nreturn unique(ld,rdo);\n\
    }\n/*\nReturn sorted unique elements in an array\n>>> unique([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n[123L, 0L, 2L, 3L, 5L, 9L]\n*/\nlong[] unique(long[][]\
    \ l, long[][] rd)\n{\nlong[] ld = new long[l.length];\nfor(int i = 0; i < l.length;\
    \ i++) \n{\n    ld[i] = l[i][0];\n}\nlong[] rdo = new long[rd.length];\nfor(int\
    \ i = 0; i < rd.length; i++) \n{\n    rdo[i] = rd[i][0];\n}\nreturn unique(ld,rdo);\n\
    }\n</code>\n<|/ a dscore=0 |>\n<| c |>\nHow can you make sense of the code above\
    \ without knowing the language used? It would be better to explain how these methods\
    \ work.\n<|/ c |>\n<| a tags=arrays,sorting,algorithm,language-agnostic |>\nThis\
    \ can be done in O(n) time and O(1) space.\n<code>\nprivate void sort(int[] a)\n\
    {\n    // sort by first number\n    int first = a", "{\n    long[] ret = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i) {\n        ret[i] = l[i];\n    }\n    Arrays.sort(ret);\n\
    \    return ret;\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=sorting,optimization,algorithm,big-o\
    \ dscore=2 |>\nI took the code of Elias Van Ootegem and wrote it in Java. The\
    \ code is self-explanatory.\n<code>\npublic static long unique(long[] array) {\n\
    \    Set<Long> set = new HashSet<Long>();\n    Long[] ret = new Long[array.length];\n\
    \    for (int i = 0; i < array.length; i++) {\n        set.add((long) array[i]);\n\
    \        ret[i] = set.size() - 1;\n    }\n    Arrays.sort(ret);\n    return ret[array.length-1];\n\
    }\n</code>\n<|/ a |>\n<| a dscore=2 |>\nI wrote a similar one in Python for the\
    \ challenge. Worked for me in O(nlogn) and O(n) time.\n<code>\ndef uniqueInOrder(arr):\n\
    \    seen = set()\n    unique = []\n    i = 0\n    while i < len(arr):\n     \
    \   if arr[i] in seen:\n            unique.append(arr[i])\n        else:\n   \
    \         seen.add(arr[i])\n        i += 1\n    unique.reverse()\n    return unique\n\
    </code>\n<|/ a tags=sorting,optimization,algorithm,big-o |>\n<| a tags=sorting,optimization,algorithm,big-o\
    \ dscore=2 |>\nI wrote a solution in Java which runs in O(nlogn) time for an array\
    \ of size upto 10^7.\n<code>\nimport java.util.Arrays;\nimport java.util.List;\n\
    import java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\nimport\
    \ java.util.stream.IntStream;", "{\n\t// This could have been made faster with\
    \ some trickery with bit operations.\n\t// But this seems simpler, and should\
    \ probably be fast.", "{\n\tlong[] out = new long[l.length];\n\tint[] count =\
    \ new int[l.length];\n\t\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tcount[l[i]]++;\n\
    \t}\n\t\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (count[l[i]] == 1)\n\
    \t\t{\n\t\t\tout[l[i]] = l[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j = i+1;\
    \ j < l.length; j++)\n\t\t\t{\n\t\t\t\tif (l[i] != l[j])\n\t\t\t\t{\n\t\t\t\t\t\
    if (count[l[j]] > 1) count[l[j]] -= 1; else i--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    }\n\t\n\treturn out;\n}\n/*\nReturn array of unique elements in an array\n\t>>>\
    \ unique(array.array('L', [5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L]))\n\tarray('L',\
    \ [0L, 2L, 3L, 5L, 9L, 123L])\n*/\npublic static native long[] unique(long []l)\
    \ /*-{\n\tvar out = new long[l.length];\n\tvar count = new int[l.length];\n\t\
    for (var i=0; i < l.length; i++)\n\t\tcount[l[i]]++;\n\t\n\tfor (var i=0; i <\
    \ l.length; i++)\n\t{\n\t\tif (count[l[i]] == 1)\n\t\t\tout[l[i]] = l[i];\n\t\t\
    else\n\t\t{\n\t\t\tfor (var j = i+1; j < l.length; j++)\n\t\t\t{\n\t\t\t\tif (l[i]\
    \ != l[j])\n\t\t\t\t{\n\t\t\t\t\tif (count[l[j]] > 1) count[l[j]] -= 1; else i--;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n}-*/;\n/*\nReturn array of unique\
    \ elements in an array\n\t>>> unique(array.array('L', [5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L]))\n\tarray('L', [0L, 2L, 3L, 5L, 9L, 123L])\n*/\npublic static\
    \ native long[] unique(long[] l) /*-{\n\tvar out = new long[l.length];\n\tvar\
    \ count = new int[l.length];\n\tfor (var i=0; i < l.length; i++)\n\t\tcount[l[i]]++;\n\
    \t\n\tfor (var i=0; i < l.length; i++)\n\t{\n\t\tif (count[l[i]] == 1)\n\t\t\t\
    out[l[i]] = l[i];\n\t\telse\n\t\t{\n\t\t\tfor (var j = i+1; j < l.length; j++)\n\
    \t\t\t{\n\t\t\t\tif (l[i] != l[j])\n\t\t\t\t{\n\t\t\t\t\tif (count[l[j]] > 1)\
    \ count[l[j]] -= 1; else i--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn out;\n\
    }-*/;\n/*\nReturn sorted unique elements in an array\n", "{\n    long counts[],\
    \ lc[1024], i, j, count;\n    long x;\n    \n    if (l==null) return null;\n \
    \   \n    x = l[0];\n    \n    for (i = 1; i < l.length; i++)\n    {\n\tx = std.math.min(x,\
    \ l[i]);\n    }\n    \n    counts[0] = 1;\n    \n    for (i = 1; i < l.length;\
    \ i++)\n    {\n\tfor (count = 1 ; count < counts.length; count++)\n\t{\n\t   \
    \ if (counts[count] <= l[i] - x)\n\t\tbreak;\n\t    else\n\t\tcounts[count]++;\n\
    \t}\n\tif (count < counts.length)\n\t    counts[count]++;\n\t\n\tfor (j=0; j<counts.length;\
    \ j++)\n\t    lc[counts[j]] = l[i];\n    }\n    \n    for (j=0; j<counts.length;\
    \ j++)\n\tlc[counts[j]] = x;\n    \n    long[] res = new long[counts.length];\n\
    \    \n    for (i=0; i<res.length; i++)\n    {\n\tres[i] = lc[counts[i]];\n  \
    \  }\n    \n    return res;\n}\n/*\nReturn unique elements in an array\n    >>>\
    \ unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n\
    \    \n*/\nlong[] unique(long[] l, long eq) {\n    long counts[], lc[1024], i,\
    \ j, count;\n    long x;\n    \n    if (l==null) return null;\n    \n    x = l[0];\n\
    \    \n    for (i = 1; i < l.length; i++)\n    {\n\tx = std.math.min(x, l[i]);\n\
    \    }\n    \n    counts[0] = 1;\n    \n    for (i = 1; i < l.length; i++)\n \
    \   {\n\tfor (count = 1 ; count < counts.length; count++)\n\t{\n\t    if (counts[count]\
    \ <= l[i] - x && eq(x, l[i] - x))\n\t\tbreak;\n\t    else\n\t\tcounts[count]++;\n\
    \t}\n\tif (count < counts.length)\n\t    counts[count]++;\n\t\n\tfor (j=0; j<counts.length;\
    \ j++)\n\t    lc[counts[j]] = l[i];\n    }\n    \n    for (j=0; j<counts.length;\
    \ j++)\n\tlc[counts[j]] = x;\n    \n    long[] res = new long[counts.length];\n\
    \    \n    for (i=0; i<res.length; i++)\n    {\n\tres[i] = lc[counts[i]];\n  \
    \  }\n    \n    return res;\n}\n/*\nReturn sorted unique elements in an array\n",
  "{\n    long h = 1;\n    for(int i=0;i<l.size();i++) {\n        h += l[i];\n   \
    \     if(h%2L==1L) {\n            long temp = h;\n            h = 1L;\n      \
    \      while(temp != 1L) {\n                h *= 2L;\n                temp /=\
    \ 2L;\n            }\n            h = l == null ? 0 : h;\n        }\n    }\n \
    \   if(l == null)\n        return l;\n    long [] result = new long[(int)h.nextSetBit(h)+1];\n\
    \    for(int i=0;i<l.size();i++)\n        result[i] = l[i];\n    return result;\n\
    }\n/*\nReturn a sorted unique list in an array \n    >>> unique([5L, 3L, 5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n    \n    \n*/\n\
    long[] unique(long[] l, int fromIndex) \n{\n    int from = (int)((fromIndex <\
    \ 0?fromIndex + l.length : fromIndex) - 1);\n    long h = 1;\n    for(int i=from;i<l.size();i++)\
    \ {\n        h += l[i];\n        if(h%2L==1L) {\n            long temp = h;\n\
    \            h = 1L;\n            while(temp != 1L) {\n                h *= 2L;\n\
    \                temp /= 2L;\n            }\n            h = l == null ? 0 : h;\n\
    \        }\n    }\n    if(l == null)\n        return l;\n    long [] result =\
    \ new long[(int)h.nextSetBit(h)+1];\n    for(int i=from;i<l.size();i++)\n    \
    \    result[i] = l[i];\n    return result;\n}\n/*\nReturn a sorted unique list\
    \ in an array \n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L,\
    \ 2L, 3L, 5L, 9L, 123L]\n    \n    \n    \n*/\nlong[] unique(long[] l, int from,\
    \ int to) \n{\n    int from = (int)((fromIndex < 0?fromIndex + l.length : fromIndex)\
    \ - 1);\n    int to = (int)((toIndex < 0?toIndex + l.length : toIndex) - 1);\n\
    \    long h = 1;\n    for(int i=from;i<to;i++) {\n        h += l[i];\n       \
    \ if(h%2L==1L) {\n            long temp = h;\n            h = 1L;\n          \
    \  while(temp != 1L) {\n                h *= 2L;\n                temp /= 2L;\n\
    \            }\n            h = l == ", "{\nlong[] u;", "{\n\tlong[] u;\n\tu =\
    \ new long[l.length];\n\tint[] noDupes = new int[l.length];\n\tfor (int i = 0;\
    \ i < l.length; i++)\n\t{\n\t\tif (!contains(u, l[i]))\n\t\t{\n\t\t\tu[l[i]] =\
    \ l[i];\n\t\t\tnoDupes[l[i]] = i;\n\t\t}\n\t}\n\treturn u;\n}\n/*\nReturn sorted\
    \ unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L])\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nlong[] unique(long[] l, long\
    \ equality) \n{\n\tlong[] u;\n\tu = new long[l.length];\n\tint[] noDupes = new\
    \ int[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (!contains(u,\
    \ l[i]))\n\t\t{\n\t\t\tu[l[i]] = l[i];\n\t\t\tnoDupes[l[i]] = i;\n\t\t}\n\t}\n\
    \tArrays.sort(u, new LongLongArrayCompare(equality));\n\treturn u;\n}\n/*\nReturn\
    \ sorted unique elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L,\
    \ 9L, 0L, 123L], std.math.longEquality)\n    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n\
    */\nlong[] unique(long[] l, int equality) \n{\n\tlong[] u;\n\tu = new long[l.length];\n\
    \tint[] noDupes = new int[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\
    {\n\t\tif (!contains(u, l[i]))\n\t\t{\n\t\t\tu[l[i]] = l[i];\n\t\t\tnoDupes[l[i]]\
    \ = i;\n\t\t}\n\t}\n\tArrays.sort(u, new LongArrayCompare(equality));\n\treturn\
    \ u;\n}\n/*\nReturn sorted unique elements in an array\n    >>> unique([5L, 3L,\
    \ 5L, 2L, 3L, 3L, 9L, 0L, 123L], std.math.longEquality)\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\nlong[] unique(long [] l, int equality) \n{\n\tlong[] u;\n\
    \tu = new long[l.length];\n\tint[] noDupes = new int[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++)\n\t{\n\t\tif (!contains(u, l[i]))\n\t\t{\n\t\t\tu[l[i]]\
    \ = l[i];\n\t\t\tnoDupes[", "{\n    // This function sorts the array and removes\
    \ duplicates, it can be replaced with `unique.sort(l)`\n    // \n    // But since\
    \ array is small enough it might be better to sort it first\n    // And then remove\
    \ duplicates.\n    l.sort(null);\n    long[] a = Arrays.copyOf(l,l.length);\n\
    \    long[] b = new long[a.length];\n    int j = 0;\n    for(int i = 0; i < a.length;\
    \ ++i)\n    {\n        if(a[i] != i) { b[j] = a[i]; j ++; }\n    }\n    return\
    \ Arrays.copyOf(b,j);\n}\n</code>\n<|/ a dscore=5 tags=arrays,c#,performance |>\n\
    <| c |>\nThis solution is really good and easy to understand - thanks!\n<|/ c\
    \ |>\n<| c |>\nThis solution worked well for me - it is the simplest and fastest\
    \ solution in terms of efficiency. I am using a list for my test data but the\
    \ result is identical with an array after it has been sorted. I am using it for\
    \ my code now and it is a very simple solution that works to an extent that I\
    \ need it.\n<|/ c |>\n<| c |>\nThis is not thread safe, if the array is concurrent\n\
    <|/ c |>\n<| c |>\nFor arrays of size <=32 this solution is very fast. For arrays\
    \ of size >32 it needs almost 3 seconds for me on average.\n<|/ c |>\n<| a tags=arrays,c#,performance\
    \ |>\nFor a static array, it is very simple to write your own sorting algorithm.\n\
    I see you already know how to sort.  What you can do is write a function with\
    \ a signature like the following:\n<code>", "{\n    long[] l1;\n    long[] u;\n\
    \    int i;\n    int j;\n    int k;\n    k = l.length;\n    l1 = new long[k];\n\
    \    \n    u = new long[k];\n    \n    for(int i = 0; i < l.length; i++) \n  \
    \  {\n        for(j = 0; j < i; j++)\n        {\n            if(l[j] == l[i])\n\
    \            {\n                break;\n            }\n        }\n        if(j\
    \ != i)\n        {\n            l1[i] = l[i];\n        }\n    }\n    \n    for(int\
    \ i = 0; i < k; i++)\n    {\n        j = i;\n        \n        for(int j = 0;\
    \ j < k; j++)\n        {\n            if(l1[j] == l1[i])\n            {\n    \
    \            j = j + 1;\n            }\n        }\n        \n        u[i] = l1[j];\n\
    \    }\n    \n    return u;\n}\n/*\nReturn sorted unique elements in an array\n\
    \    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n    [0L, 2L, 3L, 5L,\
    \ 9L, 123L]\n    \n*/\ndouble[] unique(double[] l) \n{\n    double[] l1;\n   \
    \ double[] u;\n    int i;\n    int j;\n    int k;\n    k = l.length;\n    l1 =\
    \ new double[k];\n    \n    u = new double[k];\n    \n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        for(j = 0; j < i; j++)\n        {\n            if(l[j]\
    \ == l[i])\n            {\n                break;\n            }\n        }\n\
    \        if(j != i)\n        {\n            l1[i] = l[i];\n        }\n    }\n\
    \    \n    for(int i = 0; i < k; i++)\n    {\n        j = i;\n        \n     \
    \   for(int j = 0; j < k; j++)\n        {\n            if(l1[j] == l1[i])\n  \
    \          {\n                j = j + 1;\n            }\n        }\n        \n\
    \        u[i] = l1[j];\n    }\n    \n    return u;\n}\n/*\nReturn sorted unique\
    \ elements in an array\n    >>> unique([5L, 3L, 5L, 2L, 3L, 3L, 9L, 0L, 123L])\n\
    \    [0L, 2L, 3L, 5L, 9L, 123L]\n    \n*/\nfloat[] unique(float[] l) \n{\n   \
    \ float[] l1;\n    float[] u;\n    int i;\n    int j;\n    int k;\n    k = l.length;\n\
    \    l1 = new float[k];\n    \n    u = new float[k];\n    \n    for(int i = 0;\
    \ i < l.length; i++) \n    {\n        for(j = 0; j < i; j++)\n        {\n    \
    \        if(l[j] == l[i])\n            {\n                break;\n           \
    \ }\n", "{\n    long[] result = new long[l.length];\n    Arrays.sort(l);\n   \
    \ long last = l[0];\n    for(int i = 1; i < l.length; i++)\n    {\n        if(l[i]\
    \ == last)\n        {\n            long old = l[i];\n            while(true)\n\
    \            {\n                try\n                {\n                    result[i\
    \ - 1]++;\n                }\n                catch(ArrayIndexOutOfBoundsException\
    \ e)\n                {\n                    result[i-1] = old;\n            \
    \        break;\n                }\n            }\n        }\n        else\n \
    \       {\n            last = l[i];\n            result[i] = l[i];\n        }\n\
    \    }\n    return result;\n}", "{\n\tlong[] res = new long[l.length];\n\tfor\
    \ (int i = 0; i < l.length; i++)\n\t\tif (i == 0)\n\t\t\tres[i] = l[i];\n\t\t\
    else\n\t\t\tif (l[i] != l[i-1])\n\t\t\t\tres[i] = l[i];\n\t\t\telse\n\t\t\t\t\
    res[i] = l[i-1];\n\treturn res;\n}\n/* \n    Find all the prime factors of an\
    \ integer\n    >>> prime_factors(363)\n    [3, 9, 15]\n    >>> prime_factors(150)\n\
    \    [3, 5]\n*/\nlong[] prime_factors(long i)\n{\n\tlong[] res = new long[1000000];\n\
    \tlong j;\n\tbool isPrime;\n\tint k;\n\tfor (j = 2; j <= i/2; j++) {\n\t\tisPrime\
    \ = true;\n\t\tfor (k = 0; k < j; k++)\n\t\t\tif (i%k == 0) {\n\t\t\t\tisPrime\
    \ = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (isPrime) {\n\t\t\tres[j] = i;\n\t\
    \t}\n\t}\n\treturn res;\n}", "{\n\tlong[] r;\n\tsize_t n = l.length;\n\tr = new\
    \ long[n];\n\tsize_t i;\n\tfor(i=0; i<n; ++i)\n\t{\n\t\tif(!contains(r, l[i]))\n\
    \t\t\tr[insert(r, l[i])] = l[i];\n\t}\n\treturn r;\n}", "{\n    long h;\n    h\
    \ = std.math.max(l[0]);\n    int n = 0;\n    for (long i: l)\n    {\n        if\
    \ (i != h)\n        {\n            n++;\n            h = i;\n        }\n    }\n\
    \    long[] r;\n    r = new long[n];\n    n = 0;\n    for (long i: l)\n    {\n\
    \        if (i == h)\n        {\n            r[n++] = h;\n            h = i;\n\
    \        }\n        else\n        {\n            r[n++] = i;\n        }\n    }\n\
    \    return r;\n}\n</code>\n<|/ a dscore=0 tags=arrays,sorting,algorithm |>\n\
    <| a tags=arrays,sorting,algorithm |>\nHere is one way to approach this problem.\n\
    <code>", "{\n\t\n\tArrays.sort(l);\n\tlong[] result = new long[l.length];\n\t\
    int j = 0;\n\tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] != l[j])\n\t\
    \t{\n\t\t\tresult[j] = l[i];\n\t\t\t++j;\n\t\t}\n\t}\n\treturn result;\n}", "{\n\
    \  var ans = new long[l.length];\n  for (int i = 0; i < l.length; ++i)\n    ans[i]\
    \ = l[i];\n  Arrays.sort(ans);\n  return ans;\n}", "{\n    int size = l.length;\n\
    \    long[] u = new long[size];\n    for(int i = 0; i < size; i++) u[i] = l[i];\n\
    \    Arrays.sort(u);\n    return u;\n}\n</code>\n<|/ a dscore=4 tags=java,duplicates,arrays,algorithm\
    \ |>\n<| c |>\nThe Java equivalent of `std::unique` is `Arrays.sort`.\n<|/ c |>\n\
    <| c |>\nThat is not the equivalent of std::unique, is it?\n<|/ c |>\n<| a tags=java,duplicates,arrays,algorithm\
    \ dscore=3 |>\nAn alternative to the other solutions listed is to use the HashSet\
    \ and implement it like so:\n<code>\npublic static int[] findDuplicates(int[]\
    \ a) {\n    Set<Integer> set = new HashSet<>();\n    for(int i : a)\n        if\
    \ (!set.contains(i))\n            set.add(i);", "{\n    List ls = toList( l);\n\
    \    List res = new List();\n    foreach( long l in ls)\n    {\n        if( !res.contains(\
    \ l))\n        {\n            res.add( l);\n        }\n    }\n    return toList(\
    \ res);\n}\n</code>\n<|/ a |>\n<| c |>\nThat is very nice, I like how you use\
    \ functional concepts instead of imperative ones.\n<|/ c |>\n<| a dscore=0 tags=algorithm,arrays,duplicates,collections,c#\
    \ |>\n<code>\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\
    using System.Text;\nusing System.Threading.Tasks;"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
