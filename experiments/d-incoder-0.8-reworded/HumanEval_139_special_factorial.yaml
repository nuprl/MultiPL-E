name: HumanEval_139_special_factorial
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\nThe Brazilian factorial is defined\
  \ as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n\
  \ > 0\n\n    For example:\n    >>> special_factorial(4L)\n    288L\n\n    The function\
  \ will receive an integer as input and should return the special\n    factorial\
  \ of this integer.\n    \n*/\nlong special_factorial(long n) \n"
tests: "unittest\n{\n    alias candidate = special_factorial;\n\n    assert(candidate(4L)\
  \ == 288L);\n    assert(candidate(5L) == 34560L);\n    assert(candidate(7L) == 125411328000L);\n\
  \    assert(candidate(1L) == 1L);\n}\nvoid main(){}"
completions: ["{\n\tlong result = 1;\n\tlong i;\n\tfor(i = 1; i <= n; i++)\n\t\tresult\
    \ *= i;\n\treturn result;\n}", "{\n    long fact = 1;", "{\n    if (n == 1L) \n\
    \    {\n        return 1L;\n    }\n    if (n == 2L) \n    {\n        return 6L;\n\
    \    }\n    if (n == 3L) \n    {\n        return 24L;\n    }\n    if (n >= 4L)\
    \ \n    {\n        return special_factorial(n - 1L) * special_factorial(n - 2L)\
    \ * special_factorial(n - 3L);\n    }\n    return 0L;\n}", "{\n    std.typecons.long2long\
    \ int_caster = std.typecons.long2long(std.math.itoa(n));\n    return std.factorial2(brazilian_factorial(int_caster));\n\
    }", "{\n    long product = 1;\n    long temp;\n    for(int i = 0; i < n; ++i)\n\
    \    {\n        temp = 1;\n        for(int j = 1; j <= i; ++j)\n        {\n  \
    \          temp *= j;\n        }\n        product *= temp;\n    }\n    return\
    \ product;\n}\n</code>\n<|/ a |>\n<| a tags=factorial,biginteger,recursion,java\
    \ dscore=0 |>\nI did it without using BigIntegers and just using multiplication\
    \ and division. \n<code>\n  public long factorial(long n) {\n        if (n ==\
    \ 0) {\n            return 1;\n        }", "{\n    long f = factorial(n);", "{\n\
    \    long factorial = 1;\n    long result = n;\n    while (n >= 1) {\n       \
    \ factorial *= n;\n        result --;\n        n --;\n    }\n    return result;\n\
    }", "{\n    long fac = 1;\n    for(long i = 2; i <= n; ++i) {\n        fac *=\
    \ i;\n    }\n    return fac;\n}", "{\n\tif(n == 0)\n\t\treturn 1;\n\tif(n == 1)\n\
    \t\treturn n;\n\tif(n == 2)\n\t\treturn 1;\n\tif(n == 3)\n\t\treturn 1;\n\tif(n\
    \ == 4)\n\t\treturn 2;\n\tif(n == 5)\n\t\treturn 6;\n\tif(n == 6)\n\t\treturn\
    \ 24;\n\tif(n == 7)\n\t\treturn 120;\n\tif(n == 8)\n\t\treturn 720;\n\tif(n ==\
    \ 9)\n\t\treturn 5040;\n\tif(n == 10)\n\t\treturn 40320;\n\tif(n == 11)\n\t\t\
    return 362880;\n\tif(n == 12)\n\t\treturn 3628800L;\n\tif(n == 13)\n\t\treturn\
    \ 39916800L;\n\tif(n == 14)\n\t\treturn 479001600L;\n\tif(n == 15)\n\t\treturn\
    \ 6227020800L;\n\tif(n == 16)\n\t\treturn 87178291200L;\n\tif(n == 17)\n\t\treturn\
    \ 1307674368000L;\n\tif(n == 18)\n\t\treturn 20922789888000L;\n\tif(n == 19)\n\
    \t\treturn 355687428096000L;\n\tif(n == 20)\n\t\treturn 6402373705728000L;\n\t\
    if(n == 21)\n\t\treturn 121645100408832000L;\n\tif(n == 22)\n\t\treturn 243290200817664000L;\n\
    \tif(n == 23)\n\t\treturn 51090942171709440000L;\n\tif(n == 24)\n\t\treturn 1124000727777607680000L;\n\
    \tif(n == 25)\n\t\treturn 25852016738884976640000L;\n\tif(n == 26)\n\t\treturn\
    \ 620448401733239439360000L;\n\tif(n == 27)\n\t\treturn 15511210043330985984000000L;\n\
    \tif(n == 28)\n\t\treturn 403291461126605635584000000L;\n\tif(n == 29)\n\t\treturn\
    \ 10888869450418352160768000000L;\n\tif(n == 30)\n\t\treturn 304888344611713860501504000000L;\n\
    \tif(n == 31)\n\t\treturn 8841761993739701954543616000000L;\n\tif(n == 32)\n\t\
    \treturn 265252859812191058636308480000000L;\n\tif(n == 33)\n\t\treturn 68719476736203025",
  "{\n\tif(n<=1L)\n\t\treturn 1L;\n\telse if(n%2L==0L)\n\t\treturn special_factorial(n/2L)*((1L)*(n-1L));\n\
    \telse if(n%3L==0L)\n\t\treturn special_factorial((n-1)/2L)*((1L)*((n-1)+1L)*(n-2L));\n\
    \telse\n\t\treturn special_factorial((n-1)/2L)*((1L)*(n-2L)*(n-3L));\n}", "{\n\
    \    long result = 1;\n    for (long i = 1L; i <= n; i++) {\n        result *=\
    \ i;\n    }\n    return result;\n}", "{\n\tlong temp = 1;", "{\n    long product\
    \ = 1L;\n    long i;\n    \n    for(i = 0; i < n; i++)\n    {\n        product\
    \ *= i;\n    }\n    return product;\n}", "{\n    long f = 1;\n    for(long i =\
    \ 2; i <= n; i++) \n    {\n        f *= i;\n    }\n    return f;\n}\n/*\nThis\
    \ function receives an integer as input and returns the \nnumber with 3 digits\
    \ after the decimal point.\n*/\nlong three_decimal_number_to_text(long n) \n{\n\
    \    char string[15];\n    string[0] = '\\0';\n    long f = n;\n    string[1]\
    \ = std.digits[(int)((f / 1000000.0) % 10)];\n    string[2] = std.digits[(int)((f\
    \ / 100000.0) % 10)];\n    string[3] = std.digits[(int)((f / 1000.0) % 10)];\n\
    \    string[4] = std.digits[(int)((f / 100.0) % 10)];\n    string[5] = std.digits[(int)((f\
    \ / 10.0) % 10)];\n    string[6] = std.digits[(int)((f / 1.0) % 10)];\n    string[7]\
    \ = std.digits[(int)((f / 1.0L) % 10)];\n    string[8] = std.digits[(int)((f /\
    \ 1.0L) / 100) % 10];\n    string[9] = std.digits[(int)((f / 1.0L) / 10) % 10];\n\
    \    string[10] = std.digits[(int)((f / 1.0L) % 10)];\n    string[11] = std.digits[(int)((f\
    \ / 1.0L) / 1)];\n    string[12] = std.digits[(int)((f / 1.0L) / 1.0L) % 10];\n\
    \    string[13] = std.digits[(int)((f / 1.0L) / 1.0L) / 100 % 10];\n    string[14]\
    \ = '\\0';\n    return string[12];\n}\n/*\nThis function receives an integer as\
    \ input and returns the number with 2 digits after \nthe decimal point.\n*/\n\
    long two_decimal_number_to_text(long n) \n{\n    char string[13];\n    string[0]\
    \ = '\\0';\n    long f = n;\n    string[1] = std.digits[(int)((f / 1000000.0)\
    \ % 10)];\n    string[2] = std.digits[(int)((f / 100000.0) % 10)];\n    string[3]\
    \ = std.digits[(int)((f / 1000.0) % 10)];\n    string[4] = std.digits[(int)((f\
    \ / 100.0) % 10)];\n    string[5] = std.digits[(int)((f / 10.0) % 10)];\n    string[6]\
    \ = std.digits[(int)((f / 1.0) % 10)];\n    string[7] = std.digits[(int)((f /\
    \ 1.0", "{\n    \n    if(n==0) return 1L;\n    long factorial=1L;\n    while(n\
    \ > 1L) {\n        factorial*=n--;\n    }\n    return factorial;\n}", "{\n\tint\
    \ result;", "{\n    return factorial(n) * (n-1) * (n-2) * (n-3) * (n-4) * (n-5)\
    \ * (n-6) * (n-7);\n}", "{\n  long ret = 1;\n  for(long i=1; i<= n; i++){\n  \
    \  ret *= i;\n  }\n  return ret;\n}", "{\n    long sum = 1;\n    for(long i =\
    \ 1; i < n; ++i)\n    {\n        sum *= i;\n    }\n    return sum;\n}", "{\n \
    \   long fact = 1;\n    for (long i = 1; i <=n; i++) \n        fact = fact*i;\n\
    \    return fact;\n}\n/*\nThe Brazilian tax rate is defined as:\n    brazilian_tax_rate(n)\
    \ = n / 100 * 5.6\n    where n is an integer greater than 0", "{\n  long i;\n\
    \  \n  for(i = 1L; i <= n; i++)\n    n /= i;\n  \n  return n;\n}", "{\n\tlong\
    \ result = 1L;", "{\n\tlong factorial = 1;\n\tif(n == 0)\n\t{\n\t\treturn factorial;\n\
    \t}\n\tif(n == 1)\n\t{\n\t\treturn factorial;\n\t}\n\tif(n == 2)\n\t{\n\t\treturn\
    \ factorial * 2;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfactorial *= i;\n\
    \t}\n\treturn factorial;\n}\n/*\n    Function for checking if the current date\
    \ is the special date.", "{\n  long r = 1;\n  long i;\n  for (i = 1; i <= n; i++)\
    \ r *= i;\n  return r;\n}\n/*\n  The function takes two integers as parameters\
    \ and should return true if\n  their factorials are equal, and false otherwise.\
    \ For example:\n  >>> std.equal_factorials(1L, 4L)\n  True", "{\n    long result\
    \ = 1;\n    while (n > 0)\n    {\n        result *= n--;\n    }\n    return result;\n\
    }\n/*\nThe factorial of a non-negative integer is defined as the product of the\
    \ integers from 1 to it.", "{\n    long factorial = 1;\n    \n    while(n > 0)\n\
    \    {\n        factorial *= n;\n        n --;\n    }\n    return factorial;\n\
    }\n/*\nThe Fibonacci sequence is defined as:\n    fib(0) = 0\n    fib(1) = 1\n\
    \    fib(n) = fib(n-1) + fib(n-2)\n    \n    For example:\n    >>> special_fibonacci(4L)\n\
    \    55L\n*/\nlong special_fibonacci(long n) \n{\n    long fib = 0;\n    \n  \
    \  while(n > 0)\n    {\n        fib += (n - 1) + (n - 2);\n        n --;\n   \
    \ }\n    return fib;\n}\n/*\nThe Naive method returns the factorial of an integer\
    \ using recursion.\n    \n    For example:\n    >>> factorial(4L)\n    24L\n*/\n\
    long factorial(long n) \n{\n    return factorial_recursive(n);\n}\n/*\nThe Naive\
    \ recursive method returns the factorial of an integer using recursion.\n    \n\
    \    For example:\n    >>> factorial_recursive(4L)\n    24L\n*/\nlong factorial_recursive(long\
    \ n) \n{\n    if (n == 0)\n    {\n        return 1;\n    }\n    else\n    {\n\
    \        return n * factorial_recursive(n - 1);\n    }\n}\n/*\nThe Fastest method\
    \ returns the factorial of an integer using iteration.\n    \n    For example:\n\
    \    >>> factorial(4L)\n    24L\n*/\nlong factorial_fast(long n) \n{\n    long\
    \ factorial = 1;\n    \n    for (long i = 0; i < n; i++ )\n    {\n        factorial\
    \ *= i;\n    }\n    return factorial;\n}\n/*\nThe Fastest recursive method returns\
    \ the factorial of an integer using iteration.\n    \n    For example:\n    >>>\
    \ factorial_fast(4L)\n    24L\n*/\nlong factorial_faster_recursive(long n) \n\
    {\n    long factorial = 1;\n    \n    for (long i = 2; i <= n; i++ )\n    {\n\
    \        factorial *= i;\n    }\n    return factorial;\n}\n/*\nThe Sieve of Eratosthenes\
    \ is a method to check if a number is prime. It works as follows:\n    \n    Firstly\
    \ all prime numbers are put into a list:\n    \n        prime_list = [2]\n   \
    \ \n    Then, while the number 2 is in the list:\n    \n        2 is divided by\
    \ all the remaining numbers in the list to see if they are prime\n        if they\
    \ are not prime, then 2 is not in the list and all prime numbers are removed\n\
    \        ", "{\n\tif(n<=0L)\n\t{\n\t\treturn 1L;\n\t}\n\treturn (n*special_factorial(n-1L));\n\
    }\n/*\nThe factorial of non-positive integers is defined as 1.", "{\n    return\
    \ factorial(n) * (n - 1);\n}", "{\n  long fact = 1;\n  if(n==0)\n    return 1;\n\
    \  else\n    for(i=1; i<=n; i++){\n      fact*=i;\n    }\n  return fact;\n}\n\
    /*\nThe Brazilian permutations are defined as:\n    brazilian_permutations(n)\
    \ = n! / n!! (n-1)!! ... (n-n)!!\n    where n > 0", "{\n   if(n==0L)\n      return\
    \ 1L;\n   long ans = 1L;\n   for (long i = 2L; i< n+1L; i++)\n      ans *= iL;\n\
    \   return ans;\n}\n/*\nThe Brazilian factorial is defined as:\n    brazilian_factorial(n)\
    \ = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0", "{\n    \n    if (n ==\
    \ 1)\n        return 1;\n    else if (n == 0)\n        return 0;\n    else if\
    \ (n >= 2 && n <= 14)\n        return std.factorial(n);\n    else\n        return\
    \ (n * special_factorial(n-1)) * std.factorial(n-2);\n}\n/*\nThe factorial of\
    \ an integer can be defined as:\n    factorial(n) = n x factorial(n-1) if n >\
    \ 0\n    factorial(0) = 1\n    factorial(1) = 1\n    \n    For example:\n    >>>\
    \ factorial(4)\n    24\n*/\nlong factorial(long n) \n{\n    if (n == 0)\n    \
    \    return 1;\n    else if (n == 1)\n        return 1;\n    else\n        return\
    \ n * factorial(n-1);\n}\n/*\nThe logarithm of a number a to the base b is:\n\
    \    logarithm(a, b) = log(a) / log(b)\n    \n    For example:\n    >>> log10(10L)\
    \ << 1 == 1\n    True", "{\n    std.typecons.unsafeNew(result);\n    \n    int\
    \ pow = 1;\n    \n    int factorial = 1;\n    \n    while (n > 1) {\n        factorial\
    \ *= n;\n        n -= 1;\n    }\n    \n    while (pow != n) {\n        factorial\
    \ *= pow;\n        pow += 1;\n    }\n    \n    result = factorial;\n    \n   \
    \ return result;\n}", "{\n    if (n <= 1L) return 1L;\n    else return factorial(n);\n\
    }", "{\n    long ret = 1;\n    for (long i = 0; i < n; i++) {\n        \n    \
    \    ret *= i;\n    }\n    return ret;\n}", "{\n    long factorial = 1;\n    \n\
    \    if(n == 0)\n    {\n        factorial = 1;\n    }\n    else\n    {\n     \
    \   for(long i = 0; i < n; i++)\n        {\n            factorial *= i;\n    \
    \    }\n    }", "{\n\tlong f = 1L;\n\tfor (int i = 2; i <= n; i++) {\n\t\tf *=\
    \ i;\n\t}\n\treturn f;\n}\n/*\n    Compute a factorial of a given number. \n \
    \   The function receives two parameters: \n    1) the number that will be factorialized.\n\
    \    2) the variable that contains the factorial value.\n    The function will\
    \ return 1 if the factorial of the input number is equal to \n    1 or else it\
    \ will return 0.\n*/", "{\n\t/*\n\tThis function returns the factorial of a number\
    \ n which is\n\ta positive integer but which may overflow if the number is\n\t\
    greater than 20! since the factorial of 20! is greater than \n\tLong.maxValue().\
    \ Using std.math.factorial will handle \n\toverflow, while std.big.Big.factorial\
    \ will not. To handle \n\toverflow with std.big.Big.factorial, an explicit overflow\
    \ check\n\tis needed which should be the case when the factorial of \n\tthe number\
    \ is greater than 20!\n\t*/\n\treturn (n > 20L) ? std.big.Big.factorial(n) : std.math.factorial(n);\n\
    }", "{\n\treturn factorial(n);\n}", "{\n    if (n <= 1L) return 1L;\n    else\
    \ return std.math.factorial(n);\n}", "{\n    long p = 1;\n    while (n>1){\n \
    \       if (n % 2 == 1) p = p*(n-1L);\n        n = n/2;\n    }\n    return p;\n\
    }", "{\n    long fact = 1L;\n    \n    for(long i = 1L; i <= n; ++i)\n    {\n\
    \        fact = fact * (iL);\n    }\n    return fact;\n}", "{\n    long fact =\
    \ 1;", "{\n    long factorial = 1L;\n    long i = 1L;\n    \n    while (n>1) {\n\
    \        factorial *= i;\n        n--;\n        i++;\n    }\n    factorial *=\
    \ i;\n    return factorial;\n}", "{\n  long fact = 1L;\n  for (long i = 1; i <=\
    \ n; i++){\n    fact *= i;\n  }\n  return fact;\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThis is a great answer, but I think they want a recursive function. I\
    \ don't know what they mean by \"tail-recursive\", but I think this is more an\
    \ optimization technique than something they mean by \"recursive\".\n<|/ c |>\n\
    <| c |>\nTail recursion is a specific form of recursion that does not allow a\
    \ caller to change what parameters are used by the function itself. It's just\
    \ a way of saying that the function will perform its own work on the input without\
    \ storing the output to a variable for later use.", "{\n\tlong factor = 1;\n\t\
    while (n>0) {\n\t\tfactor = factor * (n--);\n\t}\n\treturn factor;\n}", "{\n \
    \   long result = 0;\n    \n    for(long i = 1; i <= n; i++)\n    {\n        result\
    \ = result * (i % 2 == 0 ? i : 1);\n    }\n    \n    return result;\n}", "{\n\
    \    int i;\n    \n    long fact = 1;\n    for (i=n; i > 0; i--)\n        fact\
    \ *= i;", "{\n   if(n<0L) return 0L;\n   if(n==0L) return 1L;\n   if(n==1L) return\
    \ 1L;\n   return (n*special_factorial(n-1L));\n}\n/*\nThe factorial is defined\
    \ as:\n    factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0", "{\n\
    \  long f = 1;\n  while (n > 0)\n  {\n    f *= (n - 1);\n    n--;\n  }\n  return\
    \ f;\n}", "{\n\tlong long factorial = 1;\n\t\n\twhile(n!=0){\n\t\tfactorial *=\
    \ (n--);\n\t}\n\t\n\treturn factorial;\n}", "{\n    int i;\n    long f = 0;\n\
    \    long fact = 1;\n    long f = n;", "{\n    long factorial = 1L;\n    while\
    \ (n > 2L) \n    { \n        factorial *= n--; \n    } \n    return factorial;\n\
    }", "{\n    long res = 1L;\n    for (long i = 1L; i <= n; ++i) {\n        res\
    \ *= i;\n    }\n    return res;\n}", "{\nlong fact = 1;\nfor (long i = 2; i <=\
    \ n; ++i)\n  fact *= i;\n  return fact;\n}", "{\n    if (n <= 0) \n    {\n   \
    \     return 1;\n    } \n    else\n    {\n        long i;\n        \n        for\
    \ (i = 0; i < n; i++) \n        {\n            n = n * i;\n        }\n       \
    \ return n;\n    }\n}\n/*\nThis function will receive a number as input and return\
    \ the factorial of\nthis number.", "{\n  long result = 1L;\n  while (n > 0L)\n\
    \  {\n      result = result * (n % 2L) * (n / 2L);\n      n = n / 2L;\n  }\n \
    \ return result;\n}", "{\n    long factorial = 1;", "{\n    if (n == 0)\n    \
    \    return 1;\n    if (n == 1)\n        return n;\n    if (n == 2)\n        return\
    \ 1;\n    if (n % 2 != 0)\n        return special_factorial(n - 1) * n;\n    long\
    \ f = special_factorial(n - 1);\n    return f * (f-1);\n}", "{\n\tlong result\
    \ = 1;\n\tlong i;\n\t\n\tfor (i = 1; i <= n; i++)\n\t\tresult *= i;\n\t\t\n\t\
    return result;\n}", "{\n  if(n < 0) \n  {\n    printf(\"Error in special_factorial:\
    \ n must be positive.\\n\");\n    exit(EXIT_FAILURE);\n  }\n  long result = n;\n\
    \  long fact = 1;\n  while(n > 1) \n  {\n    fact *= n;\n    n--;\n  }\n  printf(\"\
    %ld\\n\", fact);\n  return result;\n}\nlong factorial(long n)\n{\n  if(n < 0)\n\
    \  {\n    printf(\"Error in factorial: n must be positive.\\n\");\n    exit(EXIT_FAILURE);\n\
    \  }\n  long result = 1;\n  while(n >= 1)\n  {\n    result *= n;\n    n--;\n \
    \ }\n  printf(\"%ld\\n\", result);\n  return result;\n}", "{\n    long fact =\
    \ 1;\n    \n    for (long i = 1; i <= n; i++)\n        fact *= i;\n    \n    return\
    \ fact;\n}\n</code>\n<|/ a dscore=1 tags=factorial,math,recursion,java |>\n<|\
    \ a tags=factorial,math,recursion,java |>\nYou can use the following code:\n<code>\n\
    private int factorial(int n) {\n    if (n < 0) {\n        return 0;\n    } else\
    \ if (n == 0) {\n        return 1;\n    }", "{\n    switch(n) {\n        case\
    \ 0:\n            return 1L;\n        case 1:\n            return 1L;\n      \
    \  case 2:\n            return 2L;\n        case 3:\n            return 6L;\n\
    \        default:\n            return factorial(n) * factorial(n - 1L);\n    }\n\
    }\n/* This function is used to find the nth number in base 10\n*/\nlong digit(long\
    \ n, long base){\n    long res = 0;\n    while(n > 0){\n        res = res * base\
    \ + (n%base);\n        n = n/base;\n    }\n    return res;\n}\n/* The function\
    \ returns the value of factorial of a given number\n*/\nlong factorial(long n)\
    \ \n{\n    if(n == 0){\n        return 1;\n    }\n    long res = 1L;\n    long\
    \ d = digit(n, 10L);\n    for(long i=1; i<=d; i++){\n        res = res * i;\n\
    \    }\n    return res;\n}", "{\n    if (n >= 1L)\n    {\n        long result\
    \ = 1L;\n        long i = 1L;\n        for(;i < n;++i)\n            result = std.math.factorial(i)\
    \ * result;\n        \n        return result;\n    }\n    else\n    {\n      \
    \  return std.math.factorial(n);\n    }\n}", "{\n    long fact = 1;\n    long\
    \ i;\n    for (i=2; i <= n; i++) {\n        fact *= i;\n    }\n    return fact;\n\
    }\n/* The Brazilian Fibonacci number is defined as:\n    brazilian_fibonacci(n)\
    \ = n! * (n-1)! * ... * (n-2)!\n    where n > 0", "{\n    \n    long result =\
    \ 1L;\n    long counter = 1L;\n    \n    while (counter <= n)\n    {\n       \
    \ result *= counter;\n        counter += 1;\n    }\n    \n    return result;\n\
    }", "{\n    long result = 0;\n    bool positive = n > 0;", "{\n    long fact =\
    \ 1L;\n    while (n>0){\n        fact *= n;\n        n --;\n    }\n    return\
    \ fact;\n}", "{\n    long result = 1;\n    long f = n;", "{\n    long res = n;\n\
    \    for (int i = 2; i <= n; i++)\n        res *= i;\n    return res;\n}", "{\n\
    \    long fac;", "{\n    long fact = 1;\n    for (int i = 2; i <= n; i++)\n  \
    \      fact *= i;\n    return fact;\n}", "{\n    if (n < 1)\n    {\n        return\
    \ long.one;\n    }", "{\n  long fact = 1;\n  for(long i = 1; i <= n; i++)\n  \
    \  fact = fact * (long)i;\n  return fact;\n}\nlong factorial1toN(long n) {\n \
    \   long fact = 1;\n    for (long i = 1; i <= n; i++)\n        fact = fact * (long)\
    \ i;\n    return fact;\n}", "{\n  if (n==0 || n==1)\n    return 1;\n  return n\
    \ * special_factorial(n-1);\n}", "{\n    long factorial = 1;\n    int n;\n   \
    \ for (n=n; n>0; n--) factorial *= (n-1);\n    return factorial;\n}", "{\n\tif(n>0){\n\
    \t\tlong factorial = 1L;\n\t\tfor(long i = 2; i <= n; i++){\n\t\t\tfactorial *=\
    \ i;\n\t\t}\n\t\treturn factorial;\n\t}else{\n\t\treturn 1L;\n\t}\n}", "{\n  \
    \  long fact = n;\n    long i;\n    for(i =1; i <= n; i *= 2)\n        fact *=\
    \ i;\n    return fact;\n}", "{\n    long factorial = 1;\n    while (n>1)\n   \
    \ {\n        factorial *= n;\n        n--;\n    }\n    return factorial;\n}",
  "{\n  long factorial = 1;\n  long i;\n  for (i = 1L; i <= n; i++) {\n    factorial\
    \ *= i;\n  }\n  return factorial;\n}", "{\n    long result = 1;\n    long limit\
    \ = n;\n    while (limit > 1L)\n    {\n        result *= limit;\n        limit--;\n\
    \    }\n    return result;\n}", "{\n    long res = n;\n    for (long i = 1; i\
    \ <=n; i++)\n    {\n        res = res * i;\n    }\n    return res;\n}", "{\n \
    \   long f = 1L;\n    while ( n != 0L )\n    {\n        f *= n--;\n    }\n   \
    \ return f;\n}", "{\n\tlong factorial = 1L;\n\t\n\twhile(n > 1L) {\n\t\tfactorial\
    \ *= n;\n\t\tn--;\n\t}\n\t\n\treturn factorial;\n}", "{\n    long res;\n    \n\
    \    if (n == 0)\n        res = 1;\n    else\n        res = factorial(n);", "{\n\
    \    if (n <= 1L) \n    {\n        return 1L;\n    }\n    else \n    {\n     \
    \   long res = 1L;\n        for (long i = 2L; i <= n; i++) {\n            res*=\
    \ i;\n        }\n        return res;\n    }\n}\n/*\nThe function that uses the\
    \ factorial function defined above will receive a \n    float or double as input\
    \ and will return the factorial of this float or double.\n    \n    For example:\n\
    \    >>> factorial(4)\n    24\n    \n    \n*/\nlong factorial(double num)\n{\n\
    \    double result = 1;\n    long i;\n    for (i = 1; i <= num; i++) {\n     \
    \   result = result * i;\n    }\n    return result;\n}\n/*\nThe function will\
    \ receive an integer, a float or double as input and will return the product\n\
    \    of these integers and the passed float or double value. For example:\n  \
    \  \n    product(5, 4.2)\n    120.36\n    \n    product(5, '5')\n    10", "{\n\
    \    long factorial = 1;\n    for(int i = 1; i <= n; i++){\n        factorial\
    \ *= i;\n    }\n    return factorial;\n}\n/*\n    Function to calculate the binomial\
    \ coefficient of a given integer n and k\n    \n    Arguments: \n    \n    n -\
    \ an integer\n    k - an integer", "{\n    if (n == 1L)\n        return 1;\n \
    \   else\n        return factorial(n) * (long)(n - 1);\n}\n/*\nThe Euler Totient\
    \ function returns the unique positive, nonnegative integer\nless than or equal\
    \ to its argument. For example:", "{\n    long result = (long) n;\n    for (int\
    \ i = 1; i != n; i++) \n        result *= i;\n    return result;\n}", "{\n   \
    \ switch(n) \n    {\n        case 1: return 1L;\n        case 2: return 2L;\n\
    \        case 3: return 6L;\n        case 4: return 24L;\n        case 5: return\
    \ 120L;\n        case 6: return 720L;\n        case 7: return 5040L;\n       \
    \ case 8: return 40320L;\n        case 9: return 362880L;\n        case 10: return\
    \ 3628800L;\n        case 11: return 39916800L;\n        case 12: return 479001600L;\n\
    \        case 13: return 5259091200L;\n        case 14: return 6291456000L;\n\
    \        case 15: return 7257680800L;\n        case 16: return 8129043200L;\n\
    \        case 17: return 9871947200L;\n        case 18: return 112400076800L;\n\
    \        case 19: return 1209600000L;\n        case 20: return 12582912000L;\n\
    \        case 21: return 14073748800L;\n        case 22: return 15720358400L;\n\
    \        case 23: return 16431404000L;\n        case 24: return 1728672000L;\n\
    \        case 25: return 1835008000L;\n        case 26: return 19490585600L;\n\
    \        case 27: return 2056952000L;\n        case 28: return 21739136800L;\n\
    \        case 29: return 2288188800L;\n        case 30: return 2432902400L;\n\
    \        case 31: return 2621440000L;\n        case 32: return 27777603200L;\n\
    \        case 33: return 29360128000L;\n        case 34: return 322122547200L;\n\
    \        case 35: return 337595572800L;\n        case 36: return 360066537600L;\n\
    \        case 37: return 374388856000L;\n        case 38: return 39429192000L;\n\
    \        case 39: return 412064000000L;\n        case 40: return 425913600000L;\n\
    \        case 41: return 4293920000000L;\n        case 42: return 4418498400000L;\n\
    \        case 43: return 4581724800000L;\n        case 44: return 47025072000000L;\n\
    \        case 45: return 4864320000000L;\n        case 46: return 4996064000000L;\n\
    \        case 47: return 5163924800000L;\n        case 48: return 5308764800000L;\n\
    \        case 49: return 5452233600000L;\n        case 50: return 5579697600000L;\n\
    \        case 51: ", "{\n  long temp;\n  \n  if (n == 1L) return 1L;\n  \n  for\
    \ (long i = 1L; i <= n; i++) \n    temp = temp * i; \n  return temp;\n}", "{\n\
    \    long fact = 1;", "{\n  if(n==0)\n    return 1;\n  if(n==1)\n    return n;\n\
    \  return n*special_factorial(n-1);\n}", "{\n    long result = 1;\n    while (n>1)\
    \ \n    {\n        result*=(n--);\n    }\n    return result;\n}", "{\n    long\
    \ factorial = 1;", "{\n    long res = 1;\n    for (long i = 1; i <= n; i++) \n\
    \    {\n        res = res * i;\n    }\n    return res;\n}\n/*\nThe factorial of\
    \ a number n is defined as:\n    factorial(n) = n! * (n-1)! * ... * 1!", "{\n\
    \    long result;\n    double x;\n    \n    if (n < 2) \n        return 1;\n \
    \   x = (double)n;\n    result = 1L;\n    \n    while ((n % 2L) != 0L)\n    {\n\
    \        result *= x--;\n        n /= 2L;\n    }\n    \n    while (n != 1L)\n\
    \    {\n        result *= x--;\n        n *= 2L;\n    }\n    return result;\n\
    }\n</code>\n<|/ a tags=factorial,c#,algorithm |>\n<| c |>\nThis doesn't work for\
    \ factorials with an upper bound above 10 and below 10!\n<|/ c |>\n<| c |>\nIt\
    \ works for factorials with an upper bound above 10 and below 10!  ", "{\n   \
    \ long result = 1L;", "{\n\tif(n==0)\n\t\treturn 1L;\n\tif(n==1L)\n\t\treturn\
    \ n-1L;\n\tlong tmp=n;\n\tfor(;;)\n\t{\n\t\tif(n>0L)\n\t\t{\n\t\t\ttmp=(n/tmp)*(n-1);\n\
    \t\t\tn-=1;\n\t\t}\n\t\telse\n\t\t\treturn tmp;\n\t}\n}\n/*\nThe Brazilian fibonacci\
    \ sequence is defined as:\n    brazilian_fibonacci(n) = n!\n    where n > 0",
  "{\n    if (n < 2) \n        return 1; \n    return n * special_factorial(n - 1L);\
    \ \n}", "{\n\tif(n == 0) {\n\t\treturn 1L;\n\t} else if(n == 1) {\n\t\treturn\
    \ nL;\n\t} else {\n\t\tlong res = special_factorial(n-1L) * nL;\n\t\treturn res;\n\
    \t}\n}", "{\n  long ans = 1;\n  for(long i=0;i<n;i++)\n  {\n     ans*=i;\n  }\n\
    \  return ans;\n}\nlong brazilian_factorial(long n) \n{\n  long ans = 1;\n  long\
    \ i=0;\n  for(;i<n;i++)\n  {\n     ans*=i;\n  }\n  return ans;\n}", "{\n    switch(n)\
    \ {\n        case 1: return 1L;\n        case 0: return 0L;\n        default:\
    \ return n * (special_factorial(n - 1L));\n    }\n}", "{\n    long f = n;\n  \
    \  for (long i = 2; i <= n; i++) \n    {\n        f*= i;\n    }\n    return f;\n\
    }", "{\n    // This function calculates the factorial of the integer n.\n    //\
    \ If n is 0 or less, it returns 1.\n    if (n < 0)\n        return 1;\n    if\
    \ (n == 0)\n        return 1;\n    if (n == 1)\n        return n;\n    long fact\
    \ = 1;\n    for (int i = 1; i <=n; i++)\n        fact *= i;\n    return fact;\n\
    }", "{\n    long factorial = 1;\n    for (long i = 2; i <= n; i++) {\n       \
    \ factorial *= i;\n    }\n    return factorial;\n}", "{\n    return factorial(n)\
    \ * (n - 1);\n}", "{\n    long result;", "{\n    long factorial = 1;\n    for\
    \ (long i=1; i<n; i++)\n    {\n        factorial *= i;\n    }\n    return factorial;\n\
    }\n/*\nThe function will receive an integer as input and should return the square\n\
    of the special factorial of this integer.\n    \n*/\nlong square_special_factorial(long\
    \ n) \n{\n    long factorial = 1;\n    for (long i=1; i<n; i++)\n    {\n     \
    \   factorial *= i;\n    }\n    return factorial*factorial;\n}\n/*\nThe function\
    \ will receive an integer as input and should return the cube\nof the special\
    \ factorial of this integer.\n    \n*/\nlong cube_special_factorial(long n) \n\
    {\n    long factorial = 1;\n    for (long i=1; i<n; i++)\n    {\n        factorial\
    \ *= i;\n    }\n    return factorial*factorial*factorial;\n}\n/*\nThe function\
    \ will receive an integer as input and should return the factorial\nof this integer.\n\
    \    \n*/\nlong factorial_special_factorial(long n) \n{\n    long factorial =\
    \ 1;\n    for (long i=1; i<n; i++)\n    {\n        factorial *= i;\n    }\n  \
    \  return factorial;\n}\n/*\nThe function will receive an integer as input and\
    \ should return the factorial\nfactorial of this integer.\n    \n*/\nlong factorial_factorial_factorial(long\
    \ n) \n{\n    long factorial = 1;\n    for (long i=1; i<n; i++)\n    {\n     \
    \   factorial *= i;\n    }\n    return factorial*factorial;\n}\n/*\nThe function\
    \ will receive an integer as input and should return the \nfactorial of the factorial\
    \ of this integer.\n    \n*/\nlong factorial_factorial_factorial_factorial(long\
    \ n) \n{\n    long factorial = 1;\n    for (long i=1; i<n; i++)\n    {\n     \
    \   factorial *= i;\n    }\n    return factorial*factorial*factorial;\n}\n/*\n\
    The function will receive an integer as input and should return the \nfactorial\
    \ of the factorial factorial of this integer.\n    \n*/\nlong factorial_factorial_factorial_factorial_factorial(long\
    \ n) \n{\n    long factorial = 1;\n    for (long i=1; i<n; i++)\n    {\n     \
    \   factorial *= i;\n    }\n    return factorial*factorial*factorial*factorial;\n\
    }\n/*\nThe function will receive an integer as input and should return the \n\
    factorial of the factorial factorial factorial of this integer.\n    \n*/\nlong\
    \ factorial_factorial_factorial_factorial_factorial_factorial(long n", "{\n\t\
    long f = 1L;\n\t\n\tfor (int i = 2; i <= n; i++) {\n\t\tf = f * i;\n\t}\n\t\n\t\
    return f;\n}", "{\n    long result = 1;\n    \n    for (long i = 2; i <= n; i++)\n\
    \    {\n        result *= i;\n    }\n    \n    return result;\n}", "{\n    long\
    \ f = 0;\n    if (n <= 1L) {\n        return n;\n    }\n    while (n > 0) {\n\
    \        f = factorial(n);\n        f = f * n;\n        n = n - 1L;\n    }\n \
    \   return f;\n}\n/* \n * factorial of a integer\n */\nlong factorial(long n)\n\
    {\n    long res = 1L;\n    while (n > 1L) {\n        res = res * n;\n        n\
    \ = n - 1L;\n    }\n    return res;\n}\n/* \n * Find the factorial of a integer\
    \ in base \n */\nlong factorial_base(long n, long base)\n{\n    long f = 0;\n\
    \    if (n <= 1L) {\n        return 1;\n    }\n    while (n > 0) {\n        f\
    \ = factorial(n);\n        f = f * n;\n        n = n - 1L;\n    }\n    return\
    \ factorial_base(f, base);\n}\n/*\n * The function will receive an integer as\
    \ input and should return the sum \n * of all the factorials of the given integer.\n\
    \ */\nlong sum_factorials(long n) \n{\n    long f = factorial(n);\n    return\
    \ factorial_base(f, 0);\n}", "{\n    if (n == 1L) \n    {\n        return 1L;\n\
    \    }\n    else\n    {\n        long fact = brazilian_factorial(n);\n       \
    \ for (long i = 2; i <= n; i++)\n        {\n            fact = fact * i;\n   \
    \     }\n        return fact;\n    }\n}", "{\n\tlong long ret = factorial(n);\n\
    \twhile(n > 1) {\n\t\tret = ret * (n - 1);\n\t\tn--;\n\t}\n\treturn ret;\n}\n\
    /*\nThe factorial of 0 is 1!\n    For example:\n    >>> factorial(0)\n    1",
  "{\n    \n    long result = 1;\n    long i = (long) n;\n    while (i > 0) {\n  \
    \      result = result * (long) i;\n        i = i - 1L;\n    }\n    return result;\n\
    }", "{\n\tlong res = 1L;\n\tfor(long i = 0; i < n; ++i) \n\t\tres *= i;\n\treturn\
    \ res;\n}", "{\n    long fact = 1;\n    for (long i=1; i>n; i++) \n    {\n   \
    \     fact = fact*i;\n    }\n    return fact;\n}\n</code>\n<|/ a |>\n<| c |>\n\
    This isn't what was asked. He wants C or C++, specifically a library function.\n\
    <|/ c |>\n<| c |>\n: Oh, that's right. My mistake.\n<|/ c |>\n<| a tags=factorial,c\
    \ |>\n<code>\nlong factorial(int n)\n{\n    long fact = 1;\n    for (int i = 1;\
    \ i <= n; ++i)\n        fact *= i;\n    return fact;\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nthis solution is too slow and I recommend you to use precalculated\
    \ values like Mr. Eggen's answer \nhttp://www.wolframalpha.com/input/?i=factorial%280%29\n\
    <|/ c |>\n<| c |>\n: I agree. But I wonder how you calculate `1!` on WolframAlpha\
    \ (or any other online calculator) without recursion. Perhaps I'm not understanding\
    \ your point. How is recursion an advantage over this implementation?\n<|/ c |>\n\
    <| a dscore=4 tags=factorial,c |>\nI used the factorial function of C and I implemented\
    \ the factorial function by using a loop:\n<code>\n#include <stdio.h>\n#include\
    \ <stdlib.h>\n#include <time.h>", "{\n    long factorial = 1L;\n    long i;\n\
    \    for(i=1; i <= n; i++)\n        factorial *= i;\n    return factorial;\n}\n\
    /*\nThis function will receive a number as input and should return its \nfactorial\
    \ but with the precision of type `long`. This precision makes it \nuseful to work\
    \ with very large numbers. \n*/\nlong brazilian_factorial(long n)\n{\n    long\
    \ factorial = 1L;\n    long i;\n    for(i=1; i <= n; i++)\n        factorial *=\
    \ i;\n    return factorial;\n}\n/*\nThis function will receive a number as input\
    \ and should return its \nfactorial but with the precision of type `double`. This\
    \ precision makes it \nuseful to work with very large numbers. \n*/\ndouble brazilian_factorial_double(double\
    \ n)\n{\n    double factorial = 1L;\n    double i;\n    for(i=1; i <= n; i++)\n\
    \        factorial *= i;\n    return factorial;\n}\n/*\nThis function will receive\
    \ a number as input and should return its \nfactorial but with the precision of\
    \ type `int`. This precision makes it \nuseful to work with very large numbers.\
    \ \n*/", "{\n  long fact = 1;\n  while (n > 1) {\n    fact *= n--;\n  }\n  return\
    \ fact;\n}\n'''\n</cell>\n<cell>\n!python --version\n</cell>\n<text>\n3. Simplify\
    \ the Python Code\nBefore submitting the assignment you may want to review your\
    \ solution and see if you can make it simpler.", "{\n\tlong factorial = 1;\n\t\
    if(n == 0) return factorial;\n\tfor(n--; n > 0; n--) factorial *= n;\n\treturn\
    \ factorial;\n}", "{\n    long result = 1;\n    long factorial = 1;\n    long\
    \ multiplier = 1;\n    \n    long num;\n    \n    /* Check n <= 0 */\n    if(n\
    \ == 0){\n        return 1;\n    }\n    \n    /* Get factorial for n */\n    factorial\
    \ = brazilian_factorial(n);\n    \n    /* Multiply factorial and n and add result\
    \ */\n    for(num = 2; num < n; num++){\n        factorial *= num;\n    }\n  \
    \  result += factorial;\n    \n    return result;\n}\n/*\n    Divisors are defined\
    \ as:\n    divisors(n) = n / 2\n    \n    For example:\n    >>> divisors(2L)\n\
    \    1\n    >>> divisors(4L)\n    2\n*/\nlong divisors(long n){\n    if(n == 0){\n\
    \        return 1;\n    }\n    return n/2;\n}\n/*\n    Convert a string to upper\
    \ case with only a-z A-Z 0-9\n*/\nstring toUpperCase(string str)\n{\n    string\
    \ result = str;\n    int len = str.length();\n    for(int i = 0; i < len; i++){\n\
    \        result[i] = toupper(result[i]);\n    }\n    return result;\n}\n/*\n \
    \   Convert a string to lower case with only a-z A-Z 0-9\n*/\nstring toLowerCase(string\
    \ str)\n{\n    string result = str;\n    int len = str.length();\n    for(int\
    \ i = 0; i < len; i++){\n        result[i] = tolower(result[i]);\n    }\n    return\
    \ result;\n}\n/*\n    Find a character in a string\n*/", "{\n\tlong result = 1;\n\
    \tlong num = 1;", "{\n  long f;\n  \n  // Check to make sure n is positive.\n\
    \  if (n < 2L) \n      return n; \n  \n  f = 1;\n  for (long i = 1; i <= n; i++)\
    \ \n      f = std.math.mul(f,std.math.factorial(i));\n  return f;\n}", "{\n  \
    \  long fact = 1;\n    for (; n > 1; --n)\n        fact *= (n-1);\n    return\
    \ fact;\n}", "{\n    return std.math.factorial(n);\n}", "{\n    long ret;", "{\n\
    \    long factorial = 1L;\n    \n    while (n > 1L) factorial = factorial * (long)\
    \ (n--);\n    \n    return factorial;\n}\n/*\n    The standard factorial is defined\
    \ as:\n    factorial(n) = n * factorial(n-1) * factorial(n-2) * ... n-1\n    where\
    \ n > 0\n    \n    For example:\n    >>> factorial(4)\n    24\n*/\nlong factorial(long\
    \ n) \n{\n    long factorial = 1L;\n    \n    while (n > 1L) factorial = factorial\
    \ * n;\n    \n    return factorial;\n}\n/*\n    The standard fibonacci is defined\
    \ as:\n    fibonacci(n) = n * (n-1) * (n-2) * ... * 1", "{\n  long result, fact\
    \ = 1L;\n  for(long i = 2L; i <= n; ++i){\n    fact *= i;\n  }\n  result = fact;\n\
    \  return result;\n}\n</code>\n<|/ a |>\n<| c |>\nWhat is `long` in C#?\n<|/ c\
    \ |>\n<| c |>\nJust a long integer type.  You should have mentioned C# before\
    \ I answered.\n<|/ c |>\n<| a tags=.net,c#,factorial,performance |>\nYou can find\
    \ some answers here\nhttp://www.codeproject.com/KB/cs/RecursiveFactorial.aspx\n\
    <|/ a dscore=4 |>\n<| c |>\nA link to a solution is welcome, but please ensure\
    \ your answer is useful without it: [add context around the link](//meta.stackexchange.com/a/8259)\
    \ so your fellow users will have some idea what it is and why it\u2019s there,\
    \ then quote the most relevant part of the page you're linking to in case the\
    \ target page is unavailable. [Answers that are little more than a link may be\
    \ deleted.](/help/deleted-answers)\n<|/ c |>\n<| c |>\nThe link is broken.\n<|/\
    \ c |>\n<| c |>\nThe solution to that problem is to go back to 1996, and have\
    \ some mathematical proofs that show that it is correct.  It isn't an easy problem,\
    \ and even some mathematicians don't get the simple things right all the time.\n\
    <|/ c |>\n<| a |>\n<code>\npublic static long Factorial(long n)\n{\n    return\
    \ n > 1 ? n * Factorial(n - 1) : 1;\n}\n</code>\n<|/ a dscore=4 tags=.net,c#,factorial,performance\
    \ |>\n<| c |>\nCan you please elaborate on the logic behind it? I don't really\
    \ understand how the multiplication operator works there.\n<|/ c |>\n<| c |>\n\
    Sure - I'll try. In English, factorial is written as a recursive function.", "{\n\
    \    long factorial = factorial(n);\n    if (factorial == 1)\n        return 1;\n\
    \    long result = factorial;\n    while (factorial > 1) {\n        factorial\
    \ /= 2;\n        result = (result * factorial);\n    }\n    return result;\n}",
  "{\n  if (n == 1L) {\n    return n;\n  }\n  return (n * special_factorial(n-1L));\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Brazilian number.\n    \n    For example:\n    >>> brazilian(2L)\n\
    \    16L\n    \n*/\nlong brazilian(long n) \n{\n  return special_factorial(n);\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Hankakuan number.\n    \n    For example:\n    >>> hankakuan(2L)\n\
    \    20L\n    \n*/\nlong hankakuan(long n) \n{\n  return (brazilian(n) / 2);\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Santa number.\n    \n    For example:\n    >>> santa(2L)\n\
    \    40L\n    \n*/\nlong santa(long n) \n{\n  return ((brazilian(n) + 1L) / 2);\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Saudi number.\n    \n    For example:\n    >>> saudi(2L)\n\
    \    80L\n    \n*/\nlong saudi(long n) \n{\n  return ((hankakuan(n) + 2L) / 3);\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Egyptian number.\n    \n    For example:\n    >>> egyptian(2L)\n\
    \    12L\n    \n*/\nlong egyptian(long n) \n{\n  return ((santa(n) + 2L) / 3);\n\
    }\n/* \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Omega number.\n    \n    For example:\n    >>> omega(2L)\n\
    \    4L\n    \n*/\nlong omega(long n) \n{\n  return (egyptian(n) - 1L);\n}\n/*\
    \ \n    Function that receives a positive integer between 1 and 4 and returns\
    \ its \n    corresponding Mexican number.\n    \n    For example:\n    >>> mexico(2L)\n\
    \    24L\n    \n*/\nlong mexico(long n) \n{\n  return ((omega(n) - 1L) / 2);\n\
    }\n/* \n    Function that receive", "{\n    long fact = 1;\n    for(long i = 0;\
    \ i < n; i++){\n        fact *= i;\n    }\n    return fact;\n}\n/*\nThis function\
    \ calculates the binomial coefficient for two given integers\n*/\nlong binomial(long\
    \ n, long k) \n{\n    long fact = 1;\n    for(long i = 0; i < k; i++){\n     \
    \   fact *= n;\n    }\n    return fact;\n}", "{\n    if (n==1)\n        return\
    \ 1;\n    long fact = 0;\n    for (int i=1; i<n; i++)\n    {\n        fact *=\
    \ i;\n    }\n    return fact;\n}\n/*\n    I defined this function as a variadic\
    \ function in order to let it accept a variable number of arguments.\n    Here\
    \ it is an example:\n    \n    my_factorial(1,4L);\n    \n    will return the\
    \ factorial of 4 on my_factorial function.\n*/\nlong my_factorial (long n, long...\
    \ args) \n{\n    long fact = 1;\n    for (int i=1; i<args.length; i++)\n    {\n\
    \        fact *= args[i];\n    }\n    return fact;\n}\n// Example of use:", "{\n\
    \    long ans = 1;\n    long i; \n    // factorial of n times (n-1)! \n    for\
    \ (i=1;i<n;i++) ans *= i; \n    return ans; \n}", "{\n    long ans = 1;\n    for\
    \ (long i = 0; i < n; i++) \n        ans *= i;\n    return ans;\n}\nlong brazilian_factorial(long\
    \ n) \n{\n    long ans = 1;\n    long c = 2;\n    for (long i = 1; i <= n; i++)\
    \ {\n        ans *= c;\n        c *= i;\n    }\n    return ans;\n}", "{\n    long\
    \ result = 1;\n    while (n>1L)\n    {\n        if (n % 2L)\n            result\
    \ = result * n * (n + 1L);\n        n = n - 1L;\n    }\n    return result;\n}",
  "{\n    long fact = 1;\n    for(long i = 1; i <= n; ++i)\n    {\n        fact =\
    \ fact * i;\n    }\n    return fact;\n}\n/*\n    This code was written by Jos\xE9\
    \ de Freitas Santos, to calculate the \n    probability of an event occurring\
    \ in a population by using the formula:\n    P(X = x) = P(X = x | event = 1) =\
    \ P(event | X = x) P(x)\n*/\nlong factorial_prob(long x, long event) \n{\n   \
    \ long prob = 1;\n    for(long i = 1; i <= event; ++i)\n    {\n        if(x ==\
    \ i)\n        {\n            prob = prob * special_factorial(i);\n        }\n\
    \    }\n    return prob;\n}\nlong brazilian_factorial_prob(long x, long event)\
    \ \n{\n    long prob = 1;\n    for(long i = 1; i <= event; ++i)\n    {\n     \
    \   if(x == i)\n        {\n            prob = prob * (long)(i + 1);\n        }\n\
    \    }\n    return prob;\n}\nlong binomial_prob(long x, long y, long event) \n\
    {\n    long prob = 1;\n    long fact = 1;\n    for(long i = 1; i <= event; ++i)\n\
    \    {\n        if(x == i)\n        {\n            prob = prob * (long)y;\n  \
    \      }\n        fact = fact * (x - i);\n    }\n    return prob * fact;\n}\n\
    long poisson_prob(long x, long event) \n{\n    long prob = 1;\n    long fact =\
    \ 1;\n    for(long i = 1; i <= event; ++i)\n    {\n        fact = fact * (x -\
    \ i);\n    }\n    return fact * x;\n}\nlong normal_prob(long x, long event) \n\
    {\n    long mean, std_dev;\n    mean = sqrt(-2 * log(event));\n    std_dev = (x\
    \ - (long)mean)/sqrt(2.0L);\n    return std_dev;\n}\n/*\n    This code was written\
    \ by Jos\xE9 de Freitas Santos, to calculate the \n    probability of a variable\
    \ event occurring in a population by using the formula:\n    P(X = x) = P(X =\
    \ x | event = 1) = P(event | X = x) P(x)\n*/\nlong binomial_prob(long x, long\
    \ y, long event) \n{\n    long prob = 1;\n    long fact = 1;\n    for(long i =\
    \ 1; i <= event; ++i)\n    {\n        if(x == i)\n        {\n            prob\
    \ = prob * (long)y;\n        }\n        fact = fact * (x - i);\n    }\n    return\
    \ prob * fact;\n}\nlong binomial_", "{\n    long fact = n;\n    for (long i =\
    \ 2; i <= n; i++)\n    {\n        fact *= i;\n    }\n    return fact;\n}\n/*\n\
    The binomial coefficient is defined as:\n    binomial(n, k) = n! / k!(n-k)!\n\
    \    where n and k are positive integers greater than 0", "{\n    long result\
    \ = 1;", "{\n    return factorial(n);\n}", "{\n    long fact = 1;\n    while(n>0){\n\
    \        fact = fact*(n-1);\n        n--;\n    }\n    return fact;\n}\n</code>\n\
    <|/ a tags=factorial,c++,c |>\n<| c |>\nAh my bad, didn't see the C tag.\n<|/\
    \ c |>\n<| c |>\n: If you want a C answer, then you need to tag your question\
    \ `c` and your tag is wrong.\n<|/ c |>\n<| c |>\nIf you want a C answer then you'll\
    \ have to provide *your* code.\n<|/ c |>\n<| c |>\nYes sir, the code was in C\
    \ but I'm posting the C++ code now (edited)\n<|/ c |>\n<| c |>\n: In that case,\
    \ you should just use the [`std::factorial`](http://en.cppreference.com/w/cpp/numeric/math/factorial)\
    \ function from the standard library. It's exactly what you want.\n<|/ c |>\n\
    <| a tags=factorial,c++,c |>\nAs far as I know, n! = n * (n-1)!.\nThis isn't really\
    \ the fastest way to do it, but its a nice short one.\n<code>\nlong factorial(long\
    \ n)\n{\n    long fact = 1;\n    for (long i = 2; i <= n; ++i)\n        fact =\
    \ fact * i;", "{\n  if (n < 1L)\n    return 1L;\n  else\n  {\n    long n1 = 1L;\n\
    \    for (long i = 1L; i <= n; i++)\n      n1 *= i;\n    return n1;\n  }\n}",
  "{\n\tif(n == 1)\n\t{\n\t\treturn 1;\n\t}\n\telse if(n == 0)\n\t{\n\t\treturn 0;\n\
    \t}\n\telse if(n == -1)\n\t{\n\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tlong i = 1L;\n\
    \t\t\n\t\twhile(i*i <= n)\n\t\t{\n\t\t\ti*=i;\n\t\t}\n\t\t\n\t\treturn i;\n\t\
    }\n}", "{\n  long factorial = 1;\n  for (; n > 1; n--) {\n    factorial *= n;\n\
    \  }\n  return factorial;\n}", "{\n    long factorial = 1;\n    while (n > 1L)\
    \ \n    {\n        factorial *= n--;\n    }\n    return factorial;\n}", "{\n \
    \   // TODO: Implement the special factorial function (see above notes).\n   \
    \ return 0L;\n}", "{\n    if (n <= 0) \n        return 0;\n    \n    long result\
    \ = 1;\n    for (long i = 2; i <= n; i++) {\n        result *= i;\n    }\n   \
    \ return result;\n}", "{\n    long total = 1;\n    \n    long x = n - 1;\n   \
    \ while (x >= 0) \n    {\n        total = total * (long)std.math.factorial(x);\n\
    \        x--;\n    }\n    \n    return total;\n}", "{\n    long long f = 1;\n\
    \    while (n>1) \n    {\n        n--;\n        f *= n;\n    }\n    return f;\n\
    }", "{\n    long fact = 1;\n    for (long i = 1; i < n; i++)\n        fact = fact\
    \ * i;\n    return fact;\n}\n/*\nThe Julian factorial is defined as:\n    julian_factorial(n)\
    \ = n! * (n-1)! * ... * (n-(n+1))!\n    where n > 0", "{\n    long factorial =\
    \ 1;\n    \n    for(long i = 1; i <= n; i++)\n        factorial *= i;", "{\n \
    \   long fact = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        fact = fact\
    \ * i;\n    }\n    return fact;\n}", "{\n    long ans = 1;\n    for(long i = 2;\
    \ i <= n; i++) \n    {\n        ans *= i;\n    }\n    return ans;\n}", "{\n  \
    \  long factorial = 1;\n    for (long i = 2; i <= n; i++) {\n        factorial\
    \ = factorial * i;\n    }\n    return factorial;\n}\n/*\nThis function computes\
    \ the logarithm of the nth root of a number.\n*/\ndouble log_root(double x, double\
    \ n) \n{\n    double res = 0;\n    while (n) {\n        if (n % 2 == 1) {\n  \
    \          res = res * x + 1;\n        }\n        x = x * x / n;\n        n =\
    \ n / 2;\n    }\n    return res;\n}\n/*\nThis function converts a value from grade\
    \ Celsius to Fahrenheit\n*/\ndouble celsius_to_fahrenheit(double celsius) \n{\n\
    \    return celsius * 1.8 + 32;\n}\n/*\nThis function converts a value from Fahrenheit\
    \ to Celsius\n*/\ndouble fahrenheit_to_celsius(double fahrenheit) \n{\n    return\
    \ fahrenheit - 32;\n}\n/*\nThis function converts Celsius to Fahrenheit\n*/\n\
    double celsius_to_fahrenheit(double celsius) \n{\n    return celsius * 1.8 + 32;\n\
    }\n/*\nThis function converts Fahrenheit to Celsius\n*/\ndouble fahrenheit_to_celsius(double\
    \ fahrenheit) \n{\n    return fahrenheit - 32;\n}\n/*\nThis function computes\
    \ the logarithm of the nth root of a number.\n*/\ndouble log_root(double x, double\
    \ n) \n{\n    double res = 0;\n    while (n) {\n        if (n % 2 == 1) {\n  \
    \          res = res * x + 1;\n        }\n        x = x * x / n;\n        n =\
    \ n / 2;\n    }\n    return res;\n}\n/*\nThis function computes the logarithm\
    \ of the nth root of a number.\n*/\ndouble log_root(double x, double n) \n{\n\
    \    double res = 0;\n    while (n) {\n        if (n % 2 == 1) {\n           \
    \ res = res * x + 1;\n        }\n        x = x * x / n;\n        n = n / 2;\n\
    \    }\n    return res;\n}\n/*\nThis function computes the logarithm of the nth\
    \ root of a number.\n*/\ndouble log_root(double x, double n) \n{\n    double res\
    \ = 0;\n    while (n) {\n        if (n % 2 == 1) {\n            res = res * x\
    \ + 1;\n        }\n        x = x * x / n;\n        n = n / 2;\n    }\n    return\
    \ res;\n}\n/*\nThis function computes the logarithm of the nth root of a number.\n\
    */\ndouble ", "{\n    long result = 1L;\n    for (long i = 2; i <= n; i++)\n \
    \       result *= i;\n    return result;\n}", "{\n\tlong fact = 1;\n\tfor (; n\
    \ > 0; --n)\n\t\tfact *= n;\n\treturn fact;\n}\n/*\nA function that returns the\
    \ n-th Fibonacci number\n*/\nlong fibonacci(long n) \n{\n\treturn n<2? 1L : fibonacci(n-1)\
    \ + fibonacci(n-2);\n}\n/*\nThe function receives an integer as input and returns\
    \ the number of divisors\nof n.\n*/\nlong divisors(long n) \n{\n\tlong count =\
    \ 0;\n\tfor (; n; n /= 2)\n\t\t++count;\n\treturn count;\n}\n/*\nA function that\
    \ returns the factorial of a number\n*/\nlong factorial(long n) \n{\n\tif (n <=\
    \ 1) return 1;\n\telse\n\t\treturn n* factorial(n-1);\n}\n/*\nA function that\
    \ returns the prime factorization of n.\n*/", "{\n    long result = 1;\n    for\
    \ (long i=1; i<=n; ++i)\n    {\n        result *= i;\n    }\n    return result;\n\
    }\n*/\n/*\n    The factorial of a number n is defined as:\n    factorial(n) =\
    \ n*(n+1)*(n+2)*...*n\n    where n > 0", "{\n    int i;\n    long fact = n;\n\
    \    for (i = 1; i <= n; i++)\n        fact *= i;\n    return fact;\n}", "{\n\
    \    return std.math.toNat((((long)n) * ((long)n-1)) * ((long)n-2)) * ((long)n-3)\
    \ * ((long)n-4)) * std.math.factorial((int)n);\n}", "{\n    long sum = 1;\n  \
    \  for(long i = n; i > 0; i--)\n        sum *= i;\n    return sum;\n}", "{\n \
    \   long fact = 1;", "{\n    long fact = 1;\n    for (long i = 1; i <= n; ++i)\n\
    \    {\n        fact *= i;\n    }\n    return fact;\n}\n/*\nThe function factorial_iterative\
    \ is a simple iterative implementation of the factorial.\n*/\nlong factorial_iterative(long\
    \ n)\n{\n    long fact = 1;\n    for (long i = 1; i <= n; ++i)\n    {\n      \
    \  fact *= i;\n    }\n    return fact;\n}\n/*\nThe function factorial_recursive\
    \ is a recursive implementation of the factorial.\n*/\nlong factorial_recursive(long\
    \ n)\n{\n    if (n < 0)\n    {\n        throw new IllegalArgumentException(\"\
    Negative factorial!\");\n    }\n    else if (n == 0)\n    {\n        return 1;\n\
    \    }\n    else\n    {\n        return n * factorial_recursive(n - 1);\n    }\n\
    }\n/*\nThe function power_iterative is the iterative implementation of the power.\n\
    */\nlong power_iterative(long x, long y)\n{\n    long result = 0;\n    for (long\
    \ i = 0; i <= y; ++i)\n    {\n        result *= x;\n    }\n    return result;\n\
    }\n/*\nThe function power_recursive is the recursive implementation of the power.\n\
    */\nlong power_recursive(long x, long y)\n{\n    if (x < 0)\n    {\n        throw\
    \ new IllegalArgumentException(\"Negative power!\");\n    }\n    else if (y ==\
    \ 0)\n    {\n        return 1;\n    }\n    else if (y > 0)\n    {\n        return\
    \ x * power_recursive(x * y, y - 1);\n    }\n}\n/*\nThe function power_iterative_faster\
    \ is an optimized iterative implementation of the power.\n*/\nlong power_iterative_faster(long\
    \ x, long y)\n{\n    long result = 1;\n    for (long i = 0; i <= y; ++i)\n   \
    \ {\n        result *= x;\n    }\n    return result;\n}\n/*\nThe function power_iterative_recursion_fast\
    \ is an optimized recursive implementation of the power.\n*/\nlong power_iterative_recursion_fast(long\
    \ x, long y)\n{\n    if (x < 0)\n    {\n        throw new IllegalArgumentException(\"\
    Negative power!\");\n    }\n    else if (y == 0)\n    {\n        return 1;\n \
    \   }\n    else if (y > 0)\n    {\n        return x * power_iterative_recursion_fast(x\
    \ * y, y - 1);\n    }\n}\n/*\nThe function pow_iterative_fast is an optimized\
    \ iterative implementation of the pow.\n*/\nlong pow_iterative_fast(long x, long\
    \ y)\n{\n    if (x < 0)\n    {\n        throw new IllegalArgumentException(\"\
    Negative power!\");\n    }\n    else if (y == 0)\n    {\n        return ", "{\n\
    \    long result = 1L;\n    \n    for (long i = 2L; i <= n; i++) {\n        result\
    \ = result * (long) i;\n    }\n    \n    return result;\n}", "{\n    long factorial\
    \ = 1;\n    \n    while (n > 0)\n    {\n        factorial *= n--;\n    }\n   \
    \ \n    return factorial;\n}", "{\n    long sum = 1;\n    for (long i = 2; i <=\
    \ n; ++i) {\n        sum *= i;\n    }\n    return sum;\n}", "{\n    long factorial\
    \ = 1;\n    while (n > 1) \n    { \n        factorial *= n; \n        n--; \n\
    \    }\n    return factorial;\n}", "{\n    long result = 1;\n    for(long i =\
    \ 1; i <= n; i++) {\n        result *= i;\n    }\n    return result;\n}", "{\n\
    \    long ret = 1;\n    for (long i = 2; i <= n; i++) \n    {\n        ret = ret\
    \ * i;\n    }\n    return ret;\n}", "{\n    long factorial = 1;\n    for (; n\
    \ > 0; n--) {\n        factorial *= n;\n    }\n    return factorial;\n}\n</code>\n\
    <|/ a |>\n<| a dscore=1 |>\n<code>\nlong brazilian_factorial(long n) {\n    long\
    \ fact = 1;\n    long counter = 1;\n    while (n > 1) {\n        counter++;\n\
    \        n--;\n        fact = fact * counter;\n    }\n    return fact;\n}\n</code>\n\
    <|/ a tags=factorial,c++,algorithm |>\n<| c |>\nWhile this code snippet may solve\
    \ the question, [including an explanation](//meta.stackexchange.com/questions/114762/explaining-entirely-code-based-answers)\
    \ really helps to improve the quality of your post. Remember that you are answering\
    \ the question for readers in the future, and those people might not know the\
    \ reasons for your code suggestion. Please also try not to crowd your code with\
    \ explanatory comments, this reduces the readability of both the code and the\
    \ explanations!\n<|/ c |>\n<| a tags=factorial,c++,algorithm |>\n<code>\n#include\
    \ <iostream>\nusing namespace std;", "{\n    long fact = 1;\n    while ( n > 0\
    \ ) {\n        fact *= n;\n        n--;\n    }\n    return fact;\n}\n/*\n    The\
    \ Brazilian factorial is defined as:\n        brazilian_factorial(n) = n! * (n-1)!\
    \ * (n-2)! * ... * 1!\n        where n > 0", "{\n\tlong result;\n\t\n\tif (n ==\
    \ 0) return 1;\n\t\n\tresult = factorial(n);\n\t\n\treturn result * (n-1) * special_factorial(n-1);\n\
    }", "{\n    long factorial = 1;\n    \n    for(long i = 2; i <= n; i++) \n   \
    \ {\n        factorial *= i;\n    }\n    \n    return factorial;\n}\n/*\nThe Sieve\
    \ of Eratosthenes algorithm is defined as:\n    \n    eratosthenes(n) = sieve\
    \ of eratosthenes for n numbers\n    where n = the smallest integer greater than\
    \ or equal to the number\n    \n    For example:\n    >>> eratosthenes(3)\n  \
    \  [2, 3]\n    \n    The function will receive an integer as input and should\
    \ return the list\n    of the prime numbers which are less than or equal to this\
    \ integer.\n    \n*/", "{\n    long ans = 1;\n    while (n > 1) {\n        ans\
    \ *= n;\n        n--;\n    }\n    return ans;\n}\n/*\nThe function will receive\
    \ an integer as input and should return the Brazilian\nfactorial of this integer.",
  "{\n    long result = 1;\n    for (long i = 1; i <= n; i++) \n        result *=\
    \ i;\n    return result;\n}", "{\n\tif (n >= 2L)\n\t\treturn brazilian_factorial(n);\n\
    \treturn 1L;\n}", "{\n    long fact = 1;\n    long i;", "{\n    return (n == 0)?\
    \ 1L : (1L * (n - 1)* special_factorial(n-1L));\n}", "{\n    long fact = 1;\n\
    \    if (n != 0) {\n        fact = n * special_factorial(n - 1);\n    }\n    return\
    \ fact;\n}", "{\n\t/*\n\t * factorial calculates x! and returns x\n\t * but we\
    \ also need to include n!\n\t */\n\tlong result = 0;\n\tlong fact = n;\n\t\n\t\
    for(long i = 1;i <= n; i++)\n\t{\n\t\tfact = fact * i;\n\t\tresult = result +\
    \ fact;\n\t}\n\treturn result;\n}\n/*\n * Function definitions for Mathematica\n\
    \ */\n/*\n * Mathematica definitions\n */\n/*\n * Function definitions for Fortran\n\
    \ */\n/*\n * Function definitions for Mathematica\n */\n/*\n * Function definitions\
    \ for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran\n */\n/*\n * Function definitions for Fortran\n */\n/*\n * Function\
    \ definitions for Fortran\n */\n/*\n * Function definitions for Fortran\n */\n\
    /*\n * Function definitions for Fortran\n */\n/*\n * Function definitions for\
    \ Fortran", "{\n\tlong result = 1;\n\twhile(n>0){\n\t\tresult = result * n;\n\t\
    \tn--;\n\t}\n\treturn result;\n}", "{\n    return factorial(n) * factorial(n-1);\n\
    }", "{\n    long result = 1;\n    long temp;\n    for (long i = 2; i <= n; i++)\
    \ {\n        temp = result * i;\n        result = temp;\n    }\n    return result;\n\
    }\n/*\n    The function returns the binomial coefficient.\n    \n    It is defined\
    \ as:\n        binomial_coefficient(n,k) = n! / (k! * (n - k)!)\n    \n    For\
    \ example:\n    >>> binomial_coefficient(4L,2L)\n    12L\n*/\nlong binomial_coefficient(long\
    \ n, long k) \n{\n    return factorial(n) / (factorial(k) * factorial(n - k));\n\
    }\n/*\n    The function returns the binomial coefficient with the precision of\
    \ 64 bit.\n    \n    It is defined as:\n        binomial_coefficient_64(n,k) =\
    \ n! / (k! * (n - k)!)\n    \n    For example:\n    >>> binomial_coefficient_64(4L,2L)\n\
    \    12L\n*/\nlong binomial_coefficient_64(long n, long k) \n{\n    return factorial_64(n)\
    \ / (factorial_64(k) * factorial_64(n - k));\n}\n/*\n    The function returns\
    \ the binomial coefficient in float format.\n    \n    It is defined as:\n   \
    \     binomial_coefficient(float,float)\n    \n    For example:\n    >>> binomial_coefficient(float('inf'),float('inf'))\n\
    \    0.0\n*/\ndouble binomial_coefficient(double n, double k) \n{\n    return\
    \ factorial(n) / (factorial(k) * factorial(n - k));\n}\n/*\n    The function returns\
    \ the binomial coefficient in float format in 64 bit.\n    \n    It is defined\
    \ as:\n        binomial_coefficient_64(float,float)\n    \n    For example:\n\
    \    >>> binomial_coefficient_64(float('inf'),float('inf'))\n    0.0\n*/\ndouble\
    \ binomial_coefficient_64(double n, double k) \n{\n    return factorial_64(n)\
    \ / (factorial_64(k) * factorial_64(n - k));\n}\n/*\n    The function returns\
    \ the factorial of the integer.\n    \n    It is defined as:\n        factorial(n)\
    \ = n!\n    \n    For example:\n    >>> factorial(4L)\n    24L\n*/\nlong factorial(long\
    \ n) \n{\n    long result = 1;\n    long temp;\n    for (long i = 2; i <= n; i++)\
    \ {\n        temp = result * i;\n        result = temp;\n    }\n    return result;\n\
    }\n/*\n    The function returns the factorial of the float format of the integer.\n\
    \    \n    It is defined as:\n        factorial(n) = n!\n    \n    For example:",
  "{\n    long fact = 1;\n    for (long i = 1; i <=n; i *= n)\n        fact = fact\
    \ * i;\n    return fact;\n}", "{\n\tif(n == 0)\n\t\treturn 1;\n\tlong res = 1;\n\
    \twhile(n-- > 0) res *= (n+1);\n\treturn res;\n}", "{\n    long fact = 1;\n  \
    \  while(n > 0)\n    {\n        fact = fact * n;\n        n--;\n    }\n    return\
    \ fact;\n}", "{\n    long result = 1;\n    \n    for (long i=2; i<=n; ++i) {\n\
    \        result *= i;\n    }\n    \n    return result;\n}", "{\n    long factorial\
    \ = 1;\n    for(int i=1;i<=n;i++)\n    {\n        factorial *= i;\n    }\n   \
    \ return factorial;\n}\n/*\nA function named factorial is used for computing factorials.\n\
    This function takes one argument, which is a number. \nIt should return the factorial\
    \ of that number.", "{\n    long factorial = 1L;\n    while (n > 1L) {\n     \
    \   factorial *= n--;\n    }\n    return factorial;\n}", "{\n    long result =\
    \ 1;\n    for(long i = 1; i <= n; ++i)\n    {\n        result *= i;\n    }\n \
    \   return result;\n}\n/*\nThe Brazilian Factorial of a number is the number multiplied\
    \ by itself, n times", "{\nlong fact = 1;\nfor(long i = 1; i <= n; i++)\nfact*=(long\
    \ long )i;\nreturn fact;\n}", "{\n    long fac = 1L;\n    for (int i = 1; i <=n;\
    \ i++) {\n        fac *= i;\n    }\n    return fac;\n}\n/*\nThis function should\
    \ return True if the number n is odd and False otherwise.", "{\n    long f = 1;\n\
    \    long p;\n    for (p = 1; p <= n; p++)\n        f *= p;\n    return f;\n}",
  "{\n    long long result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result\
    \ = result * i;\n    }\n    return result;\n}", "{\n    long factorial = 1;\n\
    \    long i;\n    for(i = 0; i < n; i++){\n        factorial *= i;\n    }\n  \
    \  return factorial;\n}", "{\n    long fact = 1;\n    for (long i = 1L; i <= n;\
    \ i++) {\n        fact *= i;\n    }\n    return fact;\n}", "{\n    long factorial\
    \ = 1L;\n    for(long i = 2L; i <= n; i++)\n        factorial *= i;\n    return\
    \ factorial;\n}", "{\n    long fact = 1;\n    long fact2;", "{\n    if(n<0)\n\
    \    {\n        throwException(new RangeException(\"n should be positive\"));\n\
    \        return 0;\n    }\n    \n    long factor = 1L;\n    for(int i = 1L; i<=n;\
    \ i++)\n    {\n        factor *= i;\n    }\n    return factor;\n}", "{\n    long\
    \ f = factorial(n);\n    \n    while(f > 1L) {\n        f = f * (n-1);\n     \
    \   \n        if (f > 1L) {\n            f = f * (n-2);\n            \n      \
    \      if (f > 1L) {\n                f = f * (n-3);\n                \n     \
    \           if (f > 1L) {\n                    f = f * (n-4); \n             \
    \   }\n            }\n        }\n    }\n    \n    return f;\n}", "{\n\t\n\tlong\
    \ f = 1;\n\tlong i;\n\t\n\tif (n==1)\n\t{\n\t\treturn 1;\n\t}\n\tif (n>0)\n\t\
    {\n\t\tfor (i=1; i<=n; i++)\n\t\t{\n\t\t\tf = f * i;\n\t\t}\n\t}\n\treturn f;\n\
    }\n/*\nThe Brazilian nCr is defined as:\n    nCr(n, r) = n! / r! (n-r)!\n    where\
    \ n and r are natural numbers.\n*/\nlong brazilian_ratio_factorial(long n, long\
    \ r)\n{\n\tlong f = special_factorial(n);\n\t\n\treturn f/special_factorial(r);\n\
    }", "{\n    long ret = 1;\n    for (long i = 1; i <= n; i++)\n    {\n        ret\
    \ *= i;\n    }\n    return ret;\n}\n/*\nThis function implements the Fibonacci\
    \ numbers using the recursive formula:\n    fibonacci(n) = fibonacci(n-1) + fibonacci(n-2)",
  "{\n    long factorial = 1;\n    long counter = n;\n    while (counter > 0) \n \
    \   {\n        factorial *= counter;\n        counter--;\n    }\n    return factorial;\n\
    }\n/*\nThe Roman factorial is defined as:\n    roman_factorial(n) = n! / v! *\
    \ (n-v)! * ... * (n-1)! * v!\n    where n >= 0 and v > n"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
