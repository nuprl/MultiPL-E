language: scala
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = evens.takeWhile(x => x != even).takeWhile(x => x % 2 ==\
    \ 0).sorted\n        if (result.isEmpty) List(even, index)\n        else List(even,\
    \ index).sortWith((x, y) => x < y)\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbielzlmm.scala:35:52 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m List(even, index).sortWith((x,\
    \ y) => x < y)\n\e[31m\e[31m   |\e[0m                                        \
    \          ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of AnyVal, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m\
    \   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result: List[Long] = if (index == -1) Nil else List(even, index)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\
    \tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.pluck(tmpxual_w9k.scala:31)\n\
    \tat Problem$.main(tmpxual_w9k.scala:39)\n\tat Problem.main(tmpxual_w9k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOfMin\n        val smallestEvenValue\
    \ = smallestEven / 2\n        val smallestEvenIndex = smallestEvenIndex\n    \
    \    val result = arr.filter(_ == smallestEvenValue)\n        val resultSorted\
    \ = result.sortWith(_ < _)\n        val smallestValue = resultSorted.head\n  \
    \      val smallestIndex = resultSorted.indexOfMin\n        val smallestIndex\
    \ = smallestIndex\n        val resultList = List(smallestValue, smallestIndex)\n\
    \        return resultList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc1t12s3u.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpc1t12s3u.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmallestIndex\e[0m = smallestIndex\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0msmallestIndex is already defined as \e[33mvalue\e[0m \e[35msmallestIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpc1t12s3u.scala:33:44 ------------------------\e[0m\e[0m\n\
    \e[31m33 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = evensSorted.indexOfMin\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue indexOfMin is not a member of List[Long] - did you mean\
    \ evensSorted.indexOf?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc1t12s3u.scala:39:41\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36msmallestIndex\e[0m = resultSorted.indexOfMin\n\e[31m\e[31m   |\e[0m      \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue indexOfMin\
    \ is not a member of List[Long] - did you mean resultSorted.indexOf?\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val smalest_value = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n\
    \        val smalest_evens = evens.filter(_ == smalest_value)\n        val smalest_evens_index\
    \ = smalest_evens.indexOf(smalest_value)\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_index = smalest_evens_index + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_index\
    \ = smalest_evens_index + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_index = smalest_evens_index + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_index\
    \ = smalest_evens_index + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_index = smalest_evens_index + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_index\
    \ = smalest_evens_index + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_index = smalest_evens_index + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_index\
    \ = smalest_evens_index + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_index = smalest_evens_index + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_index\
    \ = smalest_evens_index + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_index = smalest_evens_index + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_index\
    \ = smalest_evens_index + 1\n        val smalest_evens_index = smalest_evens_index\
    \ + 1\n        val smalest_evens_index = smalest_evens_index + 1\n        val\
    \ smalest_evens_index = smalest_evens_index + 1\n        val smalest_evens_index\
    \ = sm\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpubi2n_mq.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpubi2n_mq.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpubi2n_mq.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpubi2n_mq.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_evens_index\e[0m\
    \ = smalest_evens_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalest_evens_index is already defined as \e[33mvalue\e[0m\
    \ \e[35msmalest_evens_index\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpubi2n_mq.scala:39:12 ---------"
  stdout: ''
  timestamp: 1659798887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val smalest_value = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n\
    \        val result = evens.filter(_ == smalest_value).takeWhile(_ != smalest_value)\n\
    \        if (result.isEmpty) result else result.zip(evens.indexOf(result)).filter(_._2\
    \ == smalest_index).map(_._1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3mm43cen.scala:34:64\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result \e[33melse\e[0m result.zip(evens.indexOf(result)).filter(_._2 == smalest_index).map(_._1)\n\
    \e[31m\e[31m   |\e[0m                                                   ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Int\n\
    \e[31m   |\e[0m                                             Required: IterableOnce[Any]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sorted\n        val evensSortedIndex = evensSorted.indexWhere(x\
    \ => x == evensSorted.head)\n        val evensSortedEvens = evensSorted.take(evensSortedIndex\
    \ + 1)\n        val evensSortedEvensSorted = evensSortedEvens.sorted\n       \
    \ val evensSortedEvensSortedIndex = evensSortedEvensSorted.indexWhere(x => x ==\
    \ evensSortedEvensSorted.head)\n        val smalest_value = evensSortedEvensSortedIndex\n\
    \        val smalest_index = evensSortedIndex\n        if (evensSorted.isEmpty)\
    \ {\n            List[Long]()\n        } else {\n            evensSortedEvensSortedIndex.map(x\
    \ => x % 2 == 0).filter(x => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x\
    \ => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x\
    \ => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x\
    \ => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x\
    \ => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x\
    \ => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x\
    \ => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x\
    \ => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x\
    \ => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x\
    \ => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x\
    \ => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x\
    \ => x).map(x => x).takeWhile(x => x).map(x => x).takeWhile(x => x).\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp24d5tide.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp24d5tide.scala:55:0 ----------------------------\e[0m\e[0m\n\e[31m55\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp24d5tide.scala:41:40 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            evensSortedEvensSortedIndex.map(\e[36mx\e\
    [0m => x % \e[31m2\e[0m == \e[31m0\e[0m).filter(\e[36mx\e[0m => x).map(\e[36mx\e\
    [0m => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e\
    [0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m\
    \ => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e\
    [0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m\
    \ => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e\
    [0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m\
    \ => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e\
    [0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m\
    \ => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e\
    [0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m\
    \ => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e\
    [0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m\
    \ => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e\
    [0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m\
    \ => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e\
    [0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m\
    \ => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e\
    [0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m\
    \ => x).takeWhile(\e[36mx\e[0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e\
    [0m => x).map(\e[36mx\e[0m => x).takeWhile(\e[36mx\e[0m => x).map(\e"
  stdout: ''
  timestamp: 1659798888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x =>\
    \ x != even).take(index).toList\n        if (result.isEmpty) result else result\
    \ ++ List(even, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp02_8ahup.scala:37)\n\tat Problem.main(tmp02_8ahup.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x - y)\n        val evensSortedSet\
    \ = evensSorted.toSet\n        val evensSortedSortedSet = evensSortedSet.toSet\n\
    \        val evensSortedSortedSet = evensSortedSortedSet.toSet\n        val evensSortedSortedSet\
    \ = evensSortedSortedSet.toSet\n        val evensSortedSortedSet = evensSortedSortedSet.toSet\n\
    \        val evensSortedSortedSet = evensSortedSortedSet.toSet\n        val evensSortedSortedSet\
    \ = evensSortedSortedSet.toSet\n        val evensSortedSortedSet = evensSortedSortedSet.toSet\n\
    \        val evensSortedSortedSet = evensSortedSortedSet.toSet\n        val evensSortedSortedSet\
    \ = evensSortedSortedSet.toSet\n        val evensSortedSortedSet = evensSortedSortedSet.toSet\n\
    \        val evensSortedSortedSet = evensSortedSortedSet.toSet\n        val evensSortedSortedSet\
    \ = evensSortedSortedSet.toSet\n        val evensSortedSortedSet = evensSortedSortedSet.toSet\n\
    \        val evensSortedSortedSet = evensSortedSortedSet.toSet\n        val evensSortedSortedSet\
    \ = evensSortedSortedSet.toSet\n        val evensSortedSortedSet = evensSortedSortedSet.toSet\n\
    \        val evensSortedSortedSet = evensSortedSortedSet.toSet\n        val evensSortedSortedSet\
    \ = evensSortedSortedSet.toSet\n        val evensSortedSortedSet = evensSortedSortedSet.toSet\n\
    \        val evensSortedSortedSet = evensSortedSortedSet.toSet\n        val evensSortedSortedSet\
    \ = evensSortedSortedSet.toSet\n        val evensSortedSortedSet = evensSortedSortedSet.toSet\n\
    \        val evensSortedSortedSet = evensSortedSortedSet.toSet\n        val evensSortedSortedSet\
    \ = evensSortedSortedSet.toSet\n        val evensSortedSortedSet = evensSortedSortedSet.toSet\n\
    \        val evensSortedSortedSet = evensSortedSortedSet.toSet\n        val evensSortedSortedSet\
    \ = evensSortedSortedSet.toSet\n        val evensSortedSortedSet = evensSortedSortedSet.toSet\n\
    \        val evensSortedSortedSet = evensSortedSortedSet.toSet\n        val evensSortedSorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphpd7cnid.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphpd7cnid.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevensSortedSortedSet\e[0m = evensSortedSortedSet.toSet\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mevensSortedSortedSet is already defined as \e[33mvalue\e[0m \e[35mevensSortedSortedSet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphpd7cnid.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mevensSortedSortedSet\e[0m = evensSortedSortedSet.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSortedSortedSet is already defined as \e[33mvalue\e[0m\
    \ \e[35mevensSortedSortedSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphpd7cnid.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevensSortedSortedSet\e[0m\
    \ = evensSortedSortedSet.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSortedSortedSet is already defined as \e[33mvalue\e[0m\
    \ \e[35mevensSortedSortedSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphpd7cnid.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mevensSortedSortedSet\e[0m\
    \ = evensSortedSortedSet.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSortedSortedSet is already defined as \e[33mvalue\e[0m\
    \ \e[35mevensSortedSortedSet"
  stdout: ''
  timestamp: 1659798888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(_ % 2 == 0).sortBy(_)\n\
    \        val index = even.zipWithIndex.filter(_._2 % 2 == 0).minBy(_._1)._2\n\
    \        even.filter(_ == index).sortBy(_)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp8e8gla6n.scala:30:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36meven\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                        ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmp8e8gla6n.scala:32:39 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        even.filter(_ == index).sortBy(_)\n\e[31m\e[31m\
    \   |\e[0m                                       ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$6 of expanded function:\n\e[31m   |\e[0m   _$6 => even.filter(_$5\
    \ => _$5 == index).sortBy(_$6).\n2 errors found\n"
  stdout: ''
  timestamp: 1659798887
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result: List[Long] = List(even, index)\n        if (evens.isEmpty)\
    \ result\n        else result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf4h32boo.scala:38)\n\tat Problem.main(tmpf4h32boo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted = evens.sorted\n\
    \        val smallestEven = evensSorted.head\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(0)\n        val index = smallestEvenIndex\n        val smallestEvenValue\
    \ = evensSorted.take(smallestEvenIndex).sum\n        val smallestEvenValueIndex\
    \ = evensSorted.indexOf(smallestEvenValue)\n        result.add(smallestEvenValue)\n\
    \        result.add(smallestEvenValueIndex)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpual3d3jg.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798884
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x - y)\n        val evensSortedIndex\
    \ = evensSorted.zipWithIndex.toList\n        val smallestEven = evensSortedIndex.minBy(x\
    \ => x._2)\n        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = evensSortedIndex.find(x => x._1 == smallestEvenValue).get._2\n        val\
    \ smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex\
    \ - 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smalle\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqaud68t8.scala:71:4 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqaud68t8.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndex\e[0m = smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqaud68t8.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = smallestEvenIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqaud68t8.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqaud68t8.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded"
  stdout: ''
  timestamp: 1659798888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(-_)\n\
    \        val even = evens.head\n        val index = evens.indexOf(0)\n       \
    \ val result = List(even, index)\n        if (evens.isEmpty) result\n        else\
    \ result.sortBy(-_)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphdfyaybb.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmphdfyaybb.scala:35:27 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(-_)\n\e[31m\e[31m\
    \   |\e[0m                           ^^\e[0m\n\e[31m   |\e[0mvalue unary_- is\
    \ not a member of AnyVal, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmphdfyaybb.scala:35:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(-_)\n\e[31m\e[31m\
    \   |\e[0m                              ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659798888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        if (even.isEmpty) List()\n        else {\n\
    \            val smalest_value = even(0)\n            val smalest_index = even.indexOf(smalest_value)\n\
    \            val result = even.takeWhile(x => x != smalest_value).takeWhile(x\
    \ => x != smalest_index).reverse\n            if (result.isEmpty) List()\n   \
    \         else List(smalest_value, smalest_index)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpng4866ke.scala:41)\n\tat Problem.main(tmpng4866ke.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_)\n\
    \        val even = evens.head\n        val index = arr.indexOf(even)\n      \
    \  val result = List(even, index)\n        if (evens.isEmpty) result\n       \
    \ else result.sortBy(_._1).reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpocte9l2u.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\e[31m   |\e[0m\
    \      /* missing */summon[java.util.Comparator[Any]]\n\e[31m   |\e[0m    )\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type\
    \ java.util.Comparator[Any].\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpocte9l2u.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[Int])\n\e[31m  \
    \ |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpocte9l2u.scala:35:29 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                           ^^^^\e[0m\n\e[31m   |\e[0m   \
    \                        value _1 is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpocte9l2u.scala:35:32 -----------------------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_._1).reverse\n\e[31m\e\
    [31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1659798888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0)\n        val evenSorted = even.sortWith((x, y) => x.compare(y))\n       \
    \ val evenSmallest = evenSorted.head\n        val evenSmallestIndex = evenSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestValueList = evenSmallestValue.toList\n\
    \        if (evenSmallestIndexList.isEmpty) {\n            evenSmallestIndexList.foreach(x\
    \ => evenSmallestValueList.map(_ + 1))\n        }\n        else {\n          \
    \  evenSmallestIndexList.foreach(x => evenSmallestValueList.map(_ + 1))\n    \
    \        evenSmallestIndexList.foreach(x => evenSmallestValueList.map(_ + x))\n\
    \        }\n        evenSmallestValueList.map(x => evenSmallestValue)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp04zhgx7t.scala:31:58\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevenSorted\e\
    [0m = even.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m\
    \   |\e[0m                                                 ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                 Found:    Int\n\
    \e[31m   |\e[0m                                                 Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp04zhgx7t.scala:35:54\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mevenSmallestIndexList\e[0m = evenSmallestIndex.toList\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue toList is not a member of Int - did you mean evenSmallestIndex.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp04zhgx7t.scala:36:54 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e\
    [0m = evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Long - did you mean evenSmallestValue.toInt?\n3 errors found\n"
  stdout: ''
  timestamp: 1659798888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val even = evens.head\n        val index\
    \ = evens.indexOf(0)\n        val result = List(even, index)\n        if (arr.isEmpty)\
    \ result\n        else pluck(arr.drop(1))\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxep32a2q.scala:34:25\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_)\n\
    \        val smallest = evens.head\n        val index = evens.indexOf(0)\n   \
    \     val result: List[Long] = if (index == -1) List(smallest) else evens.take(index).sortBy(_)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp_apfyk6v.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmp_apfyk6v.scala:33:95 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mif\e[0m (index == -\e[31m1\e[0m) List(smallest) \e\
    [33melse\e[0m evens.take(index).sortBy(_)\n\e[31m\e[31m   |\e[0m             \
    \                                                                            \
    \      ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m   I could not infer the type of the parameter _$3 of expanded function:\n\
    \e[31m   |\e[0m   _$3 => evens.take(index).sortBy(_$3).\n2 errors found\n"
  stdout: ''
  timestamp: 1659798887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n        val evensSortedWithIndex\
    \ = evensSorted.zipWithIndex\n        val smallestEven = evensSortedWithIndex.minBy(_._1)._2\n\
    \        val smallestEvenIndex = evensSortedWithIndex.minBy(_._1)._1\n       \
    \ val index = arr.indexOf(smallestEven)\n        val result = List(smallestEven,\
    \ smallestEvenIndex)\n        if (arr.isEmpty) result\n        else result.::(pluck(arr.drop(index)))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8iz59wlg.scala:37:25\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp8iz59wlg.scala:38:22 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33melse\e[0m result.::(pluck(arr.drop(index)))\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m             Found:    List[Matchable]\n\e[31m   |\e[0m            \
    \ Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798887
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result: List[Long] = if (index > -1) evens.take(index) else evens\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7ghaixds.scala:37)\n\tat Problem.main(tmp7ghaixds.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sorted\n\
    \        val even = evens.head\n        val index = arr.indexOf(even)\n      \
    \  val result = arr.filter(_ == even)\n        if (result.isEmpty) List(even,\
    \ index)\n        else result.sortBy(_).take(1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpp89xjhug.scala:35:27 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_).take(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m\
    \   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$3 of expanded function:\n\e[31m   |\e[0m   _$3 =>\
    \ result.sortBy(_$3).take(1).\n\e[31m\e[31m-- Error: /tmp/tmpp89xjhug.scala:35:29\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m35 |\e[0m       \
    \ \e[33melse\e[0m result.sortBy(_).take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                            ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798883
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(-_)\n\
    \        val smallest = evens.head\n        val index = evens.indexOfFirst { _\
    \ == smallest }\n        val result = List(smallest, index)\n        if (evens.isEmpty)\
    \ result\n        else result.filter(_ % 2 == 0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjj5befg9.scala:32:26 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = evens.indexOfFirst\
    \ { _ == smallest }\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value indexOfFirst is not a member of\
    \ List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1659798887
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        arr.foreach { x =>\n            if (x % 2 == 0) {\n                result.add(x)\n\
    \            }\n        }\n        if (result.isEmpty) {\n            result.addAll(Array[Long]())\n\
    \        }\n        return result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn3tryxtk.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798882
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = arr.indexOf(even)\n       \
    \ val result = arr.filter(_ == even).sortWith(_ < _).take(1).map(_ + 1)\n    \
    \    if (result.isEmpty) result else result :+ index\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpteb00n4j.scala:37)\n\tat Problem.main(tmpteb00n4j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith(_ < _)\n        val smallestEven\
    \ = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val smallestEvenIndex = smallestEvenIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValue = evensSorted.take(smallestEvenIndex).sum\n   \
    \     val smallestEvenValueIndex = evensSorted.indexOf(smallestEvenValue)\n  \
    \      val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\
    \        val smallestEvenValueIndex = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphz9p1vfu.scala:55:36 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m\
    \   |\e[0m                                    expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphz9p1vfu.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndex\e[0m = smallestEvenIndex.min(evensSorted.indexOf(_))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphz9p1vfu.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphz9p1vfu.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = smallestEvenValueIndex.min(evensSorted.indexOf(_))\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E16"
  stdout: ''
  timestamp: 1659798897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven / 2\n        val smallestEvenIndex = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = smallestEven\
    \ / 2\n        val smallestEvenIndex = evensSorted.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValue = smallestEven / 2\n        val smallestEvenIndex\
    \ = evensSorted.indexOf(smallestEvenValue)\n        val smallestEvenValue = smallestEven\
    \ / 2\n        \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwx9c9uua.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evensSorted.indexOf(smallestEvenValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwx9c9uua.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEven / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwx9c9uua.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evensSorted.indexOf(smallestEvenValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwx9c9uua.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEven / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwx9c9uua.scala:39:12 ---------------------------"
  stdout: ''
  timestamp: 1659798897
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = if (index == -1) Nil else List(smallest, index)\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcbl05fz8.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798898
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_).reverse\n\
    \        val even = evens.head\n        val index = arr.indexOf(even)\n      \
    \  val result: List[Long] = List(even, index)\n        if (evens.isEmpty) result\n\
    \        else result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp3gcjdcpe.scala:30:50 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                               ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmp3gcjdcpe.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798896
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_)\n\
    \        val smalest_value = evens.head\n        val smalest_index = evens.indexOf(0)\n\
    \        val smalest_even = evens.takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_ < smalest_value).takeWhile(_\
    \ < smalest_value).takeWhile(_ < smalest_value\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpju3b37ia.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpju3b37ia.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mNo implicit Ordering defined for Any..\n\e[31m   |\e[0mI found:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e\
    [35mAny\e[0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[Any]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[Any].\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpju3b37ia.scala:34:5 ---------------------\e[0m\e[0m\n\
    \e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798901
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x - y)\n        val evensSortedIndex\
    \ = evensSorted.zipWithIndex.toList\n        val smallestEven = evensSortedIndex.minBy(x\
    \ => x._2)\n        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = evensSortedIndex.filter(x => x._1 == smallestEvenValue).minBy(x => x._2)\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenIndex._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenIndex._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenIndex._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenIndex._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenIndex._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenIndex._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenIndex._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenIndex._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenIndex._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenIndex._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenIndex._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenIndex._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenIndex._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenIndex._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenIndex._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smalle\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvsku2dme.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvsku2dme.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndex\e[0m = smallestEvenIndex._2\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmallestEvenIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpvsku2dme.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m = smallestEvenIndex._1\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e[35msmallestEvenValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvsku2dme.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = smallestEvenIndex._2\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvsku2dme.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m = smallestEvenIndex._1\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e[35msmallestEvenValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same gro"
  stdout: ''
  timestamp: 1659798901
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = List(smallest, index)\n        if (arr.isEmpty) result\n\
    \        else result.filter(_ < arr.min).sortBy(_._1).head\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzy7xj87m.scala:34:25\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpzy7xj87m.scala:35:29 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.filter(_ < arr.min).sortBy(_._1).head\n\
    \e[31m\e[31m   |\e[0m                           ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ < is not a member of AnyVal, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzy7xj87m.scala:35:49 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.filter(_ < arr.min).sortBy(_._1).head\n\
    \e[31m\e[31m   |\e[0m                                               ^^^^\e[0m\n\
    \e[31m   |\e[0m                                      value _1 is not a member\
    \ of AnyVal\n\e[31m\e[31m-- Error: /tmp/tmpzy7xj87m.scala:35:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.filter(_ < arr.min).sortBy(_._1).head\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n4 errors found\n"
  stdout: ''
  timestamp: 1659798901
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_).reverse\n\
    \        val even = evens.head\n        val index = arr.indexOf(even)\n      \
    \  val result: List[Long] = List(even, index)\n        if (arr.isEmpty) result\n\
    \        else result.sortBy(_._1).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpqh91zwoy.scala:30:50 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                               ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmpqh91zwoy.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqh91zwoy.scala:35:29 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                           ^^^^\e[0m\n\e[31m   |\e[0m   \
    \                        value _1 is not a member of Long\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpqh91zwoy.scala:35:32 -----------------------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_._1).reverse\n\e[31m\e\
    [31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1659798900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith(_ < _)\n        val evensSortedSet\
    \ = evensSorted.toSet\n        val smalestEven = evensSortedSet.head\n       \
    \ val smalestEvenIndex = evensSorted.indexOf(smalestEven)\n        val smalestEvenValue\
    \ = evensSortedSet.last\n        val smalestEvenIndexList = evensSorted.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSet = evensSortedSet.take(smalestEvenIndex).toSet\n\
    \        val smalestEvenIndexSetList = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSet = evensSortedSet.take(smalestEvenIndex).toSet\n\
    \        val smalestEvenIndexSetSetList = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSetSetList = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSetSetList: List[Long] = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSetSetSetList: List[Long] = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSetSetSetList: List[Long] = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSetSetSetList: List[Long] = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSetSetSetList: List[Long] = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSetSetSetSetList: List[Long] = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSetSetSetSetList: List[Long] = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSetSetSetSetList: List[Long] = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSetSetSetSetSetList: List[Long] = evensSortedSet.take(smalestEvenIndex).toList\n\
    \        val smalestEvenIndexSetSetSetSetSetSetList: List[Long] = evensSorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb__n0i9f.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenIndexSetSetSetList\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = evensSortedSet.take(smalestEvenIndex).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenIndexSetSetSetList is already defined as \e[33mvalue\e\
    [0m \e[35msmalestEvenIndexSetSetSetList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb__n0i9f.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenIndexSetSetSetSetList\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = evensSortedSet.take(smalestEvenIndex).toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenIndexSetSetSetSetList is already defined as \e\
    [33mvalue\e[0m \e[35msmalestEvenIndexSetSetSetSetList\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb__n0i9f.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalestEvenIndexSetSetSetSetList\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m]\
    \ = evensSortedSet.take(smalestEvenIndex).toList\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenIndexSetSetSetSetList is already defined as \e\
    [33mvalue\e[0m \e[35msmalestEvenIndexSetSetSetSetList\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb__n0i9f.scala:46:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalestEvenIndexSetSetSetSetList\e[0m: \e[35mList\e[0m[\e[35mLo"
  stdout: ''
  timestamp: 1659798899
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_)\n\
    \        val even = evens.head\n        val index = evens.indexOfFirst { x =>\
    \ x == even }\n        if (index == -1) List(even)\n        else List(even, index)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpue1oh8oy.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = arr.indexOf(even)\n       \
    \ val result = arr.filter(_ != even).sortWith(_ < _).takeWhile(_ < even).take(index).toList\n\
    \        result.sortWith(_ < _).takeWhile(_ < even).take(index).toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnbxkw40l.scala:37)\n\tat Problem.main(tmpnbxkw40l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798901
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(_ % 2 == 0).sortBy(_)\n\
    \        val evenIndex = arr.zipWithIndex.filter(_._2 % 2 == 0).sortBy(_._1).map(x\
    \ => x._2)\n        val evenValue = even.head\n        val index = evenIndex.head\n\
    \        val result = if (even.size == 0 || evenIndex.size == 0 || evenIndex.contains(index))\
    \ {\n            List[Long]()\n        } else {\n            List[Long](evenValue,\
    \ index)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmph2pxhg7z.scala:30:51 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36meven\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                        ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even).sortBy(x => x).takeWhile(x => x <\
    \ even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x\
    \ => x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x =>\
    \ x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x\
    \ < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x <\
    \ even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x\
    \ => x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x =>\
    \ x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x\
    \ < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x <\
    \ even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x\
    \ => x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x =>\
    \ x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x\
    \ < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x <\
    \ even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x\
    \ => x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x =>\
    \ x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x\
    \ < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x <\
    \ even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x => x < even).takeWhile(x\
    \ => x < even).takeWhile(x => x < even).takeWhile(x \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa2_p7cyx.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa2_p7cyx.scala:33:1518\
    \ ----------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = arr.filter(_ != even).sortBy(\e[36mx\e[0m => x).takeWhile(\e[36mx\e[0m =>\
    \ x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x <\
    \ even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e\
    [36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e\
    [0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m =>\
    \ x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x <\
    \ even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e\
    [36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e\
    [0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m =>\
    \ x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x <\
    \ even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e\
    [36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e\
    [0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m =>\
    \ x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x <\
    \ even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e\
    [36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e\
    [0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m =>\
    \ x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x <\
    \ even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e\
    [36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e\
    [0m => x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m =>\
    \ x < even).takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e[0m => x <\
    \ even).takeWhile(\e[36mx\e[0m => x < "
  stdout: ''
  timestamp: 1659798901
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n     \
    \   val evensSortedSortedWithIndex = evensSorted.zipWithIndex\n        val smallestEven\
    \ = evensSortedSortedWithIndex.minBy(x => x._2)\n        val smallestEvenIndex\
    \ = evensSortedSortedWithIndex.filter(x => x._2 == smallestEven).minBy(x => x._1)\n\
    \        val smallestEvenValue = smallestEvenIndex._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValueIndex = evensSortedSortedWithIndex.filter(x\
    \ => x._2 == smallestEvenValue).minBy(x => x._1)\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex._2\n        val smallestEvenValueIndex = smallestEvenValueIndex._1\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex._2\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex._1\n        val smallestEvenValueIndex = smallestEvenValueIndex._2\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex._1\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex._2\n        val smallestEvenValueIndex = smallestEvenValueIndex._1\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex._2\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex._1\n        val smallestEvenValueIndex = smallestEvenValueIndex._2\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex._1\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex._2\n        val smallestEvenValueIndex = smallestEvenValueIndex._1\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex._2\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex._1\n        val smallestEvenValueIndex = smallestEvenValueIndex._2\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex._1\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex._2\n        val smallestEvenValueIndex = smallestEvenValueIndex._1\n\
    \        val smallestEvenValueIndex = smallestEvenValueIndex._2\n        val smallestEvenValueIndex\
    \ = smallestEvenValueIndex._1\n        val smallestEvenValueIndex = smallestEvenValueIndex._2\n\
    \        val smallestEvenValueIndex = smallest\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8pfc0sz1.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8pfc0sz1.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = smallestEvenValueIndex._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8pfc0sz1.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = smallestEvenValueIndex._1\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8pfc0sz1.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = smallestEvenValueIndex._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8pfc0sz1.scala:41:12 -----------"
  stdout: ''
  timestamp: 1659798902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(_ % 2 == 0)\n\
    \        val evenSorted = even.sortWith((x, y) => x.compare(y))\n        val evenSmallest\
    \ = evenSorted.head\n        val evenSmallestIndex = evenSorted.indexOf(0)\n \
    \       val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestValueList = evenSmallestValue.toList\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexList.length\n    \
    \    val evenSmallestValueListLength = evenSmallestValueList.length\n        val\
    \ smallestEvenSmallestValue = evenSmallestValueList(0)\n        val smallestEvenSmallestIndex\
    \ = evenSmallestIndexList(0)\n        val smallestEvenSmallestIndexList = smallestEvenSmallestIndex.toList\n\
    \        val smallestEvenSmallestValueList = smallestEvenSmallestValue.toList\n\
    \        val smallestEvenSmallestIndexListLength = smallestEvenSmallestIndexList.length\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueList.length\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEvenSmallestValueListLength\n\
    \        val smallestEvenSmallestValueListLength = smallestEven\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpff2ac37j.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenSmallestValueListLength\e\
    [0m = smallestEvenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenSmallestValueListLength is already defined as\
    \ \e[33mvalue\e[0m \e[35msmallestEvenSmallestValueListLength\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpff2ac37j.scala:46:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenSmallestValueListLength\e[0m = smallestEvenSmallestValueListLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenSmallestValueListLength is already defined as\
    \ \e[33mvalue\e[0m \e[35msmallestEvenSmallestValueListLength\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpff2ac37j.scala:47:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenSmallestValueListLength\e[0m = smallestEvenSmallestValueListLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenSmallestValueListLength is already defined as\
    \ \e[33mvalue\e[0m \e[35msmallestEvenSmallestValueListLength\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpff2ac37j.scala:48:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenSmallestValueListLength\e[0m = smallestEvenSmallestValueListLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m"
  stdout: ''
  timestamp: 1659798902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).takeWhile(x => x < arr.last).reverse\n        val index =\
    \ arr.lastIndexWhere(x => x % 2 == 0)\n        val smallest = even.takeWhile(x\
    \ => x < arr.last).reverse.head\n        val result = List(smallest, index)\n\
    \        if (even.isEmpty) result\n        else result.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqvz5t55v.scala:34:26\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (even.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                          Found:    (result : List[AnyVal])\n\e[31m \
    \  |\e[0m                          Required: List[Long]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpqvz5t55v.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).sortWith(_ < _).take(index).map(x\
    \ => x)\n        if (result.isEmpty) result else result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb6excrs8.scala:37)\n\tat Problem.main(tmpb6excrs8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = evens.indexOf(even)\n     \
    \   val result = List(even, index)\n        if (arr.isEmpty) result\n        else\
    \ result.sortBy(-_)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnib6_da6.scala:34:25\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpnib6_da6.scala:35:27 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(-_)\n\e[31m\e[31m\
    \   |\e[0m                           ^^\e[0m\n\e[31m   |\e[0mvalue unary_- is\
    \ not a member of AnyVal, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmpnib6_da6.scala:35:30 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(-_)\n\e[31m\e[31m\
    \   |\e[0m                              ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659798902
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = evens.takeWhile(x => x != even).takeWhile(x => x != index).sorted\n\
    \        val index = result.indexOf(0)\n        val result = result.takeWhile(x\
    \ => x != index).sorted\n        result.takeWhile(x => x != even).takeWhile(x\
    \ => x != index).sorted\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb0m8f6t8.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = result.indexOf(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mindex is already defined as \e[33mvalue\e[0m \e[35mindex\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpb0m8f6t8.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.takeWhile(\e[36mx\e\
    [0m => x != index).sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n2 errors found\n"
  stdout: ''
  timestamp: 1659798898
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOfFirst\
    \ { x => x == even }\n        val result = arr.filter(_ != even).sortWith(_ <\
    \ _).take(index).sorted\n        arr.filter(_ != even).sortWith(_ < _).take(index).sorted\
    \ ++ result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvp5rq_sh.scala:32:26 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = evens.indexOfFirst\
    \ { \e[36mx\e[0m => x == even }\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value indexOfFirst is not a member of\
    \ List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1659798900
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evensSortedIndex\
    \ = evensSorted.indexWhere(_ % 2 == 0)\n        val smallestEven = evensSortedSortedIndex.min\n\
    \        val smallestEvenIndex = evensSorted.indexOf(smallestEven)\n        val\
    \ smallestEvenValue = evensSortedSortedIndex.min\n        val smallestEvenIndexList\
    \ = evensSorted.take(smallestEvenIndex + 1)\n        val smallestEvenIndexListSorted\
    \ = smallestEvenIndexList.sortWith(_ < _)\n        val smallestEvenIndexListSortedIndex\
    \ = smallestEvenIndexListSorted.indexWhere(_ % 2 == 0)\n        val smallestEvenIndexListSortedValue\
    \ = smallestEvenIndexListSorted.min\n        val smallestEvenIndexListSortedIndexList\
    \ = smallestEvenIndexListSorted.take(smallestEvenIndexListSortedIndex + 1)\n \
    \       val smallestEvenIndexListSortedIndexListSorted = smallestEvenIndexListSortedIndexList.sortWith(_\
    \ < _)\n        val smallestEvenIndexListSortedIndexListSortedIndex = smallestEvenIndexListSortedIndexListSorted.indexWhere(_\
    \ % 2 == 0)\n        val smallestEvenIndexListSortedIndexListSortedValue = smallestEvenIndexListSortedIndexListSorted.min\n\
    \        val smallestEvenIndexListSortedIndexListSortedIndexList = smallestEvenIndexListSortedIndexListSorted.take(smallestEvenIndexListSortedIndexListSortedIndex\
    \ + 1)\n        val smallestEvenIndexListSortedIndexListSortedIndexListSorted\
    \ = smallestEvenIndexListSortedIndexListSortedIndexList.sortWith(_ < _)\n    \
    \    val smallestEvenIndexListSortedIndexListSortedIndexListSortedIndex = smallestEvenIndexListSortedIndexListSortedIndexListSorted.indexWhere(_\
    \ % 2 == 0)\n        val smallestEvenIndexListSortedIndexListSortedIndexListSortedValue\
    \ = smallestEvenIndexListSortedIndexListSortedIndexListSorted.min\n        val\
    \ smallestEvenIndexListSortedIndexListSortedIndexListSortedIndexList = smallestEvenIndexListSortedIndexListSortedIndexListSortedIndexListSorted.take(smallestEvenIndexListSortedIndexListSortedIndexListSortedIndexListSortedIndex\
    \ + 1)\n        val smallestEvenIndexListSortedIndexListSortedIndexListSortedIndexListSortedIndex\
    \ = smallestEvenIndexListSortedIndexListSortedIndexListSortedIndexListSortedIndexListSorted.indexWhere(_\
    \ % 2 == 0)\n        val smallestEven\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp160aw53c.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp160aw53c.scala:33:27\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36msmallestEven\e[0m = evensSortedSortedIndex.min\n\e[31m\e[31m   |\e[0m    \
    \                       ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                  Not found: evensSortedSortedIndex\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp160aw53c.scala:35:32 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ evensSortedSortedIndex.min\n\e[31m\e[31m   |\e[0m                          \
    \      ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \      Not found: evensSortedSortedIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp160aw53c.scala:48:81 ------------------------\e[0m\e\
    [0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexListSortedIndexListSortedIndexListSortedIndexList\e\
    [0m = smallestEvenIndexListSortedIndexListSortedIndexListSortedIndexListSorted.take(smallestEvenIndexListSortedIndexListSortedIndexListSortedIndexListSortedIndex\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: smallestEvenIndexListSortedIndexListSortedIndexListSortedIndexListSorted\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp160aw53c.scala:49:92\
    \ ------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e\
    [36msmallestEvenIndexListSortedIndexListSortedIndexListSortedIndexListSortedIndex\e\
    [0m = smallestEvenIndexListSortedIndexListSorted"
  stdout: ''
  timestamp: 1659798902
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even).sortBy(x => x).takeWhile(x => x <\
    \ even).take(index).toList\n        if (result.isEmpty) result else result.sortWith(_\
    \ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpaec68hlf.scala:37)\n\tat Problem.main(tmpaec68hlf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798904
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sorted\n        val evensSortedIndex = evensSorted.indexWhere(_\
    \ % 2 == 0)\n        val evensSortedEven = evensSorted.take(evensSortedIndex)\n\
    \        val evensSortedEvenIndex = evensSortedEven.indexWhere(_ % 2 == 0)\n \
    \       val smalestEven = evensSortedEven.take(evensSortedEvenIndex)\n       \
    \ val smalestEvenIndex = smalestEven.indexWhere(_ % 2 == 0)\n        val smalestEvenValue\
    \ = smalestEven.take(smalestEvenIndex).head\n        val smalestEvenValueIndex\
    \ = smalestEven.indexOf(smalestEvenValue)\n        val smalestEvenValueIndex =\
    \ smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evensSortedIndex)\n        val smalestEvenValueIndex\
    \ = smalestEvenValueIndex.min(evens\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpleqprvdu.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpleqprvdu.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalestEvenValueIndex\e[0m = smalestEvenValueIndex.min(evensSortedIndex)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmalestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpleqprvdu.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenValueIndex\e\
    [0m = smalestEvenValueIndex.min(evensSortedIndex)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmalestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpleqprvdu.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenValueIndex\e\
    [0m = smalestEvenValueIndex.min(evensSortedIndex)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmalestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpleqprvdu.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenValueIndex\e\
    [0m = smalestEvenValueIndex.min(evensSortedIndex)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659798909
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = evens.indexOf(even)\n     \
    \   val result = if (index > 0) evens.take(index) else evens\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplbgat9nx.scala:37)\n\tat Problem.main(tmplbgat9nx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val evenIndex = arr.indexOf(even, index + 1)\n        val evenValue =\
    \ evens.last\n        val evenIndexList = List(even, evenIndex, evenValue)\n \
    \       if (evenIndexList.size == 1) {\n            evenIndexList\n        } else\
    \ {\n            val evenIndexList = evenIndexList.sortBy(x => x)\n          \
    \  evenIndexList.take(1)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9anuxnj9.scala:37:12\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            evenIndexList\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \ Found:    (evenIndexList : List[AnyVal])\n\e[31m   |\e[0m            Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9anuxnj9.scala:39:32\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e\
    [0m \e[36mevenIndexList\e[0m = evenIndexList.sortBy(\e[36mx\e[0m => x)\n\e[31m\e\
    [31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m         \
    \                       Recursive \e[33mvalue\e[0m \e[35mevenIndexList\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798910
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = evens.indexOf(even)\n     \
    \   val result = arr.filter(_ == even).sortWith(_ < _).take(index).map(_ + 1)\n\
    \        if (result.isEmpty) result else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7sfj0cz_.scala:37)\n\tat Problem.main(tmp7sfj0cz_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).takeWhile(_ < arr.last).map(x => x).reverse\n        val index\
    \ = arr.zipWithIndex.filter(x => x % 2 == 0).sortBy(x => x._1).takeWhile(_ < arr.last).map(x\
    \ => x._2).reverse\n        even.head -> index.head\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt2x85u7p.scala:31:51 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = arr.zipWithIndex.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(\e[36mx\e[0m => x._1).takeWhile(_\
    \ < arr.last).map(\e[36mx\e[0m => x._2).reverse\n\e[31m\e[31m   |\e[0m       \
    \                                          ^^^\e[0m\n\e[31m   |\e[0mvalue % is\
    \ not a member of (Long @uncheckedVariance, Int), but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe following import\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpt2x85u7p.scala:31:91 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = arr.zipWithIndex.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(\e[36mx\e[0m => x._1).takeWhile(_\
    \ < arr.last).map(\e[36mx\e[0m => x._2).reverse\n\e[31m\e[31m   |\e[0m       \
    \                                                                            \
    \      ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of (Long, Int), but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt2x85u7p.scala:32:8\
    \ ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m        even.head -> index.head\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    (Long, Int)\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798914
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val smalest_value = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n\
    \        val result = evens.takeWhile(x => x != smalest_value).takeWhile(x =>\
    \ x != smalest_index).map(x => x).sorted\n        result.headOption.getOrElse(List[Long]())\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxcalpbgk.scala:34:35\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result.headOption.getOrElse(List[\e\
    [35mLong\e[0m]())\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Matchable\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val even = evens.min\n        val index = arr.indexOf(even)\n  \
    \      val result = arr.filter(_ != even)\n        if (result.isEmpty) List(even,\
    \ index)\n        else List(even, index).sortBy(_._1).head\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9v7qxw7a.scala:35:40 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m List(even, index).sortBy(_._1).head\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^\e[0m\n\e[31m \
    \  |\e[0m                                      value _1 is not a member of AnyVal\n\
    \e[31m\e[31m-- Error: /tmp/tmp9v7qxw7a.scala:35:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m List(even, index).sortBy(_._1).head\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n        val smallestEven\
    \ = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val smallestEvenValue = smallestEven\n        val smallestEvenIndexList\
    \ = List(smallestEvenIndex, smallestEvenIndex + 1)\n        val smallestEvenValueList\
    \ = List(smallestEvenValue, smallestEvenValue)\n        val smallestEvenIndexSet\
    \ = smallestEvenIndexList.map(x => Set(x))\n        val smallestEvenValueSet =\
    \ smallestEvenValueList.map(x => Set(x))\n        val smallestEvenIndexSetSet\
    \ = smallestEvenIndexSet.map(x => Set(x))\n        val smallestEvenValueSetSet\
    \ = smallestEvenValueSet.map(x => Set(x))\n        val smallestEvenIndexSetSetSet\
    \ = smallestEvenIndexSetSet.map(x => Set(x))\n        val smallestEvenValueSetSetSet\
    \ = smallestEvenValueSetSet.map(x => Set(x))\n        val smallestEvenIndexSetSetSet\
    \ = smallestEvenIndexSetSet.map(x => Set(x))\n        val smallestEvenValueSetSetSet\
    \ = smallestEvenValueSetSet.map(x => Set(x))\n        val smallestEvenIndexSetSetSet\
    \ = smallestEvenIndexSetSet.map(x => Set(x))\n        val smallestEvenValueSetSetSet\
    \ = smallestEvenValueSetSet.map(x => Set(x))\n        val smallestEvenIndexSetSetSet\
    \ = smallestEvenIndexSetSet.map(x => Set(x))\n        val smallestEvenValueSetSetSet\
    \ = smallestEvenValueSetSet.map(x => Set(x))\n        val smallestEvenIndexSetSetSet\
    \ = smallestEvenIndexSetSet.map(x => Set(x))\n        val smallestEvenValueSetSetSet\
    \ = smallestEvenValueSetSet.map(x => Set(x))\n        val smallestEvenIndexSetSetSet\
    \ = smallestEvenIndexSetSet.map(x => Set(x))\n        val smallestEvenValueSetSetSet\
    \ = smallestEvenValueSetSet.map(x => Set(x))\n        val smallestEvenIndexSetSetSet\
    \ = smallestEvenIndexSetSet.map(x => Set(x))\n        val smallestEvenValueSetSetSet\
    \ = smallestEvenValueSetSet.map(x => Set(x))\n        val smallestEvenIndexSetSetSet\
    \ = smallestEvenIndexSetSet.map(x => Set(x))\n        val smallestEven\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbuo16bj8.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbuo16bj8.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndexSetSetSet\e[0m = smallestEvenIndexSetSet.map(\e[36mx\e\
    [0m => Set(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndexSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenIndexSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbuo16bj8.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueSetSetSet\e\
    [0m = smallestEvenValueSetSet.map(\e[36mx\e[0m => Set(x))\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbuo16bj8.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndexSetSetSet\e\
    [0m = smallestEvenIndexSetSet.map(\e[36mx\e[0m => Set(x))\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndexSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenIndexSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbuo16bj8.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueSetSetSet\e\
    [0m = smallestEvenValueS"
  stdout: ''
  timestamp: 1659798912
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (evens.isEmpty) result\n\
    \        else result.take(index).zip(evens.take(index)).map(_._1)\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd56sz_q5.scala:38)\n\tat Problem.main(tmpd56sz_q5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val smalest_value = evens.head\n        val\
    \ smalest_index = evens.indexOf(0)\n        val evens_with_smallest_index = evens.takeWhile(x\
    \ => x < smalest_value)\n        val evens_with_smallest_value_index = evens_with_smallest_index.zipWithIndex.sortBy(_._1).reverse.head\n\
    \        val smalest_value_index = evens_with_smallest_value_index.head._2\n \
    \       val smalest_value_index_in_list = evens_with_smallest_value_index.head._1\n\
    \        val smalest_value_index_in_array = evens_with_smallest_value_index.head._2\n\
    \        val smalest_value_index_in_array_in_list = evens_with_smallest_value_index.head._3\n\
    \        val smalest_value_index_in_array_in_array = evens_with_smallest_value_index.head._4\n\
    \        val smalest_value_index_in_array_in_array_in_list = evens_with_smallest_value_index.head._5\n\
    \        val smalest_value_index_in_array_in_array_in_array = evens_with_smallest_value_index.head._6\n\
    \        val smalest_value_index_in_array_in_array_in_array_in_list = evens_with_smallest_value_index.head._7\n\
    \        val smalest_value_index_in_array_in_array_in_array_in_array = evens_with_smallest_value_index.head._8\n\
    \        val smalest_value_index_in_array_in_array_in_array_in_array_in_list =\
    \ evens_with_smallest_value_index.head._9\n        val smalest_value_index_in_array_in_array_in_array_in_array_in_array\
    \ = evens_with_smallest_value_index.head._10\n        val smalest_value_index_in_array_in_array_in_array_in_array_in_array_in_list\
    \ = evens_with_smallest_value_index.head._11\n        val smalest_value_index_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = evens_with_smallest_value_index.head._12\n        val smalest_value_index_in_array_in_array_in_array_in_array_in_array_in_array_in_list\
    \ = evens_with_smallest_value_index.head._13\n        val smalest_value_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_list\
    \ = evens_with_smallest_value_index.head._14\n        val smalest_value\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe6ldqno_.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe6ldqno_.scala:35:71\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36msmalest_value_index\e[0m = evens_with_smallest_value_index.head._2\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value _2 is not a member of Tuple.Head[(Long,\
    \ Int)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe6ldqno_.scala:36:79 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmalest_value_index_in_list\e\
    [0m = evens_with_smallest_value_index.head._1\n\e[31m\e[31m   |\e[0m         \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     value _1 is not a member of Tuple.Head[(Long,\
    \ Int)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe6ldqno_.scala:37:80 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalest_value_index_in_array\e\
    [0m = evens_with_smallest_value_index.head._2\n\e[31m\e[31m   |\e[0m         \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                     value _2 is not a member of Tuple.Head[(Long,\
    \ Int)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe6ldqno_.scala:38:88 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_value_index_in_array_in_list\e\
    [0m = evens_with_smallest_value_index.head._3\n\e[31m\e[31m   |\e[0m         \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value _3 is not a member of Tuple.Head[(Long,\
    \ Int)]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe6ldqno_.scala:39:89 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_value_index_in_array_in_array\e\
    [0m = evens_with_smallest_value_index.head._4\n\e[31m\e[31m   |\e[0m     "
  stdout: ''
  timestamp: 1659798916
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).takeWhile(x => x < arr.last).reverse\n        val index =\
    \ arr.lastIndexWhere(x => x % 2 == 0)\n        if (even.isEmpty) List(arr.last)\n\
    \        else even.take(index).toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwtrdkytt.scala:36)\n\tat Problem.main(tmpwtrdkytt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val even = evens.head\n        val index\
    \ = evens.indexOf(0)\n        val result = if (index > 0) evens.take(index) else\
    \ evens.take(evens.length)\n        arr.filterNot(x => x == even).sortBy(x =>\
    \ x).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5i806dcn.scala:37)\n\tat Problem.main(tmp5i806dcn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = arr.indexOf(even)\n       \
    \ val result = List(even, index)\n        if (evens.isEmpty) result\n        else\
    \ result.sortWith(_ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps8o0z4ay.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmps8o0z4ay.scala:35:31 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m                             ^^^\e[0m\n\e[31m   |\e[0mvalue < is\
    \ not a member of AnyVal, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798913
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val evensIndex = arr.zipWithIndex.filter(x => x % 2 == 0).sortBy(_._1).reverse.head._2\n\
    \        val evensIndex = evensIndex.filter(_ < arr.length)\n        val evensIndex\
    \ = evensIndex.filter(_ >= 0)\n        val evensIndex = evensIndex.filter(_ <\
    \ arr.length)\n        val evensIndex = evensIndex.filter(_ >= 0)\n        val\
    \ evensIndex = evensIndex.filter(_ < arr.length)\n        val evensIndex = evensIndex.filter(_\
    \ >= 0)\n        val evensIndex = evensIndex.filter(_ < arr.length)\n        val\
    \ evensIndex = evensIndex.filter(_ >= 0)\n        val evensIndex = evensIndex.filter(_\
    \ < arr.length)\n        val evensIndex = evensIndex.filter(_ >= 0)\n        val\
    \ evensIndex = evensIndex.filter(_ < arr.length)\n        val evensIndex = evensIndex.filter(_\
    \ >= 0)\n        val evensIndex = evensIndex.filter(_ < arr.length)\n        val\
    \ evensIndex = evensIndex.filter(_ >= 0)\n        val evensIndex = evensIndex.filter(_\
    \ < arr.length)\n        val evensIndex = evensIndex.filter(_ >= 0)\n        val\
    \ evensIndex = evensIndex.filter(_ < arr.length)\n        val evensIndex = evensIndex.filter(_\
    \ >= 0)\n        val evensIndex = evensIndex.filter(_ < arr.length)\n        val\
    \ evensIndex = evensIndex.filter(_ >= 0)\n        val evensIndex = evensIndex.filter(_\
    \ < arr.length)\n        val evensIndex = evensIndex.filter(_ >= 0)\n        val\
    \ evensIndex = evensIndex.filter(_ < arr.length)\n        val evensIndex = evensIndex.filter(_\
    \ >= 0)\n        val evensIndex = evensIndex.filter(_ < arr.length)\n        val\
    \ evensIndex = evensIndex.filter(_ >= 0)\n        val evensIndex = evensIndex.filter(_\
    \ < arr.length)\n        val evensIndex = evensIndex.filter(_ >= 0)\n        val\
    \ evensIndex = evensIndex.filter(_ < arr.length)\n        val evensIndex = evensIndex.filter(_\
    \ >= 0)\n        val evensIndex = evensIndex.filter(_ < arr.length)\n        val\
    \ evensIndex = evensIndex.filter(_ >= 0)\n        val evensIndex = even\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptfrbx4gs.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mevensIndex\e[0m = evensIndex.filter(_\
    \ < arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensIndex is already defined as \e[33mvalue\e[0m \e[35mevensIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptfrbx4gs.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mevensIndex\e[0m = evensIndex.filter(_\
    \ >= \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensIndex is already defined as \e[33mvalue\e[0m \e[35mevensIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptfrbx4gs.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mevensIndex\e[0m = evensIndex.filter(_\
    \ < arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensIndex is already defined as \e[33mvalue\e[0m \e[35mevensIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptfrbx4gs.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mevensIndex\e[0m = evensIndex.filter(_\
    \ >= \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensIndex is already defined as \e[33mvalue\e[0m \e[35mevensIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptfrbx4gs.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mevensIndex\e[0m = evensIndex.filter(_\
    \ < arr.lengt"
  stdout: ''
  timestamp: 1659798914
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n        val evenSmallest\
    \ = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.map(x => arr(x))\n        val evenSmallestValueList = evenSmallestIndexList.map(x\
    \ => arr(x))\n        val evenSmallestValueListSorted = evenSmallestValueList.sortWith((x,\
    \ y) => x < y)\n        val evenSmallestValueListSortedHead = evenSmallestValueListSorted.head\n\
    \        val evenSmallestValueListSortedHeadIndex = evenSmallestValueListSorted.indexOf(0)\n\
    \        val evenSmallestValueListSortedHeadValue = evenSmallestValueListSortedHead\n\
    \        val evenSmallestValueListSortedHeadIndexList = evenSmallestValueListSortedHeadIndex.map(x\
    \ => arr(x))\n        val evenSmallestValueListSortedHeadValueList = evenSmallestValueListSortedHeadIndexList.map(x\
    \ => arr(x))\n        val evenSmallestValueListSortedHeadValueListSorted = evenSmallestValueListSortedHeadValueList.sortWith((x,\
    \ y) => x < y)\n        val evenSmallestValueListSortedHeadValueListSortedHead\
    \ = evenSmallestValueListSortedHeadValueListSorted.head\n        val evenSmallestValueListSortedHeadValueListSortedHeadIndex\
    \ = evenSmallestValueListSortedHeadValueListSorted.indexOf(0)\n        val evenSmallestValueListSortedHeadValueListSortedHeadValue\
    \ = evenSmallestValueListSortedHeadValueListSortedHead\n        val evenSmallestValueListSortedHeadValueListSortedHeadIndexList\
    \ = evenSmallestValueListSortedHeadValueListSortedHeadIndex.map(x => arr(x))\n\
    \        val evenSmallestValueListSortedHeadValueListSortedHeadValueList = evenSmallestValueListSortedHeadValueListSortedHeadIndexList.map(x\
    \ => arr(x))\n        val evenSmallestValueListSortedHeadValueListSortedHeadValueListSorted\
    \ = evenSmallestValueListSortedHeadValueListSortedHeadValueList.sortWith((x, y)\
    \ => x < y)\n        val evenSmallestValueListSortedHeadValueListSortedHeadValueListSortedHead\
    \ = evenSmallestValueListSortedHeadValueListSortedHead\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt_0ct29m.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.map(\e[36mx\e[0m => arr(x))\n\e[31m\e[31m   |\e[0m   \
    \                                 ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                    value map is not a member of Int\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpt_0ct29m.scala:51:5 ---------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798914
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val evenIndex = even.indexOf(0)\n       \
    \ if(evenIndex == -1) {\n            return Nil\n        }\n        val min =\
    \ even.take(evenIndex).min\n        val index = even.indexOf(min)\n        val\
    \ result = even.take(index).sortBy(x => x).reverse\n        arr.take(index) ++\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq3fwl05j.scala:41)\n\tat Problem.main(tmpq3fwl05j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_)\n\
    \        val even = evens.head\n        val index = evens.indexOf(0)\n       \
    \ val result = List(even, index)\n        if (evens.isEmpty) result\n        else\
    \ result.sortBy(_._1).reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6s_gd2ha.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\e[31m   |\e[0m\
    \      /* missing */summon[java.util.Comparator[Any]]\n\e[31m   |\e[0m    )\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type\
    \ java.util.Comparator[Any].\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6s_gd2ha.scala:35:29\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                           ^^^^\e[0m\n\e[31m   |\e[0m   \
    \                        value _1 is not a member of Nothing\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp6s_gd2ha.scala:35:32 -----------------------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_._1).reverse\n\e[31m\e\
    [31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659798916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = evens.takeWhile(x => x < even).takeWhile(x => x != even).sorted\n\
    \        val index = result.indexOf(0)\n        val value = result.takeWhile(x\
    \ => x < even).takeWhile(x => x != even).sorted\n        val index = result.indexOf(0)\n\
    \        val value = result.takeWhile(x => x < even).takeWhile(x => x != even).sorted\n\
    \        val index = result.indexOf(0)\n        val value = result.takeWhile(x\
    \ => x < even).takeWhile(x => x != even).sorted\n        val index = result.indexOf(0)\n\
    \        val value = result.takeWhile(x => x < even).takeWhile(x => x != even).sorted\n\
    \        val index = result.indexOf(0)\n        val value = result.takeWhile(x\
    \ => x < even).takeWhile(x => x != even).sorted\n        val index = result.indexOf(0)\n\
    \        val value = result.takeWhile(x => x < even).takeWhile(x => x != even).sorted\n\
    \        val index = result.indexOf(0)\n        val value = result.takeWhile(x\
    \ => x < even).takeWhile(x => x != even).sorted\n        val index = result.indexOf(0)\n\
    \        val value = result.takeWhile(x => x < even).takeWhile(x => x != even).sorted\n\
    \        val index = result.indexOf(0)\n        val value = result.takeWhile(x\
    \ => x < even).takeWhile(x => x != even).sorted\n        val index = result.indexOf(0)\n\
    \        val value = result.takeWhile(x => x < even).takeWhile(x => x != even).sorted\n\
    \        val index = result.indexOf(0)\n        val value = result.takeWhile(x\
    \ => x < even).takeWhile(x => x != even).sorted\n        val index = result.indexOf(0)\n\
    \        val value = result.takeWhile(x => x < even).takeWhile(x => x != even).sorted\n\
    \        val index = result.indexOf(0)\n        val value = result.takeWhile(x\
    \ => x < even).takeWhile(x => x != even).sorted\n        val index = result.indexOf(0)\n\
    \        val value = result.takeWhile(x => x < even).takeWhile(x => x != even).sorted\n\
    \        val index = result.indexOf(0)\n        val value = result.takeWhile(x\
    \ => x < even).takeWhile(x => x != even).sorted\n        val index = result.indexOf(0)\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpysqwy8b_.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = result.indexOf(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mindex is already defined as \e[33mvalue\e[0m \e[35mindex\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpysqwy8b_.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = result.indexOf(\e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mindex is already defined as \e[33mvalue\e[0m \e[35mindex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpysqwy8b_.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mvalue\e[0m = result.takeWhile(\e[36mx\e[0m => x < even).takeWhile(\e[36mx\e\
    [0m => x != even).sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue is already defined as \e[33mvalue\e[0m \e[35mvalue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpysqwy8b_.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = result.indexOf(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mindex is already defined as \e[33mvalue\e[0m \e[35mindex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpysqwy8b_.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mvalue\e[0m = result.takeWhile(\e[36mx\e[0m\
    \ => x < even).takeWhile(\e[36mx\e[0m => x != even).sorted\n\e[31m\e[3"
  stdout: ''
  timestamp: 1659798914
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val smalest_value = evens.head\n        val smalest_index\
    \ = evens.indexOf(0)\n        val smalest_even = evens.takeWhile(x => x % 2 ==\
    \ 0).min\n        val smalest_even_index = evens.indexOf(smalest_even)\n     \
    \   val smalest_even_index = smalest_even_index + 1\n        val smalest_even_index_2\
    \ = smalest_even_index + 2\n        val smalest_even_index_3 = smalest_even_index\
    \ + 3\n        val smalest_even_index_4 = smalest_even_index + 4\n        val\
    \ smalest_even_index_5 = smalest_even_index + 5\n        val smalest_even_index_6\
    \ = smalest_even_index + 6\n        val smalest_even_index_7 = smalest_even_index\
    \ + 7\n        val smalest_even_index_8 = smalest_even_index + 8\n        val\
    \ smalest_even_index_9 = smalest_even_index + 9\n        val smalest_even_index_10\
    \ = smalest_even_index + 10\n        val smalest_even_index_11 = smalest_even_index\
    \ + 11\n        val smalest_even_index_12 = smalest_even_index + 12\n        val\
    \ smalest_even_index_13 = smalest_even_index + 13\n        val smalest_even_index_14\
    \ = smalest_even_index + 14\n        val smalest_even_index_15 = smalest_even_index\
    \ + 15\n        val smalest_even_index_16 = smalest_even_index + 16\n        val\
    \ smalest_even_index_17 = smalest_even_index + 17\n        val smalest_even_index_18\
    \ = smalest_even_index + 18\n        val smalest_even_index_19 = smalest_even_index\
    \ + 19\n        val smalest_even_index_20 = smalest_even_index + 20\n        val\
    \ smalest_even_index_21 = smalest_even_index + 21\n        val smalest_even_index_22\
    \ = smalest_even_index + 22\n        val smalest_even_index_23 = smalest_even_index\
    \ + 23\n        val smalest_even_index_24 = smalest_even_index + 24\n        val\
    \ smalest_even_index_25 = smalest_even_index + 25\n        val smalest_even_index_26\
    \ = smalest_even_index + 26\n        val smalest_even_index_27 = \n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpm1236c10.scala:61:35 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index_27\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                   expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm1236c10.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = smalest_even_index + \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpm1236c10.scala:62:5 ---------------------\e[0m\e[0m\n\
    \e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798914
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val evenIndex = arr.zipWithIndex.filter(x => x % 2 == 0).sortBy(_._1).reverse.head._2\n\
    \        val evenValue = even.head\n        val index = evenIndex\n        val\
    \ result = if (even.size == 0) List(0) else List(evenValue, index)\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv4bblkwz.scala:31:55 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevenIndex\e[0m = arr.zipWithIndex.filter(\e\
    [36mx\e[0m => x % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_._1).reverse.head._2\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^\e\
    [0m\n\e[31m   |\e[0mvalue % is not a member of (Long @uncheckedVariance, Int),\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mThe following import might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv4bblkwz.scala:35:15\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798915
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(_ % 2 == 0).sortBy(_).reverse\n\
    \        val index = even.indexOf(0)\n        val result = if (index >= 0) even.take(index)\
    \ else even\n        result.sortBy(_).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpbz6l671t.scala:30:49 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36meven\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                              ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmpbz6l671t.scala:30:51\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36meven\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mBigDecimal\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpbz6l671t.scala:33:22 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        result.sortBy(_).reverse\n\e[31m\e[31m   |\e\
    [0m                      ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$3\
    \ of expanded function:\n\e[31m   |\e[0m   _$3 => result.sortBy(_$3).reverse.\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798913
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n        val evensSortedSortedWithIndex\
    \ = evensSorted.zipWithIndex.sortWith((x, y) => x._2 < y._2)\n        val smalest_value\
    \ = evensSortedSortedWithIndex.head._1\n        val smalest_index = evensSortedSortedWithIndex.head._2\n\
    \        val index = evensSortedSortedWithIndex.last._2\n        if (evensSorted.isEmpty)\
    \ List(smalest_value, smalest_index)\n        else evensSortedSortedWithIndex.takeWhile((x,\
    \ y) => x._2 == index).head\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_9vbf6nm.scala:37:62 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33melse\e[0m evensSortedSortedWithIndex.takeWhile((x,\
    \ y) => x._2 == index).head\n\e[31m\e[31m   |\e[0m                           \
    \                                 ^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                       value _2 is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659798915
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ == even).sortWith(_ < _).take(index).map(_\
    \ + 1)\n        if (result.isEmpty) result else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcyyxoiqy.scala:37)\n\tat Problem.main(tmpcyyxoiqy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798920
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evensSortedWithIndex\
    \ = evensSorted.zipWithIndex\n        val smallestEven = evensSortedWithIndex.minBy(_._1)._2\n\
    \        val index = evensSortedWithIndex.indexOf(smallestEven)\n        val result\
    \ = evensSortedWithIndex.filter(_._1 == smallestEven).map(_._2)\n        if(result.isEmpty)\
    \ result else List(smallestEven, index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe8ku357k.scala:36:27\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mif\e[0m(result.isEmpty)\
    \ result \e[33melse\e[0m List(smallestEven, index)\n\e[31m\e[31m   |\e[0m    \
    \                       ^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \  Found:    (result : List[Int])\n\e[31m   |\e[0m                           Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evensSortedWithIndex\
    \ = evensSorted.zipWithIndex\n        val smallestEven = evensSortedWithIndex.minBy(_._1)\n\
    \        val smallestEvenIndex = evensSortedWithIndex.indexWhere(_._1 == smallestEven)\n\
    \        val smallestEvenValue = smallestEven._2\n        val smallestEvenIndex\
    \ = smallestEvenIndex.minBy(_._1)\n        val smallestEvenValue = smallestEvenIndex._2\n\
    \        val smallestEvenIndex = smallestEvenIndex.minBy(_._1)\n        val smallestEvenValue\
    \ = smallestEvenIndex._2\n        val smallestEvenIndex = smallestEvenIndex.minBy(_._1)\n\
    \        val smallestEvenValue = smallestEvenIndex._2\n        val smallestEvenIndex\
    \ = smallestEvenIndex.minBy(_._1)\n        val smallestEvenValue = smallestEvenIndex._2\n\
    \        val smallestEvenIndex = smallestEvenIndex.minBy(_._1)\n        val smallestEvenValue\
    \ = smallestEvenIndex._2\n        val smallestEvenIndex = smallestEvenIndex.minBy(_._1)\n\
    \        val smallestEvenValue = smallestEvenIndex._2\n        val smallestEvenIndex\
    \ = smallestEvenIndex.minBy(_._1)\n        val smallestEvenValue = smallestEvenIndex._2\n\
    \        val smallestEvenIndex = smallestEvenIndex.minBy(_._1)\n        val smallestEvenValue\
    \ = smallestEvenIndex._2\n        val smallestEvenIndex = smallestEvenIndex.minBy(_._1)\n\
    \        val smallestEvenValue = smallestEvenIndex._2\n        val smallestEvenIndex\
    \ = smallestEvenIndex.minBy(_._1)\n        val smallestEvenValue = smallestEvenIndex._2\n\
    \        val smallestEvenIndex = smallestEvenIndex.minBy(_._1)\n        val smallestEvenValue\
    \ = smallestEvenIndex._2\n        val smallestEvenIndex = smallestEvenIndex.minBy(_._1)\n\
    \        val smallestEvenValue = smallestEvenIndex._2\n        val smallestEvenIndex\
    \ = smallestEvenIndex.minBy(_._1)\n        val smallestEvenValue = smallestEvenIndex._2\n\
    \        val smallestEvenIndex = smallestEvenIndex.minBy(_._1)\n        val smallestEvenValue\
    \ = smallestEvenIndex._2\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfftynx95.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex.minBy(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfftynx95.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenIndex._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfftynx95.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex.minBy(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfftynx95.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenIndex._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfftynx95.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval"
  stdout: ''
  timestamp: 1659798925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(_ % 2 == 0).sortBy(_).reverse\n\
    \        val evenIndex = even.indexOf(0)\n        val smalest_value = even.take(evenIndex).min\n\
    \        val smalest_index = evenIndex\n        val result = even.filter(_ ==\
    \ smalest_value).sortBy(_).reverse\n        if (result.isEmpty) Nil\n        else\
    \ result.take(1).map(_ -> smalest_index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmprflmham6.scala:30:49 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36meven\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                              ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmprflmham6.scala:30:51\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36meven\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                   ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmprflmham6.scala:34:60 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = even.filter(_\
    \ == smalest_value).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m                 \
    \                                           ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$4 of expanded function:\n\e[31m   |\e[0m   _$4 => even.filter(_$3\
    \ => _$3 == smalest_value).sortBy(_$4).reverse.\n3 errors found\n"
  stdout: ''
  timestamp: 1659798921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val even = evens.head\n        val index\
    \ = evens.indexOf(0)\n        val result = List(even, index)\n        if (evens.isEmpty)\
    \ result\n        else result.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaijh2lfi.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaijh2lfi.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798923
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evenSmallest = evensSorted.head\n\
    \        val evenSmallestIndex = evensSorted.indexOfFirst { x => x == evenSmallest\
    \ }\n        val evenSmallestValue = evensSorted.take(evenSmallestIndex).sum\n\
    \        val evenSmallestIndexList = evensSorted.take(evenSmallestIndex).zipWithIndex.toList\n\
    \        val smalestValue = evenSmallestValue\n        val smalestIndexList =\
    \ evenSmallestIndexList\n        if (evensSorted.isEmpty) {\n            evenSmallestIndexList.map\
    \ { x => x._1 }\n        } else {\n            evenSmallestIndexList.map { x =>\
    \ x._1 }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk3kngmum.scala:33:44 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndex\e[0m =\
    \ evensSorted.indexOfFirst { \e[36mx\e[0m => x == evenSmallest }\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        value indexOfFirst is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val even = evens.head\n        val index\
    \ = arr.indexOf(even)\n        val result = List(even, index)\n        if (evens.isEmpty)\
    \ result\n        else result.sortBy(x => x._1).reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwp7ditym.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpwp7ditym.scala:35:34 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(x => x._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                value _1 is not a member of AnyVal\n\e[31m\e\
    [31m-- Error: /tmp/tmpwp7ditym.scala:35:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(x => x._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659798926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evenSmallest = evensSorted.head\n\
    \        val evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue\
    \ = evenSmallest\n        val evenSmallestIndexList = evenSmallestIndex.map(i\
    \ => arr(i))\n        val evenSmallestValueList = evenSmallestIndexList.map(i\
    \ => arr(i))\n        val evenSmallestValueListSorted = evenSmallestValueList.sortWith(_\
    \ < _)\n        val evenSmallestValueListSorted = evenSmallestValueListSorted.head\n\
    \        val evenSmallestValueListSortedIndex = evenSmallestValueListSorted.indexOf(0)\n\
    \        val evenSmallestValueListSortedValue = evenSmallestValueListSorted.head\n\
    \        val evenSmallestValueListSortedIndexList = evenSmallestValueListSortedIndex.map(i\
    \ => arr(i))\n        val evenSmallestValueListSortedValueList = evenSmallestValueListSortedIndexList.map(i\
    \ => arr(i))\n        val evenSmallestValueListSortedValueListSorted = evenSmallestValueListSortedValueList.sortWith(_\
    \ < _)\n        val evenSmallestValueListSortedValueListSorted = evenSmallestValueListSortedValueListSorted.head\n\
    \        val evenSmallestValueListSortedValueListSortedIndex = evenSmallestValueListSortedValueListSorted.indexOf(0)\n\
    \        val evenSmallestValueListSortedValueListSortedValue = evenSmallestValueListSortedValueListSorted.head\n\
    \        val evenSmallestValueListSortedValueListSortedIndexList = evenSmallestValueListSortedValueListSortedIndex.map(i\
    \ => arr(i))\n        val evenSmallestValueListSortedValueListSortedValueList\
    \ = evenSmallestValueListSortedValueListSortedIndexList.map(i => arr(i))\n   \
    \     val evenSmallestValueListSortedValueListSortedValueListSorted = evenSmallestValueListSortedValueListSortedValueList.sortWith(_\
    \ < _)\n        val evenSmallestValueListSortedValueListSortedValueListSorted\
    \ = evenSmallestValueListSortedValueListSortedValueListSorted.head\n        val\
    \ evenSmallestValueListSortedValueListSortedValueListSortedIndex = evenSmallestValueListSortedValueListSortedValue\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn9wph8n3.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSorted\e\
    [0m = evenSmallestValueListSorted.head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListSorted is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListSorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn9wph8n3.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSortedValueListSorted\e\
    [0m = evenSmallestValueListSortedValueListSorted.head\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListSortedValueListSorted is already defined\
    \ as \e[33mvalue\e[0m \e[35mevenSmallestValueListSortedValueListSorted\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpn9wph8n3.scala:50:12 ---------------------------\e[0m\e[0m\n\e[31m50\
    \ |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSortedValueListSortedValueListSorted\e\
    [0m = evenSmallestValueListSortedValueListSortedValueListSorted.head\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListSortedValueListSortedValueListSorted\
    \ is already defined as \e[33mvalue\e[0m \e[35mevenSmallestValueListSortedValueListSortedValueListSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpn9wph8n3.scala:35:54 ------------------------\e[0m\e[0m\n\
    \e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e[0m = evenSma"
  stdout: ''
  timestamp: 1659798925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val smalest_value = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n\
    \        val result = evens.filter(_ == smalest_value).sortWith(_ < _).takeWhile(_\
    \ < smalest_index).drop(1)\n        val index = evens.indexOf(smalest_value)\n\
    \        if (result.isEmpty) Nil\n        else result :: Nil\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5239x6oh.scala:36:13\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33melse\e[0m result\
    \ :: Nil\n\e[31m\e[31m   |\e[0m             ^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \        Found:    (result : List[Long])\n\e[31m   |\e[0m             Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n     \
    \   val smallestEven = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val result = evensSorted.filter(x => x != smallestEven)\n        if (result.isEmpty)\
    \ List() else List(smallestEven, smallestEvenIndex)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyegkn_gj.scala:31:60\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                   Found:    Int\n\
    \e[31m   |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798926
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val even = evens.head\n        val index\
    \ = evens.indexOf(even)\n        val result = arr.filter(x => x % 2 == 0).sortBy(x\
    \ => x).reverse.takeWhile(x => x % 2 == 0).takeWhile(x => x != even).takeWhile(x\
    \ => x != index).reverse\n        if (result.isEmpty) Nil\n        else result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoj975_jq.scala:38)\n\tat Problem.main(tmpoj975_jq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = if (evens.isEmpty) Nil else List(even, index)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps8x3hxc8.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val even = evens.head\n        val index\
    \ = evens.indexOf(0)\n        val result = arr.filter(x => x % 2 == 0).sortBy(x\
    \ => x).reverse.filter(x => x == even).head\n        val resultList = List(result,\
    \ index)\n        if (arr.isEmpty) resultList\n        else resultList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvn39jjzd.scala:35:25\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ resultList\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                         Found:    (resultList : List[AnyVal])\n\e\
    [31m   |\e[0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvn39jjzd.scala:36:13 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33melse\e[0m resultList\n\e[31m\e[31m   |\e\
    [0m             ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:    (resultList\
    \ : List[AnyVal])\n\e[31m   |\e[0m             Required: List[Long]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798926
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evensSortedWithIndex\
    \ = evensSorted.zipWithIndex\n        val smallestEven = evensSortedWithIndex.minBy(_._1)\n\
    \        val smallestEvenIndex = evensSortedWithIndex.indexOf(smallestEven)\n\
    \        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = smallestEven._2\n        val smallestEvenIndex = smallestEvenIndex + 1\n \
    \       val smallestEvenValue = smallestEvenIndex\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenIndex\n\
    \        val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n   \
    \     val \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9d_mj29p.scala:74:11 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp9d_mj29p.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEven._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9d_mj29p.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9d_mj29p.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9d_mj29p.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35m"
  stdout: ''
  timestamp: 1659798928
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = evens.indexOf(even)\n     \
    \   val result = arr.filter(_ == even).sortWith(_ < _).take(index).sortWith(_\
    \ < _).take(1)\n        if (result.isEmpty) result else result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcucxw3r7.scala:37)\n\tat Problem.main(tmpcucxw3r7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x - y)\n        val evensSortedIndex\
    \ = evensSorted.zipWithIndex.toList\n        val smalestEven = evensSortedIndex.find(x\
    \ => x._2 < evensSortedIndex.size)\n        val smalestEvenValue = smalestEven._1\n\
    \        val smalestEvenIndex = smalestEven._2\n        val smalestEvenIndex =\
    \ arr.indexOf(smalestEvenValue)\n        val smalestEvenValue = arr.take(smalestEvenIndex).sortWith((x,\
    \ y) => x - y)\n        val smalestEvenValue = smalestEvenValue(0)\n        val\
    \ smalestEvenIndex = arr.indexOf(smalestEvenValue)\n        val smalestEvenIndex\
    \ = arr.indexOf(smalestEvenValue)\n        val smalestEvenValue = arr.take(smalestEvenIndex).sortWith((x,\
    \ y) => x - y)\n        val smalestEvenValue = smalestEvenValue(0)\n        val\
    \ smalestEvenIndex = arr.indexOf(smalestEvenValue)\n        val smalestEvenIndex\
    \ = arr.indexOf(smalestEvenValue)\n        val smalestEvenValue = arr.take(smalestEvenIndex).sortWith((x,\
    \ y) => x - y)\n        val smalestEvenValue = smalestEvenValue(0)\n        val\
    \ smalestEvenIndex = arr.indexOf(smalestEvenValue)\n        val smalestEvenIndex\
    \ = arr.indexOf(smalestEvenValue)\n        val smalestEvenValue = arr.take(smalestEvenIndex).sortWith((x,\
    \ y) => x - y)\n        val smalestEvenValue = smalestEvenValue(0)\n        val\
    \ smalestEvenIndex = arr.indexOf(smalestEvenValue)\n        val smalestEvenIndex\
    \ = arr.indexOf(smalestEvenValue)\n        val smalestEvenValue = arr.take(smalestEvenIndex).sortWith((x,\
    \ y) => x - y)\n        val smalestEvenValue = smalestEvenValue(0)\n        val\
    \ smalestEvenIndex = arr.indexOf(smalestEvenValue)\n        val smalestEvenIndex\
    \ = arr.indexOf(smalestEvenValue)\n        val smalestEvenValue = arr.take(smalestEvenIndex).sortWith((x,\
    \ y) => x - y)\n        val smalestEvenValue = smalestEvenValue(0)\n        val\
    \ smalestEvenIndex = arr.indexOf(smalestEvenValue)\n        val smalestEven\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdx_n4ucs.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdx_n4ucs.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalestEvenIndex\e[0m = arr.indexOf(smalestEvenValue)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msmalestEvenIndex is already defined as \e[33mvalue\e[0m \e[35msmalestEvenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdx_n4ucs.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenValue\e[0m = arr.take(smalestEvenIndex).sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmalestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpdx_n4ucs.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenValue\e[0m =\
    \ smalestEvenValue(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmalestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpdx_n4ucs.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenIndex\e[0m =\
    \ arr.indexOf(smalestEvenValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msma"
  stdout: ''
  timestamp: 1659798928
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result: List[Long] = List(even, index)\n        if (evens.isEmpty)\
    \ result\n        else result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf4h32boo.scala:38)\n\tat Problem.main(tmpf4h32boo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n        val smallestEven\
    \ = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val smallestEvenValue = smallestEven % 2\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val result = List(smallestEvenValue, smallestEvenIndex)\n\
    \        if (evensSorted.isEmpty) result\n        else result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpupg9_r1n.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpupg9_r1n.scala:37:33 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mif\e[0m (evensSorted.isEmpty) result\n\e\
    [31m\e[31m   |\e[0m                                 ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                 Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                                 Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpupg9_r1n.scala:38:13 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m\
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m             Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m             Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = mutable.ArrayBuffer.empty[Long]\n\
    \        var index = 0\n        var smallest = 0\n        var smallestIndex =\
    \ 0\n        var evenSmallest = 0\n        var evenSmallestIndex = 0\n       \
    \ for(i <- 0 until arr.length) {\n            if(arr(i) % 2 == 0) {\n        \
    \        evenSmallest = arr(i)\n                evenSmallestIndex = i\n      \
    \      }\n            else {\n                smallest = arr(i)\n            \
    \    smallestIndex = i\n            }\n        }\n        for(i <- 0 until arr.length)\
    \ {\n            if(arr(i) % 2 == 0) {\n                if(arr(i) < evenSmallest)\
    \ {\n                    evenSmallest = arr(i)\n                    evenSmallestIndex\
    \ = i\n                }\n            }\n            else {\n                if(arr(i)\
    \ < smallest) {\n                    smallest = arr(i)\n                    smallestIndex\
    \ = i\n                }\n            }\n        }\n        if(evenSmallest ==\
    \ 0) {\n            return result\n        }\n        else {\n            result.add(evenSmallest)\n\
    \            result.add(evenSmallestIndex)\n        }\n        if(smallest ==\
    \ 0) {\n            return result\n        }\n        else {\n            result.add(smallest)\n\
    \            result.add(smallestIndex)\n        }\n        return result\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgfqbtszq.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpgfqbtszq.scala:38:34 --------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                evenSmallest = arr(i)\n\e[31m\e[31m \
    \  |\e[0m                               ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgfqbtszq.scala:42:30\
    \ --------------------\e[0m\e[0m\n\e[31m42 |\e[0m                smallest = arr(i)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                          Found:    Long\n\e[31m   |\e[0m                   \
    \        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgfqbtszq.scala:49:38\
    \ --------------------\e[0m\e[0m\n\e[31m49 |\e[0m                    evenSmallest\
    \ = arr(i)\n\e[31m\e[31m   |\e[0m                                   ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                   Found:    Long\n\e[31m   |\e\
    [0m                                   Required: Int\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgfqbtszq.scala:55:34 --------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m                    smallest = arr(i)\n\e[31m\e[31m \
    \  |\e[0m                               ^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n5 er"
  stdout: ''
  timestamp: 1659798929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = List(even, index)\n        if (evens.isEmpty) result\n \
    \       else result.sortBy(x => x).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplnvc78jn.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmplnvc78jn.scala:35:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(x => x).reverse\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0mNo\
    \ implicit Ordering defined for AnyVal..\n\e[31m   |\e[0mI found:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m    scala.math.Ordering.ordered[\e[35mAnyVal\e[0m](\n\e[31m\
    \   |\e[0m      /* missing */summon[scala.math.Ordering.AsComparable[AnyVal]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type scala.math.Ordering.AsComparable[AnyVal].\n2 errors found\n"
  stdout: ''
  timestamp: 1659798929
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sorted\n        val evensSortedIndex = evensSorted.indexOf(0)\n\
    \        val smallestEven = evensSortedIndex\n        val smallestEvenIndex =\
    \ evensSorted.indexOf(smallestEven)\n        val smallestEvenValue = evensSorted\n\
    \        val smallestEvenValueIndex = evensSortedIndex\n        val smallestEvenValueValue\
    \ = evensSorted\n        val smallestEvenValueValueIndex = evensSortedIndex\n\
    \        val smallestEvenValueValueValue = evensSorted\n        val smallestEvenValueValueValueIndex\
    \ = evensSortedIndex\n        val smallestEvenValueValueValueValue = evensSortedIndex\n\
    \        val smallestEvenValueValueValueIndex = evensSortedIndex\n        val\
    \ smallestEvenValueValueValueValue = evensSortedIndex\n        val smallestEvenValueValueValueIndex\
    \ = evensSortedIndex\n        val smallestEvenValueValueValueValue = evensSortedIndex\n\
    \        val smallestEvenValueValueValueIndex = evensSortedIndex\n        val\
    \ smallestEvenValueValueValueValue = evensSortedIndex\n        val smallestEvenValueValueValueIndex\
    \ = evensSortedIndex\n        val smallestEvenValueValueValueValue = evensSortedIndex\n\
    \        val smallestEvenValueValueValueIndex = evensSortedIndex\n        val\
    \ smallestEvenValueValueValueValue = evensSortedIndex\n        val smallestEvenValueValueValueIndex\
    \ = evensSortedIndex\n        val smallestEvenValueValueValueValue = evensSortedIndex\n\
    \        val smallestEvenValueValueValueIndex = evensSortedIndex\n        val\
    \ smallestEvenValueValueValueValue = evensSortedIndex\n        val smallestEvenValueValueValueIndex\
    \ = evensSortedIndex\n        val smallestEvenValueValueValueValue = evensSortedIndex\n\
    \        val smallestEvenValueValueValueIndex = evensSortedIndex\n        val\
    \ smallestEvenValueValueValueValue = evensSortedIndex\n        val smallestEvenValueValueValueIndex\
    \ = evensSortedIndex\n        val smallestEvenValueValueValueValue = evensSortedIndex\n\
    \        val smallestEvenValueValueValueIndex = evensSortedIndex\n        val\
    \ smallestEvenValueValueValueValue = evensSortedIndex\n        val smallestEvenValueValueValueIndex\
    \ = evensSortedIndex\n        val smallestEvenValueValueValueValue = evensSortedIndex\n\
    \        val smallestEvenValueValueValueIndex = evensSortedIndex\n        val\
    \ smallestEvenValueValueValueValue = evensSortedIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfv55gwpb.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueValueValueIndex\e\
    [0m = evensSortedIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueValueValueIndex is already defined as \e\
    [33mvalue\e[0m \e[35msmallestEvenValueValueValueIndex\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfv55gwpb.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenValueValueValueValue\e[0m = evensSortedIndex\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValueValueValueValue is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueValueValueValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfv55gwpb.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenValueValueValueIndex\e[0m = evensSortedIndex\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValueValueValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueValueValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfv55gwpb.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenValueValueValueValue\e[0m = evensSortedIndex\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValueValueValueValue is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueValueValueValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be define"
  stdout: ''
  timestamp: 1659798928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        arr.foreach(x => if (x % 2 == 0) result += x)\n        if (result.isEmpty)\
    \ result\n        else result.sortWith(_ < _).take(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptbpe925u.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798925
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = arr.filter(_ != even).take(index).sorted\n        result.headOption.toList\
    \ match {\n            case Nil => Nil\n            case x => List(x, index)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0sprukh_.scala:36:27\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mcase\e[0m x\
    \ => List(x, index)\n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e\
    [31m   |\e[0m                           Found:    (x : List[Long])\n\e[31m   |\e\
    [0m                           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).takeWhile(x => x < arr.last)\n        if (evens.isEmpty) List()\n\
    \        else {\n            val smallest = evens.head\n            val index\
    \ = evens.indexOfFirst { x => x == smallest }\n            List(smallest, index)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp01cqxc3e.scala:34:30 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mindex\e[0m = evens.indexOfFirst\
    \ { \e[36mx\e[0m => x == smallest }\n\e[31m\e[31m   |\e[0m                   \
    \     ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        value indexOfFirst\
    \ is not a member of List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1659798930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortWith(_ < _)\n        if (even.isEmpty) List()\n        else {\n     \
    \       val min = even(0)\n            val index = even.indexOf(min)\n       \
    \     val result = even.takeWhile(x => x != min).drop(index).map(x => x -> index).toList\n\
    \            if (result.isEmpty) List()\n            else result\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeg9c4i4r.scala:37:17\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33melse\e[0m result\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mresult\e[0m\e[1m\e[31m \e[0m\e[1m\e\
    [31m:\e[0m\e[1m\e[31m \e[0mList[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e\
    [31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e\
    [0m                 Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798933
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val even = evens.head\n        val index = evens.indexOf(even)\n\
    \        val result = List(even, index)\n        if (evens.isEmpty) result\n \
    \       else result.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy2z8tn4e.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy2z8tn4e.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = evens.indexOf(even)\n     \
    \   val result = arr.filter(_ == even)\n        if (result.isEmpty) List(even,\
    \ index)\n        else result.sortBy(_).head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpzqxx4pk4.scala:35:27 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_).head\n\e[31m\e\
    [31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m   Missing parameter\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$3 of expanded function:\n\e[31m   |\e[0m   _$3 => result.sortBy(_$3).head.\n\
    \e[31m\e[31m-- Error: /tmp/tmpzqxx4pk4.scala:35:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_).head\n\e[31m\e\
    [31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798932
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val smallest = evens.head\n        val index\
    \ = evens.indexOf(0)\n        val result: List[Long] = if (evens.isEmpty) Nil\
    \ else List(smallest, index)\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuvw2xaci.scala:37)\n\tat Problem.main(tmpuvw2xaci.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sorted\n        val evensSortedIndex = evensSorted.indexWhere(x\
    \ => x == evensSorted.head)\n        val smallestEven = evensSortedIndex\n   \
    \     val smallestEvenValue = evensSorted\n        val smallestEvenIndex = evensSortedIndex\n\
    \        val smallestEvenValue = evensSorted\n        val smallestEvenIndex =\
    \ evensSortedIndex\n        val smallestEvenValue = evensSorted\n        val smallestEvenIndex\
    \ = evensSortedIndex\n        val smallestEvenValue = evensSorted\n        val\
    \ smallestEvenIndex = evensSortedIndex\n        val smallestEvenValue = evensSorted\n\
    \        val smallestEvenIndex = evensSortedIndex\n        val smallestEvenValue\
    \ = evensSorted\n        val smallestEvenIndex = evensSortedIndex\n        val\
    \ smallestEvenValue = evensSorted\n        val smallestEvenIndex = evensSortedIndex\n\
    \        val smallestEvenValue = evensSorted\n        val smallestEvenIndex =\
    \ evensSortedIndex\n        val smallestEvenValue = evensSorted\n        val smallestEvenIndex\
    \ = evensSortedIndex\n        val smallestEvenValue = evensSorted\n        val\
    \ smallestEvenIndex = evensSortedIndex\n        val smallestEvenValue = evensSorted\n\
    \        val smallestEvenIndex = evensSortedIndex\n        val smallestEvenValue\
    \ = evensSorted\n        val smallestEvenIndex = evensSortedIndex\n        val\
    \ smallestEvenValue = evensSorted\n        val smallestEvenIndex = evensSortedIndex\n\
    \        val smallestEvenValue = evensSorted\n        val smallestEvenIndex =\
    \ evensSortedIndex\n        val smallestEvenValue = evensSorted\n        val smallestEvenIndex\
    \ = evensSortedIndex\n        val smallestEvenValue = evensSorted\n        val\
    \ smallestEvenIndex = evensSortedIndex\n        val smallestEvenValue = evensSorted\n\
    \        val smallestEvenIndex = evensSortedIndex\n        val smallestEvenValue\
    \ = evensSorted\n        val smallestEvenIndex = evensSortedIndex\n        val\
    \ smallestEvenValue = evensSorted\n        val smallestEvenIndex = evensSortedIndex\n\
    \        val smallestEvenValue = evensSorted\n        val smallestEvenIndex =\
    \ evensSortedIndex\n        val smallestEvenValue = evensSorted\n        val smallestEvenIndex\
    \ = evensSortedIndex\n        val smallestEvenValue = evensSorted\n        val\
    \ smallestEven\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6f5jlruz.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6f5jlruz.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenValue\e[0m = evensSorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6f5jlruz.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evensSortedIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6f5jlruz.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ evensSorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6f5jlruz.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evensSortedIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Namin"
  stdout: ''
  timestamp: 1659798936
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evenSmallest = evensSorted.head\n\
    \        val evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue\
    \ = evenSmallest / 2\n        val evenSmallestIndexInList = evenSmallestIndex\n\
    \        val evenSmallestValueInList = evenSmallestValue\n        val evenSmallestIndexInList\
    \ = evenSmallestIndex\n        val evenSmallestValueInList = evenSmallestValue\n\
    \        val evenSmallestIndexInList = evenSmallestIndex\n        val evenSmallestValueInList\
    \ = evenSmallestValue\n        val evenSmallestIndexInList = evenSmallestIndex\n\
    \        val evenSmallestValueInList = evenSmallestValue\n        val evenSmallestIndexInList\
    \ = evenSmallestIndex\n        val evenSmallestValueInList = evenSmallestValue\n\
    \        val evenSmallestIndexInList = evenSmallestIndex\n        val evenSmallestValueInList\
    \ = evenSmallestValue\n        val evenSmallestIndexInList = evenSmallestIndex\n\
    \        val evenSmallestValueInList = evenSmallestValue\n        val evenSmallestIndexInList\
    \ = evenSmallestIndex\n        val evenSmallestValueInList = evenSmallestValue\n\
    \        val evenSmallestIndexInList = evenSmallestIndex\n        val evenSmallestValueInList\
    \ = evenSmallestValue\n        val evenSmallestIndexInList = evenSmallestIndex\n\
    \        val evenSmallestValueInList = evenSmallestValue\n        val evenSmallestIndexInList\
    \ = evenSmallestIndex\n        val evenSmallestValueInList = evenSmallestValue\n\
    \        val evenSmallestIndexInList = evenSmallestIndex\n        val evenSmallestValueInList\
    \ = evenSmallestValue\n        val evenSmallestIndexInList = evenSmallestIndex\n\
    \        val evenSmallestValueInList = evenSmallestValue\n        val evenSmallestIndexInList\
    \ = evenSmallestIndex\n        val evenSmallestValueInList = evenSmallestValue\n\
    \        val evenSmallestIndexInList = evenSmallestIndex\n        val evenSmallestValueInList\
    \ = evenSm\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaae4lu57.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexInList\e\
    [0m = evenSmallestIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexInList is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexInList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaae4lu57.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueInList\e\
    [0m = evenSmallestValue\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueInList is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueInList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaae4lu57.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexInList\e\
    [0m = evenSmallestIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexInList is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexInList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaae4lu57.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueInList\e\
    [0m = evenSmallestValue\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueInList is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueInList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaae4lu57.scala:41:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659798938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even).sortBy(x => x).takeWhile(x => x <\
    \ even).drop(1)\n        if (result.isEmpty) result :: Nil\n        else result\
    \ :: List(index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmtivxm5_.scala:34:28\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result :: Nil\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Found:    (result : List[Long])\n\e\
    [31m   |\e[0m                            Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpmtivxm5_.scala:35:13 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result :: List(index)\n\e[31m\e\
    [31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \     Found:    List[Matchable]\n\e[31m   |\e[0m             Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(x => x % 2 == 0).filter(x => x != even).map(x\
    \ => (x, index)).toList\n        if (result.isEmpty) result\n        else result.sortBy(_._1).head._1\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx7lriv__.scala:34:28\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Found:    \e[1m\e[31m(\e[0m\e[1m\e[31mresult\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0mList[\e[1m\e[31m(\e[0mLong\e\
    [1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\e[1m\e[31m)\e\
    [0m\n\e[31m   |\e[0m                            Required: List[Long]\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx7lriv__.scala:35:38 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(_._1).head._1\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m             Found:    Long\n\e[31m   |\e[0m             Required: \e[1m\e\
    [32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        arr.foreach(x => {\n            val even = x % 2 == 0\n            val\
    \ index = arr.indexOf(x)\n            if (even && index != -1) {\n           \
    \     result.append((x -> index))\n            }\n        })\n        if (result.isEmpty)\
    \ {\n            result.clear()\n        }\n        result.toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpju0tu7ev.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798934
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x - y)\n        val evensSortedIndex\
    \ = evensSorted.zipWithIndex.toList\n        val smallestEven = evensSortedIndex.minBy(x\
    \ => x._2)\n        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = evensSortedIndex.filter(x => x._1 == smallestEvenValue).minBy(x => x._2)\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenIndex._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenIndex._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenIndex._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenIndex._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenIndex._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenIndex._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenIndex._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenIndex._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenIndex._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenIndex._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenIndex._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenIndex._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smallestEvenValue\
    \ = smallestEvenIndex._1\n        val smallestEvenIndex = smallestEvenIndex._2\n\
    \        val smallestEvenValue = smallestEvenIndex._1\n        val smallestEvenIndex\
    \ = smallestEvenIndex._2\n        val smallestEvenValue = smallestEvenIndex._1\n\
    \        val smallestEvenIndex = smallestEvenIndex._2\n        val smalle\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvsku2dme.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvsku2dme.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndex\e[0m = smallestEvenIndex._2\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmallestEvenIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpvsku2dme.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m = smallestEvenIndex._1\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e[35msmallestEvenValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvsku2dme.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = smallestEvenIndex._2\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvsku2dme.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m = smallestEvenIndex._1\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e[35msmallestEvenValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same gro"
  stdout: ''
  timestamp: 1659798901
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val even = evens.head\n        val index\
    \ = arr.indexOf(even)\n        val result = (even, index)\n        if (arr.isEmpty)\
    \ result\n        else result::pluck(arr.drop(index))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcq89auxi.scala:34:25\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : (Long, Int))\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpcq89auxi.scala:35:13 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result::pluck(arr.drop(index))\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    (result : (Long, Int))\n\e[31m   |\e[0m             Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798940
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n        val evensSortedSortedWithIndex\
    \ = evensSorted.zipWithIndex.toList\n        val smalestValue = evensSortedSortedWithIndex.head._2\n\
    \        val smalestIndex = evensSortedSortedWithIndex.head._1\n        val evensSortedSortedWithIndex2\
    \ = evensSorted.zipWithIndex.filter(_._1 == smalestIndex).sortWith((x, y) => x\
    \ < y)\n        val evensSortedSortedWithIndex3 = evensSortedSortedWithIndex2.map(_._2)\n\
    \        val evensSortedSortedWithIndex4 = evensSortedSortedWithIndex3.filter(_\
    \ % 2 == 0)\n        val evensSortedSortedWithIndex5 = evensSortedSortedWithIndex4.sortWith((x,\
    \ y) => x < y)\n        val evensSortedSortedWithIndex6 = evensSortedSortedWithIndex5.map(_._2)\n\
    \        val evensSortedSortedWithIndex7 = evensSortedSortedWithIndex6.filter(_\
    \ % 2 == 0)\n        val evensSortedSortedWithIndex8 = evensSortedSortedWithIndex7.sortWith((x,\
    \ y) => x < y)\n        val evensSortedSortedWithIndex9 = evensSortedSortedWithIndex8.map(_._2)\n\
    \        val evensSortedSortedWithIndex10 = evensSortedSortedWithIndex9.filter(_\
    \ % 2 == 0)\n        val evensSortedSortedWithIndex11 = evensSortedSortedWithIndex10.sortWith((x,\
    \ y) => x < y)\n        val evensSortedSortedWithIndex12 = evensSortedSortedWithIndex11.map(_._2)\n\
    \        val evensSortedSortedWithIndex13 = evensSortedSortedWithIndex12.filter(_\
    \ % 2 == 0)\n        val evensSortedSortedWithIndex14 = evensSortedSortedWithIndex13.sortWith((x,\
    \ y) => x < y)\n        val evensSortedSortedWithIndex15 = evensSortedSortedWithIndex14.map(_._2)\n\
    \        val evensSortedSortedWithIndex16 = evensSortedSortedWithIndex15.filter(_\
    \ % 2 == 0)\n        val evensSortedSortedWithIndex17 = evensSortedSortedWithIndex16.sortWith((x,\
    \ y) => x < y)\n        val evensSortedSortedWithIndex18 = evensSortedSortedWithIndex17.map(_._2)\n\
    \        val evensSortedSortedWithIndex19 = evensSortedSortedWithIndex18.filter(_\
    \ % 2 == 0)\n        val evensSortedSortedWithIndex20 = evens\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsxt_9ama.scala:35:117 -----------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevensSortedSortedWithIndex2\e\
    [0m = evensSorted.zipWithIndex.filter(_._1 == smalestIndex).sortWith((\e[36mx\e\
    [0m, \e[36my\e[0m) => x < y)\n\e[31m\e[31m   |\e[0m                          \
    \                                                                            \
    \             ^^^\e[0m\n\e[31m   |\e[0mvalue < is not a member of (Long, Int),\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpsxt_9ama.scala:39:76 ------------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevensSortedSortedWithIndex6\e\
    [0m = evensSortedSortedWithIndex5.map(_._2)\n\e[31m\e[31m   |\e[0m           \
    \                                                               ^^^^\e[0m\n\e\
    [31m   |\e[0m                                         value _2 is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsxt_9ama.scala:40:79\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e\
    [36mevensSortedSortedWithIndex7\e[0m = evensSortedSortedWithIndex6.filter(_ %\
    \ \e[31m2\e[0m == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                       \
    \                                                      ^^^\e[0m\n\e[31m   |\e\
    [0mvalue % is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import math.BigDecimal.ja"
  stdout: ''
  timestamp: 1659798945
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = evens.takeWhile(x => x != even).takeWhile(x => x != index).sorted\n\
    \        val index = result.indexOf(0)\n        val result = result.takeWhile(x\
    \ => x != index).sorted\n        val index = result.indexOf(0)\n        val result\
    \ = result.takeWhile(x => x != index).sorted\n        val index = result.indexOf(0)\n\
    \        val result = result.takeWhile(x => x != index).sorted\n        val index\
    \ = result.indexOf(0)\n        val result = result.takeWhile(x => x != index).sorted\n\
    \        val index = result.indexOf(0)\n        val result = result.takeWhile(x\
    \ => x != index).sorted\n        val index = result.indexOf(0)\n        val result\
    \ = result.takeWhile(x => x != index).sorted\n        val index = result.indexOf(0)\n\
    \        val result = result.takeWhile(x => x != index).sorted\n        val index\
    \ = result.indexOf(0)\n        val result = result.takeWhile(x => x != index).sorted\n\
    \        val index = result.indexOf(0)\n        val result = result.takeWhile(x\
    \ => x != index).sorted\n        val index = result.indexOf(0)\n        val result\
    \ = result.takeWhile(x => x != index).sorted\n        val index = result.indexOf(0)\n\
    \        val result = result.takeWhile(x => x != index).sorted\n        val index\
    \ = result.indexOf(0)\n        val result = result.takeWhile(x => x != index).sorted\n\
    \        val index = result.indexOf(0)\n        val result = result.takeWhile(x\
    \ => x != index).sorted\n        val index = result.indexOf(0)\n        val result\
    \ = result.takeWhile(x => x != index).sorted\n        val index = result.indexOf(0)\n\
    \        val result = result.takeWhile(x => x != index).sorted\n        val index\
    \ = result.indexOf(0)\n        val result = result.takeWhile(x => x != index).sorted\n\
    \        val index = result.indexOf(0)\n        val result = result.takeWhile(x\
    \ => x != index).sorted\n        val index = result.indexOf(0)\n        val result\
    \ = result.takeWhile(x => x != index).sorted\n        val index = result.indexOf(0)\n\
    \        val result = result.takeWhile(x => x != index).sorted\n        val index\
    \ = result.indexOf(0)\n        val result = result.takeWhile(x => x != index).sorted\n\
    \        val index = result.indexOf(0)\n        val result = result.takeWhile(x\
    \ => x \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqpojt1uh.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqpojt1uh.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mindex\e[0m = result.indexOf(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mindex is already defined\
    \ as \e[33mvalue\e[0m \e[35mindex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqpojt1uh.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.takeWhile(\e\
    [36mx\e[0m => x != index).sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqpojt1uh.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = result.indexOf(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mindex is already defined as \e[33mvalue\e[0m \e[35mindex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqpojt1uh.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.takeWhile(\e[36mx\e\
    [0m => x != index).sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqpojt1uh.sc"
  stdout: ''
  timestamp: 1659798938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = mutable.ArrayBuffer.empty[Long]\n\
    \        arr.foreach { x =>\n            if (x % 2 == 0) {\n                result.add(x)\n\
    \            }\n        }\n        if (result.isEmpty) {\n            result.addAll(0)\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1r_vj3bq.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798935
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val even = evens.head\n        val index\
    \ = evens.indexOf(0)\n        val result = evens.takeWhile(x => x != even).takeWhile(x\
    \ => x != even).indexOf(0)\n        if (result == -1) List(even, index)\n    \
    \    else List(even, index)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpetflfyxc.scala:38)\n\tat Problem.main(tmpetflfyxc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).takeWhile(x => x < arr.last).reverse\n        val index =\
    \ even.indexOf(0)\n        if (index == -1) {\n            List[Long]()\n    \
    \    } else {\n            even.take(index).toList\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxl3kl246.scala:39)\n\tat Problem.main(tmpxl3kl246.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798942
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n        val evensSortedWithIndex\
    \ = evensSorted.zipWithIndex\n        val smalestValue = evensSortedWithIndex.minBy(_._1)._2\n\
    \        val smalestIndex = evensSortedWithIndex.minBy(_._1)._2\n        val smalestEven\
    \ = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n        val\
    \ smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSortedWithIndex.filter(x => x._1 == smalestValue).head._2\n\
    \        val smalestEvenIndex = evensSorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr8om5fdu.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenIndex\e[0m =\
    \ evensSortedWithIndex.filter(\e[36mx\e[0m => x._1 == smalestValue).head._2\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmalestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpr8om5fdu.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenIndex\e[0m =\
    \ evensSortedWithIndex.filter(\e[36mx\e[0m => x._1 == smalestValue).head._2\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmalestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpr8om5fdu.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenIndex\e[0m =\
    \ evensSortedWithIndex.filter(\e[36mx\e[0m => x._1 == smalestValue).head._2\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmalestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpr8om5fdu.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmalestEvenIndex\e[0m =\
    \ evensSortedWithIndex.filter(\e[36mx\e[0m => x._1 == smalestValue).head._2\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmales"
  stdout: ''
  timestamp: 1659798940
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(-_)\n\
    \        if(evens.isEmpty) Nil\n        else evens.takeWhile(_ < evens.min).map(x\
    \ => (x, evens.indexOf(x)))\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpce0x7jur.scala:32:53\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.takeWhile(_\
    \ < evens.min).map(x => (x, evens.indexOf(x)))\n\e[31m\e[31m   |\e[0m        \
    \                                             ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                                   Found:    \e[1m\e\
    [31m(\e[0mLong\e[1m\e[31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e\
    [0m\n\e[31m   |\e[0m                                                   Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798941
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(-_)\n\
    \        val smalest_value = evens.head\n        val smalest_index = evens.indexWhere(_\
    \ == smalest_value)\n        val result = evens.takeWhile(_ != smalest_value).takeWhile(_\
    \ != smalest_index).reverse\n        if (result.isEmpty) result else List(smalest_value,\
    \ smalest_index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg4eqrcm0.scala:37)\n\tat Problem.main(tmpg4eqrcm0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798943
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).takeWhile(x => x < arr.last).reverse\n        val index =\
    \ arr.indexWhere(x => x % 2 == 0)\n        val smalest_value = even.head\n   \
    \     val smalest_index = index\n        val result = even.takeWhile(x => x !=\
    \ smalest_value).reverse\n        if (result.isEmpty) List(smalest_value, smalest_index)\n\
    \        else List(smalest_value, smalest_index, result)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppim1wk90.scala:36:48\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33melse\e[0m List(smalest_value,\
    \ smalest_index, result)\n\e[31m\e[31m   |\e[0m                              \
    \                  ^^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \           Found:    (result : List[Long])\n\e[31m   |\e[0m                 \
    \                        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798940
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val smallest = evens.head\n        val index\
    \ = evens.indexWhere(x => x == smallest)\n        val result = List(smallest,\
    \ index)\n        if (evens.isEmpty) result\n        else result.sortBy(x => x._1).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8ugs8cz3.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp8ugs8cz3.scala:35:34 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(x => x._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                value _1 is not a member of AnyVal\n\e[31m\e\
    [31m-- Error: /tmp/tmp8ugs8cz3.scala:35:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(x => x._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mBigDecimal\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mInt\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord\
    \ of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798943
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = mutable.ArrayBuffer.empty[Long]\n\
    \        arr.sortWith(_.compareTo(_) < 0)\n        val even = arr.filter(x =>\
    \ x % 2 == 0)\n        val index = arr.indexWhere(x => x % 2 == 0)\n        val\
    \ smalest_value = even.min\n        val smalest_index = index\n        result.add(smalest_value)\n\
    \        result.add(smalest_index)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9x1gz9eh.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798939
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val smallest = evens.head\n        val index = evens.indexWhere(x\
    \ => x == smallest)\n        val result = List(smallest, index)\n        if (evens.isEmpty)\
    \ result\n        else result.sortBy(x => x)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnwqexp45.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpnwqexp45.scala:35:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(x => x)\n\e[31m\e\
    [31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0mNo implicit\
    \ Ordering defined for AnyVal..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e[35mAnyVal\e[0m](\n\
    \e[31m   |\e[0m      /* missing */summon[java.util.Comparator[AnyVal]]\n\e[31m\
    \   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found\
    \ that match type java.util.Comparator[AnyVal].\n2 errors found\n"
  stdout: ''
  timestamp: 1659798944
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evenSmallest = evensSorted.head\n\
    \        val evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue\
    \ = evenSmallest\n        val evenSmallestIndexList = evenSmallestIndex.map(i\
    \ => arr(i))\n        val evenSmallestValueList = evenSmallestIndexList.map(i\
    \ => arr(i))\n        val evenSmallestValueListSorted = evenSmallestValueList.sortWith(_\
    \ < _)\n        val evenSmallestValueListSortedHead = evenSmallestValueListSorted.head\n\
    \        val evenSmallestValueListSortedHeadIndex = evenSmallestValueListSorted.indexOf(0)\n\
    \        val evenSmallestValueListSortedHeadValue = evenSmallestValueListSortedHead\n\
    \        val evenSmallestValueListSortedTail = evenSmallestValueListSorted.tail\n\
    \        val evenSmallestValueListSortedTailIndex = evenSmallestValueListSortedTail.indexOf(0)\n\
    \        val evenSmallestValueListSortedTailValue = evenSmallestValueListSortedTail\n\
    \        val evenSmallestValueListSortedTailValueIndex = evenSmallestValueListSortedTailIndex.map(i\
    \ => arr(i))\n        val evenSmallestValueListSortedTailValueIndexSorted = evenSmallestValueListSortedTailValueIndex.sortWith(_\
    \ < _)\n        val evenSmallestValueListSortedTailValueIndexSortedHead = evenSmallestValueListSortedTailValueIndexSorted.head\n\
    \        val evenSmallestValueListSortedTailValueIndexSortedHeadIndex = evenSmallestValueListSortedTailValueIndexSorted.indexOf(0)\n\
    \        val evenSmallestValueListSortedTailValueIndexSortedHeadValue = evenSmallestValueListSortedTailValueIndexSortedHead\n\
    \        val evenSmallestValueListSortedTailValueIndexSortedTail = evenSmallestValueListSortedTailValueIndexSorted.tail\n\
    \        val evenSmallestValueListSortedTailValueIndexSortedTailIndex = evenSmallestValueListSortedTailValueIndexSortedTail.indexOf(0)\n\
    \        val evenSmallestValueListSortedTailValueIndexSortedTailValue = evenSmallestValueListSortedTailValueIndexSortedTail\n\
    \        val evenSmallestValueListSortedTailValueIndexSortedTailValueIndex = evenSmallest\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuabo6p_x.scala:35:54 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e\
    [0m = evenSmallestIndex.map(\e[36mi\e[0m => arr(i))\n\e[31m\e[31m   |\e[0m   \
    \                                 ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                    value map is not a member of Int\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpuabo6p_x.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659798943
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        if (evens.isEmpty) List(-1L)\n        else\
    \ evens.takeWhile(x => x < arr.min).reverse.map(x => arr.indexOf(x)).filter(x\
    \ => x >= 0)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5gsz814_.scala:32:86\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33melse\e[0m evens.takeWhile(x\
    \ => x < arr.min).reverse.map(x => arr.indexOf(x)).filter(x => x >= \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m \
    \  |\e[0m             Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659798945
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = evens.indexOf(even)\n     \
    \   val result = arr.filter(_ == even)\n        if (result.isEmpty) List(even,\
    \ index)\n        else List(even, index).sortBy(_._1).reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr4jwvcc8.scala:35:40 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m List(even, index).sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^\e[0m\n\e[31m \
    \  |\e[0m                                      value _1 is not a member of AnyVal\n\
    \e[31m\e[31m-- Error: /tmp/tmpr4jwvcc8.scala:35:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m List(even, index).sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val evenIndex = arr.indexWhere(x => x % 2 == 0)\n       \
    \ val smalest_value = even.head\n        val smalest_index = evenIndex\n     \
    \   val result = even.takeWhile(x => x != smalest_value).takeWhile(x => x != smalest_index).sorted\n\
    \        if (result.isEmpty) result else result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjj7xbwg5.scala:38)\n\tat Problem.main(tmpjj7xbwg5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = if (index == -1) List(smallest) else List(smallest, index)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb7sizww8.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val smalest_value = evens.head\n        val\
    \ smalest_index = evens.indexOf(0)\n        val result = evens.takeWhile(x =>\
    \ x != smalest_value).takeWhile(x => x != smalest_index).reverse\n        if (result.isEmpty)\
    \ Nil\n        else result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi1qky9_g.scala:38)\n\tat Problem.main(tmpi1qky9_g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x - y)\n        val evensSortedSortedWithIndex\
    \ = evensSorted.zipWithIndex\n        val smallestEven = evensSortedSortedWithIndex.minBy(_._1)._2\n\
    \        val smallestEvenIndex = evensSortedSortedWithIndex.minBy(_._1)._1\n \
    \       val smallestEvenValue = evensSortedSortedWithIndex.minBy(_._1)._2\n  \
    \      val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._1\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._2\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._1\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._2\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._1\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._2\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._1\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._2\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._1\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._2\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._1\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._2\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._1\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._2\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._1\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._2\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._1\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._2\n\
    \        val smallestEvenValueIndex = evensSortedSortedWithIndex.minBy(_._1)._1\n\
    \        val smallestEvenValueIndex = even\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6obc38cj.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = evensSortedSortedWithIndex.minBy(_._1)._2\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6obc38cj.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = evensSortedSortedWithIndex.minBy(_._1)._1\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6obc38cj.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = evensSortedSortedWithIndex.minBy(_._1)._2\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6obc38cj.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = evensSortedSortedWithIndex.minBy(_._1)._1\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote th"
  stdout: ''
  timestamp: 1659798951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val evens = arr.filter(_ % 2 == 0)\n        val minEven = evens.min\n\
    \        val minIndex = evens.indexOf(minEven)\n        val minValue = minEven\
    \ - minIndex\n        val maxEven = evens.max\n        val maxIndex = evens.indexOf(maxEven)\n\
    \        val maxValue = maxEven - maxIndex\n        val minIndex = minIndex +\
    \ 1\n        val maxIndex = maxIndex + 1\n        val minValue = minValue + 1\n\
    \        val maxValue = maxValue + 1\n        val minIndex = minIndex - 1\n  \
    \      val maxIndex = maxIndex - 1\n        val minValue = minValue - 1\n    \
    \    val maxValue = maxValue - 1\n        val minIndex = minIndex + 1\n      \
    \  val maxIndex = maxIndex + 1\n        val minValue = minValue + 1\n        val\
    \ maxValue = maxValue + 1\n        val minIndex = minIndex - 1\n        val maxIndex\
    \ = maxIndex - 1\n        val minValue = minValue - 1\n        val maxValue =\
    \ maxValue - 1\n        val minIndex = minIndex + 1\n        val maxIndex = maxIndex\
    \ + 1\n        val minValue = minValue + 1\n        val maxValue = maxValue +\
    \ 1\n        val minIndex = minIndex - 1\n        val maxIndex = maxIndex - 1\n\
    \        val minValue = minValue - 1\n        val maxValue = maxValue - 1\n  \
    \      val minIndex = minIndex + 1\n        val maxIndex = maxIndex + 1\n    \
    \    val minValue = minValue + 1\n        val maxValue = maxValue + 1\n      \
    \  val minIndex = minIndex - 1\n        val maxIndex = maxIndex - 1\n        val\
    \ minValue = minValue - 1\n        val maxValue = maxValue - 1\n        val minIndex\
    \ = minIndex + 1\n        val maxIndex = maxIndex + 1\n        val minValue =\
    \ minValue + 1\n        val maxValue = maxValue + 1\n        val minIndex = minIndex\
    \ - 1\n        val maxIndex = maxIndex - 1\n        val minValue = minValue -\
    \ 1\n        val maxValue = maxValue - 1\n        val minIndex = minIndex + 1\n\
    \        val maxIndex = maxIndex + 1\n        val minValue = minValue + 1\n  \
    \      val maxValue = maxValue + 1\n        val minIndex = minIndex - 1\n    \
    \    val maxIndex = maxIndex - 1\n        val minValue = minValue - 1\n      \
    \  val maxValue = maxValue - 1\n        val minIndex = minIndex + 1\n        val\
    \ maxIndex = maxIndex + 1\n        val minValue = minValue + 1\n        val maxValue\
    \ = maxValue + 1\n        val minIndex = minIndex - 1\n        val maxIndex =\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7gfbpq6f.scala:91:22 ---------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = \n\e[31m\e\
    [31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m                   \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp7gfbpq6f.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mminIndex\e[0m = minIndex\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mminIndex is already defined as \e[33mvalue\e[0m \e[35mminIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7gfbpq6f.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mmaxIndex\e[0m = maxIndex + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmaxIndex is already defined as \e[33mvalue\e[0m \e[35mmaxIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7gfbpq6f.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mminValue\e[0m = minValue + \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mminValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7gfbpq6f.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxValue\e[0m = maxValue + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxValue is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same "
  stdout: ''
  timestamp: 1659798951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val smallestEven = evens.min\n        val smallestIndex = evens.indexOf(smallestEven)\n\
    \        val result = evens.filter(x => x != smallestEven).takeWhile(x => x <\
    \ smallestEven).drop(1)\n        if (smallestIndex == -1) {\n            Array[Long]()\n\
    \        } else {\n            Array(smallestEven, smallestIndex)\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzvtd_q5f.scala:35:12\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            Array[\e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           Found:    \e[1m\e[31mArray\e[0m[Long]\n\e[31m   |\e[0m           \
    \ Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpzvtd_q5f.scala:37:17 --------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m            Array(smallestEven, smallestIndex)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            Found:    \e[1m\e[31mArray\e[0m[Long]\n\e[31m   |\e[0m          \
    \  Required: \e[1m\e[32mList\e[0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(x => x % 2 == 0).sorted\n        if (evens.isEmpty)\
    \ {\n            List[Long]()\n        } else if (evens.size == 1) {\n       \
    \     List(even, index)\n        } else {\n            val smallestEven = evens.head\n\
    \            val smallestIndex = evens.indexOf(0)\n            val index = arr.indexOf(0)\n\
    \            val result = arr.filter(x => x % 2 == 0).sorted\n            if (smallest\
    \ == smallestEven) {\n                List(smallestEven, smallestIndex)\n    \
    \        } else {\n                List(smallestEven, smallestIndex)\n       \
    \     }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpda3rbxji.scala:43:16 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            \e[33mif\e[0m (smallest == smallestEven)\
    \ {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \           Not found: smallest\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val smallest = evens.head\n        val index\
    \ = evens.indexWhere(x => x == smallest)\n        val result = if (index == 0)\
    \ List(smallest) else evens.take(index).sortBy(x => x).reverse\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzg_v_dxx.scala:37)\n\tat Problem.main(tmpzg_v_dxx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798954
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sorted\n        val evensSortedIndex = evensSorted.indexWhere(x\
    \ => x == evensSorted.head)\n        val evensSortedValue = evensSorted.head\n\
    \        val evensSortedIndexList = evensSortedIndex.toList\n        val evensSortedValueList\
    \ = evensSortedValue.toList\n        val evensSortedIndexListLength = evensSortedIndexList.length\n\
    \        val evensSortedValueListLength = evensSortedValueList.length\n      \
    \  val evensSortedIndexListLength = evensSortedIndexListLength\n        val evensSortedValueListLength\
    \ = evensSortedValueListLength\n        val evensSortedIndexListLength = evensSortedIndexListLength\n\
    \        val evensSortedValueListLength = evensSortedValueListLength\n       \
    \ val evensSortedIndexListLength = evensSortedIndexListLength\n        val evensSortedValueListLength\
    \ = evensSortedValueListLength\n        val evensSortedIndexListLength = evensSortedIndexListLength\n\
    \        val evensSortedValueListLength = evensSortedValueListLength\n       \
    \ val evensSortedIndexListLength = evensSortedIndexListLength\n        val evensSortedValueListLength\
    \ = evensSortedValueListLength\n        val evensSortedIndexListLength = evensSortedIndexListLength\n\
    \        val evensSortedValueListLength = evensSortedValueListLength\n       \
    \ val evensSortedIndexListLength = evensSortedIndexListLength\n        val evensSortedValueListLength\
    \ = evensSortedValueListLength\n        val evensSortedIndexListLength = evensSortedIndexListLength\n\
    \        val evensSortedValueListLength = evensSortedValueListLength\n       \
    \ val evensSortedIndexListLength = evensSortedIndexListLength\n        val evensSortedValueListLength\
    \ = evensSortedValueListLength\n        val evensSortedIndexListLength = evensSortedIndexListLength\n\
    \        val evensSortedValueListLength = evensSortedValueListLength\n       \
    \ val evensSortedIndexListLength = evensSortedIndexListLength\n        val evensSortedValueListLength\
    \ = evensSortedValueListLength\n        val evensSortedIndexListLength = evensSortedIndexListLength\n\
    \        val evensSortedValueListLength = evensSortedValueListLength\n       \
    \ val evensSortedIndexListLength = evensSortedIndexListLength\n        val evensSortedValueListLength\
    \ = evensSortedValueListLength\n        val evensSortedIndexList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnvb6v1rg.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnvb6v1rg.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevensSortedIndexListLength\e[0m = evensSortedIndexListLength\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSortedIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevensSortedIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnvb6v1rg.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevensSortedValueListLength\e\
    [0m = evensSortedValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSortedValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevensSortedValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnvb6v1rg.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevensSortedIndexListLength\e\
    [0m = evensSortedIndexListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSortedIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevensSortedIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnvb6v1rg.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevensSortedValueListLength\e\
    [0m = evensSortedValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659798952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n        val evenSmallest\
    \ = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOf(0)\n\
    \        val evenSmallestValue = evenSmallest\n        val evenSmallestIndexList\
    \ = evenSmallestIndex.toList\n        val evenSmallestValueList = evenSmallestValue.toList\n\
    \        val evenSmallestIndexListSorted = evenSmallestIndexList.sortWith((x,\
    \ y) => x < y)\n        val evenSmallestValueListSorted = evenSmallestValueList.sortWith((x,\
    \ y) => x < y)\n        val evenSmallestValueListSortedHead = evenSmallestValueListSorted.head\n\
    \        val evenSmallestValueListSortedTail = evenSmallestValueListSorted.tail\n\
    \        val evenSmallestValueListSortedTailHead = evenSmallestValueListSortedTail.head\n\
    \        val evenSmallestValueListSortedTailTail = evenSmallestValueListSortedTail.tail\n\
    \        val evenSmallestValueListSortedTailTailHead = evenSmallestValueListSortedTailTail.head\n\
    \        val evenSmallestValueListSortedTailTailTail = evenSmallestValueListSortedTailTail.tail\n\
    \        val evenSmallestValueListSortedTailTailTailHead = evenSmallestValueListSortedTailTailTail.head\n\
    \        val evenSmallestValueListSortedTailTailTailTail = evenSmallestValueListSortedTailTailTail.tail\n\
    \        val evenSmallestValueListSortedTailTailTailTailHead = evenSmallestValueListSortedTailTailTailTail.head\n\
    \        val evenSmallestValueListSortedTailTailTailTailTail = evenSmallestValueListSortedTailTailTailTail.tail\n\
    \        val evenSmallestValueListSortedTailTailTailTailHead = evenSmallestValueListSortedTailTailTailTailTail.head\n\
    \        val evenSmallestValueListSortedTailTailTailTailTailTail = evenSmallestValueListSortedTailTailTailTailTail.tail\n\
    \        val evenSmallestValueListSortedTailTailTailTailTailHead = evenSmallestValueListSortedTailTailTailTailTailTail.head\n\
    \        val evenSmallestValueListSortedTailTailTailTailTailTail = evenSmallestValueList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu9e0y1gu.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSortedTailTailTailTailHead\e\
    [0m = evenSmallestValueListSortedTailTailTailTailTail.head\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListSortedTailTailTailTailHead is already\
    \ defined as \e[33mvalue\e[0m \e[35mevenSmallestValueListSortedTailTailTailTailHead\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu9e0y1gu.scala:52:12 ---------------------------\e[0m\e[0m\n\e\
    [31m52 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSortedTailTailTailTailTailTail\e\
    [0m = evenSmallestValueList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListSortedTailTailTailTailTailTail is already\
    \ defined as \e[33mvalue\e[0m \e[35mevenSmallestValueListSortedTailTailTailTailTailTail\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpu9e0y1gu.scala:35:54 ------------------------\e[0m\e[0m\n\
    \e[31m35 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexList\e[0m = evenSmallestIndex.toList\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toList is not a member of Int - did you mean evenSmallestIndex.toInt?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu9e0y1gu.scala:36:54 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueList\e\
    [0m = evenSmallestValue.toList\n\e[31m\e[31m   |\e[0m                        \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toList is not\
    \ a member of Long - did you mean evenSmallestValue.toInt?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpu9e0y1gu"
  stdout: ''
  timestamp: 1659798953
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x - y)\n        val evensSortedIndex\
    \ = evensSorted.indexWhere(x => x == evensSorted.head)\n        val smalestValue\
    \ = evensSorted.take(evensSortedIndex).min\n        val smalestIndex = evensSortedIndex\n\
    \        val result = evensSorted.takeWhile(x => x == smalestValue).takeWhile(x\
    \ => x != smalestValue).map(x => smalestIndex + x).toList\n        if (result.isEmpty)\
    \ result\n        else result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf_l315y7.scala:31:51\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e\
    [0m                                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                   Found:    Long\n\e[31m \
    \  |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798951
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(_ % 2 == 0).sortWith(_\
    \ < _)\n        if (even.isEmpty) List()\n        else {\n            val min\
    \ = even(0)\n            val index = even.indexOf(min)\n            val result\
    \ = even.takeWhile(_ < min).takeWhile(_ < index).zipWithIndex.filter(_._2 < index).map(_._1)\n\
    \            if (result.isEmpty) List()\n            else result\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7t9ebecn.scala:41)\n\tat Problem.main(tmp7t9ebecn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = arr.filter(_ != even)\n        if (evens.isEmpty) result\n\
    \        else result.take(index).sortWith(_ < _).head\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpab7lzm5o.scala:35:48\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.take(index).sortWith(_\
    \ < _).head\n\e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             Found:    Long\n\e[31m   |\e[0m             Required:\
    \ \e[1m\e[32mList\e[0m\e[1m\e[32m[\e[0mLong\e[1m\e[32m]\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evenSmallest = evensSorted.head\n\
    \        val evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue\
    \ = evenSmallest\n        val evenSmallestIndexList = evenSmallestIndex.toList\n\
    \        val evenSmallestValueList = evenSmallestValue.toList\n        val evenSmallestIndexListSorted:\
    \ List[Int] = evenSmallestIndexList.sortWith(_ < _)\n        val evenSmallestValueListSorted:\
    \ List[Long] = evenSmallestValueList.sortWith(_ < _)\n        val evenSmallestValueListSortedList:\
    \ List[Long] = evenSmallestValueListSorted.map(x => arr.indexOf(x))\n        val\
    \ evenSmallestValueListSortedListList: List[Long] = evenSmallestValueListSortedList.map(x\
    \ => arr.indexOf(x))\n        val evenSmallestValueListSortedListListList: List[Long]\
    \ = evenSmallestValueListSortedListList.map(x => arr.indexOf(x))\n        val\
    \ evenSmallestValueListSortedListListList: List[Long] = evenSmallestValueListSortedListListList.map(x\
    \ => arr.indexOf(x))\n        val evenSmallestValueListSortedListListListList:\
    \ List[Long] = evenSmallestValueListSortedListListListList.map(x => arr.indexOf(x))\n\
    \        val evenSmallestValueListSortedListListListList: List[Long] = evenSmallestValueListSortedListListListList.map(x\
    \ => arr.indexOf(x))\n        val evenSmallestValueListSortedListListListList:\
    \ List[Long] = evenSmallestValueListSortedListListListList.map(x => arr.indexOf(x))\n\
    \        val evenSmallestValueListSortedListListListListList: List[Long] = evenSmallestValueListSortedListListListListList.map(x\
    \ => arr.indexOf(x))\n        val evenSmallestValueListSortedListListListListList:\
    \ List[Long] = evenSmallestValueListSortedListListListListList.map(x => arr.indexOf(x))\n\
    \        val evenSmallestValueListSortedListListListListListList: List[Long] =\
    \ evenSmallestValueListSortedListListListListListList.map(x => arr.indexOf(x))\n\
    \        val evenSmallestValueListSortedListListListListListList: List[Long] =\
    \ evenSmallestValueListSortedListListListListListList.map(x \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0wlktggj.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0wlktggj.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mevenSmallestValueListSortedListListList\e[0m: \e[35mList\e[0m[\e[35mLong\e\
    [0m] = evenSmallestValueListSortedListListList.map(\e[36mx\e[0m => arr.indexOf(x))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListSortedListListList is already defined\
    \ as \e[33mvalue\e[0m \e[35mevenSmallestValueListSortedListListList\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0wlktggj.scala:44:12 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSortedListListListList\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = evenSmallestValueListSortedListListListList.map(\e\
    [36mx\e[0m => arr.indexOf(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListSortedListListListList is already defined\
    \ as \e[33mvalue\e[0m \e[35mevenSmallestValueListSortedListListListList\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0wlktggj.scala:45:12 ---------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListSortedListListListList\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = evenSmallestValueListSortedListListListList.map(\e\
    [36mx\e[0m => arr.indexOf(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659798955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = if (arr.isEmpty) Nil else List(even, index)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptk0am71n.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798954
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x - y)\n        val evensSortedIndex\
    \ = evensSorted.zipWithIndex.toList\n        val smallestEven = evensSortedIndex.minBy(x\
    \ => x._2)\n        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = evensSortedIndex.find(x => x._1 == smallestEvenValue).get._2\n        val\
    \ smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue\
    \ + 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenValue\
    \ = smallestEvenValue - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenValue = smallestEvenValue -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenValue = smallestEvenValue - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenValue\
    \ = smallestEvenValue - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenValue = smallestEvenValue -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenValue = smallestEvenValue - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenValue = smallestEvenValue +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenValue\
    \ = smallestEvenValue - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenValue = smallestEvenValue + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenValue = smallestEvenValue -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenValue\
    \ = smallestEvenValue + 1\n        val smalle\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_9wdrmm_.scala:71:4 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_9wdrmm_.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndex\e[0m = smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_9wdrmm_.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m = smallestEvenValue\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_9wdrmm_.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_9wdrmm_.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded"
  stdout: ''
  timestamp: 1659798955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evensSortedWithIndex\
    \ = evensSorted.zipWithIndex\n        val smalestValue = evensSortedWithIndex.minBy(_._1)._2\n\
    \        val smalestIndex = evensSortedWithIndex.minBy(_._1)._2\n        val smalestValueAndIndex\
    \ = smalestValue -> smalestIndex\n        val smalestValueAndIndexList = smalestValueAndIndex.map(x\
    \ => x._1 -> x._2)\n        val smalestValueAndIndexListSorted = smalestValueAndIndexList.sortBy(_._1)\n\
    \        val smalestValueAndIndexListSortedWithIndex = smalestValueAndIndexListSorted.zipWithIndex\n\
    \        val smalestValueAndIndexListSortedWithIndexSorted = smalestValueAndIndexListSortedWithIndex.sortBy(_._1)\n\
    \        val smalestValueAndIndexListSortedWithIndexSortedWithIndex = smalestValueAndIndexListSortedWithIndexSorted.zipWithIndex\n\
    \        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSorted = smalestValueAndIndexListSortedWithIndexSortedWithIndex.sortBy(_._1)\n\
    \        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSorted.zipWithIndex\n\
    \        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndex.sortBy(_._1)\n\
    \        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.sortBy(_._1)\n\
    \        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted.zipWithIndex\n\
    \        val smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.sortBy(_._1)\n\
    \        val smalestValueAndIndexListSortedWithIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5e76fw5b.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp5e76fw5b.scala:36:64\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e\
    [0m \e[36msmalestValueAndIndexList\e[0m = smalestValueAndIndex.map(\e[36mx\e[0m\
    \ => x._1 -> x._2)\n\e[31m\e[31m   |\e[0m                                    \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \ Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m                   \
    \       I could not infer the type of the parameter x.\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp5e76fw5b.scala:37:70 ------------------------\e[0m\e\
    [0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmalestValueAndIndexListSorted\e\
    [0m = smalestValueAndIndexList.sortBy(_._1)\n\e[31m\e[31m   |\e[0m           \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      value sortBy is not a member of (Nothing, Nothing)\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5e76fw5b.scala:44:99 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36msmalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\e\
    [0m = smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.sortBy(_._1)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                           ^\e[0m\n\e[31m   |\e[0mRecursive \e\
    [33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  smalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp5e76fw5b.scala:45:105 --------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalestValueAndIndexListSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\e\
    [0m = smalestValueAndIndexListSortedWithIndexSo"
  stdout: ''
  timestamp: 1659798956
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result: List[Long] = if (index == -1) Nil else List(even, index)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcpl70jnn.scala:37)\n\tat Problem.main(tmpcpl70jnn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798958
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evensSortedSortedWithIndex\
    \ = evensSorted.zipWithIndex\n        val smallestEven = evensSortedSortedWithIndex.minBy(_._1)\n\
    \        val smallestEvenIndex = evensSortedSortedWithIndex.minBy(_._2)\n    \
    \    val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex =\
    \ smallestEven._2\n        val index = smallestEvenIndex\n        val value =\
    \ smallestEvenValue\n        val result: List[Long] = List(value, index)\n   \
    \     return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwn0ytikd.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEven._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpwn0ytikd.scala:39:45 --------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = List(value, index)\n\e[31m\e[31m   |\e[0m             \
    \                                ^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                        Found:    (index : (Long, Int))\n\e[31m   |\e[0m    \
    \                                     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659798956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sorted\n\
    \        val even = evens.head\n        val index = arr.indexOf(even)\n      \
    \  val evenIndex = arr.indexOf(even, index + 1)\n        val evenValue = evens.take(evenIndex).sum\n\
    \        val evenIndexList = evens.take(evenIndex).zipWithIndex.sortBy(_._1).map(_._2)\n\
    \        val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n       \
    \ val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList\
    \ = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList = evenIndexList.takeWhile(_\
    \ < arr.length)\n        val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n\
    \        val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n       \
    \ val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList\
    \ = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList = evenIndexList.takeWhile(_\
    \ < arr.length)\n        val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n\
    \        val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n       \
    \ val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList\
    \ = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList = evenIndexList.takeWhile(_\
    \ < arr.length)\n        val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n\
    \        val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n       \
    \ val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList\
    \ = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList = evenIndexList.takeWhile(_\
    \ < arr.length)\n        val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n\
    \        val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n       \
    \ val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList\
    \ = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList = evenIndexList.takeWhile(_\
    \ < arr.length)\n        val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n\
    \        val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n       \
    \ val evenIndexList = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList\
    \ = evenIndexList.takeWhile(_ < arr.length)\n        val evenIndexList = evenIndexList.takeWhile(_\
    \ < arr.length)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd590_f4h.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenIndexList\e[0m = evenIndexList.takeWhile(_\
    \ < arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenIndexList is already defined as \e[33mvalue\e[0m \e[35mevenIndexList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpd590_f4h.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mevenIndexList\e[0m = evenIndexList.takeWhile(_\
    \ < arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenIndexList is already defined as \e[33mvalue\e[0m \e[35mevenIndexList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpd590_f4h.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mevenIndexList\e[0m = evenIndexList.takeWhile(_\
    \ < arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenIndexList is already defined as \e[33mvalue\e[0m \e[35mevenIndexList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpd590_f4h.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mevenIndexList\e[0m = evenIndexList.takeWhile(_\
    \ < arr.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenIndexList is already defined as \e[33mvalue\e[0m \e[35mevenIndexList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpd590_f4h.scala:40:12 -------------"
  stdout: ''
  timestamp: 1659798958
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val smalest_value = evens.head\n        val smalest_index\
    \ = evens.indexOf(0)\n        val evens_without_smalest_value = evens.filterNot(x\
    \ => x == smalest_value)\n        if (evens_without_smalest_value.isEmpty) List(smalest_value,\
    \ smalest_index)\n        else evens_without_smalest_value.takeWhile(x => x <\
    \ smalest_value).sortBy(x => x).takeWhile(x => x < smalest_value).map(x => smalest_value\
    \ + x).takeWhile(x => x < smalest_value).map(x => smalest_index + x)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoein31ru.scala:38)\n\tat Problem.main(tmpoein31ru.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798960
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).reverse\n        val even = evens.head\n        val index\
    \ = arr.indexOf(even)\n        val result = arr.takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => x != even).takeWhile(x => x != even).takeWhile(x => x != even).takeWhile(x\
    \ => \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_o5hart8.scala:33:1391 -------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.takeWhile(\e\
    [36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e\
    [0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m\
    \ => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m =>\
    \ x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x\
    \ != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x !=\
    \ even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e\
    [36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e\
    [0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m\
    \ => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m =>\
    \ x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x\
    \ != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x !=\
    \ even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e\
    [36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e\
    [0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m\
    \ => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m =>\
    \ x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x\
    \ != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x !=\
    \ even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e\
    [36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e\
    [0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m\
    \ => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m =>\
    \ x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x\
    \ != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x !=\
    \ even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e[36mx\e[0m => x != even).takeWhile(\e\
    [36mx\e[0m => \n\e[31m\e[31m   |\e[0m                              "
  stdout: ''
  timestamp: 1659798958
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = if (index == 0) List(even) else List(even, index)\n    \
    \    result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8fgv9wt6.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798958
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sorted\n        val evensSortedIndex = evens.zipWithIndex.sortBy(_._1).reverse.head._2\n\
    \        val evensSortedIndexList = evensSortedIndex.map(x => arr.indexOf(x)).filter(x\
    \ => x >= 0)\n        val smallestEven = evensSortedIndexList.head\n        val\
    \ smallestEvenIndex = arr.indexOf(smallestEven)\n        val smallestEvenValue\
    \ = evensSortedIndexList.head\n        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n       \
    \ val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex\
    \ = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n       \
    \ val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex\
    \ = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n       \
    \ val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex\
    \ = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n       \
    \ val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex\
    \ = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n       \
    \ val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex\
    \ = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n       \
    \ val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex\
    \ = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n\
    \        val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n       \
    \ val smallestEvenValueIndex = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex\
    \ = arr.indexOf(smallestEvenValue)\n        val smallestEvenValueIndex = arr.indexOf(smalle\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyeemkebi.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyeemkebi.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenValueIndex\e[0m = arr.indexOf(smallestEvenValue)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyeemkebi.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = arr.indexOf(smallestEvenValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyeemkebi.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = arr.indexOf(smallestEvenValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyeemkebi.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = arr.indexOf(smallestEvenValue)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex "
  stdout: ''
  timestamp: 1659798961
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val smallestEven = evens.min\n        val smallestIndex = evens.indexOf(smallestEven)\n\
    \        val result = evens.filterNot(x => x == smallestEven)\n        if (smallestIndex\
    \ == -1) {\n            List()\n        } else {\n            List(smallestEven,\
    \ smallestIndex)\n        }\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3x4sq5qp.scala:42)\n\tat Problem.main(tmp3x4sq5qp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        if (evens.isEmpty) Nil\n        else evens.takeWhile(x\
    \ => x < evens.min).zipWithIndex.filter(_._2 % 2 == 0).map(_._1).reverse\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_cnf_d75.scala:35)\n\tat Problem.main(tmp_cnf_d75.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = evens.takeWhile(x => x != even).takeWhile(x => x != index).sorted\n\
    \        even.takeWhile(x => x != result).takeWhile(x => x != index).sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgtn1n84v.scala:34:13 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        even.takeWhile(\e[36mx\e[0m => x != result).takeWhile(\e\
    [36mx\e[0m => x != index).sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        value takeWhile is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659798962
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evensSortedSortedWithIndex\
    \ = evensSorted.zipWithIndex.toList\n        val smallestEven = evensSortedSortedWithIndex.minBy(_._1)\n\
    \        val smallestEvenIndex = evensSortedSortedWithIndex.indexOf(smallestEven)\n\
    \        val smallestEvenValue = smallestEven._1\n        val smallestEvenIndex\
    \ = smallestEven._2\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenIndex = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenIndex = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenIndex = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenIndex = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenIndex = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n     \
    \   val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue =\
    \ smallestEvenIndex\n        val smallestEvenIndex = smallestEvenIndex\n     \
    \   val smallestEvenValue = smallestEvenIndex\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val smallestEvenValue = smallestEvenIndex\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk1njugt0.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEven._2\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk1njugt0.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk1njugt0.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk1njugt0.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk1njugt0.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m  "
  stdout: ''
  timestamp: 1659798963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val smallestEven = evensSorted.head\n\
    \        val smallestEvenIndex = evensSorted.indexOf(0)\n        val smallestEvenValue\
    \ = smallestEven\n        val smallestEvenIndex = smallestEvenIndex\n        val\
    \ smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n\
    \        val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n        val smallestEvenValue = smallestEvenValue\n   \
    \     val smallestEvenIndex = smallestEvenIndex\n        val smallestEvenValue\
    \ = smallestEvenValue\n        val smallestEvenIndex = smallestEvenIndex\n   \
    \     val smallestEvenValue = smallestEvenValue\n        val smallestEvenIndex\
    \ = smallestEvenIndex\n\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxzno0z_f.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxzno0z_f.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxzno0z_f.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxzno0z_f.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValue\e[0m =\
    \ smallestEvenValue\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValue is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenValue\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxzno0z_f.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[3"
  stdout: ''
  timestamp: 1659798963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n        val evensSortedIndex\
    \ = evensSorted.zipWithIndex.toList\n        val smallestEven = evensSortedIndex.head._2\n\
    \        val smallestEvenIndex = evensSortedIndex.head._1\n        val evensSortedWithoutSmallestEven\
    \ = evensSorted.filterNot(x => x == smallestEven)\n        val evensSortedWithoutSmallestEvenIndex\
    \ = evensSortedWithoutSmallestEven.zipWithIndex.toList\n        val smallestEvenIndex\
    \ = evensSortedWithoutSmallestEvenIndex.head._1\n        val smallestEvenValue\
    \ = evensSortedWithoutSmallestEvenIndex.head._2\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._1\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._2\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._3\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._4\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._5\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._6\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._7\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._8\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._9\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._10\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._11\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._12\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._13\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._14\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._15\n        val smallestEvenValueIndex\
    \ = evensSortedWithoutSmallestEvenIndex.last._16\n        val smallestEvenValueIndex\
    \ = evens\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuit0kuip.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ evensSortedWithoutSmallestEvenIndex.head._1\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpuit0kuip.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = evensSortedWithoutSmallestEvenIndex.last._2\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuit0kuip.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = evensSortedWithoutSmallestEvenIndex.last._3\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuit0kuip.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenValueIndex\e\
    [0m = evensSortedWithoutSmallestEvenIndex.last._4\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenValueIndex is already defined as \e[33mvalue\e\
    [0m \e[35msmallestEvenValueIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ o"
  stdout: ''
  timestamp: 1659798963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        arr.foreach(x => if (x % 2 == 0) result += x)\n        if (result.isEmpty)\
    \ result\n        else result.sortWith((x, y) => x < y).take(1)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkon3dk_o.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798961
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n     \
    \   val smalest_value = evensSorted.head\n        val smalest_index = evensSorted.indexOf(0)\n\
    \        val result = evensSorted.takeWhile(x => x != smalest_value).takeWhile(x\
    \ => x != smalest_index).reverse\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb41yxwbk.scala:31:60\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                   Found:    Int\n\
    \e[31m   |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val evens = arr.filter(x => x % 2 == 0)\n        val evensSorted = evens.sortWith((x,\
    \ y) => x < y)\n        val evenSmallestValue = evensSorted.head\n        val\
    \ evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestIndexInList\
    \ = evenSmallestIndex\n        val evenSmallestIndexInList = evenSmallestIndexInList.next\n\
    \        val evenSmallestIndexInList = evenSmallestIndexInList.next\n        val\
    \ evenSmallestIndexInList = evenSmallestIndexInList.next\n        val evenSmallestIndexInList\
    \ = evenSmallestIndexInList.next\n        val evenSmallestIndexInList = evenSmallestIndexInList.next\n\
    \        val evenSmallestIndexInList = evenSmallestIndexInList.next\n        val\
    \ evenSmallestIndexInList = evenSmallestIndexInList.next\n        val evenSmallestIndexInList\
    \ = evenSmallestIndexInList.next\n        val evenSmallestIndexInList = evenSmallestIndexInList.next\n\
    \        val evenSmallestIndexInList = evenSmallestIndexInList.next\n        val\
    \ evenSmallestIndexInList = evenSmallestIndexInList.next\n        val evenSmallestIndexInList\
    \ = evenSmallestIndexInList.next\n        val evenSmallestIndexInList = evenSmallestIndexInList.next\n\
    \        val evenSmallestIndexInList = evenSmallestIndexInList.next\n        val\
    \ evenSmallestIndexInList = evenSmallestIndexInList.next\n        val evenSmallestIndexInList\
    \ = evenSmallestIndexInList.next\n        val evenSmallestIndexInList = evenSmallestIndexInList.next\n\
    \        val evenSmallestIndexInList = evenSmallestIndexInList.next\n        val\
    \ evenSmallestIndexInList = evenSmallestIndexInList.next\n        val evenSmallestIndexInList\
    \ = evenSmallestIndexInList.next\n        val evenSmallestIndexInList = evenSmallestIndexInList.next\n\
    \        val evenSmallestIndexInList = evenSmallestIndexInList.next\n        val\
    \ evenSmallestIndexInList = evenSmallestIndexInList.next\n        val evenSmallestIndexInList\
    \ = evenSmallestIndex\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxl4562nj.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexInList\e\
    [0m = evenSmallestIndexInList.next\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexInList is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexInList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxl4562nj.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexInList\e\
    [0m = evenSmallestIndexInList.next\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexInList is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexInList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxl4562nj.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexInList\e\
    [0m = evenSmallestIndexInList.next\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexInList is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexInList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxl4562nj.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndexInList\e\
    [0m = evenSmallestIndexInList.next\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexInList is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexInList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31"
  stdout: ''
  timestamp: 1659798964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = if (index == -1) Nil else List(even, index)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsxfa1oaq.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_).reverse\n\
    \        val even = evens.head\n        val index = evens.indexOf(0)\n       \
    \ val result: List[Long] = if (index > 0) evens.take(index) else evens.take(evens.length)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmp9uoyxuow.scala:30:50 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                               ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmp9uoyxuow.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortWith(_ < _)\n        if (even.isEmpty) List()\n        else {\n     \
    \       val index = even.indexOf(0)\n            if (index == 0) List()\n    \
    \        else {\n                val smalest_value = even.take(index).min\n  \
    \              val smalest_index = even.indexOf(smalest_value)\n             \
    \   List(smalest_value, smalest_index)\n            }\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.pluck(tmphg8g8kqg.scala:36)\n\tat Problem$.main(tmphg8g8kqg.scala:43)\n\
    \tat Problem.main(tmphg8g8kqg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798968
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(x => x % 2 == 0).filter(x => x != even).sortBy(x\
    \ => x).takeWhile(x => x < even).take(1)\n        if (result.isEmpty) result else\
    \ List(even, index)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbe6h0qlr.scala:37)\n\tat Problem.main(tmpbe6h0qlr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798969
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).takeWhile(x => x < arr.last).reverse\n        val index =\
    \ arr.lastIndexWhere(x => x % 2 == 0)\n        val result = even.takeWhile(x =>\
    \ x < arr.last).reverse.takeWhile(x => x < arr.last).reverse\n        if (result.isEmpty)\
    \ List(arr.last)\n        else List(arr.last, index)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz69owyxv.scala:37)\n\tat Problem.main(tmpz69owyxv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = evens.indexOf(even)\n     \
    \   val result = arr.filter(_ == even).sortWith(_ < _).take(index).reverse\n \
    \       result.isEmpty() match {\n            case true => List()\n          \
    \  case false => result\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp1lyaftkh.scala:34:15 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        result.isEmpty() \e[33mmatch\e[0m {\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \e[33mmethod\e\
    [0m \e[35misEmpty\e[0m in \e[33mclass\e[0m \e[35mList\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n        val evenSmallest\
    \ = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOfFirst\
    \ { x => x == evenSmallest }\n        val evenSmallestValue = evenSmallest\n \
    \       val evenSmallestIndexList = evenSmallestIndex :: Nil\n        val evenSmallestValueList\
    \ = evenSmallestValue :: Nil\n        if (evensSorted.isEmpty) {\n           \
    \ Nil\n        } else {\n            evenSmallestValueList :: evenSmallestIndexList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmm3gu4oz.scala:33:44 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestIndex\e[0m =\
    \ evensSorted.indexOfFirst { \e[36mx\e[0m => x == evenSmallest }\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        value indexOfFirst is not a member of List[Long]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmm3gu4oz.scala:40:12 --------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            evenSmallestValueList :: evenSmallestIndexList\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \           Found:    (evenSmallestValueList : List[Long])\n\e[31m   |\e[0m  \
    \          Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(_ % 2 == 0).sortBy(-_)\n\
    \        val evenIndex = even.indexWhere(_ % 2 == 0)\n        val smallestEven\
    \ = even.take(evenIndex).min\n        val smallestEvenIndex = even.indexOf(smallestEven)\n\
    \        val result = if (smallestEvenIndex == -1) Nil else List(smallestEven,\
    \ smallestEvenIndex)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpparluuzw.scala:35:8\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        var index = 0\n        arr.foreach(x => {\n            if (x % 2 == 0)\
    \ {\n                index += 1\n                result += x\n            }\n\
    \        })\n        if (result.isEmpty) {\n            return result\n      \
    \  }\n        val smallestEvenValue = result.min\n        val smallestEvenIndex\
    \ = result.indexWhere(_ == smallestEvenValue)\n        val smallestEvenIndexList\
    \ = result.take(smallestEvenIndex).toList\n        if (smallestEvenIndexList.length\
    \ == 1) {\n            smallestEvenIndexList :+ smallestEvenIndex\n        } else\
    \ {\n            smallestEvenIndexList\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_fjddy_y.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = List(even, index)\n        if (arr.isEmpty) result\n   \
    \     else result.sortBy(x => x._1).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7jnd6opb.scala:34:25\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (arr.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                         Found:    (result : List[AnyVal])\n\e[31m   |\e\
    [0m                         Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp7jnd6opb.scala:35:34 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(x => x._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                value _1 is not a member of AnyVal\n\e[31m\e\
    [31m-- Error: /tmp/tmp7jnd6opb.scala:35:37 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(x => x._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659798970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val smalest_value = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n\
    \        val smalest_even_value = evens(smalest_index)\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value_index = smalest_index\n    \
    \    val smalest_even_value_index2 = smalest_index\n        val smalest_even_value_index3\
    \ = smalest_index\n        val smalest_even_value_index4 = smalest_index\n   \
    \     val smalest_even_value_index5 = smalest_index\n        val smalest_even_value_index6\
    \ = smalest_index\n        val smalest_even_value_index7 = smalest_index\n   \
    \     val smalest_even_value_index8 = smalest_index\n        val smalest_even_value_index9\
    \ = smalest_index\n        val smalest_even_value_index10 = smalest_index\n  \
    \      val smalest_even_value_index11 = smalest_index\n        val smalest_even_value_index12\
    \ = smalest_index\n        val smalest_even_value_index13 = smalest_index\n  \
    \      val smalest_even_value_index14 = smalest_index\n        val smalest_even_value_index15\
    \ = smalest_index\n        val smalest_even_value_index16 = smalest_index\n  \
    \      val smalest_even_value_index17 = smalest_index\n        val smalest_even_value_index18\
    \ = smalest_index\n        val smalest_even_value_index19 = smalest_index\n  \
    \      val smalest_even_value_index20 = smalest_index\n        val smalest_even_value_index21\
    \ = smalest_index\n        val smalest_even_value_index22 = smalest_index\n  \
    \      val smalest_even_value_index23 = smalest_index\n        val smalest_even_value_index24\
    \ = smalest_index\n        val smalest_even_value_index25 = smalest_index\n  \
    \      val smalest_even_value_index26 = smalest_index\n        val smalest_even_value_index27\
    \ = smalest_index\n        val smalest_even_value_index28 = smalest_index\n  \
    \      val smalest_even_value_index29 = smalest_index\n        val smalest_even_value_index30\
    \ = smalest_index\n        val smalest_even_value_index31 = smalest_index\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2s4kvo_a.scala:66:5\
    \ ---------------------\e[0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798970
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith(_ < _)\n        val smallestEven\
    \ = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val index = smallestEvenIndex\n        val result: List[Long] = List(smallestEven,\
    \ index)\n        if (evensSorted.isEmpty) result\n        else result.sortWith(_\
    \ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf76ytuyj.scala:40)\n\tat Problem.main(tmpf76ytuyj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798973
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).takeWhile(x => x < arr.last)\n        if (even.isEmpty) Nil\n\
    \        else even.takeWhile(x => x < arr.last).sortBy(x => x).take(1)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi9qp1p3m.scala:35)\n\tat Problem.main(tmpi9qp1p3m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.filter(_ < arr.max)\n    \
    \    val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.filter(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.filter(_ < arr.max)\n    \
    \    val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.filter(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.filter(_ < arr.max)\n    \
    \    val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.filter(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.filter(_ < arr.max)\n    \
    \    val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.filter(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.filter(_ < arr.max)\n    \
    \    val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.filter(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.filter(_ < arr.max)\n    \
    \    val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.filter(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = evensSorted.filter(_ < arr.max)\n    \
    \    val evensSorted = evensSorted.takeWhile(_ < arr.max)\n        val evensSorted\
    \ = evensSorted.filter(_ < arr.max)\n        val evensSorted = evensSorted.takeWhile(_\
    \ < arr.max)\n        val evensSorted = even\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw25te4z_.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpw25te4z_.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.filter(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpw25te4z_.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.takeWhile(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpw25te4z_.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evensSorted.filter(_\
    \ < arr.max)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevensSorted is already defined as \e[33mvalue\e[0m \e[35mevensSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpw25te4z_.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = even"
  stdout: ''
  timestamp: 1659798974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val smallest = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = List(smallest, index)\n        if (evens.isEmpty) result\n\
    \        else evens.take(1).foldLeft(result)((x, y) => if (x._2 < y._2) x else\
    \ y)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpolxid0rp.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpolxid0rp.scala:35:60 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m evens.take(\e[31m1\e[0m).foldLeft(result)((x,\
    \ y) => \e[33mif\e[0m (x._2 < y._2) x \e[33melse\e[0m y)\n\e[31m\e[31m   |\e[0m\
    \                                                          ^^^^\e[0m\n\e[31m \
    \  |\e[0m                                value _2 is not a member of List[AnyVal]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpolxid0rp.scala:35:78 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m evens.take(\e[31m1\e[0m).foldLeft(result)((x,\
    \ y) => \e[33mif\e[0m (x._2 < y._2) x \e[33melse\e[0m y)\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \  ^\e[0m\n\e[31m   |\e[0m                                                  Found:\
    \    (y : Long)\n\e[31m   |\e[0m                                             \
    \     Required: List[AnyVal]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x - y)\n        val smallestEven\
    \ = evensSorted.head\n        val smallestIndex = evensSorted.indexOf(0)\n   \
    \     val result: List[Long] = if (smallestEven == 0) List(smallestIndex) else\
    \ List(smallestEven, smallestIndex)\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkh5fn4eo.scala:31:51\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x - y)\n\e[31m\e[31m   |\e\
    [0m                                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                   Found:    Long\n\e[31m \
    \  |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x < y)\n        val smallestEven\
    \ = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val smallestEvenIndex = if (smallestEvenIndex == -1) -1 else smallestEvenIndex\n\
    \        val result = if (smallestEvenIndex == arr.length) arr.toList else arr.take(smallestEvenIndex).zip(smallestEven).toList\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpojq4h4sf.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ \e[33mif\e[0m (smallestEvenIndex == -\e[31m1\e[0m) -\e[31m1\e[0m \e[33melse\e\
    [0m smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpojq4h4sf.scala:35:106 -------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e\
    [0m (smallestEvenIndex == arr.length) arr.toList \e[33melse\e[0m arr.take(smallestEvenIndex).zip(smallestEven).toList\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                  ^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                         Found:    (smallestEven : Long)\n\
    \e[31m   |\e[0m                                         Required: IterableOnce[Any]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpojq4h4sf.scala:36:8\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Long\
    \ | (Long, Nothing)])\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val smalest_value = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n\
    \        val smalest_even_value = evens(smalest_index)\n        val smalest_even_index\
    \ = evens.indexOf(smalest_even_value)\n        val smalest_even_value_index =\
    \ smalest_even_index\n        val smalest_even_value_index_plus_1 = smalest_even_index\
    \ + 1\n        val smalest_even_value_index_plus_2 = smalest_even_index + 2\n\
    \        val smalest_even_value_index_plus_3 = smalest_even_index + 3\n      \
    \  val smalest_even_value_index_plus_4 = smalest_even_index + 4\n        val smalest_even_value_index_plus_5\
    \ = smalest_even_index + 5\n        val smalest_even_value_index_plus_6 = smalest_even_index\
    \ + 6\n        val smalest_even_value_index_plus_7 = smalest_even_index + 7\n\
    \        val smalest_even_value_index_plus_8 = smalest_even_index + 8\n      \
    \  val smalest_even_value_index_plus_9 = smalest_even_index + 9\n        val smalest_even_value_index_plus_10\
    \ = smalest_even_index + 10\n        val smalest_even_value_index_plus_11 = smalest_even_index\
    \ + 11\n        val smalest_even_value_index_plus_12 = smalest_even_index + 12\n\
    \        val smalest_even_value_index_plus_13 = smalest_even_index + 13\n    \
    \    val smalest_even_value_index_plus_14 = smalest_even_index + 14\n        val\
    \ smalest_even_value_index_plus_15 = smalest_even_index + 15\n        val smalest_even_value_index_plus_16\
    \ = smalest_even_index + 16\n        val smalest_even_value_index_plus_17 = smalest_even_index\
    \ + 17\n        val smalest_even_value_index_plus_18 = smalest_even_index + 18\n\
    \        val smalest_even_value_index_plus_19 = smalest_even_index + 19\n    \
    \    val smalest_even_value_index_plus_20 = smalest_even_index + 20\n        val\
    \ smalest_even_value_index_plus_21 = smalest_even_index + 21\n        val smalest_even_value_index_plus_22\
    \ = smalest_even_index + 22\n        val smalest_even_value_index_plus_23 = smalest_even_index\
    \ + 23\n        val smalest_even_value_index_plus_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1p5905mq.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp1p5905mq.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = evens.indexOf(even)\n     \
    \   val result = arr.filter(_ == even).sortBy(_).take(index)\n        result.headOption.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmppaxt2bi8.scala:33:50 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.filter(_\
    \ == even).sortBy(_).take(index)\n\e[31m\e[31m   |\e[0m                      \
    \                            ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter\
    \ _$3 of expanded function:\n\e[31m   |\e[0m   _$3 => arr.filter(_$2 => _$2 ==\
    \ even).sortBy(_$3).take(index).\n\e[31m\e[31m-- Error: /tmp/tmppaxt2bi8.scala:33:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m33 |\e[0m       \
    \ \e[33mval\e[0m \e[36mresult\e[0m = arr.filter(_ == even).sortBy(_).take(index)\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        var index = 0\n        var smallest = 0\n        var smallestIndex =\
    \ 0\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0)\
    \ {\n                if (smallest == 0) {\n                    smallest = arr(i)\n\
    \                    smallestIndex = i\n                } else {\n           \
    \         if (arr(i) < smallest) {\n                        smallest = arr(i)\n\
    \                        smallestIndex = i\n                    }\n          \
    \      }\n            }\n        }\n        result.add(smallest)\n        result.add(smallestIndex)\n\
    \        return result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0j9ckxu.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm0j9ckxu.scala:37:34\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m                    smallest\
    \ = arr(i)\n\e[31m\e[31m   |\e[0m                               ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               Found:    Long\n\e[31m   |\e[0m  \
    \                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpm0j9ckxu.scala:41:38 --------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                        smallest = arr(i)\n\e[31m\e[31m\
    \   |\e[0m                                   ^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                               Found:    Long\n\e[31m   |\e[0m              \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val result = if (index == -1) List(even) else List(even, index)\n   \
    \     return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf_nc__wq.scala:34:15\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mreturn\e[0m result\n\
    \e[31m\e[31m   |\e[0m               ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \  Found:    (result : List[AnyVal])\n\e[31m   |\e[0m               Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_).reverse\n\
    \        val smallest = evens.head\n        val index = evens.indexOfFirst { _\
    \ == smallest }\n        if (index >= 0) {\n            List(smallest, index)\n\
    \        } else {\n            List()\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmpghi9nh3h.scala:30:50 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                               ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 => arr.filter(_$1\
    \ => _$1 % 2 == 0).sortBy(_$2).reverse.\n\e[31m\e[31m-- Error: /tmp/tmpghi9nh3h.scala:30:52\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m30 |\e[0m       \
    \ \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = arr.indexOf(even)\n\
    \        val result = arr.takeWhile(x => x != even).takeWhile(x => x % 2 == 0).sorted\n\
    \        if (result.isEmpty) List(even, index)\n        else List(even, index,\
    \ result)\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpok105c1_.scala:35:31\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m List(even,\
    \ index, result)\n\e[31m\e[31m   |\e[0m                               ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               Found:    (result : List[Long])\n\
    \e[31m   |\e[0m                               Required: Long\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659798975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val smalest_value = evens.head\n        val smalest_index\
    \ = evens.indexOf(0)\n        if (evens.isEmpty) List(smalest_value, smalest_index)\n\
    \        else evens.takeWhile(x => x < smalest_value).sortBy(x => x).takeWhile(x\
    \ => x < smalest_value).map(x => smalest_value + x).takeWhile(x => x < smalest_value).map(x\
    \ => smalest_index).takeWhile(x => x < smalest_index).map(x => smalest_value +\
    \ x).takeWhile(x => x < smalest_index).map(x => smalest_index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8b4i94ee.scala:37)\n\tat Problem.main(tmp8b4i94ee.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n     \
    \   val evenSmallest = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOfFirst\
    \ { x => x == evenSmallest }\n        val evenSmallestValue = evenSmallest\n \
    \       val evenSmallestIndexList = evenSmallestIndex.toList\n        val smalestValue\
    \ = evenSmallestValue\n        val smalestIndexList = evenSmallestIndexList.toList\n\
    \        if (evenSmallestIndexList.isEmpty) {\n            List[Long]()\n    \
    \    } else {\n            val smalestIndexListWithSmallestIndex = smalestIndexList.zip(smalestValue).sortWith((x,\
    \ y) => x.compare(y))\n            val smalestIndexWithSmallestValue = smalestIndexListWithSmallestIndex.head\n\
    \            val smalestIndexWithSmallestIndex = smalestIndexListWithSmallestIndex.last\n\
    \            val smalestIndexWithSmallestValueIndex = smalestIndexWithSmallestIndex.zip(smalestValue).sortWith((x,\
    \ y) => x.compare(y))\n            val smalestIndexWithSmallestValueIndex = smalestIndexWithSmallestValueIndex.last\n\
    \            val smalestIndexWithSmallestValueIndex = smalestIndexWithSmallestValueIndex.last\n\
    \            val smalestIndexWithSmallestValueIndex = smalestIndexWithSmallestValueIndex.last\n\
    \            val smalestIndexWithSmallestValueIndex = smalestIndexWithSmallestValueIndex.last\n\
    \            val smalestIndexWithSmallestValueIndex = smalestIndexWithSmallestValueIndex.last\n\
    \            val smalestIndexWithSmallestValueIndex = smalestIndexWithSmallestValueIndex.last\n\
    \            val smalestIndexWithSmallestValueIndex = smalestIndexWithSmallestValueIndex.last\n\
    \            val smalestIndexWithSmallestValueIndex = smalestIndexWithSmallestValueIndex.last\n\
    \            val smalestIndexWithSmallestValueIndex = smalestIndexWithSmallestValueIndex.last\n\
    \            val smalestIndexWithSmallestValueIndex = smalestIndexWithSmallestValueIndex.last\n\
    \            val \n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpnnbrweli.scala:55:15 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnnbrweli.scala:69:0 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnnbrweli.scala:31:60\
    \ --------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e\
    [0m = evens.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m\
    \   |\e[0m                                                   ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                                   Found:    Int\n\
    \e[31m   |\e[0m                                                   Required: Boolean\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnnbrweli.scala:33:44\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mevenSmallestIndex\e[0m = evensSorted.indexOfFirst { \e[36mx\e[0m => x == evenSmallest\
    \ }\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        value indexOfFirst is not a member\
    \ of List[Long]\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnnbrweli.scala:45:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m            \e[33mval\e\
    [0m \e[36msmalestIndexWithSmallestValueIndex\e[0m = smalestIndexWithSmallestValueIndex.last\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmalestIndexWithSmallestValueIndex is already defined as \e\
    [33mvalue\e[0m \e[35msmalestIndexWithSmallestValueIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/t"
  stdout: ''
  timestamp: 1659798978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val even = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).takeWhile(x => x < arr.last).map(x => x).reverse\n       \
    \ val index = arr.filter(x => x % 2 == 0).sortBy(x => x).takeWhile(x => x < arr.last).map(x\
    \ => arr.lastIndexOf(x)).map(x => x).reverse\n        val result = even.zip(index).filter(_._1\
    \ < _._1).map(_._2)\n        if (result.isEmpty) result\n        else result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfr7pfufu.scala:32:46 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = even.zip(index).filter(_._1\
    \ < _._1).map(_._2)\n\e[31m\e[31m   |\e[0m                                   \
    \         ^^^^\e[0m\n\e[31m   |\e[0m                                        value\
    \ _1 is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfr7pfufu.scala:33:28\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m (result.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                            ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Found:    (result : List[Int])\n\e[31m \
    \  |\e[0m                            Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfr7pfufu.scala:34:13 --------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33melse\e[0m result\n\e[31m\e[31m   |\e[0m\
    \             ^^^^^^\e[0m\n\e[31m   |\e[0m             Found:    (result : List[Int])\n\
    \e[31m   |\e[0m             Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = List(even, index)\n        if (evens.isEmpty) result\n \
    \       else result.sortWith((x, y) => x < y)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1ba0q8o6.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp1ba0q8o6.scala:35:41 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortWith((x, y) => x <\
    \ y)\n\e[31m\e[31m   |\e[0m                                       ^^^\e[0m\n\e\
    [31m   |\e[0mvalue < is not a member of AnyVal, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\
    \e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659798979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_)\n\
    \        val even = evens.head\n        val index = evens.indexOfFirst { x =>\
    \ x == even }\n        val result = arr.filter(_ % 2 == 0).sortBy(_).takeWhile(_\
    \ != even).take(index).map(_ / 2)\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpna36lpc3.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.ordered[\e[35mAny\e[0m](\n\e[31m   |\e[0m      /* missing\
    \ */summon[scala.math.Ordering.AsComparable[Any]]\n\e[31m   |\e[0m    )\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type scala.math.Ordering.AsComparable[Any].\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmpna36lpc3.scala:33:51 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).takeWhile(_ != even).take(index).map(_\
    \ / \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \              ^\e[0m\n\e[31m   |\e[0mMissing parameter type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mI could not infer the type of the parameter _$4 of expanded function:\n\
    \e[31m   |\e[0m_$4 => \n\e[31m   |\e[0m  arr.filter(_$3 => _$3 % 2 == 0).sortBy(_$4).takeWhile(_$5\
    \ => _$5 != even).take\n\e[31m   |\e[0m    (\n\e[31m   |\e[0m  index).map(_$6\
    \ => _$6 / 2).\n\e[31m\e[31m-- Error: /tmp/tmpna36lpc3.scala:33:53 -----------------------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_).takeWhile(_ != even).take(index).map(_\
    \ / \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                                     \
    \                ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mDeprecatedDoubleOrdering\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mLong\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659798981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val evens = arr.filter(x => x % 2 == 0)\n        val even = evens.min\n\
    \        val index = arr.indexOf(even)\n        result.add(even)\n        result.add(index)\n\
    \        return result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9klj284d.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = List(even, index)\n        if (evens.isEmpty) result\n \
    \       else result.reverse\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz_v8j8qh.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz_v8j8qh.scala:35:20 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.reverse\n\e[31m\e[31m\
    \   |\e[0m             ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             Found:\
    \    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m             Required: List[\e\
    [1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val evensSorted = evens.sortWith(_ < _)\n        val evenSmallest = evensSorted.head\n\
    \        val evenSmallestIndex = evensSorted.indexOf(0)\n        val evenSmallestValue\
    \ = evenSmallest\n        val evenSmallestIndexList = evenSmallestIndex.asInstanceOf[List[Long]]\n\
    \        val evenSmallestValueList = evenSmallestValue.asInstanceOf[List[Long]]\n\
    \        val evenSmallestIndexListLength = evenSmallestIndexList.length\n    \
    \    val evenSmallestValueListLength = evenSmallestValueList.length\n        if\
    \ (evenSmallestIndexListLength == 0 || evenSmallestValueListLength == 0) {\n \
    \           List[Long]()\n        } else {\n            val evenSmallestIndexListLength\
    \ = evenSmallestIndexList.length\n            val evenSmallestValueListLength\
    \ = evenSmallestValueList.length\n            val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n            val evenSmallestValueListLength =\
    \ evenSmallestValueListLength\n            val evenSmallestIndexListLength = evenSmallestIndexListLength\n\
    \            val evenSmallestValueListLength = evenSmallestValueListLength\n \
    \           val evenSmallestIndexListLength = evenSmallestIndexListLength\n  \
    \          val evenSmallestValueListLength = evenSmallestValueListLength\n   \
    \         val evenSmallestIndexListLength = evenSmallestIndexListLength\n    \
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \       val evenSmallestIndexListLength = evenSmallestIndexListLength\n      \
    \      val evenSmallestValueListLength = evenSmallestValueListLength\n       \
    \     val evenSmallestIndexListLength = evenSmallestIndexListLength\n        \
    \    val evenSmallestValueListLength = evenSmallestValueListLength\n         \
    \   val evenSmallestIndexListLength = evenSmallestIndexListLength\n          \
    \  val evenSmallestValueListLength = evenSmallestValueListLength\n           \
    \ val evenSmallestIndexListLength = evenSmallestIndexListLength\n            val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n            val evenSmallestIndexListLength\
    \ = evenSmallestIndexListLength\n            val evenSmallestValueListLength =\
    \ evenSmallestValueListLength\n            val evenSm\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpslx01oyo.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpslx01oyo.scala:76:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpslx01oyo.scala:44:16 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m            \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e[0m\
    \ = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpslx01oyo.scala:45:16 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpslx01oyo.scala:46:16 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            \e[33mval\e[0m \e[36mevenSmallestIndexListLength\e\
    [0m = evenSmallestIndexListLength\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestIndexListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestIndexListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpslx01oyo.scala:47:16 -----------------"
  stdout: ''
  timestamp: 1659798982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result = if (index == -1) Nil else List(smallest, index)\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcbl05fz8.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798898
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = mutable.ListBuffer[Long]()\n\
    \        arr.foreach(x => if (x % 2 == 0) result += x)\n        arr.sortWith(_\
    \ < _)\n        result.takeWhile(_ % 2 == 0).headOption\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpong_q4s_.scala:30:21 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n     \
    \   val evenSmallest = evensSorted.head\n        val evenSmallestIndex = evensSorted.indexOfFirst\
    \ { x => x == evenSmallest }\n        val evenSmallestValue = evenSmallest\n \
    \       val evenSmallestIndexList = evenSmallestIndex.asInstanceOf[List[Int]]\n\
    \        val evenSmallestValueList = evenSmallestValue.asInstanceOf[List[Long]]\n\
    \        val evenSmallestValueListLength = evenSmallestValueList.length\n    \
    \    val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n        val evenSmallestValueListLength\
    \ = evenSmallestValueListLength\n        val evenSmallestValueListLength = evenSmallestValueListLength\n\
    \        val evenSmallestValueListLength = evenSmallestValueListLength\n     \
    \   val evenSmallestValueListLength = evenSmallestValueListLength\n        val\
    \ evenSmallestValueListLength = evenSmallestValueListLength\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi55d51hi.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi55d51hi.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi55d51hi.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi55d51hi.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mevenSmallestValueListLength\e\
    [0m = evenSmallestValueListLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mevenSmallestValueListLength is already defined as \e[33mvalue\e\
    [0m \e[35mevenSmallestValueListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all b"
  stdout: ''
  timestamp: 1659798983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(x => x % 2 == 0 && x != even).sorted\n      \
    \  if (result.isEmpty) List()\n        else List(even, index)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong,\
    \ 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp24ff93ft.scala:38)\n\tat Problem.main(tmp24ff93ft.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798983
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val smallest = evens.min\n        val index = evens.indexOf(smallest)\n\
    \        val result: List[Long] = List(smallest, index)\n        if (evens.isEmpty)\
    \ result\n        else result.sortWith((a, b) => a.compareTo(b) < 0)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_6siy1f0.scala:38)\n\tat Problem.main(tmp_6siy1f0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith((x, y) => x.compare(y))\n     \
    \   val smallestEven = evensSorted.head\n        val smallestEvenIndex = evensSorted.indexOf(0)\n\
    \        val smallestEvenValue = smallestEven\n        val smallestEvenIndex =\
    \ smallestEvenIndex\n        val result = List(smallestEvenValue, smallestEvenIndex)\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpp1gt5rv9.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpp1gt5rv9.scala:31:60 --------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mevensSorted\e[0m = evens.sortWith((\e\
    [36mx\e[0m, \e[36my\e[0m) => x.compare(y))\n\e[31m\e[31m   |\e[0m            \
    \                                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                Found:    Int\n\e[31m   |\e[0m\
    \                                                   Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp1gt5rv9.scala:37:15 --------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mreturn\e[0m result\n\e[31m\e[31m   |\e\
    [0m               ^^^^^^\e[0m\n\e[31m   |\e[0m               Found:    (result\
    \ : List[AnyVal])\n\e[31m   |\e[0m               Required: List[Long]\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659798984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sorted\n\
    \        val even = evens.head\n        val index = evens.indexOfFirst { x =>\
    \ x == even }\n        val result = arr.filter(_ % 2 == 0).filter(_ == even).sorted\n\
    \        if (result.isEmpty) Nil\n        else result.take(1).map(_ - index).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpun5ei0h5.scala:32:26 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mindex\e[0m = evens.indexOfFirst\
    \ { \e[36mx\e[0m => x == even }\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value indexOfFirst is not a member of\
    \ List[Long]\n1 error found\n"
  stdout: ''
  timestamp: 1659798984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val smalest_value = evens.min\n        val smalest_index = evens.indexOf(smalest_value)\n\
    \        val smalest_even = evens(smalest_index)\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_even_index = smalest_index\n\
    \        val smalest_even_value = smalest_value\n        val smalest_even_index\
    \ = smalest_index\n        val smalest_even_value = smalest_value\n        val\
    \ smalest_even_index = smalest_index\n        val smalest_even_value = smalest_value\n\
    \        val smalest_even_index = smalest_index\n        val smalest_even_value\
    \ = smalest_value\n        val smalest_even_index = smalest_index\n        val\
    \ smalest_even_value = smalest_value\n        val smalest_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf_23rcbn.scala:73:4 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf_23rcbn.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmalest_even_index\e[0m = smalest_index\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msmalest_even_index\
    \ is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpf_23rcbn.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpf_23rcbn.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_index\e[0m = smalest_index\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_index is already defined as \e[33mvalue\e[0m \e[35msmalest_even_index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpf_23rcbn.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36msmalest_even_value\e[0m = smalest_value\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msmalest_even_value is already defined as \e[33mvalue\e[0m \e[35msmalest_even_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- "
  stdout: ''
  timestamp: 1659798985
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x).map(x => x).distinct\n        val smallest = evens.head\n\
    \        val index = evens.indexOf(smallest)\n        val result = if (index ==\
    \ 0) List(smallest) else evens.take(index).zip(evens.drop(index)).map(_._1)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgmq9wgn5.scala:37)\n\tat Problem.main(tmpgmq9wgn5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val even = evens.min\n        val index = evens.indexOf(even)\n\
    \        val smalest_value = evens.filter(x => x % 2 == 0).min\n        val smalest_index\
    \ = evens.indexOf(smalest_value)\n        val result = if (smalest_index == -1)\
    \ Array(smalest_value) else Array(smalest_value, smalest_index)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuazykx9_.scala:36:8\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        var index = 0\n        var smallest = 0\n        var smallestIndex =\
    \ 0\n        for (i <- 0 until arr.length) {\n            if (arr(i) % 2 == 0)\
    \ {\n                if (smallest == 0) {\n                    smallest = arr(i)\n\
    \                    smallestIndex = i\n                } else {\n           \
    \         if (arr(i) < smallest) {\n                        smallest = arr(i)\n\
    \                        smallestIndex = i\n                    }\n          \
    \      }\n            }\n        }\n        result.add(smallest)\n        result.add(smallestIndex)\n\
    \        return result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm0j9ckxu.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm0j9ckxu.scala:37:34\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m                    smallest\
    \ = arr(i)\n\e[31m\e[31m   |\e[0m                               ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               Found:    Long\n\e[31m   |\e[0m  \
    \                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpm0j9ckxu.scala:41:38 --------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                        smallest = arr(i)\n\e[31m\e[31m\
    \   |\e[0m                                   ^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                               Found:    Long\n\e[31m   |\e[0m              \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659798976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = List(even, index)\n        if (evens.isEmpty) result\n \
    \       else result.sortBy(x => x).reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvj14mtel.scala:34:27\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mif\e[0m (evens.isEmpty)\
    \ result\n\e[31m\e[31m   |\e[0m                           ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                           Found:    (result : List[AnyVal])\n\e[31m\
    \   |\e[0m                           Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmpvj14mtel.scala:35:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33melse\e[0m result.sortBy(x => x).reverse\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0mNo\
    \ implicit Ordering defined for AnyVal..\n\e[31m   |\e[0mI found:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m    scala.math.Ordering.comparatorToOrdering[\e[35mAnyVal\e\
    [0m](\n\e[31m   |\e[0m      /* missing */summon[java.util.Comparator[AnyVal]]\n\
    \e[31m   |\e[0m    )\n\e[31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were\
    \ found that match type java.util.Comparator[AnyVal].\n2 errors found\n"
  stdout: ''
  timestamp: 1659798986
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sorted\n        val even = evens.head\n        val index = evens.indexOf(0)\n\
    \        val result = arr.filter(x => x % 2 == 0).filter(x => x != even).sorted\n\
    \        if (result.isEmpty) List()\n        else if (result.size == 1) List(result(0))\n\
    \        else List(result(0), index)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(pluck((List[Long](4l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong, 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong,\
    \ 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsaxsz1f5.scala:39)\n\tat Problem.main(tmpsaxsz1f5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659798986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0)\n        val evensSorted = evens.sortWith(_ < _)\n        val evensSortedIndex\
    \ = evensSorted.zipWithIndex.toList\n        val smallestEven = evensSortedIndex.find(x\
    \ => x._2 == 0)\n        val smallestEvenValue = smallestEven._1\n        val\
    \ smallestEvenIndex = smallestEven._2\n        val smallestEvenIndex = smallestEvenIndex\
    \ + 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex - 1\n        val smallestEvenIndex = smallestEvenIndex +\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex - 1\n        val smallestEvenIndex\
    \ = smallestEvenIndex + 1\n        val smallestEvenIndex = smallestEvenIndex -\
    \ 1\n        val smallestEvenIndex = smallestEvenIndex + 1\n        val smallestEven\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxj8ppw1x.scala:72:4 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxj8ppw1x.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36msmallestEvenIndex\e[0m = smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e[35msmallestEvenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxj8ppw1x.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m = smallestEvenIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxj8ppw1x.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxj8ppw1x.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36msmallestEvenIndex\e[0m =\
    \ smallestEvenIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msmallestEvenIndex is already defined as \e[33mvalue\e[0m \e\
    [35msmallestEvenIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded"
  stdout: ''
  timestamp: 1659798986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val evens = arr.filter(_ % 2 == 0)\n        val even = evens.min\n  \
    \      val index = arr.indexOf(even)\n        result += (even -> index)\n    \
    \    evens.filter(_ != even).foreach(x => result += (x -> arr.indexOf(x)))\n \
    \       result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy8h_tiby.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659798984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0)\n\
    \        val even = evens.min\n        val index = arr.indexOf(even)\n       \
    \ val result = arr.filter(_ != even).filter(_ % 2 == 0).minBy(_ % 2 == 0)\n  \
    \      val resultList = List(result._1, result._2)\n        if (arr.isEmpty) {\n\
    \            resultList.filter(_ != 0)\n        } else {\n            resultList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpypn350f5.scala:34:37 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresultList\e[0m = List(result._1,\
    \ result._2)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              value _1 is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpypn350f5.scala:34:48 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresultList\e[0m = List(result._1,\
    \ result._2)\n\e[31m\e[31m   |\e[0m                                         ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        value _2 is not a\
    \ member of Long\n2 errors found\n"
  stdout: ''
  timestamp: 1659798986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(x => x % 2 ==\
    \ 0).sortBy(x => x)\n        val even = evens.head\n        val index = evens.indexOf(even)\n\
    \        val result = if (index == 0) even :: Nil else even :: index\n       \
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxxryptqm.scala:33:59 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mif\e\
    [0m (index == \e[31m0\e[0m) even :: Nil \e[33melse\e[0m even :: index\n\e[31m\e\
    [31m   |\e[0m                                                           ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                         value :: is not a\
    \ member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659798986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n    // your task is to pluck one of the nodes and return it.\n\
    \    // The plucked node should be the node with the smallest even value.\n  \
    \  // If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n    // The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    // If there are no even values or\
    \ the given array is empty, return [].\n    // Example 1:\n    // Input: [4,2,3]\n\
    \    // Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n    // Example 2:\n    // Input: [1,2,3]\n    //\
    \ Output: [2, 1]\n    // Explanation: 2 has the smallest even value, and 2 has\
    \ the smallest index. \n    // Example 3:\n    // Input: []\n    // Output: []\n\
    \    // Example 4:\n    // Input: [5, 0, 3, 0, 4, 2]\n    // Output: [0, 1]\n\
    \    // Explanation: 0 is the smallest value, but  there are two zeros,\n    //\
    \ so we will choose the first zero, which has the smallest index.\n    // Constraints:\n\
    \    // * 1 <= nodes.length <= 10000\n    // * 0 <= node.value\n    def pluck(arr\
    \ : List[Long]) : List[Long] = {\n        val evens = arr.filter(_ % 2 == 0).sortBy(_)\n\
    \        val even = evens.head\n        val index = arr.indexOf(even)\n      \
    \  val result = if (index == -1) Nil else List(even, index)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(pluck((List[Long](4l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong))).equals((List[Long](2l.toLong, 1l.toLong))));\n    assert(pluck((List[Long]())).equals((List[Long]())));\n\
    \    assert(pluck((List[Long](5l.toLong, 0l.toLong, 3l.toLong, 0l.toLong, 4l.toLong,\
    \ 2l.toLong))).equals((List[Long](0l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 0l.toLong, 5l.toLong, 3l.toLong))).equals((List[Long](0l.toLong,\
    \ 3l.toLong))));\n    assert(pluck((List[Long](5l.toLong, 4l.toLong, 8l.toLong,\
    \ 4l.toLong, 8l.toLong))).equals((List[Long](4l.toLong, 1l.toLong))));\n    assert(pluck((List[Long](7l.toLong,\
    \ 6l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long](6l.toLong, 1l.toLong))));\n\
    \    assert(pluck((List[Long](7l.toLong, 9l.toLong, 7l.toLong, 1l.toLong))).equals((List[Long]())));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpw3yte3_u.scala:30:52 -----------------------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mevens\e[0m = arr.filter(_\
    \ % \e[31m2\e[0m == \e[31m0\e[0m).sortBy(_)\n\e[31m\e[31m   |\e[0m           \
    \                                         ^\e[0m\n\e[31m   |\e[0mNo implicit Ordering\
    \ defined for Any..\n\e[31m   |\e[0mI found:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \    scala.math.Ordering.comparatorToOrdering[\e[35mAny\e[0m](\n\e[31m   |\e[0m\
    \      /* missing */summon[java.util.Comparator[Any]]\n\e[31m   |\e[0m    )\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mBut no implicit values were found that match type\
    \ java.util.Comparator[Any].\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw3yte3_u.scala:34:8\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Int])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659798986
