name: HumanEval_5_intersperse
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Insert a number 'delimeter' between every two consecutive elements of input\
  \ list `numbers'\n    // >>> intersperse([], 4)\n    // []\n    // >>> intersperse([1,\
  \ 2, 3], 4)\n    // [1, 4, 2, 4, 3]\n    def intersperse(numbers : List[Long], delimeter\
  \ : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()),\
  \ (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
  \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
  \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
  \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
  \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
completions: ["        val result = numbers.foldLeft(List[Long]())((acc, x) => acc\
    \ ++ x :: acc.take(acc.size - 1))\n        result.take(result.size - 1).reverse.foldLeft(List[Long]())((acc,\
    \ x) => acc ++ delimeter :: x :: acc)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => x :: acc)\n        val delimeters\
    \ = result.takeWhile(_ != delimeter)\n        val interspersedResult = delimeters.reverse.foldLeft(List[Long]())((acc,\
    \ x) => x :: acc)\n        interspersedResult ++ result.drop(delimeters.length)",
  "        val result = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach\
    \ { case (number, index) =>\n            if (index > 0) {\n                result.add(delimeter)\n\
    \            }\n            result.add(number)\n        }\n        result.toList",
  "        val result = new mutable.ListBuffer[Long]()\n        var i = 0\n      \
    \  while (i < numbers.size) {\n            result.append(numbers(i))\n       \
    \     result.append(delimeter)\n            result.append(numbers(i + 1))\n  \
    \          i += 1\n        }\n        result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => acc :+ elem + delimeter)\n        result.dropRight(1)", "        val\
    \ result = numbers.foldLeft(List[Long]())((acc, elem) => {\n            acc :+\
    \ elem\n            acc :+ delimeter\n        })\n        result :+ delimeter",
  "        val result = new mutable.ListBuffer[Long]()\n        var i = 0\n      \
    \  while (i < numbers.size) {\n            result += numbers.take(i).map(x =>\
    \ delimeter + x).drop(i)\n            i += numbers.size - 1\n        }\n     \
    \   result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => {\n            acc :+ elem\n            acc :+ delimeter\n        })\n\
    \        result", "        val result = new mutable.ListBuffer[Long]()\n     \
    \   numbers.foreach { number =>\n            result += number\n            result\
    \ += delimeter\n        }\n        result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach(x => result += x)\n\
    \        result ++ (numbers.take(numbers.size - 1).map(x => delimeter))", "  \
    \      val result = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter\
    \ + x)\n        result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => x :: acc)\n        result.takeWhile(_ != delimeter) ::: result.drop(1)",
  "        val result = new mutable.ListBuffer[Long]()\n        var i = 0\n      \
    \  while (i < numbers.size) {\n            result += numbers(i)\n            result\
    \ += delimeter\n            i += 1\n        }\n        result.toList", "     \
    \   val result = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter +\
    \ x)\n        result.dropRight(1)", "        val numbersWithDelimeter = numbers.map(n\
    \ => delimeter + n).reverse\n        numbersWithDelimeter.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ n)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => {\n            val newAcc = acc :+ elem\n            val newDelimeter\
    \ = delimeter :+ elem\n            intersperse(newAcc, newDelimeter)\n       \
    \ })\n        result.reverse", "        val numbers_copy = numbers.toList\n  \
    \      val result = new mutable.ListBuffer[Long]()\n        var i = 0\n      \
    \  while (i < numbers_copy.size) {\n            if (numbers_copy(i) == delimeter)\
    \ {\n                result.add(numbers_copy(i))\n                i += 1\n   \
    \         } else {\n                result.add(numbers_copy(i))\n            \
    \    i += 1\n                result.add(delimeter)\n            }\n        }\n\
    \        return result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => x :: acc)\n        val delimeters = result.takeWhile(_ != delimeter).map(x\
    \ => delimeter)\n        delimeters.reverse.foldLeft(result)((acc, x) => x ::\
    \ acc)"]
stop_tokens:
- "\n    }\n"
