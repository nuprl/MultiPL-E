name: HumanEval_9_rolling_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
  \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers :\
  \ List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
  \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
  \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
  \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
completions: ["        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        val result: List[Long] = new\
    \ mutable.ArrayBuffer[Long]()\n        for(x <- max.keySet) {\n            val\
    \ maxValue = max.get(x)\n            val currentIndex = numbers.indexOf(x)\n \
    \           if(currentIndex > 0) {\n                val lastValue = numbers(currentIndex\
    \ - 1)\n                if(maxValue > lastValue) {\n                    result.add(maxValue)\n\
    \                }\n            }\n        }\n        result", "        val max\
    \ = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => {\n            rollingMax.append(x)\n          \
    \  max.append(x)\n        })\n        rollingMax.foreach(x => {\n            if\
    \ (max.contains(x)) {\n                max.remove(x)\n                rollingMax.append(x)\n\
    \            }\n        })\n        rollingMax.toList", "        val result =\
    \ new mutable.ListBuffer[Long]()\n        var max = 0L\n        var maxIndex =\
    \ 0\n        var i = 0\n        while (i < numbers.length) {\n            max\
    \ = numbers(i)\n            while (i < numbers.length && numbers(i) <= max) {\n\
    \                i += 1\n            }\n            if (i < numbers.length) {\n\
    \                result.add(max)\n                maxIndex = i\n            }\n\
    \        }\n        result.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val maxKey = max.max.key\n\
    \            if (maxKey == null || n < maxKey) {\n                max.put(n, n)\n\
    \            } else {\n                val maxValue = max.max.value\n        \
    \        if (maxValue < n) {\n                    max.put(n, maxValue)\n     \
    \           } else {\n                    val maxKeyValue = max.max.key\n    \
    \                if (maxKeyValue < n) {\n                        max.put(maxKeyValue,\
    \ n)\n                    } else {\n                        max.put(n, maxValue)\n\
    \                    }\n                }\n            }\n        }\n        max.values.toList",
  "        val max = new mutable.ListBuffer[Long]()\n        val maxIndex = new mutable.ListBuffer[Int]()\n\
    \        numbers.foreach { number =>\n            if (number.toLong > max.last)\
    \ {\n                max += number\n                maxIndex += number\n     \
    \       }\n        }\n        val maxIndex = maxIndex.toList\n        val maxIndex\
    \ = maxIndex.sortWith(_ < _)\n        val maxIndex = maxIndex.drop(maxIndex.size\
    \ - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n       \
    \ val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex\
    \ = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size\
    \ - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n       \
    \ val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex\
    \ = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size\
    \ - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n       \
    \ val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex\
    \ = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size\
    \ - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n       \
    \ val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex\
    \ = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size\
    \ - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.size - ", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        val rollingMax = new mutable.ArrayList[Long]()\n\
    \        numbers.foreach { n =>\n            val maxKey = max.max(n) + n\n   \
    \         if (maxKey > rollingMax.last)\n                rollingMax.clear()\n\
    \            rollingMax.add(maxKey)\n            max.put(maxKey, maxKey)\n   \
    \     }\n        rollingMax.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax.clear()\n       \
    \     rollingMax.push(number)\n            rollingMax.foreach { rollingMax =>\n\
    \                val maxIndex = rollingMax.lastIndex\n                rollingMax.drop(maxIndex).foreach\
    \ { rollingMax =>\n                    rollingMax.lastOption.getOrElse(rollingMax.last).max(rollingMax.lastOption.getOrElse(rollingMax.last))\n\
    \                }\n            }\n        }\n        rollingMax.toList", "  \
    \      val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            val maxKey = max.max.key\n            if (maxKey == null ||\
    \ n > maxKey) {\n                max.put(n.toLong, n)\n            } else {\n\
    \                max.put(maxKey, n)\n            }\n        }\n        val result\
    \ = new mutable.ArrayList[Long]()\n        max.foreach { case (k, v) =>\n    \
    \        result += v\n        }\n        result", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            if (max.contains(n)) {\n\
    \                max += n\n            } else {\n                max += (n, Long.MaxValue)\n\
    \            }\n        }\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.foreach { case (k, v) =>\n            if (v > result.last) result\
    \ += v\n        }\n        result.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => {\n            rollingMax.append(x)\n            if (rollingMax.size > max.size)\
    \ {\n                max.clear()\n                max.append(rollingMax.max)\n\
    \                rollingMax.clear()\n            }\n        })\n        max.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            if (max.containsKey(n)) {\n                max.update(n, max(max(n),\
    \ n))\n            } else {\n                max.update(n, n)\n            }\n\
    \        }\n        max.values.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var maxValue = numbers(0)\n        numbers.foreach\
    \ { number =>\n            if (number > maxValue) {\n                maxValue\
    \ = number\n                maxIndex = 0\n            }\n            if (number\
    \ == maxValue) {\n                max += number\n                maxIndex += 1\n\
    \            }\n        }\n        max += maxValue\n        max.toList", "   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val max = number.max\n            max match {\n            \
    \    case Some(max) => max.foreach { max =>\n                    max.foreach {\
    \ max =>\n                        max.foreach { max =>\n                     \
    \       max.foreach { max =>\n                                max.foreach { max\
    \ =>\n                                    max.foreach { max =>\n             \
    \                           max.foreach { max =>\n                           \
    \                 max.foreach { max =>\n                                     \
    \           max.foreach { max =>\n                                           \
    \         max.foreach { max =>\n                                             \
    \           max.foreach { max =>\n                                           \
    \                 max.foreach { max =>\n                                     \
    \                           max.foreach { max =>\n                           \
    \                                         max.foreach { max =>\n             \
    \                                                           max.foreach { max\
    \ =>\n                                                                       \
    \     max.foreach { max =>\n                                                 \
    \                               max.foreach { max =>\n                       \
    \                                                             max.foreach { max\
    \ =>\n                                                                       \
    \                 max.foreach { max =>\n                                     \
    \                                                       max.foreach { max =>\n\
    \                                                                            \
    \                    max.foreach { max =>\n                                  \
    \                                                                  max.foreach\
    \ { max =>\n                                                                 \
    \                                       max.foreach { max =>\n               \
    \                                                                            \
    \                 max.foreach { max =>\n                                     \
    \                                                                           max.foreach\
    \ { max =>\n                                                                 \
    \                                                   max.foreach { max =>\n   \
    \                                                                            \
    \                                         max.foreach { max =>\n             \
    \                                                                            \
    \                                   max.foreach { max =>\n                   \
    \                                                                            \
    \                                 max.foreach { max =>\n                     \
    \                                                                            \
    \                                   max.foreach { max =>\n                   \
    \                                                                            \
    \                                         max.foreach { max =>\n             \
    \                                                                            \
    \                                                   max.foreach { max =>\n   \
    \                                                                            \
    \                                                                 max.foreach\
    \ { max =>\n                                                                 \
    \                                                                            \
    \       max.foreach { max =>\n                                               \
    \                                                                            \
    \                             max.foreach { max =>\n                         \
    \                                                                            \
    \                                                       max.foreach { max =>\n\
    \                                                                            \
    \                                                                            \
    \        max.foreach { max =>\n                                              \
    \                                                                            \
    \                                          max.foreach { max =>\n            \
    \                                                                            \
    \                                                                            \
    \    max.foreach { max =>\n                                                  \
    \                                                                            \
    \                                              max.foreach { max =>\n        \
    \                                                                            \
    \                                                                            \
    \                max.foreach { max =>\n                                      \
    \                                                                            \
    \                                                                  max.foreach\
    \ { max =>\n                                                                 \
    \                                                                            \
    \                                           max.foreach { max =>\n           \
    \                                                                            \
    \                                                                            \
    \                         max.foreach { max =>\n                             \
    \                                                                            \
    \                                                                            \
    \           max.foreach { max =>\n                                           \
    \                                                                            \
    \                                                                            \
    \ max.foreach { max =>\n                                                     \
    \                                                                            \
    \                                                                       max.foreach\
    \ { max =>\n                                                                 \
    \                                                                            \
    \                                                               max.foreach {\
    \ max =>\n                                                                   \
    \                                                                            \
    \                                                                 max.foreach\
    \ { max =>\n                                                                 \
    \                                                                            \
    \                                                                       max.foreach\
    \ { max =>\n                                                                 \
    \                                                                            \
    \                                                                           max.foreach\
    \ { max =>\n                                                                ",
  "        val max = new mutable.ListBuffer[Long]()\n        var maxIndex = 0\n  \
    \      var currentMax = 0L\n        var currentMaxIndex = 0\n        var currentMaxIndex2\
    \ = 0\n        var currentMaxIndex3 = 0\n        var currentMaxIndex4 = 0\n  \
    \      var currentMaxIndex5 = 0\n        var currentMaxIndex6 = 0\n        var\
    \ currentMaxIndex7 = 0\n        var currentMaxIndex8 = 0\n        var currentMaxIndex9\
    \ = 0\n        var currentMaxIndex10 = 0\n        var currentMaxIndex11 = 0\n\
    \        var currentMaxIndex12 = 0\n        var currentMaxIndex13 = 0\n      \
    \  var currentMaxIndex14 = 0\n        var currentMaxIndex15 = 0\n        var currentMaxIndex16\
    \ = 0\n        var currentMaxIndex17 = 0\n        var currentMaxIndex18 = 0\n\
    \        var currentMaxIndex19 = 0\n        var currentMaxIndex20 = 0\n      \
    \  var currentMaxIndex21 = 0\n        var currentMaxIndex22 = 0\n        var currentMaxIndex23\
    \ = 0\n        var currentMaxIndex24 = 0\n        var currentMaxIndex25 = 0\n\
    \        var currentMaxIndex26 = 0\n        var currentMaxIndex27 = 0\n      \
    \  var currentMaxIndex28 = 0\n        var currentMaxIndex29 = 0\n        var currentMaxIndex30\
    \ = 0\n        var currentMaxIndex31 = 0\n        var currentMaxIndex32 = 0\n\
    \        var currentMaxIndex33 = 0\n        var currentMaxIndex34 = 0\n      \
    \  var currentMaxIndex35 = 0\n        var currentMaxIndex36 = 0\n        var currentMaxIndex37\
    \ = 0\n        var currentMaxIndex38 = 0\n        var currentMaxIndex39 = 0\n\
    \        var currentMaxIndex40 = 0\n        var currentMaxIndex41 = 0\n      \
    \  var currentMaxIndex42 = 0\n        var currentMaxIndex43 = 0\n        var currentMaxIndex44\
    \ = 0\n        var currentMaxIndex45 = 0\n        var currentMaxIndex46 = 0\n\
    \        var currentMaxIndex47 = 0\n        var currentMaxIndex48 = 0\n      \
    \  var currentMaxIndex49 = 0\n        var currentMaxIndex50 = 0\n        var currentMaxIndex51\
    \ = 0\n        var currentMaxIndex52 = 0\n        var currentMaxIndex53 = 0\n\
    \        var currentMaxIndex54 = 0\n        var currentMaxIndex55 = 0\n      \
    \  var currentMaxIndex56 = 0\n        var currentMaxIndex57 = 0\n        var currentMaxIndex58\
    \ = 0\n        var currentMaxIndex59 = 0\n        var currentMaxIndex60 = 0\n\
    \        var currentMaxIndex61 = 0\n        var currentMaxIndex62 = 0\n      \
    \  var currentMaxIndex63 = 0\n        var currentMaxIndex64 = 0\n        var currentMaxIndex65\
    \ = 0\n        var currentMaxIndex66 = 0\n        var currentMaxIndex67 = 0\n\
    \        var currentMaxIndex68 = 0\n        var currentMaxIndex69 = 0\n      \
    \  var currentMaxIndex70 = 0", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        val rollingMaxIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach\
    \ { number =>\n            if (rollingMaxIndex.contains(number)) {\n         \
    \       rollingMax.updated(rollingMaxIndex.last, number)\n            } else {\n\
    \                rollingMax.updated(rollingMaxIndex.last, number)\n          \
    \      rollingMaxIndex += number\n            }\n        }\n        rollingMax.toList",
  "        val maxes = mutable.ArrayBuffer.empty[Long]\n        val maxesIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        numbers.foreach { number =>\n            val index = maxes.size\n   \
    \         maxes += number\n            maxesIndex += index\n        }\n      \
    \  val maxesIndex = maxesIndex.toList\n        val maxesSize = maxes.size\n  \
    \      val maxesIndex = maxesIndex.sortBy(-_)\n        val maxesSize = maxesIndex.size\n\
    \        val maxesIndex = maxesIndex.drop(maxesSize - maxesIndex.size)\n     \
    \   val maxesSize = maxesIndex.size\n        val maxesIndex = maxesIndex.drop(maxesSize\
    \ - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n        val maxesIndex\
    \ = maxesIndex.drop(maxesSize - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n\
    \        val maxesIndex = maxesIndex.drop(maxesSize - maxesIndex.size)\n     \
    \   val maxesSize = maxesIndex.size\n        val maxesIndex = maxesIndex.drop(maxesSize\
    \ - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n        val maxesIndex\
    \ = maxesIndex.drop(maxesSize - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n\
    \        val maxesIndex = maxesIndex.drop(maxesSize - maxesIndex.size)\n     \
    \   val maxesSize = maxesIndex.size\n        val maxesIndex = maxesIndex.drop(maxesSize\
    \ - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n        val maxesIndex\
    \ = maxesIndex.drop(maxesSize - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n\
    \        val maxesIndex = maxesIndex.drop(maxesSize - maxesIndex.size)\n     \
    \   val maxesSize = maxesIndex.size\n        val maxesIndex = maxesIndex.drop(maxesSize\
    \ - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n        val maxesIndex\
    \ = maxesIndex.drop(maxesSize - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n\
    \        val maxesIndex = maxesIndex.drop(maxesSize - maxesIndex.size)\n     \
    \   val maxesSize = maxesIndex.size\n        val maxesIndex = maxesIndex.", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, math.max(max.getOrElse(x, 0), x)))\n        max.values.toList",
  "        val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxIndex = maxes.indexWhere(_ > number)\n            if\
    \ (maxIndex == -1) {\n                maxes += number\n            } else {\n\
    \                maxes(maxIndex) = max(maxes(maxIndex), number)\n            }\n\
    \        }\n        maxes.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax.append(number)\n\
    \            rollingMax.lastOption\n                .foreach { rollingMax =>\n\
    \                    if (number > rollingMax) {\n                        rollingMax\
    \ = number\n                    }\n                }\n        }\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            val maxKey = max.minKey\n            if (maxKey == null ||\
    \ n < maxKey) {\n                max += n -> n\n            }\n        }\n   \
    \     val maxKeys = max.keySet\n        val maxValues = max.values\n        val\
    \ maxKeysAndValues = maxKeys.zip(maxValues)\n        val maxKeysAndValuesSorted\
    \ = maxKeysAndValues.sortBy(_._1).reverse\n        val maxKeysAndValuesSortedWithMax\
    \ = maxKeysAndValuesSorted.takeWhile(_._2 > 0)\n        val maxKeysAndValuesSortedWithMaxWithMax\
    \ = maxKeysAndValuesSortedWithMax.takeWhile(_._2 == maxKeysAndValuesSortedWithMax.last._2)\n\
    \        val maxKeysAndValuesSortedWithMaxWithMaxWithMax = maxKeysAndValuesSortedWithMaxWithMax.takeWhile(_._2\
    \ == maxKeysAndValuesSortedWithMaxWithMax.last._2)\n        val maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMax\
    \ = maxKeysAndValuesSortedWithMaxWithMaxWithMax.takeWhile(_._2 == maxKeysAndValuesSortedWithMaxWithMaxWithMax.last._2)\n\
    \        val maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMax = maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMax.takeWhile(_._2\
    \ == maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMax.last._2)\n        val\
    \ maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMaxWithMax = maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMax.takeWhile(_._2\
    \ == maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMax.last._2)\n    \
    \    val maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMaxWithMax = maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMax.takeWhile(_._2\
    \ == maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMax.last._2)\n    \
    \    val maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMaxWithMax = maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMaxWithMax.takeWhile(_._2\
    \ == maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMaxWithMax.last._2)\n\
    \        val maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMax", "        val\
    \ max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var rollingMaxIndex = 0\n        var currentMax\
    \ = 0L\n        var currentRollingMax = 0L\n        var currentMaxIndex = 0\n\
    \        numbers.foreach { number =>\n            if (number > currentMax) {\n\
    \                max.append(number)\n                maxIndex = number\n     \
    \           currentMax = number\n            }\n            if (number > currentRollingMax)\
    \ {\n                rollingMax.append(number)\n                rollingMaxIndex\
    \ = number\n                currentRollingMax = number\n            }\n      \
    \  }\n        max.append(currentMax)\n        rollingMax.append(currentRollingMax)\n\
    \        max.toList", "        val max = new mutable.HashMap[Long, Long]()\n \
    \       numbers.foreach(n => {\n            val maxKey = max.getOrElse(n, 0)\n\
    \            val maxValue = max.getOrElse(n, 0)\n            max.put(n, maxValue\
    \ + 1)\n        })\n        max.values.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val maxIndex = new mutable.ListBuffer[Int]()\n        numbers.foreach\
    \ { number =>\n            if (number.toLong > max.last) {\n                max\
    \ += number.toLong\n                maxIndex += 0\n            } else {\n    \
    \            max += number.toLong\n                maxIndex += 1 \n          \
    \  }\n        }\n        val maxIndex = maxIndex.toList\n        val maxIndex\
    \ = maxIndex.sortWith(_ < _)\n        val maxIndex = maxIndex.dropRight(1)\n \
    \       val maxIndex = maxIndex.takeRight(numbers.size)\n        val maxIndex\
    \ = maxIndex.zipWithIndex.map { case (number, index) => (number, index) }\n  \
    \      val maxIndex = maxIndex.toList\n        val maxIndex = maxIndex.sortWith(_._1\
    \ < _._1)\n        val maxIndex = maxIndex.dropRight(1)\n        val maxIndex\
    \ = maxIndex.takeRight(numbers.size)\n        val maxIndex = maxIndex.zipWithIndex.map\
    \ { case (number, index) => (number, index) }\n        val maxIndex = maxIndex.toList\n\
    \        val maxIndex = maxIndex.sortWith(_._1 < _._1)\n        val maxIndex =\
    \ maxIndex.dropRight(1)\n        val maxIndex = maxIndex.takeRight(numbers.size)\n\
    \        val maxIndex = maxIndex.zipWithIndex.map { case (number, index) => (number,\
    \ index) }\n        val maxIndex = maxIndex.toList\n        val maxIndex = maxIndex.sortWith(_._1\
    \ < _._1)\n        val maxIndex = maxIndex.dropRight(1)\n        val maxIndex\
    \ = maxIndex.takeRight(numbers.size)\n        val maxIndex = maxIndex.zipWithIndex.map\
    \ { case (number, index) => (number, index) }\n        val maxIndex = maxIndex.toList\n\
    \        val maxIndex = maxIndex.sortWith(_._1 < _._1)\n        val maxIndex =\
    \ maxIndex.dropRight(1)\n        val maxIndex = maxIndex.takeRight(numbers.size)\n\
    \        val maxIndex = maxIndex.zipWithIndex.map { case (number, index) => (number,\
    \ index) }\n        val maxIndex = maxIndex.toList\n        val maxIndex = maxIndex.sortWith(_._1\
    \ < _._1)\n        val maxIndex = maxIndex.dropRight(1)\n        val maxIndex\
    \ = maxIndex.takeRight(numbers.size)\n        val maxIndex = maxIndex.zipWithIndex.map\
    \ { case (number, index) => (number, index) }\n        ", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach(x => result.add(x))\
    \ // add all elements to result\n        val maxIndex = result.lastIndex\n   \
    \     val maxValue = result.last\n        result.drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(maxIndex).drop(",
  "        val result = new mutable.ListBuffer[Long]()\n        val rollingMax = numbers.foldLeft(0L)\
    \ { (max, element) =>\n            if (max < element) max else element\n     \
    \   }\n        val rollingMaxIndex = new mutable.ListBuffer[Int]()\n        val\
    \ rollingMaxIndexSize = new mutable.ListBuffer[Int]()\n        val rollingMaxIndexMax\
    \ = new mutable.ListBuffer[Int]()\n        val rollingMaxIndexMaxSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSize = new mutable.ListBuffer[Int]()\n    \
    \    val rollingMaxIndexMaxSizeSizeSize = new mutable.ListBuffer[Int]()\n    \
    \    val rollingMaxIndexMaxSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSizeSizeSizeSize = new mutable.ListBuffer[Int]()\n\
    \        val rollingMaxIndexMaxSizeSizeSizeSizeSizeSizeSizeSizeSize = new mutable.ListBuffer",
  "        val result = new mutable.ListBuffer[Long]()\n        numbers.foreach {\
    \ number =>\n            val maxIndex = numbers.indexWhere(_ > number)\n     \
    \       if (maxIndex < numbers.size) {\n                result.add(numbers(maxIndex))\n\
    \                numbers.remove(maxIndex)\n            }\n        }\n        result.toList",
  "        val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x =>\
    \ maxes += x)\n        numbers.reverse.foreach(x => maxes += x)\n        maxes.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, Math.max(max.getOrElse(x, 0), x)))\n        max.values.toList",
  "        val maxes = mutable.ListBuffer.empty[Long]\n        val maxesIndex = mutable.ListBuffer.empty[Int]\n\
    \        numbers.foreach { n =>\n            val maxIndex = maxes.indexWhere(x\
    \ => x > n)\n            if (maxIndex == -1) {\n                maxes += n\n \
    \               maxesIndex += 0\n            } else {\n                maxes(maxIndex)\
    \ = n\n                maxesIndex(maxIndex) = maxesIndex(maxIndex) + 1\n     \
    \       }\n        }\n        maxes.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { x =>\n            val max = x.getOrElse(max,\
    \ 0)\n            max.update(x, x + 1)\n        }\n        val maxList = max.toList.sortBy(_._1).reverse\n\
    \        val result: List[Long] = new mutable.ArrayBuffer[Long]()\n        val\
    \ current = new mutable.HashMap[Long, Long]()\n        numbers.foreach { x =>\n\
    \            val max = x.getOrElse(max, 0)\n            val current = current.getOrElse(x,\
    \ 0)\n            val rollingMax = maxList.take(current + max)\n            result\
    \ += rollingMax\n            current.update(x, current + max)\n        }\n   \
    \     result", "        val result = new mutable.ListBuffer[Long]()\n        val\
    \ rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach { number\
    \ =>\n            rollingMax.append(number)\n            if (rollingMax.size >\
    \ 1) {\n                val maxIndex = rollingMax.lastIndex\n                val\
    \ maxValue = rollingMax(maxIndex)\n                if (number > maxValue) {\n\
    \                    rollingMax.clear()\n                    rollingMax.append(number)\n\
    \                }\n            }\n        }\n        result.append(rollingMax.last)\n\
    \        result.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => {\n            rollingMax.append(x)\n          \
    \  rollingMax.append(rollingMax.max)\n        })\n        rollingMax.toList",
  "        val maxes = new mutable.ListBuffer[Long]()\n        var max = 0L\n    \
    \    var i = 0\n        while (i < numbers.length) {\n            if (numbers(i)\
    \ > max) {\n                max = numbers(i)\n            }\n            i +=\
    \ 1\n        }\n        maxes += max\n        while (i < numbers.length) {\n \
    \           if (numbers(i) > max) {\n                maxes += numbers(i)\n   \
    \         }\n            i += 1\n        }\n        maxes.toList", "        val\
    \ maxList = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n\
    \            val maxIndex = maxList.lastIndex\n            if (maxIndex == -1)\
    \ {\n                maxList += number\n            } else {\n               \
    \ maxList += maxList(maxIndex + 1)\n            }\n        }\n        maxList.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        val rollingMaxIndex\
    \ = mutable.ListBuffer.empty[Int]\n        val rollingMaxIndex = numbers.zipWithIndex.foreach\
    \ { case (number, index) =>\n            if (number > rollingMax(index)) {\n \
    \               rollingMax(index) = number\n                rollingMaxIndex(index)\
    \ = index\n            }\n        }\n        rollingMax.toList", "        val\
    \ max = new mutable.ListBuffer[Long]()\n        var maxIndex = 0\n        var\
    \ currentMax = 0L\n        var currentIndex = 0\n        numbers.foreach(x =>\
    \ {\n            if (currentIndex == maxIndex) {\n                max += currentMax\n\
    \                maxIndex += 1\n                currentMax = 0L\n            \
    \    currentIndex = 0\n            }\n            currentMax += x\n          \
    \  currentIndex += 1\n        })\n        max += currentMax\n        maxIndex\
    \ += 1\n        max.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        val maxesCount = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val maxIndex = maxes.indexWhere(x => x > number)\n\
    \            if (maxIndex >= 0) {\n                maxes(maxIndex) = number\n\
    \                maxesCount(maxIndex) = maxesCount(maxIndex) + 1\n           \
    \ } else {\n                maxes += number\n                maxesCount += number\n\
    \            }\n        }\n        val maxesCount = maxesCount.toList\n      \
    \  val maxesIndex = maxes.indexWhere(x => x == maxes.max)\n        val maxesCount\
    \ = maxesCount(maxesIndex)\n        val maxesCount = maxesCount.toLong\n     \
    \   val maxesIndex = maxes.indexWhere(x => x == maxes.max)\n        val maxesCount\
    \ = maxesCount(maxesIndex)\n        val maxesCount = maxesCount.toLong\n     \
    \   val maxesIndex = maxes.indexWhere(x => x == maxes.max)\n        val maxesCount\
    \ = maxesCount(maxesIndex)\n        val maxesCount = maxesCount.toLong\n     \
    \   val maxesIndex = maxes.indexWhere(x => x == maxes.max)\n        val maxesCount\
    \ = maxesCount(maxesIndex)\n        val maxesCount = maxesCount.toLong\n     \
    \   val maxesIndex = maxes.indexWhere(x => x == maxes.max)\n        val maxesCount\
    \ = maxesCount(maxesIndex)\n        val maxesCount = maxesCount.toLong\n     \
    \   val maxesIndex = maxes.indexWhere(x => x == maxes.max)\n        val maxesCount\
    \ = maxesCount(maxesIndex)\n        val maxesCount = maxesCount.toLong\n     \
    \   val maxesIndex = maxes.indexWhere(x => x == maxes.max)\n        val maxesCount\
    \ = maxesCount(maxesIndex)\n        val maxesCount = maxesCount.toLong\n     \
    \   val maxesIndex = maxes.indexWhere(x => x == maxes.max)\n        val maxesCount\
    \ = maxesCount(maxesIndex)\n        val maxesCount = maxesCount.toLong\n     \
    \   val maxesIndex = maxes.indexWhere(x => x == maxes.max)\n        val maxesCount\
    \ = maxesCount(maxesIndex)\n        val maxesCount = maxesCount.toLong\n     \
    \   val maxesIndex = maxes.indexWhere(x => x == maxes.max)\n        val maxesCount\
    \ = maxesCount(maxesIndex)\n        val maxesCount = max", "        val max =\
    \ new mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n        \
    \    val maxKey = max.keySet().toList.max\n            if (maxKey < n)\n     \
    \           max.put(maxKey, n)\n            else\n                max.put(n, maxKey)\n\
    \        }\n        max.values.toList", "        val maxes = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach\
    \ { number =>\n            rollingMax.append(number)\n            rollingMax.takeWhile(_\
    \ < number).foreach { max =>\n                maxes += max\n            }\n  \
    \      }\n        maxes", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach\
    \ { n =>\n            rollingMax.clear()\n            rollingMax.append (n)\n\
    \            rollingMax.foreach { m =>\n                if (m > max) {\n     \
    \               max = m\n                }\n            }\n        }\n       \
    \ rollingMax.toList", "        val max = new mutable.HashMap[Long, Long]()\n \
    \       numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n        max.values.toList",
  "        val result = new mutable.ListBuffer[Long]()\n        numbers.foreach {\
    \ number =>\n            val maxIndex = numbers.lastIndexWhere(x => x > number)\n\
    \            if (maxIndex == -1) result += number\n            else {\n      \
    \          val maxValue = numbers(maxIndex)\n                result += (maxValue\
    \ + number).max\n            }\n        }\n        result.toList", "        val\
    \ max = new mutable.ListBuffer[Long]()\n        numbers.foreach { n =>\n     \
    \       val maxIndex = max.indexOf(n)\n            if (maxIndex == -1) {\n   \
    \             max += n\n            } else {\n                max += max(maxIndex\
    \ + 1, n)\n            }\n        }\n        max.toList", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        val maxIndex = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            val maxValue = max.getOrElse(number,\
    \ 0L)\n            val maxIndex = maxIndex.getOrElse(number, 0L)\n           \
    \ val newMaxValue = number + maxValue\n            val newMaxIndex = number +\
    \ maxIndex\n            max.put(newMaxValue, newMaxValue)\n            maxIndex.put(newMaxIndex,\
    \ newMaxIndex)\n        }\n        val maxList = max.toList\n        val maxIndexList\
    \ = maxIndex.toList\n        val maxIndexListSize = maxIndexList.size\n      \
    \  val maxListSize = maxList.size\n        val maxListSize = maxListSize - maxIndexListSize\n\
    \        val maxListSize = maxListSize + 1\n        val maxListSize = maxListSize\
    \ * maxIndexListSize\n        val maxListSize = maxListSize * maxIndexListSize\n\
    \        val maxListSize = maxListSize * maxIndexListSize\n        val maxListSize\
    \ = maxListSize * maxIndexListSize\n        val maxListSize = maxListSize * maxIndexListSize\n\
    \        val maxListSize = maxListSize * maxIndexListSize\n        val maxListSize\
    \ = maxListSize * maxIndexListSize\n        val maxListSize = maxListSize * maxIndexListSize\n\
    \        val maxListSize = maxListSize * maxIndexListSize\n        val maxListSize\
    \ = maxListSize * maxIndexListSize\n        val maxListSize = maxListSize * maxIndexListSize\n\
    \        val maxListSize = maxListSize * maxIndexListSize\n        val maxListSize\
    \ = maxListSize * maxIndexListSize\n        val maxListSize = maxListSize * maxIndexListSize\n\
    \        val maxListSize = maxListSize * maxIndexListSize\n        val maxListSize\
    \ = maxListSize * maxIndexListSize\n        val maxListSize = maxListSize * maxIndexListSize\n\
    \        val maxListSize = maxListSize * maxIndexListSize\n        val maxListSize\
    \ = maxListSize * maxIndexListSize\n        val maxListSize = maxListSize * maxIndexListSize\n\
    \        val maxListSize = maxListSize * maxIndexListSize\n        val maxListSize\
    \ = maxListSize * maxIndexListSize\n        val maxListSize = maxListSize * maxIndexListSize\n\
    \        val maxListSize = maxListSize * maxIndexListSize\n        val maxListSize\
    \ = maxList", "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach\
    \ { n =>\n            val max = max.getOrElseUpdate(n, 0L)\n            max.update(n\
    \ + 1, Math.max(n, max.get(n) + 1))\n        }\n        val result: List[Long]\
    \ = new mutable.ListBuffer[Long]()\n        max.foreach { case (k, v) =>\n   \
    \         result.add(v)\n        }\n        result.toList", "        val max =\
    \ new mutable.HashMap[Long, Long]()\n        val maxes = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n    \
    \    max.foreach(x => maxes += x)\n        maxes.toList", "        val maxList\
    \ = mutable.ListBuffer[Long]()\n        numbers.foreach(x => maxList += x)\n \
    \       val maxIndex = maxList.indexOf(maxList.max)\n        val maxElement =\
    \ maxList.take(maxIndex).max\n        val maxList2 = maxList.drop(maxIndex).takeWhile(x\
    \ => x != maxElement)\n        numbers(maxIndex + 1) :: maxList2", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number =>\n\
    \            val max = number.toLong\n            val maxKey = max.toLong\n  \
    \          max.foreach { maxValue =>\n                val maxKey = maxValue.toLong\n\
    \                if (max.contains(maxKey)) {\n                    max.remove(maxKey)\n\
    \                } else {\n                    max.put(maxKey, maxValue)\n   \
    \             }\n            }\n        }\n        max.values.toList", "     \
    \   val max = new mutable.HashMap[Long, Long]()\n        val maxIndex = new mutable.HashMap[Long,\
    \ Int]()\n        numbers.foreach { n =>\n            val maxKey = max.keySet().toList.max\n\
    \            if (maxKey < n) {\n                max.put(n, maxKey)\n         \
    \       maxIndex.put(n, maxKey.toInt)\n            }\n        }\n        val maxList\
    \ = max.values.toList\n        val maxIndex = maxIndex.values.toList\n       \
    \ val maxIndex = maxIndex.zipWithIndex.map { case (v, i) => (v, i) }\n       \
    \ val maxIndex = maxIndex.sortBy(_._1).reverse\n        val maxIndex = maxIndex.map\
    \ { case (v, i) => (maxList(i), v) }\n        val maxIndex = maxIndex.map { case\
    \ (v, i) => (maxIndex(i), v) }\n        val maxIndex = maxIndex.map { case (v,\
    \ i) => (maxIndex(i), v) }\n        val maxIndex = maxIndex.map { case (v, i)\
    \ => (maxIndex(i), v) }\n        val maxIndex = maxIndex.map { case (v, i) =>\
    \ (maxIndex(i), v) }\n        val maxIndex = maxIndex.map { case (v, i) => (maxIndex(i),\
    \ v) }\n        val maxIndex = maxIndex.map { case (v, i) => (maxIndex(i), v)\
    \ }\n        val maxIndex = maxIndex.map { case (v, i) => (maxIndex(i), v) }\n\
    \        val maxIndex = maxIndex.map { case (v, i) => (maxIndex(i), v) }\n   \
    \     val maxIndex = maxIndex.map { case (v, i) => (maxIndex(i), v) }\n      \
    \  val maxIndex = maxIndex.map { case (v, i) => (maxIndex(i), v) }\n        val\
    \ maxIndex = maxIndex.map { case (v, i) => (maxIndex(i), v) }\n        val maxIndex\
    \ = maxIndex.map { case (v, i) => (maxIndex(i), v) }\n        val maxIndex = maxIndex.map\
    \ { case (v, i) => (maxIndex(i), v) }\n        val maxIndex = maxIndex.map { case\
    \ (v, i) => (maxIndex(i), v) }\n        val maxIndex = maxIndex.map { case (v,\
    \ i) => (maxIndex(i), v) }\n        val maxIndex = maxIndex.map { case (v, i)\
    \ => (maxIndex(i), v) }\n        val max", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            val maxIndex = numbers.lastIndexWhere(_\
    \ == number)\n            if (maxIndex > 0) {\n                result.add(numbers.apply(maxIndex))\n\
    \                numbers.drop(maxIndex + 1)\n            } else {\n          \
    \      result.add(number)\n            }\n        }\n        result.toList", " \
    \       val max = new mutable.ListBuffer[Long]()\n        val currentMax = numbers.head\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex\
    \ = numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n   \
    \     val currentMaxIndex = numbers.indexOf(0)\n        val currentMaxIndex =\
    \ numbers.indexOf(0)\n        val currentMaxIndex = numbers.indexOf(0)\n     \
    \   val currentMaxIndex = ", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        val rollingMaxIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach\
    \ { number =>\n            rollingMax.lastOption match {\n                case\
    \ None =>\n                    rollingMax.append (number)\n                  \
    \  rollingMaxIndex.append (0)\n                case Some(last) =>\n          \
    \          val index = rollingMaxIndex.last\n                    val newMax =\
    \ math.max(last, number)\n                    if (newMax > rollingMax(index))\
    \ {\n                        rollingMax.append (newMax)\n                    \
    \    rollingMaxIndex.append (index + 1)\n                    }\n            }\n\
    \        }\n        rollingMax.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0L\n        var i = 0\n        while (i < numbers.length) {\n\
    \            if (numbers(i) > max) {\n                max = numbers(i)\n     \
    \       }\n            i += 1\n        }\n        numbers.reverse.takeWhile(_\
    \ < max).reverse.foreach(maxes += max)\n        return maxes.toList", "      \
    \  val result = new mutable.ListBuffer[Long]()\n        var max = 0L\n       \
    \ var index = 0\n        numbers.foreach { n =>\n            if (n > max) {\n\
    \                max = n\n                index = numbers.indexOf(n)\n       \
    \     }\n        }\n        numbers.foreach { n =>\n            if (n == max)\
    \ {\n                result.add(numbers(index))\n            }\n        }\n  \
    \      result.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val maxList = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n        max.foreach { case (k,\
    \ v) => maxList += k }\n        maxList.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            if (max.containsKey(n))\
    \ {\n                max.update(n, max(n) + 1)\n            } else {\n       \
    \         max.put(n, 1L)\n            }\n        }\n        val maxList = new\
    \ mutable.ListBuffer[Long]()\n        for (n <- max.keys) {\n            val maxValue\
    \ = max(n)\n            while (maxValue > 0) {\n                maxList += n\n\
    \                maxValue -= 1\n            }\n        }\n        maxList.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        max.values.toList", "     \
    \   val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var rollingMaxIndex = 0\n        var currentMax\
    \ = 0L\n        var currentRollingMax = 0L\n        numbers.foreach(number =>\
    \ {\n            if (number > currentMax) {\n                max.append(number)\n\
    \                maxIndex = number\n            }\n            if (number > currentRollingMax)\
    \ {\n                rollingMax.append(number)\n                rollingMaxIndex\
    \ = number\n            }\n        })\n        max.reverse.foreach(number => {\n\
    \            if (number > currentMax) {\n                max.append(number)\n\
    \                maxIndex = number\n            }\n        })\n        rollingMax.reverse.foreach(number\
    \ => {\n            if (number > currentRollingMax) {\n                rollingMax.append(number)\n\
    \                rollingMaxIndex = number\n            }\n        })\n       \
    \ rollingMax.reverse.foreach(number => {\n            if (number > currentRollingMax)\
    \ {\n                rollingMax.append(number)\n                rollingMaxIndex\
    \ = number\n            }\n        })\n        rollingMax.reverse.foreach(number\
    \ => {\n            if (number > currentRollingMax) {\n                rollingMax.append(number)\n\
    \                rollingMaxIndex = number\n            }\n        })\n       \
    \ rollingMax.reverse.foreach(number => {\n            if (number > currentRollingMax)\
    \ {\n                rollingMax.append(number)\n                rollingMaxIndex\
    \ = number\n            }\n        })\n        rollingMax.reverse.foreach(number\
    \ => {\n            if (number > currentRollingMax) {\n                rollingMax.append(number)\n\
    \                rollingMaxIndex = number\n            }\n        })\n       \
    \ rollingMax.reverse.foreach(number => {\n            if (number > currentRollingMax)\
    \ {\n                rollingMax.append(number)\n                rollingMaxIndex\
    \ = number\n            }\n        })\n        rollingMax.reverse.foreach(number\
    \ => {\n            if (number > currentRollingMax) {\n                rollingMax.append(number)\n\
    \                rollingMaxIndex = number\n            }\n        })\n       \
    \ rollingMax.reverse.foreach(number => {\n            if (number > currentRollingMax)\
    \ {\n                rollingMax.append(number)\n                rollingMaxIndex\
    \ = number\n            }\n        })\n        rollingMax.reverse.foreach(number\
    \ => {\n            if (number > currentRollingMax) {\n                rollingMax.append(number)\n\
    \                rollingMaxIndex = number\n            }\n        })\n       \
    \ rollingMax.reverse.foreach(number => {\n            if (number > currentRollingMax)\
    \ {\n                rollingMax.append(number)\n                rollingMaxIndex\
    \ = number", "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach\
    \ { number =>\n            val max = number.max(max)\n        }\n        max.values.toList",
  "        val maxList = mutable.ListBuffer.empty[Long]\n        val maxIndex = mutable.ListBuffer.empty[Int]\n\
    \        numbers.foreach(x => {\n            if (maxList.size < x) {\n       \
    \         maxList += x\n                maxIndex += 0\n            } else {\n\
    \                val index = maxIndex.last\n                if (x > maxList(index))\
    \ {\n                    maxList += x\n                    maxIndex += index\n\
    \                }\n            }\n        })\n        maxList.toList", "    \
    \    val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x =>\
    \ max.put(x, max.getOrElse(x, 0) + x))\n        max.values.toList", "        val\
    \ result = new mutable.ListBuffer[Long]()\n        var max = 0L\n        var index\
    \ = 0\n        numbers.foreach{\n            x => {\n                if (x > max)\
    \ {\n                    max = x\n                }\n            }\n        }\n\
    \        numbers.foreach{\n            x => {\n                if (x == max) {\n\
    \                    result.add(max)\n                    index = 0\n        \
    \        } else {\n                    result.add(max)\n                    index\
    \ += 1\n                }\n            }\n        }\n        result.toList", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ number =>\n            val maxKey = math.max(number, max.getOrElse(number, 0))\n\
    \            max.put(number, maxKey)\n        }\n        val maxList = max.values.toList\n\
    \        val maxListWithMax = maxList.zip(maxList).map { case (max, max2) => max\
    \ max max2 }\n        val maxListWithMax2 = maxListWithMax.zip(maxListWithMax).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax3 = maxListWithMax2.zip(maxListWithMax2).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax4 = maxListWithMax3.zip(maxListWithMax3).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax5 = maxListWithMax4.zip(maxListWithMax4).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax6 = maxListWithMax5.zip(maxListWithMax5).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax7 = maxListWithMax6.zip(maxListWithMax6).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax8 = maxListWithMax7.zip(maxListWithMax7).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax9 = maxListWithMax8.zip(maxListWithMax8).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax10 = maxListWithMax9.zip(maxListWithMax9).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax11 = maxListWithMax10.zip(maxListWithMax10).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax12 = maxListWithMax11.zip(maxListWithMax11).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax13 = maxListWithMax12.zip(maxListWithMax12).map\
    \ { case (max, max2) => max max max2 }\n        val maxListWithMax14 = maxListWithMax13.zip(maxListWithMax13).map\
    \ { case (max, max2) => max max max2 }\n        ", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxes = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => max.put(x, max(x.getOrElse(x, 0L) + 1)));\n        max.foreach { case (k,\
    \ v) => maxes += k }\n        maxes", "        val rollingMax = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => rollingMax.append(x))\n        rollingMax.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        val rollingMaxIndex\
    \ = mutable.ListBuffer.empty[Int]\n        numbers.foreach { number =>\n     \
    \       rollingMax.synchronized {\n                if (rollingMax.size < number)\
    \ {\n                    rollingMax.clear()\n                    rollingMaxIndex.clear()\n\
    \                }\n                rollingMax.synchronized {\n              \
    \      rollingMax.append(number)\n                    rollingMaxIndex.append(number)\n\
    \                }\n            }\n        }\n        rollingMax.synchronized\
    \ {\n            rollingMax.sortWith(_ < _)\n        }\n        rollingMax.synchronized\
    \ {\n            rollingMax.take(rollingMaxIndex.size)\n        }", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number =>\n\
    \            val maxKey = number.toLong\n            val maxValue = max.getOrElse(maxKey,\
    \ 0L)\n            val newMaxValue = maxValue + number\n            max.put(maxKey,\
    \ newMaxValue)\n        }\n        max.values.toList", "        val max = new\
    \ mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        val rollingMaxIndex = new mutable.ListBuffer[Int]()\n        numbers.foreach(number\
    \ => {\n            if (rollingMaxIndex.size < rollingMax.size) {\n          \
    \      rollingMax.append(number)\n                rollingMaxIndex.append(0)\n\
    \            } else {\n                val index = rollingMaxIndex.last\n    \
    \            if (number > rollingMax(index)) {\n                    rollingMax.append(number)\n\
    \                    rollingMaxIndex.append(index)\n                }\n      \
    \      }\n        })\n        rollingMax.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var maxValue = numbers(0)\n        numbers.foreach\
    \ { n =>\n            if (maxValue < n) maxValue = n\n            if (maxIndex\
    \ < maxValue) maxIndex += 1\n            else {\n                max.append(maxValue)\n\
    \                maxIndex = 1\n            }\n        }\n        max.append(maxValue)\n\
    \        max.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0L\n        var index = 0\n        numbers.foreach { number\
    \ =>\n            if (number > max) {\n                max = number\n        \
    \        index = rollingMax.size\n            }\n            rollingMax.append(number)\n\
    \        }\n        rollingMax.take(index).reverse", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxList = new mutable.ArrayList[Long]()\n        numbers.foreach\
    \ { n =>\n            val maxKey = max(n, n)\n            max.put(maxKey, max(n,\
    \ n))\n            maxList += maxKey\n        }\n        maxList.toList", "  \
    \      val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { n\
    \ =>\n            val maxIndex = maxes.indexWhere(x => x > n)\n            if\
    \ (maxIndex >= 0) {\n                maxes(maxIndex) = n\n            } else {\n\
    \                maxes += n\n            }\n        }\n        maxes.toList",
  "        val rolling_max = mutable.ArrayBuffer.empty[Long]\n        var max_rolling_max\
    \ = 0L\n        var max_rolling_max_index = 0\n        var max_rolling_max_index2\
    \ = 0\n        var max_rolling_max_index3 = 0\n        var max_rolling_max_index4\
    \ = 0\n        var max_rolling_max_index5 = 0\n        var max_rolling_max_index6\
    \ = 0\n        var max_rolling_max_index7 = 0\n        var max_rolling_max_index8\
    \ = 0\n        var max_rolling_max_index9 = 0\n        var max_rolling_max_index10\
    \ = 0\n        var max_rolling_max_index11 = 0\n        var max_rolling_max_index12\
    \ = 0\n        var max_rolling_max_index13 = 0\n        var max_rolling_max_index14\
    \ = 0\n        var max_rolling_max_index15 = 0\n        var max_rolling_max_index16\
    \ = 0\n        var max_rolling_max_index17 = 0\n        var max_rolling_max_index18\
    \ = 0\n        var max_rolling_max_index19 = 0\n        var max_rolling_max_index20\
    \ = 0\n        var max_rolling_max_index21 = 0\n        var max_rolling_max_index22\
    \ = 0\n        var max_rolling_max_index23 = 0\n        var max_rolling_max_index24\
    \ = 0\n        var max_rolling_max_index25 = 0\n        var max_rolling_max_index26\
    \ = 0\n        var max_rolling_max_index27 = 0\n        var max_rolling_max_index28\
    \ = 0\n        var max_rolling_max_index29 = 0\n        var max_rolling_max_index30\
    \ = 0\n        var max_rolling_max_index31 = 0\n        var max_rolling_max_index32\
    \ = 0\n        var max_rolling_max_index33 = 0\n        var max_rolling_max_index34\
    \ = 0\n        var max_rolling_max_index35 = 0\n        var max_rolling_max_index36\
    \ = 0\n        var max_rolling_max_index37 = 0\n        var max_rolling_max_index38\
    \ = 0\n        var max_rolling_max_index39 = 0\n        var max_rolling_max_index40\
    \ = 0\n        var max_rolling_max_index41 = 0\n        var max_rolling_max_index42\
    \ = 0\n        var max_rolling_max_index43 = 0\n        var max_rolling_max_index44\
    \ = 0\n        var max_rolling_max_index45 = 0\n        var max_rolling_max_index46\
    \ = 0\n        var max_rolling_max_index47 = 0\n        var max_rolling_max_index48\
    \ = 0\n        var max_rolling_max_index49 = 0\n        var max_rolling_max_index50\
    \ = 0\n        var max_rolling_max_index51 = 0\n        var max_rolling_max_index52\
    \ = 0\n        var max_rolling_max_index53 = 0\n        var max_rolling_max_index54\
    \ = 0\n        var max_rolling_max_", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var max = 0L\n        var index = 0\n        while(index < numbers.length)\
    \ {\n            max = numbers(index)\n            while(max > numbers(index))\
    \ {\n                max -= numbers(index)\n                index += 1\n     \
    \       }\n            result += max\n        }\n        result.toList", "   \
    \     val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        val rollingMaxIndex = new mutable.ListBuffer[Int]()\n        numbers.foreach\
    \ { x =>\n            if (max.length < rollingMaxIndex.length) {\n           \
    \     max += x\n                rollingMaxIndex += 0\n                rollingMax\
    \ += x\n            } else {\n                val index = rollingMaxIndex.last\n\
    \                if (x > max.last) {\n                    max += x\n         \
    \           rollingMaxIndex += index\n                    rollingMax += x\n  \
    \              } else {\n                    rollingMaxIndex += index\n      \
    \              rollingMax += x\n                }\n            }\n        }\n\
    \        rollingMax.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(n => {\n            val maxIndex = maxes.lastIndex\n\
    \            if (maxIndex == -1) {\n                maxes += n\n            }\
    \ else {\n                maxes += maxes.get(maxIndex) + n\n            }\n  \
    \      })\n        maxes.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(n => {\n            val maxKey = max.getOrElseUpdate(n,\
    \ 0L)\n            if (maxKey > n) max.put(n, maxKey)\n        })\n        max.values.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            rollingMax.clear()\n            rollingMax.append (number)\n\
    \            rollingMax.foreach { rollingMax =>\n                if (rollingMax.max()\
    \ < number) {\n                    rollingMax.clear()\n                    rollingMax.append\
    \ (number)\n                }\n            }\n        }\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val maxList = new\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach(x => max.put(x, max(x.getOrElse(x,\
    \ 0L) + 1)));\n        max.foreach {\n            case (k, v) => maxList += k\n\
    \        }\n        maxList.toList", "        val maxes = mutable.ArrayBuffer.empty[Long]\n\
    \        val maxesIndex = 0\n        numbers.foreach { number =>\n           \
    \ if (number > maxes.get(maxesIndex)) {\n                maxes += number\n   \
    \             maxesIndex += 1\n            }\n        }\n        maxes", "   \
    \     val maxes = mutable.ArrayBuffer.empty[Long]\n        numbers.foreach(x =>\
    \ maxes += x)\n        val maxesList = maxes.toList\n        val maxesListLength\
    \ = maxesList.length\n        val maxesListLength = maxesListLength - 1\n    \
    \    val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1", "        val max = new mutable.ListBuffer[Long]()\n  \
    \      val maxIndex = new mutable.ListBuffer[Int]()\n        numbers.foreach {\
    \ number =>\n            val index = numbers.indexOf(number)\n            if (index\
    \ > maxIndex.last)\n                maxIndex += index\n            if (index ==\
    \ maxIndex.last)\n                max += number\n        }\n        max.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val rollingMaxIndex = rollingMax.lastIndex\n      \
    \      rollingMax.updated(rollingMaxIndex + 1, number)\n        }\n        rollingMax.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        val rollingMaxIndex\
    \ = mutable.ListBuffer.empty[Int]\n        numbers.foreach { number =>\n     \
    \       rollingMax.lastOption match {\n                case None =>\n        \
    \            rollingMax.append(number)\n                    rollingMaxIndex.append(0)\n\
    \                case Some(max) =>\n                    rollingMax.append(max)\n\
    \                    rollingMaxIndex.append(rollingMaxIndex.lastOption.getOrElse(0)\
    \ + 1)\n            }\n        }\n        rollingMax.toList", "        val max\
    \ = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => {\n            if (max.size > 0) {\n           \
    \     max.lastOption match {\n                    case Some(x) => rollingMax.append(x)\n\
    \                    case None => rollingMax.append(x)\n                }\n  \
    \          } else {\n                rollingMax.append(x)\n            }\n   \
    \     })\n        rollingMax.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            val max = number max number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number\n            max += number\n            max += number\n\
    \            max += number", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0L\n        var maxIndex = 0L\n        var i = 0L\n       \
    \ while (i < numbers.length) {\n            if (numbers(i) > max) {\n        \
    \        max = numbers(i)\n                maxIndex = i\n            }\n     \
    \       i += 1\n        }\n        rollingMax.clear()\n        rollingMax.add(maxIndex)\n\
    \        rollingMax.add(max)\n        rollingMax", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val rollingMax = new mutable.ArrayList[Long]()\n        numbers.foreach(x\
    \ => {\n            val max = max.getOrElse(x, 0)\n            val rollingMax\
    \ = rollingMax.getOrElse(x, new mutable.ArrayList[Long]())\n            rollingMax.add(max)\n\
    \        })\n        rollingMax.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(x => maxes += x)\n        val maxesList = maxes.toList\n\
    \        val maxesListSize = maxesList.length\n        val maxesListIterator =\
    \ maxesList.iterator\n        val maxesListIteratorSize = maxesListIterator.size\n\
    \        val maxesListIteratorIndex = maxesListIterator.index\n        val maxesListIteratorIndexSize\
    \ = maxesListIteratorIndex.size\n        val maxesListIteratorIndexValue = maxesListIteratorIndex.value\n\
    \        val maxesListIteratorIndexValueSize = maxesListIteratorIndexValue.size\n\
    \        val maxesListIteratorIndexValueValue = maxesListIteratorIndexValue.value\n\
    \        val maxesListIteratorIndexValueValueSize = maxesListIteratorIndexValueValue.size\n\
    \        val maxesListIteratorIndexValueValueValue = maxesListIteratorIndexValueValue.value\n\
    \        val maxesListIteratorIndexValueValueValueSize = maxesListIteratorIndexValueValueValue.size\n\
    \        val maxesListIteratorIndexValueValueValueValue = maxesListIteratorIndexValueValueValue.value\n\
    \        val maxesListIteratorIndexValueValueValueSize = maxesListIteratorIndexValueValueValueValue.size\n\
    \        val maxesListIteratorIndexValueValueValueValue = maxesListIteratorIndexValueValueValueValue.value\n\
    \        val maxesListIteratorIndexValueValueValueValueSize = maxesListIteratorIndexValueValueValueValueValue.size\n\
    \        val maxesListIteratorIndexValueValueValueValueValue = maxesListIteratorIndexValueValueValueValueValue.value\n\
    \        val maxesListIteratorIndexValueValueValueValueSize = maxesListIteratorIndexValueValueValueValueValue.size\n\
    \        val maxesListIteratorIndexValueValueValueValueValue = maxesListIteratorIndexValueValueValueValueValue.value\n\
    \        val maxesListIteratorIndexValueValueValueValueSize = maxesListIteratorIndexValueValueValueValueValueValue.size\n\
    \        val maxesListIteratorIndexValueValueValueValueValueValue = maxesListIteratorIndexValueValueValueValueValueValue.value\n\
    \        val maxesListIteratorIndexValueValueValueValueValueSize = maxesListIteratorIndexValueValueValueValueValueValueValue.size\n\
    \        val maxesListIteratorIndexValueValueValueValueValueValue = maxesListIteratorIndexValueValueValueValueValueValueValue.value\n\
    \        val maxesListIteratorIndexValueValueValueValueValueSize = maxesListIteratorIndexValueValueValueValueValueValueValue.size\n\
    \        val maxesListIteratorIndexValueValueValueValue", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n            if\
    \ (max.containsKey(n)) {\n                max += (n, max(n))\n            } else\
    \ {\n                max += (n, n)\n            }\n        }\n        val result\
    \ = new mutable.ArrayList[Long]()\n        max.values.foreach { n =>\n       \
    \     if (n > result.last) result += n\n        }\n        result", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n  \
    \          val max = max.getOrElseUpdate(n, 0L)\n            val cur = max.getOrElse(n,\
    \ 0)\n            max.put(n, cur + n)\n        }\n        val res = new mutable.ArrayList[Long]()\n\
    \        max.foreach { case (k, v) =>\n            res += v\n        }\n     \
    \   res", "        val max = new mutable.HashMap[Long, Long]()\n        val rollingMax\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach { n =>\n         \
    \   if (max.contains(n)) {\n                rollingMax += max(n)\n           \
    \ }\n            else {\n                max += (n, n)\n                rollingMax\
    \ += n\n            }\n        }\n        rollingMax.toList", "        val maxes\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n    \
    \        val maxIndex = maxes.indexWhere(x => x > number)\n            if (maxIndex\
    \ < 0) maxes += number\n            else maxes(maxIndex) = max(maxes(maxIndex),\
    \ number)\n        }\n        maxes.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val rollingMax = new mutable.ArrayList[Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        max.values.foreach(x => rollingMax.add(x))\n\
    \        rollingMax.toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var max = 0L\n        var index = 0\n        while(index < numbers.length)\
    \ {\n            max = numbers(index)\n            while(max > numbers(index))\
    \ {\n                max -= numbers(index)\n                index += 1\n     \
    \       }\n            result.add(max)\n        }\n        return result.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val maxIndex = rollingMax.lastIndex\n            rollingMax.updated(maxIndex\
    \ + 1, number)\n        }\n        rollingMax.toList", "        val max = new\
    \ mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => {\n            rollingMax.append(x)\n          \
    \  max.append(x)\n        })\n        rollingMax.foreach(x => {\n            max.remove(x)\n\
    \        })\n        max.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            val max = number.max(max)\n\
    \        }\n        max.values.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var maxValue = numbers(0)\n        numbers.foreach(x\
    \ => {\n            if (x > maxValue) {\n                maxValue = x\n      \
    \          maxIndex = 0\n            }\n            if (x == maxValue) {\n   \
    \             max.append(x)\n                maxIndex += 1\n            }\n  \
    \      })\n        max.reverse", "        val max = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var maxValue = numbers(0)\n        var index\
    \ = 0\n        while (index < numbers.size) {\n            if (numbers(index)\
    \ > maxValue) {\n                maxValue = numbers(index)\n                maxIndex\
    \ = index\n            }\n            index += 1\n        }\n        max += maxValue\n\
    \        val maxIndex = maxIndex + 1\n        var index = 0\n        while (index\
    \ < numbers.size) {\n            if (numbers(index) > maxValue) {\n          \
    \      maxValue = numbers(index)\n                maxIndex = index\n         \
    \   }\n            index += 1\n        }\n        max += maxValue\n        val\
    \ maxIndex = maxIndex + 1\n        var index = 0\n        while (index < numbers.size)\
    \ {\n            if (numbers(index) > maxValue) {\n                maxValue =\
    \ numbers(index)\n                maxIndex = index\n            }\n          \
    \  index += 1\n        }\n        max += maxValue\n        val maxIndex = maxIndex\
    \ + 1\n        var index = 0\n        while (index < numbers.size) {\n       \
    \     if (numbers(index) > maxValue) {\n                maxValue = numbers(index)\n\
    \                maxIndex = index\n            }\n            index += 1\n   \
    \     }\n        max += maxValue\n        val maxIndex = maxIndex + 1\n      \
    \  var index = 0\n        while (index < numbers.size) {\n            if (numbers(index)\
    \ > maxValue) {\n                maxValue = numbers(index)\n                maxIndex\
    \ = index\n            }\n            index += 1\n        }\n        max += maxValue\n\
    \        val maxIndex = maxIndex + 1\n        var index = 0\n        while (index\
    \ < numbers.size) {\n            if (numbers(index) > maxValue) {\n          \
    \      maxValue = numbers(index)\n                maxIndex = index\n         \
    \   }\n            index += 1\n        }\n        max += maxValue\n        val\
    \ maxIndex = maxIndex + 1\n        var index = 0\n        while (index < numbers.size)\
    \ {\n            if (numbers(index) > maxValue) {\n                maxValue =\
    \ numbers(index)\n                maxIndex = index\n            }\n          \
    \  index += 1\n        }\n        max += maxValue\n        val maxIndex = maxIndex\
    \ + 1\n        var index = 0\n        while (index < numbers.size) {\n       \
    \     if (numbers(index) > maxValue) {\n                maxValue = numbers(index)\n\
    \                maxIndex = index\n            }\n            index += 1\n   \
    \     }\n        max += maxValue\n        val maxIndex = maxIndex + 1\n      \
    \  var index = 0\n        while (index < numbers.size) {\n            if (numbers(index)\
    \ > maxValue) {\n                maxValue = numbers(index)\n                maxIndex\
    \ = index\n            }\n            index += 1\n        }\n        max += maxValue\n\
    \        val maxIndex = maxIndex + 1\n        var index = 0\n        while (index\
    \ < numbers.size) {\n            if (numbers(index) > maxValue) {\n          \
    \      ", "        val max = new mutable.HashMap[Long, Long]()\n        val maxIndex\
    \ = new mutable.HashMap[Long, Int]()\n        val maxIndexMap = new mutable.HashMap[Int,\
    \ Int]()\n        numbers.foreach { n =>\n            if (max.containsKey(n))\
    \ {\n                val maxValue = max.get(n)\n                val maxIndexValue\
    \ = maxIndex.get(n)\n                val maxIndexMapValue = maxIndexMap.get(n)\n\
    \                if (maxValue > n) {\n                    max.put(n, n)\n    \
    \                maxIndex.put(n, maxIndexValue + 1)\n                    maxIndexMap.put(maxIndexValue,\
    \ maxIndexMapValue + 1)\n                } else {\n                    max.put(n,\
    \ maxValue)\n                    maxIndex.put(n, maxIndexValue + 1)\n        \
    \            maxIndexMap.put(maxIndexValue, maxIndexMapValue + 1)\n          \
    \      }\n            } else {\n                max.put(n, n)\n              \
    \  maxIndex.put(n, 0)\n                maxIndexMap.put(0, 0)\n            }\n\
    \        }\n        val maxList = new mutable.ArrayList[Long]()\n        val maxIndexList\
    \ = new mutable.ArrayList[Int]()\n        val maxIndexMapList = new mutable.ArrayList[Int]()\n\
    \        max.foreach { case (k, v) =>\n            val maxIndex = maxIndexMap.get(k)\n\
    \            val maxIndexList = maxIndexList.add(maxIndex)\n            val maxIndexMapList\
    \ = maxIndexMapList.add(maxIndexMap.get(k))\n            val maxValue = v\n  \
    \          val maxListValue = maxList.getOrElse(maxIndex, 0)\n            if (maxValue\
    \ > maxListValue) {\n                maxList.put(maxIndex, v)\n              \
    \  maxIndexMap.put(maxIndexMap.get(k), maxIndexMap.get(k) + 1)\n            }\
    \ else {\n                maxList.put(maxIndex, maxListValue)\n              \
    \  maxIndexMap.put(maxIndexMap.get(k), maxIndexMap.get(k) + 1)\n            }\n\
    \        }\n        maxList.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach\
    \ { x =>\n            max.append(x)\n            if (max.size > rollingMax.size)\
    \ {\n                rollingMax.clear()\n                rollingMax.append(max.max)\n\
    \                max.clear()\n            }\n            rollingMax.append(x)\n\
    \        }\n        rollingMax.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0L\n        var sum = 0L\n        var i = 0\n        while\
    \ (i < numbers.length) {\n            val current = numbers(i)\n            if\
    \ (current > max) {\n                max = current\n            }\n          \
    \  sum += current\n            i += 1\n        }\n        val rollingMax = numbers.takeWhile(_\
    \ < sum).reverse.takeWhile(_ > max).reverse\n        rollingMax.foreach(maxes\
    \ += max)\n        return maxes", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        val maxNumber = numbers.head\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = numbers.last\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxValue = ", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        val maxNumber = numbers.head\n        val maxIndex = numbers.indexOf(0)\n\
    \        val maxIndex = maxIndex + 1\n        while(maxIndex < numbers.size) {\n\
    \            val maxValue = numbers.last\n            val maxIndex = numbers.indexOf(maxValue)\n\
    \            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val maxIndex = maxIndex + 1\n            val maxIndex = maxIndex\
    \ + 1\n            val max", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val rollingMax = new mutable.ArrayList[Long]()\n        numbers.foreach(x\
    \ => {\n            val max = x.getOrElse(-1L).max(max)\n            rollingMax.add(max)\n\
    \        })\n        rollingMax.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        val rollingMaxIndex\
    \ = new mutable.ListBuffer[Int]()\n        numbers.foreach(x => {\n          \
    \  rollingMaxIndex += 1;\n            rollingMax.append(x)\n            if (rollingMaxIndex.size\
    \ == numbers.size) {\n                if (rollingMax.max > max.last) {\n     \
    \               max.append(rollingMax.max)\n                }\n              \
    \  rollingMax.clear()\n                rollingMaxIndex.clear()\n            }\n\
    \        })\n        max.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n\
    \        val maxes = max.toList.sortBy(_._2)\n        val maxesList = maxes.map(x\
    \ => x._1)\n        val rollingMax = maxesList.takeWhile(_ < numbers(numbers.size))\n\
    \        rollingMax.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0L\n        var index = 0\n        numbers.foreach { n =>\n\
    \            if (n > max) {\n                max = n\n                maxes +=\
    \ max\n            }\n            if (n == max) {\n                maxes += n\n\
    \            }\n        }\n        maxes", "        val rollingMax = mutable.ListBuffer[Long]()\n\
    \        val rollingMaxIndex = mutable.ListBuffer[Int]()\n        val rollingMaxIndexSize\
    \ = mutable.ListBuffer[Int]()\n        numbers.foreach { number =>\n         \
    \   rollingMax.append(number)\n            rollingMaxIndex.append(0)\n       \
    \     rollingMaxIndexSize += rollingMaxIndex.last\n        }\n        rollingMaxIndex.foreach\
    \ { index =>\n            rollingMaxIndexSize -= 1\n            rollingMaxIndex\
    \ += rollingMaxIndexSize\n        }\n        rollingMax.foreach { number =>\n\
    \            rollingMaxIndex.foreach { index =>\n                if (number >\
    \ rollingMax(index)) {\n                    rollingMax(index) = number\n     \
    \           }\n            }\n        }\n        rollingMax.toList", "       \
    \ val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val rollingMaxElement = rollingMax.last\n            rollingMax.append(rollingMaxElement)\n\
    \            rollingMax.append(number)\n        }\n        rollingMax.toList",
  "        val rolling_max_list = mutable.ListBuffer[Long]()\n        val rolling_max_list_size\
    \ = numbers.size\n        val rolling_max_list_index = numbers.size - 1\n    \
    \    numbers.reverse.foreach(x => {\n            rolling_max_list += x\n     \
    \       rolling_max_list_index -= 1\n            if (rolling_max_list_index ==\
    \ 0) {\n                rolling_max_list += rolling_max_list.last\n          \
    \      rolling_max_list_index -= 1\n            }\n        })\n        rolling_max_list.reverse",
  "        val max = new mutable.ListBuffer[Long]()\n        var maxIndex = 0\n  \
    \      var currentMax = numbers(0)\n        numbers.foreach { number =>\n    \
    \        if (number > currentMax) {\n                maxIndex += 1\n         \
    \       currentMax = number\n            }\n            max.append(number)\n \
    \       }\n        max.reverse", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val max = max.getOrElseUpdate(n,\
    \ 0L)\n            val curMax = max.getOrElseUpdate(n, 0)\n            max.update(n,\
    \ curMax + 1)\n        }\n        max.values.toList", "        val maxList = mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            val maxIndex = maxList.lastIndex\n\
    \            val maxValue = maxList(maxIndex)\n            if (number > maxValue)\
    \ {\n                maxList += number\n            }\n        }\n        maxList.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        var max = 0L\n\
    \        var index = 0\n        numbers.foreach{ n =>\n            max = math.max(max,\
    \ n)\n            rollingMax.append(max)\n            index += 1\n           \
    \ if (index > numbers.size) {\n                rollingMax.clear()\n          \
    \      index = 0\n            }\n        }\n        rollingMax.toList", "    \
    \    val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var rollingMaxIndex = 0\n        var currentMax\
    \ = 0L\n        var currentRollingMax = 0L\n        var currentMaxIndex = 0\n\
    \        var currentRollingMaxIndex = 0\n        var currentMaxIndex = 0\n   \
    \     var currentRollingMaxIndex = 0\n        numbers.foreach { number =>\n  \
    \          if (number > currentMax) {\n                max.clear()\n         \
    \       rollingMax.clear()\n                max.append(number)\n             \
    \   rollingMax.append(currentRollingMax)\n                maxIndex = currentMaxIndex\n\
    \                rollingMaxIndex = currentRollingMaxIndex\n                currentMax\
    \ = number\n                currentRollingMax = number\n                currentMaxIndex\
    \ = number\n                currentRollingMaxIndex = number\n            } else\
    \ if (number > currentRollingMax) {\n                max.clear()\n           \
    \     rollingMax.clear()\n                max.append(number)\n               \
    \ rollingMax.append(currentRollingMax)\n                maxIndex = currentMaxIndex\n\
    \                rollingMaxIndex = currentRollingMaxIndex\n                currentMax\
    \ = number\n                currentRollingMax = number\n                currentMaxIndex\
    \ = number\n                currentRollingMaxIndex = number\n                currentRollingMax\
    \ = number\n            } else if (number == currentMax) {\n                max.append(number)\n\
    \                rollingMax.append(currentRollingMax)\n                maxIndex\
    \ = currentMaxIndex\n                rollingMaxIndex = currentRollingMaxIndex\n\
    \                currentMax = number\n                currentRollingMax = number\n\
    \                currentMaxIndex = number\n                currentRollingMaxIndex\
    \ = number\n            } else if (number == currentRollingMax) {\n          \
    \      max.append(number)\n                rollingMax.append(currentRollingMax)\n\
    \                maxIndex = currentMaxIndex\n                rollingMaxIndex =\
    \ currentRollingMaxIndex\n                currentMax = number\n              \
    \  currentRollingMax = number\n                currentMaxIndex = number\n    \
    \            currentRollingMaxIndex = number\n                currentRollingMax\
    \ = number\n            } else {\n                max.append(number)\n       \
    \         rollingMax.append(currentRollingMax)\n                maxIndex = currentMaxIndex\n\
    \                rollingMaxIndex = currentRollingMaxIndex\n                currentMax\
    \ = number\n                currentRollingMax = number\n                currentMaxIndex\
    \ = number\n                currentRollingMaxIndex = number\n                currentRollingMax\
    \ = number\n            }\n        }\n        rollingMax.toList", "        val\
    \ max = new mutable.ListBuffer[Long]()\n        var maxIndex = 0\n        var\
    \ maxValue = numbers(0)\n        var maxIndexes = new mutable.ListBuffer[Int]()\n\
    \        numbers.foreach { n =>\n            if (n > maxValue) {\n           \
    \     maxValue = n\n                maxIndex = 0\n                maxIndexes +=\
    \ 0\n            }\n            if (n == maxValue) {\n                maxIndexes\
    \ += maxIndex\n            }\n            if (n > maxValue) {\n              \
    \  maxIndex += 1\n                maxIndexes += maxIndex\n            }\n    \
    \    }\n        val maxIndexesList = maxIndexes.toList\n        val maxIndexesListSize\
    \ = maxIndexesList.length\n        val maxIndexesListMax = maxIndexesList.max\n\
    \        val maxIndexesListMaxIndex = maxIndexesList.maxIndex\n        val maxIndexesListMaxValue\
    \ = maxIndexesList.maxValue\n        val maxIndexesListMaxIndex = maxIndexesList.maxIndex\n\
    \        val maxIndexesListMaxValue = maxIndexesList.maxValue\n        val maxIndexesListMaxIndex\
    \ = maxIndexesList.maxIndex\n        val maxIndexesListMaxValue = maxIndexesList.maxValue\n\
    \        val maxIndexesListMaxIndex = maxIndexesList.maxIndex\n        val maxIndexesListMaxValue\
    \ = maxIndexesList.maxValue\n        val maxIndexesListMaxIndex = maxIndexesList.maxIndex\n\
    \        val maxIndexesListMaxValue = maxIndexesList.maxValue\n        val maxIndexesListMaxIndex\
    \ = maxIndexesList.maxIndex\n        val maxIndexesListMaxValue = maxIndexesList.maxValue\n\
    \        val maxIndexesListMaxIndex = maxIndexesList.maxIndex\n        val maxIndexesListMaxValue\
    \ = maxIndexesList.maxValue\n        val maxIndexesListMaxIndex = maxIndexesList.maxIndex\n\
    \        val maxIndexesListMaxValue = maxIndexesList.maxValue\n        val maxIndexesListMaxIndex\
    \ = maxIndexesList.maxIndex\n        val maxIndexesListMaxValue = maxIndexesList.maxValue\n\
    \        val maxIndexesListMaxIndex = maxIndexesList.maxIndex\n        val maxIndexesListMaxValue\
    \ = maxIndexesList.maxValue\n        val maxIndexesListMaxIndex = maxIndexesList.maxIndex\n\
    \        val maxIndexesListMaxValue = maxIndexesList.maxValue\n        val maxIndexesListMaxIndex\
    \ = maxIndexesList.maxIndex\n        val maxIndexesListMaxValue = maxIndexesList.maxValue\n\
    \        val maxIndexes", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(x => max.put(x, if (max.getOrElse(x, 0) > x) max.getOrElse(x,\
    \ 0) else x))\n        val result: List[Long] = new mutable.ArrayBuffer[Long]()\n\
    \        val rollingMax = numbers.reverse.foldLeft(List[Long]())((acc, x) => {\n\
    \            val max = max.getOrElse(x, 0)\n            val rollingMax = if (max\
    \ > x) x else x + max\n            acc :+ rollingMax\n        })\n        result.reverse.foreach(x\
    \ => result.insert(result.size - 1, x))\n        result.reverse", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { x =>\n  \
    \          val maxKey = max.max.key\n            if (maxKey == null || x > maxKey)\
    \ {\n                max.put(x, x)\n            } else {\n                max.put(maxKey,\
    \ Math.max(max.get(maxKey), x))\n            }\n        }\n        max.values.toList",
  "        val maxes = new mutable.ListBuffer[Long]()\n        numbers.foreach { number\
    \ =>\n            val maxIndex = maxes.indexOf(math.max(maxes.lastOption, number))\n\
    \            if (maxIndex == -1) {\n                maxes += number\n        \
    \    } else {\n                maxes(maxIndex) = number\n            }\n     \
    \   }\n        maxes.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        val rollingMaxIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach\
    \ { number =>\n            rollingMax.append(number)\n            rollingMaxIndex.append(0)\n\
    \        }\n        rollingMax.foreach { number =>\n            rollingMaxIndex.foreach\
    \ { index =>\n                if (number > rollingMax(index)) {\n            \
    \        rollingMax(index) = number\n                }\n            }\n      \
    \  }\n        rollingMax.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        numbers.foreach(number => {\n            if\
    \ (number > max.lastOption.getOrElse(number)) {\n                max += number\n\
    \                maxIndex += 1\n            }\n        })\n        max.reverse",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            if (max.contains(n)) {\n                max += (n, max(n))\n\
    \            } else {\n                max += (n, n)\n            }\n        }\n\
    \        val result = new mutable.ArrayList[Long]()\n        max.foreach { case\
    \ (k, v) =>\n            if (v > result.last) result :+ v\n        }\n       \
    \ result", "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => {\n            if (max.contains(x)) {\n                val max = max(x)\n\
    \                max.updated(x, max(x + 1))\n            } else {\n          \
    \      max.updated(x, x)\n            }\n        })\n        max.values.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ListBuffer[Long]()\n        for (i <- 0 until numbers.size) {\n    \
    \        val value = numbers(i)\n            val max = max.get(value, 0L) + 1\n\
    \            max.put(value, max)\n            rollingMax += value\n          \
    \  if (max.size > rollingMax.size) {\n                rollingMax += max.get(rollingMax.last)\n\
    \                max.clear()\n            }\n        }\n        rollingMax.toList",
  "        val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach { n =>\n            if (rollingMax.size\
    \ > 0) {\n                rollingMax.lastOption match {\n                    case\
    \ Some(maxN) =>\n                        if (n > maxN) {\n                   \
    \         rollingMax.clear()\n                            rollingMax.append(n)\n\
    \                        }\n                    case None =>\n               \
    \         rollingMax.append(n)\n                }\n            } else {\n    \
    \            rollingMax.append(n)\n            }\n        }\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            if (max.containsKey(n)) {\n                max.put(n, max(n)\
    \ + 1)\n            } else {\n                max.put(n, 1)\n            }\n \
    \       }\n        val maxList = max.toList.sortBy(_._1).reverse\n        val\
    \ result: List[Long] = new mutable.ArrayList[Long]()\n        for (i <- 0 until\
    \ maxList.size) {\n            result.add(maxList(i)._1)\n        }\n        result",
  "        val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ArrayList[Long]()\n        numbers.foreach { number =>\n           \
    \ val maxKey = math.max(number, max.getOrElse(number, 0))\n            max.put(number,\
    \ maxKey)\n            rollingMax += maxKey\n        }\n        rollingMax.toList",
  "        val max = new mutable.ListBuffer[Long]()\n        var maxIndex = 0\n  \
    \      var currentMax = 0L\n        var currentIndex = 0\n        numbers.foreach{\n\
    \            val currentElement = it\n            val currentMaxIndex = currentIndex\n\
    \            val currentMax = currentElement\n            currentIndex += 1\n\
    \            val currentMaxIndex = currentIndex\n            val currentMax =\
    \ currentElement\n            currentIndex += 1\n            val currentMaxIndex\
    \ = currentIndex\n            val currentMax = currentElement\n            currentIndex\
    \ += 1\n            val currentMaxIndex = currentIndex\n            val currentMax\
    \ = currentElement\n            currentIndex += 1\n            val currentMaxIndex\
    \ = currentIndex\n            val currentMax = currentElement\n            currentIndex\
    \ += 1\n            val currentMaxIndex = currentIndex\n            val currentMax\
    \ = currentElement\n            currentIndex += 1\n            val currentMaxIndex\
    \ = currentIndex\n            val currentMax = currentElement\n            currentIndex\
    \ += 1\n            val currentMaxIndex = currentIndex\n            val currentMax\
    \ = currentElement\n            currentIndex += 1\n            val currentMaxIndex\
    \ = currentIndex\n            val currentMax = currentElement\n            currentIndex\
    \ += 1\n            val currentMaxIndex = currentIndex\n            val currentMax\
    \ = currentElement\n            currentIndex += 1\n            val currentMaxIndex\
    \ = currentIndex\n            val currentMax = currentElement\n            currentIndex\
    \ += 1\n            val currentMaxIndex = currentIndex\n            val currentMax\
    \ = currentElement\n            currentIndex += 1\n            val currentMaxIndex\
    \ = currentIndex\n            val currentMax = currentElement\n            currentIndex\
    \ += 1\n            val currentMaxIndex = currentIndex\n            val currentMax\
    \ = currentElement\n            currentIndex += 1\n            val currentMaxIndex\
    \ = currentIndex\n            val currentMax = currentElement\n            currentIndex\
    \ += 1\n            val currentMaxIndex = currentIndex\n            val currentMax\
    \ = currentElement\n            currentIndex += 1\n            val currentMaxIndex\
    \ = currentIndex\n            val currentMax = currentElement\n            currentIndex\
    \ += 1\n            val currentMaxIndex = currentIndex\n            val currentMax\
    \ = currentElement\n            currentIndex += 1\n            val currentMaxIndex\
    \ = currentIndex\n            val currentMax = currentElement\n            currentIndex\
    \ += 1\n            val currentMaxIndex = currentIndex\n            val currentMax\
    \ = currentElement\n            currentIndex += 1\n            val currentMaxIndex\
    \ = currentIndex\n            val currentMax = currentElement\n            currentIndex\
    \ += 1\n            val currentMaxIndex = currentIndex\n            val currentMax\
    \ = currentElement\n            currentIndex += 1\n            val currentMaxIndex\
    \ = currentIndex\n            ", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach\
    \ { n =>\n            rollingMax.clear()\n            rollingMax.push(n)\n   \
    \         while (rollingMax.nonEmpty) {\n                val m = rollingMax.last\n\
    \                if (m > max) {\n                    max += m\n              \
    \      rollingMax.clear()\n                }\n                else {\n       \
    \             rollingMax.clear()\n                }\n            }\n        }\n\
    \        rollingMax.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val maxIndex = new mutable.HashMap[Long, Int]()\n        val maxIndexMap\
    \ = new mutable.HashMap[Int, Long]()\n        val maxIndexMap2 = new mutable.HashMap[Int,\
    \ Int]()\n        numbers.foreach { number =>\n            val index = maxIndex.getOrElse(number,\
    \ -1)\n            if (index == -1) {\n                max.put(number, number)\n\
    \                maxIndex.put(number, 0)\n                maxIndexMap.put(index,\
    \ number)\n                maxIndexMap2.put(index, 0)\n            } else {\n\
    \                val maxIndex = maxIndexMap.get(index)\n                val maxValue\
    \ = max.get(maxIndex)\n                if (number > maxValue) {\n            \
    \        max.put(number, number)\n                    maxIndex.put(number, index)\n\
    \                    maxIndexMap.put(index, number)\n                    maxIndexMap2.put(index,\
    \ index)\n                }\n            }\n        }\n        val maxIndexList\
    \ = maxIndexMap2.values.toList\n        val maxIndexList2 = maxIndexList.sortWith(_\
    \ < _)\n        val maxIndexList3 = maxIndexList2.reverse\n        val maxIndexList4\
    \ = maxIndexList3.map(x => maxIndexMap.get(x))\n        val maxIndexList5 = maxIndexList4.map(x\
    \ => maxIndexMap2.get(x))\n        val maxIndexList6 = maxIndexList5.map(x =>\
    \ maxIndexMap2.get(x))\n        val maxIndexList7 = maxIndexList6.map(x => maxIndexMap2.get(x))\n\
    \        val maxIndexList8 = maxIndexList7.map(x => maxIndexMap2.get(x))\n   \
    \     val maxIndexList9 = maxIndexList8.map(x => maxIndexMap2.get(x))\n      \
    \  val maxIndexList10 = maxIndexList9.map(x => maxIndexMap2.get(x))\n        val\
    \ maxIndexList11 = maxIndexList10.map(x => maxIndexMap2.get(x))\n        val maxIndexList12\
    \ = maxIndexList11.map(x => maxIndexMap2.get(x))\n        val maxIndexList13 =\
    \ maxIndexList12.map(x => maxIndexMap2.get(x))\n        val maxIndexList14 = maxIndexList13.map(x\
    \ => maxIndexMap2.get(x))\n        val maxIndexList15 = maxIndexList14.map(x =>\
    \ maxIndexMap2.get(x))\n        val maxIndexList16 = maxIndexList15.map(x => maxIndexMap2.get(x))\n\
    \        val maxIndexList17 = maxIndexList16.map(x => maxIndexMap2.get(x))\n \
    \       val maxIndexList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            val maxIndex = rollingMax.lastIndex\n\
    \            if (maxIndex == -1) rollingMax += number\n            else rollingMax(maxIndex)\
    \ = max(rollingMax(maxIndex), number)\n        }\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ArrayList[Long]()\n        numbers.foreach { n =>\n            val max\
    \ = max.getOrElseUpdate(n, 0L)\n            val rollingMax = rollingMax.getOrElseUpdate(n,\
    \ new mutable.ArrayList[Long]())\n            rollingMax.add(max)\n        }\n\
    \        rollingMax.map(_.max)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var max = 0L\n        var maxIndex = 0\n        numbers.foreach { number\
    \ =>\n            if (number > max) {\n                max = number\n        \
    \        maxIndex = numbers.indexOf(number)\n            }\n        }\n      \
    \  result += max\n        numbers.drop(maxIndex).foreach { number =>\n       \
    \     if (number > max) {\n                max = number\n                maxIndex\
    \ = numbers.indexOf(number)\n            }\n        }\n        result += max\n\
    \        result", "        val max = new mutable.HashMap[Long, Long]()\n     \
    \   numbers.foreach(x => max.put(x, max.getOrElse(x, 0) + x))\n        max.values.toList",
  "        val maxes = mutable.ListBuffer.empty[Long]\n        val maxesIndex = mutable.ListBuffer.empty[Int]\n\
    \        numbers.foreach { number =>\n            val index = maxes.size\n   \
    \         val maxValue = number\n            val maxIndex = index\n          \
    \  val maxValue = number\n            val maxIndex = index\n            val maxValue\
    \ = number\n            val maxIndex = index\n            val maxValue = number\n\
    \            val maxIndex = index\n            val maxValue = number\n       \
    \     val maxIndex = index\n            val maxValue = number\n            val\
    \ maxIndex = index\n            val maxValue = number\n            val maxIndex\
    \ = index\n            val maxValue = number\n            val maxIndex = index\n\
    \            val maxValue = number\n            val maxIndex = index\n       \
    \     val maxValue = number\n            val maxIndex = index\n            val\
    \ maxValue = number\n            val maxIndex = index\n            val maxValue\
    \ = number\n            val maxIndex = index\n            val maxValue = number\n\
    \            val maxIndex = index\n            val maxValue = number\n       \
    \     val maxIndex = index\n            val maxValue = number\n            val\
    \ maxIndex = index\n            val maxValue = number\n            val maxIndex\
    \ = index\n            val maxValue = number\n            val maxIndex = index\n\
    \            val maxValue = number\n            val maxIndex = index\n       \
    \     val maxValue = number\n            val maxIndex = index\n            val\
    \ maxValue = number\n            val maxIndex = index\n            val maxValue\
    \ = number\n            val maxIndex = index\n            val maxValue = number\n\
    \            val maxIndex = index\n            val maxValue = number\n       \
    \     val maxIndex = index\n            val maxValue = number\n            val\
    \ maxIndex = index\n            val maxValue = number\n            val maxIndex\
    \ = index\n            val maxValue = number\n            val maxIndex = index\n\
    \            val maxValue = number\n            val maxIndex = index\n       \
    \     val maxValue = number\n            val maxIndex = index\n            val\
    \ maxValue = number\n            val maxIndex = index\n            val maxValue\
    \ = number\n            val maxIndex = index\n            val maxValue = number\n\
    \            val maxIndex = index\n            val maxValue = number\n       \
    \     val maxIndex = index\n            val maxValue = number\n            val\
    \ maxIndex = index\n            val maxValue = number\n            val maxIndex\
    \ = index\n            val maxValue = number\n            val maxIndex = index\n\
    \            val maxValue = number\n            val maxIndex = index\n       \
    \     val maxValue = number\n            val maxIndex = index\n            val\
    \ maxValue = number\n            val maxIndex = index\n            val maxValue\
    \ = number\n            val maxIndex = index\n            val ", "        val\
    \ max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number =>\n\
    \            val max = number.max(max)\n        }\n        max.values.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        val rollingMaxIndex\
    \ = mutable.ListBuffer.empty[Int]\n        numbers.foreach { number =>\n     \
    \       rollingMax.append(number)\n            rollingMaxIndex.append(0)\n   \
    \     }\n        rollingMax.foreach { number =>\n            rollingMaxIndex.foreach\
    \ { index =>\n                if (number > rollingMax(index)) {\n            \
    \        rollingMax(index) = number\n                }\n            }\n      \
    \  }\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxes = new mutable.ListBuffer[Long]()\n        numbers.foreach(n\
    \ => {\n            val maxKey = max.keySet().toList.max\n            val maxValue\
    \ = max.get(maxKey)\n            if (maxValue < n)\n                max.put(maxKey,\
    \ n)\n            else {\n                val maxes = maxes :+ maxValue\n    \
    \            max.clear()\n                max.put(maxKey, maxes.max)\n       \
    \     }\n        })\n        maxes", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0L\n        var currentMax = 0L\n        var currentIndex =\
    \ 0L\n        var currentSum = 0L\n        var currentSumOfSquares = 0L\n    \
    \    var currentSumOfSquareOfMax = 0L\n        var currentSumOfSquareOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMax = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMax = 0L\n       \
    \ var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMax = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n        var currentSumOfSquareOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMaxOfMax\
    \ = 0L\n", "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach\
    \ { n =>\n            val max = max.getOrElseUpdate(n, 0L)\n            max.update(n\
    \ + 1, Math.max(n, max.get(n) + 1))\n        }\n        max.values.toList", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            if (max.containsKey(n)) {\n                max.update(n, max(n)\
    \ + 1)\n            } else {\n                max.put(n, 1L)\n            }\n\
    \        }\n        val maxList = new mutable.ListBuffer[Long]()\n        for\
    \ (n <- max.keys) {\n            if (max(n) > numbers.size) {\n              \
    \  maxList += n\n            }\n        }\n        return maxList.toList", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        max.values.toList", "     \
    \   val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var rollingMaxIndex = 0\n        numbers.foreach\
    \ { number =>\n            if (number > max.last) {\n                max.append(number)\n\
    \                maxIndex = number\n            }\n            else {\n      \
    \          val maxIndex = max.last\n                max.remove(maxIndex)\n   \
    \             max.append(number)\n                maxIndex = number\n        \
    \    }\n        }\n        rollingMax.append(maxIndex)\n        rollingMaxIndex\
    \ += 1\n        numbers.foreach { number =>\n            if (number > max.last)\
    \ {\n                max.append(number)\n                maxIndex = number\n \
    \           }\n            else {\n                val maxIndex = max.last\n \
    \               max.remove(maxIndex)\n                max.append(number)\n   \
    \             maxIndex = number\n            }\n        }\n        rollingMax.append(maxIndex)\n\
    \        rollingMaxIndex += 1\n        rollingMax.toList", "        val maxes\
    \ = new mutable.ListBuffer[Long]()\n        val rollingMax = numbers.foldLeft(0L)\
    \ { (max, cur) => if (max < cur) max else cur }\n        val rollingMaxIndex =\
    \ numbers.indexOf(rollingMax)\n        val rollingMaxIndex = rollingMaxIndex +\
    \ 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        val rollingMaxIndex\
    \ = rollingMaxIndex - 1\n        val rollingMaxIndex = rollingMaxIndex - 1\n \
    \       val rollingMaxIndex = rollingMaxIndex - 1\n        ", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n      \
    \      val max = max.getOrElseUpdate(n, 0L)\n            val cur = max.getOrElse(n,\
    \ 0)\n            max.put(n, cur + n)\n        }\n        val res = new mutable.ArrayList[Long]()\n\
    \        max.foreach { case (k, v) =>\n            res += k\n        }\n     \
    \   res", "        val max = new mutable.ListBuffer[Long]()\n        val rollingMax\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n    \
    \        if (max.length < rollingMax.length) max += number\n            else rollingMax\
    \ += max\n        }\n        rollingMax.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax.append(number)\n\
    \            rollingMax.lastOption match {\n                case Some(max) =>\n\
    \                    rollingMax.dropRight(1) += max\n                case None\
    \ =>\n            }\n        }\n        rollingMax.toList", "        val max =\
    \ new mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n        \
    \    val maxKey = max.max.key\n            if (maxKey == null || n > maxKey) {\n\
    \                max.put(n, n)\n            } else {\n                val maxValue\
    \ = max.max.value\n                if (maxValue > n) {\n                    max.put(n,\
    \ maxValue)\n                }\n            }\n        }\n        max.values.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val rollingMax = new\
    \ mutable.ArrayList[Long]()\n        for (i <- 0 until numbers.size) {\n     \
    \       val value = numbers(i)\n            if (max.contains(value)) {\n     \
    \           val max = max(value)\n                rollingMax.add(value)\n    \
    \            max.foreach(x => max.remove(x))\n            } else {\n         \
    \       max.put(value, value)\n                rollingMax.add(value)\n       \
    \     }\n        }\n        rollingMax.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val maxIndex = new mutable.ListBuffer[Int]()\n        numbers.foreach\
    \ { number =>\n            val index = numbers.indexOf(number)\n            if\
    \ (index != -1) {\n                if (max.length < index) max += number\n   \
    \             maxIndex += index\n            }\n        }\n        val maxIndex\
    \ = maxIndex.toList\n        val maxIndex = maxIndex.sortBy(-_)\n        val maxIndex\
    \ = maxIndex.take(maxIndex.length)\n        val maxIndex = maxIndex.map(_.toLong)\n\
    \        val maxIndex = maxIndex.distinct\n        val maxIndex = maxIndex.map(_.toLong)\n\
    \        val maxIndex = maxIndex.take(maxIndex.length)\n        val maxIndex =\
    \ maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.distinct\n        val\
    \ maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.take(maxIndex.length)\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.distinct\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.take(maxIndex.length)\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.distinct\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.take(maxIndex.length)\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.distinct\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.take(maxIndex.length)\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.distinct\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.take(maxIndex.length)\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.distinct\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.take(maxIndex.length)\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.distinct\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = maxIndex.take(maxIndex.length)\n\
    \        val maxIndex = maxIndex.map(_.toLong)\n        val maxIndex = ", "  \
    \      val result = new mutable.ListBuffer[Long]()\n        var max = 0L\n   \
    \     var maxIndex = 0\n        numbers.foreach { number =>\n            if (number\
    \ > max) {\n                max = number\n                maxIndex = numbers.indexOf(number)\n\
    \            }\n        }\n        result.add(max)\n        numbers.drop(maxIndex).foreach\
    \ { number =>\n            if (number > max) {\n                max = number\n\
    \                maxIndex = numbers.indexOf(number)\n            }\n        }\n\
    \        result.add(max)\n        result", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { n =>\n            val maxIndex = maxes.indexWhere(x\
    \ => x > n)\n            if (maxIndex >= 0) maxes.append(maxes(maxIndex))\n  \
    \          else maxes.append(n)\n        }\n        maxes.toList", "        val\
    \ maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n\
    \            val maxIndex = maxes.size\n            val maxValue = maxes.getOrElse(maxIndex,\
    \ number)\n            if (number > maxValue) {\n                maxes += number\n\
    \            }\n        }\n        maxes.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { number =>\n            if (max.contains(number))\
    \ {\n                max += number\n            } else {\n                max\
    \ += number -> number\n            }\n        }\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.foreach { case (number, max) =>\n            while (max > 0) {\n\
    \                result += number\n                max -= 1\n            }\n \
    \       }\n        result.toList", "        val maxList = mutable.ListBuffer.empty[Long]\n\
    \        var maxValue = numbers(0)\n        numbers.foreach { number =>\n    \
    \        if (number > maxValue) {\n                maxValue = number\n       \
    \     }\n            maxList += number\n        }\n        maxList.toList", " \
    \       val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new\
    \ mutable.ListBuffer[Long]()\n        val rollingMaxIndex = new mutable.ListBuffer[Int]()\n\
    \        numbers.foreach(x => {\n            if (rollingMaxIndex.size < rollingMax.size)\
    \ {\n                max += x\n                rollingMaxIndex += 0\n        \
    \        rollingMax += x\n            } else {\n                max += rollingMax(rollingMaxIndex)\n\
    \                rollingMaxIndex += 0\n                rollingMax += x\n     \
    \       }\n        })\n        rollingMax.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        val maxesIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach\
    \ { number =>\n            val index = maxes.size\n            maxes += number\n\
    \            maxesIndex += index\n        }\n        val maxesSize = maxes.size\n\
    \        val maxesIndex = maxesIndex.toArray\n        val maxesArray = maxes.toArray\n\
    \        val maxesArraySize = maxesArray.length\n        val maxesArrayIndex =\
    \ maxesArray.indices\n        val maxesArraySize = maxesArraySize\n        val\
    \ maxesArrayIndex = maxesArrayIndex.toArray\n        val maxesArray = maxesArray.toArray\n\
    \        val maxesArraySize = maxesArraySize\n        val maxesArrayIndex = maxesArrayIndex.toArray\n\
    \        val maxesArray = maxesArray.toArray\n        val maxesArraySize = maxesArraySize\n\
    \        val maxesArrayIndex = maxesArrayIndex.toArray\n        val maxesArray\
    \ = maxesArray.toArray\n        val maxesArraySize = maxesArraySize\n        val\
    \ maxesArrayIndex = maxesArrayIndex.toArray\n        val maxesArray = maxesArray.toArray\n\
    \        val maxesArraySize = maxesArraySize\n        val maxesArrayIndex = maxesArrayIndex.toArray\n\
    \        val maxesArray = maxesArray.toArray\n        val maxesArraySize = maxesArraySize\n\
    \        val maxesArrayIndex = maxesArrayIndex.toArray\n        val maxesArray\
    \ = maxesArray.toArray\n        val maxesArraySize = maxesArraySize\n        val\
    \ maxesArrayIndex = maxesArrayIndex.toArray\n        val maxesArray = maxesArray.toArray\n\
    \        val maxesArraySize = maxesArraySize\n        val maxesArrayIndex = maxesArrayIndex.toArray\n\
    \        val maxesArray = maxesArray.toArray\n        val maxesArraySize = maxesArraySize\n\
    \        val maxesArrayIndex = maxesArrayIndex.toArray\n        val maxesArray\
    \ = maxesArray.toArray\n        val maxesArraySize = maxesArraySize\n        val\
    \ maxesArrayIndex = maxesArrayIndex.toArray\n        val maxesArray = maxesArray.toArray\n\
    \        val maxesArraySize = maxesArraySize\n        val maxesArrayIndex = maxesArrayIndex.toArray\n\
    \        val maxesArray = maxesArray.toArray\n        val maxesArraySize = maxes",
  "        val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach(x => max.append(x))\n  \
    \      max.foreach(x => {\n            rollingMax.append(x)\n            rollingMax.foreach(y\
    \ => {\n                if (y > x) rollingMax.clear()\n            })\n      \
    \  })\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxes = new mutable.ArrayList[Long]()\n        numbers.foreach(n\
    \ => {\n            if (max.containsKey(n)) {\n                val m = max.get(n)\n\
    \                if (m > n) {\n                    max.put(n, m)\n           \
    \     } else {\n                    max.put(n, m)\n                    maxes +=\
    \ m\n                }\n            } else {\n                max.put(n, n)\n\
    \                maxes += n\n            }\n        })\n        maxes", "    \
    \    val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { x\
    \ =>\n            val max = x.getOrElse(max.getOrElse(x, 0), x)\n            max.foreach\
    \ { y =>\n                max.remove(y)\n            }\n        }\n        max.values.toList",
  "        val max = new mutable.ListBuffer[Long]()\n        var maxIndex = 0\n  \
    \      var maxValue = numbers(0)\n        numbers.foreach { n =>\n           \
    \ if (n > maxValue) {\n                maxValue = n\n                maxIndex\
    \ = 0\n            }\n            if (n == maxValue) {\n                max +=\
    \ maxValue\n                maxIndex += 1\n            }\n        }\n        max\
    \ += maxValue\n        max += maxValue\n        max += maxValue\n        max +=\
    \ maxValue\n        max += maxValue\n        max += maxValue\n        max += maxValue\n\
    \        max += maxValue\n        max += maxValue\n        max += maxValue\n \
    \       max += maxValue\n        max += maxValue\n        max += maxValue\n  \
    \      max += maxValue\n        max += maxValue\n        max += maxValue\n   \
    \     max += maxValue\n        max += maxValue\n        max += maxValue\n    \
    \    max += maxValue\n        max += maxValue\n        max += maxValue\n     \
    \   max += maxValue\n        max += maxValue\n        max += maxValue\n      \
    \  max += maxValue\n        max += maxValue\n        max += maxValue\n       \
    \ max += maxValue\n        max += maxValue\n        max += maxValue\n        max\
    \ += maxValue\n        max += maxValue\n        max += maxValue\n        max +=\
    \ maxValue\n        max += maxValue\n        max += maxValue\n        max += maxValue\n\
    \        max += maxValue\n        max += maxValue\n        max += maxValue\n \
    \       max += maxValue\n        max += maxValue\n        max += maxValue\n  \
    \      max += maxValue\n        max += maxValue\n        max += maxValue\n   \
    \     max += maxValue\n        max += maxValue\n        max += maxValue\n    \
    \    max += maxValue\n        max += maxValue\n        max += maxValue\n     \
    \   max += maxValue\n        max += maxValue\n        max += maxValue\n      \
    \  max += maxValue\n        max += maxValue\n        max += maxValue\n       \
    \ max += maxValue\n        max += maxValue\n        max += maxValue\n        max\
    \ += maxValue\n        max += maxValue\n        max += maxValue\n        max +=\
    \ maxValue\n        max += maxValue\n        max += maxValue\n        max += maxValue\n\
    \        max += maxValue\n        max += maxValue\n        max += maxValue\n \
    \       max += maxValue\n        max += max", "        val max = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var maxValue = numbers(0)\n        numbers.foreach\
    \ { n =>\n            if (n > maxValue) {\n                maxValue = n\n    \
    \            maxIndex = 0\n            }\n            if (n == maxValue) {\n \
    \               max += maxValue\n                maxIndex += 1\n            }\n\
    \        }\n        max += maxValue\n        max += numbers(maxIndex)\n      \
    \  max.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach(x\
    \ => maxes += x)\n        val maxesList = maxes.toList\n        val maxesListLength\
    \ = maxesList.length\n        val maxesListLength = maxesListLength - 1\n    \
    \    val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1\n        val maxesListLength = maxesListLength - 1\n   \
    \     val maxesListLength = maxesListLength - 1\n        val maxesListLength =\
    \ maxesListLength - 1", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        var max = 0L\n        var i = 0\n        while (i < numbers.length) {\n\
    \            if (numbers(i) > max) {\n                max = numbers(i)\n     \
    \       }\n            i += 1\n        }\n        maxes += max\n        val maxes2\
    \ = mutable.ListBuffer.empty[Long]\n        var max2 = 0L\n        var i = 0\n\
    \        while (i < numbers.length) {\n            if (numbers(i) > max2) {\n\
    \                max2 = numbers(i)\n            }\n            i += 1\n      \
    \  }\n        maxes2 += max2\n        if (maxes.size == numbers.length) {\n  \
    \          return maxes\n        } else {\n            return maxes2\n       \
    \ }", "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        val maxes = max.toList.sortBy(_._1).reverse\n\
    \        val maxesList = maxes.map(x => x._2)\n        val maxesList2 = maxes.map(x\
    \ => x._1)\n        val maxesList3 = maxes.map(x => x._2)\n        val maxesList4\
    \ = maxes.map(x => x._1)\n        val maxesList5 = maxes.map(x => x._2)\n    \
    \    val maxesList6 = maxes.map(x => x._1)\n        val maxesList7 = maxes.map(x\
    \ => x._2)\n        val maxesList8 = maxes.map(x => x._1)\n        val maxesList9\
    \ = maxes.map(x => x._2)\n        val maxesList10 = maxes.map(x => x._1)\n   \
    \     val maxesList11 = maxes.map(x => x._2)\n        val maxesList12 = maxes.map(x\
    \ => x._1)\n        val maxesList13 = maxes.map(x => x._2)\n        val maxesList14\
    \ = maxes.map(x => x._1)\n        val maxesList15 = maxes.map(x => x._2)\n   \
    \     val maxesList16 = maxes.map(x => x._1)\n        val maxesList17 = maxes.map(x\
    \ => x._2)\n        val maxesList18 = maxes.map(x => x._1)\n        val maxesList19\
    \ = maxes.map(x => x._2)\n        val maxesList20 = maxes.map(x => x._1)\n   \
    \     val maxesList21 = maxes.map(x => x._2)\n        val maxesList22 = maxes.map(x\
    \ => x._1)\n        val maxesList23 = maxes.map(x => x._2)\n        val maxesList24\
    \ = maxes.map(x => x._1)\n        val maxesList25 = maxes.map(x => x._2)\n   \
    \     val maxesList26 = maxes.map(x => x._1)\n        val maxesList27 = maxes.map(x\
    \ => x._2)\n        val maxesList28 = maxes.map(x => x._1)\n        val maxesList29\
    \ = maxes.map(x => x._2)\n        val maxesList30 = maxes.map(x => x._1)\n", " \
    \       val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val maxIndex = rollingMax.lastIndex\n            rollingMax.updated(maxIndex\
    \ + 1, number)\n        }\n        rollingMax.toList", "        val maxes = mutable.ArrayBuffer.empty[Long]\n\
    \        numbers.foreach(x => maxes += x)\n        val maxesRollingMax = maxes.sliding(2).max\n\
    \        maxesRollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => {\n            val max = max(x) + x\n            max.foreach { x => rollingMax.append(x)\
    \ }\n        })\n        rollingMax.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        val maxIndex = new mutable.HashMap[Long, Int]()\n        numbers.foreach\
    \ { number =>\n            val maxKey = if (max.containsKey(number)) maxKey(number)\
    \ else number\n            val maxValue = if (max.containsKey(maxKey)) maxValue(maxKey)\
    \ else 0\n            val index = if (maxIndex.containsKey(number)) maxIndex.get(number)\
    \ else 0\n            val newMaxValue = if (maxValue > number) number else maxValue\n\
    \            max.put(number, newMaxValue)\n            maxIndex.put(number, index\
    \ + 1)\n        }\n        max.values.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val maxKey = max.maxKey()\n\
    \            if (maxKey == null || n < maxKey) {\n                max.put(n, n)\n\
    \            } else {\n                val maxValue = max.get(maxKey)\n      \
    \          max.put(maxKey, maxValue + 1)\n            }\n        }\n        val\
    \ result = new mutable.ArrayList[Long]()\n        max.foreach { case (k, v) =>\n\
    \            result.add(v)\n        }\n        return result.toList", "      \
    \  val max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        val rollingMaxIndex = new mutable.ListBuffer[Int]()\n        numbers.foreach(x\
    \ => {\n            if (rollingMaxIndex.size < rollingMax.size) {\n          \
    \      max += x\n                rollingMaxIndex += 0\n            } else {\n\
    \                max += rollingMax(rollingMaxIndex.toList)\n                rollingMaxIndex\
    \ += 0\n            }\n        })\n        rollingMax.toList", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x => {\n      \
    \      if (max.contains(x)) {\n                max(x) = max(x) + x\n         \
    \   } else {\n                max.put(x, x)\n            }\n        })\n     \
    \   max.values.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(rollingMax.append(_))\n        rollingMax.toList", " \
    \       val result = new mutable.ListBuffer[Long]()\n        numbers.foreach(number\
    \ => {\n            val maxIndex = numbers.lastIndexWhere(x => x > number)\n \
    \           if (maxIndex >= 0) {\n                result.add(numbers(maxIndex))\n\
    \                numbers.remove(maxIndex)\n            }\n        })\n       \
    \ result.toList", "        val max = new mutable.HashMap[Long, Long]()\n     \
    \   numbers.foreach { n =>\n            val maxKey = max.keySet().toList.max\n\
    \            if (maxKey < n)\n                max.put(n, maxKey)\n        }\n\
    \        val maxList = max.values.toList\n        val maxIndex = maxList.indexOf(0)\n\
    \        val maxElement = maxList[maxIndex]\n        val maxListWithoutMax = maxList.filterNot(_\
    \ == maxElement)\n        val maxListWithoutMaxIndex = maxListWithoutMax.indexOf(0)\n\
    \        val maxElementWithoutMax = maxListWithoutMax[maxListWithoutMaxIndex]\n\
    \        val maxElementIndex = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex\
    \ = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n\
    \        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex\
    \ = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n\
    \        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex\
    \ = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n\
    \        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex\
    \ = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n\
    \        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex\
    \ = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n\
    \        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex\
    \ = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n\
    \        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex\
    \ = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n\
    \        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex\
    \ = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n\
    \        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex\
    \ = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n\
    \        val maxElementWithoutMaxIndex = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex\
    \ = maxListWithoutMaxIndex\n        val maxElementWithoutMaxIndex = max", "  \
    \      val maxes = new mutable.ListBuffer[Long]()\n        val max = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(n => {\n            if (n.isMax) {\n                max\
    \ += n\n            } else {\n                maxes += n\n            }\n    \
    \    })\n        max += maxes.last\n        maxes.clear()\n        max.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        val rollingMaxIndex\
    \ = mutable.ListBuffer.empty[Int]\n        numbers.foreach { number =>\n     \
    \       rollingMax.updated(rollingMaxIndex.last, number)\n            rollingMaxIndex\
    \ += number\n        }\n        rollingMax.toList", "        val rollingMax =\
    \ mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n      \
    \      rollingMax.append(number)\n            if (rollingMax.size > 1) {\n   \
    \             rollingMax.drop(1).max match {\n                    case Some(max)\
    \ => rollingMax.update(0, max)\n                    case None => rollingMax.update(0,\
    \ number)\n                }\n            } else {\n                rollingMax.update(0,\
    \ number)\n            }\n        }\n        rollingMax.toList", "        val\
    \ max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        numbers.foreach { n =>\n            rollingMax.append(n)\n\
    \            if (rollingMax.size > maxIndex) {\n                max.append(rollingMax.max)\n\
    \                maxIndex = rollingMax.size\n            }\n        }\n      \
    \  max.toList", "        val max = new mutable.ListBuffer[Long]()\n        var\
    \ maxIndex = 0\n        var maxValue = numbers(0)\n        numbers.foreach { n\
    \ =>\n            if (n > maxValue) {\n                maxValue = n\n        \
    \        maxIndex = 0\n            }\n            if (n == maxValue) {\n     \
    \           max.append(maxValue)\n                maxIndex += 1\n            }\n\
    \        }\n        max.reverse", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        val rollingMaxIndex\
    \ = new mutable.ListBuffer[Int]()\n        numbers.foreach { number =>\n     \
    \       if (rollingMaxIndex.contains(number)) {\n                rollingMax.append(rollingMax(rollingMaxIndex.last))\n\
    \                rollingMaxIndex.removeLast\n            }\n            rollingMax.append(number)\n\
    \            rollingMaxIndex.append(0)\n        }\n        rollingMax.append(rollingMax(rollingMaxIndex.last))\n\
    \        rollingMax", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        val rollingMaxIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach\
    \ { number =>\n            rollingMax.synchronized {\n                rollingMax.clear()\n\
    \                rollingMaxIndex.synchronized {\n                    rollingMaxIndex.clear()\n\
    \                    rollingMaxIndex.clear()\n                    rollingMaxIndex\
    \ += 0\n                    rollingMaxIndex += number\n                    rollingMaxIndex\
    \ += number\n                    rollingMaxIndex += number\n                 \
    \   rollingMaxIndex += number\n                    rollingMaxIndex += number\n\
    \                    rollingMaxIndex += number\n                    rollingMaxIndex\
    \ += number\n                    rollingMaxIndex += number\n                 \
    \   rollingMaxIndex += number\n                    rollingMaxIndex += number\n\
    \                    rollingMaxIndex += number\n                    rollingMaxIndex\
    \ += number\n                    rollingMaxIndex += number\n                 \
    \   rollingMaxIndex += number\n                    rollingMaxIndex += number\n\
    \                    rollingMaxIndex += number\n                    rollingMaxIndex\
    \ += number\n                    rollingMaxIndex += number\n                 \
    \   rollingMaxIndex += number\n                    rollingMaxIndex += number\n\
    \                    rollingMaxIndex += number\n                    rollingMaxIndex\
    \ += number\n                    rollingMaxIndex += number\n                 \
    \   rollingMaxIndex += number\n                    rollingMaxIndex += number\n\
    \                    rollingMaxIndex += number\n                    rollingMaxIndex\
    \ += number\n                    rollingMaxIndex += number\n                 \
    \   rollingMaxIndex += number\n                    rollingMaxIndex += number\n\
    \                    rollingMaxIndex += number\n                    rollingMaxIndex\
    \ += number\n                    rollingMaxIndex += number\n                 \
    \   rollingMaxIndex += number\n                    rollingMaxIndex += number\n\
    \                    rollingMaxIndex += number\n                    rollingMaxIndex\
    \ += number\n                    rollingMaxIndex += number\n                 \
    \   rollingMaxIndex += number\n                    rollingMaxIndex += number\n\
    \                    rollingMaxIndex += number\n                    rollingMaxIndex\
    \ += number\n                    rollingMaxIndex += number\n                 \
    \   rollingMaxIndex += number\n                    rollingMaxIndex += number\n\
    \                    rollingMaxIndex += number\n                    rollingMaxIndex\
    \ += number\n                    rollingMaxIndex += number\n                 \
    \   rollingMaxIndex += number\n                    rollingMaxIndex += number\n\
    \                    rollingMaxIndex += number\n                    rollingMaxIndex\
    \ += number\n                    rollingMaxIndex += number\n", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n      \
    \      val maxKey = max.getOrElseUpdate(n, 0L)\n            val maxValue = max.getOrElseUpdate(n,\
    \ 0L)\n            if (maxKey < n) max.put(n, maxValue)\n        }\n        val\
    \ result: List[Long] = new mutable.ListBuffer[Long]()\n        max.foreach { case\
    \ (k, v) =>\n            if (v > 0) result += k\n        }\n        result.toList",
  "        val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { n\
    \ =>\n            val maxIndex = maxes.lastIndex\n            val maxValue = maxes.get(maxIndex)\
    \ match {\n                case None => n\n                case Some(max) => math.max(max,\
    \ n)\n            }\n            maxes += maxValue\n        }\n        maxes.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        val maxIndex = new\
    \ mutable.HashMap[Long, Long]()\n        numbers.foreach(x => {\n            if\
    \ (max.contains(x)) {\n                val max = max(x)\n                val maxIndex\
    \ = maxIndex(x)\n                maxIndex += x\n                maxIndex.foreach(y\
    \ => max.update(y, max))\n            } else {\n                max.update(x,\
    \ x)\n                maxIndex.update(x, x)\n            }\n        })\n     \
    \   max.values.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        val maxes = new mutable.ListBuffer[Long]()\n        numbers.foreach(n\
    \ => {\n            val maxKey = max.getOrElse(n, 0)\n            val maxValue\
    \ = max.getOrElse(n, 0)\n            val newMaxValue = maxValue + n\n        \
    \    max.put(n, newMaxValue)\n            maxes += newMaxValue\n        })\n \
    \       maxes.toList", "        val max = new mutable.ListBuffer[Long]()\n   \
    \     val rollingMax = new mutable.ListBuffer[Long]()\n        var maxIndex =\
    \ 0\n        var rollingMaxIndex = 0\n        var maxValue = numbers(0)\n    \
    \    var rollingMaxValue = numbers(0)\n        numbers.foreach { x =>\n      \
    \      if (x > maxValue) {\n                maxValue = x\n                maxIndex\
    \ = 0\n            }\n            if (x == maxValue) {\n                max.append(x)\n\
    \                maxIndex += 1\n            }\n            if (maxIndex > rollingMaxIndex)\
    \ {\n                rollingMaxValue = maxValue\n                rollingMaxIndex\
    \ = maxIndex\n            }\n            if (maxIndex == rollingMaxIndex) {\n\
    \                rollingMax.append(rollingMaxValue)\n            }\n        }\n\
    \        rollingMax.toList", "        val max = new mutable.HashMap[Long, Long]()\n\
    \        numbers.foreach(n => max.put(n, max.getOrElse(n, n)))\n        val result\
    \ = new mutable.ArrayList[Long]()\n        val rollingMax = numbers.foldLeft(0L)\
    \ { (max, n) => max.max { case (k, v) => if (v > n) v else k } }\n        val\
    \ rollingMaxIndex = numbers.indexOf(rollingMax)\n        numbers.take(rollingMaxIndex\
    \ + 1).foreach(n => result.add(max(n)))\n        result.toList", "        val\
    \ max = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var rollingMaxIndex = 0\n        numbers.foreach\
    \ { n =>\n            if (rollingMaxIndex < rollingMax.size) {\n             \
    \   if (rollingMax(rollingMaxIndex) < n) {\n                    rollingMax(rollingMaxIndex)\
    \ = n\n                    rollingMaxIndex += 1\n                }\n         \
    \   } else {\n                rollingMax.append(n)\n                rollingMaxIndex\
    \ += 1\n            }\n            if (rollingMaxIndex == rollingMax.size) {\n\
    \                max.append(rollingMax.max)\n                rollingMaxIndex =\
    \ 0\n            }\n        }\n        max.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var maxValue = numbers(0)\n        numbers.foreach(n\
    \ => {\n            if (n > maxValue) {\n                maxValue = n\n      \
    \          maxIndex = 0\n            }\n            if (n == maxValue) {\n   \
    \             max.append(maxValue)\n                maxIndex += 1\n          \
    \  }\n        })\n        max.reverse", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        val rollingMaxIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach(number\
    \ => {\n            rollingMax.lastOption match {\n                case None =>\n\
    \                    rollingMax.append(number)\n                    rollingMaxIndex.append(0)\n\
    \                case Some(lastMax) =>\n                    val index = rollingMaxIndex.lastOption.getOrElse(0)\
    \ // get last index\n                    val newMax = math.max(lastMax, number)\n\
    \                    rollingMax.append(newMax)\n                    rollingMaxIndex.append(index\
    \ + 1)\n            }\n        })\n        rollingMax.toList", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        numbers.foreach { n =>\n      \
    \      val maxKey = max.max.key\n            if (maxKey == null || n < maxKey)\
    \ {\n                max.put(n, n)\n            } else {\n                val\
    \ maxValue = max.max.value\n                if (maxValue < n) {\n            \
    \        max.put(maxKey, n)\n                }\n            }\n        }\n   \
    \     max.values.toList", "        val maxes = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        var max = 0L\n\
    \        var i = 0\n        while (i < numbers.length) {\n            if (numbers(i)\
    \ > max) {\n                max = numbers(i)\n            }\n            i +=\
    \ 1\n        }\n        maxes += max\n        rollingMax += max\n        val rollingMaxLength\
    \ = rollingMax.length\n        val maxesLength = maxes.length\n        var j =\
    \ 0\n        while (j < maxesLength) {\n            if (rollingMax(j) < maxes(j))\
    \ {\n                rollingMax(j) = maxes(j)\n            }\n            j +=\
    \ 1\n        }\n        rollingMax.toList", "        val maxes = mutable.ListBuffer.empty[Long]\n\
    \        val currentMax = numbers.head\n        val currentMaxIndex = numbers.indexOf(0)\n\
    \        numbers.tail.foreach { n =>\n            if (n > currentMax) {\n    \
    \            maxes += currentMax\n                currentMax = currentMax\n  \
    \              currentMaxIndex = numbers.indexOf(n)\n            }\n         \
    \   currentMax = currentMax\n            currentMaxIndex += 1\n        }\n   \
    \     maxes += currentMax\n        maxes", "        val max = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => max += x)\n        max.toList", "        val max\
    \ = new mutable.HashMap[Long, Long]()\n        val rollingMax = new mutable.ArrayBuffer[Long]()\n\
    \        numbers.foreach(n => {\n            val maxKey = max.minKey\n       \
    \     if (maxKey != null && maxKey > n) {\n                max.remove(maxKey)\n\
    \            }\n            max += n -> n\n        })\n        max.foreach {\n\
    \            case (k, v) => rollingMax += k\n        }\n        rollingMax.toList",
  "        val rollingMax = mutable.ListBuffer.empty[Long]\n        numbers.foreach\
    \ { number =>\n            val rollingMaxElement = rollingMax.last\n         \
    \   if (number > rollingMaxElement) {\n                rollingMax.append(number)\n\
    \            }\n        }\n        rollingMax.toList", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { n =>\n            val maxKey = max.max(n) + n\n   \
    \         if (maxKey > rollingMax.last)\n                rollingMax += maxKey\n\
    \            else\n                rollingMax += maxKey + n\n        }\n     \
    \   rollingMax.toList"]
stop_tokens:
- "\n    }\n"
