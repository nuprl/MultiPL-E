name: HumanEval_9_rolling_max
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n    // in the sequence.\n    // >>> rolling_max([1,\
  \ 2, 3, 2, 3, 4, 2])\n    // [1, 2, 3, 3, 3, 4, 4]\n    def rollingMax(numbers :\
  \ List[Long]) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n\
  \    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong,\
  \ 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong,\
  \ 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong,\
  \ 100l.toLong, 100l.toLong))));\n    }\n\n}\n"
completions: ["        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, max.getOrElse(x, 0) + x))\n        val result: List[Long] = new\
    \ mutable.ArrayBuffer[Long]()\n        for(x <- max.keySet) {\n            val\
    \ maxValue = max.get(x)\n            val currentIndex = numbers.indexOf(x)\n \
    \           if(currentIndex > 0) {\n                val lastValue = numbers(currentIndex\
    \ - 1)\n                if(maxValue > lastValue) {\n                    result.add(maxValue)\n\
    \                }\n            }\n        }\n        result", "        val max\
    \ = new mutable.ListBuffer[Long]()\n        val rollingMax = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => {\n            rollingMax.append(x)\n          \
    \  max.append(x)\n        })\n        rollingMax.foreach(x => {\n            if\
    \ (max.contains(x)) {\n                max.remove(x)\n                rollingMax.append(x)\n\
    \            }\n        })\n        rollingMax.toList", "        val result =\
    \ new mutable.ListBuffer[Long]()\n        var max = 0L\n        var maxIndex =\
    \ 0\n        var i = 0\n        while (i < numbers.length) {\n            max\
    \ = numbers(i)\n            while (i < numbers.length && numbers(i) <= max) {\n\
    \                i += 1\n            }\n            if (i < numbers.length) {\n\
    \                result.add(max)\n                maxIndex = i\n            }\n\
    \        }\n        result.toList", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            val maxKey = max.max.key\n\
    \            if (maxKey == null || n < maxKey) {\n                max.put(n, n)\n\
    \            } else {\n                val maxValue = max.max.value\n        \
    \        if (maxValue < n) {\n                    max.put(n, maxValue)\n     \
    \           } else {\n                    val maxKeyValue = max.max.key\n    \
    \                if (maxKeyValue < n) {\n                        max.put(maxKeyValue,\
    \ n)\n                    } else {\n                        max.put(n, maxValue)\n\
    \                    }\n                }\n            }\n        }\n        max.values.toList",
  "        val max = new mutable.ListBuffer[Long]()\n        val maxIndex = new mutable.ListBuffer[Int]()\n\
    \        numbers.foreach { number =>\n            if (number.toLong > max.last)\
    \ {\n                max += number\n                maxIndex += number\n     \
    \       }\n        }\n        val maxIndex = maxIndex.toList\n        val maxIndex\
    \ = maxIndex.sortWith(_ < _)\n        val maxIndex = maxIndex.drop(maxIndex.size\
    \ - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n       \
    \ val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex\
    \ = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size\
    \ - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n       \
    \ val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex\
    \ = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size\
    \ - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n       \
    \ val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex\
    \ = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size\
    \ - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n       \
    \ val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex\
    \ = maxIndex.drop(maxIndex.size - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size\
    \ - maxIndex.last)\n        val maxIndex = maxIndex.drop(maxIndex.size - maxIndex.last)\n\
    \        val maxIndex = maxIndex.drop(maxIndex.size - ", "        val max = new\
    \ mutable.HashMap[Long, Long]()\n        val rollingMax = new mutable.ArrayList[Long]()\n\
    \        numbers.foreach { n =>\n            val maxKey = max.max(n) + n\n   \
    \         if (maxKey > rollingMax.last)\n                rollingMax.clear()\n\
    \            rollingMax.add(maxKey)\n            max.put(maxKey, maxKey)\n   \
    \     }\n        rollingMax.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax.clear()\n       \
    \     rollingMax.push(number)\n            rollingMax.foreach { rollingMax =>\n\
    \                val maxIndex = rollingMax.lastIndex\n                rollingMax.drop(maxIndex).foreach\
    \ { rollingMax =>\n                    rollingMax.lastOption.getOrElse(rollingMax.last).max(rollingMax.lastOption.getOrElse(rollingMax.last))\n\
    \                }\n            }\n        }\n        rollingMax.toList", "  \
    \      val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            val maxKey = max.max.key\n            if (maxKey == null ||\
    \ n > maxKey) {\n                max.put(n.toLong, n)\n            } else {\n\
    \                max.put(maxKey, n)\n            }\n        }\n        val result\
    \ = new mutable.ArrayList[Long]()\n        max.foreach { case (k, v) =>\n    \
    \        result += v\n        }\n        result", "        val max = new mutable.HashMap[Long,\
    \ Long]()\n        numbers.foreach { n =>\n            if (max.contains(n)) {\n\
    \                max += n\n            } else {\n                max += (n, Long.MaxValue)\n\
    \            }\n        }\n        val result = new mutable.ListBuffer[Long]()\n\
    \        max.foreach { case (k, v) =>\n            if (v > result.last) result\
    \ += v\n        }\n        result.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        val rollingMax = new mutable.ListBuffer[Long]()\n        numbers.foreach(x\
    \ => {\n            rollingMax.append(x)\n            if (rollingMax.size > max.size)\
    \ {\n                max.clear()\n                max.append(rollingMax.max)\n\
    \                rollingMax.clear()\n            }\n        })\n        max.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            if (max.containsKey(n)) {\n                max.update(n, max(max(n),\
    \ n))\n            } else {\n                max.update(n, n)\n            }\n\
    \        }\n        max.values.toList", "        val max = new mutable.ListBuffer[Long]()\n\
    \        var maxIndex = 0\n        var maxValue = numbers(0)\n        numbers.foreach\
    \ { number =>\n            if (number > maxValue) {\n                maxValue\
    \ = number\n                maxIndex = 0\n            }\n            if (number\
    \ == maxValue) {\n                max += number\n                maxIndex += 1\n\
    \            }\n        }\n        max += maxValue\n        max.toList", "   \
    \     val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach { number\
    \ =>\n            val max = number.max\n            max match {\n            \
    \    case Some(max) => max.foreach { max =>\n                    max.foreach {\
    \ max =>\n                        max.foreach { max =>\n                     \
    \       max.foreach { max =>\n                                max.foreach { max\
    \ =>\n                                    max.foreach { max =>\n             \
    \                           max.foreach { max =>\n                           \
    \                 max.foreach { max =>\n                                     \
    \           max.foreach { max =>\n                                           \
    \         max.foreach { max =>\n                                             \
    \           max.foreach { max =>\n                                           \
    \                 max.foreach { max =>\n                                     \
    \                           max.foreach { max =>\n                           \
    \                                         max.foreach { max =>\n             \
    \                                                           max.foreach { max\
    \ =>\n                                                                       \
    \     max.foreach { max =>\n                                                 \
    \                               max.foreach { max =>\n                       \
    \                                                             max.foreach { max\
    \ =>\n                                                                       \
    \                 max.foreach { max =>\n                                     \
    \                                                       max.foreach { max =>\n\
    \                                                                            \
    \                    max.foreach { max =>\n                                  \
    \                                                                  max.foreach\
    \ { max =>\n                                                                 \
    \                                       max.foreach { max =>\n               \
    \                                                                            \
    \                 max.foreach { max =>\n                                     \
    \                                                                           max.foreach\
    \ { max =>\n                                                                 \
    \                                                   max.foreach { max =>\n   \
    \                                                                            \
    \                                         max.foreach { max =>\n             \
    \                                                                            \
    \                                   max.foreach { max =>\n                   \
    \                                                                            \
    \                                 max.foreach { max =>\n                     \
    \                                                                            \
    \                                   max.foreach { max =>\n                   \
    \                                                                            \
    \                                         max.foreach { max =>\n             \
    \                                                                            \
    \                                                   max.foreach { max =>\n   \
    \                                                                            \
    \                                                                 max.foreach\
    \ { max =>\n                                                                 \
    \                                                                            \
    \       max.foreach { max =>\n                                               \
    \                                                                            \
    \                             max.foreach { max =>\n                         \
    \                                                                            \
    \                                                       max.foreach { max =>\n\
    \                                                                            \
    \                                                                            \
    \        max.foreach { max =>\n                                              \
    \                                                                            \
    \                                          max.foreach { max =>\n            \
    \                                                                            \
    \                                                                            \
    \    max.foreach { max =>\n                                                  \
    \                                                                            \
    \                                              max.foreach { max =>\n        \
    \                                                                            \
    \                                                                            \
    \                max.foreach { max =>\n                                      \
    \                                                                            \
    \                                                                  max.foreach\
    \ { max =>\n                                                                 \
    \                                                                            \
    \                                           max.foreach { max =>\n           \
    \                                                                            \
    \                                                                            \
    \                         max.foreach { max =>\n                             \
    \                                                                            \
    \                                                                            \
    \           max.foreach { max =>\n                                           \
    \                                                                            \
    \                                                                            \
    \ max.foreach { max =>\n                                                     \
    \                                                                            \
    \                                                                       max.foreach\
    \ { max =>\n                                                                 \
    \                                                                            \
    \                                                               max.foreach {\
    \ max =>\n                                                                   \
    \                                                                            \
    \                                                                 max.foreach\
    \ { max =>\n                                                                 \
    \                                                                            \
    \                                                                       max.foreach\
    \ { max =>\n                                                                 \
    \                                                                            \
    \                                                                           max.foreach\
    \ { max =>\n                                                                ",
  "        val max = new mutable.ListBuffer[Long]()\n        var maxIndex = 0\n  \
    \      var currentMax = 0L\n        var currentMaxIndex = 0\n        var currentMaxIndex2\
    \ = 0\n        var currentMaxIndex3 = 0\n        var currentMaxIndex4 = 0\n  \
    \      var currentMaxIndex5 = 0\n        var currentMaxIndex6 = 0\n        var\
    \ currentMaxIndex7 = 0\n        var currentMaxIndex8 = 0\n        var currentMaxIndex9\
    \ = 0\n        var currentMaxIndex10 = 0\n        var currentMaxIndex11 = 0\n\
    \        var currentMaxIndex12 = 0\n        var currentMaxIndex13 = 0\n      \
    \  var currentMaxIndex14 = 0\n        var currentMaxIndex15 = 0\n        var currentMaxIndex16\
    \ = 0\n        var currentMaxIndex17 = 0\n        var currentMaxIndex18 = 0\n\
    \        var currentMaxIndex19 = 0\n        var currentMaxIndex20 = 0\n      \
    \  var currentMaxIndex21 = 0\n        var currentMaxIndex22 = 0\n        var currentMaxIndex23\
    \ = 0\n        var currentMaxIndex24 = 0\n        var currentMaxIndex25 = 0\n\
    \        var currentMaxIndex26 = 0\n        var currentMaxIndex27 = 0\n      \
    \  var currentMaxIndex28 = 0\n        var currentMaxIndex29 = 0\n        var currentMaxIndex30\
    \ = 0\n        var currentMaxIndex31 = 0\n        var currentMaxIndex32 = 0\n\
    \        var currentMaxIndex33 = 0\n        var currentMaxIndex34 = 0\n      \
    \  var currentMaxIndex35 = 0\n        var currentMaxIndex36 = 0\n        var currentMaxIndex37\
    \ = 0\n        var currentMaxIndex38 = 0\n        var currentMaxIndex39 = 0\n\
    \        var currentMaxIndex40 = 0\n        var currentMaxIndex41 = 0\n      \
    \  var currentMaxIndex42 = 0\n        var currentMaxIndex43 = 0\n        var currentMaxIndex44\
    \ = 0\n        var currentMaxIndex45 = 0\n        var currentMaxIndex46 = 0\n\
    \        var currentMaxIndex47 = 0\n        var currentMaxIndex48 = 0\n      \
    \  var currentMaxIndex49 = 0\n        var currentMaxIndex50 = 0\n        var currentMaxIndex51\
    \ = 0\n        var currentMaxIndex52 = 0\n        var currentMaxIndex53 = 0\n\
    \        var currentMaxIndex54 = 0\n        var currentMaxIndex55 = 0\n      \
    \  var currentMaxIndex56 = 0\n        var currentMaxIndex57 = 0\n        var currentMaxIndex58\
    \ = 0\n        var currentMaxIndex59 = 0\n        var currentMaxIndex60 = 0\n\
    \        var currentMaxIndex61 = 0\n        var currentMaxIndex62 = 0\n      \
    \  var currentMaxIndex63 = 0\n        var currentMaxIndex64 = 0\n        var currentMaxIndex65\
    \ = 0\n        var currentMaxIndex66 = 0\n        var currentMaxIndex67 = 0\n\
    \        var currentMaxIndex68 = 0\n        var currentMaxIndex69 = 0\n      \
    \  var currentMaxIndex70 = 0", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        val rollingMaxIndex = mutable.ListBuffer.empty[Int]\n        numbers.foreach\
    \ { number =>\n            if (rollingMaxIndex.contains(number)) {\n         \
    \       rollingMax.updated(rollingMaxIndex.last, number)\n            } else {\n\
    \                rollingMax.updated(rollingMaxIndex.last, number)\n          \
    \      rollingMaxIndex += number\n            }\n        }\n        rollingMax.toList",
  "        val maxes = mutable.ArrayBuffer.empty[Long]\n        val maxesIndex = mutable.ArrayBuffer.empty[Int]\n\
    \        numbers.foreach { number =>\n            val index = maxes.size\n   \
    \         maxes += number\n            maxesIndex += index\n        }\n      \
    \  val maxesIndex = maxesIndex.toList\n        val maxesSize = maxes.size\n  \
    \      val maxesIndex = maxesIndex.sortBy(-_)\n        val maxesSize = maxesIndex.size\n\
    \        val maxesIndex = maxesIndex.drop(maxesSize - maxesIndex.size)\n     \
    \   val maxesSize = maxesIndex.size\n        val maxesIndex = maxesIndex.drop(maxesSize\
    \ - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n        val maxesIndex\
    \ = maxesIndex.drop(maxesSize - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n\
    \        val maxesIndex = maxesIndex.drop(maxesSize - maxesIndex.size)\n     \
    \   val maxesSize = maxesIndex.size\n        val maxesIndex = maxesIndex.drop(maxesSize\
    \ - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n        val maxesIndex\
    \ = maxesIndex.drop(maxesSize - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n\
    \        val maxesIndex = maxesIndex.drop(maxesSize - maxesIndex.size)\n     \
    \   val maxesSize = maxesIndex.size\n        val maxesIndex = maxesIndex.drop(maxesSize\
    \ - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n        val maxesIndex\
    \ = maxesIndex.drop(maxesSize - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n\
    \        val maxesIndex = maxesIndex.drop(maxesSize - maxesIndex.size)\n     \
    \   val maxesSize = maxesIndex.size\n        val maxesIndex = maxesIndex.drop(maxesSize\
    \ - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n        val maxesIndex\
    \ = maxesIndex.drop(maxesSize - maxesIndex.size)\n        val maxesSize = maxesIndex.size\n\
    \        val maxesIndex = maxesIndex.drop(maxesSize - maxesIndex.size)\n     \
    \   val maxesSize = maxesIndex.size\n        val maxesIndex = maxesIndex.", " \
    \       val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach(x\
    \ => max.put(x, math.max(max.getOrElse(x, 0), x)))\n        max.values.toList",
  "        val maxes = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number\
    \ =>\n            val maxIndex = maxes.indexWhere(_ > number)\n            if\
    \ (maxIndex == -1) {\n                maxes += number\n            } else {\n\
    \                maxes(maxIndex) = max(maxes(maxIndex), number)\n            }\n\
    \        }\n        maxes.toList", "        val rollingMax = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach { number =>\n            rollingMax.append(number)\n\
    \            rollingMax.lastOption\n                .foreach { rollingMax =>\n\
    \                    if (number > rollingMax) {\n                        rollingMax\
    \ = number\n                    }\n                }\n        }\n        rollingMax.toList",
  "        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach {\
    \ n =>\n            val maxKey = max.minKey\n            if (maxKey == null ||\
    \ n < maxKey) {\n                max += n -> n\n            }\n        }\n   \
    \     val maxKeys = max.keySet\n        val maxValues = max.values\n        val\
    \ maxKeysAndValues = maxKeys.zip(maxValues)\n        val maxKeysAndValuesSorted\
    \ = maxKeysAndValues.sortBy(_._1).reverse\n        val maxKeysAndValuesSortedWithMax\
    \ = maxKeysAndValuesSorted.takeWhile(_._2 > 0)\n        val maxKeysAndValuesSortedWithMaxWithMax\
    \ = maxKeysAndValuesSortedWithMax.takeWhile(_._2 == maxKeysAndValuesSortedWithMax.last._2)\n\
    \        val maxKeysAndValuesSortedWithMaxWithMaxWithMax = maxKeysAndValuesSortedWithMaxWithMax.takeWhile(_._2\
    \ == maxKeysAndValuesSortedWithMaxWithMax.last._2)\n        val maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMax\
    \ = maxKeysAndValuesSortedWithMaxWithMaxWithMax.takeWhile(_._2 == maxKeysAndValuesSortedWithMaxWithMaxWithMax.last._2)\n\
    \        val maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMax = maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMax.takeWhile(_._2\
    \ == maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMax.last._2)\n        val\
    \ maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMaxWithMax = maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMax.takeWhile(_._2\
    \ == maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMax.last._2)\n    \
    \    val maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMaxWithMax = maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMax.takeWhile(_._2\
    \ == maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMax.last._2)\n    \
    \    val maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMaxWithMax = maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMaxWithMax.takeWhile(_._2\
    \ == maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMaxWithMaxWithMax.last._2)\n\
    \        val maxKeysAndValuesSortedWithMaxWithMaxWithMaxWithMax"]
stop_tokens:
- "\n    }\n"
