language: scala
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringBuilder\
    \ = new StringBuilder(xorBitsStringLength)\n        for (i<-xorBitsStringLength\
    \ to 0) {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n\
    \        }\n        xorBitsStringBuilder.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdo4_t3_j.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val aLen = aArray.length\n        val bLen = bArray.length\n\
    \        val xorArray = new Array[Char](aLen + bLen)\n        val xorLen = xorArray.length\n\
    \        val xorResult = new StringBuilder(xorLen)\n        var i = 0\n      \
    \  while (i < aLen && i < bLen) {\n            xorArray(i) = aArray(i) xor bArray(i)\n\
    \            i += 1\n        }\n        while (i < aLen) {\n            xorArray(i)\
    \ = aArray(i)\n            i += 1\n        }\n        while (i < bLen) {\n   \
    \         xorArray(i) = bArray(i)\n            i += 1\n        }\n        xorResult.append(xorArray)\n\
    \        xorResult.toString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnz69wiqs.scala:18:36 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n        for(i\
    \ <- 0 until xorArray.length)\n            xorArray(i) = (aArray(i) XOR bArray(i)).toChar\n\
    \        new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdmdnnsy4.scala:13:37 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = (aArray(i) XOR bArray(i)).toChar\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val result = xorBitsString.reverse\n        return result\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp09vf4jrq.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = new mutable.StringBuilder\n        val xor =\
    \ mutable.BitSet(b.length)\n        val xorResult = mutable.BitSet(b.length)\n\
    \        val xorResult2 = mutable.BitSet(b.length)\n        val xorResult3 = mutable.BitSet(b.length)\n\
    \        val xorResult4 = mutable.BitSet(b.length)\n        val xorResult5 = mutable.BitSet(b.length)\n\
    \        val xorResult6 = mutable.BitSet(b.length)\n        val xorResult7 = mutable.BitSet(b.length)\n\
    \        val xorResult8 = mutable.BitSet(b.length)\n        val xorResult9 = mutable.BitSet(b.length)\n\
    \        val xorResult10 = mutable.BitSet(b.length)\n        val xorResult11 =\
    \ mutable.BitSet(b.length)\n        val xorResult12 = mutable.BitSet(b.length)\n\
    \        val xorResult13 = mutable.BitSet(b.length)\n        val xorResult14 =\
    \ mutable.BitSet(b.length)\n        val xorResult15 = mutable.BitSet(b.length)\n\
    \        val xorResult16 = mutable.BitSet(b.length)\n        val xorResult17 =\
    \ mutable.BitSet(b.length)\n        val xorResult18 = mutable.BitSet(b.length)\n\
    \        val xorResult19 = mutable.BitSet(b.length)\n        val xorResult20 =\
    \ mutable.BitSet(b.length)\n        val xorResult21 = mutable.BitSet(b.length)\n\
    \        val xorResult22 = mutable.BitSet(b.length)\n        val xorResult23 =\
    \ mutable.BitSet(b.length)\n        val xorResult24 = mutable.BitSet(b.length)\n\
    \        val xorResult25 = mutable.BitSet(b.length)\n        val xorResult26 =\
    \ mutable.BitSet(b.length)\n        val xorResult27 = mutable.BitSet(b.length)\n\
    \        val xorResult28 = mutable.BitSet(b.length)\n        val xorResult29 =\
    \ mutable.BitSet(b.length)\n        val xorResult30 = mutable.BitSet(b.length)\n\
    \        val xorResult31 = mutable.BitSet(b.length)\n        val xorResult32 =\
    \ mutable.BitSet(b.length)\n        val xorResult33 = mutable.BitSet(b.length)\n\
    \        val xorResult34 = mutable.BitSet(b.length)\n        val xorResult35 =\
    \ mutable.BitSet(b.length)\n        val xorResult36 = mutable.BitSet(b.length)\n\
    \        val xorResult37 = mutable.BitSet(b.length)\n        val xorResult38 =\
    \ mut\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppief5lbg.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppief5lbg.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmppief5lbg.scala:13:24 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.BitSet(b.length)\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmppief5lbg.scala:14:25 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmppief5lbg.scala:15:25 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmppief5lbg.scala:16:25 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mxorResult4\e[0m = mutable.Bit"
  stdout: ''
  timestamp: 1659793114
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp32_cd089.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = xorBits.toBinaryString\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringWithZeros\
    \ = Array.fill(xorBitsStringLength)(0)\n        xorBitsStringWithZeros ++ xorBitsString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpim7kvmj6.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793114
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        val xorArrayIndex = 0\n        for (i <- 0 until aArray.length)\
    \ xorArray(i) = aArray(i) xor bArray(i)\n        new String(xorArray)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2r_5c5_r.scala:13:65 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until aArray.length)\
    \ xorArray(i) = aArray(i) xor bArray(i)\n\e[31m\e[31m   |\e[0m               \
    \                                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                      value xor is not a member of Char\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        val xor = mutable.ArrayBuffer.fill(aArray.length)(0)\n        val xor2\
    \ = mutable.ArrayBuffer.fill(bArray.length)(0)\n        for(i <- 0 until aArray.length)\n\
    \            xor(i) = aArray(i) xor bArray(i)\n        for(i <- 0 until xor.length)\n\
    \            result.append(xor(i))\n        return result.toString\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphcwhu5dt.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphcwhu5dt.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.ArrayBuffer.fill(aArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmphcwhu5dt.scala:13:19 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxor2\e[0m = mutable.ArrayBuffer.fill(bArray.length)(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer[String]()\n        val xorList2\
    \ = mutable.ListBuffer[String]()\n        val xorList3 = mutable.ListBuffer[String]()\n\
    \        val xorList4 = mutable.ListBuffer[String]()\n        val xorList5 = mutable.ListBuffer[String]()\n\
    \        val xorList6 = mutable.ListBuffer[String]()\n        val xorList7 = mutable.ListBuffer[String]()\n\
    \        val xorList8 = mutable.ListBuffer[String]()\n        val xorList9 = mutable.ListBuffer[String]()\n\
    \        val xorList10 = mutable.ListBuffer[String]()\n        val xorList11 =\
    \ mutable.ListBuffer[String]()\n        val xorList12 = mutable.ListBuffer[String]()\n\
    \        val xorList13 = mutable.ListBuffer[String]()\n        val xorList14 =\
    \ mutable.ListBuffer[String]()\n        val xorList15 = mutable.ListBuffer[String]()\n\
    \        val xorList16 = mutable.ListBuffer[String]()\n        val xorList17 =\
    \ mutable.ListBuffer[String]()\n        val xorList18 = mutable.ListBuffer[String]()\n\
    \        val xorList19 = mutable.ListBuffer[String]()\n        val xorList20 =\
    \ mutable.ListBuffer[String]()\n        val xorList21 = mutable.ListBuffer[String]()\n\
    \        val xorList22 = mutable.ListBuffer[String]()\n        val xorList23 =\
    \ mutable.ListBuffer[String]()\n        val xorList24 = mutable.ListBuffer[String]()\n\
    \        val xorList25 = mutable.ListBuffer[String]()\n        val xorList26 =\
    \ mutable.ListBuffer[String]()\n        val xorList27 = mutable.ListBuffer[String]()\n\
    \        val xorList28 = mutable.ListBuffer[String]()\n        val xorList29 =\
    \ mutable.ListBuffer[String]()\n        val xorList30 = mutable.ListBuffer[String]()\n\
    \        val xorList31 = mutable.ListBuffer[String]()\n        val xorList32 =\
    \ mutable.ListBuffer[String]()\n        val xorList33 = mutable.ListBuffer[String]()\n\
    \        val xorList34 = mutable.ListBuffer[String]()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpstv8p1k9.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpstv8p1k9.scala:12:23 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxorList2\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpstv8p1k9.scala:13:23 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorList3\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpstv8p1k9.scala:14:23 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorList4\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpstv8p1k9.scala:15:23 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorList5\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpstv8p1k9.scala:16:23 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m    "
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpty4pgdhf.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer[String]()\n        val xorListSize\
    \ = mutable.ListBuffer[Int]()\n        var xorCount = 0\n        var xorCount2\
    \ = 0\n        var xorCount3 = 0\n        var xorCount4 = 0\n        var xorCount5\
    \ = 0\n        var xorCount6 = 0\n        var xorCount7 = 0\n        var xorCount8\
    \ = 0\n        var xorCount9 = 0\n        var xorCount10 = 0\n        var xorCount11\
    \ = 0\n        var xorCount12 = 0\n        var xorCount13 = 0\n        var xorCount14\
    \ = 0\n        var xorCount15 = 0\n        var xorCount16 = 0\n        var xorCount17\
    \ = 0\n        var xorCount18 = 0\n        var xorCount19 = 0\n        var xorCount20\
    \ = 0\n        var xorCount21 = 0\n        var xorCount22 = 0\n        var xorCount23\
    \ = 0\n        var xorCount24 = 0\n        var xorCount25 = 0\n        var xorCount26\
    \ = 0\n        var xorCount27 = 0\n        var xorCount28 = 0\n        var xorCount29\
    \ = 0\n        var xorCount30 = 0\n        var xorCount31 = 0\n        var xorCount32\
    \ = 0\n        var xorCount33 = 0\n        var xorCount34 = 0\n        var xorCount35\
    \ = 0\n        var xorCount36 = 0\n        var xorCount37 = 0\n        var xorCount38\
    \ = 0\n        var xorCount39 = 0\n        var xorCount40 = 0\n        var xorCount41\
    \ = 0\n        var xorCount42 = 0\n        var xorCount43 = 0\n        var xorCount44\
    \ = 0\n        var xorCount45 = 0\n        var xorCount46 = 0\n        var xorCount47\
    \ = 0\n        var xorCount48 = 0\n        var xorCount49 = 0\n        var xorCount50\
    \ = 0\n        var xorCount51 = 0\n        var xorCount52 = 0\n        var xorCount53\
    \ = 0\n        var xorCount54 = 0\n        var xorCount55 = 0\n        var xorCount56\
    \ = 0\n        var xorCount57 = 0\n        var xorCount58 = 0\n        var xorCount59\
    \ = 0\n        var xorCount60 = 0\n        var xorCount61 = 0\n        var xorCount62\
    \ = 0\n        var xorCount63 = 0\n        var xorCount64 = 0\n        var xorCount65\
    \ = 0\n        var xorCount66 = 0\n        var xorCount67 = 0\n        var xorCount68\
    \ = 0\n        var xorCount69 = 0\n        var xorCount70 = 0\n        var xorCount71\
    \ = 0\n        var xorCount72 = 0\n        var xorCount73 = 0\n        var xorCount74\
    \ = 0\n        var xorCount75 = 0\n        var xorCount76 = 0\n        var xorCount77\
    \ = 0\n        var xorCount78 = 0\n        var xor\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcxsek5nd.scala:92:4 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcxsek5nd.scala:11:22\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mxorList\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcxsek5nd.scala:12:26\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mxorListSize\e[0m = mutable.ListBuffer[\e[35mInt\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpcxsek5nd.scala:92:5 ---------------------\e[0m\e[0m\n\e[31m92\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpty4pgdhf.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val xorBitsStringWithLeadingZeros = xorBitsStringWithLeadingZeros.substring(0,\
    \ xorBitsStringWithLeadingZeros.length - 1)\n        xorBitsStringWithLeadingZeros\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprzd9rjzx.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsStringWithLeadingZeros.substring(\e[31m0\e[0m, xorBitsStringWithLeadingZeros.length\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithLeadingZeros is already defined as \e[33mvalue\e\
    [0m \e[35mxorBitsStringWithLeadingZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprzd9rjzx.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmprzd9rjzx.scala:13:58 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n3 errors found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n \
    \       val bList = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        val xor = mutable.BitSet(b.length)\n        val xorResult = mutable.BitSet(b.length)\n\
    \        val xorResult2 = mutable.BitSet(b.length)\n        val xorResult3 = mutable.BitSet(b.length)\n\
    \        val xorResult4 = mutable.BitSet(b.length)\n        val xorResult5 = mutable.BitSet(b.length)\n\
    \        val xorResult6 = mutable.BitSet(b.length)\n        val xorResult7 = mutable.BitSet(b.length)\n\
    \        val xorResult8 = mutable.BitSet(b.length)\n        val xorResult9 = mutable.BitSet(b.length)\n\
    \        val xorResult10 = mutable.BitSet(b.length)\n        val xorResult11 =\
    \ mutable.BitSet(b.length)\n        val xorResult12 = mutable.BitSet(b.length)\n\
    \        val xorResult13 = mutable.BitSet(b.length)\n        val xorResult14 =\
    \ mutable.BitSet(b.length)\n        val xorResult15 = mutable.BitSet(b.length)\n\
    \        val xorResult16 = mutable.BitSet(b.length)\n        val xorResult17 =\
    \ mutable.BitSet(b.length)\n        val xorResult18 = mutable.BitSet(b.length)\n\
    \        val xorResult19 = mutable.BitSet(b.length)\n        val xorResult20 =\
    \ mutable.BitSet(b.length)\n        val xorResult21 = mutable.BitSet(b.length)\n\
    \        val xorResult22 = mutable.BitSet(b.length)\n        val xorResult23 =\
    \ mutable.BitSet(b.length)\n        val xorResult24 = mutable.BitSet(b.length)\n\
    \        val xorResult25 = mutable.BitSet(b.length)\n        val xorResult26 =\
    \ mutable.BitSet(b.length)\n        val xorResult27 = mutable.BitSet(b.length)\n\
    \        val xorResult28 = mutable.BitSet(b.length)\n        val xorResult29 =\
    \ mutable.BitSet(b.length)\n        val xorResult30 = mutable.BitSet(b.length)\n\
    \        val xorResult31 = mutable.BitSet(b.length)\n        val xorResult32 =\
    \ mutable.BitSet(b.length)\n        val xorResult33 = mutable.BitSet(b.length)\n\
    \        val xorResult34 = mutable.BitSet(b.length)\n        val xorResult35 =\
    \ mutable.BitSet(b.length)\n        val xorResult36 = mutable.BitSet(b.length)\n\
    \        val xorResult37 = mutable.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprvaxx201.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmprvaxx201.scala:11:25 ------------------------\e[0m\e[0m\n\e[31m11\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.StringBuilder\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmprvaxx201.scala:12:18 ------------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmprvaxx201.scala:13:24 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.BitSet(b.length)\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmprvaxx201.scala:14:25 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmprvaxx201.scala:15:25 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation availa"
  stdout: ''
  timestamp: 1659793115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(x => x._1 ^ x._2)\n        val xorString =\
    \ xorArray.toString.map(_.toChar).mkString\n        xorString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnwl0xgvk.scala:18)\n\tat Problem.main(tmpnwl0xgvk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793116
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        aList.zip(\n\
    \            bList.zip(aList.tail).map { case (a, b) => a ^ b }\n        ).foreach\
    \ { x => xorList += x._1 }\n        xorList.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw65d33a0.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n        val\
    \ xorArrayIndex = 0\n        for (i <- 0 until b.length) {\n            xorArray(xorArrayIndex)\
    \ = aArray(i) xor bArray(i)\n            xorArrayIndex += 1\n        }\n     \
    \   new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3simx1hs.scala:14:48 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(xorArrayIndex) = aArray(i) xor bArray(i)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                      value xor is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3simx1hs.scala:15:26\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m            xorArrayIndex\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        value += is not a member of Int - did you mean xorArrayIndex.!=?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val result = xorBits.toBinaryString\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbz3f1rq1.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        var result = 0\n        var i = 0\n        while (i < a.length) {\n \
    \           result ^= aBits & (1 << i)\n            i += 1\n        }\n      \
    \  i = 0\n        while (i < b.length) {\n            result ^= bBits & (1 <<\
    \ i)\n            i += 1\n        }\n        return Integer.toBinaryString(result).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqfjb84oo.scala:25)\n\tat Problem.main(tmpqfjb84oo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = aList.zip(bList).map { case (x, y) => x ^ y }\n\
    \        result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        var result = \"\"\n        var carry = 0\n        for\
    \ (i <- 0 until aArray.length) {\n            val aChar = aArray(i)\n        \
    \    val bChar = bArray(i)\n            val aBit = aChar & 1\n            val\
    \ bBit = bChar & 1\n            val aAndBBit = aBit & bBit\n            val aOrBBit\
    \ = aBit | bBit\n            val aAndBChar = aAndBBit == 0 ? aChar : aAndBChar\n\
    \            val aOrBChar = aOrBBit == 0 ? aChar : aOrBChar\n            val aAndBCharArray\
    \ = aAndBChar.toCharArray\n            val aOrBCharArray = aOrBChar.toCharArray\n\
    \            val aAndBCharArrayLength = aAndBCharArray.length\n            val\
    \ aOrBCharArrayLength = aOrBCharArray.length\n            val aAndBCharArrayLength2\
    \ = aAndBCharArrayLength * 2\n            val aOrBCharArrayLength2 = aOrBCharArrayLength\
    \ * 2\n            val aAndBCharArrayLength3 = aAndBCharArrayLength * 3\n    \
    \        val aOrBCharArrayLength3 = aOrBCharArrayLength * 3\n            val aAndBCharArrayLength4\
    \ = aAndBCharArrayLength * 4\n            val aOrBCharArrayLength4 = aOrBCharArrayLength\
    \ * 4\n            val aAndBCharArrayLength5 = aAndBCharArrayLength * 5\n    \
    \        val aOrBCharArrayLength5 = aOrBCharArrayLength * 5\n            val aAndBCharArrayLength6\
    \ = aAndBCharArrayLength * 6\n            val aOrBCharArrayLength6 = aOrBCharArrayLength\
    \ * 6\n            val aAndBCharArrayLength7 = aAndBCharArrayLength * 7\n    \
    \        val aOrBCharArrayLength7 = aOrBCharArrayLength * 7\n            val aAndBCharArrayLength8\
    \ = aAndBCharArrayLength * 8\n            val aOrBCharArrayLength8 = aOrBCharArrayLength\
    \ * 8\n            val aAndBCharArrayLength9 = aAndBCharArrayLength * 9\n    \
    \        val aOrBCharArrayLength9 = aOrBCharArrayLength * 9\n            val aAndBCharArrayLength10\
    \ = aAndBCharArrayLength * 10\n            val aOrBCharArrayLength10\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyg0esc8f.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyg0esc8f.scala:52:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m52 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpyg0esc8f.scala:20:52 ------------------------\e[0m\e[0m\n\
    \e[31m20 |\e[0m            \e[33mval\e[0m \e[36maAndBChar\e[0m = aAndBBit == \e\
    [31m0\e[0m ? aChar : \e[35maAndBChar\e[0m\n\e[31m\e[31m   |\e[0m             \
    \                                       ^^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                         Not found: type aAndBChar\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyg0esc8f.scala:20:42 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36maAndBChar\e[0m = aAndBBit\
    \ == \e[31m0\e[0m ? aChar : \e[35maAndBChar\e[0m\n\e[31m\e[31m   |\e[0m      \
    \                                  ^^^\e[0m\n\e[31m   |\e[0m                 \
    \                       value ? is not a member of Int\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpyg0esc8f.scala:21:50 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36maOrBChar\e[0m = aOrBBit ==\
    \ \e[31m0\e[0m ? aChar : \e[35maOrBChar\e[0m\n\e[31m\e[31m   |\e[0m          \
    \                                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                          Not found: type aOrBChar\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyg0esc8f.scala:21:40 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mval\e[0m \e[36maOrBChar\e[0m = aOrBBit\
    \ == \e[31m0\e[0m ? aChar : \e[35maOrBChar\e[0m\n\e[31m\e[31m   |\e[0m       \
    \                               ^^^\e[0m\n\e[31m   |\e[0m                    \
    \                  value ? is not a member of Int\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Er"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer[String]()\n        var i\
    \ = 0\n        while (i < aList.size) {\n            xorList += aList(i) xor bList(i)\n\
    \            i += 1\n        }\n        xorList.toList.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprnmdwuzb.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        var result = \"\"\n        for (i <- 0 until aArray.length)\n\
    \            result += ((aArray(i) XOR bArray(i)) & 1).toChar\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjxw03r0t.scala:13:19 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += ((aArray(i) XOR bArray(i)) & \e\
    [31m1\e[0m).toChar\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m            value += is not a member of String - did you mean String.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjxw03r0t.scala:13:34 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += ((aArray(i) XOR bArray(i)) & \e\
    [31m1\e[0m).toChar\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        value XOR is not a member of Char\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for (i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzouj7ip9.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n        var i\
    \ = 0\n        while (i < aList.size) {\n            xorList += (aList(i) xor\
    \ bList(i))\n            i += 1\n        }\n        xorList.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmj36nxhr.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793117
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        var i = 0\n\
    \        while (i < a.length) {\n            result.append(aArray(i) ^ bArray(i))\n\
    \            i += 1\n        }\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793119
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer[Int]()\n        for(i <-\
    \ 0 until aList.length){\n            xorList += (aList(i) xor bList(i))\n   \
    \     }\n        xorList.toList.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpts310bdq.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl0l6h03q.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        var\
    \ i = 0\n        while (i < aList.size) {\n            xorList += aList(i) xor\
    \ bList(i)\n            i += 1\n        }\n        xorList.mkString\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpls26tqnm.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(x => x._1 xor x._2)\n        val xorString\
    \ = xorArray.toString.map(_.toChar).mkString\n        xorString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprjoi6qlg.scala:13:24 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        ).map(x => x._1 xor x._2)\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^^\e[0m\n\e[31m   |\e[0m                   value xor\
    \ is not a member of Int\n\e[31m\e[31m-- Error: /tmp/tmprjoi6qlg.scala:13:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        ).map(x => x._1 xor x._2)\n\e[31m\e[31m   |\e\
    [0m                                 ^\e[0m\n\e[31m   |\e[0m                  \
    \               No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \                                 where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpty4pgdhf.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n        var\
    \ i = 0\n        while (i < xorArray.length) {\n            xorArray(i) = aArray(i)\
    \ ^ bArray(i)\n            i += 1\n        }\n        xorArray.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7v5jzk35.scala:14:26\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i)\
    \ ^ bArray(i)\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Int\n\e[31m   |\e[0m \
    \                         Required: Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n        var\
    \ i = 0\n        while (i < xorArray.length) {\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        xorArray.toString.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpssx15ggk.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n \
    \       val bList = b.toCharArray.map(_.toInt)\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        var i = 0\n        while (i < aList.length && i < bList.length) {\n \
    \           xorList += (aList(i) xor bList(i))\n            i += 1\n        }\n\
    \        xorList.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj_e7blkg.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793119
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = new StringBuilder\n        var carry = 0\n  \
    \      for(i <- 0 until aList.length){\n            val aChar = aList(i)\n   \
    \         val bChar = bList(i)\n            val xor = aChar xor bChar\n      \
    \      val newCarry = xor and carry\n            carry = newCarry\n          \
    \  result.append(newCarry)\n        }\n        result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp30pve2uq.scala:16:28 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aChar xor\
    \ bChar\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n \
    \       val bList = b.toCharArray.map(_.toInt)\n        val xorList = aList.zip(bList).map(x\
    \ => x._1 xor x._2)\n        val xorString = xorList.map(x => x.toChar).mkString\n\
    \        xorString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb0di8coa.scala:11:53 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = aList.zip(bList).map(\e\
    [36mx\e[0m => x._1 xor x._2)\n\e[31m\e[31m   |\e[0m                          \
    \                      ^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                value xor is not a member of Int\n\e[31m\e[31m-- Error: /tmp/tmpb0di8coa.scala:11:62\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m11 |\e[0m       \
    \ \e[33mval\e[0m \e[36mxorList\e[0m = aList.zip(bList).map(\e[36mx\e[0m => x._1\
    \ xor x._2)\n\e[31m\e[31m   |\e[0m                                           \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \        No ClassTag available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m       \
    \                                   where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val aLen = aList.length\n        val bLen = bList.length\n\
    \        val result = new StringBuilder\n        var i = 0\n        while (i <\
    \ aLen && i < bLen) {\n            if (aList(i) XOR bList(i) == 0) {\n       \
    \         result.append(aList(i))\n                i += 1\n            } else\
    \ {\n                result.append(bList(i))\n                i += 1\n       \
    \     }\n        }\n        while (i < aLen) {\n            result.append(aList(i))\n\
    \            i += 1\n        }\n        while (i < bLen) {\n            result.append(bList(i))\n\
    \            i += 1\n        }\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdakk8lgc.scala:16:25 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mif\e[0m (aList(i) XOR bList(i) == \e\
    [31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        val xorArrayIndex = 0\n        for (i <- 0 until aArray.length)\n\
    \            for (j <- 0 until bArray.length)\n                if (aArray(i) ==\
    \ bArray(j))\n                    xorArray(xorArrayIndex) |= aArray(i)\n     \
    \           xorArrayIndex += 1\n        return new String(xorArray)\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_jidd35_.scala:16:44 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                    xorArray(xorArrayIndex) |= aArray(i)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value |= is not a member of Char - did you mean Char.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_jidd35_.scala:17:30 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                xorArrayIndex += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ += is not a member of Int - did you mean xorArrayIndex.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        for(i <- 0\
    \ until aArray.length)\n            result.append(aArray(i) XOR bArray(i))\n \
    \       return result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmdhkvdbi.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result.append(aArray(i) XOR bArray(i))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toCharArray\n        val bList\
    \ = b.toCharArray\n        val result = new mutable.StringBuilder\n        var\
    \ i = 0\n        while (i < aList.length && i < bList.length) {\n            if\
    \ (aList(i) XOR bList(i) == 1) {\n                result += \"1\"\n          \
    \  } else {\n                result += \"0\"\n            }\n            i +=\
    \ 1\n        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc2qn4rn6.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc2qn4rn6.scala:14:25 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m (aList(i) XOR bList(i) == \e\
    [31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value XOR is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659793120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        xorBitsString.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph4nh4lm7.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793120
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringWithLeadingZeros\
    \ = if (xorBitsStringLength < 4) \"0\" + xorBitsString else xorBitsString\n  \
    \      val xorBitsStringWithTrailingZeros = if (xorBitsStringLength < 4) xorBitsString\
    \ else xorBitsString + \"0\"\n        val xorBitsStringWithLeadingAndTrailingZeros\
    \ = xorBitsStringWithLeadingZeros + xorBitsStringWithTrailingZeros\n        xorBitsStringWithLeadingAndTrailingZeros\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6y6pzc7t.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n        var\
    \ i = 0\n        while (i < xorArray.length) {\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        xorArray.toString.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoiik1f81.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        var result = 0\n        for (i <- 0 until aArray.length)\
    \ {\n            result ^= aArray(i)\n            result ^= bArray(i)\n      \
    \  }\n        Integer.toBinaryString(result)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfbspc9os.scala:19)\n\tat Problem.main(tmpfbspc9os.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_wrrcrkc.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_wrrcrkc.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpty4pgdhf.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        var i = 0\n\
    \        while (i < aArray.length) {\n            result.append(aArray(i) ^ bArray(i))\n\
    \            i += 1\n        }\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793122
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n        val\
    \ xorString = new StringBuilder\n        for(i <- 0 until xorArray.length)\n \
    \           xorArray(i) = aArray(i) xor bArray(i)\n        xorString.append(xorArray)\n\
    \        xorString.toString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm87tlrhy.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        var i = 0\n\
    \        while (i < aArray.length) {\n            result.append(aArray(i) ^ bArray(i))\n\
    \            i += 1\n        }\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793122
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        for\
    \ (i<-0 until aList.length)\n            for (j<-0 until bList.length)\n     \
    \           if (aList(i) == bList(j))\n                    xorList += aList(i)\n\
    \        xorList.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp87onqyvk.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer[String]()\n        for(i\
    \ <- 0 until aList.length){\n            xorList += aList(i) xor bList(i)\n  \
    \      }\n        xorList.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvo9hirmx.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new mutable.StringBuilder\n        var\
    \ i = 0\n        while (i < aArray.length && i < bArray.length) {\n          \
    \  val aChar = aArray(i)\n            val bChar = bArray(i)\n            if (aChar\
    \ != bChar) {\n                result.append(aChar)\n            } else {\n  \
    \              result.append(aChar)\n            }\n            i += 1\n     \
    \   }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp707ti8cr.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793122
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n \
    \       val bList = b.toCharArray.map(_.toInt)\n        val xorList = for {\n\
    \            i <- aList\n            j <- bList\n        } yield {\n         \
    \   val xor = i xor j\n            xor.toChar\n        }\n        xorList.toList.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwl2gbbqj.scala:15:24 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = i xor j\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^\e[0m\n\e[31m   |\e[0m       \
    \               value xor is not a member of Int\n\e[31m\e[31m-- Error: /tmp/tmpwl2gbbqj.scala:17:9\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m      \
    \  }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0m         No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m         where:    B is a type\
    \ variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659793124
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpty4pgdhf.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm48d17v4.scala:12:63 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until aArray.length)\
    \ xorArray += (aArray(i) xor bArray(i))\n\e[31m\e[31m   |\e[0m               \
    \                                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                     value xor is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793124
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793125
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        var result = \"\"\n        var i = 0\n        var j\
    \ = 0\n        while (i < aArray.length && j < bArray.length) {\n            val\
    \ xor = aArray(i) XOR bArray(j)\n            result += (if (xor == 0) '0' else\
    \ '1')\n            i += 1\n            j += 1\n        }\n        result\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpujemcj75.scala:15:32 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aArray(i)\
    \ XOR bArray(j)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      value XOR is not a member of Char\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793124
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toCharArray\n        val bList\
    \ = b.toCharArray\n        val result = new mutable.StringBuilder\n        var\
    \ i = 0\n        while (i < aList.length && i < bList.length) {\n            val\
    \ aChar = aList(i)\n            val bChar = bList(i)\n            if (aChar !=\
    \ bChar) {\n                result.append(aChar)\n            } else {\n     \
    \           result.append(aChar)\n            }\n            i += 1\n        }\n\
    \        return result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaeld24g1.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793123
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        val xor = mutable.BitSet(aArray.length)\n        val xor2 = mutable.BitSet(aArray.length)\n\
    \        val xor3 = mutable.BitSet(aArray.length)\n        val xor4 = mutable.BitSet(aArray.length)\n\
    \        val xor5 = mutable.BitSet(aArray.length)\n        val xor6 = mutable.BitSet(aArray.length)\n\
    \        val xor7 = mutable.BitSet(aArray.length)\n        val xor8 = mutable.BitSet(aArray.length)\n\
    \        val xor9 = mutable.BitSet(aArray.length)\n        val xor10 = mutable.BitSet(aArray.length)\n\
    \        val xor11 = mutable.BitSet(aArray.length)\n        val xor12 = mutable.BitSet(aArray.length)\n\
    \        val xor13 = mutable.BitSet(aArray.length)\n        val xor14 = mutable.BitSet(aArray.length)\n\
    \        val xor15 = mutable.BitSet(aArray.length)\n        val xor16 = mutable.BitSet(aArray.length)\n\
    \        val xor17 = mutable.BitSet(aArray.length)\n        val xor18 = mutable.BitSet(aArray.length)\n\
    \        val xor19 = mutable.BitSet(aArray.length)\n        val xor20 = mutable.BitSet(aArray.length)\n\
    \        val xor21 = mutable.BitSet(aArray.length)\n        val xor22 = mutable.BitSet(aArray.length)\n\
    \        val xor23 = mutable.BitSet(aArray.length)\n        val xor24 = mutable.BitSet(aArray.length)\n\
    \        val xor25 = mutable.BitSet(aArray.length)\n        val xor26 = mutable.BitSet(aArray.length)\n\
    \        val xor27 = mutable.BitSet(aArray.length)\n        val xor28 = mutable.BitSet(aArray.length)\n\
    \        val xor29 = mutable.BitSet(aArray.length)\n        val xor30 = mutable.BitSet(aArray.length)\n\
    \        val xor31 = mutable.BitSet(aArray.length)\n        val xor32 = mutable.BitSet(aArray.length)\n\
    \        val xor33 = mutable.BitSet(aArray.length)\n        val xor34 = mutable.BitSet(aArray.length)\n\
    \        val xor35 = mutable.BitSet\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4z46280g.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4z46280g.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.BitSet(aArray.length)\n\
    \e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4z46280g.scala:13:19 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mxor2\e[0m = mutable.BitSet(aArray.length)\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4z46280g.scala:14:19 ------------------------\e[0m\e[0m\n\e[31m14 |\e\
    [0m        \e[33mval\e[0m \e[36mxor3\e[0m = mutable.BitSet(aArray.length)\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4z46280g.scala:15:19 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mxor4\e[0m = mutable.BitSet(aArray.length)\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4z46280g.scala:16:19 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        \e[33mval\e[0m \e[36mxor5\e[0m = mutable.BitSet(aArray.length)\n\e\
    [31m\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1659793126
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        var i = 0\n\
    \        while (i < aArray.length) {\n            result.append(aArray(i) ^ bArray(i))\n\
    \            i += 1\n        }\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793122
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringBuilder = new StringBuilder(xorBitsString)\n       \
    \ while(xorBitsStringBuilder.length < xorBitsString.length) {\n            xorBitsStringBuilder.insert(xorBitsString.length,\
    \ \"0\")\n        }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3y9mjq92.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp3y9mjq92.scala:17:29 --------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        xorBitsStringBuilder.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793126
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringBuilder\
    \ = new StringBuilder(xorBitsStringLength)\n        for(i <- 0 until xorBitsStringLength)\
    \ {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n      \
    \  }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg1ned3wp.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpg1ned3wp.scala:18:29 --------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        xorBitsStringBuilder.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793126
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        aList.zip(bList).foreach\
    \ { case (aChar, bChar) =>\n            xorList += aChar ^ bChar\n        }\n\
    \        xorList.toList.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcukaoyaq.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793124
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringBuilder\
    \ = new StringBuilder(xorBitsStringLength)\n        xorBitsStringBuilder.append(xorBitsString.substring(0,\
    \ xorBitsStringLength - 1))\n        xorBitsStringBuilder.append(xorBitsString.substring(xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppyhvg79e.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmppyhvg79e.scala:17:29 --------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        xorBitsStringBuilder.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793126
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        xorArray.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0oc_sn_u.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793126
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringBuilder\
    \ = new StringBuilder(xorBitsStringLength)\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.insert(0, xorBitsString)\n        xorBitsStringBuilder.reverse()\n\
    \        xorBitsStringBuilder.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsvbx35us.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpsvbx35us.scala:15:36 -----------------------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e\
    [35mStringBuilder\e[0m: (i: Int): Char\n\e[31m\e[31m-- Error: /tmp/tmpsvbx35us.scala:17:36\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \ xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmissing argument for parameter i of \e[33mmethod\e[0m \e[35mapply\e\
    [0m in \e[33mclass\e[0m \e[35mStringBuilder\e[0m: (i: Int): Char\n3 errors found\n"
  stdout: ''
  timestamp: 1659793127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpty4pgdhf.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        for\
    \ ((x, y) <- aList zip bList) {\n            xorList += x ^ y\n        }\n   \
    \     xorList.toList.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_8i8wqdr.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793125
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_wrrcrkc.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_wrrcrkc.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = aList.zip(bList).map(x => x._1 xor x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7jod0jwg.scala:11:52 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = aList.zip(bList).map(\e\
    [36mx\e[0m => x._1 xor x._2).mkString\n\e[31m\e[31m   |\e[0m                 \
    \                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                       value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        aList.zip(bList).foreach\
    \ { case (aChar, bChar) =>\n            xorList += aChar ^ bChar\n        }\n\
    \        xorList.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9awhttwp.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793125
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        val xorArrayIndex = 0\n        for (i <- 0 until aArray.length)\
    \ xorArray(i) = aArray(i) xor bArray(i)\n        xorArrayIndex\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuunfhrqp.scala:13:65 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until aArray.length)\
    \ xorArray(i) = aArray(i) xor bArray(i)\n\e[31m\e[31m   |\e[0m               \
    \                                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                                      value xor is not a member of Char\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpuunfhrqp.scala:14:8 ---------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        xorArrayIndex\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (xorArrayIndex : Int)\n\e[31m   |\e[0m \
    \       Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        xorBitsStringWithLeadingZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpycrz61ma.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpycrz61ma.scala:13:58 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toIntArray\n        val bBits\
    \ = b.toIntArray\n        val xorBits = Array.ofDim[Int](aBits.length)\n     \
    \   val xorBitsCopy = Array.ofDim[Int](aBits.length)\n        var i = 0\n    \
    \    while (i < aBits.length) {\n            xorBits(i) = aBits(i) xor bBits(i)\n\
    \            i += 1\n        }\n        var j = 0\n        while (j < xorBits.length)\
    \ {\n            xorBitsCopy(j) = xorBits(j)\n            j += 1\n        }\n\
    \        xorBitsCopy.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeukkcqaz.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpeukkcqaz.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793127
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        var result = 0\n        for (i <- 0 until aArray.length)\
    \ {\n            result ^= (aArray(i) ^ bArray(i))\n        }\n        Integer.toBinaryString(result)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpk4a5jdii.scala:18)\n\tat Problem.main(tmpk4a5jdii.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        var result = \"\"\n        val aLen = a.length\n        val bLen = b.length\n\
    \        val aBitsLen = aBits.length\n        val bBitsLen = bBits.length\n  \
    \      val aBitsMask = aBits - 1\n        val bBitsMask = bBits - 1\n        val\
    \ aBitsShift = aLen - aBitsLen\n        val bBitsShift = bLen - bBitsLen\n   \
    \     val aBitsMaskShift = aBitsLen - aBitsShift\n        val bBitsMaskShift =\
    \ bBitsLen - bBitsShift\n        val aBitsMaskShift2 = aBitsLen - aBitsShift -\
    \ 2\n        val bBitsMaskShift2 = bBitsLen - bBitsShift - 2\n        val aBitsMaskShift3\
    \ = aBitsLen - aBitsShift - 3\n        val bBitsMaskShift3 = bBitsLen - bBitsShift\
    \ - 3\n        val aBitsMaskShift4 = aBitsLen - aBitsShift - 4\n        val bBitsMaskShift4\
    \ = bBitsLen - bBitsShift - 4\n        val aBitsMaskShift5 = aBitsLen - aBitsShift\
    \ - 5\n        val bBitsMaskShift5 = bBitsLen - bBitsShift - 5\n        val aBitsMaskShift6\
    \ = aBitsLen - aBitsShift - 6\n        val bBitsMaskShift6 = bBitsLen - bBitsShift\
    \ - 6\n        val aBitsMaskShift7 = aBitsLen - aBitsShift - 7\n        val bBitsMaskShift7\
    \ = bBitsLen - bBitsShift - 7\n        val aBitsMaskShift8 = aBitsLen - aBitsShift\
    \ - 8\n        val bBitsMaskShift8 = bBitsLen - bBitsShift - 8\n        val aBitsMaskShift9\
    \ = aBitsLen - aBitsShift - 9\n        val bBitsMaskShift9 = bBitsLen - bBitsShift\
    \ - 9\n        val aBitsMaskShift10 = aBitsLen - aBitsShift - 10\n        val\
    \ bBitsMaskShift10 = bBitsLen - bBitsShift - 10\n        val aBitsMaskShift11\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp6z6_ny5.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp6z6_ny5.scala:14:29\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36maBitsLen\e[0m = aBits.length\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value length is not\
    \ a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp6z6_ny5.scala:15:29\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mbBitsLen\e[0m = bBits.length\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value length is not\
    \ a member of Int\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp6z6_ny5.scala:41:5\
    \ ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659793128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val xorBitsStringWithZeros = xorBitsStringWithZeros.substring(0,\
    \ xorBitsStringWithZeros.length - 1)\n        xorBitsStringWithZeros\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkols5jbk.scala:14:12 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e\
    [0m = xorBitsStringWithZeros.substring(\e[31m0\e[0m, xorBitsStringWithZeros.length\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorBitsStringWithZeros is already defined as \e[33mvalue\e\
    [0m \e[35mxorBitsStringWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkols5jbk.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpkols5jbk.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n3 errors found\n"
  stdout: ''
  timestamp: 1659793128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Int](a.length)\n        for(i\
    \ <- 0 until xorArray.length)\n            xorArray(i) = aArray(i) xor bArray(i)\n\
    \        new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp86_w1xvo.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmp86_w1xvo.scala:14:12 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(xorArray)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m\
    \ \e[35mString\e[0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\
    \e[31m   |\e[0m (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m\
    \   |\e[0m (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m \
    \  |\e[0m (x$0: Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1:\
    \ Int, x$2: Int, x$3: Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int,\
    \ x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\
    \e[31m   |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((xorArray : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringBuilder\
    \ = new StringBuilder(xorBitsStringLength)\n        xorBitsStringBuilder.append(xorBitsString.substring(0,\
    \ xorBitsStringLength - 1))\n        xorBitsStringBuilder.append(xorBitsString.substring(xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0c1t_mpv.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp0c1t_mpv.scala:17:36 -----------------------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e\
    [35mStringBuilder\e[0m: (i: Int): Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659793128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        val xorResult = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            xorResult(i) =\
    \ xorArray(i).toChar\n            i += 1\n        }\n        xorResult.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph9zi1boo.scala:15:36 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793129
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        for(i\
    \ <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n     \
    \           if(aList(i) == bList(j))\n                    xorList += aList(i)\n\
    \        xorList.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfz5pcpam.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpty4pgdhf.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        var result = \"\"\n        for(i <- 0 until aArray.length)\n\
    \            result += (aArray(i) XOR bArray(i))\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjmizgwr6.scala:13:19 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += (aArray(i) XOR bArray(i))\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpjmizgwr6.scala:13:33 ------------------------\e[0m\e[0m\n\
    \e[31m13 |\e[0m            result += (aArray(i) XOR bArray(i))\n\e[31m\e[31m \
    \  |\e[0m                       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \             value XOR is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659793130
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        var carry =\
    \ 0\n        for (i <- 0 until aArray.length)\n            carry += aArray(i)\
    \ xor bArray(i)\n        for (i <- 0 until aArray.length)\n            result.append(carry\
    \ % 2)\n            carry /= 2\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk7fjewub.scala:14:18 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            carry += aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpk7fjewub.scala:14:31 ------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m            carry += aArray(i) xor bArray(i)\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                     value\
    \ xor is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659793130
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        aList.zip(bList).foreach\
    \ { case (aChar, bChar) =>\n            xorList += aChar ^ bChar\n        }\n\
    \        xorList.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9awhttwp.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793125
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        xorBitsStringWithLeadingZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpycrz61ma.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpycrz61ma.scala:13:58 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793128
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(x => x._1 ^ x._2)\n        val xorString =\
    \ xorArray.toString.map(_.toChar).mkString\n        xorString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnwl0xgvk.scala:18)\n\tat Problem.main(tmpnwl0xgvk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793116
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        var result = \"\"\n        for(i <- 0 until aBits) {\n            result\
    \ += (a & (1 << i)) ^ (b & (1 << i))\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnwgacivq.scala:13:19 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += (a & (\e[31m1\e[0m << i)) ^ (b\
    \ & (\e[31m1\e[0m << i))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m            value += is not a member of String - did you mean String.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnwgacivq.scala:13:25 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += (a & (\e[31m1\e[0m << i)) ^ (b\
    \ & (\e[31m1\e[0m << i))\n\e[31m\e[31m   |\e[0m                       ^^^\e[0m\n\
    \e[31m   |\e[0m                       value & is not a member of String\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793130
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        var result = \"\"\n        var carry = 0\n        var i = 0\n       \
    \ while (i < a.length) {\n            val aBit = aBits & (1 << (a.length - i -\
    \ 1))\n            val bBit = bBits & (1 << (b.length - i - 1))\n            val\
    \ aBitOrBBit = aBit | bBit\n            val aBitAndCarry = aBitOrBBit & carry\n\
    \            val aBitOrCarry = aBitAndCarry | aBit\n            val aBitOrCarryAndCarry\
    \ = aBitOrCarry | carry\n            val result = aBitOrCarryAndCarry.toString\n\
    \            carry = aBitAndCarry\n            i += 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4kqszaqo.scala:28)\n\tat Problem.main(tmp4kqszaqo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793131
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val aLen = aArray.length\n        val bLen = bArray.length\n\
    \        val result = new StringBuilder\n        var i = 0\n        var j = 0\n\
    \        while (i < aLen && j < bLen) {\n            if (aArray(i) == '0' && bArray(j)\
    \ == '0') {\n                result.append(aArray(i))\n                i += 1\n\
    \                j += 1\n            } else if (aArray(i) == '0' && bArray(j)\
    \ != '0') {\n                result.append(bArray(j))\n                j += 1\n\
    \            } else if (aArray(i) != '0' && bArray(j) == '0') {\n            \
    \    result.append(aArray(i))\n                i += 1\n            } else {\n\
    \                result.append(aArray(i))\n                i += 1\n          \
    \      j += 1\n            }\n        }\n        return result.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptzhnm_60.scala:36)\n\tat Problem.main(tmptzhnm_60.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793131
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp32_cd089.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = aList.zip(bList).map(x => x._1 xor x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7jod0jwg.scala:11:52 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = aList.zip(bList).map(\e\
    [36mx\e[0m => x._1 xor x._2).mkString\n\e[31m\e[31m   |\e[0m                 \
    \                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                       value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        aList.zip(bList).foreach\
    \ { case (aChar, bChar) =>\n            xorList += aChar ^ bChar\n        }\n\
    \        xorList.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1n35bipy.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793129
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Int](aArray.length)\n    \
    \    var xor = 0\n        for (i <- 0 until aArray.length) {\n            xor\
    \ = xor + (aArray(i) xor bArray(i))\n            xorArray(i) = xor\n        }\n\
    \        new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3bi0qy1a.scala:14:35 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xor = xor + (aArray(i) xor bArray(i))\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value xor is not a member of Char\n\e[31m\e[31m-- [E134]\
    \ Type Error: /tmp/tmp3bi0qy1a.scala:17:12 -----------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(xorArray)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m\
    \ (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0:\
    \ Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int,\
    \ x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3:\
    \ Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\e[31m  \
    \ |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((xorArray : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toCharArray\n        val bList\
    \ = b.toCharArray\n        val result = new StringBuilder\n        var i = 0\n\
    \        while (i < aList.length && i < bList.length) {\n            if (aList(i)\
    \ XOR bList(i) == 1) {\n                result.append(aList(i))\n            \
    \    i += 1\n            } else {\n                result.append(bList(i))\n \
    \               i += 1\n            }\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvuqhgwvq.scala:14:25 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mif\e[0m (aList(i) XOR bList(i) == \e\
    [31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < Math.max(aArray.length,\
    \ bArray.length)) {\n            result(i) = aArray(i) xor bArray(i)\n       \
    \     i += 1\n        }\n        new String(result)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpefcsatyc.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result(i) = aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        var result = \"\"\n        for (i <- 0 until aArray.length)\
    \ {\n            val aChar = aArray(i)\n            val bChar = bArray(i)\n  \
    \          val aInt = aChar match {\n                case '0' => 0\n         \
    \       case '1' => 1\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character \" + aChar)\n            }\n            val bInt = bChar match\
    \ {\n                case '0' => 0\n                case '1' => 1\n          \
    \      case _ => throw new IllegalArgumentException(\"Invalid character \" + bChar)\n\
    \            }\n            val xor = aInt xor bInt\n            result += xor\
    \ match {\n                case 0 => aChar\n                case 1 => bChar\n\
    \                case _ => throw new IllegalArgumentException(\"Invalid character\
    \ \" + xor)\n            }\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd60ac_da.scala:25:27 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aInt xor\
    \ bInt\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpd60ac_da.scala:27:21 -----------------------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m                \e[33mcase\e[0m \e[31m0\e[0m => aChar\n\e\
    [31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m           Values\
    \ of types Int and Unit cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpd60ac_da.scala:28:21 -----------------------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m                \e[33mcase\e[0m \e[31m1\e[0m => bChar\n\e\
    [31m\e[31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m           Values\
    \ of types Int and Unit cannot be compared with == or !=\n3 errors found\n"
  stdout: ''
  timestamp: 1659793132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        var result = \"\"\n        for (i <- 0 until aArray.length)\n\
    \            result += ((aArray(i) XOR bArray(i)) XOR aArray(i))\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpye54oq84.scala:13:19 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += ((aArray(i) XOR bArray(i)) XOR\
    \ aArray(i))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value += is not a member of String - did you mean String.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpye54oq84.scala:13:34 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result += ((aArray(i) XOR bArray(i)) XOR\
    \ aArray(i))\n\e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        value XOR is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringBuilder\
    \ = new StringBuilder(xorBitsStringLength)\n        for(i <- 0 until xorBitsStringLength)\
    \ {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n      \
    \  }\n        xorBitsStringBuilder.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg1ned3wp.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpg1ned3wp.scala:18:29 --------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        xorBitsStringBuilder.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793126
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl0l6h03q.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793118
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(\n            x => x._1 xor x._2\n        ).map(\n\
    \            x => x.toString.toCharArray\n        ).map(\n            x => x.mkString(\"\
    \")\n        )\n        xorArray.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpentro9kn.scala:14:22 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[36mx\e[0m => x._1 xor x._2\n\e[31m\e[31m\
    \   |\e[0m                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m                 value\
    \ xor is not a member of Int\n\e[31m\e[31m-- Error: /tmp/tmpentro9kn.scala:15:9\
    \ ------------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m      \
    \  ).map(\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0m         No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m         where:    B is a type\
    \ variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659793133
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toCharArray\n        val bList\
    \ = b.toCharArray\n        val xorResult = mutable.Buffer.empty[Char]\n      \
    \  for (i <- 0 until aList.length)\n            xorResult += (aList(i) XOR bList(i))\n\
    \        xorResult.toString\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxjtiujgh.scala:11:24 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.Buffer.empty[\e\
    [35mChar\e[0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793131
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpty4pgdhf.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        var carry =\
    \ 0\n        var i = 0\n        while (i < aArray.length) {\n            val aChar\
    \ = aArray(i)\n            val bChar = bArray(i)\n            val aInt = aChar\
    \ match {\n                case '1' => 1\n                case '0' => 0\n    \
    \            case _ => throw new IllegalArgumentException(\"Invalid input\")\n\
    \            }\n            val bInt = bChar match {\n                case '1'\
    \ => 1\n                case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid input\")\n            }\n            val aInt = aInt XOR bInt\n      \
    \      val aChar = aInt match {\n                case 0 => '0'\n             \
    \   case 1 => '1'\n                case _ => throw new IllegalArgumentException(\"\
    Invalid input\")\n            }\n            result.append(aChar)\n          \
    \  carry = aInt XOR carry\n            i += 1\n        }\n        if (carry !=\
    \ 0) {\n            result.append(carry)\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9jnyn5l.scala:27:16 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36maInt\e[0m = aInt XOR\
    \ bInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0maInt is already defined as \e[33mvalue\e[0m \e[35maInt\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpe9jnyn5l.scala:28:16 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m            \e[33mval\e[0m \e[36maChar\e[0m = aInt \e[33mmatch\e[0m {\n\
    \e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0maChar is already defined\
    \ as \e[33mvalue\e[0m \e[35maChar\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m29 |\e[0m                \e[33mcase\e[0m \e[31m0\e[0m => \e[31m'0'\e[0m\n\
    \e[31m30 |\e[0m                \e[33mcase\e[0m \e[31m1\e[0m => \e[31m'1'\e[0m\n\
    \e[31m31 |\e[0m                \e[33mcase\e[0m _ => \e[33mthrow\e[0m \e[33mnew\e\
    [0m \e[35mIllegalArgumentException\e[0m(\e[31m\"Invalid input\"\e[0m)\n\e[31m32\
    \ |\e[0m            }\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe9jnyn5l.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            carry = aInt\
    \ XOR carry\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                    value XOR is not a member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1659793133
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        var\
    \ i = 0\n        while (i < aList.length && i < bList.length) {\n            xorList\
    \ += (aList(i) xor bList(i))\n            i += 1\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuwv2twoa.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = xorBits.toBinaryString\n\
    \        xorBitsString.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqj9a0b05.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793133
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        var\
    \ i = 0\n        while (i < aList.size) {\n            xorList += aList(i) xor\
    \ bList(i)\n            i += 1\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb9djp_bv.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n \
    \       val bList = b.toCharArray.map(_.toInt)\n        val xorList = mutable.ListBuffer.empty[Int]\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.toString.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu6kmso3k.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        var result = \"\"\n        var carry = 0\n        for(i <-\
    \ 0 until aList.length){\n            val aChar = aList(i)\n            val bChar\
    \ = bList(i)\n            val aVal = aChar match {\n                case '1' =>\
    \ 1\n                case '0' => 0\n                case _ => throw new IllegalArgumentException(\"\
    Invalid character \" + aChar)\n            }\n            val bVal = bChar match\
    \ {\n                case '1' => 1\n                case '0' => 0\n          \
    \      case _ => throw new IllegalArgumentException(\"Invalid character \" + bChar)\n\
    \            }\n            val aValInt = aVal.toInt\n            val bValInt\
    \ = bVal.toInt\n            val aValIntInt = aValInt.toInt\n            val bValIntInt\
    \ = bValInt.toInt\n            val aValIntIntInt = aValIntInt.toInt\n        \
    \    val bValIntIntInt = bValIntInt.toInt\n            val aValIntIntIntInt =\
    \ aValIntIntInt.toInt\n            val bValIntIntIntInt = bValIntIntInt.toInt\n\
    \            val aValIntIntIntIntInt = aValIntIntIntInt.toInt\n            val\
    \ bValIntIntIntIntInt = bValIntIntIntInt.toInt\n            val aValIntIntIntIntIntInt\
    \ = aValIntIntIntIntInt.toInt\n            val bValIntIntIntIntIntInt = bValIntIntIntIntInt.toInt\n\
    \            val aValIntIntIntIntIntIntInt = aValIntIntIntIntIntInt.toInt\n  \
    \          val bValIntIntIntIntIntIntInt = bValIntIntIntIntIntIntInt.toInt\n \
    \           val aValIntIntIntIntIntIntIntInt = aValIntIntIntIntIntIntIntInt.toInt\n\
    \            val bValIntIntIntIntIntIntIntInt = bValIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aValIntIntIntIntIntIntIntIntInt = aValIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bValIntIntIntIntIntIntIntIntInt = bValIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aValIntIntIntIntIntIntIntIntIntInt = aValIntIntIntIntInt\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnz98p0mm.scala:53:0 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnz98p0mm.scala:43:50\
    \ ------------------------\e[0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbValIntIntIntIntIntIntIntIntInt\e[0m = bValIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: bValIntIntIntIntIntIntIntIntIntInt\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnz98p0mm.scala:52:1\
    \ ---------------------\e[0m\e[0m\n\e[31m52 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpnz98p0mm.scala:46:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m46 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659793134
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        val xor = new\
    \ mutable.HashMap[Char, Int]()\n        for (i <- 0 until aArray.length) {\n \
    \           xor(aArray(i), bArray(i)) match {\n                case Some(x) =>\
    \ result.append((x % 2).toChar)\n                case None => result.append('0')\n\
    \            }\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9mw1dy8p.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = \e[33mnew\e[0m\
    \ mutable.HashMap[\e[35mChar\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9mw1dy8p.scala:15:47\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m                \e[33mcase\e\
    [0m Some(x) => result.append((x % \e[31m2\e[0m).toChar)\n\e[31m\e[31m   |\e[0m\
    \                                               ^\e[0m\n\e[31m   |\e[0m      \
    \                                         Not found: x\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        val result = xorBitsStringWithZeros.reverse\n        return\
    \ result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoztc846w.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpoztc846w.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793134
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val result = xorBits.toBinaryString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj6qk3u3u.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793134
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        xorBitsStringWithLeadingZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpycrz61ma.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpycrz61ma.scala:13:58 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new Array[Int](b.length)\n\
    \        var i = 0\n        while (i < b.length) {\n            result(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        new String(result)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpey5ufof4.scala:14:34 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result(i) = aArray(i) xor bArray(i)\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   value xor is not a member of Int\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpey5ufof4.scala:17:12 -----------------------------\e[0m\e[0m\n\
    \e[31m17 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(result)\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m \e[35mString\e\
    [0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\e[31m   |\e[0m\
    \ (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]): String\n\e\
    [31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0:\
    \ Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int,\
    \ x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3:\
    \ Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\e[31m  \
    \ |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((result : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793135
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        var\
    \ i = 0\n        while (i < aList.size) {\n            xorList += aList(i) xor\
    \ bList(i)\n            i += 1\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb9djp_bv.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793132
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringBuilder\
    \ = new StringBuilder(xorBitsStringLength)\n        for ((index, value) <- xorBitsString.zipWithIndex)\
    \ xorBitsStringBuilder.append(value).append(if (index != xorBitsStringLength -\
    \ 1) \"0\" else \"\")\n        xorBitsStringBuilder.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2pgn6gp_.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp2pgn6gp_.scala:16:29 --------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        xorBitsStringBuilder.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    StringBuilder\n\
    \e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793135
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringWithZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ \"0\")\n        xorBitsStringWithZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt0yo0k23.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpt0yo0k23.scala:13:51 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithZeros\e[0m =\
    \ xorBitsString.padToLength(xorBitsString.length, \e[31m\"0\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793137
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val result = aBits xor bBits\n        val resultString = Integer.toBinaryString(result)\n\
    \        resultString.reverse\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpebnva441.scala:11:27 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new mutable.StringBuilder\n        var\
    \ carry = 0\n        for(i <- 0 until aArray.length)\n            for(j <- 0 until\
    \ bArray.length)\n                if(aArray(i) XOR bArray(j) == 1)\n         \
    \           result.append(carry)\n                else\n                    result.append(0)\n\
    \                carry = 1\n            if(carry == 1)\n                result.append(1)\n\
    \        return result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphkyvsps0.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphkyvsps0.scala:15:29 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m                \e[33mif\e[0m(aArray(i) XOR bArray(j)\
    \ == \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   value XOR is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        val\
    \ xorListSize = mutable.ListBuffer.empty[Int]\n        val xorListSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSize = mutable.ListBuffer.empty[Int]\n        val\
    \ xorListSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n        val xorListSizeSizeSizeSizeSize\
    \ = mutable.ListBuffer.empty[Int]\n        val xorListSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize = mutable.ListBuffer.empty[Int]\n\
    \        val xorListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize =\
    \ mutable.ListBuffer.empty[Int]\n        val xorListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.ListBuffer.empty[Int]\n        val xorListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.ListBuffer.empty[Int]\n        val xorListSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSizeSize\
    \ = mutable.ListBuffer.empty[Int]\n        val xorListSizeSizeSize\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp149l794z.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp149l794z.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorListSizeSizeSizeSizeSize\e[0m = mutable.ListBuffer.empty[\e[35mInt\e\
    [0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorListSizeSizeSizeSizeSize is already defined as \e[33mvalue\e\
    [0m \e[35mxorListSizeSizeSizeSizeSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp149l794z.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mxorListSizeSizeSizeSizeSizeSize\e\
    [0m = mutable.ListBuffer.empty[\e[35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorListSizeSizeSizeSizeSizeSize is already defined as \e[33mvalue\e\
    [0m \e[35mxorListSizeSizeSizeSizeSizeSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp149l794z.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mxorListSizeSizeSizeSizeSizeSizeSizeSize\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mxorListSizeSizeSizeSizeSizeSizeSizeSize is already defined\
    \ as \e[33mvalue\e[0m \e[35mxorListSizeSizeSizeSizeSizeSizeSizeSize\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp149l794z.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mxorListSizeSizeSizeSizeSizeSizeSizeSize\e\
    ["
  stdout: ''
  timestamp: 1659793136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toBinaryString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringWithZeros\
    \ = Array.fill(xorBitsStringLength)(0)\n        xorBitsStringWithZeros ++ xorBitsString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7qxj0qn7.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp7qxj0qn7.scala:15:8 ---------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        xorBitsStringWithZeros ++ xorBitsString.reverse\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    Array[AnyVal]\n\e[31m   |\e[0m        Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n        for(i\
    \ <- 0 until xorArray.length)\n            xorArray(i) = aArray(i) xor bArray(i)\n\
    \        new String(xorArray)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl1jlwa4m.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793137
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.Array[Int](aArray.length)\n\
    \        val xor = new mutable.Array[Int](aArray.length)\n        val xorResult\
    \ = new mutable.Array[Int](aArray.length)\n        val xorResultIndex = 0\n  \
    \      val xorResultIndex2 = 0\n        val xorResultIndex3 = 0\n        val xorResultIndex4\
    \ = 0\n        val xorResultIndex5 = 0\n        val xorResultIndex6 = 0\n    \
    \    val xorResultIndex7 = 0\n        val xorResultIndex8 = 0\n        val xorResultIndex9\
    \ = 0\n        val xorResultIndex10 = 0\n        val xorResultIndex11 = 0\n  \
    \      val xorResultIndex12 = 0\n        val xorResultIndex13 = 0\n        val\
    \ xorResultIndex14 = 0\n        val xorResultIndex15 = 0\n        val xorResultIndex16\
    \ = 0\n        val xorResultIndex17 = 0\n        val xorResultIndex18 = 0\n  \
    \      val xorResultIndex19 = 0\n        val xorResultIndex20 = 0\n        val\
    \ xorResultIndex21 = 0\n        val xorResultIndex22 = 0\n        val xorResultIndex23\
    \ = 0\n        val xorResultIndex24 = 0\n        val xorResultIndex25 = 0\n  \
    \      val xorResultIndex26 = 0\n        val xorResultIndex27 = 0\n        val\
    \ xorResultIndex28 = 0\n        val xorResultIndex29 = 0\n        val xorResultIndex30\
    \ = 0\n        val xorResultIndex31 = 0\n        val xorResultIndex32 = 0\n  \
    \      val xorResultIndex33 = 0\n        val xorResultIndex34 = 0\n        val\
    \ xorResultIndex35 = 0\n        val xorResultIndex36 = 0\n        val xorResultIndex37\
    \ = 0\n        val xorResultIndex38 = 0\n        val xorResultIndex39 = 0\n  \
    \      val xorResultIndex40 = 0\n        val xorResultIndex41 = 0\n        val\
    \ xorResultIndex42 = 0\n        val xorResultIndex43 = 0\n        val xorResultIndex44\
    \ = 0\n        val xorResultIndex45 = 0\n        val xorResultIndex46 = 0\n  \
    \      val xorResultIndex47 = 0\n        val xorResultIndex48 = 0\n        val\
    \ xorResultIndex49 = 0\n        val xorResultIndex50 = 0\n        val xorResultIndex51\
    \ = 0\n        val xorResultIndex52 = 0\n        val xorResultIndex53 = 0\n  \
    \      val xorResultIndex54 = 0\n        val xorResultIndex\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl4n_c8eg.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl4n_c8eg.scala:11:25\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.Array[\e[35mInt\e[0m](aArray.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpl4n_c8eg.scala:12:22 ------------------------\e[0m\e\
    [0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = \e[33mnew\e[0m mutable.Array[\e\
    [35mInt\e[0m](aArray.length)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpl4n_c8eg.scala:13:28 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = \e[33mnew\e\
    [0m mutable.Array[\e[35mInt\e[0m](aArray.length)\n\e[31m\e[31m   |\e[0m      \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl4n_c8eg.scala:69:5\
    \ ---------------------\e[0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659793137
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        for(i\
    \ <- 0 until aList.size) {\n            xorList += aList(i) xor bList(i)\n   \
    \     }\n        xorList.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwxcnjh0c.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_wrrcrkc.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_wrrcrkc.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        for(i\
    \ <- 0 until aList.size) {\n            xorList += aList(i) xor bList(i)\n   \
    \     }\n        xorList.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyu5_pzn6.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = new mutable.StringBuilder\n        val xor =\
    \ new mutable.BitSet(aList.size + b.size)\n        for(i <- 0 until aList.size)\
    \ {\n            xor.set(aList(i))\n            for(j <- 0 until bList.size) {\n\
    \                xor.set(bList(j))\n                if(xor.cardinality() == 0)\
    \ {\n                    result.append(0)\n                } else {\n        \
    \            result.append(1)\n                }\n                xor.clear(xor.cardinality())\n\
    \            }\n        }\n        result.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1w1xnhk_.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1w1xnhk_.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = \e[33mnew\e[0m\
    \ mutable.BitSet(aList.size + b.size)\n\e[31m\e[31m   |\e[0m                 \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = new StringBuilder\n        var carry = 0\n  \
    \      for (i <- 0 until aList.size) {\n            val aChar = aList(i)\n   \
    \         val bChar = bList(i)\n            val aCharInt = aChar.toInt\n     \
    \       val bCharInt = bChar.toInt\n            val aCharInt = aCharInt + carry\n\
    \            val bCharInt = bCharInt + carry\n            val aCharChar = aCharInt.toChar\n\
    \            val bCharChar = bCharInt.toChar\n            val aCharCharInt = aCharChar.toInt\n\
    \            val bCharCharInt = bCharChar.toInt\n            val aCharCharInt\
    \ = aCharCharInt + carry\n            val bCharCharInt = bCharCharInt + carry\n\
    \            val aCharCharChar = aCharCharInt.toChar\n            val bCharCharChar\
    \ = bCharCharInt.toChar\n            val aCharCharCharInt = aCharCharChar.toInt\n\
    \            val bCharCharCharInt = bCharCharChar.toInt\n            val aCharCharCharInt\
    \ = aCharCharCharInt + carry\n            val bCharCharCharInt = bCharCharCharInt\
    \ + carry\n            val aCharCharCharChar = aCharCharCharInt.toChar\n     \
    \       val bCharCharCharChar = bCharCharCharInt.toChar\n            val aCharCharCharCharInt\
    \ = aCharCharCharChar.toInt\n            val bCharCharCharCharInt = bCharCharCharChar.toInt\n\
    \            val aCharCharCharCharInt = aCharCharCharCharInt + carry\n       \
    \     val bCharCharCharCharInt = bCharCharCharCharInt + carry\n            val\
    \ aCharCharCharCharChar = aCharCharCharCharInt.toChar\n            val bCharCharCharCharChar\
    \ = bCharCharCharCharInt.toChar\n            val aCharCharCharCharCharInt = aCharCharCharCharChar.toInt\n\
    \            val bCharCharCharCharCharInt = bCharCharCharCharChar.toInt\n    \
    \        val aCharCharCharCharCharInt = aCharCharCharCharCharInt + carry\n   \
    \         val bCharCharCharCharCharInt = bCharCharCharCharCharInt + carry\n  \
    \          val aCharCharCharCharCharChar = aCharCharCharCharCharInt.toChar\n \
    \           val bCharCharCharCharCharChar = b\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpje4mizxs.scala:54:0 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpje4mizxs.scala:18:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e\
    [0m \e[36maCharInt\e[0m = aCharInt + carry\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0maCharInt is already defined as \e[33mvalue\e[0m \e[35maCharInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpje4mizxs.scala:19:16 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m            \e[33mval\e[0m \e[36mbCharInt\e[0m = bCharInt + carry\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mbCharInt is already defined as \e[33mvalue\e[0m \e[35mbCharInt\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpje4mizxs.scala:24:16 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m            \e[33mval\e[0m \e[36maCharCharInt\e[0m = aCharCharInt + carry\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0maCharCharInt is already defined as \e[33mvalue\e[0m \e[35maCharCharInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpje4mizxs.scala:25:16 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m            \e[33mval\e[0m \e[36mbCharCharInt\e[0m = bCharCharInt\
    \ + carry\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbCharCharInt is already defined as \e[33mvalue\e[0m \e[35mbCharCharInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpje4mizxs.scala:30:16 -------------------"
  stdout: ''
  timestamp: 1659793138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        for(i\
    \ <- 0 until aList.size) {\n            val xor = aList(i) xor bList(i)\n    \
    \        xorList += xor.asInstanceOf[String]\n        }\n        xorList.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp05wbmqh2.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp05wbmqh2.scala:13:31 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aList(i)\
    \ xor bList(i)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                      value xor is not a member of Char\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = Array.ofDim[Char](2)\n        val xorArray2\
    \ = Array.ofDim[Char](2)\n        val xorArray3 = Array.ofDim[Char](2)\n     \
    \   val xorArray4 = Array.ofDim[Char](2)\n        val xorArray5 = Array.ofDim[Char](2)\n\
    \        val xorArray6 = Array.ofDim[Char](2)\n        val xorArray7 = Array.ofDim[Char](2)\n\
    \        val xorArray8 = Array.ofDim[Char](2)\n        val xorArray9 = Array.ofDim[Char](2)\n\
    \        val xorArray10 = Array.ofDim[Char](2)\n        val xorArray11 = Array.ofDim[Char](2)\n\
    \        val xorArray12 = Array.ofDim[Char](2)\n        val xorArray13 = Array.ofDim[Char](2)\n\
    \        val xorArray14 = Array.ofDim[Char](2)\n        val xorArray15 = Array.ofDim[Char](2)\n\
    \        val xorArray16 = Array.ofDim[Char](2)\n        val xorArray17 = Array.ofDim[Char](2)\n\
    \        val xorArray18 = Array.ofDim[Char](2)\n        val xorArray19 = Array.ofDim[Char](2)\n\
    \        val xorArray20 = Array.ofDim[Char](2)\n        val xorArray21 = Array.ofDim[Char](2)\n\
    \        val xorArray22 = Array.ofDim[Char](2)\n        val xorArray23 = Array.ofDim[Char](2)\n\
    \        val xorArray24 = Array.ofDim[Char](2)\n        val xorArray25 = Array.ofDim[Char](2)\n\
    \        val xorArray26 = Array.ofDim[Char](2)\n        val xorArray27 = Array.ofDim[Char](2)\n\
    \        val xorArray28 = Array.ofDim[Char](2)\n        val xorArray29 = Array.ofDim[Char](2)\n\
    \        val xorArray30 = Array.ofDim[Char](2)\n        val xorArray31 = Array.ofDim[Char](2)\n\
    \        val xorArray32 = Array.ofDim[Char](2)\n        val xorArray33 = Array.ofDim[Char](2)\n\
    \        val xorArray34 = Array.ofDim[Char](2)\n        val xorArray35 = Array.ofDim[Char](2)\n\
    \        val xorArray36 = Array.ofDim[Char](2)\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe5au4q7s.scala:48:5\
    \ ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val result = xorBitsString.reverse\n        return result\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp09vf4jrq.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringBuilder\
    \ = new StringBuilder(xorBitsStringLength)\n        xorBitsStringBuilder.append(xorBitsString.substring(0,\
    \ xorBitsStringLength - 1))\n        xorBitsStringBuilder.append(xorBitsString.substring(xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0c1t_mpv.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp0c1t_mpv.scala:17:36 -----------------------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e\
    [35mStringBuilder\e[0m: (i: Int): Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659793128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringBuilder\
    \ = new StringBuilder(xorBitsStringLength)\n        xorBitsStringBuilder.append(xorBitsString.charAt(0))\n\
    \        for (i = 1; i < xorBitsStringLength; i++) {\n            xorBitsStringBuilder.append(xorBitsString.charAt(i))\n\
    \        }\n        xorBitsStringBuilder.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_urr10p9.scala:16:15 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m (i = \e[31m1\e[0m; i < xorBitsStringLength;\
    \ i++) {\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m        \
    \       ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_urr10p9.scala:16:43\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m\
    \ (i = \e[31m1\e[0m; i < xorBitsStringLength; i++) {\n\e[31m\e[31m   |\e[0m  \
    \                                         ^\e[0m\n\e[31m   |\e[0m            \
    \                               '<-' expected, but ';' found\n\e[31m\e[31m-- [E032]\
    \ Syntax Error: /tmp/tmp_urr10p9.scala:16:48 ---------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m (i = \e[31m1\e[0m; i < xorBitsStringLength;\
    \ i++) {\n\e[31m\e[31m   |\e[0m                                              \
    \  ^\e[0m\n\e[31m   |\e[0m                                                pattern\
    \ expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_urr10p9.scala:11:28\
    \ ------------------------\e[0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e\
    [36mxorBits\e[0m = aBits xor bBits\n\e[31m\e[31m   |\e[0m                    \
    \  ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      value xor is not a member\
    \ of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_urr10p9.scala:16:18\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mfor\e[0m (i\
    \ = \e[31m1\e[0m; i < xorBitsStringLength; i++) {\n\e[31m\e[31m   |\e[0m     \
    \             ^\e[0m\n\e[31m   |\e[0mvalue foreach is not a member of Null, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffe"
  stdout: ''
  timestamp: 1659793139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_wrrcrkc.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_wrrcrkc.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](aArray.length)\n   \
    \     var i = 0\n        while (i < aArray.length) {\n            xorArray(i)\
    \ = aArray(i) xor bArray(i)\n            i += 1\n        }\n        xorArray.toString.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqsbim6pw.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[Int]\n        for(i\
    \ <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n        xorList.toString.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7y3y59pd.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793137
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_wrrcrkc.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_wrrcrkc.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val aLen = aList.length\n        val bLen = bList.length\n\
    \        val result = new StringBuilder(aLen * bLen)\n        var i = 0\n    \
    \    while (i < aLen) {\n            val aChar = aList(i)\n            val bChar\
    \ = bList(i)\n            val xor = aChar xor bChar\n            result.append(xor)\n\
    \            i += 1\n        }\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpd_yyvg0r.scala:18:28 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aChar xor\
    \ bChar\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringWithLeadingZeros = xorBitsString.padToLength(xorBitsString.length,\
    \ '0')\n        xorBitsStringWithLeadingZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0ggkmh6i.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp0ggkmh6i.scala:13:58 ------------------------\e[0m\e\
    [0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorBitsStringWithLeadingZeros\e\
    [0m = xorBitsString.padToLength(xorBitsString.length, \e[31m'0'\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value padToLength is not a member\
    \ of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        aList.zip(bList).foreach\
    \ { case (aChar, bChar) =>\n            xorList += aChar xor bChar\n        }\n\
    \        xorList.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxilj5qpy.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        var result = 0\n        val aLen = a.length\n        val bLen = b.length\n\
    \        val aLenBits = aLen.toInt\n        val bLenBits = bLen.toInt\n      \
    \  val aLenBitsBits = aLenBits * 8\n        val bLenBitsBits = bLenBits * 8\n\
    \        val aLenBitsBitsBits = aLenBitsBits * 8\n        val bLenBitsBitsBits\
    \ = bLenBitsBits * 8\n        val aLenBitsBitsBitsBits = aLenBitsBitsBits * 8\n\
    \        val bLenBitsBitsBitsBits = bLenBitsBitsBits * 8\n        val aLenBitsBitsBitsBitsBits\
    \ = aLenBitsBitsBits * 8\n        val bLenBitsBitsBitsBitsBits = bLenBitsBitsBits\
    \ * 8\n        val aLenBitsBitsBitsBitsBitsBits = aLenBitsBitsBits * 8\n     \
    \   val bLenBitsBitsBitsBitsBitsBits = bLenBitsBitsBits * 8\n        val aLenBitsBitsBitsBitsBitsBitsBits\
    \ = aLenBitsBitsBits * 8\n        val bLenBitsBitsBitsBitsBitsBitsBits = bLenBitsBitsBits\
    \ * 8\n        val aLenBitsBitsBitsBitsBitsBitsBitsBits = aLenBitsBitsBits * 8\n\
    \        val bLenBitsBitsBitsBitsBitsBitsBitsBits = bLenBitsBitsBits * 8\n   \
    \     val aLenBitsBitsBitsBitsBitsBitsBitsBitsBits = aLenBitsBitsBits * 8\n  \
    \      val bLenBitsBitsBitsBitsBitsBitsBitsBitsBits = bLenBitsBitsBits * 8\n \
    \       val aLenBitsBitsBitsBitsBitsBitsBitsBitsBitsBits = aLenBitsBitsBits *\
    \ 8\n        val bLenBitsBitsBitsBitsBitsBitsBitsBitsBitsBitsBits = bLenBits\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9q2knxo7.scala:34:5\
    \ ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        for (i <- 0 until aArray.length)\n            result.append(aArray(i)\
    \ xor bArray(i))\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpreab9qh1.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793139
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new StringBuilder\n\
    \        for(i <- 0 until aArray.length)\n            result.append(aArray(i)\
    \ xor bArray(i))\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbru9ag_t.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            result.append(aArray(i) xor bArray(i))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793141
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        for\
    \ (i<-0 until aList.length) xorList += aList(i) xor bList(i)\n        xorList.toList.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdnz_n2al.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793140
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        var i = 0\n\
    \        while (i < aArray.length) {\n            result.append(aArray(i) ^ bArray(i))\n\
    \            i += 1\n        }\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793122
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        for(i\
    \ <- 0 until aList.size) {\n            xorList += (aList(i) xor bList(i)).toString\n\
    \        }\n        xorList.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2as6dwav.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793140
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for (i <- 0 until aArray.length)\n            xorArray += (aArray(i)\
    \ xor bArray(i))\n        xorArray.toString.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpacqe9bwe.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793140
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = new StringBuilder\n        val xor = mutable.ListBuffer[Int]()\n\
    \        val xorResult = mutable.ListBuffer[Int]()\n        for(i <- 0 until aList.length)\
    \ xor += (aList(i) xor bList(i))\n        for(i <- 0 until xor.length) xorResult\
    \ += xor(i).toInt\n        for(i <- 0 until xorResult.length) result += xorResult(i).toChar\n\
    \        return result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7fink_fr.scala:12:18 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7fink_fr.scala:13:24 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659793140
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpty4pgdhf.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length)\n            xorArray += (aArray(i) xor\
    \ bArray(i))\n        xorArray.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzykjrfy2.scala:13:35 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray += (aArray(i) xor bArray(i))\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793142
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        var i = 0\n\
    \        while (i < aArray.length) {\n            result.append(aArray(i) Xor\
    \ bArray(i))\n            i += 1\n        }\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbadk7knj.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result.append(aArray(i) Xor bArray(i))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value Xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793142
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        for(i\
    \ <- 0 until aList.size) {\n            xorList += aList(i) xor bList(i)\n   \
    \     }\n        xorList.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyu5_pzn6.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793136
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n        var\
    \ xor = 0\n        for(i <- 0 until xorArray.length)\n            xor = xor +\
    \ (aArray(i) xor bArray(i))\n        xorArray = xorArray.reverse\n        new\
    \ String(xorArray)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxjdf1wop.scala:14:35 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xor = xor + (aArray(i) xor bArray(i))\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value xor is not a member of Char\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpxjdf1wop.scala:15:17 -----------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        xorArray = xorArray.reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment\
    \ to val xorArray\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793142
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val result = xorBits.toBinaryString\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbz3f1rq1.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringWithLeadingZeros\
    \ = if (xorBitsStringLength < 4) \"0\" + xorBitsString else xorBitsString\n  \
    \      val xorBitsStringWithTrailingZeros = if (xorBitsStringLength < 4) xorBitsString\
    \ else xorBitsString.substring(0,xorBitsStringLength)\n        xorBitsStringWithLeadingZeros\
    \ + xorBitsStringWithTrailingZeros\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp86r2utpb.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793142
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        var carry =\
    \ 0\n        var i = 0\n        while (i < aArray.length) {\n            val aChar\
    \ = aArray(i)\n            val bChar = bArray(i)\n            val aVal = aChar\
    \ ^ bChar\n            val bVal = bChar ^ aChar\n            val aValInt = aVal\
    \ & 0xff\n            val bValInt = bVal & 0xff\n            val aValString =\
    \ aValInt.toString\n            val bValString = bValInt.toString\n          \
    \  val aValChar = aValString.charAt(0)\n            val bValChar = bValString.charAt(0)\n\
    \            val aValInt2 = aValInt.toInt\n            val bValInt2 = bValInt.toInt\n\
    \            val aValString2 = aValInt2.toString\n            val bValString2\
    \ = bValInt2.toString\n            val aValChar2 = aValString2.charAt(0)\n   \
    \         val bValChar2 = bValString2.charAt(0)\n            val aValInt3 = aValInt.toInt\n\
    \            val bValInt3 = bValInt.toInt\n            val aValString3 = aValInt3.toString\n\
    \            val bValString3 = bValInt3.toString\n            val aValChar3 =\
    \ aValString3.charAt(0)\n            val bValChar3 = bValString3.charAt(0)\n \
    \           val aValInt4 = aValInt.toInt\n            val bValInt4 = bValInt.toInt\n\
    \            val aValString4 = aValInt4.toString\n            val bValString4\
    \ = bValInt4.toString\n            val aValChar4 = aValString4.charAt(0)\n   \
    \         val bValChar4 = bValString4.charAt(0)\n            val aValInt5 = aValInt.toInt\n\
    \            val bValInt5 = bValInt.toInt\n            val aValString5 = aValInt5.toString\n\
    \            val bValString5 = bValInt5.toString\n            val aValChar5 =\
    \ aValString5.charAt(0)\n            val bValChar5 = bValString5.charAt(0)\n \
    \           val aValInt6 = aValInt.toInt\n            val bValInt6 = bValInt.toInt\n\
    \            val aValString6 = aValInt6.toString\n            val bValString6\
    \ = bValInt6.toString\n            val aValChar6 = aValString6.charAt(0)\n   \
    \         val b\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9ajxcsr5.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9ajxcsr5.scala:63:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp9ajxcsr5.scala:62:1 ---------------------\e[0m\e[0m\n\
    \e[31m62 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp9ajxcsr5.scala:56:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m56 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659793143
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array[Int](aArray.length)\n\
    \        for(i <- 0 until xorArray.length) xorArray(i) = aArray(i) xor bArray(i)\n\
    \        xorArray.toString\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr7fk5gu2.scala:12:66 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mfor\e[0m(i <- \e[31m0\e[0m until xorArray.length)\
    \ xorArray(i) = aArray(i) xor bArray(i)\n\e[31m\e[31m   |\e[0m               \
    \                                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                        value xor is not a member of Int\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793143
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val result = new mutable.StringBuilder\n\
    \        for (i <- 0 until aArray.length)\n            result.append(aArray(i)\
    \ xor bArray(i))\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5f43lf25.scala:11:25 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659793141
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toBinaryString(xorBits)\n\
    \        val xorBitsStringWithoutZeros = xorBitsString.replaceAll(\"0\", \"\"\
    )\n        xorBitsStringWithoutZeros\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2518tj6v.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793143
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        xorArray.toString.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0oc_sn_u.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793126
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val result = xorBits.toBinaryString\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbz3f1rq1.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toBinaryString(xorBits)\n\
    \        val xorBitsStringWithoutLeadingZeros = xorBitsString.substring(1,xorBitsString.length)\n\
    \        val xorBitsStringWithoutTrailingZeros = xorBitsStringWithoutLeadingZeros.substring(0,\
    \ xorBitsStringWithoutLeadingZeros.length-1)\n        xorBitsStringWithoutTrailingZeros\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpspzhrqfo.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793143
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val xorBitsString = Integer.toString(xorBits)\n\
    \        val xorBitsStringLength = xorBitsString.length\n        val xorBitsStringBuilder\
    \ = new StringBuilder(xorBitsStringLength)\n        xorBitsStringBuilder.append(xorBitsString.substring(0,\
    \ xorBitsStringLength - 1))\n        xorBitsStringBuilder.append(xorBitsString.substring(xorBitsStringLength\
    \ - 1))\n        xorBitsStringBuilder.reverse()\n        xorBitsStringBuilder.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0c1t_mpv.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp0c1t_mpv.scala:17:36 -----------------------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        xorBitsStringBuilder.reverse()\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmissing argument\
    \ for parameter i of \e[33mmethod\e[0m \e[35mapply\e[0m in \e[33mclass\e[0m \e\
    [35mStringBuilder\e[0m: (i: Int): Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659793128
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        val xor = mutable.BitSet(b.length)\n\
    \        val xorResult = mutable.BitSet(b.length)\n        val xorResult2 = mutable.BitSet(b.length)\n\
    \        val xorResult3 = mutable.BitSet(b.length)\n        val xorResult4 = mutable.BitSet(b.length)\n\
    \        val xorResult5 = mutable.BitSet(b.length)\n        val xorResult6 = mutable.BitSet(b.length)\n\
    \        val xorResult7 = mutable.BitSet(b.length)\n        val xorResult8 = mutable.BitSet(b.length)\n\
    \        val xorResult9 = mutable.BitSet(b.length)\n        val xorResult10 =\
    \ mutable.BitSet(b.length)\n        val xorResult11 = mutable.BitSet(b.length)\n\
    \        val xorResult12 = mutable.BitSet(b.length)\n        val xorResult13 =\
    \ mutable.BitSet(b.length)\n        val xorResult14 = mutable.BitSet(b.length)\n\
    \        val xorResult15 = mutable.BitSet(b.length)\n        val xorResult16 =\
    \ mutable.BitSet(b.length)\n        val xorResult17 = mutable.BitSet(b.length)\n\
    \        val xorResult18 = mutable.BitSet(b.length)\n        val xorResult19 =\
    \ mutable.BitSet(b.length)\n        val xorResult20 = mutable.BitSet(b.length)\n\
    \        val xorResult21 = mutable.BitSet(b.length)\n        val xorResult22 =\
    \ mutable.BitSet(b.length)\n        val xorResult23 = mutable.BitSet(b.length)\n\
    \        val xorResult24 = mutable.BitSet(b.length)\n        val xorResult25 =\
    \ mutable.BitSet(b.length)\n        val xorResult26 = mutable.BitSet(b.length)\n\
    \        val xorResult27 = mutable.BitSet(b.length)\n        val xorResult28 =\
    \ mutable.BitSet(b.length)\n        val xorResult29 = mutable.BitSet(b.length)\n\
    \        val xorResult30 = mutable.BitSet(b.length)\n        val xorResult31 =\
    \ mutable.BitSet(b.length)\n        val xorResult32 = mutable.BitSet(b.length)\n\
    \        val xorResult33 = mutable.BitSet(b.length)\n        val xorResult34 =\
    \ mutable.BitSet(b.length)\n        val xorResult35 = mutable.BitSet(b.length)\n\
    \        val xorResult36 = mutable.BitSet(b.length)\n        val xorResult37 =\
    \ mutable.BitSet(b.length)\n        val xorResult38\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph4etrprm.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph4etrprm.scala:12:18\
    \ ------------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mxor\e[0m = mutable.BitSet(b.length)\n\e[31m\e[31m   |\e[0m               \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph4etrprm.scala:13:24 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmph4etrprm.scala:14:25 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult2\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmph4etrprm.scala:15:25 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mxorResult3\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmph4etrprm.scala:16:25 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mxorResult4\e[0m = mutable.BitSet(b.length)\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compili"
  stdout: ''
  timestamp: 1659793144
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = aList.zip(bList).map(x => x._1 xor x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7jod0jwg.scala:11:52 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = aList.zip(bList).map(\e\
    [36mx\e[0m => x._1 xor x._2).mkString\n\e[31m\e[31m   |\e[0m                 \
    \                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \                       value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793127
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val result = xorBits.toBinaryString\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbz3f1rq1.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](Math.max(aArray.length,\
    \ bArray.length))\n        var i = 0\n        while (i < xorArray.length) {\n\
    \            xorArray(i) = aArray(i) xor bArray(i)\n            i += 1\n     \
    \   }\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp32_cd089.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpty4pgdhf.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Int](aArray.length)\n    \
    \    for(i <- 0 until aArray.length)\n            xorArray(i) = aArray(i) xor\
    \ bArray(i)\n        new String(xorArray)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpkhxafek5.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmpkhxafek5.scala:14:12 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mnew\e[0m \e[35mString\e[0m(xorArray)\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mconstructor\e[0m \e[35mString\e[0m in \e[33mclass\e[0m\
    \ \e[35mString\e[0m with types\n\e[31m   |\e[0m (x$0: StringBuilder): String\n\
    \e[31m   |\e[0m (x$0: StringBuffer): String\n\e[31m   |\e[0m (x$0: Array[Byte]):\
    \ String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\e[31m\
    \   |\e[0m (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\e[31m \
    \  |\e[0m (x$0: Array[Byte], x$1: String): String\n\e[31m   |\e[0m (x$0: Array[Byte],\
    \ x$1: Int, x$2: Int, x$3: java.nio.charset.Charset): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: String): String\n\e[31m   |\e[0m\
    \ (x$0: Array[Byte], x$1: Int): String\n\e[31m   |\e[0m (x$0: Array[Byte], x$1:\
    \ Int, x$2: Int, x$3: Int): String\n\e[31m   |\e[0m (x$0: Array[Int], x$1: Int,\
    \ x$2: Int): String\n\e[31m   |\e[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\
    \e[31m   |\e[0m (x$0: Array[Char]): String\n\e[31m   |\e[0m (x$0: String): String\n\
    \e[31m   |\e[0m (): String\n\e[31m   |\e[0mmatch arguments ((xorArray : Array[Int]))\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659793144
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for (i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzouj7ip9.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793117
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        var xor = 0\n        for (i <- 0 until aArray.length) xor += (aArray(i)\
    \ xor bArray(i))\n        xor.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5gp856gu.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5gp856gu.scala:13:45 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until aArray.length)\
    \ xor += (aArray(i) xor bArray(i))\n\e[31m\e[31m   |\e[0m                    \
    \                     ^^^^^^\e[0m\n\e[31m   |\e[0m                  value += is\
    \ not a member of Int - did you mean Int.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp5gp856gu.scala:13:59 ------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mfor\e[0m (i <- \e[31m0\e[0m until aArray.length) xor +=\
    \ (aArray(i) xor bArray(i))\n\e[31m\e[31m   |\e[0m                           \
    \                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                     value xor is not a member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1659793144
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val aSet = mutable.Set(aList)\n        val bSet = mutable.Set(bList)\n\
    \        val xorList = mutable.ListBuffer[String]()\n        val xorSet = mutable.Set[String]()\n\
    \        aSet.foreach { x =>\n            bSet.foreach { y =>\n              \
    \  val xor = x ^ y\n                val xorString = Integer.toString(xor)\n  \
    \              xorList += xorString\n                xorSet += xorString\n   \
    \         }\n        }\n        xorList.mkString(\"\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfx4h_y7f.scala:11:19 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36maSet\e[0m = mutable.Set(aList)\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpfx4h_y7f.scala:12:19 ------------------------\e[0m\e[0m\n\e[31m12 |\e\
    [0m        \e[33mval\e[0m \e[36mbSet\e[0m = mutable.Set(bList)\n\e[31m\e[31m \
    \  |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfx4h_y7f.scala:13:22\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mxorList\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfx4h_y7f.scala:14:21\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mxorSet\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m    \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659793143
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n        for(i\
    \ <- 0 until xorArray.length)\n            xorArray(i) = aArray(i) xor bArray(i)\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr6bg9h89.scala:13:36 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793144
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        var\
    \ i = 0\n        while (i < aList.size) {\n            xorList += aList(i) xor\
    \ bList(i)\n            i += 1\n        }\n        xorList.toList.toString\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu_lwoz1i.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793143
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length)\n            xorArray += (aArray(i) xor\
    \ bArray(i))\n        xorArray.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzykjrfy2.scala:13:35 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray += (aArray(i) xor bArray(i))\n\e\
    [31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                         value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793142
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val result = xorBits.toBinaryString\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbz3f1rq1.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793115
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        var result = \"\"\n        var i = 0\n        var j\
    \ = 0\n        while (i < aArray.length && j < bArray.length) {\n            if\
    \ (aArray(i) == '1' && bArray(j) == '1') {\n                result += aArray(i).toChar\n\
    \                i += 1\n                j += 1\n            } else if (aArray(i)\
    \ == '0' && bArray(j) == '0') {\n                result += aArray(i).toChar\n\
    \                i += 1\n                j += 1\n            } else {\n      \
    \          result += aArray(i).toChar\n                i += 1\n              \
    \  j += 1\n            }\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd2uissr4.scala:32)\n\tat Problem.main(tmpd2uissr4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793145
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(bArray).map(x\
    \ => x._1 ^ x._2)\n        val xorString = xorArray.toString.map(_.toChar).mkString\n\
    \        xorString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpha3kk3jk.scala:16)\n\tat Problem.main(tmpha3kk3jk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        var result = \"\"\n        for (i <- 0 until aArray.length)\
    \ {\n            val aChar = aArray(i)\n            val bChar = bArray(i)\n  \
    \          val xor = aChar xor bChar\n            result += xor.asInstanceOf[String]\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"\
    1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5yxuuwft.scala:15:28 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36mxor\e[0m = aChar xor\
    \ bChar\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793145
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_wrrcrkc.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_wrrcrkc.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toIntArray\n        val bBits\
    \ = b.toIntArray\n        val xorBits = Array.ofDim[Int](Math.max(aBits.length,\
    \ bBits.length))\n        var i = 0\n        while (i < xorBits.length) {\n  \
    \          xorBits(i) = aBits(i).xor(bBits(i))\n            i += 1\n        }\n\
    \        xorBits.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpefnp5lia.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpefnp5lia.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659793146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = Array.ofDim[Int](2)\n\
    \        val xorArray2 = Array.ofDim[Int](2)\n        val xorArray3 = Array.ofDim[Int](2)\n\
    \        val xorArray4 = Array.ofDim[Int](2)\n        val xorArray5 = Array.ofDim[Int](2)\n\
    \        val xorArray6 = Array.ofDim[Int](2)\n        val xorArray7 = Array.ofDim[Int](2)\n\
    \        val xorArray8 = Array.ofDim[Int](2)\n        val xorArray9 = Array.ofDim[Int](2)\n\
    \        val xorArray10 = Array.ofDim[Int](2)\n        val xorArray11 = Array.ofDim[Int](2)\n\
    \        val xorArray12 = Array.ofDim[Int](2)\n        val xorArray13 = Array.ofDim[Int](2)\n\
    \        val xorArray14 = Array.ofDim[Int](2)\n        val xorArray15 = Array.ofDim[Int](2)\n\
    \        val xorArray16 = Array.ofDim[Int](2)\n        val xorArray17 = Array.ofDim[Int](2)\n\
    \        val xorArray18 = Array.ofDim[Int](2)\n        val xorArray19 = Array.ofDim[Int](2)\n\
    \        val xorArray20 = Array.ofDim[Int](2)\n        val xorArray21 = Array.ofDim[Int](2)\n\
    \        val xorArray22 = Array.ofDim[Int](2)\n        val xorArray23 = Array.ofDim[Int](2)\n\
    \        val xorArray24 = Array.ofDim[Int](2)\n        val xorArray25 = Array.ofDim[Int](2)\n\
    \        val xorArray26 = Array.ofDim[Int](2)\n        val xorArray27 = Array.ofDim[Int](2)\n\
    \        val xorArray28 = Array.ofDim[Int](2)\n        val xorArray29 = Array.ofDim[Int](2)\n\
    \        val xorArray30 = Array.ofDim[Int](2)\n        val xorArray31 = Array.ofDim[Int](2)\n\
    \        val xorArray32 = Array.ofDim[Int](2)\n        val xorArray33 = Array.ofDim[Int](2)\n\
    \        val xorArray34 = Array.ofDim[Int](2)\n        val xorArray35 = Array.ofDim[Int](2)\n\
    \        val xorArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_wrrcrkc.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_wrrcrkc.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        val xorBits = aBits xor bBits\n        val result = xorBits.toString.reverse\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphxt032im.scala:11:28 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorBits\e[0m = aBits xor\
    \ bBits\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value xor is not a member of Int\n1 error found\n"
  stdout: ''
  timestamp: 1659793145
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793125
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val result = new StringBuilder\n        var i = 0\n\
    \        while (i < aArray.length && i < bArray.length) {\n            result.append(aArray(i)\
    \ Xor bArray(i))\n            i += 1\n        }\n        result.toString\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"),\
    \ (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvkrsxc2w.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            result.append(aArray(i) Xor bArray(i))\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value Xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793145
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](b.length)\n        var\
    \ i = 0\n        while (i < xorArray.length) {\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        xorArray.toString.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoiik1f81.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793121
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](aArray.length)\n   \
    \     for(i <- 0 until xorArray.length)\n            xorArray(i) = (aArray(i)\
    \ XOR bArray(i)).toChar\n        new String(xorArray)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"\
    010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp71h15ilr.scala:13:37 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            xorArray(i) = (aArray(i) XOR bArray(i)).toChar\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                           value XOR is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793146
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = new StringBuilder\n        var i = 0\n      \
    \  while (i < aList.size) {\n            result.append(aList(i) ^ bList(i))\n\
    \            i += 1\n        }\n        return result.toString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = Array.ofDim[Char](2)\n        val xorArray2\
    \ = Array.ofDim[Char](2)\n        val xorArray3 = Array.ofDim[Char](2)\n     \
    \   val xorArray4 = Array.ofDim[Char](2)\n        val xorArray5 = Array.ofDim[Char](2)\n\
    \        val xorArray6 = Array.ofDim[Char](2)\n        val xorArray7 = Array.ofDim[Char](2)\n\
    \        val xorArray8 = Array.ofDim[Char](2)\n        val xorArray9 = Array.ofDim[Char](2)\n\
    \        val xorArray10 = Array.ofDim[Char](2)\n        val xorArray11 = Array.ofDim[Char](2)\n\
    \        val xorArray12 = Array.ofDim[Char](2)\n        val xorArray13 = Array.ofDim[Char](2)\n\
    \        val xorArray14 = Array.ofDim[Char](2)\n        val xorArray15 = Array.ofDim[Char](2)\n\
    \        val xorArray16 = Array.ofDim[Char](2)\n        val xorArray17 = Array.ofDim[Char](2)\n\
    \        val xorArray18 = Array.ofDim[Char](2)\n        val xorArray19 = Array.ofDim[Char](2)\n\
    \        val xorArray20 = Array.ofDim[Char](2)\n        val xorArray21 = Array.ofDim[Char](2)\n\
    \        val xorArray22 = Array.ofDim[Char](2)\n        val xorArray23 = Array.ofDim[Char](2)\n\
    \        val xorArray24 = Array.ofDim[Char](2)\n        val xorArray25 = Array.ofDim[Char](2)\n\
    \        val xorArray26 = Array.ofDim[Char](2)\n        val xorArray27 = Array.ofDim[Char](2)\n\
    \        val xorArray28 = Array.ofDim[Char](2)\n        val xorArray29 = Array.ofDim[Char](2)\n\
    \        val xorArray30 = Array.ofDim[Char](2)\n        val xorArray31 = Array.ofDim[Char](2)\n\
    \        val xorArray32 = Array.ofDim[Char](2)\n        val xorArray33 = Array.ofDim[Char](2)\n\
    \        val xorArray34 = Array.ofDim[Char](2)\n        val xorArray35 = Array.ofDim[Char](2)\n\
    \        val xorArray36 = Array.ofDim[Char](2)\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe5au4q7s.scala:48:5\
    \ ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659793138
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n\
    \        var result = 0\n        var i = 0\n        while (i < a.length) {\n \
    \           val aBit = aBits(i)\n            val bBit = bBits(i)\n           \
    \ result |= aBit ^ bBit\n            i += 1\n        }\n        return Integer.toBinaryString(result)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmp4shp01ij.scala:14:23 -----------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36maBit\e[0m = aBits(i)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                 \e[33mvalue\e[0m \e[35maBits\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E050] Type Error: /tmp/tmp4shp01ij.scala:15:23 -----------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mval\e[0m \e[36mbBit\e[0m = bBits(i)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                 \e[33mvalue\e[0m \e[35mbBits\e[0m does not take parameters\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659793145
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray\
    \ = b.toCharArray\n        val xorArray = new Array[Char](a.length)\n        var\
    \ i = 0\n        while (i < xorArray.length) {\n            xorArray(i) = aArray(i)\
    \ xor bArray(i)\n            i += 1\n        }\n        new String(xorArray)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg9fcjhwc.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            xorArray(i) = aArray(i) xor bArray(i)\n\e\
    [31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value xor is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659793146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = mutable.ArrayBuffer.empty[Int]\n\
    \        for(i <- 0 until aArray.length) xorArray += (aArray(i) xor bArray(i))\n\
    \        xorArray.toString.reverse\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpty4pgdhf.scala:11:23 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorArray\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793113
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aBits = a.toIntArray\n        val bBits\
    \ = b.toIntArray\n        val result = new mutable.StringBuilder\n        val\
    \ xor = new mutable.BitSet(aBits.length)\n        xor.set(aBits.length)\n    \
    \    val xorResult = new mutable.BitSet(aBits.length)\n        xorResult.set(aBits.length)\n\
    \        val xorResult2 = new mutable.BitSet(aBits.length)\n        xorResult2.set(aBits.length)\n\
    \        val xorResult3 = new mutable.BitSet(aBits.length)\n        xorResult3.set(aBits.length)\n\
    \        val xorResult4 = new mutable.BitSet(aBits.length)\n        xorResult4.set(aBits.length)\n\
    \        val xorResult5 = new mutable.BitSet(aBits.length)\n        xorResult5.set(aBits.length)\n\
    \        val xorResult6 = new mutable.BitSet(aBits.length)\n        xorResult6.set(aBits.length)\n\
    \        val xorResult7 = new mutable.BitSet(aBits.length)\n        xorResult7.set(aBits.length)\n\
    \        val xorResult8 = new mutable.BitSet(aBits.length)\n        xorResult8.set(aBits.length)\n\
    \        val xorResult9 = new mutable.BitSet(aBits.length)\n        xorResult9.set(aBits.length)\n\
    \        val xorResult10 = new mutable.BitSet(aBits.length)\n        xorResult10.set(aBits.length)\n\
    \        val xorResult11 = new mutable.BitSet(aBits.length)\n        xorResult11.set(aBits.length)\n\
    \        val xorResult12 = new mutable.BitSet(aBits.length)\n        xorResult12.set(aBits.length)\n\
    \        val xorResult13 = new mutable.BitSet(aBits.length)\n        xorResult13.set(aBits.length)\n\
    \        val xorResult14 = new mutable.BitSet(aBits.length)\n        xorResult14.set(aBits.length)\n\
    \        val xorResult15 = new mutable.BitSet(aBits.length)\n        xorResult15.set(aBits.length)\n\
    \        val xorResult16 = new mutable.BitSet(aBits.length)\n        xorResult16.set(aBits.length)\n\
    \        val xorResult17 = new mutable.BitSet(aBits.length)\n        xorResult17.set(aBits.length)\n\
    \        val xorResult18 = new mutable.BitSet(aBits.length)\n        xorResult18.set(aBits.length)\n\
    \        val xorResult19 = new mutable.BitSet(aBits.length)\n        x\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"\
    101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
    0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n \
    \   }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpr2r00ol4.scala:9:22 -------------------------\e\
    [0m\e[0m\n\e[31m9 |\e[0m        \e[33mval\e[0m \e[36maBits\e[0m = a.toIntArray\n\
    \e[31m\e[31m  |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m  |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpr2r00ol4.scala:10:22 ------------------------\e[0m\e\
    [0m\n\e[31m10 |\e[0m        \e[33mval\e[0m \e[36mbBits\e[0m = b.toIntArray\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                value toIntArray is not a member of String\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpr2r00ol4.scala:11:25 ------------------------\e[0m\e\
    [0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m\
    \ mutable.StringBuilder\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr2r00ol4.scala:12:22 ------------------------\e\
    [0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e[36mxor\e[0m = \e[33mnew\e[0m\
    \ mutable.BitSet(aBits.length)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpr2r00ol4.scala:14:28 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mxorResult\e[0m = \e[33mnew\e\
    [0m mutable.BitSet(aBits.length)\n\e[31m\e[31m   |\e[0m                      \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr2r00ol4.scala:16:29\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mxorResult2\e[0m = \e[33mnew\e[0m mutable.BitSet(aBits.length)\n\e[31m\e[31m\
    \   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \             "
  stdout: ''
  timestamp: 1659793147
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val xorList = mutable.ListBuffer.empty[String]\n        for(i\
    \ <- 0 until aList.length)\n            for(j <- 0 until bList.length)\n     \
    \           if(aList(i) == bList(j))\n                    xorList += aList(i)\n\
    \        xorList.toList.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n   \
    \ assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbknikew2.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793146
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toCharArray.map(_.toInt)\n \
    \       val bList = b.toCharArray.map(_.toInt)\n        val xorList = mutable.ListBuffer[Int]()\n\
    \        for(i <- 0 until aList.length) xorList += (aList(i) xor bList(i))\n \
    \       xorList.toString.toCharArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n\
    \    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"\
    0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe3q5qo66.scala:11:22 ------------------------\e\
    [0m\e[0m\n\e[31m11 |\e[0m        \e[33mval\e[0m \e[36mxorList\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659793146
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aArray = a.toCharArray.map(_.toInt)\n\
    \        val bArray = b.toCharArray.map(_.toInt)\n        val xorArray = aArray.zip(\n\
    \            bArray\n        ).map(x => x._1 ^ x._2)\n        val xorString =\
    \ xorArray.toString.map(_.toChar)\n        xorString.mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\"\
    )).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\"\
    )));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1ux2mjdy.scala:18)\n\tat Problem.main(tmp1ux2mjdy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659793147
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = new StringBuilder\n        var carry = 0\n  \
    \      for (i <- 0 until aList.size) {\n            val aChar = aList(i)\n   \
    \         val bChar = bList(i)\n            val aCharInt = aChar.toInt\n     \
    \       val bCharInt = bChar.toInt\n            val aCharIntInt = aCharInt.toInt\n\
    \            val bCharIntInt = bCharInt.toInt\n            val aCharIntIntInt\
    \ = aCharIntInt.toInt\n            val bCharIntIntInt = bCharIntInt.toInt\n  \
    \          val aCharIntIntIntInt = aCharIntIntInt.toInt\n            val bCharIntIntIntInt\
    \ = bCharIntIntInt.toInt\n            val aCharIntIntIntIntInt = aCharIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntInt = bCharIntIntIntInt.toInt\n            val\
    \ aCharIntIntIntIntIntInt = aCharIntIntIntIntInt.toInt\n            val bCharIntIntIntIntIntInt\
    \ = bCharIntIntIntIntInt.toInt\n            val aCharIntIntIntIntIntIntInt = aCharIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val bCharIntIntIntIntIntIntIntIntIntIntInt = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \            val aCharIntIntIntIntIntIntIntIntIntIntIntInt = aCharIntIntIntIntIntIntIntInt\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
    ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\"\
    )).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbhgeje87.scala:45:0 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbhgeje87.scala:35:57\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m\
    \ \e[36mbCharIntIntIntIntIntIntIntIntIntIntInt\e[0m = bCharIntIntIntIntIntIntIntIntIntIntIntInt.toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \        Not found: bCharIntIntIntIntIntIntIntIntIntIntIntInt\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbhgeje87.scala:44:1 ---------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpbhgeje87.scala:38:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m38 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659793147
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793125
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    //\
    \ Perform binary XOR on these inputs and return result also as a string.\n   \
    \ // >>> string_xor('010', '110')\n    // '100'\n    def stringXor(a : String,\
    \ b : String) : String = {\n        val aList = a.toList\n        val bList =\
    \ b.toList\n        val result = aList.zip(bList).map(x => x._1 ^ x._2).mkString\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"\
    111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"),\
    \ (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"\
    0101\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659793125
