language: scala
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj5yvyanq.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj5yvyanq.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj5yvyanq.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj5yvyanq.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj5yvyanq.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same gro"
  stdout: ''
  timestamp: 1659795240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else stack.pop())\n     \
    \   val stackSize = stack.size\n        if (stackSize == 0) \"No\" else \"Yes\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpewofhl79.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpewofhl79.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => if (x == \"(\") stack.push(x) else stack.pop())\n  \
    \      if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt2w7xpma.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpt2w7xpma.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795234
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            s match {\n                case \")\"\
    \ =>\n                    close.add (stack.last)\n                    stack.pop\n\
    \                case \")(\"  =>\n                    stack.push (s)\n       \
    \         case \")(\"  =>\n                    stack.push (s)\n              \
    \  case \")(\" =>\n                    stack.push (s)\n                case \"\
    )\" =>\n                    close.add (stack.last)\n                    stack.pop\n\
    \                case _ =>\n                    open += s\n            }\n   \
    \     }\n        if (stack.size < 2) \"No\"\n        else {\n            val open1\
    \ = open.toList\n            val close1 = close.toList\n            val open2\
    \ = open1.filterNot(close1.contains)\n            if (open2.size == 0) \"No\"\n\
    \            else {\n                val open3 = open2.filterNot(open1.contains)\n\
    \                if (open3.size == 0) \"No\"\n                else {\n       \
    \             val open4 = open3.filterNot(open1.contains)\n                  \
    \  if (open4.size == 0) \"No\"\n                    else {\n                 \
    \       val open5 = open4.filterNot(open1.contains)\n                        if\
    \ (open5.size == 0) \"No\"\n                        else {\n                 \
    \           val open6 = open5.filterNot(open1.contains)\n                    \
    \        if (open6.size == 0) \"No\"\n                            else {\n   \
    \                             val open7 = open6.filterNot(open1.contains)\n  \
    \                              if (open7.size == 0) \"No\"\n                 \
    \               else {\n                                    val open8 = open7.filterNot(open1.contains)\n\
    \                                    if (open8.size == 0) \"No\"\n           \
    \                         else {\n                                        val\
    \ open9 = open8.filterNot(open1.contains)\n                                  \
    \      if (open9.size == 0) \"No\"\n                                        else\
    \ {\n                                            val open10 = open9.filterNot(open1.contains)\n\
    \                                            if (open10.size == 0) \"No\"\n  \
    \                                          else {\n                          \
    \                      val open11 = open10.filterNot(open1.contains)\n       \
    \                                         if (open11.size == 0) \"No\"\n     \
    \                                           else {\n                         \
    \                           val open12 = open11.filterNot(open1.contains)\n  \
    \                                                  if (open12.size == 0) \"No\"\
    \n                                                    else {\n               \
    \                                         val open13 = open12.filterNot(open1.contains)\n\
    \                                                        if (open13.size == 0)\
    \ \"No\"\n                                                        else {\n   \
    \                                                         val open14 = open13.filterNot(open1.contains)\n\
    \                                                            if (open14.\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnsmr_vbl.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpnsmr_vbl.scala:97:0 ----------------------------\e[0m\e[0m\n\e[31m97\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnsmr_vbl.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpnsmr_vbl.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpnsmr_vbl.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpnsmr_vbl.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpnsmr_vbl.scala:96:1 ---------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   "
  stdout: ''
  timestamp: 1659795240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        for(i <- 0 until stackSize) {\n   \
    \         val str = lst(i)\n            val open = str.indexOf(\"(\")\n      \
    \      val close = str.indexOf(\")\")\n            if(open < 0 || close < 0) {\n\
    \                result += \"No\"\n                return result.toString\n  \
    \          }\n            val openCount = stack.length\n            val closeCount\
    \ = openCount - 1\n            val openParen = str.indexOf(\"(\", open)\n    \
    \        val closeParen = str.indexOf(\")\", close)\n            val openParenCount\
    \ = openParen - open\n            val closeParenCount = closeParen - close\n \
    \           val openParenCount = openParenCount - 1\n            val closeParenCount\
    \ = closeParenCount - 1\n            val openCount = openParenCount + closeParenCount\n\
    \            val closeCount = closeParenCount + openParenCount\n            if(openCount\
    \ > closeCount) {\n                result += \"No\"\n                return result.toString\n\
    \            }\n            val openParenIndex = stack.indexOf(\"(\", openParen)\n\
    \            val closeParenIndex = stack.indexOf(\")\", closeParen)\n        \
    \    val openParenIndex = openParenIndex + 1\n            val closeParenIndex\
    \ = closeParenIndex + 1\n            val openParenCount = openParenIndex - openParen\n\
    \            val closeParenCount = closeParenIndex - closeParen\n            val\
    \ openParenCount = openParenCount - 1\n            val closeParenCount = closeParenCount\
    \ - 1\n            val openCount = openParenCount + closeParenCount\n        \
    \    val closeCount = closeParenCount + openParenCount\n            if(openCount\
    \ > closeCount) {\n                result += \"No\"\n                return result.toString\n\
    \            }\n            val openParenIndex = stack.indexOf(\"(\", openParen)\n\
    \            val closeParenIndex = stack.indexOf(\")\", closeParen)\n        \
    \    val openParenIndex = openParenIndex + 1\n            val closeParenIndex\
    \ = closeParenIndex + 1\n            val openParenCount = openParenIndex - openParen\n\
    \            val closeParenCount = closeParenIndex - closeParen\n            val\
    \ openParenCount = openParenCount - 1\n            val closeParenCount = closeParenCount\
    \ - 1\n            val openCount = openParenCount + closeParenCount\n        \
    \    val closeCount = closeParenCount + openParenCount\n            if(openCount\
    \ > closeCount) {\n                result += \"No\"\n                return result.toString\n\
    \            }\n            val openParenIndex = stack.indexOf(\"(\", openParen)\n\
    \            val closeParenIndex = stack.indexOf(\")\", closeParen)\n        \
    \    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9n5b8izc.scala:89:0 ----------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9n5b8izc.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9n5b8izc.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9n5b8izc.scala:33:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36mopenParenCount\e[0m = openParenCount - \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopenParenCount is already defined as \e[33mvalue\e[0m \e[35mopenParenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9n5b8izc.scala:34:16 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m            \e[33mval\e[0m \e[36mcloseParenCount\e[0m = closeParenCount\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcloseParenCount is already defined as \e[33mvalue\e[0m \e\
    [35mcloseParenCount\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9n5b8izc.scala:45:16 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            \e[33mval\e[0m \e[36mopenParenCount\e[0m\
    \ = ope"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val newStr = str.substring(open + 1, close)\n            val newStack\
    \ = stack.dropRight(1)\n            val newResult = result.dropRight(1)\n    \
    \        val newStackPush = stack.push(\"(\")\n            val newResultPush =\
    \ result.push(\"(\")\n            val newStackPop = stack.pop()\n            val\
    \ newResultPop = result.pop()\n            if(newStack.isEmpty && newResult.isEmpty)\
    \ {\n                val newStackPush2 = stack.push(\"(\")\n                val\
    \ newResultPush2 = result.push(\"(\")\n                val newStackPop2 = stack.pop()\n\
    \                val newResultPop2 = result.pop()\n                if(newStackPush2\
    \ != newStackPop2 && newResultPush2 != newResultPop2) {\n                    return\
    \ \"No\"\n                }\n            }\n            if(newStackPush != newStackPop\
    \ && newResultPush != newResultPop) {\n                return \"No\"\n       \
    \     }\n            stack.push(newStr)\n            result.push(newStr)\n   \
    \     }\n        if(stack.size == 0) {\n            return \"Yes\"\n        }\n\
    \        return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaj54sx_v.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpaj54sx_v.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        val openCount = mutable.ListBuffer[Int]()\n        val closeCount = mutable.ListBuffer[Int]()\n\
    \        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n        \
    \        open += s\n                openCount += 1 \n            } else if (s.startsWith(\"\
    )\")) {\n                close += s\n                closeCount += 1 \n      \
    \      } else {\n                stack += s\n            }\n        }\n      \
    \  if (openCount.sum != closeCount.sum) {\n            return \"No\"\n       \
    \ }\n        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val open = open.toList\n        val close = close.toList\n        val\
    \ stack = stack.toList\n        val stackSize = stack.size\n        val stackSize\
    \ = stackSize.toInt\n        val openCount = openCount.toList\n        val closeCount\
    \ = closeCount.toList\n        val openCount = openCount.toList\n        val closeCount\
    \ = closeCount.toList\n        val open = open.toList\n        val close = close.toList\n\
    \        val stack = stack.toList\n        val stackSize = stack.size\n      \
    \  val stackSize = stackSize.toInt\n        val openCount = openCount.toList\n\
    \        val closeCount = closeCount.toList\n        val openCount = openCount.toList\n\
    \        val closeCount = closeCount.toList\n        val open = open.toList\n\
    \        val close = close.toList\n        val stack = stack.toList\n        val\
    \ stackSize = stack.size\n        val stackSize = stackSize.toInt\n        val\
    \ openCount = openCount.toList\n        val closeCount = closeCount.toList\n \
    \       val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val open = open.toList\n        val close = close.toList\n        val\
    \ stack = stack.toList\n        val stackSize = stack.size\n        val stackSize\
    \ = stackSize.toInt\n        val openCount = openCount.toList\n        val closeCount\
    \ = closeCount.toList\n        val openCount = openCount.toList\n        val closeCount\
    \ = closeCount.toList\n        val open = open.toList\n        val close = close.toList\n\
    \        val stack = stack\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpafui4123.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpafui4123.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcloseCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpafui4123.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopen\e[0m = open.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopen is already defined as \e[33mvalue\e[0m \e[35mopen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpafui4123.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = close.toList\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mclose is already\
    \ defined as \e[33mvalue\e[0m \e[35mclose\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpafui4123.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstack\e[0m = stack.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the "
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\" => {\n                    open.push(x)\n                }\n    \
    \            case \")(\" => {\n                    stack.push(x)\n           \
    \     }\n                case \")\" => {\n                    val str = stack.pop()\n\
    \                    val openStr = open.pop()\n                    val closeStr\
    \ = close.pop()\n                    val newStr = str + openStr + closeStr\n \
    \                   result.add(newStr)\n                }\n                case\
    \ _ => {\n                    stack.push(x)\n                }\n            }\n\
    \        })\n        if (close.isEmpty) {\n            return \"No\"\n       \
    \ }\n        if (open.isEmpty) {\n            return \"Yes\"\n        }\n    \
    \    if (close.size == open.size) {\n            return \"Yes\"\n        }\n \
    \       return \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7wgplpvp.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7wgplpvp.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7wgplpvp.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7wgplpvp.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.length){\n            val str = lst(i)\n       \
    \     if(str == \"(\"){\n                stack.push(str)\n            }else if(str\
    \ == \")\"){\n                val top = stack.pop()\n                if(top ==\
    \ str){\n                    result += \"Yes\"\n                }else{\n     \
    \               result += \"No\"\n                }\n            }else{\n    \
    \            result += \"No\"\n            }\n        }\n        result.mkString(\"\
    ,\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo2t99nrf.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpo2t99nrf.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        lst.foreach(x => x\
    \ match {\n            case x if x.startsWith(\"(\") => stack += x\n         \
    \   case x if x.startsWith(\")\") => queue += x\n            case x => result\
    \ += x\n        })\n        val stackSize = stack.size\n        val queueSize\
    \ = queue.size\n        val isGood = stackSize == queueSize\n        if (isGood)\
    \ {\n            val stack = stack.drop(stackSize)\n            val queue = queue.drop(queueSize)\n\
    \            val stackStr = stack.toList\n            val queueStr = queue.toList\n\
    \            val stackStrSize = stackStr.size\n            val queueStrSize =\
    \ queueStr.size\n            val isGood = stackStrSize == queueStrSize\n     \
    \       if (isGood) {\n                val stackStr = stackStr.drop(stackStrSize\
    \ - 1)\n                val queueStr = queueStr.drop(queueStrSize - 1)\n     \
    \           val stackStrSize = stackStr.size\n                val queueStrSize\
    \ = queueStr.size\n                val isGood = stackStrSize == queueStrSize\n\
    \                if (isGood) {\n                    val stackStr = stackStr.drop(stackStrSize\
    \ - 1)\n                    val queueStr = queueStr.drop(queueStrSize - 1)\n \
    \                   val stackStrSize = stackStr.size\n                    val\
    \ queueStrSize = queueStr.size\n                    val isGood = stackStrSize\
    \ == queueStrSize\n                    if (isGood) {\n                       \
    \ val stackStr = stackStr.drop(stackStrSize - 1)\n                        val\
    \ queueStr = queueStr.drop(queueStrSize - 1)\n                        val stackStrSize\
    \ = stackStr.size\n                        val queueStrSize = queueStr.size\n\
    \                        val isGood = stackStrSize == queueStrSize\n         \
    \               if (isGood) {\n                            val stackStr = stackStr.drop(stackStrSize\
    \ - 1)\n                            val queueStr = queueStr.drop(queueStrSize\
    \ - 1)\n                            val stackStrSize = stackStr.size\n       \
    \                     val queueStrSize = queueStr.size\n                     \
    \       val isGood = stackStrSize == queueStrSize\n                          \
    \  if (isGood) {\n                                val stackStr = stackStr.drop(stackStrSize\
    \ - 1)\n                                val queueStr = queueStr.drop(queueStrSize\
    \ - 1)\n                                val stackStrSize = stackStr.size\n   \
    \                             val queueStrSize = queueStr.size\n             \
    \                   val isGood = stackStrSize == queueStrSize\n              \
    \                  if (is\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3entl63u.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3entl63u.scala:83:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m83 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp3entl63u.scala:16:20 ------------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp3entl63u.scala:17:20 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3entl63u.scala:18:21 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp3entl63u.scala:28:24 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mstack\e[0m = stack.drop(stackSize)\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mstack\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3entl63u.scala:29:24 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mqueue\e[0m "
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => open.push(x)\n           \
    \     case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")(\" => close.push(x)\n                case \")()\" =>\
    \ open.push(x)\n                case _ => stack.push(x)\n            }\n     \
    \   })\n        val openCount = open.size\n        val closeCount = close.size\n\
    \        if (openCount == closeCount) {\n            val openStack = stack.take(openCount)\n\
    \            val closeStack = stack.drop(closeCount)\n            val openStackSize\
    \ = openStack.size\n            val closeStackSize = closeStack.size\n       \
    \     if (openStackSize == closeStackSize) {\n                val openStack =\
    \ stack.take(openStackSize)\n                val closeStack = stack.drop(closeStackSize)\n\
    \                val openStackSize = openStack.size\n                val closeStackSize\
    \ = closeStack.size\n                if (openStackSize == closeStackSize) {\n\
    \                    val openStack = stack.take(openStackSize)\n             \
    \       val closeStack = stack.drop(closeStackSize)\n                    val openStackSize\
    \ = openStack.size\n                    val closeStackSize = closeStack.size\n\
    \                    if (openStackSize == closeStackSize) {\n                \
    \        val openStack = stack.take(openStackSize)\n                        val\
    \ closeStack = stack.drop(closeStackSize)\n                        val openStackSize\
    \ = openStack.size\n                        val closeStackSize = closeStack.size\n\
    \                        if (openStackSize == closeStackSize) {\n            \
    \                val openStack = stack.take(openStackSize)\n                 \
    \           val closeStack = stack.drop(closeStackSize)\n                    \
    \        val openStackSize = openStack.size\n                            val closeStackSize\
    \ = closeStack.size\n                            if (openStackSize == closeStackSize)\
    \ {\n                                val openStack = stack.take(openStackSize)\n\
    \                                val closeStack = stack.drop(closeStackSize)\n\
    \                                val openStackSize = openStack.size\n        \
    \                        val closeStackSize = closeStack.size\n              \
    \                  if (openStackSize == closeStackSize) {\n                  \
    \                  val openStack = stack.take(openStackSize)\n               \
    \                     val closeStack = stack.drop(closeStackSize)\n          \
    \                          val openStackSize = openStack.size\n              \
    \                      val closeStack\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5jqxfqaf.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5jqxfqaf.scala:85:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m85 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp5jqxfqaf.scala:16:20 ------------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp5jqxfqaf.scala:17:21 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5jqxfqaf.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp5jqxfqaf.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmp5jqxfqaf.scala:69:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m69 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e["
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   else if (x == \")\") close += x\n            else stack += x\n        })\n\
    \        if (open.size == 0 && close.size == 0) \"No\"\n        else if (open.size\
    \ == 0 && close.size > 0) \"Yes\"\n        else if (open.size > 0 && close.size\
    \ == 0) \"No\"\n        else if (open.size > 0 && close.size > 0) \"Yes\"\n  \
    \      else matchParens(stack.toList)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw13o0yx8.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpw13o0yx8.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpw13o0yx8.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpw13o0yx8.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openCount = stack.length\n      \
    \          val closeCount = stack.length\n                stack.push(str)\n  \
    \              while(openCount > 0 && closeCount > 0) {\n                    val\
    \ open = stack.pop()\n                    val close = stack.pop()\n          \
    \          if(open != close) {\n                        result.append(\"No\")\n\
    \                        return\n                    }\n                    openCount\
    \ -= 1\n                    closeCount -= 1\n                }\n             \
    \   result.append(\"Yes\")\n            }\n        }\n        result.mkString(\"\
    ,\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsrf1cdi8.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsrf1cdi8.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpsrf1cdi8.scala:33:24 --------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        \e[33mreturn\e[0m\n\e[31m\e[31m\
    \   |\e[0m                        ^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \         Found:    Unit\n\e[31m   |\e[0m                        Required: String\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") stack.push(x)\n     \
    \       if (x == \"(\") stack += x\n            if (x == \")\") stack -= x\n \
    \           if (x == \")\") result += stack.toList\n        })\n        if (result.size\
    \ == lst.length) result.mkString(\"(\", \")\")\n        else result.mkString(\"\
    (\", \")\", \"(\", \")\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpczxlvthj.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpczxlvthj.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n\
    \        val stackSize3 = stackSize2 * stackSize\n        val stackSize4 = stackSize3\
    \ * stackSize\n        val stackSize5 = stackSize4 * stackSize\n        val stackSize6\
    \ = stackSize5 * stackSize\n        val stackSize7 = stackSize6 * stackSize\n\
    \        val stackSize8 = stackSize7 * stackSize\n        val stackSize9 = stackSize8\
    \ * stackSize\n        val stackSize10 = stackSize9 * stackSize\n        val stackSize11\
    \ = stackSize10 * stackSize\n        val stackSize12 = stackSize11 * stackSize\n\
    \        val stackSize13 = stackSize12 * stackSize\n        val stackSize14 =\
    \ stackSize13 * stackSize\n        val stackSize15 = stackSize14 * stackSize\n\
    \        val stackSize16 = stackSize15 * stackSize\n        val stackSize17 =\
    \ stackSize16 * stackSize\n        val stackSize18 = stackSize17 * stackSize\n\
    \        val stackSize19 = stackSize18 * stackSize\n        val stackSize20 =\
    \ stackSize19 * stackSize\n        val stackSize21 = stackSize20 * stackSize\n\
    \        val stackSize22 = stackSize21 * stackSize\n        val stackSize23 =\
    \ stackSize22 * stackSize\n        val stackSize24 = stackSize23 * stackSize\n\
    \        val stackSize25 = stackSize24 * stackSize\n        val stackSize26 =\
    \ stackSize25 * stackSize\n        val stackSize27 = stackSize26 * stackSize\n\
    \        val stackSize28 = stackSize27 * stackSize\n        val stackSize29 =\
    \ stackSize28 * stackSize\n        val stackSize30 = stackSize29 * stackSize\n\
    \        val stackSize31 = stackSize30 * stackSize\n        val stackSize32 =\
    \ stackSize31 * stackSize\n        val stackSize33 = stackSize32 * stackSize\n\
    \        val stackSize34 = stackSize33 * stackSize\n        val stackSize35 =\
    \ stackSize34 * stackSize\n        val stackSize36 = stackSize35 * stackSize\n\
    \        val stackSize37 = stackSize36 * stackSize\n        val stackSize38 =\
    \ stackSize37 * stackSize\n        val stackSize39 = stackSize38 * stackSize\n\
    \        val stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6b9lran6.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6b9lran6.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val len = open - close\n            if(len > 0) {\n           \
    \     stack.push(str)\n                while(stack.size > 0 && stack.head != str)\
    \ {\n                    val top = stack.pop()\n                    if(top.length\
    \ == len) {\n                        result += (top + str.substring(close+1))\n\
    \                    }\n                }\n            }\n        }\n        if(result.size\
    \ == lst.size) {\n            val str = result.mkString\n            if(str.contains(\"\
    (\") && str.contains(\")\")) {\n                return \"Yes\"\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplo0nhzwe.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmplo0nhzwe.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n\
    \        val stackSize3 = stackSize2 * stackSize\n        val stackSize4 = stackSize3\
    \ * stackSize\n        val stackSize5 = stackSize4 * stackSize\n        val stackSize6\
    \ = stackSize5 * stackSize\n        val stackSize7 = stackSize6 * stackSize\n\
    \        val stackSize8 = stackSize7 * stackSize\n        val stackSize9 = stackSize8\
    \ * stackSize\n        val stackSize10 = stackSize9 * stackSize\n        val stackSize11\
    \ = stackSize10 * stackSize\n        val stackSize12 = stackSize11 * stackSize\n\
    \        val stackSize13 = stackSize12 * stackSize\n        val stackSize14 =\
    \ stackSize13 * stackSize\n        val stackSize15 = stackSize14 * stackSize\n\
    \        val stackSize16 = stackSize15 * stackSize\n        val stackSize17 =\
    \ stackSize16 * stackSize\n        val stackSize18 = stackSize17 * stackSize\n\
    \        val stackSize19 = stackSize18 * stackSize\n        val stackSize20 =\
    \ stackSize19 * stackSize\n        val stackSize21 = stackSize20 * stackSize\n\
    \        val stackSize22 = stackSize21 * stackSize\n        val stackSize23 =\
    \ stackSize22 * stackSize\n        val stackSize24 = stackSize23 * stackSize\n\
    \        val stackSize25 = stackSize24 * stackSize\n        val stackSize26 =\
    \ stackSize25 * stackSize\n        val stackSize27 = stackSize26 * stackSize\n\
    \        val stackSize28 = stackSize27 * stackSize\n        val stackSize29 =\
    \ stackSize28 * stackSize\n        val stackSize30 = stackSize29 * stackSize\n\
    \        val stackSize31 = stackSize30 * stackSize\n        val stackSize32 =\
    \ stackSize31 * stackSize\n        val stackSize33 = stackSize32 * stackSize\n\
    \        val stackSize34 = stackSize33 * stackSize\n        val stackSize35 =\
    \ stackSize34 * stackSize\n        val stackSize36 = stackSize35 * stackSize\n\
    \        val stackSize37 = stackSize36 * stackSize\n        val stackSize38 =\
    \ stackSize37 * stackSize\n        val stackSize39 = stackSize38 * stackSize\n\
    \        val stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6b9lran6.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6b9lran6.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.add(x)\n\
    \            case x if x == \"(\" => open.add(x)\n            case _ => stack\
    \ += x\n        })\n        val openCount = open.size\n        val closeCount\
    \ = close.size\n        if (openCount == closeCount) {\n            result +=\
    \ \"Yes\"\n        } else {\n            result += \"No\"\n        }\n       \
    \ result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzjah0xhp.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzjah0xhp.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzjah0xhp.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpzjah0xhp.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop()\n                }\n                case\
    \ \")()\" => {\n                    stack += x\n                }\n          \
    \      case \")(\" => {\n                    stack += x\n                }\n \
    \               case _ => {\n                    stack += x\n                }\n\
    \            }\n        })\n        stack.toList match {\n            case Nil\
    \ => {\n                result.add(\"Yes\")\n            }\n            case _\
    \ => {\n                result.add(\"No\")\n            }\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxd57d5eg.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxd57d5eg.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x startsWith \"(\"\
    \ => open.push(x)\n            case x if x startsWith \")\" => close.push(x)\n\
    \            case _ => stack.push(x)\n        })\n        val openCount = open.size\n\
    \        val closeCount = close.size\n        if (openCount == 0 || closeCount\
    \ == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqyhndhe3.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqyhndhe3.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqyhndhe3.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqyhndhe3.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val stackSize = lst.size\n        for(i <- 0 until stackSize) {\n   \
    \         val str = lst(i)\n            val open = str.indexOf(\"(\")\n      \
    \      val close = str.indexOf(\")\")\n            if(open < 0 || close < 0) {\n\
    \                result.append(\"No\")\n                return result.toString()\n\
    \            }\n            val openCount = stackSize - open\n            val\
    \ closeCount = close - open\n            if(openCount > closeCount) {\n      \
    \          result.append(\"No\")\n                return result.toString()\n \
    \           }\n            val openParen = str.substring(0, open)\n          \
    \  val closeParen = str.substring(close)\n            val openParenCount = openParen.length\n\
    \            val closeParenCount = closeParen.length\n            val openParenStack\
    \ = stack.take(openParenCount)\n            val closeParenStack = stack.drop(closeParenCount)\n\
    \            val newStack = openParenStack ++ closeParenStack\n            val\
    \ newStackSize = newStack.size\n            val newStackStr = newStack.mkString(\"\
    (\", \")\")\n            if(newStackStr == str) {\n                result.append(\"\
    Yes\")\n                return result.toString()\n            }\n            stack\
    \ += newStack\n        }\n        result.append(\"No\")\n        return result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqxcwkdf6.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqxcwkdf6.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795236
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            val open = s.indexOf(\"(\")\n       \
    \     val close = s.indexOf(\")\")\n            if (open < 0 || close < 0) return\n\
    \            if (open > close) return\n            if (open > stack.size) {\n\
    \                stack += s\n            } else {\n                val top = stack.pop()\n\
    \                if (top != s) {\n                    result += \"No\"\n     \
    \               return\n                }\n            }\n        }\n        result\
    \ += \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxa1nc_8r.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxa1nc_8r.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpxa1nc_8r.scala:21:39 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (open < \e[31m0\e[0m || close\
    \ < \e[31m0\e[0m) \e[33mreturn\e[0m\n\e[31m\e[31m   |\e[0m                   \
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \           Found:    Unit\n\e[31m   |\e[0m                                  \
    \     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxa1nc_8r.scala:22:30\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (open\
    \ > close) \e[33mreturn\e[0m\n\e[31m\e[31m   |\e[0m                          \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                              Found:    Unit\n\
    \e[31m   |\e[0m                              Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxa1nc_8r.scala:29:20 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                    \e[33mreturn\e[0m\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m                    Found:\
    \    Unit\n\e[31m   |\e[0m                    Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with "
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   if (x == \")\") close += x\n            if (open.contains(x)) stack += x\n\
    \            if (close.contains(x)) stack -= x\n        })\n        if (stack.size\
    \ == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu0fxduub.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpu0fxduub.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpu0fxduub.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpu0fxduub.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795235
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hr16b0o.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hr16b0o.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7hr16b0o.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hr16b0o.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7hr16b0o.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same gro"
  stdout: ''
  timestamp: 1659795254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach(x => if (x == \"\
    (\") stack += x else if (!x == \"(\") queue += x else ())\n        while (stack.nonEmpty\
    \ || queue.nonEmpty) {\n            val x = stack.pop() match {\n            \
    \    case \")\" => good.remove(x)\n                case \")(\"  => stack += x\n\
    \                case \")(\" => queue += x\n                case _ => ()\n   \
    \         }\n        }\n        if (good.size == 0) \"No\" else \"Yes\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt9fxaga_.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpt9fxaga_.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpt9fxaga_.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpt9fxaga_.scala:19:59 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) queue += x \e[33melse\e[0m ())\n\e[31m\e[31m   |\e[0m              \
    \                                             ^^\e[0m\n\e[31m   |\e[0m       \
    \                          value unary_! is not a member of String\n4 errors found\n"
  stdout: ''
  timestamp: 1659795253
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openCount = stack.length\n      \
    \          val closeCount = stack.length\n                while(open < close &&\
    \ openCount > 0 && closeCount > 0) {\n                    if(openCount > closeCount)\
    \ {\n                        stack.pop\n                        openCount -= 1\n\
    \                    } else {\n                        stack.pop\n           \
    \             closeCount -= 1\n                    }\n                }\n    \
    \            if(openCount > closeCount) {\n                    stack.append(str)\n\
    \                } else {\n                    result.append(\"Yes\")\n      \
    \          }\n            }\n        }\n        result.mkString(\",\")\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp329_uak4.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp329_uak4.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                stack.push(x)\n\
    \            } else if (x == \")\") {\n                if (stack.nonEmpty) {\n\
    \                    val top = stack.pop()\n                    if (top == \"\
    (\") {\n                        result += \"(\" + top + \")\"\n              \
    \      } else {\n                        result += \"(\" + top + \")\"\n     \
    \               }\n                } else {\n                    result += \"\
    (\" + x + \")\"\n                }\n            }\n        })\n        if (result.nonEmpty)\
    \ {\n            val last = result.last\n            if (last.startsWith(\"(\"\
    ) && last.endsWith(\")\")) {\n                result.last = \"Yes\"\n        \
    \    } else {\n                result.last = \"No\"\n            }\n        }\n\
    \        result.last\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzhu733wj.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzhu733wj.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795247
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open != -1 && close != -1) {\n                val stackStr =\
    \ str.substring(open + 1, close)\n                if(!stackStr.isEmpty) {\n  \
    \                  stack.push(stackStr)\n                }\n                val\
    \ newStr = str.substring(0, open) + str.substring(close + 1)\n               \
    \ if(!stackStr.isEmpty && newStr != str) {\n                    result.add(\"\
    No\")\n                    return result.toString\n                }\n       \
    \     }\n        }\n        result.add(\"Yes\")\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_3uojrss.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_3uojrss.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val newStr = str.substring(open + 1, close)\n            val newStack\
    \ = stack.dropRight(1)\n            val newResult = result.dropRight(1)\n    \
    \        val newStackPush = stack.push(newStr)\n            val newResultPush\
    \ = result.push(newStr)\n            val newStackPop = stack.pop()\n         \
    \   val newResultPop = result.pop()\n            val newStackEmpty = stack.isEmpty\n\
    \            val newResultEmpty = result.isEmpty\n            val newStackEmptyOrPop\
    \ = stack.isEmpty || stack.pop() == newStr\n            val newResultEmptyOrPop\
    \ = result.isEmpty || result.pop() == newStr\n            val newStackEmptyOrPopOrPush\
    \ = newStackEmpty || newStackPop == newStr\n            val newResultEmptyOrPopOrPush\
    \ = newResultEmpty || newResultPop == newStr\n            val newStackEmptyOrPopOrPushOrPop\
    \ = newStackEmptyOrPop || newStackPush == newStr\n            val newResultEmptyOrPopOrPushOrPop\
    \ = newResultEmptyOrPop || newResultPush == newStr\n            val newStackEmptyOrPopOrPushOrPopOrPush\
    \ = newStackEmptyOrPopOrPush || newStackPop == newStr || newStackPush == newStr\n\
    \            val newResultEmptyOrPopOrPushOrPopOrPush = newResultEmptyOrPopOrPush\
    \ || newResultPop == newStr || newResultPush == newStr\n            val newStackEmptyOrPopOrPushOrPopOrPush\
    \ = newStackEmptyOrPopOrPushOrPop || newStackPush == newStr || newStackPop ==\
    \ newStr || newStackPush == newStr || newStackPop == newStr\n            val newResultEmptyOrPopOrPushOrPopOrPush\
    \ = newResultEmptyOrPopOrPushOrPop || newResultPush == newStr || newResultPop\
    \ == newStr || newResultPush == newStr || newResultPop == newStr || newResultPush\
    \ == newStr\n            val newStackEmptyOrPopOrPushOrPopOrPushOrPush = newStackEmptyOrPopOrPushOrPopOrPush\
    \ || newStackPush == newStr || newStackPop == newStr || newStackPush == newStr\
    \ || newStackPop == newStr || newStackPush\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj5migkfs.scala:59:0 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj5migkfs.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj5migkfs.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj5migkfs.scala:58:1\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpj5migkfs.scala:43:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m43 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659795255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n\
    \        val stackSize3 = stackSize2 * stackSize\n        val stackSize4 = stackSize3\
    \ * stackSize\n        val stackSize5 = stackSize4 * stackSize\n        val stackSize6\
    \ = stackSize5 * stackSize\n        val stackSize7 = stackSize6 * stackSize\n\
    \        val stackSize8 = stackSize7 * stackSize\n        val stackSize9 = stackSize8\
    \ * stackSize\n        val stackSize10 = stackSize9 * stackSize\n        val stackSize11\
    \ = stackSize10 * stackSize\n        val stackSize12 = stackSize11 * stackSize\n\
    \        val stackSize13 = stackSize12 * stackSize\n        val stackSize14 =\
    \ stackSize13 * stackSize\n        val stackSize15 = stackSize14 * stackSize\n\
    \        val stackSize16 = stackSize15 * stackSize\n        val stackSize17 =\
    \ stackSize16 * stackSize\n        val stackSize18 = stackSize17 * stackSize\n\
    \        val stackSize19 = stackSize18 * stackSize\n        val stackSize20 =\
    \ stackSize19 * stackSize\n        val stackSize21 = stackSize20 * stackSize\n\
    \        val stackSize22 = stackSize21 * stackSize\n        val stackSize23 =\
    \ stackSize22 * stackSize\n        val stackSize24 = stackSize23 * stackSize\n\
    \        val stackSize25 = stackSize24 * stackSize\n        val stackSize26 =\
    \ stackSize25 * stackSize\n        val stackSize27 = stackSize26 * stackSize\n\
    \        val stackSize28 = stackSize27 * stackSize\n        val stackSize29 =\
    \ stackSize28 * stackSize\n        val stackSize30 = stackSize29 * stackSize\n\
    \        val stackSize31 = stackSize30 * stackSize\n        val stackSize32 =\
    \ stackSize31 * stackSize\n        val stackSize33 = stackSize32 * stackSize\n\
    \        val stackSize34 = stackSize33 * stackSize\n        val stackSize35 =\
    \ stackSize34 * stackSize\n        val stackSize36 = stackSize35 * stackSize\n\
    \        val stackSize37 = stackSize36 * stackSize\n        val stackSize38 =\
    \ stackSize37 * stackSize\n        val stackSize39 = stackSize38 * stackSize\n\
    \        val stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6b9lran6.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6b9lran6.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \")()\" => close.push(x)\n            case x if x\
    \ == \"()\" => open.push(x)\n            case x if x == \")(\" => open.push(x)\n\
    \            case x if x == \")()()\" => open.push(x)\n            case x if x\
    \ == \")(\" => stack.push(x)\n            case x if x == \")()\" => stack.push(x)\n\
    \            case x if x == \")()()\" => stack.push(x)\n            case x if\
    \ x == \")(\" => stack.push(x)\n            case x if x == \")()()\" => stack.push(x)\n\
    \            case x if x == \")(\" => stack.push(x)\n            case x if x ==\
    \ \")()()\" => stack.push(x)\n            case x if x == \")(\" => stack.push(x)\n\
    \            case x if x == \")()()\" => stack.push(x)\n            case x if\
    \ x == \")(\" => stack.push(x)\n            case x if x == \")()()\" => stack.push(x)\n\
    \            case x if x == \")(\" => stack.push(x)\n            case x if x ==\
    \ \")()()\" => stack.push(x)\n            case x if x == \")(\" => stack.push(x)\n\
    \            case x if x == \")()()\" => stack.push(x)\n            case x if\
    \ x == \")(\" => stack.push(x)\n            case x if x == \")()()\" => stack.push(x)\n\
    \            case x if x == \")(\" => stack.push(x)\n            case x if x ==\
    \ \")()()\" => stack.push(x)\n            case x if x == \")(\" => stack.push(x)\n\
    \            case x if x == \")()()\" => stack.push(x)\n            case x if\
    \ x == \")(\" => stack.push(x)\n            case x if x == \")()()\" => stack.push(x)\n\
    \            case x if x == \")(\" => stack.push(x)\n            case x if x ==\
    \ \")()()\" => stack.push(x)\n            case x if x == \")(\" => stack.push(x)\n\
    \            case x if x == \")()()\" => stack.push(x)\n            case x if\
    \ x == \")(\" => stack.push(x)\n            case x if x == \")()()\" => stack.push(x)\n\
    \            case x if x == \")(\" => stack.push(x)\n            case x if x ==\
    \ \")()()\" => stack.push(x)\n            case x if x == \")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp7_3gpxfq.scala:57:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m x == \")\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     unclosed string literal\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp7_3gpxfq.scala:59:4 ----------------------------\e[0m\e[0m\n\e[31m59\
    \ |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e\
    [35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^^\e[0m\n\e[31m   |\e[0m   \
    \ ')' expected, but identifier found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7_3gpxfq.scala:75:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m75 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp7_3gpxfq.scala:16:20 ------------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp7_3gpxfq.scala:17:21 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7_3gpxfq.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp7_3gpxfq.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |"
  stdout: ''
  timestamp: 1659795249
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   if (x == \")\") close += x\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"Yes\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (close.isEmpty && !open.isEmpty) result += \"No\"\n \
    \           if (open.isEmpty && close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"\
    No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n     \
    \       if (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close.isEmpty) result += \"No\"\n  \
    \          if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && close\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa8h99jk3.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa8h99jk3.scala:56:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m56 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpa8h99jk3.scala:72:0 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa8h99jk3.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa8h99jk3.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa8h99jk3.scala:18:19\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa8h99jk3.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e["
  stdout: ''
  timestamp: 1659795248
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj5yvyanq.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj5yvyanq.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj5yvyanq.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj5yvyanq.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj5yvyanq.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same gro"
  stdout: ''
  timestamp: 1659795240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            val open = s.indexOf(\"(\")\n       \
    \     val close = s.indexOf(\")\")\n            if (open < 0 || close < 0) {\n\
    \                result += \"No\"\n            } else {\n                result\
    \ += \"Yes\"\n                stack.push(s)\n                while (open >= 0\
    \ && close >= 0) {\n                    if (open < close) {\n                \
    \        result += \"Yes\"\n                        stack.push(s.substring(0,\
    \ open))\n                        open -= 1\n                    } else {\n  \
    \                      result += \"No\"\n                        stack.push(s.substring(0,\
    \ close))\n                        close -= 1\n                    }\n       \
    \         }\n                stack.pop\n            }\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3kywx_od.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3kywx_od.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp3kywx_od.scala:30:29 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m                        open -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      value -= is not a member of Int - did you mean open.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp3kywx_od.scala:34:30 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        close -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value -= is not a member of Int - did you mean close.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659795255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            val open = s.indexOf(\"(\")\n       \
    \     val close = s.indexOf(\")\")\n            if (open < 0 || close < 0) return\n\
    \            if (open > close) {\n                stack.push(s)\n            }\
    \ else {\n                val left = stack.pop()\n                val right =\
    \ s.substring(open + 1, close)\n                val newLeft = left + right\n \
    \               val newRight = right + left\n                if (newLeft.length\
    \ == newRight.length) {\n                    result += (newLeft + newRight)\n\
    \                } else {\n                    result += (newLeft + newRight)\n\
    \                }\n            }\n        }\n        if (result.isEmpty) \"No\"\
    \ else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv2mo6ug5.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpv2mo6ug5.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpv2mo6ug5.scala:21:39 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (open < \e[31m0\e[0m || close\
    \ < \e[31m0\e[0m) \e[33mreturn\e[0m\n\e[31m\e[31m   |\e[0m                   \
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \           Found:    Unit\n\e[31m   |\e[0m                                  \
    \     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                val newStack = mutable.Stack[String]()\n\
    \                val newResult = mutable.ListBuffer.empty[String]\n          \
    \      for(j <- 0 until open) {\n                    newStack += str.substring(0,\
    \ j)\n                }\n                for(j <- open until close) {\n      \
    \              newStack += str.substring(j, close + 1)\n                }\n  \
    \              for(j <- close + 1 until str.length) {\n                    newStack\
    \ += str.substring(j, str.length)\n                }\n                for(j <-\
    \ 0 until newStack.size) {\n                    newResult += newStack(j)\n   \
    \             }\n                stack += newStack\n                result +=\
    \ newResult\n            }\n        }\n        if(stack.size == 0) {\n       \
    \     result += \"No\"\n        } else {\n            result += \"Yes\"\n    \
    \    }\n        return result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd_8bd6hj.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd_8bd6hj.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpd_8bd6hj.scala:25:31 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e[0m \e[36mnewStack\e[0m =\
    \ mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd_8bd6hj.scala:26:32\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e\
    [0m \e[36mnewResult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.length) {\n            val str = lst(i)\n      \
    \      if(str == \"(\") {\n                stack.push(str)\n            } else\
    \ if(str == \")\") {\n                val str = stack.pop()\n                if(str\
    \ != \"\") {\n                    result += \"(\" + str + \")\"\n            \
    \    }\n            }\n        }\n        if(result.size == lst.length) result.mkString(\"\
    Yes\") else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl0frof0i.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpl0frof0i.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795250
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.Queue[String]()\n        val open = mutable.HashSet[String]()\n\
    \        val close = mutable.HashSet[String]()\n        lst.foreach(x => {\n \
    \           x match {\n                case \")\" => close.add(x)\n          \
    \      case \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => open.add(x)\n                case \")(\"  =>\
    \ open.add(x)\n                case \")(\"  => open.add(x)\n                case\
    \ \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n      \
    \          case \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => open.add(x)\n                case \")(\"  =>\
    \ open.add(x)\n                case \")(\"  => open.add(x)\n                case\
    \ \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n      \
    \          case \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => open.add(x)\n                case \")(\"  =>\
    \ open.add(x)\n                case \")(\"  => open.add(x)\n                case\
    \ \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n      \
    \          case \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => open.add(x)\n                case \")(\"  =>\
    \ open.add(x)\n                case \")(\"  => open.add(x)\n                case\
    \ \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n      \
    \          case \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => open.add(x)\n                case \")(\"  =>\
    \ open.add(x)\n                case \")(\"  => open.add(x)\n                case\
    \ \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n      \
    \          case \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => open.add(x)\n                case \")(\"  =>\
    \ open.add(x)\n                case \")(\"  => open.add(x)\n                case\
    \ \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n      \
    \          case \")(\"  => open.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => open.add(x)\n                case \")(\"  =>\
    \ open.add(x)\n                case \")(\"  => open.add(x)\n                case\
    \ \")(\"  => open.add(x)\n\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps4_2x3m3.scala:90:0 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps4_2x3m3.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps4_2x3m3.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps4_2x3m3.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps4_2x3m3.scala:19:19\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps4_2x3m3.scala:20:20\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.HashSet[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e"
  stdout: ''
  timestamp: 1659795257
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.add(x)\n                case \")(\"  => open.add(x)\n             \
    \   case \")()\" => open.add(x)\n                case \")()()\" => open.add(x)\n\
    \                case _ => stack += x\n            }\n        })\n        val\
    \ openCount = open.size\n        val closeCount = close.size\n        if (openCount\
    \ == closeCount) {\n            val openList = open.iterator\n            val\
    \ closeList = close.iterator\n            while (openList.hasNext && closeList.hasNext)\
    \ {\n                val open = openList.next()\n                val close = closeList.next()\n\
    \                val openCount = open.size\n                val closeCount = close.size\n\
    \                if (openCount == closeCount) {\n                    val openList\
    \ = open.iterator\n                    val closeList = close.iterator\n      \
    \              while (openList.hasNext && closeList.hasNext) {\n             \
    \           val open = openList.next()\n                        val close = closeList.next()\n\
    \                        val openCount = open.size\n                        val\
    \ closeCount = close.size\n                        if (openCount == closeCount)\
    \ {\n                            val openList = open.iterator\n              \
    \              val closeList = close.iterator\n                            while\
    \ (openList.hasNext && closeList.hasNext) {\n                                val\
    \ open = openList.next()\n                                val close = closeList.next()\n\
    \                                val openCount = open.size\n                 \
    \               val closeCount = close.size\n                                if\
    \ (openCount == closeCount) {\n                                    val openList\
    \ = open.iterator\n                                    val closeList = close.iterator\n\
    \                                    while (openList.hasNext && closeList.hasNext)\
    \ {\n                                        val open = openList.next()\n    \
    \                                    val close = closeList.next()\n          \
    \                              val openCount = open.size\n                   \
    \                     val closeCount = close.size\n                          \
    \              if (openCount == closeCount) {\n                              \
    \              val openList = open.iterator\n                                \
    \            val closeList = close.iterator\n                                \
    \            while (openList.hasNext && closeList.hasNext) {\n               \
    \                                 val open = openList.next()\n               \
    \                                 val close = closeList.next()\n             \
    \                                   val openCount = open.size\n              \
    \                                  val closeCount = close.size\n             \
    \                                   if (openCount == closeCount) {\n         \
    \                                           val openList = open.iterator\n   \
    \                                                 val closeList = close.iterator\n\
    \                                                    while (openList.hasNext &&\
    \ closeList.hasNext) {\n                                                     \
    \   val open = openList.next()\n                                             \
    \           val close = closeList.next()\n                                   \
    \                     val openCount = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp__uddo5v.scala:77:71 ---------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m                                                    \
    \    \e[33mval\e[0m \e[36mopenCount\e[0m = \n\e[31m\e[31m   |\e[0m           \
    \                                                            ^\e[0m\n\e[31m  \
    \ |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp__uddo5v.scala:95:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m95 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp__uddo5v.scala:16:20 ------------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp__uddo5v.scala:17:21 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp__uddo5v.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp__uddo5v.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m               "
  stdout: ''
  timestamp: 1659795251
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf('(')\n            val close = str.indexOf(')')\n \
    \           val left = str.substring(0, open)\n            val right = str.substring(open\
    \ + 1, close)\n            val newStack = stack.dropRight(1).dropRight(1)\n  \
    \          val newResult = result.dropRight(1).dropRight(1)\n            val newLeft\
    \ = left + newStack.mkString\n            val newRight = right + newResult.mkString\n\
    \            val newStr = newLeft + newRight\n            if(newStr != str) {\n\
    \                stack.push(str)\n                result.push(newStr)\n      \
    \      }\n        }\n        if(stack.size == 0) {\n            \"No\"\n     \
    \   } else {\n            \"Yes\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcw2rm6g2.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcw2rm6g2.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795252
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach(x => if (x == \"\
    (\") stack += x else if (!x == \"(\") queue += x else ())\n        val goodString\
    \ = if (stack.size == 0) \"No\" else \"Yes\"\n        val goodString = if (queue.size\
    \ == 0) \"No\" else \"Yes\"\n        goodString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6aavgpqd.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgoodString\e[0m = \e[33mif\e\
    [0m (queue.size == \e[31m0\e[0m) \e[31m\"No\"\e[0m \e[33melse\e[0m \e[31m\"Yes\"\
    \e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodString is already defined as \e[33mvalue\e[0m \e[35mgoodString\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp6aavgpqd.scala:16:20 ------------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp6aavgpqd.scala:17:20 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6aavgpqd.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp6aavgpqd.scala:19:59 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) queue += x \e[33melse\e[0m ())\n\e[31m\e[31m   |\e[0m              \
    \                                             ^^\e[0m\n\e[31m   |\e[0m       \
    \                          value unary_! is no"
  stdout: ''
  timestamp: 1659795259
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.length){\n            val str = lst(i)\n       \
    \     if(str == \"(\"){\n                stack += str\n            }else if(str\
    \ == \")\"){\n                if(stack.size == 0){\n                    result\
    \ += \"No\"\n                }else{\n                    result += \"Yes\"\n \
    \               }\n                stack -= str\n            }\n        }\n  \
    \      if(result.size == 0){\n            result += \"No\"\n        }\n      \
    \  result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2iq_28jh.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2iq_28jh.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                val stackStr = str.substring(open + 1,\
    \ close)\n                val stackSize = stack.size\n                if(stackSize\
    \ > 0) {\n                    result += \"No\"\n                } else {\n   \
    \                 stack += str\n                    result += \"Yes\"\n      \
    \          }\n            }\n        }\n        result.mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv90de2ea.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpv90de2ea.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val x = stack.pop()\n            val y = stack.pop()\n            val\
    \ z = x + y\n            result += (if (z.length == x.length) z else z + \")\"\
    )\n        }\n        if (result.nonEmpty) result.head\n        else \"No\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmmf96l5h.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmmf96l5h.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795254
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        for(i <- 0 until stackSize) {\n   \
    \         val str = lst(i)\n            val open = str.indexOf('(')\n        \
    \    val close = str.indexOf(')')\n            val newStr = str.substring(open\
    \ + 1, close)\n            val newStack = stack.dropRight(1).dropRight(1)\n  \
    \          val newResult = result.dropRight(1).dropRight(1)\n            val newStackSize\
    \ = newStack.size()\n            val newResultSize = newResult.size()\n      \
    \      val newStackIsEmpty = newStackSize == 0\n            val newResultIsEmpty\
    \ = newResultSize == 0\n            val newStackIsFull = newStackSize == stackSize\n\
    \            val newResultIsFull = newResultSize == stackSize\n            val\
    \ newStackIsEmptyOrFull = newStackIsEmpty || newStackIsFull\n            val newResultIsEmptyOrFull\
    \ = newResultIsEmpty || newResultIsFull\n            val newStackIsFullOrEmpty\
    \ = newStackIsFull || newStackIsEmpty\n            val newResultIsFullOrEmpty\
    \ = newResultIsFull || newResultIsEmpty\n            val newStackIsEmptyOrFullOrEmpty\
    \ = newStackIsEmptyOrFull || newStackIsEmptyOrEmpty\n            val newResultIsEmptyOrFullOrEmpty\
    \ = newResultIsEmptyOrFull || newResultIsEmptyOrEmpty\n            val newStackIsFullOrEmptyOrEmpty\
    \ = newStackIsFullOrEmpty || newStackIsEmptyOrFullOrEmpty\n            val newResultIsFullOrEmptyOrEmpty\
    \ = newResultIsFullOrEmpty || newResultIsEmptyOrFullOrEmpty\n            val newStackIsEmptyOrFullOrEmptyOrEmpty\
    \ = newStackIsEmptyOrFullOrEmptyOrEmpty || newStackIsEmptyOrFullOrEmpty\n    \
    \        val newResultIsEmptyOrFullOrEmptyOrEmpty = newResultIsEmptyOrFullOrEmptyOrEmpty\
    \ || newResultIsEmptyOrFullOrEmptyOrEmpty\n            val newStackIsFullOrEmptyOrEmptyOrEmpty\
    \ = newStackIsFullOrEmptyOrEmptyOrEmpty || newStackIsFullOrEmptyOrEmptyOrEmpty\n\
    \            val newResultIsFullOrEmptyOrEmptyOrEmpty = newResultIsFullOrEmptyOrEmptyOrEmpty\
    \ || newResultIsFullOrEmptyOrEmptyOrEmpty\n            val newStackIsEmptyOrFullOrEmptyOrEmptyOrEmpty\
    \ = newStackIsEmptyOrFullOrEmptyOrEmptyOrEmpty || newStackIsEmptyOrFull\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw2v_7axi.scala:62:0 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw2v_7axi.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw2v_7axi.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw2v_7axi.scala:61:1\
    \ ---------------------\e[0m\e[0m\n\e[31m61 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpw2v_7axi.scala:46:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m46 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659795260
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val left = str.substring(0, open)\n \
    \               val right = str.substring(close + 1)\n                val newStr\
    \ = left + right\n                if(!stack.contains(newStr)) {\n            \
    \        result.append(\"Yes\")\n                } else {\n                  \
    \  result.append(\"No\")\n                }\n                stack += newStr\n\
    \            }\n        }\n        result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprlzdsril.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmprlzdsril.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    if(str == \"(\") {\n                stack.push(str)\n            } else if(str\
    \ == \")\") {\n                val top = stack.pop()\n                if(top ==\
    \ \"(\") {\n                    result += \"(\"\n                } else {\n  \
    \                  result += \"(\"\n                    result += top\n      \
    \          }\n            } else {\n                result += \"(\"\n        \
    \        result += str\n                result += \"(\"\n                stack.push(str)\n\
    \            }\n        }\n        if(stack.size == 0) {\n            \"No\"\n\
    \        } else {\n            \"Yes\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprv4rcj9n.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmprv4rcj9n.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795255
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.length) {\n            val str = lst(i)\n      \
    \      val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openStr = str.substring(0, open)\n\
    \                val closeStr = str.substring(close+1, str.length)\n         \
    \       val newStr = openStr + closeStr\n                stack += newStr\n   \
    \         }\n        }\n        if(stack.size == 0) {\n            result.append(\"\
    Yes\")\n        } else {\n            result.append(\"No\")\n        }\n     \
    \   return result.toString()\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n \
    \   assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqiufzqod.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqiufzqod.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795256
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.ListBuffer.empty[String]\n        val close = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\" => {\n                    open.push(x)\n                }\n    \
    \            case \")(\" => {\n                    stack.push(x)\n           \
    \     }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5l_m6waj.scala:126:4 ---------------------------\e\
    [0m\e[0m\n\e[31m126 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp5l_m6waj.scala:143:0 ---------------------------\e[0m\e[0m\n\e[31m143\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5l_m6waj.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5l_m6waj.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp5l_m6waj.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp5l_m6waj.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmp5l_m6waj.scala:127:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m127 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m("
  stdout: ''
  timestamp: 1659795262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n\
    \        val stackSize3 = stackSize2 * stackSize\n        val stackSize4 = stackSize3\
    \ * stackSize\n        val stackSize5 = stackSize4 * stackSize\n        val stackSize6\
    \ = stackSize5 * stackSize\n        val stackSize7 = stackSize6 * stackSize\n\
    \        val stackSize8 = stackSize7 * stackSize\n        val stackSize9 = stackSize8\
    \ * stackSize\n        val stackSize10 = stackSize9 * stackSize\n        val stackSize11\
    \ = stackSize10 * stackSize\n        val stackSize12 = stackSize11 * stackSize\n\
    \        val stackSize13 = stackSize12 * stackSize\n        val stackSize14 =\
    \ stackSize13 * stackSize\n        val stackSize15 = stackSize14 * stackSize\n\
    \        val stackSize16 = stackSize15 * stackSize\n        val stackSize17 =\
    \ stackSize16 * stackSize\n        val stackSize18 = stackSize17 * stackSize\n\
    \        val stackSize19 = stackSize18 * stackSize\n        val stackSize20 =\
    \ stackSize19 * stackSize\n        val stackSize21 = stackSize20 * stackSize\n\
    \        val stackSize22 = stackSize21 * stackSize\n        val stackSize23 =\
    \ stackSize22 * stackSize\n        val stackSize24 = stackSize23 * stackSize\n\
    \        val stackSize25 = stackSize24 * stackSize\n        val stackSize26 =\
    \ stackSize25 * stackSize\n        val stackSize27 = stackSize26 * stackSize\n\
    \        val stackSize28 = stackSize27 * stackSize\n        val stackSize29 =\
    \ stackSize28 * stackSize\n        val stackSize30 = stackSize29 * stackSize\n\
    \        val stackSize31 = stackSize30 * stackSize\n        val stackSize32 =\
    \ stackSize31 * stackSize\n        val stackSize33 = stackSize32 * stackSize\n\
    \        val stackSize34 = stackSize33 * stackSize\n        val stackSize35 =\
    \ stackSize34 * stackSize\n        val stackSize36 = stackSize35 * stackSize\n\
    \        val stackSize37 = stackSize36 * stackSize\n        val stackSize38 =\
    \ stackSize37 * stackSize\n        val stackSize39 = stackSize38 * stackSize\n\
    \        val stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6b9lran6.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6b9lran6.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   if (x == \")\") close += x\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"Yes\"\n            if (open.isEmpty && close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n \
    \           if (open.isEmpty && close.isEmpty) result += \"Yes\"\n           \
    \ if (open.isEmpty && !close.isEmpty) result += \"Yes\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"Yes\"\n\
    \            if (open.isEmpty && close.isEmpty) result += \"No\"\n           \
    \ if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"Yes\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"Yes\"\n\
    \            if (open.isEmpty && close.isEmpty) result += \"No\"\n           \
    \ if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"Yes\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"Yes\"\n\
    \            if (open.isEmpty && close.isEmpty) result += \"No\"\n           \
    \ if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"Yes\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"Yes\"\n\
    \            if (open.isEmpty && close.isEmpty) result += \"No\"\n           \
    \ if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"Yes\"\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6sdmc03b.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6sdmc03b.scala:56:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m56 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmp6sdmc03b.scala:72:0 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6sdmc03b.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6sdmc03b.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6sdmc03b.scala:18:19\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6sdmc03b.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e["
  stdout: ''
  timestamp: 1659795262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.length){\n            val str = lst(i)\n       \
    \     val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val left = str.substring(0, open)\n            val right = str.substring(open\
    \ + 1, close)\n            val newStr = left + right + \")\"\n            val\
    \ newStack = stack.push(newStr)\n            val newResult = result.push(newStack.mkString)\n\
    \            if(newResult.size == lst.length){\n                val newStack =\
    \ stack.pop()\n                val newResult = result.pop()\n                if(newStack\
    \ == newResult){\n                    return \"Yes\"\n                }\n    \
    \        }\n        }\n        return \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3su5zkqs.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3su5zkqs.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795263
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.length){\n            val str = lst(i)\n       \
    \     val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0){\n                return \"No\"\n   \
    \         }\n            val openCount = stack.length\n            val closeCount\
    \ = stack.length\n            val openParen = open - 1\n            val closeParen\
    \ = close + 1\n            while(openCount > 0 && closeCount > 0 && openParen\
    \ < closeParen){\n                val openParenCount = stack.length\n        \
    \        val closeParenCount = stack.length\n                val openParenStr\
    \ = stack.pop()\n                val closeParenStr = stack.pop()\n           \
    \     if(openParenStr == closeParenStr){\n                    openCount -= 1\n\
    \                    closeCount -= 1\n                }\n                else\
    \ if(openParenStr < closeParenStr){\n                    openCount -= 1\n    \
    \            }\n                else{\n                    closeCount -= 1\n \
    \               }\n                openParen -= 1\n                closeParen\
    \ += 1\n            }\n            if(openCount > closeCount){\n             \
    \   result += \"Yes\"\n            }\n            else{\n                result\
    \ += \"No\"\n            }\n            stack.push(str)\n        }\n        return\
    \ result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt4n0y_wq.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpt4n0y_wq.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpt4n0y_wq.scala:44:26 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                openParen -= \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Int - did you mean openParen.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpt4n0y_wq.scala:45:27 ------------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m                closeParen += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value +=\
    \ is not a member of Int - did you mean closeParen.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659795269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.synchronized {\n                        stack.pop()\
    \ match {\n                            case Some(closing) => result += closing\n\
    \                            case None => result += x\n                      \
    \  }\n                    }\n                case \")(\" =>\n                \
    \    open.synchronized {\n                        stack.pop() match {\n      \
    \                      case Some(opening) => result += opening\n             \
    \               case None => result += x\n                        }\n        \
    \            }\n                case \")(\" =>\n                    open.synchronized\
    \ {\n                        stack.pop() match {\n                           \
    \ case Some(opening) => result += opening\n                            case None\
    \ => result += x\n                        }\n                    }\n         \
    \       case \")(\" =>\n                    open.synchronized {\n            \
    \            stack.pop() match {\n                            case Some(opening)\
    \ => result += opening\n                            case None => result += x\n\
    \                        }\n                    }\n                case \")(\"\
    \ =>\n                    open.synchronized {\n                        stack.pop()\
    \ match {\n                            case Some(opening) => result += opening\n\
    \                            case None => result += x\n                      \
    \  }\n                    }\n                case \")(\" =>\n                \
    \    open.synchronized {\n                        stack.pop() match {\n      \
    \                      case Some(opening) => result += opening\n             \
    \               case None => result += x\n                        }\n        \
    \            }\n                case \")(\" =>\n                    open.synchronized\
    \ {\n                        stack.pop() match {\n                           \
    \ case Some(opening) => result += opening\n                            case None\
    \ => result += x\n                        }\n                    }\n         \
    \       case \")(\" =>\n                    open.synchronized {\n            \
    \            stack.pop() match {\n                            case Some(opening)\
    \ => result += opening\n                            case None => result += x\n\
    \                        }\n                    }\n                case \")(\"\
    \ =>\n                    open.synchronized {\n                        stack.pop()\
    \ match {\n                            case Some(opening) => result += opening\n\
    \                            case None => result += x\n                      \
    \  }\n                    }\n                case \")(\" =>\n                \
    \    open.synchronized {\n                        stack.pop() match {\n      \
    \                      case Some(opening) => result += opening\n             \
    \               case None => result += x\n                        }\n        \
    \            }\n                case \")(\" =>\n                    open.synchronized\
    \ {\n                        stack.pop() match {\n                           \
    \ case Some(opening) => result += opening\n                            case None\
    \ => result += x\n                        }\n                    }\n         \
    \       case \")(\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpnqfexmdk.scala:99:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m99 |\e[0m                \e[33mcase\e[0m \")(\n\e[31m\e[31m  \
    \ |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmpnqfexmdk.scala:101:34 ----------------------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m    |\e[0m           \
    \                       ^\e[0m\n\e[31m    |\e[0m                             \
    \  end of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpnqfexmdk.scala:117:0 ---------------------------\e[0m\e[0m\n\e[31m117\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnqfexmdk.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpnqfexmdk.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpnqfexmdk.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpnqfexmdk.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mu"
  stdout: ''
  timestamp: 1659795262
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val newStr = str.substring(open + 1, close)\n            val newStack\
    \ = stack.dropRight(open).reverse\n            val newResult = result.dropRight(open).reverse\n\
    \            val newStack2 = stack.dropRight(close).reverse\n            val newResult2\
    \ = result.dropRight(close).reverse\n            val newStack3 = stack.dropRight(open\
    \ + 1).reverse\n            val newResult3 = result.dropRight(open + 1).reverse\n\
    \            val newStack4 = stack.dropRight(close + 1).reverse\n            val\
    \ newResult4 = result.dropRight(close + 1).reverse\n            val newStack5\
    \ = stack.dropRight(open + 2).reverse\n            val newResult5 = result.dropRight(open\
    \ + 2).reverse\n            val newStack6 = stack.dropRight(close + 2).reverse\n\
    \            val newResult6 = result.dropRight(close + 2).reverse\n          \
    \  val newStack7 = stack.dropRight(open + 3).reverse\n            val newResult7\
    \ = result.dropRight(open + 3).reverse\n            val newStack8 = stack.dropRight(close\
    \ + 3).reverse\n            val newResult8 = result.dropRight(close + 3).reverse\n\
    \            val newStack9 = stack.dropRight(open + 4).reverse\n            val\
    \ newResult9 = result.dropRight(open + 4).reverse\n            val newStack10\
    \ = stack.dropRight(close + 4).reverse\n            val newResult10 = result.dropRight(close\
    \ + 4).reverse\n            val newStack11 = stack.dropRight(open + 5).reverse\n\
    \            val newResult11 = result.dropRight(open + 5).reverse\n          \
    \  val newStack12 = stack.dropRight(close + 5).reverse\n            val newResult12\
    \ = result.dropRight(close + 5).reverse\n            val newStack13 = stack.dropRight(open\
    \ + 6).reverse\n            val newResult13 = result.dropRight(open + 6).reverse\n\
    \            val newStack14 = stack.dropRight(close + 6).reverse\n           \
    \ val newResult14 = result.dropRight(close + 6).reverse\n            val newStack15\
    \ = stack.dropRight(open + 7).reverse\n            val newResult15 = result.dropRight(open\
    \ + 7).reverse\n            val newStack16 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_3qwwhld.scala:53:28 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m            \e[33mval\e[0m \e[36mnewStack16\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_3qwwhld.scala:71:0 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_3qwwhld.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_3qwwhld.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_3qwwhld.scala:70:1\
    \ ---------------------\e[0m\e[0m\n\e[31m70 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp_3qwwhld.scala:55:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m55 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1659795271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop()\n                }\n                case\
    \ \")()\" => {\n                    stack.pop()\n                    stack.pop()\n\
    \                }\n                case \")(\" => {\n                    stack.pop()\n\
    \                    stack.append(x)\n                }\n                case\
    \ _ => {\n                    stack.append(x)\n                }\n           \
    \ }\n        })\n        if (stack.size == 0) {\n            result.append(\"\
    Yes\")\n        } else {\n            result.append(\"No\")\n        }\n     \
    \   result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe2fq7w5w.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpe2fq7w5w.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795264
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \"(\" => open.push(x)\n                case \")(\" => close.push(x)\n\
    \                case \")()\" => stack.push(x)\n                case \")()()\"\
    \ => stack.push(x)\n                case \")(()\" => stack.push(x)\n         \
    \       case \")(()()\" => stack.push(x)\n                case \")(()(\" => stack.push(x)\n\
    \                case \")(()()\" => stack.push(x)\n                case \")(()(()\"\
    \ => stack.push(x)\n                case \")(()(()()\" => stack.push(x)\n    \
    \            case \")(()(()(\" => stack.push(x)\n                case \")(()(()()\"\
    \ => stack.push(x)\n                case \")(()(()(()\" => stack.push(x)\n   \
    \             case \")(()(()(()\" => stack.push(x)\n                case \")(()(()(()(\"\
    \ => stack.push(x)\n                case \")(()(()(()()\" => stack.push(x)\n \
    \               case \")(()(()(()(\" => stack.push(x)\n                case \"\
    )(()(()(()()\" => stack.push(x)\n                case \")(()(()(()(\" => stack.push(x)\n\
    \                case \")(()(()(()()\" => stack.push(x)\n                case\
    \ \")(()(()(()(\" => stack.push(x)\n                case \")(()(()(()()\" => stack.push(x)\n\
    \                case \")(()(()(()(\" => stack.push(x)\n                case \"\
    )(()(()(()()\" => stack.push(x)\n                case \")(()(()(()(\" => stack.push(x)\n\
    \                case \")(()(()(()()\" => stack.push(x)\n                case\
    \ \")(()(()(()(\" => stack.push(x)\n                case \")(()(()(()()\" => stack.push(x)\n\
    \                case \")(()(()(()(\" => stack.push(x)\n                case \"\
    )(()(()(()()\" => stack.push(x)\n                case \")(()(()(()(\" => stack.push(x)\n\
    \                case \")(()(()(()()\" => stack.push(x)\n                case\
    \ \")(()(()(()(\" => stack.push(x)\n                case \")(()(()(()()\" => stack.push(x)\n\
    \                case \")(()(()(()(\" => stack.push(x)\n                case \"\
    )(()(()(()()\" => stack.push(x)\n                case \")(()(()(()(\" => stack.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo1lrs5rn.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpo1lrs5rn.scala:78:0 ----------------------------\e[0m\e[0m\n\e[31m78\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo1lrs5rn.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpo1lrs5rn.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpo1lrs5rn.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpo1lrs5rn.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpo1lrs5rn.scala:62:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m62 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[3"
  stdout: ''
  timestamp: 1659795266
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\"  => {\n                    open.push(x)\n                }\n   \
    \             case \")()\" => {\n                    stack.push(x)\n         \
    \       }\n                case \")(\" => {\n                    val s = stack.pop()\n\
    \                    val c = close.pop()\n                    val o = open.pop()\n\
    \                    result += (s\"$s$c$o\")\n                }\n            \
    \    case _ => {\n                    result += (s\"$x\")\n                }\n\
    \            }\n        })\n        if (close.isEmpty && open.isEmpty) {\n   \
    \         return \"Yes\"\n        }\n        if (close.isEmpty || open.isEmpty)\
    \ {\n            return \"No\"\n        }\n        if (stack.size == 0) {\n  \
    \          return \"No\"\n        }\n        return \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkcpiffiq.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkcpiffiq.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkcpiffiq.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpkcpiffiq.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795265
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                result += \"Yes\"\n                stack\
    \ += str\n                while(open < close) {\n                    val left\
    \ = str.substring(0, open)\n                    val right = str.substring(open+1,\
    \ close)\n                    val newStr = left + right\n                    if(stack.contains(newStr))\
    \ {\n                        result += \"No\"\n                        break\n\
    \                    } else {\n                        result += \"Yes\"\n   \
    \                     stack += newStr\n                    }\n               \
    \     open += 1\n                }\n            }\n        }\n        result.mkString(\"\
    ,\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnvpell6h.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpnvpell6h.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpnvpell6h.scala:33:24 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnvpell6h.scala:38:25\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    open\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                 value += is not a member of Int - did you mean open.!=?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659795271
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n        \
    \        stack.push(s)\n            } else if (s.startsWith(\")\")) {\n      \
    \          val s = stack.pop()\n                if (s.startsWith(\"(\")) {\n \
    \                   stack.push(s)\n                } else {\n                \
    \    result += (s + \"(\" + s + \")\")\n                }\n            }\n   \
    \     }\n        if (stack.nonEmpty) {\n            result += \"(\" + stack.pop()\
    \ + \")\"\n        }\n        if (result.nonEmpty) {\n            return \"Yes\"\
    \n        } else {\n            return \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr480veor.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpr480veor.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(s => {\n            val newStack = mutable.Stack[String]()\n\
    \            val newResult = mutable.ListBuffer.empty[String]\n            stack.push(s)\n\
    \            while (!stack.isEmpty) {\n                val top = stack.pop()\n\
    \                if (top == \"(\") {\n                    newStack.push(top)\n\
    \                } else if (top == \")\") {\n                    if (newStack.size\
    \ == 0) {\n                        newResult += top\n                    } else\
    \ {\n                        newStack.clear()\n                        newResult\
    \ += top\n                    }\n                } else {\n                  \
    \  newStack.clear()\n                    newResult += top\n                }\n\
    \            }\n            result += newResult\n        })\n        if (result.size\
    \ == lst.length) {\n            val stack2 = mutable.Stack[String]()\n       \
    \     val result2 = mutable.ListBuffer.empty[String]\n            lst.foreach(s\
    \ => {\n                val newStack2 = mutable.Stack[String]()\n            \
    \    val newResult2 = mutable.ListBuffer.empty[String]\n                stack2.push(s)\n\
    \                while (!stack2.isEmpty) {\n                    val top2 = stack2.pop()\n\
    \                    if (top2 == \"(\") {\n                        newStack2.push(top2)\n\
    \                    } else if (top2 == \")\") {\n                        if (newStack2.size\
    \ == 0) {\n                            newResult2 += top2\n                  \
    \      } else {\n                            newStack2.clear()\n             \
    \               newResult2 += top2\n                        }\n              \
    \      } else {\n                        newStack2.clear()\n                 \
    \       newResult2 += top2\n                    }\n                }\n       \
    \         result2 += newResult2\n            })\n            if (result2.size\
    \ == lst.length) {\n                val stack3 = mutable.Stack[String]()\n   \
    \             val result3 = mutable.ListBuffer.empty[String]\n               \
    \ lst.foreach(s => {\n                    val newStack3 = mutable.Stack[String]()\n\
    \                    val newResult3 = mutable.ListBuffer.empty[String]\n     \
    \               stack3.push(s)\n                    while (!stack3.isEmpty) {\n\
    \                        val top3 = stack3.pop()\n                        if (top3\
    \ == \"(\") {\n                            newStack3.push(top3)\n            \
    \            } else if (top3 == \")\") {\n                            if (newStack3.size\
    \ == 0) {\n                                newResult3 += top3\n              \
    \              } else {\n                                newStack3.clear()\n \
    \                               newResult3 += top3\n                         \
    \   }\n                        } else {\n                            newStack3.clear()\n\
    \                            newResult3 += top3\n                        }\n \
    \                   }\n                    result3 += newResult3\n           \
    \     })\n                if (result3.size == lst.length) {\n                \
    \    val stack4 = \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpf_83p0g1.scala:91:32 ---------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m                    \e[33mval\e[0m \e[36mstack4\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e\
    [0m                                expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf_83p0g1.scala:109:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m109 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpf_83p0g1.scala:16:20 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpf_83p0g1.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpf_83p0g1.scala:19:27 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mnewStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf_83p0g1.scala:20:28 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mval\e[0m \e[36mnewResult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e"
  stdout: ''
  timestamp: 1659795268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.length) {\n            val str = lst(i)\n      \
    \      val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val newStr = str.substring(open + 1,\
    \ close)\n                val newStack = stack.drop(open + 1).dropRight(1)\n \
    \               val newResult = result.drop(open + 1).dropRight(1)\n         \
    \       val newStackStr = newStack.mkString\n                val newResultStr\
    \ = newResult.mkString\n                if(newStackStr == newResultStr) {\n  \
    \                  result.append(\"Yes\")\n                } else {\n        \
    \            result.append(\"No\")\n                }\n            }\n       \
    \ }\n        result.mkString\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n \
    \   assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp87_lz8av.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp87_lz8av.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { x =>\n            if (x == \"(\") {\n                open\
    \ += x\n                stack += x\n            } else if (x == \")\") {\n   \
    \             close += x\n                stack -= x\n            } else if (stack.nonEmpty\
    \ && stack.head == x) {\n                stack -= stack.head\n            } else\
    \ {\n                result += x\n            }\n        }\n        if (stack.nonEmpty)\
    \ {\n            result += \"No\"\n        } else {\n            result += \"\
    Yes\"\n        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjlkk3o2k.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjlkk3o2k.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjlkk3o2k.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjlkk3o2k.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795267
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop() match {\n                    case \")\" => result += \"(\" +\
    \ stack.toList + \")\"\n                    case \")()\" => result += \"(\" +\
    \ stack.toList + \")()\"\n                    case \")()()\" => result += \"(\"\
    \ + stack.toList + \")()()\"\n                    case _ => result += \"(\" +\
    \ stack.toList + \")\"\n                }\n                case \"(\" => stack.push(x)\n\
    \                case _ => stack\n            }\n        })\n        if (result.size\
    \ == lst.length) result.mkString(\"Yes\") else \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp19nest71.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp19nest71.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => if (x contains \"(\") open += x)\n        lst.foreach(x\
    \ => if (x contains \")\") close += x)\n        open foreach { x => stack.push(x)\
    \ }\n        close foreach { x => stack.pop() }\n        val openCount = open.size\n\
    \        val closeCount = close.size\n        if (openCount == closeCount) {\n\
    \            val openStack = stack.take(openCount)\n            val closeStack\
    \ = stack.take(closeCount)\n            val openStackStr = openStack.mkString\n\
    \            val closeStackStr = closeStack.mkString\n            if (openStackStr\
    \ == closeStackStr) {\n                result += \"Yes\"\n            } else {\n\
    \                result += \"No\"\n            }\n        } else {\n         \
    \   result += \"No\"\n        }\n        result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpygdgp6jh.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpygdgp6jh.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpygdgp6jh.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpygdgp6jh.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => x match {\n            case x if x startsWith \"(\"\
    \ => stack.push(x)\n            case x if x startsWith \")\" => stack.pop() match\
    \ {\n                case x if x startsWith \"(\" => result.add(x)\n         \
    \       case x if x startsWith \")\" => result.add(x)\n                case _\
    \ => result.add(x)\n            }\n            case _ => result.add(x)\n     \
    \   })\n        if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsc6j4q9h.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpsc6j4q9h.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795268
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val newStr = if (open < 0 || close < 0) str else str.substring(0,\
    \ open) + str.substring(close + 1)\n            val newStack = if (open < 0 ||\
    \ close < 0) stack else stack.dropRight(1)\n            val newResult = if (open\
    \ < 0 || close < 0) result else result.dropRight(1)\n            newStack.push(newStr)\n\
    \            newResult.push(newStr)\n        }\n        if (stack.size == 0) \"\
    No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9o9q_b7i.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9o9q_b7i.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.synchronized {\n                        stack.pop()\
    \ match {\n                            case Some(\"(\") => open.remove(stack.pop())\n\
    \                            case _ => false\n                        }\n    \
    \                }\n                case \")(\" =>\n                    stack.synchronized\
    \ {\n                        open.add(stack.pop())\n                    }\n  \
    \              case _ =>\n                    stack.synchronized {\n         \
    \               stack += x\n                    }\n            }\n        })\n\
    \        val openCount = open.synchronized {\n            lst.length\n       \
    \ }\n        val closeCount = close.synchronized {\n            lst.length\n \
    \       }\n        if (openCount == closeCount) {\n            val openList =\
    \ open.synchronized {\n                lst.toList\n            }\n           \
    \ val closeList = close.synchronized {\n                lst.toList\n         \
    \   }\n            val openSet = openList.distinct\n            val closeSet =\
    \ closeList.distinct\n            if (openSet.size == closeSet.size && openSet.size\
    \ == openCount) {\n                val openSetList = openSet.synchronized {\n\
    \                    lst.toList\n                }\n                val closeSetList\
    \ = closeSet.synchronized {\n                    lst.toList\n                }\n\
    \                val openSetSet = openSetList.distinct\n                val closeSetSet\
    \ = closeSetList.distinct\n                if (openSetSet.size == closeSetSet.size\
    \ && openSetSet.size == openCount) {\n                    val openSetSetList =\
    \ openSetSet.synchronized {\n                        lst.toList\n            \
    \        }\n                    val closeSetSetList = closeSetSet.synchronized\
    \ {\n                        lst.toList\n                    }\n             \
    \       val openSetSetSet = openSetSetList.distinct\n                    val closeSetSetList\
    \ = closeSetSetList.distinct\n                    if (openSetSetSet.size == closeSetSetSet.size\
    \ && openSetSetSet.size == openCount) {\n                        val openSetSetSetList\
    \ = openSetSetSet.synchronized {\n                            lst.toList\n   \
    \                     }\n                        val closeSetSetSetList = closeSetSetList.synchronized\
    \ {\n                            lst.toList\n                        }\n     \
    \                   val openSetSetSetSet = openSetSetSetSetList.distinct\n   \
    \                     val closeSetSetSetList = closeSetSetSetList.distinct\n \
    \                       if (openSetSetSetSet.size == closeSetSetSetSet.size &&\
    \ openSetSetSetSet.size == openCount) {\n                            val openSet\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpctuch8og.scala:83:4 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpctuch8og.scala:100:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m100 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpctuch8og.scala:16:20 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpctuch8og.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpctuch8og.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpctuch8og.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpctuch8og.scala:71:24 ---------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m                    \e[33mval\e[0m \e[36mcloseSetSetList\e\
    [0m = closeSetSet"
  stdout: ''
  timestamp: 1659795270
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            if (s == \"(\") {\n                stack.push(s)\n\
    \            } else if (s == \")\") {\n                val top = stack.pop()\n\
    \                if (top != \"(\") {\n                    result += \"No\"\n \
    \               } else {\n                    result += \"Yes\"\n            \
    \    }\n            }\n        }\n        result.mkString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_0k6jutv.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_0k6jutv.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795269
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\" => {\n                    open.push(x)\n                }\n    \
    \            case \")(\" => {\n                    stack.push(x)\n           \
    \     }\n                case \")\" => {\n                    stack.push(x)\n\
    \                }\n                case \")\" => {\n                    close.push(x)\n\
    \                }\n                case \")(\" => {\n                    open.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    close.push(x)\n\
    \                }\n                case \")(\" => {\n                    open.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    close.push(x)\n\
    \                }\n                case \")(\" => {\n                    open.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    close.push(x)\n\
    \                }\n                case \")(\" => {\n                    open.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    close.push(x)\n\
    \                }\n                case \")(\" => {\n                    open.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    close.push(x)\n\
    \                }\n                case \")(\" => {\n                    open.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    close.push(x)\n\
    \                }\n                case \")(\" => {\n                    open.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    close.push(x)\n\
    \                }\n                case \")(\" => {\n                    open.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    close.push(x)\n\
    \                }\n                case \")(\" => {\n                    open.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    close.push(x)\n\
    \                }\n                case \")(\" => {\n                    open.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptpbzxuh3.scala:142:0 ---------------------------\e\
    [0m\e[0m\n\e[31m142 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptpbzxuh3.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptpbzxuh3.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptpbzxuh3.scala:18:19\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptpbzxuh3.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptpbzxuh3.scala:20:19\
    \ --------------------\e[0m\e[0m\n\e[31m 20 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 21 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 22 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m "
  stdout: ''
  timestamp: 1659795277
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                result += \"Yes\"\n                stack.push(str)\n\
    \                while(open < close) {\n                    val temp = stack.pop()\n\
    \                    if(temp == \"\") {\n                        result += \"\
    No\"\n                        break\n                    }\n                 \
    \   result += \"Yes\"\n                    stack.push(temp + str.substring(open+1,\
    \ close))\n                    open = str.indexOf(\"(\", open+1)\n           \
    \         close = str.indexOf(\")\", open+1)\n                }\n            }\n\
    \        }\n        result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1o1sei5d.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1o1sei5d.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1o1sei5d.scala:31:24 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp1o1sei5d.scala:35:25\
    \ -----------------------------\e[0m\e[0m\n\e[31m35 |\e[0m                   \
    \ open = str.indexOf(\e[31m\"(\"\e[0m, open+\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                   Reassignment to val open\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp1o1sei5d.scala:36:26 -----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                    close = str.indexOf(\e[31m\")\"\e\
    [0m, open+\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Reassignment to val close\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659795273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n        \
    \        stack.push(s)\n            } else if (s.startsWith(\")\")) {\n      \
    \          val s = stack.pop()\n                if (s.startsWith(\"(\")) {\n \
    \                   stack.push(s)\n                } else {\n                \
    \    result ++= s\n                }\n            }\n        }\n        if (stack.size\
    \ == 0) {\n            result.append(\"Yes\")\n        } else {\n            result.append(\"\
    No\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu37pf6pi.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpu37pf6pi.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795273
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.length) {\n            val str = lst(i)\n      \
    \      val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openStr = str.substring(0, open)\n\
    \                val closeStr = str.substring(close+1)\n                val newStr\
    \ = openStr + closeStr\n                val newStack = stack.push(\"(\") + newStr\
    \ + stack.pop()\n                if(newStack.isEmpty) {\n                    result.append(\"\
    Yes\")\n                } else {\n                    result.append(\"No\")\n\
    \                }\n            }\n        }\n        return result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgf8gqnmi.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgf8gqnmi.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795276
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            s match {\n                case \")\"\
    \ =>\n                    stack.pop()\n                case \")(\"  =>\n     \
    \               stack.push(s)\n                case _ =>\n                   \
    \ stack.push(s)\n            }\n        }\n        if (stack.size == 0) {\n  \
    \          result.append(\"Yes\")\n        } else {\n            result.append(\"\
    No\")\n        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptozzwmnf.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmptozzwmnf.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795275
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackIsEmpty = stackMax == 0 && !stack.isEmpty\n        val resultIsEmpty\
    \ = result.size == 0\n        val stackIsFull = stackMax == stackSize && !stack.isEmpty\n\
    \        val resultIsFull = result.size == stackSize\n        val stackIsEmptyOrFull\
    \ = stackIsEmpty || stackIsFull\n        val resultIsEmptyOrFull = resultIsEmpty\
    \ || resultIsFull\n        val stackIsEmptyOrFullOrEmpty = stackIsEmptyOrFull\
    \ || stackIsEmpty\n        val resultIsEmptyOrFullOrEmpty = resultIsEmptyOrFull\
    \ || resultIsEmpty\n        val stackIsEmptyOrFullOrEmptyOrEmpty = stackIsEmptyOrFullOrEmpty\
    \ || stackIsEmptyOrEmpty\n        val resultIsEmptyOrFullOrEmptyOrEmpty = resultIsEmptyOrFullOrEmpty\
    \ || resultIsEmptyOrEmpty\n        val stackIsEmptyOrFullOrEmptyOrEmptyOrEmpty\
    \ = stackIsEmptyOrFullOrEmptyOrEmpty || stackIsEmptyOrEmptyOrEmpty\n        val\
    \ resultIsEmptyOrFullOrEmptyOrEmptyOrEmpty = resultIsEmptyOrFullOrEmptyOrEmpty\
    \ || resultIsEmptyOrEmptyOrEmpty\n        val stackIsEmptyOrFullOrEmptyOrEmptyOrEmptyOrEmpty\
    \ = stackIsEmptyOrFullOrEmptyOrEmptyOrEmpty || stackIsEmptyOrEmptyOrEmptyOrEmpty\n\
    \        val resultIsEmptyOrFullOrEmptyOrEmptyOrEmptyOrEmpty = resultIsEmptyOrFullOrEmptyOrEmptyOrEmpty\
    \ || resultIsEmptyOrEmptyOrEmptyOrEmpty\n        val stackIsEmptyOrFullOrEmptyOrEmptyOrEmptyOrEmptyOrEmpty\
    \ = stackIsEmptyOrFullOrEmptyOrEmptyOrEmptyOrEmpty || stackIsEmptyOrEmptyOrEmptyOrEmptyOrEmpty\n\
    \        val resultIsEmptyOrFullOrEmptyOrEmptyOrEmptyOrEmptyOrEmpty = resultIsEmptyOrFullOrEmptyOrEmptyOrEmptyOrEmpty\
    \ || resultIsEmptyOrEmptyOrEmptyOrEmptyOrEmpty\n        val stackIsEmptyOrFullOrEmptyOrEmptyOrEmptyOrEmptyOrEmptyOrEmpty\
    \ = stackIsEmptyOrFullOrEmptyOrEmptyOrEmptyOrEmptyOrEmpty || stackIsEmptyOrEmptyOrEmptyOrEmptyOrEmptyOrEmpty\n\
    \        val resultIsEmptyOrFullOrEmptyOrEmptyOrEmptyOrEmptyOrEmpty\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfbbcx6ui.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfbbcx6ui.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfbbcx6ui.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfbbcx6ui.scala:28:76\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mstackIsEmptyOrFullOrEmptyOrEmpty\e[0m = stackIsEmptyOrFullOrEmpty || stackIsEmptyOrEmpty\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                    ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                           Not found: stackIsEmptyOrEmpty\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpfbbcx6ui.scala:30:90 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mstackIsEmptyOrFullOrEmptyOrEmptyOrEmpty\e\
    [0m = stackIsEmptyOrFullOrEmptyOrEmpty || stackIsEmptyOrEmptyOrEmpty\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                 Not found: stackIsEmptyOrEmptyOrEmpty\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not F"
  stdout: ''
  timestamp: 1659795280
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        lst.foreach(x => {\n            x match\
    \ {\n                case \")\" => {\n                    stackSize -= 1\n   \
    \                 stack += x\n                }\n                case \")()\"\
    \ => {\n                    stackSize -= 1\n                    stack += x\n \
    \                   stack += \")\"\n                }\n                case \"\
    )(\" => {\n                    stackSize -= 1\n                    stack += x\n\
    \                    stack += \")\"\n                    stack += \")\"\n    \
    \            }\n                case \")()()\" => {\n                    stackSize\
    \ -= 1\n                    stack += x\n                    stack += \")\"\n \
    \                   stack += \")\"\n                    stack += \")\"\n     \
    \           }\n                case _ => {\n                    stackSize -= 1\n\
    \                    stack += x\n                }\n            }\n        })\n\
    \        if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4s0hhpye.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4s0hhpye.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4s0hhpye.scala:22:30 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    stackSize -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value -= is not a member of Int - did you mean stackSize.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp4s0hhpye.scala:26:30 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    stackSize -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value -= is not a member of Int - did you mean stackSize.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp4s0hhpye.scala:31:30 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                    stackSize -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value -= is not a member of Int - did you mean stackSize.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp4s0hhpye.scala:37:30 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    stackSize -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value -= is not a member of Int - did you mean stackSize.!=?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp4s0hhpye.scala:44:30 ------------------------\e\
    [0m\e[0m\n\e[31m44"
  stdout: ''
  timestamp: 1659795284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val stackSize = stack.size\n        \
    \        if(open > close || stackSize > 0) {\n                    result.append(\"\
    No\")\n                } else {\n                    stack.push(str)\n       \
    \             result.append(\"Yes\")\n                }\n            }\n     \
    \   }\n        return result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa8xpkwmd.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpa8xpkwmd.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795277
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop()\n                case \")(\"  => stack.append(x)\n          \
    \      case _ => stack.append(x)\n            }\n        })\n        stack.toList\
    \ match {\n            case Nil => \"No\"\n            case x :: Nil => \"Yes\"\
    \n            case x :: y => result += \"Yes\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp24kwp2oj.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp24kwp2oj.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795279
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            s match {\n                case \")\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(\"  =>\n                    close.clear()\n         \
    \           stack.clear()\n                case \")(\" =>\n                  \
    \  close.clear()\n                    stack.clear()\n                case \")()\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")()()\" =>\n                    close.clear()\n       \
    \             stack.clear()\n                case \")(())\" =>\n             \
    \       close.clear()\n                    stack.clear()\n                case\
    \ \")(())()\" =>\n                    close.clear()\n                    stack.clear()\n\
    \                case \")(())(\" =>\n                    close.clear()\n     \
    \               stack.clear()\n                case \")(())()()\" =>\n       \
    \             close.clear()\n                    stack.clear()\n             \
    \   case \")(())(())\" =>\n                    close.clear()\n               \
    \     stack.clear()\n                case \")(())(())()\" =>\n               \
    \     close.clear()\n                    stack.clear()\n                case \"\
    )(())(())()\" =>\n                    close.clear()\n                    stack.clear()\n\
    \                case \")(())(())(\" =>\n                    close.clear()\n \
    \                   stack.clear()\n                case \")(())(())()()\" =>\n\
    \                    close.clear()\n                    stack.clear()\n      \
    \          case \")(())(())(())\" =>\n                    close.clear()\n    \
    \                stack.clear()\n                case \")(())(())(())()\" =>\n\
    \                    close.clear()\n                    stack.clear()\n      \
    \          case \")(())(())(())()\" =>\n                    close.clear()\n  \
    \                  stack.clear()\n                case \")(())(())(())(\" =>\n\
    \                    close.clear()\n                    stack.clear()\n      \
    \          case \")(())(())(())()()\" =>\n                    close.clear()\n\
    \                    stack.clear()\n                case \")(())(())(())(())\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(())(())(())(())()\" =>\n                    close.clear()\n\
    \                    stack.clear()\n                case \")(())(())(())(())(\"\
    \ =>\n                    close.clear()\n                    stack.clear()\n \
    \               case \")(())(())(())(())()()\" =>\n                    close.clear()\n\
    \                    stack.clear()\n                case \")(())(())(())(())(())\"\
    \ =>\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5q_mf78f.scala:109:0 ---------------------------\e\
    [0m\e[0m\n\e[31m109 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5q_mf78f.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5q_mf78f.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5q_mf78f.scala:18:19\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5q_mf78f.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5q_mf78f.scala:20:20\
    \ --------------------\e[0m\e[0m\n\e[31m 20 |\e[0m        lst.foreach { \e[36ms\e\
    [0m =>\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found: \
    \   Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 21 |\e[0m         \
    \   s \e[33mmatch\e[0m {\n\e[31m 22 |\e[0m                \e[33mcase\e[0m \e[31m\"\
    )\"\e[0m "
  stdout: ''
  timestamp: 1659795286
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val stackStr = str.substring(open + 1,\
    \ close)\n                val stackStr = stackStr.trim\n                if(stackStr.length\
    \ == 0) {\n                    result.append(\"No\")\n                } else {\n\
    \                    stack.push(stackStr)\n                }\n            }\n\
    \        }\n        if(result.size == lst.size) {\n            val stackStr =\
    \ result.mkString(\"(\", \", \", \")\")\n            val stackStr = stackStr.trim\n\
    \            if(stackStr.length == 0) {\n                result.append(\"No\"\
    )\n            } else {\n                result.append(\"Yes\")\n            }\n\
    \        } else {\n            result.append(\"No\")\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf2qpuk2y.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpf2qpuk2y.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpf2qpuk2y.scala:26:20 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e[0m \e[36mstackStr\e[0m =\
    \ stackStr.trim\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackStr is already defined as \e[33mvalue\e[0m \e[35mstackStr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpf2qpuk2y.scala:36:16 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m            \e[33mval\e[0m \e[36mstackStr\e[0m = stackStr.trim\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mstackStr is already defined as \e[33mvalue\e[0m \e[35mstackStr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1659795281
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                stack.push(x)\n\
    \            } else if (x == \")\") {\n                if (stack.nonEmpty) {\n\
    \                    val top = stack.pop()\n                    if (top == \"\
    (\") {\n                        result.add(\"(\")\n                    } else\
    \ if (top == \")\") {\n                        result.add(\")\")\n           \
    \         }\n                }\n            }\n        })\n        if (result.size\
    \ == lst.size) {\n            val stackStr = stack.toList\n            val resultStr\
    \ = result.toList\n            if (stackStr.size == resultStr.size) {\n      \
    \          val stackStr = stackStr.sortWith(_ < _)\n                val resultStr\
    \ = resultStr.sortWith(_ < _)\n                if (stackStr == resultStr) {\n\
    \                    return \"Yes\"\n                }\n            }\n      \
    \  }\n        return \"No\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmnn6xvjc.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmnn6xvjc.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpmnn6xvjc.scala:36:31 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                \e[33mval\e[0m \e[36mstackStr\e[0m =\
    \ stackStr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m                            \
    \   ^\e[0m\n\e[31m   |\e[0m                               Recursive \e[33mvalue\e\
    [0m \e[35mstackStr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpmnn6xvjc.scala:37:32 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m                \e[33mval\e[0m \e[36mresultStr\e[0m = resultStr.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m  \
    \ |\e[0m                                Recursive \e[33mvalue\e[0m \e[35mresultStr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795280
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else stack.pop())\n     \
    \   if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph7ntu60f.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmph7ntu60f.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795280
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.add(x)\n                case \")(\"  =>\n    \
    \                open.add(x)\n                case \")()\" =>\n              \
    \      open.add(x)\n                case \")()()\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )()\" =>\n                    open.add(x)\n                case \")()()\" =>\n\
    \                    open.add(x)\n                case \")(\" =>\n           \
    \         open.add(x)\n                case \")()()\" =>\n                   \
    \ open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")()()\" =>\n                    open.add(x)\n        \
    \        case \")(\" =>\n                    open.add(x)\n                case\
    \ \")()()\" =>\n                    open.add(x)\n                case \")(\" =>\n\
    \                    open.add(x)\n                case \")()()\" =>\n        \
    \            open.add(x)\n                case \")(\" =>\n                   \
    \ open.add(x)\n                case \")()()\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")()()\" =>\n                    open.add(x)\n                case\
    \ \")(\" =>\n                    open.add(x)\n                case \")()()\" =>\n\
    \                    open.add(x)\n                case \")(\" =>\n           \
    \         open.add(x)\n                case \")()()\" =>\n                   \
    \ open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")()()\" =>\n                    open.add(x)\n        \
    \        case \")(\" =>\n                    open.add(x)\n                case\
    \ \")()()\" =>\n                    open.add(x)\n                case \")(\" =>\n\
    \                    open.add(x)\n                case \")()()\" =>\n        \
    \            open.add(x)\n                case \")(\" =>\n                   \
    \ open.add(x)\n                case \")()()\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")()()\" =>\n                    open.add(x)\n                case\
    \ \")(\" =>\n                    open.add(x)\n                case \")()()\" =>\n\
    \                    open.add(x)\n                case \")(\" =>\n           \
    \         open.add(x)\n                case \")()()\" =>\n                   \
    \ open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")()()\" \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnwvxmg_u.scala:101:4 ---------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnwvxmg_u.scala:118:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m118 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpnwvxmg_u.scala:16:20 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpnwvxmg_u.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpnwvxmg_u.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpnwvxmg_u.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpnwvxmg_u.scala:102:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m102 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e["
  stdout: ''
  timestamp: 1659795282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val str = stack.pop()\n            val open = str.indexOf(\"(\")\n   \
    \         val close = str.indexOf(\")\")\n            if(open != -1 && close !=\
    \ -1) {\n                if(open < close) {\n                    stack.push(str.substring(0,\
    \ open))\n                    stack.push(str.substring(open + 1, close))\n   \
    \             } else {\n                    stack.push(str.substring(0, close))\n\
    \                    stack.push(str.substring(close + 1, open))\n            \
    \    }\n            } else {\n                result += str\n            }\n \
    \       }\n        if(result.size == lst.size) {\n            return \"Yes\"\n\
    \        } else {\n            return \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdxhxp_wv.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdxhxp_wv.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795280
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.add(x)\n                case \")(\"  => open.add(x)\n             \
    \   case \")(\"  => close.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => close.add(x)\n                case \")(\"  =>\
    \ open.add(x)\n                case \")(\"  => close.add(x)\n                case\
    \ \")(\"  => open.add(x)\n                case \")(\"  => close.add(x)\n     \
    \           case \")(\"  => open.add(x)\n                case \")(\"  => close.add(x)\n\
    \                case \")(\"  => open.add(x)\n                case \")(\"  =>\
    \ close.add(x)\n                case \")(\"  => open.add(x)\n                case\
    \ \")(\"  => close.add(x)\n                case \")(\"  => open.add(x)\n     \
    \           case \")(\"  => close.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => close.add(x)\n                case \")(\"  =>\
    \ open.add(x)\n                case \")(\"  => close.add(x)\n                case\
    \ \")(\"  => open.add(x)\n                case \")(\"  => close.add(x)\n     \
    \           case \")(\"  => open.add(x)\n                case \")(\"  => close.add(x)\n\
    \                case \")(\"  => open.add(x)\n                case \")(\"  =>\
    \ close.add(x)\n                case \")(\"  => open.add(x)\n                case\
    \ \")(\"  => close.add(x)\n                case \")(\"  => open.add(x)\n     \
    \           case \")(\"  => close.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => close.add(x)\n                case \")(\"  =>\
    \ open.add(x)\n                case \")(\"  => close.add(x)\n                case\
    \ \")(\"  => open.add(x)\n                case \")(\"  => close.add(x)\n     \
    \           case \")(\"  => open.add(x)\n                case \")(\"  => close.add(x)\n\
    \                case \")(\"  => open.add(x)\n                case \")(\"  =>\
    \ close.add(x)\n                case \")(\"  => open.add(x)\n                case\
    \ \")(\"  => close.add(x)\n                case \")(\"  => open.add(x)\n     \
    \           case \")(\"  => close.add(x)\n                case \")(\"  => open.add(x)\n\
    \                case \")(\"  => close.add(x)\n                case \")(\"  =>\
    \ open.add(x)\n                case \")(\"  => close.add(x)\n                case\
    \ \")(\"  => open.add(x)\n                case \")(\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpns3g2px3.scala:73:4 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpns3g2px3.scala:90:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m90 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpns3g2px3.scala:16:20 ------------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpns3g2px3.scala:17:21 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpns3g2px3.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpns3g2px3.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpns3g2px3.scala:74:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m74 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e"
  stdout: ''
  timestamp: 1659795282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            s match {\n                case \")\"\
    \ =>\n                    result += \"(\"\n                    stack += s\n  \
    \              case \")(\" =>\n                    result += \"(\"\n         \
    \           stack += s\n                case \")(\" =>\n                    result\
    \ += \"(\"\n                    stack += s\n                case \")(\" =>\n \
    \                   result += \"(\"\n                    stack += s\n        \
    \        case \")(\" =>\n                    result += \"(\"\n               \
    \     stack += s\n                case \")(\" =>\n                    result +=\
    \ \"(\"\n                    stack += s\n                case \")(\" =>\n    \
    \                result += \"(\"\n                    stack += s\n           \
    \     case \")(\" =>\n                    result += \"(\"\n                  \
    \  stack += s\n                case \")(\" =>\n                    result += \"\
    (\"\n                    stack += s\n                case \")(\" =>\n        \
    \            result += \"(\"\n                    stack += s\n               \
    \ case \")(\" =>\n                    result += \"(\"\n                    stack\
    \ += s\n                case \")(\" =>\n                    result += \"(\"\n\
    \                    stack += s\n                case \")(\" =>\n            \
    \        result += \"(\"\n                    stack += s\n                case\
    \ \")(\" =>\n                    result += \"(\"\n                    stack +=\
    \ s\n                case \")(\" =>\n                    result += \"(\"\n   \
    \                 stack += s\n                case \")(\" =>\n               \
    \     result += \"(\"\n                    stack += s\n                case \"\
    )(\" =>\n                    result += \"(\"\n                    stack += s\n\
    \                case \")(\" =>\n                    result += \"(\"\n       \
    \             stack += s\n                case \")(\" =>\n                   \
    \ result += \"(\"\n                    stack += s\n                case \")(\"\
    \ =>\n                    result += \"(\"\n                    stack += s\n  \
    \              case \")(\" =>\n                    result += \"(\"\n         \
    \           stack += s\n                case \")(\" =>\n                    result\
    \ += \"(\"\n                    stack += s\n                case \")(\" =>\n \
    \                   result += \"(\"\n                    stack += s\n        \
    \        case \")(\" =>\n                    result += \"(\"\n               \
    \     stack += s\n                case \")(\" =>\n                    result +=\
    \ \"(\"\n                    stack += s\n                case \")(\" =>\n    \
    \                result += \"(\"\n                    stack += s\n           \
    \     case \")(\" =>\n                    result += \"(\"\n                  \
    \  stack += s\n                case \")(\" =>\n                    result += \"\
    (\"\n                    stack += s\n                case \")(\" =>\n        \
    \            result += \"(\"\n                    stack += s\n               \
    \ case \")(\" =>\n                    result += \"(\"\n                    \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp65kpt7lu.scala:127:0 ---------------------------\e\
    [0m\e[0m\n\e[31m127 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp65kpt7lu.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp65kpt7lu.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp65kpt7lu.scala:18:20\
    \ --------------------\e[0m\e[0m\n\e[31m 18 |\e[0m        lst.foreach { \e[36ms\e\
    [0m =>\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found: \
    \   Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 19 |\e[0m         \
    \   s \e[33mmatch\e[0m {\n\e[31m 20 |\e[0m                \e[33mcase\e[0m \e[31m\"\
    )\"\e[0m =>\n\e[31m 21 |\e[0m                    result += \e[31m\"(\"\e[0m\n\e\
    [31m 22 |\e[0m                    stack += s\n\e[31m 23 |\e[0m               \
    \ \e[33mcase\e[0m \e[31m\")(\"\e[0m =>\n\e[31m 24 |\e[0m                    result\
    \ += \e[31m\"(\"\e[0m\n\e[31m 25 |\e[0m                    stack += s\n\e[31m\
    \ 26 |\e[0m                \e[33mcase\e[0m \e[31m\")(\"\e[0m =>\n\e[31m 27 |\e\
    [0m                    result += \e[31m\"(\"\e[0m\n\e[31m 28 |\e[0m          \
    \          stack += s\n\e[31m 29 |\e[0m                \e[33mcase\e[0m \e[31m\"\
    )(\"\e[0m =>\n\e[31m 30 |\e[0m                    result += \e[31m\"(\"\e[0m\n\
    \e[31m 31 |\e[0m                    stack += s\n\e[31m 32 |\e[0m             \
    \   \e[33mcase\e[0m \e[31m\")(\"\e[0m =>\n\e[31m 33 |\e[0m                   \
    \ result += \e[31m\"(\"\e[0m\n\e[31m 34 |\e[0m                    sta"
  stdout: ''
  timestamp: 1659795289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            val open = s.indexOf('(')\n         \
    \   val close = s.lastIndexOf(')')\n            if (open < 0 || close < 0) return\n\
    \            if (open > close) return\n            if (open > stack.size) {\n\
    \                stack += s\n            } else {\n                val left =\
    \ stack.pop()\n                val right = s.substring(open + 1, close)\n    \
    \            result += (left + right)\n            }\n        }\n        if (result.size\
    \ == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxwqt4l7u.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxwqt4l7u.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpxwqt4l7u.scala:21:39 --------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m            \e[33mif\e[0m (open < \e[31m0\e[0m || close\
    \ < \e[31m0\e[0m) \e[33mreturn\e[0m\n\e[31m\e[31m   |\e[0m                   \
    \                    ^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \           Found:    Unit\n\e[31m   |\e[0m                                  \
    \     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxwqt4l7u.scala:22:30\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m            \e[33mif\e[0m (open\
    \ > close) \e[33mreturn\e[0m\n\e[31m\e[31m   |\e[0m                          \
    \    ^^^^^^\e[0m\n\e[31m   |\e[0m                              Found:    Unit\n\
    \e[31m   |\e[0m                              Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659795289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.length) {\n            val str = lst(i)\n      \
    \      val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val left = str.substring(0, open)\n            val right = str.substring(open\
    \ + 1, close)\n            val newStr = left + right + str\n            val newStack\
    \ = stack.push(newStr)\n            while(!newStack.isEmpty) {\n             \
    \   val newStr = newStack.pop()\n                val open = newStr.indexOf(\"\
    (\")\n                val close = newStr.indexOf(\")\")\n                val left\
    \ = newStr.substring(0, open)\n                val right = newStr.substring(open\
    \ + 1, close)\n                val newLeft = left + right\n                val\
    \ newRight = right + left\n                val newStr = newLeft + newRight\n \
    \               newStack.push(newStr)\n            }\n            result += (newStr)\n\
    \        }\n        if(result.size == lst.length)\n            \"Yes\"\n     \
    \   else\n            \"No\"\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n \
    \   assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn_3ol2ze.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpn_3ol2ze.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795282
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val len = open - close\n            if(len > 0) {\n           \
    \     stack.push(str)\n                while(stack.nonEmpty) {\n             \
    \       val top = stack.pop()\n                    if(top == str) {\n        \
    \                result += \"Yes\"\n                        break\n          \
    \          }\n                    if(top == close) {\n                       \
    \ result += \"No\"\n                        break\n                    }\n   \
    \                 result += \"No\"\n                }\n            }\n       \
    \ }\n        result.mkString(\",\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_uhqw0es.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_uhqw0es.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp_uhqw0es.scala:29:24 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_uhqw0es.scala:33:24\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m                        break\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                   Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.HashSet[String]()\n        val close = mutable.HashSet[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.add(x)\n                case \")(\"  => open.add(x)\n             \
    \   case _ => stack += x\n            }\n        })\n        while(stack.nonEmpty)\
    \ {\n            val s = stack.pop()\n            result += s\n            open\
    \ -= s\n            close -= s\n        }\n        if (close.isEmpty) result.mkString(\"\
    (\", \")\")\n        else result.mkString(\"(\", \")(\", \")\")\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprf35v36m.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmprf35v36m.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmprf35v36m.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmprf35v36m.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.HashSet[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795283
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.add(x)\n                case \")(\" =>\n     \
    \               open.add(x)\n                case \")(\" =>\n                \
    \    open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")(\" =>\n                    open.add(x)\n                case \"\
    )(\" =>\n                    open.add(x)\n                case \")(\" =>\n   \
    \                 open.add(x)\n                case \")(\" =>\n              \
    \      open.add(x)\n                case \")(\" =>\n                    open.add(x)\n\
    \                case \")(\" =>\n                    open.add(x)\n           \
    \     case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpugx6bi_5.scala:104:21 ----------------------------------------\e\
    [0m\e[0m\n\e[31m104 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m  \
    \  |\e[0m                     ^\e[0m\n\e[31m    |\e[0m                     unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmpugx6bi_5.scala:106:34 ----------------------------------------\e\
    [0m\e[0m\n\e[31m106 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m    |\e[0m           \
    \                       ^\e[0m\n\e[31m    |\e[0m                             \
    \  end of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpugx6bi_5.scala:122:0 ---------------------------\e[0m\e[0m\n\e[31m122\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpugx6bi_5.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpugx6bi_5.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpugx6bi_5.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpugx6bi_5.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = "
  stdout: ''
  timestamp: 1659795284
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    queue.enqueue(x)\n                }\n            \
    \    case \")(\" => {\n                    stack.push(x)\n                }\n\
    \                case \")(\" => {\n                    stack.push(x)\n       \
    \         }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \                }\n                case \")(\" => {\n                    stack.push(x)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4am8mseq.scala:144:0 ---------------------------\e\
    [0m\e[0m\n\e[31m144 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4am8mseq.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4am8mseq.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4am8mseq.scala:18:19\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4am8mseq.scala:19:18\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4am8mseq.scala:20:19\
    \ --------------------\e[0m\e[0m\n\e[31m 20 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 21 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 22 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m => {\n\e[31m 23 |\e[0m         "
  stdout: ''
  timestamp: 1659795291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxIndex = stackSize - 1\n        val stackMin = stackSize + 1\n\
    \        val stackMinIndex = stackSize + 1\n        val stackMinIndex2 = stackSize\
    \ + 1\n        val stackMinIndex3 = stackSize + 1\n        val stackMinIndex4\
    \ = stackSize + 1\n        val stackMinIndex5 = stackSize + 1\n        val stackMinIndex6\
    \ = stackSize + 1\n        val stackMinIndex7 = stackSize + 1\n        val stackMinIndex8\
    \ = stackSize + 1\n        val stackMinIndex9 = stackSize + 1\n        val stackMinIndex10\
    \ = stackSize + 1\n        val stackMinIndex11 = stackSize + 1\n        val stackMinIndex12\
    \ = stackSize + 1\n        val stackMinIndex13 = stackSize + 1\n        val stackMinIndex14\
    \ = stackSize + 1\n        val stackMinIndex15 = stackSize + 1\n        val stackMinIndex16\
    \ = stackSize + 1\n        val stackMinIndex17 = stackSize + 1\n        val stackMinIndex18\
    \ = stackSize + 1\n        val stackMinIndex19 = stackSize + 1\n        val stackMinIndex20\
    \ = stackSize + 1\n        val stackMinIndex21 = stackSize + 1\n        val stackMinIndex22\
    \ = stackSize + 1\n        val stackMinIndex23 = stackSize + 1\n        val stackMinIndex24\
    \ = stackSize + 1\n        val stackMinIndex25 = stackSize + 1\n        val stackMinIndex26\
    \ = stackSize + 1\n        val stackMinIndex27 = stackSize + 1\n        val stackMinIndex28\
    \ = stackSize + 1\n        val stackMinIndex29 = stackSize + 1\n        val stackMinIndex30\
    \ = stackSize + 1\n        val stackMinIndex31 = stackSize + 1\n        val stackMinIndex32\
    \ = stackSize + 1\n        val stackMinIndex33 = stackSize + 1\n        val stackMinIndex34\
    \ = stackSize + 1\n        val stackMinIndex35 = stackSize + 1\n        val stackMinIndex36\
    \ = stackSize + 1\n        val stackMinIndex37 = stackSize + 1\n        val stackMinIndex38\
    \ = stackSize + 1\n        val stackMinIndex39 = stackSize + 1\n        val stackMinIndex40\
    \ = stackSize + 1\n        val stackMinIndex41 = stackSize + 1\n        val stackMinIndex42\
    \ = stackSize + 1\n        val stackMin\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnie0j9op.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnie0j9op.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnie0j9op.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnie0j9op.scala:65:5\
    \ ---------------------\e[0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795292
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val newStack = mutable.Stack[String]()\n            val newResult\
    \ = mutable.ListBuffer.empty[String]\n            if(open != -1 && close != -1)\
    \ {\n                if(open > close) {\n                    newStack.push(str.substring(0,\
    \ open))\n                    newStack.push(str.substring(open + 1, close))\n\
    \                    newResult.push(str.substring(open + 1, close))\n        \
    \        } else {\n                    newStack.push(str.substring(0, close))\n\
    \                    newStack.push(str.substring(close + 1, open))\n         \
    \           newResult.push(str.substring(close + 1, open))\n                }\n\
    \                while(newStack.nonEmpty) {\n                    val newStr =\
    \ newStack.pop()\n                    val newStr2 = newResult.pop()\n        \
    \            if(newStr.equals(newStr2)) {\n                        result.push(newStr)\n\
    \                    } else {\n                        newStack.push(newStr)\n\
    \                        newResult.push(newStr2)\n                    }\n    \
    \            }\n            } else {\n                result.push(str)\n     \
    \       }\n        }\n        if(result.size == lst.size) {\n            return\
    \ \"Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk5jarag4.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpk5jarag4.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpk5jarag4.scala:22:27 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mnewStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk5jarag4.scala:23:28 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mnewResult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659795289
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                result += \"Yes\"\n                stack.push(str)\n\
    \                while(open < close && stack.nonEmpty) {\n                   \
    \ val s = stack.pop()\n                    val open2 = s.indexOf(\"(\")\n    \
    \                val close2 = s.indexOf(\")\")\n                    if(open2 <\
    \ 0 || close2 < 0 || open2 > close || close2 > open) {\n                     \
    \   result += \"No\"\n                    } else {\n                        result\
    \ += \"Yes\"\n                        stack.push(s)\n                    }\n \
    \               }\n            }\n        }\n        result.toString()\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0cpbb7n9.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0cpbb7n9.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x startsWith \"(\"\
    \ => open.push(x)\n            case x if x startsWith \")\" => close.push(x)\n\
    \            case _ => stack.push(x)\n        })\n        val openCount = open.size\n\
    \        val closeCount = close.size\n        if (openCount == 0 && closeCount\
    \ == 0) \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphhz90ben.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphhz90ben.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphhz90ben.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmphhz90ben.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795291
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackMax = stackSize - 1\n    \
    \    val stackMaxSize = stackMax * 2\n        val stackMaxSize2 = stackMaxSize\
    \ * 2\n        val stackMaxSize3 = stackMaxSize2 * 2\n        val stackMaxSize4\
    \ = stackMaxSize3 * 2\n        val stackMaxSize5 = stackMaxSize4 * 2\n       \
    \ val stackMaxSize6 = stackMaxSize5 * 2\n        val stackMaxSize7 = stackMaxSize6\
    \ * 2\n        val stackMaxSize8 = stackMaxSize7 * 2\n        val stackMaxSize9\
    \ = stackMaxSize8 * 2\n        val stackMaxSize10 = stackMaxSize9 * 2\n      \
    \  val stackMaxSize11 = stackMaxSize10 * 2\n        val stackMaxSize12 = stackMaxSize11\
    \ * 2\n        val stackMaxSize13 = stackMaxSize12 * 2\n        val stackMaxSize14\
    \ = stackMaxSize13 * 2\n        val stackMaxSize15 = stackMaxSize14 * 2\n    \
    \    val stackMaxSize16 = stackMaxSize15 * 2\n        val stackMaxSize17 = stackMaxSize16\
    \ * 2\n        val stackMaxSize18 = stackMaxSize17 * 2\n        val stackMaxSize19\
    \ = stackMaxSize18 * 2\n        val stackMaxSize20 = stackMaxSize19 * 2\n    \
    \    val stackMaxSize21 = stackMaxSize20 * 2\n        val stackMaxSize22 = stackMaxSize21\
    \ * 2\n        val stackMaxSize23 = stackMaxSize22 * 2\n        val stackMaxSize24\
    \ = stackMaxSize23 * 2\n        val stackMaxSize25 = stackMaxSize24 * 2\n    \
    \    val stackMaxSize26 = stackMaxSize25 * 2\n        val stackMaxSize27 = stackMaxSize26\
    \ * 2\n        val stackMaxSize28 = stackMaxSize27 * 2\n        val stackMaxSize29\
    \ = stackMaxSize28 * 2\n        val stackMaxSize30 = stackMaxSize29 * 2\n    \
    \    val stackMaxSize31 = stackMaxSize30 * 2\n        val stackMaxSize32 = stackMaxSize31\
    \ * 2\n        val stackMaxSize33 = stackMaxSize32 * 2\n        val stackMaxSize34\
    \ = stackMaxSize33 * 2\n        val stackMaxSize35 = stackMaxSize34 * 2\n    \
    \    val stack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6coqrib0.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6coqrib0.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6coqrib0.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6coqrib0.scala:56:5\
    \ ---------------------\e[0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val left = str.substring(0, open)\n \
    \               val right = str.substring(close + 1)\n                val newStack\
    \ = stack.push(left)\n                val newResult = result.push(right)\n   \
    \             while(!newStack.isEmpty && !newResult.isEmpty) {\n             \
    \       val left = newStack.pop()\n                    val right = newResult.pop()\n\
    \                    if(left == right) {\n                        result.append(\"\
    Yes\")\n                        break\n                    } else {\n        \
    \                newStack = stack.push(left + right)\n                       \
    \ newResult = result.push(right)\n                    }\n                }\n \
    \           }\n        }\n        result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvjetv3wj.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvjetv3wj.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpvjetv3wj.scala:34:24 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpvjetv3wj.scala:36:33\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                   \
    \     newStack = stack.push(left + right)\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                Reassignment to val newStack\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpvjetv3wj.scala:37:34 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                        newResult = result.push(right)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                        Reassignment to val newResult\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659795293
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val newStr = str.substring(open + 1, close)\n            val newStack\
    \ = stack.push(\"(\")\n            val newResult = result + newStr\n         \
    \   val newStack2 = stack.push(newStr)\n            val newResult2 = result +\
    \ newStr\n            val newStack3 = stack.push(\")\")\n            val newResult3\
    \ = result + newStr\n            val newStack4 = stack.push(\")\")\n         \
    \   val newResult4 = result + newStr\n            val newStack5 = stack.push(\"\
    (\")\n            val newResult5 = result + newStr\n            val newStack6\
    \ = stack.push(\")\")\n            val newResult6 = result + newStr\n        \
    \    val newStack7 = stack.push(\"(\")\n            val newResult7 = result +\
    \ newStr\n            val newStack8 = stack.push(\")\")\n            val newResult8\
    \ = result + newStr\n            val newStack9 = stack.push(\"(\")\n         \
    \   val newResult9 = result + newStr\n            val newStack10 = stack.push(\"\
    )\")\n            val newResult10 = result + newStr\n            val newStack11\
    \ = stack.push(\"(\")\n            val newResult11 = result + newStr\n       \
    \     val newStack12 = stack.push(\")\")\n            val newResult12 = result\
    \ + newStr\n            val newStack13 = stack.push(\"(\")\n            val newResult13\
    \ = result + newStr\n            val newStack14 = stack.push(\")\")\n        \
    \    val newResult14 = result + newStr\n            val newStack15 = stack.push(\"\
    (\")\n            val newResult15 = result + newStr\n            val newStack16\
    \ = stack.push(\")\")\n            val newResult16 = result + newStr\n       \
    \     val newStack17 = stack.push(\"(\")\n            val newResult17 = result\
    \ + newStr\n            val newStack18 = stack.push(\")\")\n            val newResult18\
    \ = result + newStr\n            val newStack19 = stack.push(\"(\")\n        \
    \    val newResult19 = result + newStr\n            val newStack20 = stack.push(\"\
    )\")\n            val newResult20 = result + newStr\n            val newStack21\
    \ = stack.push(\"(\")\n            val newResult\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpos2mb7ci.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpos2mb7ci.scala:82:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m82 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpos2mb7ci.scala:16:20 ------------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpos2mb7ci.scala:17:21 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpos2mb7ci.scala:81:1 ---------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpos2mb7ci.scala:66:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m66 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1659795299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.length) {\n            val str = lst(i)\n      \
    \      val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                val stackStr = str.substring(open + 1,\
    \ close)\n                if(!stack.isEmpty) {\n                    val stackStr\
    \ = stack.last\n                    if(stackStr == stackStr) {\n             \
    \           result += \"Yes\"\n                    } else {\n                \
    \        result += \"No\"\n                    }\n                } else {\n \
    \                   result += \"Yes\"\n                }\n                stack.push(str)\n\
    \            }\n        }\n        result.mkString(\",\")\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoavrsfwg.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpoavrsfwg.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                result += \"Yes\"\n                stack.push(str)\n\
    \                while(open > 0 && close > 0) {\n                    val open2\
    \ = stack.peek().indexOf(\"(\")\n                    val close2 = stack.peek().indexOf(\"\
    )\")\n                    if(open2 < 0 || close2 < 0 || open2 > close || close2\
    \ > open) {\n                        result += \"No\"\n                      \
    \  break\n                    } else {\n                        result += \"Yes\"\
    \n                        stack.pop\n                        stack.push(stack.peek()\
    \ + str.substring(open2, close2))\n                    }\n                }\n\
    \            }\n        }\n        result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqczopty1.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqczopty1.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqczopty1.scala:32:24 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659795296
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach { x =>\n            x match {\n                case \")\"\
    \ =>\n                    stack.pop() match {\n                        case Some(\"\
    (\") => result += \"(\"\n                        case _ => result += \"(\"\n \
    \                   }\n                case \")(\" =>\n                    stack.pop()\
    \ match {\n                        case Some(\"(\") => result += \"(\"\n     \
    \                   case _ => result += \"(\"\n                    }\n       \
    \         case \")\" =>\n                    stack.pop() match {\n           \
    \             case Some(\"(\") => result += \"(\"\n                        case\
    \ _ => result += \"(\"\n                    }\n                case \")(\" =>\n\
    \                    stack.pop() match {\n                        case Some(\"\
    (\") => result += \"(\"\n                        case _ => result += \"(\"\n \
    \                   }\n                case \")(\" =>\n                    stack.pop()\
    \ match {\n                        case Some(\"(\") => result += \"(\"\n     \
    \                   case _ => result += \"(\"\n                    }\n       \
    \         case \")(\" =>\n                    stack.pop() match {\n          \
    \              case Some(\"(\") => result += \"(\"\n                        case\
    \ _ => result += \"(\"\n                    }\n                case \")(\" =>\n\
    \                    stack.pop() match {\n                        case Some(\"\
    (\") => result += \"(\"\n                        case _ => result += \"(\"\n \
    \                   }\n                case \")(\" =>\n                    stack.pop()\
    \ match {\n                        case Some(\"(\") => result += \"(\"\n     \
    \                   case _ => result += \"(\"\n                    }\n       \
    \         case \")(\" =>\n                    stack.pop() match {\n          \
    \              case Some(\"(\") => result += \"(\"\n                        case\
    \ _ => result += \"(\"\n                    }\n                case \")(\" =>\n\
    \                    stack.pop() match {\n                        case Some(\"\
    (\") => result += \"(\"\n                        case _ => result += \"(\"\n \
    \                   }\n                case \")(\" =>\n                    stack.pop()\
    \ match {\n                        case Some(\"(\") => result += \"(\"\n     \
    \                   case _ => result += \"(\"\n                    }\n       \
    \         case \")(\" =>\n                    stack.pop() match {\n          \
    \              case Some(\"(\") => result += \"(\"\n                        case\
    \ _ => result += \"(\"\n                    }\n                case \")(\" =>\n\
    \                    stack.pop() match {\n                        case Some(\"\
    (\") => result += \"(\"\n                        case _ => result += \"(\"\n \
    \                   }\n                case \")(\" =>\n                    stack.pop()\
    \ match {\n                        case Some(\"(\") => result += \"(\"\n     \
    \                   case _ => result += \"(\"\n                    }\n       \
    \         case \")(\" =>\n                    stack.pop() match {\n          \
    \              case \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpvw7etbgg.scala:92:28 ---------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m                        \e[33mcase\e[0m \n\e[31m\e[31m\
    \   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m                \
    \            pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpvw7etbgg.scala:110:0 ---------------------------\e[0m\e[0m\n\e[31m110\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvw7etbgg.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvw7etbgg.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpvw7etbgg.scala:94:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m94 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659795295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        val openCount = mutable.Map[String, Int]()\n        val closeCount =\
    \ mutable.Map[String, Int]()\n        lst.foreach(x => {\n            x match\
    \ {\n                case \")\" => {\n                    closeCount += x -> 1\n\
    \                    close.push(x)\n                }\n                case \"\
    )(\" => {\n                    openCount += x -> 1\n                    open.push(x)\n\
    \                }\n                case \")(\" => {\n                    openCount\
    \ += x -> 1\n                    open.push(x)\n                }\n           \
    \     case \")(\" => {\n                    openCount += x -> 1\n            \
    \        open.push(x)\n                }\n                case \")(\" => {\n \
    \                   openCount += x -> 1\n                    open.push(x)\n  \
    \              }\n                case \")(\" => {\n                    openCount\
    \ += x -> 1\n                    open.push(x)\n                }\n           \
    \     case \")(\" => {\n                    openCount += x -> 1\n            \
    \        open.push(x)\n                }\n                case \")(\" => {\n \
    \                   openCount += x -> 1\n                    open.push(x)\n  \
    \              }\n                case \")(\" => {\n                    openCount\
    \ += x -> 1\n                    open.push(x)\n                }\n           \
    \     case \")(\" => {\n                    openCount += x -> 1\n            \
    \        open.push(x)\n                }\n                case \")(\" => {\n \
    \                   openCount += x -> 1\n                    open.push(x)\n  \
    \              }\n                case \")(\" => {\n                    openCount\
    \ += x -> 1\n                    open.push(x)\n                }\n           \
    \     case \")(\" => {\n                    openCount += x -> 1\n            \
    \        open.push(x)\n                }\n                case \")(\" => {\n \
    \                   openCount += x -> 1\n                    open.push(x)\n  \
    \              }\n                case \")(\" => {\n                    openCount\
    \ += x -> 1\n                    open.push(x)\n                }\n           \
    \     case \")(\" => {\n                    openCount += x -> 1\n            \
    \        open.push(x)\n                }\n                case \")(\" => {\n \
    \                   openCount += x -> 1\n                    open.push(x)\n  \
    \              }\n                case \")(\" => {\n                    openCount\
    \ += x -> 1\n                    open.push(x)\n                }\n           \
    \     case \")(\" => {\n                    openCount += x -> 1\n            \
    \        open.push(x)\n                }\n                case \")(\" => {\n \
    \                   openCount += x -> 1\n                    open.push(x)\n  \
    \              }\n                case \")(\" => {\n                    open\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp931zh8uz.scala:123:0 ---------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp931zh8uz.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp931zh8uz.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp931zh8uz.scala:18:19\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp931zh8uz.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp931zh8uz.scala:20:24\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mopenCount\e[0m = mutable.Map[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when com"
  stdout: ''
  timestamp: 1659795301
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val len = open - close\n            if(len > 0) {\n           \
    \     stack.push(str)\n                while(stack.nonEmpty) {\n             \
    \       val str = stack.pop()\n                    val close = str.indexOf(\"\
    )\")\n                    val len = close - open\n                    if(len >\
    \ 0) {\n                        stack.push(str)\n                    } else {\n\
    \                        result.add(str)\n                    }\n            \
    \    }\n            }\n        }\n        if(result.size == lst.size) {\n    \
    \        \"Yes\"\n        } else {\n            \"No\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_uf8u3ud.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_uf8u3ud.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795296
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else stack.pop())\n     \
    \   if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph7ntu60f.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmph7ntu60f.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795280
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")(\"  => stack.push(x)\n                case \")(\" => stack.push(x)\n\
    \                case \")\" => stack.push(x)\n                case x => open.add(x)\n\
    \            }\n        })\n        val openCount = open.size\n        val closeCount\
    \ = close.size\n        if (openCount == closeCount) {\n            val openList\
    \ = open.iterator\n            val closeList = close.iterator\n            while\
    \ (openList.hasNext && closeList.hasNext) {\n                val open = openList.next()\n\
    \                val close = closeList.next()\n                if (open == close)\
    \ {\n                    result += \"Yes\"\n                } else {\n       \
    \             result += \"No\"\n                }\n            }\n        }\n\
    \        result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmfa2codw.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmfa2codw.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmfa2codw.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpmfa2codw.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val len = lst.size\n        for(i <- 0 until len) {\n            val\
    \ str = lst(i)\n            val open = str.indexOf(\"(\")\n            val close\
    \ = str.indexOf(\")\")\n            if(open < 0 || close < 0) {\n            \
    \    result.append(\"No\")\n            } else {\n                val openCount\
    \ = stack.length\n                val closeCount = stack.length\n            \
    \    while(open < close && openCount > 0 && closeCount > 0) {\n              \
    \      if(openCount > closeCount) {\n                        stack.pop\n     \
    \                   openCount -= 1\n                    } else {\n           \
    \             stack.pop\n                        closeCount -= 1\n           \
    \         }\n                }\n                if(openCount > closeCount) {\n\
    \                    stack += str\n                } else {\n                \
    \    stack += str.substring(0, close)\n                    result.append(\"Yes\"\
    )\n                }\n            }\n        }\n        if(result.size == len)\
    \ {\n            result.mkString(\"Yes\")\n        } else {\n            result.mkString(\"\
    No\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5accvqmc.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5accvqmc.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795296
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop\n                case \")(\"  => stack.append(x)\n            \
    \    case _ => stack.append(x)\n            }\n        })\n        stack.toList\
    \ match {\n            case Nil => result.append(\"Yes\")\n            case x\
    \ => result.append(\"No\")\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmply_ldml8.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmply_ldml8.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795295
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack.push(x) else if (x == \")\") queue.push(x)\
    \ else if (stack.nonEmpty && queue.nonEmpty) if (!stack.isEmpty && !queue.isEmpty\
    \ && stack.peek == queue.peek) good.add(x)\n        else bad.add(x))\n       \
    \ if (good.size == lst.size) good.toSet.mkString(\"Yes\") else \"No\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0_8dgx0l.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0_8dgx0l.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0_8dgx0l.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp0_8dgx0l.scala:19:18 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795296
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n\
    \        val stackSize3 = stackSize2 * stackSize\n        val stackSize4 = stackSize3\
    \ * stackSize\n        val stackSize5 = stackSize4 * stackSize\n        val stackSize6\
    \ = stackSize5 * stackSize\n        val stackSize7 = stackSize6 * stackSize\n\
    \        val stackSize8 = stackSize7 * stackSize\n        val stackSize9 = stackSize8\
    \ * stackSize\n        val stackSize10 = stackSize9 * stackSize\n        val stackSize11\
    \ = stackSize10 * stackSize\n        val stackSize12 = stackSize11 * stackSize\n\
    \        val stackSize13 = stackSize12 * stackSize\n        val stackSize14 =\
    \ stackSize13 * stackSize\n        val stackSize15 = stackSize14 * stackSize\n\
    \        val stackSize16 = stackSize15 * stackSize\n        val stackSize17 =\
    \ stackSize16 * stackSize\n        val stackSize18 = stackSize17 * stackSize\n\
    \        val stackSize19 = stackSize18 * stackSize\n        val stackSize20 =\
    \ stackSize19 * stackSize\n        val stackSize21 = stackSize20 * stackSize\n\
    \        val stackSize22 = stackSize21 * stackSize\n        val stackSize23 =\
    \ stackSize22 * stackSize\n        val stackSize24 = stackSize23 * stackSize\n\
    \        val stackSize25 = stackSize24 * stackSize\n        val stackSize26 =\
    \ stackSize25 * stackSize\n        val stackSize27 = stackSize26 * stackSize\n\
    \        val stackSize28 = stackSize27 * stackSize\n        val stackSize29 =\
    \ stackSize28 * stackSize\n        val stackSize30 = stackSize29 * stackSize\n\
    \        val stackSize31 = stackSize30 * stackSize\n        val stackSize32 =\
    \ stackSize31 * stackSize\n        val stackSize33 = stackSize32 * stackSize\n\
    \        val stackSize34 = stackSize33 * stackSize\n        val stackSize35 =\
    \ stackSize34 * stackSize\n        val stackSize36 = stackSize35 * stackSize\n\
    \        val stackSize37 = stackSize36 * stackSize\n        val stackSize38 =\
    \ stackSize37 * stackSize\n        val stackSize39 = stackSize38 * stackSize\n\
    \        val stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6b9lran6.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6b9lran6.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { x =>\n            if (x == '(') {\n                stack.push(x)\n\
    \            } else if (x == '(') {\n                if (stack.isEmpty) {\n  \
    \                  result += \"No\"\n                } else {\n              \
    \      result += \"Yes\"\n                }\n                stack.pop()\n   \
    \         } else if (x == ')') {\n                if (stack.isEmpty) {\n     \
    \               result += \"No\"\n                } else {\n                 \
    \   result += \"Yes\"\n                }\n                stack.pop()\n      \
    \      } else {\n                result += \"No\"\n            }\n        }\n\
    \        result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp66dxehu9.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp66dxehu9.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp66dxehu9.scala:19:16 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (x == \e[31m'('\e[0m) {\n\e\
    [31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmp66dxehu9.scala:21:23 -----------------------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (x == \e[31m'('\e\
    [0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types String and Char cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmp66dxehu9.scala:28:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            } \e[33melse\e[0m \e[33mif\e[0m (x == \e\
    [31m')'\e[0m) {\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m        Values of types String and Char cannot be compared with ==\
    \ or !=\n5 errors found\n"
  stdout: ''
  timestamp: 1659795304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.length){\n            val str = lst(i)\n       \
    \     val open = str.indexOf('(')\n            val close = str.indexOf(')')\n\
    \            val openCount = stack.length\n            val closeCount = stack.length\n\
    \            if(open < 0 || close < 0){\n                result.append(\"No\"\
    )\n                return result.toString()\n            }\n            else if(open\
    \ > close){\n                result.append(\"No\")\n                return result.toString()\n\
    \            }\n            else if(open == close){\n                result.append(\"\
    No\")\n                return result.toString()\n            }\n            else\
    \ if(openCount > closeCount){\n                result.append(\"No\")\n       \
    \         return result.toString()\n            }\n            else if(openCount\
    \ == closeCount){\n                result.append(\"Yes\")\n                return\
    \ result.toString()\n            }\n            else if(openCount < closeCount){\n\
    \                stack.push(str)\n            }\n            else if(openCount\
    \ > closeCount){\n                stack.pop()\n            }\n        }\n    \
    \    result.append(\"No\")\n        return result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmk5y22n6.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmk5y22n6.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        val open = mutable.Set[String]()\n\
    \        val close = mutable.Set[String]()\n        lst.foreach(x => {\n     \
    \       if (x == \"(\") open.add(x)\n            if (x == \")\") close.add(x)\n\
    \        })\n        open.foreach(x => stack += x)\n        close.foreach(x =>\
    \ stack -= x)\n        queue.foreach(x => result += x)\n        if (stack.size\
    \ == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmm2eowma.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmm2eowma.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmm2eowma.scala:18:21 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmm2eowma.scala:19:19 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpmm2eowma.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795298
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop() match {\n                        case\
    \ Some(\"(\") => result.add(\"Yes\")\n                        case _ => result.add(\"\
    No\")\n                    }\n                }\n                case \")(\" =>\
    \ stack += x\n                case _ => stack += x\n            }\n        })\n\
    \        if (stack.size == 0) result.add(\"Yes\") else \"No\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppacbmo1x.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppacbmo1x.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795299
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach {\n            case x if x != \")\" => open.add(x)\n    \
    \        case x if x == \")\" => close.add(x)\n            case x => stack +=\
    \ x\n        }\n        val openCount = open.size\n        val closeCount = close.size\n\
    \        if (openCount == closeCount) {\n            val openStack = stack.take(openCount)\n\
    \            val closeStack = stack.drop(openCount)\n            val openStackSize\
    \ = openStack.size\n            val closeStackSize = closeStack.size\n       \
    \     if (openStackSize == closeStackSize) {\n                val openStack =\
    \ stack.take(openStackSize)\n                val closeStack = stack.drop(openStackSize)\n\
    \                val openStackSize = openStack.size\n                val closeStackSize\
    \ = closeStack.size\n                if (openStackSize == closeStackSize) {\n\
    \                    val openStack = stack.take(openStackSize)\n             \
    \       val closeStack = stack.drop(openStackSize)\n                    val openStackSize\
    \ = openStack.size\n                    val closeStackSize = closeStack.size\n\
    \                    if (openStackSize == closeStackSize) {\n                \
    \        val openStack = stack.take(openStackSize)\n                        val\
    \ closeStack = stack.drop(openStackSize)\n                        val openStackSize\
    \ = openStack.size\n                        val closeStackSize = closeStack.size\n\
    \                        if (openStackSize == closeStackSize) {\n            \
    \                val openStack = stack.take(openStackSize)\n                 \
    \           val closeStack = stack.drop(openStackSize)\n                     \
    \       val openStackSize = openStack.size\n                            val closeStackSize\
    \ = closeStack.size\n                            if (openStackSize == closeStackSize)\
    \ {\n                                val openStack = stack.take(openStackSize)\n\
    \                                val closeStack = stack.drop(openStackSize)\n\
    \                                val openStackSize = openStack.size\n        \
    \                        val closeStackSize = closeStack.size\n              \
    \                  if (openStackSize == closeStackSize) {\n                  \
    \                  val openStack = stack.take(openStackSize)\n               \
    \                     val closeStack = stack.drop(openStackSize)\n           \
    \                         val openStackSize = openStack.size\n               \
    \                     val closeStackSize = closeStack.size\n                 \
    \                   if (openStackSize == closeStackSize) {\n                 \
    \                       val openStack = stack.take(openStackSize)\n          \
    \                              val closeStack = stack.drop(openStackSize)\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_lvzi87s.scala:82:0 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_lvzi87s.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_lvzi87s.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_lvzi87s.scala:18:19\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_lvzi87s.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_lvzi87s.scala:27:8\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mif\e[0m (openCount\
    \ == closeCount) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Unit\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m \
    \       Maybe you are missing an else part for the conditional?\n\e[31m28 |\e\
    [0m            \e[33mval\e"
  stdout: ''
  timestamp: 1659795303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val stackStr = str.substring(open + 1,\
    \ close)\n                val stackStr = stackStr.trim\n                if(stackStr.isEmpty)\
    \ {\n                    result.append(\"No\")\n                } else {\n   \
    \                 stack += stackStr\n                }\n            }\n      \
    \  }\n        if(result.size == lst.size) {\n            val stackStr = stack.toList\n\
    \            val stackStr = stackStr.mkString(\"\")\n            val stackStr\
    \ = stackStr.trim\n            if(stackStr.isEmpty) {\n                result.append(\"\
    Yes\")\n            } else {\n                result.append(\"No\")\n        \
    \    }\n        }\n        result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpynycbzcz.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpynycbzcz.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpynycbzcz.scala:26:20 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e[0m \e[36mstackStr\e[0m =\
    \ stackStr.trim\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackStr is already defined as \e[33mvalue\e[0m \e[35mstackStr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpynycbzcz.scala:36:16 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m            \e[33mval\e[0m \e[36mstackStr\e[0m = stackStr.mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackStr is already defined as \e[33mvalue\e[0m \e[35mstackStr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpynycbzcz.scala:37:16 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m            \e[33mval\e[0m \e[36mstackStr\e[0m = stackStr.trim\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mstackStr is already defined as \e[33mvalue\e[0m \e[35mstackStr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same "
  stdout: ''
  timestamp: 1659795303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n        \
    \        open += s\n            } else if (s.endsWith(\")\")) {\n            \
    \    close += s\n            } else {\n                stack += s\n          \
    \  }\n        }\n        val openCount = open.size\n        val closeCount = close.size\n\
    \        if (openCount == closeCount) {\n            val openStr = open.toList\n\
    \            val closeStr = close.toList\n            val openStrSize = openStr.size\n\
    \            val closeStrSize = closeStr.size\n            val openStrSet = openStr.iterator\n\
    \            val closeStrSet = closeStr.iterator\n            while (openStrSet.hasNext\
    \ && closeStrSet.hasNext) {\n                val openStr = openStrSet.next()\n\
    \                val closeStr = closeStrSet.next()\n                val openCount\
    \ = openStr.count(\"(\")\n                val closeCount = closeStr.count(\")\"\
    )\n                if (openCount == closeCount) {\n                    val openStr\
    \ = openStr.substring(openStr.indexOf(\"(\") + 1, openStr.indexOf(\")\"))\n  \
    \                  val closeStr = closeStr.substring(closeStr.indexOf(\")\") +\
    \ 1, closeStr.indexOf(\")\"))\n                    val openStrSize = openStr.size\n\
    \                    val closeStrSize = closeStr.size\n                    val\
    \ openStrSet = openStr.iterator\n                    val closeStrSet = closeStr.iterator\n\
    \                    while (openStrSet.hasNext && closeStrSet.hasNext) {\n   \
    \                     val openStr = openStrSet.next()\n                      \
    \  val closeStr = closeStrSet.next()\n                        val openCount =\
    \ openStr.count(\"(\")\n                        val closeCount = closeStr.count(\"\
    )\")\n                        if (openCount == closeCount) {\n               \
    \             val openStr = openStr.substring(openStr.indexOf(\"(\") + 1, openStr.indexOf(\"\
    )\"))\n                            val closeStr = closeStr.substring(closeStr.indexOf(\"\
    )\") + 1, closeStr.indexOf(\")\"))\n                            val openStrSize\
    \ = openStr.size\n                            val closeStrSize = closeStr.size\n\
    \                            val openStrSet = openStr.iterator\n             \
    \               val closeStrSet = closeStr.iterator\n                        \
    \    while (openStrSet.hasNext && closeStrSet.hasNext) {\n                   \
    \             val openStr = openStrSet.next()\n                              \
    \  val closeStr = closeStrSet.next()\n                                val openCount\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj3dn99q4.scala:65:47 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m                                \e[33mval\e[0m \e[36mopenCount\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                               ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpj3dn99q4.scala:83:0 ----------------------------\e[0m\e[0m\n\e[31m83\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj3dn99q4.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj3dn99q4.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpj3dn99q4.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpj3dn99q4.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m long"
  stdout: ''
  timestamp: 1659795303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach { x =>\n            x match {\n                case \")\"\
    \ =>\n                    stack.pop()\n                case \")(\"  =>\n     \
    \               stack += x\n                case _ =>\n                    stack\
    \ += x\n            }\n        }\n        if (stack.size == 0) \"No\" else \"\
    Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxdg94p3x.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxdg94p3x.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795303
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.ListBuffer[String]()\n        val bad = mutable.ListBuffer[String]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer[Int]()\n\
    \        val goodCount = mutable.ListBuffer[Int]()\n        val badCount = mutable.ListBuffer\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcgkmu6fe.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcgkmu6fe.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcgkmu6fe.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgoodCount is already defined as \e[33mvalue\e[0m \e[35mgoodCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcgkmu6fe.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mbadCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mbadCount is already defined as \e[33mvalue\e[0m \e[35mbadCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcgkmu6fe.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mgoodCount\e[0m = mutable.ListBuffer[\e\
    [35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^"
  stdout: ''
  timestamp: 1659795308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize2 = stackSize * stackSize\n\
    \        val stackSize3 = stackSize2 * stackSize\n        val stackSize4 = stackSize3\
    \ * stackSize\n        val stackSize5 = stackSize4 * stackSize\n        val stackSize6\
    \ = stackSize5 * stackSize\n        val stackSize7 = stackSize6 * stackSize\n\
    \        val stackSize8 = stackSize7 * stackSize\n        val stackSize9 = stackSize8\
    \ * stackSize\n        val stackSize10 = stackSize9 * stackSize\n        val stackSize11\
    \ = stackSize10 * stackSize\n        val stackSize12 = stackSize11 * stackSize\n\
    \        val stackSize13 = stackSize12 * stackSize\n        val stackSize14 =\
    \ stackSize13 * stackSize\n        val stackSize15 = stackSize14 * stackSize\n\
    \        val stackSize16 = stackSize15 * stackSize\n        val stackSize17 =\
    \ stackSize16 * stackSize\n        val stackSize18 = stackSize17 * stackSize\n\
    \        val stackSize19 = stackSize18 * stackSize\n        val stackSize20 =\
    \ stackSize19 * stackSize\n        val stackSize21 = stackSize20 * stackSize\n\
    \        val stackSize22 = stackSize21 * stackSize\n        val stackSize23 =\
    \ stackSize22 * stackSize\n        val stackSize24 = stackSize23 * stackSize\n\
    \        val stackSize25 = stackSize24 * stackSize\n        val stackSize26 =\
    \ stackSize25 * stackSize\n        val stackSize27 = stackSize26 * stackSize\n\
    \        val stackSize28 = stackSize27 * stackSize\n        val stackSize29 =\
    \ stackSize28 * stackSize\n        val stackSize30 = stackSize29 * stackSize\n\
    \        val stackSize31 = stackSize30 * stackSize\n        val stackSize32 =\
    \ stackSize31 * stackSize\n        val stackSize33 = stackSize32 * stackSize\n\
    \        val stackSize34 = stackSize33 * stackSize\n        val stackSize35 =\
    \ stackSize34 * stackSize\n        val stackSize36 = stackSize35 * stackSize\n\
    \        val stackSize37 = stackSize36 * stackSize\n        val stackSize38 =\
    \ stackSize37 * stackSize\n        val stackSize39 = stackSize38 * stackSize\n\
    \        val stackSize\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6b9lran6.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6b9lran6.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6b9lran6.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659795240
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x contains \"(\") {\n           \
    \     open += x\n            } else {\n                close += x\n          \
    \  }\n        })\n        val openCount = open.size\n        val closeCount =\
    \ close.size\n        if (openCount == closeCount) {\n            val openStack\
    \ = mutable.Stack[String]()\n            open.foreach(x => {\n               \
    \ openStack += x\n            })\n            val closeStack = mutable.Stack[String]()\n\
    \            close.foreach(x => {\n                closeStack += x\n         \
    \   })\n            while (openStack.nonEmpty && closeStack.nonEmpty) {\n    \
    \            val open = openStack.pop()\n                val close = closeStack.pop()\n\
    \                if (open == close) {\n                    result += \"(\" + open\
    \ + \")\"\n                } else {\n                    result += \"(\" + open\
    \ + \")\" + close\n                }\n            }\n        }\n        if (result.nonEmpty)\
    \ {\n            return \"Yes\"\n        } else {\n            return \"No\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1wulo6f3.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1wulo6f3.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1wulo6f3.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1wulo6f3.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1wulo6f3.scala:30:28 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36mopenStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1wulo6f3.scala:34:29 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mcloseStack\e["
  stdout: ''
  timestamp: 1659795304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            val openCount = open.count(_ == s)\n\
    \            val closeCount = close.count(_ == s)\n            if (openCount >\
    \ closeCount) {\n                result += \"No\"\n            } else {\n    \
    \            result += \"Yes\"\n            }\n            open += s\n       \
    \     close += s\n            stack += s\n        }\n        result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6loklb7l.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6loklb7l.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6loklb7l.scala:18:19 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp6loklb7l.scala:19:20 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795304
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") stack.pop()\
    \ else stack += x)\n        if (stack.size == 0) \"No\" else \"Yes\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1yvsvriq.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1yvsvriq.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp1yvsvriq.scala:18:59 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) stack.pop() \e[33melse\e[0m stack += x)\n\e[31m\e[31m   |\e[0m     \
    \                                                      ^^\e[0m\n\e[31m   |\e[0m\
    \                                 value unary_! is not a member of String\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795309
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        for(i <- 0 until stackSize) {\n   \
    \         val str = lst(i)\n            val open = str.indexOf(\"(\")\n      \
    \      val close = str.indexOf(\")\")\n            if(open < 0 || close < 0) {\n\
    \                result.append(\"No\")\n            } else {\n               \
    \ val stackStr = str.substring(open + 1, close)\n                stack += stackStr\n\
    \            }\n        }\n        if(stack.size == stackSize) {\n           \
    \ result.append(\"Yes\")\n        } else {\n            result.append(\"No\")\n\
    \        }\n        result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl6x38ypa.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpl6x38ypa.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795307
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val stackSize = stack.size\n        \
    \        if(open < close && stackSize > 0) {\n                    stackSize -=\
    \ 1\n                    stack += str\n                } else if(open > close\
    \ && stackSize > 0) {\n                    stackSize -= 1\n                  \
    \  stack += str.reverse\n                } else {\n                    result.append(\"\
    No\")\n                }\n            }\n        }\n        if(result.size ==\
    \ lst.size) {\n            val stackSize = stack.size\n            if(stackSize\
    \ == 0) {\n                result.append(\"Yes\")\n            } else {\n    \
    \            result.append(\"No\")\n            }\n        }\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkgbbks4f.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkgbbks4f.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795307
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    if(str == \"(\") {\n                stack.push(str)\n            } else if(str\
    \ == \")\") {\n                val str = stack.pop()\n                if(str !=\
    \ \"\") {\n                    result += \"(\" + str + \")\"\n               \
    \ }\n            } else {\n                result += \"(\" + str + \")\"\n   \
    \         }\n        }\n        if(result.size == lst.size) {\n            val\
    \ str = result.toString\n            if(str.startsWith(\"(\") && str.endsWith(\"\
    )\")) {\n                return \"Yes\"\n            }\n        }\n        return\
    \ \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpo23tkakq.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpo23tkakq.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659795308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.ListBuffer.empty[String]\n        val close = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            if (s == \"(\") open += s\n         \
    \   if (s == \"(\") stack += s\n            if (s == \")\")\n                if\
    \ (open.isEmpty) result += \"No\"\n                else if (open == close) result\
    \ += \"Yes\"\n                else if (stack.last == close) result += \"Yes\"\n\
    \                else if (stack.last == open) result += \"No\"\n             \
    \   else if (stack.last == open) result += \"Yes\"\n                else if (stack.last\
    \ == close) result += \"No\"\n                else if (stack.last == open) result\
    \ += \"No\"\n                else if (stack.last == close) result += \"Yes\"\n\
    \                else if (stack.last == open) result += \"No\"\n             \
    \   else if (stack.last == close) result += \"No\"\n                else if (stack.last\
    \ == open) result += \"Yes\"\n                else if (stack.last == close) result\
    \ += \"No\"\n                else if (stack.last == open) result += \"No\"\n \
    \               else if (stack.last == close) result += \"Yes\"\n            \
    \    else if (stack.last == open) result += \"No\"\n                else if (stack.last\
    \ == close) result += \"No\"\n                else if (stack.last == open) result\
    \ += \"Yes\"\n                else if (stack.last == close) result += \"No\"\n\
    \                else if (stack.last == open) result += \"No\"\n             \
    \   else if (stack.last == close) result += \"Yes\"\n                else if (stack.last\
    \ == open) result += \"No\"\n                else if (stack.last == close) result\
    \ += \"No\"\n                else if (stack.last == open) result += \"Yes\"\n\
    \                else if (stack.last == close) result += \"No\"\n            \
    \    else if (stack.last == open) result += \"No\"\n                else if (stack.last\
    \ == close) result += \"Yes\"\n                else if (stack.last == open) result\
    \ += \"No\"\n                else if (stack.last == close) result += \"No\"\n\
    \                else if (stack.last == open) result += \"Yes\"\n            \
    \    else if (stack.last == close) result += \"No\"\n                else if (stack.last\
    \ == open) result += \"No\"\n                else if (stack.last == close) result\
    \ += \"Yes\"\n                else if (stack.last == open) result += \"No\"\n\
    \                else if (stack.last == close) result += \"No\"\n            \
    \    else if (stack.last == open) result += \"Yes\"\n                else if (stack.last\
    \ == close) result += \"No\"\n                else if (\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_51ibtpw.scala:60:25 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m                \e[33melse\e[0m \e[33mif\e[0m (\n\e[31m\e\
    [31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m                \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp_51ibtpw.scala:78:0 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_51ibtpw.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_51ibtpw.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_51ibtpw.scala:18:19\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_51ibtpw.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ com"
  stdout: ''
  timestamp: 1659795309
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \")()\" => close.push(x)\n            case x if x\
    \ == \"()\" => open.push(x)\n            case x if x == \")()()\" => close.push(x)\n\
    \            case x if x == \")()()()\" => close.push(x)\n            case x if\
    \ x == \")()()()()\" => close.push(x)\n            case x if x == \")()()()()()\"\
    \ => close.push(x)\n            case x if x == \")()()()()()()\" => close.push(x)\n\
    \            case x if x == \")()()()()()()()\" => close.push(x)\n           \
    \ case x if x == \")()()()()()()()()\" => close.push(x)\n            case x if\
    \ x == \")()()()()()()()()()\" => close.push(x)\n            case x if x == \"\
    )()()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()\"\
    \ => close.push(x)\n            case x if x == \")()()()()()()()()()()\" => close.push(x)\n\
    \            case x if x == \")()()()()()()()()()()()\" => close.push(x)\n   \
    \         case x if x == \")()()()()()()()()()()()()\" => close.push(x)\n    \
    \        case x if x == \")()()()()()()()()()()()()\" => close.push(x)\n     \
    \       case x if x == \")()()()()()()()()()()()()\" => close.push(x)\n      \
    \      case x if x == \")()()()()()()()()()()()()\" => close.push(x)\n       \
    \     case x if x == \")()()()()()()()()()()()()()\" => close.push(x)\n      \
    \      case x if x == \")()()()()()()()()()()()()()\" => close.push(x)\n     \
    \       case x if x == \")()()()()()()()()()()()()()\" => close.push(x)\n    \
    \        case x if x == \")()()()()()()()()()()()()()\" \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptvbkzcdl.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptvbkzcdl.scala:45:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m45 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmptvbkzcdl.scala:61:0 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptvbkzcdl.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptvbkzcdl.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptvbkzcdl.scala:18:19\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptvbkzcdl.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e"
  stdout: ''
  timestamp: 1659795307
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.ListBuffer.empty[String]\n        val close = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.push(x)\n                case \")(\" =>\n    \
    \                open.push(x)\n                case _ =>\n                   \
    \ stack.push(x)\n            }\n        })\n        while(stack.nonEmpty) {\n\
    \            val x = stack.pop()\n            x match {\n                case\
    \ \")\" =>\n                    close.push(x)\n                case \")(\" =>\n\
    \                    open.push(x)\n                case _ =>\n               \
    \     stack.push(x)\n            }\n        }\n        val openCount = open.size\n\
    \        val closeCount = close.size\n        if(openCount == closeCount) {\n\
    \            val openStr = open.toList\n            val closeStr = close.toList\n\
    \            val openStrLen = openStr.size\n            val closeStrLen = closeStr.size\n\
    \            if(openStrLen > closeStrLen) {\n                val newOpen = openStr.take(closeStrLen)\n\
    \                val newClose = closeStr.take(openStrLen)\n                val\
    \ newStack = mutable.Stack[String]()\n                newStack.push(newOpen)\n\
    \                newStack.push(newClose)\n                while(newStack.nonEmpty)\
    \ {\n                    val x = newStack.pop()\n                    x match {\n\
    \                        case \")\" =>\n                            close.push(x)\n\
    \                        case \")(\" =>\n                            open.push(x)\n\
    \                        case _ =>\n                            newStack.push(x)\n\
    \                    }\n                }\n                val newOpenCount =\
    \ open.size\n                val newCloseCount = close.size\n                if(newOpenCount\
    \ == newCloseCount) {\n                    val newOpenStr = open.toList\n    \
    \                val newCloseStr = close.toList\n                    val newOpenStrLen\
    \ = newOpenStr.size\n                    val newCloseStrLen = newCloseStr.size\n\
    \                    if(newOpenStrLen > newCloseStrLen) {\n                  \
    \      val newOpen = newOpenStr.take(newCloseStrLen)\n                       \
    \ val newClose = newCloseStr.take(newOpenStrLen)\n                        val\
    \ newStack = mutable.Stack[String]()\n                        newStack.push(newOpen)\n\
    \                        newStack.push(newClose)\n                        while(newStack.nonEmpty)\
    \ {\n                            val x = newStack.pop()\n                    \
    \        x match {\n                                case \")\" =>\n          \
    \                          close.push(x)\n                                \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpby_vkozj.scala:101:0 ---------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpby_vkozj.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpby_vkozj.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpby_vkozj.scala:18:19\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpby_vkozj.scala:19:20\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpby_vkozj.scala:51:31\
    \ ------------------------\e[0m\e[0m\n\e[31m51 |\e[0m                \e[33mval\e\
    [0m \e[36mnewStack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                               ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m lo"
  stdout: ''
  timestamp: 1659795308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val index = str.indexOf(\"(\")\n            val endIndex = str.indexOf(\"\
    )\")\n            if(index == -1 || endIndex == -1) {\n                stack +=\
    \ str\n            } else {\n                val openParen = str.substring(0,\
    \ index)\n                val closeParen = str.substring(endIndex + 1, str.length)\n\
    \                stack += openParen\n                stack += closeParen\n   \
    \         }\n        }\n        val stackSize = stack.size\n        val stackElements\
    \ = stack.iterator\n        while(stackElements.hasNext) {\n            val element\
    \ = stackElements.next()\n            val index = element.indexOf(\"(\")\n   \
    \         val endIndex = element.indexOf(\")\")\n            if(index == -1 ||\
    \ endIndex == -1) {\n                result += \"(\" + element + \")\"\n     \
    \       } else {\n                val openParen = element.substring(0, index)\n\
    \                val closeParen = element.substring(endIndex + 1, element.length)\n\
    \                result += \"(\" + openParen + \")\" + closeParen\n          \
    \  }\n        }\n        if(result.size == stackSize) {\n            return \"\
    Yes\"\n        } else {\n            return \"No\"\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqa_kcjm9.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqa_kcjm9.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.length) {\n            val str = lst(i)\n      \
    \      val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openCount = stack.length\n      \
    \          val closeCount = stack.length\n                val openParen = str.indexOf(\"\
    (\")\n                val closeParen = str.indexOf(\")\")\n                val\
    \ openParenCount = openParen\n                val closeParenCount = closeParen\n\
    \                val openCount = openParenCount - closeParenCount\n          \
    \      val closeCount = closeParenCount - openParenCount\n                val\
    \ openParenCount = openParen\n                val closeParenCount = closeParen\n\
    \                val openCount = openParenCount - closeParenCount\n          \
    \      val closeCount = closeParenCount - openParenCount\n                if(openCount\
    \ > closeCount) {\n                    result.append(\"No\")\n               \
    \ } else {\n                    result.append(\"Yes\")\n                }\n  \
    \          }\n            stack.push(str)\n        }\n        return result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp07bhhww7.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp07bhhww7.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp07bhhww7.scala:33:20 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                \e[33mval\e[0m \e[36mopenParenCount\e\
    [0m = openParen\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenParenCount is already defined as \e[33mvalue\e[0m \e[35mopenParenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp07bhhww7.scala:34:20 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m                \e[33mval\e[0m \e[36mcloseParenCount\e[0m = closeParen\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mcloseParenCount is already defined as \e[33mvalue\e[0m \e[35mcloseParenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1659795308
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val stackSize = stack.size\n            if(open < close && stackSize\
    \ > 0) {\n                val stackStr = stack.toList\n                val stackStrSize\
    \ = stackStr.size\n                val stackStrLast = stackStr(stackStrSize -\
    \ 1)\n                val stackStrFirst = stackStr(0)\n                val stackStrLastIndex\
    \ = stackStr.lastIndex\n                val stackStrFirstIndex = stackStr.indexOf(0)\n\
    \                val stackStrLastChar = stackStr(stackStrLastIndex - 1)\n    \
    \            val stackStrFirstChar = stackStr(stackStrFirstIndex - 1)\n      \
    \          val stackStrLastCharIndex = stackStr.lastIndexOf(0)\n             \
    \   val stackStrFirstCharIndex = stackStr.indexOf(0)\n                val stackStrLastCharCount\
    \ = stackStr.lastIndexOf(0)\n                val stackStrFirstCharCount = stackStr.indexOf(0)\n\
    \                val stackStrLastCharCountIndex = stackStr.lastIndexOf(0)\n  \
    \              val stackStrFirstCharCountIndex = stackStr.indexOf(0)\n       \
    \         val stackStrLastCharCountIndex = stackStr.lastIndexOf(0)\n         \
    \       val stackStrFirstCharCountIndex = stackStr.indexOf(0)\n              \
    \  val stackStrLastCharCountIndex = stackStr.lastIndexOf(0)\n                val\
    \ stackStrFirstCharCountIndex = stackStr.indexOf(0)\n                val stackStrLastCharCountIndex\
    \ = stackStr.lastIndexOf(0)\n                val stackStrFirstCharCountIndex =\
    \ stackStr.indexOf(0)\n                val stackStrLastCharCountIndex = stackStr.lastIndexOf(0)\n\
    \                val stackStrFirstCharCountIndex = stackStr.indexOf(0)\n     \
    \           val stackStrLastCharCountIndex = stackStr.lastIndexOf(0)\n       \
    \         val stackStrFirstCharCountIndex = stackStr.indexOf(0)\n            \
    \    val stackStrLastCharCountIndex = stackStr.lastIndexOf(0)\n              \
    \  val stackStrFirstCharCountIndex = stackStr.indexOf(0)\n                val\
    \ stackStrLastCharCountIndex = stackStr.lastIndexOf(0)\n                val stackStrFirstCharCountIndex\
    \ = stackStr.indexOf(0)\n                val stackStrLastCharCountIndex = stackStr.lastIndexOf(0)\n\
    \                val stackStrFirstCharCountIndex = stackStr.indexOf(0)\n     \
    \           val stackStrLastCharCountIndex = stackStr.lastIndexOf(0)\n       \
    \         val stackStrFirstCharCountIndex = stackStr\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2u8zxyso.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2u8zxyso.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2u8zxyso.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2u8zxyso.scala:18:8\
    \ ---------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mfor\e[0m(i <-\
    \ \e[31m0\e[0m until lst.size) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: String\n\e\
    [31m19 |\e[0m            \e[33mval\e[0m \e[36mstr\e[0m = lst(i)\n\e[31m20 |\e\
    [0m            \e[33mval\e[0m \e[36mopen\e[0m = str.indexOf(\e[31m\"(\"\e[0m)\n\
    \e[31m21 |\e[0m            \e[33mval\e[0m \e[36mclose\e[0m = str.indexOf(\e[31m\"\
    )\"\e[0m)\n\e[31m22 |\e[0m            \e[33mval\e[0m \e[36mstackSize\e[0m = stack.size\n\
    \e[31m23 |\e[0m            \e[33mif\e[0m(open < close && stackSize > \e[31m0\e\
    [0m) {\n\e[31m24 |\e[0m                \e[33mval\e[0m \e[36mstackStr\e[0m = stack.toList\n\
    \e[31m25 |\e[0m                \e[33mval\e[0m \e[36mstackStrSize\e[0m = stackStr.size\n\
    \e[31m26 |\e[0m                \e[33mval\e[0m \e[36mstackStrLast\e[0m = stackStr(stackStrSize\
    \ - \e[31m1\e[0m)\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36mstackStrFirst\e\
    [0m = stackStr(\e[31m0\e[0m)\n\e[31m28 |\e[0m                \e[33mval\e[0m \e\
    [36mstackStrLastIndex\e[0m = stackStr.lastIndex\n\e[31m29 |\e[0m             \
    \   \e[33mval\e"
  stdout: ''
  timestamp: 1659795310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach(x => if (x == \"\
    (\") stack += x else if (!x == \"(\") queue += x else ())\n        while(!stack.isEmpty\
    \ && !queue.isEmpty) {\n            val x = stack.pop()\n            val y = queue.pop()\n\
    \            if (x == \"(\" && y == \"(\") good += x else if (!x == \"(\" && y\
    \ == \"(\") good += y else if (!x == \"(\" && y == \")\") good += y else if (!x\
    \ == \"(\" && y == \")\") good += x else if (!x == \"(\" && y == \"[\")) good\
    \ += y else if (!x == \"(\" && y == \"[\")) good += x else if (!x == \"(\" &&\
    \ y == \"{\")) good += y else if (!x == \"(\" && y == \"{\")) good += x else if\
    \ (!x == \"(\" && y == \"]\")) good += y else if (!x == \"(\" && y == \"]\"))\
    \ good += x else if (!x == \"(\" && y == \"}\")) good += y else if (!x == \"(\"\
    \ && y == \"}\")) good += x else if (!x == \"[\" && y == \"[\")) good += y else\
    \ if (!x == \"[\" && y == \"[\")) good += x else if (!x == \"[\" && y == \"{\"\
    )) good += y else if (!x == \"[\" && y == \"{\")) good += x else if (!x == \"\
    [\" && y == \"}\")) good += y else if (!x == \"[\" && y == \"}\")) good += x else\
    \ if (!x == \"{\" && y == \"{\")) good += y else if (!x == \"{\" && y == \"{\"\
    )) good += x else if (!x == \"{\" && y == \"}\")) good += y else if (!x == \"\
    {\" && y == \"}\")) good += x else if (!x == \"}\" && y == \"}\")) good += y else\
    \ if (!x == \"}\" && y == \"}\")) good += x else if (!x == \"}\" && y == \"[\"\
    )) good += y else if (!x == \"}\" && y == \"[\")) good += x else if (!x == \"\
    }\" && y == \"{\")) good += y else if (!x == \"}\" && y == \"{\")) good += x else\
    \ if (!x == \"}\" && y == \"]\")) good += y else if (!x == \"}\" && y == \"]\"\
    )) good += x else if (!x == \"}\" && y == \"}\")) good += y else if (!x == \"\
    }\" && y == \"}\")) good \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphg6fa9e_.scala:23:205 --------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mif\e[0m (x == \e[31m\"(\"\e[0m && y\
    \ == \e[31m\"(\"\e[0m) good += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m && y == \e[31m\"(\"\e[0m) good += y \e[33melse\e[0m \e[33mif\e[0m (!x\
    \ == \e[31m\"(\"\e[0m && y == \e[31m\")\"\e[0m) good += y \e[33melse\e[0m \e[33mif\e\
    [0m (!x == \e[31m\"(\"\e[0m && y == \e[31m\")\"\e[0m) good += x \e[33melse\e[0m\
    \ \e[33mif\e[0m (!x == \e[31m\"(\"\e[0m && y == \e[31m\"[\"\e[0m)) good += y \e\
    [33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"(\"\e[0m && y == \e[31m\"[\"\e[0m))\
    \ good += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"(\"\e[0m && y == \e[31m\"\
    {\"\e[0m)) good += y \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"(\"\e[0m &&\
    \ y == \e[31m\"{\"\e[0m)) good += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m && y == \e[31m\"]\"\e[0m)) good += y \e[33melse\e[0m \e[33mif\e[0m (!x\
    \ == \e[31m\"(\"\e[0m && y == \e[31m\"]\"\e[0m)) good += x \e[33melse\e[0m \e\
    [33mif\e[0m (!x == \e[31m\"(\"\e[0m && y == \e[31m\"}\"\e[0m)) good += y \e[33melse\e\
    [0m \e[33mif\e[0m (!x == \e[31m\"(\"\e[0m && y == \e[31m\"}\"\e[0m)) good += x\
    \ \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"[\"\e[0m && y == \e[31m\"[\"\e\
    [0m)) good += y \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"[\"\e[0m && y ==\
    \ \e[31m\"[\"\e[0m)) good += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"[\"\
    \e[0m && y == \e[31m\"{\"\e[0m)) good += y \e[33melse\e[0m \e[33mif\e[0m (!x ==\
    \ \e[31m\"[\"\e[0m && y == \e[31m\"{\"\e[0m)) good += x \e[33melse\e[0m \e[33mif\e\
    [0m (!x == \e[31m\"[\"\e[0m && y == \e[31m\"}\"\e[0m)) good += y \e[33melse\e\
    [0m \e[33mif\e[0m (!x == \e[31m\"[\"\e[0m && y == \e[31m\"}\"\e[0m)) good += x\
    \ \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"{\"\e[0m && y == \e[31m\"{\"\e\
    [0m)) good += y \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"{\"\e[0m && y ==\
    \ \e[31m\"{\"\e[0m)) good += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"{\"\
    \e[0m && y == \e[31m\"}\"\e[0m)) good += y \e[33melse\e[0m \e[33mif\e[0m (!x ==\
    \ \e[31m\"{\"\e[0m && y == \e[31m\"}\"\e[0m)) good += x \e[33melse\e[0m \e[33mif\e\
    [0m (!x == \e[31m\"}\"\e[0m && y == \e[31m\"}\"\e[0m)) good += y \e[33melse\e\
    [0m \e[33mif\e[0m (!x == \e[31m\"}\"\e[0m && y == \e[31m\"}\"\e[0m)) good += x\
    \ \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"}\"\e[0m &"
  stdout: ''
  timestamp: 1659795310
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val stackSize = stack.size\n        \
    \        if(open < close) {\n                    stack.push(str)\n           \
    \     } else {\n                    val top = stack.pop()\n                  \
    \  if(top == str) {\n                        result.append(\"Yes\")\n        \
    \            } else {\n                        result.append(\"No\")\n       \
    \             }\n                }\n            }\n        }\n        return result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_csgwcu9.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_csgwcu9.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659795309
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmszynk3u.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:16:20\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:19:21\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmszynk3u.scala:20:21\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659795241
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    // match_parens(['()(', ')']) == 'Yes'\n    // match_parens([')',\
    \ ')']) == 'No'\n    def matchParens(lst : List[String]) : String = {\n      \
    \  val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            val newStack = mutable.Stack[String]()\n\
    \            val newResult = mutable.ListBuffer.empty[String]\n            val\
    \ open = s.charAt(0)\n            val close = s.charAt(s.length - 1)\n       \
    \     val openCount = if (open == '(') 1 else 0\n            val closeCount =\
    \ if (close == ')') 1 else 0\n            val newOpenCount = openCount + 1\n \
    \           val newCloseCount = closeCount + 1\n            val newOpen = if (open\
    \ == '(') '(' else ')'\n            val newClose = if (close == ')') ')')' else\
    \ '('\n            val newStackPush = stack push newOpen\n            val newStackPop\
    \ = stack pop\n            val newResultPush = newResult push newOpen\n      \
    \      val newResultPop = newResult pop\n            val newStack = newStackPush\
    \ ++ newStackPop\n            val newResult = newResultPush ++ newResultPop\n\
    \            while (newStack.length > 0) {\n                val newChar = newStack.head\n\
    \                val newCount = newStack.length\n                if (newChar ==\
    \ newClose) {\n                    newStack = newStack.tail\n                \
    \    newResult = newResultPush ++ newResultPop\n                    newStackPush\
    \ = newStack.head :: newStack\n                    newResultPush = newResult push\
    \ newClose\n                    newResultPop = newResult pop\n               \
    \     newStack = newStackPush ++ newStackPop\n                    newResult =\
    \ newResultPush ++ newResultPop\n                }\n                else if (newChar\
    \ == newOpen) {\n                    newStack = newStack.tail\n              \
    \      newResult = newResultPush ++ newResultPop\n                    newStackPush\
    \ = newStack.head :: newStack\n                    newResultPush = newResult push\
    \ newOpen\n                    newResultPop = newResult pop\n                \
    \    newStack = newStackPush ++ newStackPop\n                    newResult = newResultPush\
    \ ++ newResultPop\n                }\n                else if (newChar == '(')\
    \ {\n                    newStackPush = newStack.head :: newStack\n          \
    \          newResultPush = newResult push newOpen\n                    newResultPop\
    \ = newResult pop\n                    newStack = newStackPush ++ newStackPop\n\
    \                    newResult = newResultPush ++ newResultPop\n             \
    \   }\n                else if (newChar == ')') {\n                    newStackPush\
    \ = newStack.head :: newStack\n                    newResultPush = newResult push\
    \ newClose\n                    newResultPop = newResult pop\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpieius2i4.scala:28:48 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mnewClose\e[0m = \e[33mif\e\
    [0m (close == \e[31m')'\e[0m) \e[31m')'\e[0m)' \e[33melse\e[0m \e[31m'('\e[0m\n\
    \e[31m\e[31m   |\e[0m                                                ^\e[0m\n\e\
    [31m   |\e[0m                                             '}' expected, but ')'\
    \ found\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpieius2i4.scala:30:39 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36mnewStackPop\e[0m = stack\
    \ pop\n\e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e\
    [31m   |\e[0m                          expression expected but \e[31mend of statement\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpieius2i4.scala:32:44\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mnewResultPop\e[0m = newResult pop\n\e[31m\e[31m   |\e[0m           \
    \                                 ^\e[0m\n\e[31m   |\e[0m                    \
    \      expression expected but \e[31mend of statement\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- Error: /tmp/tmpieius2i4.scala:44:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                    newStack = newStackPush ++ newStackPop\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         end of statement expected but '=' found\n\e[31m\e[31m--\
    \ Error: /tmp/tmpieius2i4.scala:53:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m                    newStack = newStackPush ++ newStackPop\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         end of statement expected but '=' found\n\e[31m\e[31m--\
    \ Error: /tmp/tmpieius2i4.scala:60:29 -----------------------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m                    newStack = newStackPush ++ newStackPop\n\
    \e[31m\e[31m   |\e[0m            "
  stdout: ''
  timestamp: 1659795310
