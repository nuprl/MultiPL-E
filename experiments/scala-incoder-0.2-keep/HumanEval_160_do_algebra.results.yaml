language: scala
name: HumanEval_160_do_algebra
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val opLen =\
    \ opList.length\n        val operandList = operand.map(_.toLong)\n        val\
    \ operandLen = operandList.length\n        val result = operandList.foldLeft(operandList.head)\
    \ {\n            (acc, x) => acc match {\n                case Some(operator)\
    \ => operator(acc, x)\n                case None => x\n            }\n       \
    \ }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E050] Type Error: /tmp/tmpl3x4h0fp.scala:29:39 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                \e[33mcase\e[0m Some(operator) => operator(acc,\
    \ x)\n\e[31m\e[31m   |\e[0m                                       ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                 \e[33mvalue\e[0m \e[35moperator\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpl3x4h0fp.scala:30:21 --------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m                \e[33mcase\e[0m None => x\n\e[31m\e[31m   |\e[0m     \
    \                ^^^^\e[0m\n\e[31m   |\e[0m                     Found:    None.type\n\
    \e[31m   |\e[0m                     Required: Long\n\e[31m   |\e[0m          \
    \           pattern type is incompatible with expected type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659792962
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toLong).toList\n        val opLength = opList.size\n       \
    \ val operandLength = operandList.size\n        val opIndex = opList.indexOf(\"\
    +\")\n        val opLength = opList.size\n        val operandIndex = operandList.indexOf(0)\n\
    \        val operandLength = operandList.size\n        val operand1 = operandList.take(operandIndex).toList\n\
    \        val operand2 = operandList.drop(operandIndex).toList\n        val op1\
    \ = opList.take(opIndex).toList\n        val op2 = opList.drop(opIndex).toList\n\
    \        val op1Length = op1.size\n        val op2Length = op2.size\n        val\
    \ op1Index = op1.indexOf(\"*\")\n        val op2Index = op2.indexOf(\"*\")\n \
    \       val op1Length = op1.size\n        val op2Length = op2.size\n        val\
    \ op1Index = op1.indexOf(\"/\")\n        val op2Index = op2.indexOf(\"/\")\n \
    \       val op1Length = op1.size\n        val op2Length = op2.size\n        val\
    \ op1Index = op1.indexOf(\"**\")\n        val op2Index = op2.indexOf(\"**\")\n\
    \        val op1Length = op1.size\n        val op2Length = op2.size\n        val\
    \ op1Index = op1.indexOf(\"+\")\n        val op2Index = op2.indexOf(\"+\")\n \
    \       val op1Length = op1.size\n        val op2Length = op2.size\n        val\
    \ op1Index = op1.indexOf(\"-\")\n        val op2Index = op2.indexOf(\"-\")\n \
    \       val op1Length = op1.size\n        val op2Length = op2.size\n        val\
    \ op1Index = op1.indexOf(\"*\")\n        val op2Index = op2.indexOf(\"*\")\n \
    \       val op1Length = op1.size\n        val op2Length = op2.size\n        val\
    \ op1Index = op1.indexOf(\"//\")\n        val op2Index = op2.indexOf(\"//\")\n\
    \        val op1Length = op1.size\n        val op2Length = op2.size\n        val\
    \ op1Index = op1.indexOf(\"**\")\n        val op2Index = op2.indexOf(\"**\")\n\
    \        val op1Length = op1.size\n        val op2Length = op2.size\n        val\
    \ op1Index = op1.indexOf(\"+\")\n        val op2Index = op2.indexOf(\"+\")\n \
    \       val op1Length = op1.size\n        val op2Length = op2.size\n        val\
    \ op\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa2qatblm.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa2qatblm.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLength\e[0m = opList.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopLength is already defined as \e[33mvalue\e[0m \e[35mopLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa2qatblm.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36moperandLength\e[0m = operandList.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0moperandLength is already defined as \e[33mvalue\e[0m \e[35moperandLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa2qatblm.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mop1Length\e[0m = op1.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mop1Length is\
    \ already defined as \e[33mvalue\e[0m \e[35mop1Length\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa2qatblm.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mop2Length\e[0m = op2.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mop2Length is already defined as \e[33mvalue\e[0m \e[35mop2Length\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa2qatblm.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36mop1Index\e[0m = op1.indexO"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opMap = ops.zip(operand).map(x\
    \ => (x._1, x._2)).toMap\n        val opList = ops.toList\n        val operandList\
    \ = operand.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opMap.toMap\n        val operandList\
    \ = operandList.toList\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpj9rkcv1n.scala:77:11 ---------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpj9rkcv1n.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = opMap.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopMap\
    \ is already defined as \e[33mvalue\e[0m \e[35mopMap\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj9rkcv1n.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandList\e[0m = operandList.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj9rkcv1n.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mopLen\e[0m = opList.length\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopLen is already\
    \ defined as \e[33mvalue\e[0m \e[35mopLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj9rkcv1n.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandLen\e[0m = operandList.length - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0moperandLen\
    \ is already defined as \e[33mvalue\e[0m \e[35moperandLen\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tm"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val operatorList = opList.filter(_.isDigit)\n\
    \        val operandListSize = operandList.size\n        val operatorListSize\
    \ = operatorList.size\n        val operatorListSize = operatorListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \       val operandListSize = operandListSize - 1\n        val operandListSize\
    \ = operandListSize - 1\n        val operandListSize = operandListSize - 1\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbnh0pmnh.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36moperatorListSize\e[0m =\
    \ operatorListSize - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperatorListSize is already defined as \e[33mvalue\e[0m \e\
    [35moperatorListSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbnh0pmnh.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36moperandListSize\e[0m = operandListSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandListSize is already defined as \e[33mvalue\e[0m \e\
    [35moperandListSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbnh0pmnh.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36moperandListSize\e[0m = operandListSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandListSize is already defined as \e[33mvalue\e[0m \e\
    [35moperandListSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbnh0pmnh.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36moperandListSize\e[0m = operandListSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandListSize is already defined as \e[33mvalue\e[0m \e\
    [35moperandListSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbnh0pmnh.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36moperandListSize\e[0m = op"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.mkString(\"+\")\n        val opListLength\
    \ = opList.length\n        val operandList = operand.mkString(\"+\")\n       \
    \ val operandListLength = operandList.length\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmph2kc89wj.scala:74:31 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph2kc89wj.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopListLength\e[0m = opListLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopListLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mopListLength\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph2kc89wj.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandListLength\e[0m = operandListLength - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0moperandListLength is already defined as \e[33mvalue\e[0m \e[35moperandListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph2kc89wj.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mopListLength\e[0m = opListLength - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopListLength is already defined as \e[33mvalue\e[0m \e[35mopListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph2kc89wj.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m = operandListLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toLowerCase)\n        val operands\
    \ = operand.map(x => x.toLong)\n        val opMap = ops.zip(operands).toMap\n\
    \        val opList = ops.toList\n        val opListSize = opList.size\n     \
    \   val opListSize = opListSize - 1\n        val opListSize = opListSize - 1\n\
    \        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ - 1\n        val opListSize = opListSize - 1\n        val opListSize = opListSize\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp93ltsvbc.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mopListSize\e[0m = opListSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopListSize is already defined as \e[33mvalue\e[0m \e[35mopListSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp93ltsvbc.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mopListSize\e[0m = opListSize - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mopListSize is already defined as \e[33mvalue\e[0m \e[35mopListSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp93ltsvbc.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mopListSize\e[0m = opListSize - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mopListSize is already defined as \e[33mvalue\e[0m \e[35mopListSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp93ltsvbc.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mopListSize\e[0m = opListSize - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mopListSize is already defined as \e[33mvalue\e[0m \e[35mopListSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp93ltsvbc.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mopListSize\e[0m = opListSize - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mopListSize is already defined as \e"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val resultArray = new Array[Long](length)\n        var i = 0\n      \
    \  while (i < length) {\n            val op = opArray(i)\n            val operand\
    \ = operandArray(i)\n            val result = if (op == \"+\") {\n           \
    \     operandArray(i) + operandArray(i + 1)\n            } else if (op == \"-\"\
    ) {\n                operandArray(i) - operandArray(i + 1)\n            } else\
    \ if (op == \"*\") {\n                operandArray(i) * operandArray(i + 1)\n\
    \            } else if (op == \"/\") {\n                operandArray(i) / operandArray(i\
    \ + 1)\n            } else if (op == \"//\") {\n                operandArray(i)\
    \ // operandArray(i + 1)\n            } else if (op == \"**\") {\n           \
    \     operandArray(i) ** operandArray(i + 1)\n            } else {\n         \
    \       throw new Exception(\"Invalid operator\")\n            }\n           \
    \ resultArray(i) = result\n            i += 1\n        }\n        resultArray(0)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjd4n86ru.scala:43:32 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                operandArray(i) ** operandArray(i + \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                value ** is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opList = ops.toList\n\
    \        val opLen = opList.length\n        val operands = operand.map(_.toLong)\n\
    \        val operandLen = operands.toList.length\n        val opLenMinusOne =\
    \ opLen - 1\n        val operandLenMinusOne = operandLen - 1\n        val opLenMinusOneMinusOne\
    \ = opLen - 1 - 1\n        val operandLenMinusOneMinusOne = operandLen - 1 - 1\n\
    \        val opLenMinusOneMinusOneMinusOne = opLen - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n      \
    \  val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = operandLen\
    \ - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val\
    \ opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = opLen - 1 -\
    \ 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n    \
    \    val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne =\
    \ operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 -\
    \ 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd0razddd.scala:42:151 --------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = opLen - \e[31m1\e[0m - \e[31m1\e[0m - \e[31m1\e[0m - \e[31m1\e[0m - \e[31m1\e\
    [0m - \e[31m1\e[0m - \e[31m1\e[0m - \e[31m1\e[0m - \e[31m1\e[0m - \e[31m1\e[0m\
    \ - \e[31m1\e[0m - \e[31m1\e[0m - \e[31m1\e[0m - \n\e[31m\e[31m   |\e[0m     \
    \                                                                            \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd0razddd.scala:43:5\
    \ ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.mkString(\"+\")\n        val opList = ops.split(\"\
    \\\\+\").map(_.toLong)\n        val operands = operand.map(_.toLong)\n       \
    \ val opLen = opList.size\n        val operandLen = operands.size - 1\n      \
    \  val opLen = opList.size\n        val operandLen = operands.size - 1\n     \
    \   val opLen = opList.size\n        val operandLen = operands.size - 1\n    \
    \    val opLen = opList.size\n        val operandLen = operands.size - 1\n   \
    \     val opLen = opList.size\n        val operandLen = operands.size - 1\n  \
    \      val opLen = opList.size\n        val operandLen = operands.size - 1\n \
    \       val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        val opLen = opList.size\n        val operandLen = operands.size - 1\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphqma3fla.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mopLen\e[0m = opList.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopLen\
    \ is already defined as \e[33mvalue\e[0m \e[35mopLen\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphqma3fla.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandLen\e[0m = operands.size - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0moperandLen is\
    \ already defined as \e[33mvalue\e[0m \e[35moperandLen\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphqma3fla.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLen\e[0m = opList.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopLen is already defined as \e[33mvalue\e[0m \e[35mopLen\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphqma3fla.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36moperandLen\e[0m = operands.size - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandLen is already defined as \e[33mvalue\e[0m \e[35moperandLen\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphqma3fla.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mopLen\e[0m = opList.size\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopLen is already\
    \ defined as \e[33mvalue\e[0m \e[35mopLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods mus"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toInt).toList\n        val opLen = opList.size\n        val\
    \ operandLen = operandList.size\n        val opMap = new mutable.HashMap[String,\
    \ Int]()\n        val operandMap = new mutable.HashMap[String, Int]()\n      \
    \  val opMapKeys = opList.map(x => x.toLowerCase)\n        val operandMapKeys\
    \ = operandList.map(x => x.toString.toInt)\n        val opMapValues = opList.map(x\
    \ => opMap.getOrElse(x, 0))\n        val operandMapValues = operandList.map(x\
    \ => operandMap.getOrElse(x, 0))\n        val opMapKeysLen = opMapKeys.size\n\
    \        val operandMapKeysLen = operandMapKeys.size\n        val opMapValueLen\
    \ = opMapValues.size\n        val operandMapValueLen = operandMapValues.size\n\
    \        val opMapKeysSet = opMapKeys.toSet\n        val operandMapKeysSet = operandMapKeys.toSet\n\
    \        val opMapValueSet = opMapValues.toSet\n        val operandMapValueSet\
    \ = operandMapValues.toSet\n        val opMapKeysSetLen = opMapKeysSet.size\n\
    \        val operandMapKeysSetLen = operandMapKeysSet.size\n        val opMapValueSetLen\
    \ = opMapValueSet.size\n        val operandMapValueSetLen = operandMapValueSet.size\n\
    \        val opMapKeysSetIntersection = opMapKeysSet.intersect(operandMapKeysSet)\n\
    \        val operandMapKeysSetIntersection = operandMapKeysSet.intersect(opMapKeysSet)\n\
    \        val opMapValueSetIntersection = opMapValueSet.intersect(operandMapValueSet)\n\
    \        val operandMapValueSetIntersection = operandMapValueSet.intersect(opMapValueSet)\n\
    \        val opMapKeysSetDifference = opMapKeysSet.diff(operandMapKeysSet)\n \
    \       val operandMapKeysSetDifference = operandMapKeysSet.diff(opMapKeysSet)\n\
    \        val opMapValueSetDifference = opMapValueSet.diff(operandMapValueSet)\n\
    \        val operandMapValueSetDifference = operandMapValueSet.diff(opMapValueSet)\n\
    \        val opMapKeysSetSymmetricDifference = opMapKeysSet.diff(operandMapKeysSet)\n\
    \        val operandMapKey\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps4ir3tmi.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps4ir3tmi.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmps4ir3tmi.scala:28:29 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36moperandMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmps4ir3tmi.scala:45:62 --------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m        \e[33mval\e[0m \e[36mopMapKeysSetIntersection\e[0m = opMapKeysSet.intersect(operandMapKeysSet)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \ Found:    (operandMapKeysSet : Set[Int])\n\e[31m   |\e[0m                  \
    \              Required: scala.collection.Set[String]\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmps4ir3tmi.scala:46:72 --------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36moperandMapKeysSetIntersection\e\
    [0m = operandMapKeysSet.intersect(opMapKeysSet)\n\e[31m\e[31m   |\e[0m       \
    \                                                                 ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Found:    (opMapKeysSet\
    \ : Set[String])\n\e[31m   |\e[0m                             "
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val operands\
    \ = operand.map(_.toLong).toList\n        val length = operands.length - 1\n \
    \       val operators = ops.map(_.toLowerCase).toList\n        val operatorLength\
    \ = operators.length\n        val result = operands.foldLeft(0L) {\n         \
    \   (acc, elem) => acc match {\n                case 0 => elem\n             \
    \   case acc if acc < 0 => 0L\n                case acc if acc >= operatorLength\
    \ => 0L\n                case acc if operators(acc) == operators(0) => acc + operands(length)\n\
    \                case acc if operators(acc) == operators(operatorLength - 1) =>\
    \ acc + operands(length - 1)\n                case acc if operators(acc) == operators(operatorLength\
    \ - 2) => acc + operands(length - 2)\n                case acc if operators(acc)\
    \ == operators(operatorLength - 3) => acc + operands(length - 3)\n           \
    \     case acc if operators(acc) == operators(operatorLength - 4) => acc + operands(length\
    \ - 4)\n                case acc if operators(acc) == operators(operatorLength\
    \ - 5) => acc + operands(length - 5)\n                case acc if operators(acc)\
    \ == operators(operatorLength - 6) => acc + operands(length - 6)\n           \
    \     case acc if operators(acc) == operators(operatorLength - 7) => acc + operands(length\
    \ - 7)\n                case acc if operators(acc) == operators(operatorLength\
    \ - 8) => acc + operands(length - 8)\n                case acc if operators(acc)\
    \ == operators(operatorLength - 9) => acc + operands(length - 9)\n           \
    \     case acc if operators(acc) == operators(operatorLength - 10) => acc + operands(length\
    \ - 10)\n                case acc if operators(acc) == operators(operatorLength\
    \ - 11) => acc + operands(length - 11)\n                case acc if operators(acc)\
    \ == operators(operatorLength - 12) => acc + operands(length - 12)\n         \
    \       case acc if operators(acc) == operators(operatorLength - 13) => acc +\
    \ operands(length - 13)\n                case acc if operators(acc) == operators(operatorLength\
    \ - 14) => acc + operands(length - 14)\n                case acc if operators(acc)\
    \ == operators(operatorLength - 15) => acc + operands(length - 15)\n         \
    \       case acc if operators(acc) == operators(operatorLength - 16) => acc +\
    \ operands(length - 16)\n                case acc if operators(acc) == operators(operatorLength\
    \ - 17) => acc + operands(length - 17)\n                case acc if operators(acc)\
    \ == operators(operatorLength - 18) => acc + operands(length - 18)\n         \
    \       case acc if operators(acc) == operators(operatorLength - 19) => acc +\
    \ operands(length - 19\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuev3grz8.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuev3grz8.scala:61:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m61 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpuev3grz8.scala:33:38 --------------------\e[0m\e[0m\n\
    \e[31m33 |\e[0m                \e[33mcase\e[0m acc \e[33mif\e[0m operators(acc)\
    \ == operators(\e[31m0\e[0m) => acc + operands(length)\n\e[31m\e[31m   |\e[0m\
    \                                      ^^^\e[0m\n\e[31m   |\e[0m             \
    \                         Found:    (acc : Long)\n\e[31m   |\e[0m            \
    \                          Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpuev3grz8.scala:34:38 --------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m                \e[33mcase\e[0m acc \e[33mif\e[0m operators(acc)\
    \ == operators(operatorLength - \e[31m1\e[0m) => acc + operands(length - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                      ^^^\e[0m\n\e\
    [31m   |\e[0m                                      Found:    (acc : Long)\n\e\
    [31m   |\e[0m                                      Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuev3grz8.scala:35:38 --------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                \e[33mcase\e[0m acc \e[33mif\e[0m operators(acc)\
    \ == operators(operatorLength - \e[31m2\e[0m) => acc + operands(length - \e[31m2\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                      ^^^\e[0m\n\e\
    [31m   |\e[0m                                      Found:    (acc : Long)\n\e\
    [31m   |\e[0m                                      Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuev3grz8.scala:36:38 ----"
  stdout: ''
  timestamp: 1659792964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val operandLength = operandArray.length\n        val result = operandArray(0)\n\
    \        val operator = opArray(0)\n        val operand1 = operandArray(1)\n \
    \       val operand2 = operandArray(2)\n        val operand3 = operandArray(3)\n\
    \        val operand4 = operandArray(4)\n        val operand5 = operandArray(5)\n\
    \        val operand6 = operandArray(6)\n        val operand7 = operandArray(7)\n\
    \        val operand8 = operandArray(8)\n        val operand9 = operandArray(9)\n\
    \        val operand10 = operandArray(10)\n        val operand11 = operandArray(11)\n\
    \        val operand12 = operandArray(12)\n        val operand13 = operandArray(13)\n\
    \        val operand14 = operandArray(14)\n        val operand15 = operandArray(15)\n\
    \        val operand16 = operandArray(16)\n        val operand17 = operandArray(17)\n\
    \        val operand18 = operandArray(18)\n        val operand19 = operandArray(19)\n\
    \        val operand20 = operandArray(20)\n        val operand21 = operandArray(21)\n\
    \        val operand22 = operandArray(22)\n        val operand23 = operandArray(23)\n\
    \        val operand24 = operandArray(24)\n        val operand25 = operandArray(25)\n\
    \        val operand26 = operandArray(26)\n        val operand27 = operandArray(27)\n\
    \        val operand28 = operandArray(28)\n        val operand29 = operandArray(29)\n\
    \        val operand30 = operandArray(30)\n        val operand31 = operandArray(31)\n\
    \        val operand32 = operandArray(32)\n        val operand33 = operandArray(33)\n\
    \        val operand34 = operandArray(34)\n        val operand35 = operandArray(35)\n\
    \        val operand36 = operandArray(36)\n        val operand37 = operandArray(37)\n\
    \        val operand38 = operandArray(38)\n        val operand39 = operandArray(39)\n\
    \        val operand40 = operandArray(40)\n        val operand41 = operandArray(41)\n\
    \        val operand42 = operandArray(42)\n        val operand43 = operandArray(43)\n\
    \        val operand44 = operandArray(44)\n        val operand45 = operandArray(45)\n\
    \        val operand46 = operandArray(46)\n        val operand47 = operandArray(47)\n\
    \        val operand48 = operandArray(48)\n        val operand49 = operandArray(49)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp6xxqglse.scala:79:11 ---------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6xxqglse.scala:80:5 ---------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.size\n        val operandLen\
    \ = operandList.size\n        val opArray = Array.ofDim[String](opLen)\n     \
    \   val operandArray = Array.ofDim[Long](operandLen)\n        var i = 0\n    \
    \    while (i < opLen) {\n            opArray(i) = opList(i)\n            i +=\
    \ 1\n        }\n        var j = 0\n        while (j < operandLen) {\n        \
    \    operandArray(j) = operandList(j)\n            j += 1\n        }\n       \
    \ val opArrayLen = opArray.length\n        val operandArrayLen = operandArray.length\n\
    \        val opArrayLenMinusOne = opArrayLen - 1\n        val operandArrayLenMinusOne\
    \ = operandArrayLen - 1\n        val opArrayLenMinusOnePlusOne = opArrayLen +\
    \ 1\n        val operandArrayLenMinusOnePlusOne = operandArrayLen + 1\n      \
    \  val opArrayLenMinusOnePlusOnePlusOne = opArrayLen + 2\n        val operandArrayLenMinusOnePlusOnePlusOne\
    \ = operandArrayLen + 2\n        val opArrayLenMinusOnePlusOnePlusOnePlusOne =\
    \ opArrayLen + 3\n        val operandArrayLenMinusOnePlusOnePlusOnePlusOne = operandArrayLen\
    \ + 3\n        val opArrayLenMinusOnePlusOnePlusOnePlusOnePlusOne = opArrayLen\
    \ + 4\n        val operandArrayLenMinusOnePlusOnePlusOnePlusOnePlusOne = operandArrayLen\
    \ + 4\n        val opArrayLenMinusOnePlusOnePlusOnePlusOnePlusOnePlusOne = opArrayLen\
    \ + 5\n        val operandArrayLenMinusOnePlusOnePlusOnePlusOnePlusOnePlusOne\
    \ = operandArrayLen + 5\n        val opArrayLenMinusOnePlusOnePlusOnePlusOnePlusOnePlusOnePlusOne\
    \ = opArrayLen + 6\n        val operandArrayLenMinusOnePlusOnePlusOnePlusOnePlusOnePlusOnePlusOne\
    \ = operandArrayLen + 6\n        val opArrayLenMinusOnePlusOnePlusOnePlusOnePlusOnePlusOnePlusOnePlusOne\
    \ = opArrayLen + 7\n        val operandArrayLenMinusOnePlusOnePlusOnePlusOnePlusOnePlusOnePlusOnePlusOne\
    \ = operandArrayLen + 7\n        val opArrayLenMinusOnePlusOnePlusOnePlusOnePlusOnePlusOnePlusOnePlusOnePlusOne\
    \ = op\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppojipyoj.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opList = ops.toList\n\
    \        val opLen = opList.size\n        val opLenMinusOne = opLen - 1\n    \
    \    val operands = operand.toList\n        val operandLen = operands.size\n \
    \       val operandLenMinusOne = operandLen - 1\n        val operandsLenMinusOne\
    \ = operandLen - 1\n        val operandsLen = operandsLenMinusOne + 1\n      \
    \  val operandsLenMinusOne = operandsLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val operandsLenMinusOne = operandsLen - 1\n     \
    \   val operandsLenMinusOne = operandsLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val operandsLenMinusOne = operandsLen - 1\n     \
    \   val operandsLenMinusOne = operandsLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val operandsLenMinusOne = operandsLen - 1\n     \
    \   val operandsLenMinusOne = operandsLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val operandsLenMinusOne = operandsLen - 1\n     \
    \   val operandsLenMinusOne = operandsLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val operandsLenMinusOne = operandsLen - 1\n     \
    \   val operandsLenMinusOne = operandsLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val operandsLenMinusOne = operandsLen - 1\n     \
    \   val operandsLenMinusOne = operandsLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val operandsLenMinusOne = operandsLen - 1\n     \
    \   val operandsLenMinusOne = operandsLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val operandsLenMinusOne = operandsLen - 1\n     \
    \   val operandsLenMinusOne = operandsLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val operandsLenMinusOne = operandsLen - 1\n     \
    \   val operandsLenMinusOne = operandsLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val operandsLenMinusOne = operands\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6gg0ijuo.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36moperandsLenMinusOne\e[0m\
    \ = operandsLen - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandsLenMinusOne is already defined as \e[33mvalue\e[0m\
    \ \e[35moperandsLenMinusOne\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6gg0ijuo.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36moperandsLenMinusOne\e[0m\
    \ = operandsLen - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandsLenMinusOne is already defined as \e[33mvalue\e[0m\
    \ \e[35moperandsLenMinusOne\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6gg0ijuo.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36moperandsLenMinusOne\e[0m\
    \ = operandsLen - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandsLenMinusOne is already defined as \e[33mvalue\e[0m\
    \ \e[35moperandsLenMinusOne\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6gg0ijuo.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36moperandsLenMinusOne\e[0m\
    \ = operandsLen - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandsLenMinusOne is already defined as \e[33mvalue\e[0m\
    \ \e[35moperandsLenMinusOne\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6gg0ijuo.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[3"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opLen = ops.length\n\
    \        val operands = operand.map(_.toLong)\n        val operandLen = operands.length\n\
    \        val opMap = ops.zip(operands).toMap\n        val opMapLen = opMap.length\n\
    \        val opMapKeys = opMap.keys\n        val opMapValues = opMap.values.toList\n\
    \        val opMapKeysLen = opMapKeys.length\n        val opMapValuesLen = opMapValues.length\n\
    \        val opMapKeysMin = opMapKeys.min\n        val opMapValuesMin = opMapValues.min\n\
    \        val opMapKeysMax = opMapKeys.max\n        val opMapValuesMax = opMapValues.max\n\
    \        val opMapKeysSum = opMapKeys.sum\n        val opMapValuesSum = opMapValues.sum\n\
    \        val opMapKeysProduct = opMapKeys.product\n        val opMapValuesProduct\
    \ = opMapValues.product\n        val opMapKeysProductMin = opMapKeys.productMin\n\
    \        val opMapValuesProductMin = opMapValues.productMin\n        val opMapKeysProductMax\
    \ = opMapKeys.productMax\n        val opMapValuesProductMax = opMapValues.productMax\n\
    \        val opMapKeysProductSum = opMapKeys.productSum\n        val opMapValuesProductSum\
    \ = opMapValues.productSum\n        val opMapKeysProductProduct = opMapKeys.productProduct\n\
    \        val opMapValuesProductProduct = opMapValues.productProduct\n        val\
    \ opMapKeysProductProductMin = opMapKeys.productProductMin\n        val opMapValuesProductProductMin\
    \ = opMapValues.productProductMin\n        val opMapKeysProductProductMax = opMapKeys.productProductMax\n\
    \        val opMapValuesProductProductMax = opMapValues.productProductMax\n  \
    \      val opMapKeysProductProductSum = opMapKeys.productProductSum\n        val\
    \ opMapValuesProductProductSum = opMapValues.productProductSum\n        val opMapKeysProductProductProduct\
    \ = opMapKeys.productProductProduct\n        val opMapValuesProductProductProduct\
    \ = opMapValues.productProductProduct\n        val opMapKeysProductProductProductMin\
    \ = opMapKeys.productProductProductMin\n        val opMapValuesProductProductProductMin\
    \ = opMapValues.productProductProductMin\n        val opMapKeysProduct\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmputcixuwb.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmputcixuwb.scala:28:29\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mopMapLen\e[0m = opMap.length\n\e[31m\e[31m   |\e[0m                      \
    \ ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value length is not\
    \ a member of Map[String, Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmputcixuwb.scala:31:37\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mopMapKeysLen\e[0m = opMapKeys.length\n\e[31m\e[31m   |\e[0m              \
    \             ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        value\
    \ length is not a member of Iterable[String]\n\e[31m\e[31m-- Error: /tmp/tmputcixuwb.scala:37:40\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m37 |\e[0m       \
    \ \e[33mval\e[0m \e[36mopMapKeysSum\e[0m = opMapKeys.sum\n\e[31m\e[31m   |\e[0m\
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \   No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m     \
    \           where:    B is a type variable with constraint >: String\n\e[31m \
    \  |\e[0m                .\n\e[31m\e[31m-- Error: /tmp/tmputcixuwb.scala:39:48\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m39 |\e[0m       \
    \ \e[33mval\e[0m \e[36mopMapKeysProduct\e[0m = opMapKeys.product\n\e[31m\e[31m\
    \   |\e[0m                                                ^\e[0m\n\e[31m   |\e\
    [0m                No implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m                where:    B is a type variable with constraint >: String\n\
    \e[31m   |\e[0m                .\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmputcixuwb.scala:41:44\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e\
    [36mopMapKeysProductMin\e[0m = opMapKeys.productMin\n\e[31m\e[31m   |\e[0m   \
    \                               ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ productMin is not a member of Iterable[String] - did you mean op"
  stdout: ''
  timestamp: 1659792964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operands.size - 1\n        val operandLenMinusOne\
    \ = operandLen - 1\n        val opIndex = 0\n        val operandIndex = 0\n  \
    \      val result = operands(operandIndex) * operands(operandIndex + 1)\n    \
    \    while(opIndex < opLenMinusOne) {\n            val op = ops(opIndex)\n   \
    \         val operand = operands(operandIndex)\n            val operandNext =\
    \ operands(operandIndex + 1)\n            val operandNextNext = operands(operandIndex\
    \ + 2)\n            val operandNextNextNext = operands(operandIndex + 3)\n   \
    \         val operandNextNextNextNext = operands(operandIndex + 4)\n         \
    \   val operandNextNextNextNextNext = operands(operandIndex + 5)\n           \
    \ val operandNextNextNextNextNextNext = operands(operandIndex + 6)\n         \
    \   val operandNextNextNextNextNextNextNext = operands(operandIndex + 7)\n   \
    \         val operandNextNextNextNextNextNextNextNext = operands(operandIndex\
    \ + 8)\n            val operandNextNextNextNextNextNextNextNextNext = operands(operandIndex\
    \ + 9)\n            val operandNextNextNextNextNextNextNextNextNextNext = operands(operandIndex\
    \ + 10)\n            val operandNextNextNextNextNextNextNextNextNextNext = operands(operandIndex\
    \ + 11)\n            val operandNextNextNextNextNextNextNextNextNextNext = operands(operandIndex\
    \ + 12)\n            val operandNextNextNextNextNextNextNextNextNextNext = operands(operandIndex\
    \ + 13)\n            val operandNextNextNextNextNextNextNextNextNextNextNext =\
    \ operands(operandIndex + 14)\n            val operandNextNextNextNextNextNextNextNextNextNextNext\
    \ = operands(operandIndex + 15)\n            val operandNextNextNextNextNextNextNextNextNextNextNext\
    \ = operands(operandIndex + 16)\n            val operandNextNextNextNextNextNextNextNextNextNextNext\
    \ = operands(operandIndex + 17)\n            val operandNextNextNextNextNextNextNextNextNextNextNext\
    \ = operands(operandIndex + 18)\n            val operandNextNextNextNextNextNextNextNextNextNextNextNext\
    \ = operands(operandIndex + 19)\n            val operandNextNextNextNextNextNextNextNextNextNextNextNext\
    \ = operands(operandIndex + 20)\n            val operandNextNextNextNextNextNext\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6whjjomf.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6whjjomf.scala:64:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6whjjomf.scala:45:16 ---------------------------\e[0m\e[0m\n\e\
    [31m45 |\e[0m            \e[33mval\e[0m \e[36moperandNextNextNextNextNextNextNextNextNextNext\e\
    [0m = operands(operandIndex + \e[31m11\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandNextNextNextNextNextNextNextNextNextNext is already\
    \ defined as \e[33mvalue\e[0m \e[35moperandNextNextNextNextNextNextNextNextNextNext\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6whjjomf.scala:46:16 ---------------------------\e[0m\e[0m\n\e\
    [31m46 |\e[0m            \e[33mval\e[0m \e[36moperandNextNextNextNextNextNextNextNextNextNext\e\
    [0m = operands(operandIndex + \e[31m12\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandNextNextNextNextNextNextNextNextNextNext is already\
    \ defined as \e[33mvalue\e[0m \e[35moperandNextNextNextNextNextNextNextNextNextNext\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6whjjomf.scala:47:16 ---------------------------\e[0m\e[0m\n\e\
    [31m47 |\e[0m            \e[33mval\e[0m \e[36moperandNextNextNextNextNextNextNextNextNextNext\e\
    [0m = operands(operandIndex + \e[31m13\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandNextNextNextNextNextNextNextNextNextNext is already\
    \ defined as \e[3"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.asInstanceOf[List[String]]\n        val\
    \ operandList = operand.asInstanceOf[List[Long]]\n        val opLength = opList.size\n\
    \        val operandLength = operandList.size\n        val result = operandList.foldLeft(0L)\
    \ {\n            (acc, x) => acc + (opList.indexOf(_) * x)\n        }\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpu0hcgvm3.scala:28:28 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            (\e[36macc\e[0m, \e[36mx\e[0m) => acc + (opList.indexOf(_)\
    \ * x)\n\e[31m\e[31m   |\e[0m                        ^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e[0m in \e\
    [33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\
    \e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e\
    [0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short):\
    \ Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0m (x: String): String\n\
    \e[31m   |\e[0mmatch arguments (<?> => <?>)\n1 error found\n"
  stdout: ''
  timestamp: 1659792962
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val operandLength = operandArray.length\n        val result = operandArray(0)\n\
    \        val op1 = opArray(0)\n        val op2 = opArray(1)\n        val op3 =\
    \ opArray(2)\n        val op4 = opArray(3)\n        val op5 = opArray(4)\n   \
    \     val op6 = opArray(5)\n        val op7 = opArray(6)\n        val op8 = opArray(7)\n\
    \        val op9 = opArray(8)\n        val op10 = opArray(9)\n        val op11\
    \ = opArray(10)\n        val op12 = opArray(11)\n        val op13 = opArray(12)\n\
    \        val op14 = opArray(13)\n        val op15 = opArray(14)\n        val op16\
    \ = opArray(15)\n        val op17 = opArray(16)\n        val op18 = opArray(17)\n\
    \        val op19 = opArray(18)\n        val op20 = opArray(19)\n        val op21\
    \ = opArray(20)\n        val op22 = opArray(21)\n        val op23 = opArray(22)\n\
    \        val op24 = opArray(23)\n        val op25 = opArray(24)\n        val op26\
    \ = opArray(25)\n        val op27 = opArray(26)\n        val op28 = opArray(27)\n\
    \        val op29 = opArray(28)\n        val op30 = opArray(29)\n        val op31\
    \ = opArray(30)\n        val op32 = opArray(31)\n        val op33 = opArray(32)\n\
    \        val op34 = opArray(33)\n        val op35 = opArray(34)\n        val op36\
    \ = opArray(35)\n        val op37 = opArray(36)\n        val op38 = opArray(37)\n\
    \        val op39 = opArray(38)\n        val op40 = opArray(39)\n        val op41\
    \ = opArray(40)\n        val op42 = opArray(41)\n        val op43 = opArray(42)\n\
    \        val op44 = opArray(43)\n        val op45 = opArray(44)\n        val op46\
    \ = opArray(45)\n        val op47 = opArray(46)\n        val op48 = opArray(47)\n\
    \        val op49 = opArray(48)\n        val op50 = opArray(49)\n        val \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9ui5_2he.scala:79:11 ---------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9ui5_2he.scala:80:5 ---------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val length = ops.length\n        val result =\
    \ operands.foldLeft(0)(_ + _)\n        ops.zip(operands).foreach {\n         \
    \   case (opStr, operand) =>\n                val opIndex = ops.indexOf(opStr)\n\
    \                val opVal = opIndex.toLong\n                val operandVal =\
    \ operand.toLong\n                val opValInt = opVal % 10\n                val\
    \ operandValInt = operandVal % 10\n                val opValString = ops.apply(opIndex)\n\
    \                val operandValString = operands.apply(operand)\n            \
    \    val opValInt = opValInt.toInt\n                val operandValInt = operandValInt.toInt\n\
    \                val opValString = opValString.toUpperCase\n                val\
    \ operandValString = operandValString.toUpperCase\n                val opValInt\
    \ = opValInt.toInt\n                val operandValInt = operandValInt.toInt\n\
    \                val opVal = opVal.toLong\n                val operandVal = operandVal.toLong\n\
    \                val opValInt = opVal % 10\n                val operandValInt\
    \ = operandVal % 10\n                val opValString = ops.apply(opIndex)\n  \
    \              val operandValString = operands.apply(operand)\n              \
    \  val opValInt = opValInt.toInt\n                val operandValInt = operandValInt.toInt\n\
    \                val opValString = opValString.toUpperCase\n                val\
    \ operandValString = operandValString.toUpperCase\n                val opValInt\
    \ = opValInt.toInt\n                val operandValInt = operandValInt.toInt\n\
    \                val opVal = opVal.toLong\n                val operandVal = operandVal.toLong\n\
    \                val opValInt = opVal % 10\n                val operandValInt\
    \ = operandVal % 10\n                val opValString = ops.apply(opIndex)\n  \
    \              val operandValString = operands.apply(operand)\n              \
    \  val opValInt = opValInt.toInt\n                val operandValInt = operandValInt.toInt\n\
    \                val opValString = opValString.toUpperCase\n                val\
    \ operandValString = operandValString.toUpperCase\n                val opValInt\
    \ = opValInt.toInt\n                val operandValInt = operandValInt.toInt\n\
    \                val opVal = opVal.toLong\n                val operandVal = operandVal.toLong\n\
    \                val opValInt = opVal % 10\n                val \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpja4wp_ym.scala:69:19 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m                \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m\
    \                   ^\e[0m\n\e[31m   |\e[0m                   pattern expected\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpja4wp_ym.scala:78:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m78 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpja4wp_ym.scala:26:42 --------------------\e[0m\e[0m\n\
    \e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = operands.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                    \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                                          Found:\
    \    Long\n\e[31m   |\e[0m                                          Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpja4wp_ym.scala:36:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                \e[33mval\e\
    [0m \e[36mopValInt\e[0m = opValInt.toInt\n\e[31m\e[31m   |\e[0m              \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopValInt is already defined\
    \ as \e[33mvalue\e[0m \e[35mopValInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpja4wp_ym.scala:37:20 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                \e[33mval\e[0m \e[36moperandValInt\e\
    [0m = operandValInt.toInt\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandValInt is already defined as \e[33mvalue\e[0m \e[35moperandValInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpja4wp_ym.scala:38:20 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m                \e[33mval\e[0m \e[36mopValStri"
  stdout: ''
  timestamp: 1659792964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toSet\n        val operands\
    \ = operand.map(_.toInt).toSet\n        val opList = List(\n            \"+\"\
    , \"-\", \"*\", \"//\", \"**\"\n        )\n        val opSet = opList.map(_.toLowerCase).toSet\n\
    \        val opSetSize = opSet.size + 1 // +1 for the last operator\n        val\
    \ opSetSize = opSetSize * opSetSize // O(n^2) \n        val opSetSize = opSetSize\
    \ * opSetSize // O(n^2) \n        val opSetSize = opSetSize * opSetSize // O(n^2)\
    \ \n        val opSetSize = opSetSize * opSetSize // O(n^2) \n        val opSetSize\
    \ = opSetSize * opSetSize // O(n^2) \n        val opSetSize = opSetSize * opSetSize\
    \ // O(n^2) \n        val opSetSize = opSetSize * opSetSize // O(n^2) \n     \
    \   val opSetSize = opSetSize * opSetSize // O(n^2) \n        val opSetSize =\
    \ opSetSize * opSetSize // O(n^2) \n        val opSetSize = opSetSize * opSetSize\
    \ // O(n^2) \n        val opSetSize = opSetSize * opSetSize // O(n^2) \n     \
    \   val opSetSize = opSetSize * opSetSize // O(n^2) \n        val opSetSize =\
    \ opSetSize * opSetSize // O(n^2) \n        val opSetSize = opSetSize * opSetSize\
    \ // O(n^2) \n        val opSetSize = opSetSize * opSetSize // O(n^2) \n     \
    \   val opSetSize = opSetSize * opSetSize // O(n^2) \n        val opSetSize =\
    \ opSetSize * opSetSize // O(n^2) \n        val opSetSize = opSetSize * opSetSize\
    \ // O(n^2) \n        val opSetSize = opSetSize * opSetSize // O(n^2) \n     \
    \   val opSetSize = opSetSize * opSetSize // O(n^2) \n        val opSetSize =\
    \ opSetSize * opSetSize // O(n^2) \n        val opSetSize = opSetSize * opSetSize\
    \ // O(n^2) \n        val opSetSize = opSetSize * opSetSize // O(n^2) \n     \
    \   val opSetSize = opSetSize * opSetSize // O(n^2) \n        val opSetSize =\
    \ opSetSize \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptazvgk1b.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mopSetSize\e[0m = opSetSize\
    \ * opSetSize \e[34m// O(n^2) \e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopSetSize is already defined as \e[33mvalue\e[0m \e[35mopSetSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptazvgk1b.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mopSetSize\e[0m = opSetSize * opSetSize\
    \ \e[34m// O(n^2) \e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopSetSize is already defined as \e[33mvalue\e[0m \e[35mopSetSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptazvgk1b.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mopSetSize\e[0m = opSetSize * opSetSize\
    \ \e[34m// O(n^2) \e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopSetSize is already defined as \e[33mvalue\e[0m \e[35mopSetSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptazvgk1b.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mopSetSize\e[0m = opSetSize * opSetSize\
    \ \e[34m// O(n^2) \e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopSetSize is already defined as \e[33mvalue\e[0m \e[35mopSetSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptazvgk1b.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mopSetSize\e[0m = opSetSize * opSetSize\
    \ \e[34m// O(n^2) \e[0m\n\e[31m\e[3"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toDouble)\n        val operands\
    \ = operand.map(x => x.toDouble)\n        val length = ops.length\n        val\
    \ result = operands.reduceLeft((x, y) => ops(length-1) * x + y)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpef_gqp5h.scala:27:8\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Double)\n\
    \e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val result = 0\n        val stack = mutable.Stack[Long]()\n        val\
    \ stackArray = stack.toArray\n        val stackLength = stackArray.length\n  \
    \      val operandStack = mutable.Stack[Long]()\n        val operandStackArray\
    \ = operandStack.toArray\n        val operandStackLength = operandStackArray.length\n\
    \        val operatorStack = mutable.Stack[String]()\n        val operatorStackArray\
    \ = operatorStack.toArray\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStackLength\
    \ = operatorStackArray.length\n        val operatorStackLength = operatorStackArray.length\n\
    \        val operatorStackLength = operatorStackArray.length\n        val operatorStack\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp057nqyge.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp057nqyge.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperatorStackLength\e[0m = operatorStackArray.length\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0moperatorStackLength is already defined as \e[33mvalue\e[0m \e[35moperatorStackLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp057nqyge.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36moperatorStackLength\e[0m = operatorStackArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperatorStackLength is already defined as \e[33mvalue\e[0m\
    \ \e[35moperatorStackLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp057nqyge.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36moperatorStackLength\e[0m\
    \ = operatorStackArray.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperatorStackLength is already defined as \e[33mvalue\e[0m\
    \ \e[35moperatorStackLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp057nqyge.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36moperatorStackLength\e[0m\
    \ = operatorStackArray.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperatorStackLength is already defined as \e[33mvalue\e[0m\
    \ \e[35moperatorStackLength\e[0m\n\e[31m   |\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toInt)\n        val opLen = opList.length\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operandList.length\n        val operandLenMinusOne\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMinusOneInv = opLen - 1\n        val operandLenMinusOneInv\
    \ = operandLen - 1\n        val opLenMin\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphk9l616q.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphk9l616q.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLenMinusOneInv\e[0m = opLen - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopLenMinusOneInv\
    \ is already defined as \e[33mvalue\e[0m \e[35mopLenMinusOneInv\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphk9l616q.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36moperandLenMinusOneInv\e[0m = operandLen -\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandLenMinusOneInv is already defined as \e[33mvalue\e\
    [0m \e[35moperandLenMinusOneInv\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphk9l616q.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mopLenMinusOneInv\e[0m =\
    \ opLen - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopLenMinusOneInv is already defined as \e[33mvalue\e[0m \e\
    [35mopLenMinusOneInv\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphk9l616q.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36moperandLenMinusOneInv\e\
    [0m = operandLen - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandLenMinusOneInv is already defined as \e[33mvalue\e\
    [0m \e[35moperandLenMinusOneInv\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of to"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opCount = ops.size\n        val operandCount\
    \ = operands.size\n        val opIndex = ops.indexOf(\"+\")\n        val opIndex2\
    \ = ops.indexOf(\"-\")\n        val opIndex3 = ops.indexOf(\"*\")\n        val\
    \ opIndex4 = ops.indexOf(\"/\")\n        val opIndex5 = ops.indexOf(\"**\")\n\
    \        val opIndex6 = ops.indexOf(\"//\")\n        val opIndex7 = ops.indexOf(\"\
    %\")\n        val opIndex8 = ops.indexOf(\"&\")\n        val opIndex9 = ops.indexOf(\"\
    |\")\n        val opIndex10 = ops.indexOf(\"^\")\n        val opIndex11 = ops.indexOf(\"\
    ~\")\n        val opIndex12 = ops.indexOf(\"<<\")\n        val opIndex13 = ops.indexOf(\"\
    >>\")\n        val opIndex14 = ops.indexOf(\"==\")\n        val opIndex15 = ops.indexOf(\"\
    !=\")\n        val opIndex16 = ops.indexOf(\"<\")\n        val opIndex17 = ops.indexOf(\"\
    >\")\n        val opIndex18 = ops.indexOf(\"<=\")\n        val opIndex19 = ops.indexOf(\"\
    >=\")\n        val opIndex20 = ops.indexOf(\"!~\")\n        val opIndex21 = ops.indexOf(\"\
    !%\")\n        val opIndex22 = ops.indexOf(\"!&\")\n        val opIndex23 = ops.indexOf(\"\
    !|\")\n        val opIndex24 = ops.indexOf(\"!^\")\n        val opIndex25 = ops.indexOf(\"\
    !~\")\n        val opIndex26 = ops.indexOf(\"!<<\")\n        val opIndex27 = ops.indexOf(\"\
    !>>\")\n        val opIndex28 = ops.indexOf(\"!==\")\n        val opIndex29 =\
    \ ops.indexOf(\"!!=\")\n        val opIndex30 = ops.indexOf(\"!<\")\n        val\
    \ opIndex31 = ops.indexOf(\"!>\")\n        val opIndex32 = ops.indexOf(\"!<=\"\
    )\n        val opIndex33 = ops.indexOf(\"!>=\")\n        val opIndex34 = ops.indexOf(\"\
    !~\")\n        val opIndex35 = ops.indexOf(\"!%\")\n        val opIndex36 = ops.indexOf(\"\
    !&\")\n        val opIndex37 = ops.indexOf(\"!|\")\n        val opIndex38 = ops.indexOf(\"\
    !^\")\n        val opIndex39 = ops.indexOf(\"!~\")\n        val opIndex40 = ops.indexOf(\"\
    !\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp2hy_ec_t.scala:66:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m        \e[33mval\e[0m \e[36mopIndex40\e[0m = ops.indexOf(\"\
    !\n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e\
    [0m                                    unclosed string literal\n\e[31m\e[31m--\
    \ Error: /tmp/tmp2hy_ec_t.scala:68:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp2hy_ec_t.scala:67:5 ---------------------\e[0m\e[0m\n\e[31m67 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp2hy_ec_t.scala:68:4 -------------------------\e[0m\e[0m\n\e[31m68 |\e\
    [0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e\
    [0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    Not found: !def\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659792965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase)\n        val opLen =\
    \ opList.length\n        val operandList = operand.map(_.toLong)\n        val\
    \ operandLen = operandList.length\n        val operatorList = opList.dropRight(1)\n\
    \        val operatorLen = operatorList.length\n        val result = operandList.foldLeft(0L)\
    \ {\n            (acc, i) => acc + operatorList.zip(operandList).map {\n     \
    \           case (op, i) => if (op == \"+\") {\n                    acc + i\n\
    \                } else if (op == \"-\") {\n                    acc - i\n    \
    \            } else if (op == \"*\") {\n                    acc * i\n        \
    \        } else if (op == \"/\") {\n                    if (i == 0) {\n      \
    \                  throw new ArithmeticException(\"Division by zero\")\n     \
    \               }\n                    acc / i\n                } else if (op\
    \ == \"//\") {\n                    if (i == 0) {\n                        throw\
    \ new ArithmeticException(\"Division by zero\")\n                    }\n     \
    \               acc // i\n                } else if (op == \"**\") {\n       \
    \             acc ** i\n                } else {\n                    throw new\
    \ ArithmeticException(\"Unknown operator: \" + op)\n                }\n      \
    \      }.sum\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphfr16m2y.scala:48:24 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                    acc ** i\n\e[31m\e[31m   |\e[0m \
    \                   ^^^^^^\e[0m\n\e[31m   |\e[0m                    value ** is\
    \ not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1659792966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toLowerCase)\n        val operands\
    \ = operand.map(x => x.toLong)\n        val opLen = ops.size\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operands.size - 1\n        val opLenMinusOneMinusOne\
    \ = opLen - 1 - 1\n        val operandLenMinusOne = operandLen - 1\n        val\
    \ opLenMinusOneMinusOneMinusOne = opLen - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val\
    \ opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = opLen\
    \ - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n\
    \        val opLenMinusOneMin\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpduciz46w.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpduciz46w.scala:43:5 ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val opLen =\
    \ opList.length\n        val operandList = operand.map(_.toLong)\n        val\
    \ operandLen = operandList.length\n        val opMap = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap = new mutable.HashMap[Long, Long]()\n      \
    \  val result = new mutable.HashMap[String, Long]()\n        val opMapKeys = opList.map(_.toUpperCase)\n\
    \        val operandMapKeys = operandList.map(_.toLong)\n        val opMapValues\
    \ = opList.map(_.toUpperCase)\n        val operandMapValues = operandList.map(_.toLong)\n\
    \        val opMapKeySet = opMap.keySet\n        val operandMapKeySet = operandMap.keySet\n\
    \        val opMapValueSet = opMap.valueSet\n        val operandMapValueSet =\
    \ operandMap.valueSet\n        val opMapKeyIter = opMapKeys.iterator\n       \
    \ val operandMapKeyIter = operandMapKeys.iterator\n        val opMapValueIter\
    \ = opMapValues.iterator\n        val operandMapValueIter = operandMapValues.iterator\n\
    \        var i = 0\n        while (i < opLen) {\n            val opKey = opMapKeyIter.next()\n\
    \            val opValue = opMapValueIter.next()\n            val operandKey =\
    \ operandMapKeyIter.next()\n            val operandValue = operandMapValueIter.next()\n\
    \            val opKeyUpper = opKey.toUpperCase\n            val operandKeyUpper\
    \ = operandKey.toUpperCase\n            val opValueUpper = opValue.toUpperCase\n\
    \            val operandValueUpper = operandValue.toUpperCase\n            val\
    \ opKeyLower = opKey.toLowerCase\n            val operandKeyLower = operandKey.toLowerCase\n\
    \            val opValueLower = opValue.toLowerCase\n            val operandValueLower\
    \ = operandValue.toLowerCase\n            val opKeyEqual = opKeyUpper == opKeyLower\n\
    \            val operandKeyEqual = operandKeyUpper == operandKeyLower\n      \
    \      val opValueEqual = opValueUpper == opValueLower\n            val operandValueEqual\
    \ = operandValueUpper == operandValueLower\n            if (opKeyEqual) {\n  \
    \              if (operandKeyEqual) {\n                    if (opValueEqual) {\n\
    \                        if (operandValueEqual) {\n                          \
    \  result.put(opKey, operandValue)\n                        }\n              \
    \      }\n                }\n            }\n            i += 1\n        }\n  \
    \      operandMapKeys.foreach(operandMapKeyIter.next())\n        operandMapValues.foreach(operandMapValueIter.next())\n\
    \        operandMapKeys.foreach(\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp57tjmcwi.scala:73:31 ---------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m        operandMapKeys.foreach(\n\e[31m\e[31m   |\e[0m\
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \         expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp57tjmcwi.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp57tjmcwi.scala:28:29\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp57tjmcwi.scala:29:25 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp57tjmcwi.scala:49:45 ------------------------\e[0m\e[0m\n\e[31m49 |\e\
    [0m            \e[33mval\e[0m \e[36moperandKeyUpper\e[0m = operandKey.toUpperCase\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp57tjmcwi.scala:51:49\
    \ -------"
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(x => x.toChar).toList\n        val operandList\
    \ = operand.map(x => x.toLong).toList\n        val opLength = opList.length\n\
    \        val operandLength = operandList.length - 1\n        val opMap = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap = new mutable.HashMap[String, Long]()\n    \
    \    val opMap2 = new mutable.HashMap[String, Long]()\n        val operandMap2\
    \ = new mutable.HashMap[String, Long]()\n        val opMap3 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap3 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap4 = new mutable.HashMap[String, Long]()\n        val operandMap4\
    \ = new mutable.HashMap[String, Long]()\n        val opMap5 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap5 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap6 = new mutable.HashMap[String, Long]()\n        val operandMap6\
    \ = new mutable.HashMap[String, Long]()\n        val opMap7 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap7 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap8 = new mutable.HashMap[String, Long]()\n        val operandMap8\
    \ = new mutable.HashMap[String, Long]()\n        val opMap9 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap9 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap10 = new mutable.HashMap[String, Long]()\n        val operandMap10\
    \ = new mutable.HashMap[String, Long]()\n        val opMap11 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap11 = new mutable.HashMap[String, Long]()\n  \
    \      val opMap12 = new mutable.HashMap[String, Long]()\n        val operandMap12\
    \ = new mutable.HashMap[String, Long]()\n        val opMap13 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap13 = new mutable.HashMap[String, Long]()\n  \
    \      val opMap14 = new mutable.HashMap[String, Long]()\n        val operandMap14\
    \ = new mutable.HashMap[String, Long]()\n        val opMap15 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap15 = new mutable.HashMap[String, Long]()\n  \
    \      val opMap16 = new mutable.HashMap[String, Long]()\n        val operand\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprxqiyf61.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprxqiyf61.scala:23:35\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mopList\e[0m = op.map(\e[36mx\e[0m => x.toChar).toList\n\e[31m\e[31m   |\e\
    [0m                                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                      value toChar is not a member of String\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmprxqiyf61.scala:24:34 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36moperandList\e[0m = operand.map(\e\
    [36mx\e[0m => x.toLong).toList\n\e[31m\e[31m   |\e[0m                        \
    \  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue map is not a member of Null, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprxqiyf61.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: mutable\n\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val operatorList = opList.filterNot(_.equals(\"\
    *\"))\n        val operandList = operandList.filterNot(_.equals(\"*\"))\n    \
    \    val operatorList = operatorList.filterNot(_.equals(\"/\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"/\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    **\"))\n        val operandList = operandList.filterNot(_.equals(\"**\"))\n  \
    \      val operatorList = operatorList.filterNot(_.equals(\"+\"))\n        val\
    \ operandList = operandList.filterNot(_.equals(\"+\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"-\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    -\"))\n        val operatorList = operatorList.filterNot(_.equals(\"*\"))\n  \
    \      val operandList = operandList.filterNot(_.equals(\"*\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"//\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    //\"))\n        val operatorList = operatorList.filterNot(_.equals(\"**\"))\n\
    \        val operandList = operandList.filterNot(_.equals(\"**\"))\n        val\
    \ operatorList = operatorList.filterNot(_.equals(\"+\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"+\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    -\"))\n        val operandList = operandList.filterNot(_.equals(\"-\"))\n    \
    \    val operatorList = operatorList.filterNot(_.equals(\"*\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"*\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    //\"))\n        val operandList = operandList.filterNot(_.equals(\"//\"))\n  \
    \      val operatorList = operatorList.filterNot(_.equals(\"**\"))\n        val\
    \ operandList = operandList.filterNot(_.equals(\"**\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"+\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    +\"))\n        val operatorList = operatorList.filterNot(_.equals(\"-\"))\n  \
    \      val operandList = operandList.filterNot(_.equals(\"-\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"*\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    *\"))\n        val operatorList = operatorList.filterNot(\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp32_7ah9t.scala:57:50 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36moperatorList\e[0m = operatorList.filterNot(\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp32_7ah9t.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandList\e[0m = operandList.filterNot(_.equals(\e[31m\"*\"\e[0m))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp32_7ah9t.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36moperatorList\e[0m = operatorList.filterNot(_.equals(\e\
    [31m\"/\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperatorList is already defined as \e[33mvalue\e[0m \e[35moperatorList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp32_7ah9t.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36moperandList\e[0m = operandList.filterNot(_.equals(\e\
    [31m\"/\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp32_7ah9t.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mop"
  stdout: ''
  timestamp: 1659792966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toLong).toList\n        val opLen = opList.length\n        val\
    \ operandLen = operandList.length - 1\n        val opMap = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap = new mutable.HashMap[String, Long]()\n    \
    \    var opIndex = 0\n        var operandIndex = 0\n        var result = 0L\n\
    \        while (operandIndex < operandLen) {\n            val opKey = opList(opIndex)\n\
    \            val operandValue = operandList(operandIndex)\n            val operandKey\
    \ = operandList(operandIndex)\n            opMap.put(opKey, operandValue)\n  \
    \          operandMap.put(operandKey, operandValue)\n            operandIndex\
    \ += 1\n            opIndex += 1\n        }\n        val opKeys = opMap.keys\n\
    \        val opValues = opMap.values.toList\n        val operandKeys = operandMap.keys\n\
    \        val operandValues = operandMap.values.toList\n        var opIndex = 0\n\
    \        var operandIndex = 0\n        while (operandIndex < operandLen) {\n \
    \           val opKey = opKeys(opIndex)\n            val operandValue = opValues(opIndex)\n\
    \            val operandKey = operandKeys(operandIndex)\n            val operandValue\
    \ = operandValues(operandIndex)\n            val opValue = opMap(opKey)\n    \
    \        val operandValue = operandValue(operandKey)\n            result += opValue\
    \ * operandValue\n            operandIndex += 1\n            opIndex += 1\n  \
    \      }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpscs2y9sy.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mvar\e[0m \e[36mopIndex\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopIndex\
    \ is already defined as \e[33mvariable\e[0m \e[35mopIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpscs2y9sy.scala:46:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mvar\e[0m\
    \ \e[36moperandIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandIndex is already defined as \e[33mvariable\e[0m \e\
    [35moperandIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpscs2y9sy.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpscs2y9sy.scala:28:29\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpscs2y9sy.scala:51:16 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m            \e[33mval\e[0m \e[36moperandValue\e[0m =\
    \ operandValues(operandIndex)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandValue is already defined as \e[33mvalue\e[0m \e[35moperandValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659792965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opList = ops.toList\n\
    \        val operands = operand.toList\n        val opLen = opList.size\n    \
    \    val operandLen = operands.size - 1\n        val opMap = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap = new mutable.HashMap[String, Long]()\n    \
    \    val result = new mutable.HashMap[String, Long]()\n        val opMap2 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap2 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap3 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap3 = new mutable.HashMap[String, Long]()\n        val opMap4 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap4 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap5 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap5 = new mutable.HashMap[String, Long]()\n        val opMap6 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap6 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap7 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap7 = new mutable.HashMap[String, Long]()\n        val opMap8 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap8 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap9 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap9 = new mutable.HashMap[String, Long]()\n        val opMap10 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap10 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap11 = new mutable.HashMap[String, Long]()\n       \
    \ val operandMap11 = new mutable.HashMap[String, Long]()\n        val opMap12\
    \ = new mutable.HashMap[String, Long]()\n        val operandMap12 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap13 = new mutable.HashMap[String, Long]()\n       \
    \ val operandMap13 = new mutable.HashMap[String, Long]()\n        val opMap14\
    \ = new mutable.HashMap[String, Long]()\n        val operandMap14 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap15 = new mutable.HashMap[String, Long]()\n       \
    \ val operandMap15 = new mutable.HashMap[String, Long]()\n        val opMap16\
    \ = new \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb466rssq.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpb466rssq.scala:28:24 ------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb466rssq.scala:29:29\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpb466rssq.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpb466rssq.scala:31:25 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        \e[33mval\e[0m \e[36mopMap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb466rssq.scala:32:30\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap2\e[0m = \e[33mnew\e[0m mutable.HashM"
  stdout: ''
  timestamp: 1659792966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val operatorList = opList.filterNot(_.equals(\"\
    *\"))\n        val operandList = operandList.filterNot(_.equals(\"*\"))\n    \
    \    val operatorList = operatorList.filterNot(_.equals(\"/\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"/\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    **\"))\n        val operandList = operandList.filterNot(_.equals(\"**\"))\n  \
    \      val operatorList = operatorList.filterNot(_.equals(\"+\"))\n        val\
    \ operandList = operandList.filterNot(_.equals(\"+\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"-\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    -\"))\n        val operatorList = operatorList.filterNot(_.equals(\"*\"))\n  \
    \      val operandList = operandList.filterNot(_.equals(\"*\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"//\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    //\"))\n        val operatorList = operatorList.filterNot(_.equals(\"**\"))\n\
    \        val operandList = operandList.filterNot(_.equals(\"**\"))\n        val\
    \ operatorList = operatorList.filterNot(_.equals(\"+\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"+\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    -\"))\n        val operandList = operandList.filterNot(_.equals(\"-\"))\n    \
    \    val operatorList = operatorList.filterNot(_.equals(\"*\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"*\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    //\"))\n        val operandList = operandList.filterNot(_.equals(\"//\"))\n  \
    \      val operatorList = operatorList.filterNot(_.equals(\"**\"))\n        val\
    \ operandList = operandList.filterNot(_.equals(\"**\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"+\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    +\"))\n        val operatorList = operatorList.filterNot(_.equals(\"-\"))\n  \
    \      val operandList = operandList.filterNot(_.equals(\"-\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"*\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    *\"))\n        val operatorList = operatorList.filterNot(\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp32_7ah9t.scala:57:50 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36moperatorList\e[0m = operatorList.filterNot(\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp32_7ah9t.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandList\e[0m = operandList.filterNot(_.equals(\e[31m\"*\"\e[0m))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp32_7ah9t.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36moperatorList\e[0m = operatorList.filterNot(_.equals(\e\
    [31m\"/\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperatorList is already defined as \e[33mvalue\e[0m \e[35moperatorList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp32_7ah9t.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36moperandList\e[0m = operandList.filterNot(_.equals(\e\
    [31m\"/\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp32_7ah9t.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mop"
  stdout: ''
  timestamp: 1659792966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toLowerCase)\n        val operands\
    \ = operand.map(x => x.toLong)\n        val opLen = ops.size\n        val operandLen\
    \ = operands.size\n        val opIndex = ops.indexOf(\"+\")\n        val opIndex2\
    \ = ops.indexOf(\"-\")\n        val opIndex3 = ops.indexOf(\"*\")\n        val\
    \ opIndex4 = ops.indexOf(\"/\")\n        val opIndex5 = ops.indexOf(\"**\")\n\
    \        val opIndex6 = ops.indexOf(\"//\")\n        val opIndex7 = ops.indexOf(\"\
    %\")\n        val opIndex8 = ops.indexOf(\"*\")\n        val opIndex9 = ops.indexOf(\"\
    +\")\n        val opIndex10 = ops.indexOf(\"+\")\n        val opIndex11 = ops.indexOf(\"\
    *\")\n        val opIndex12 = ops.indexOf(\"+\")\n        val opIndex13 = ops.indexOf(\"\
    +\")\n        val opIndex14 = ops.indexOf(\"*\")\n        val opIndex15 = ops.indexOf(\"\
    +\")\n        val opIndex16 = ops.indexOf(\"*\")\n        val opIndex17 = ops.indexOf(\"\
    *\")\n        val opIndex18 = ops.indexOf(\"*\")\n        val opIndex19 = ops.indexOf(\"\
    *\")\n        val opIndex20 = ops.indexOf(\"*\")\n        val opIndex21 = ops.indexOf(\"\
    *\")\n        val opIndex22 = ops.indexOf(\"*\")\n        val opIndex23 = ops.indexOf(\"\
    *\")\n        val opIndex24 = ops.indexOf(\"*\")\n        val opIndex25 = ops.indexOf(\"\
    *\")\n        val opIndex26 = ops.indexOf(\"*\")\n        val opIndex27 = ops.indexOf(\"\
    *\")\n        val opIndex28 = ops.indexOf(\"*\")\n        val opIndex29 = ops.indexOf(\"\
    *\")\n        val opIndex30 = ops.indexOf(\"*\")\n        val opIndex31 = ops.indexOf(\"\
    *\")\n        val opIndex32 = ops.indexOf(\"*\")\n        val opIndex33 = ops.indexOf(\"\
    *\")\n        val opIndex34 = ops.indexOf(\"*\")\n        val opIndex35 = ops.indexOf(\"\
    *\")\n        val opIndex36 = ops.indexOf(\"*\")\n        val opIndex37 = ops.indexOf(\"\
    *\")\n        val opIndex38 = ops.indexOf(\"*\")\n        val opIndex39 = ops.indexOf(\"\
    *\")\n        val opIndex40 = ops.indexOf(\"*\")\n        val opIndex41 = ops.indexOf(\"\
    *\")\n        val opIndex42 = ops.indexOf(\"*\")\n        val opIndex43 = ops.indexOf(\"\
    *\")\n        val opIndex44 = ops.\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprzql3y_i.scala:71:4 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmprzql3y_i.scala:71:5 ---------------------\e[0m\e[0m\n\e[31m71\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.size\n        val operandLength\
    \ = operandList.size\n        val opArray = opList.map(_.toChar)\n        val\
    \ operandArray = operandList.map(_.toLong)\n        val opArrayLength = opArray.length\n\
    \        val operandArrayLength = operandArray.length\n        val opArrayLength\
    \ = opArrayLength\n        val operandArrayLength = operandArrayLength\n     \
    \   val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operand\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2ljsgxoh.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2ljsgxoh.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m \e[35moperandArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2ljsgxoh.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2ljsgxoh.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m \e[35moperandArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2ljsgxoh.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val op1 = ops.head\n\
    \        val op2 = ops.last\n        val operand1 = operand.head\n        val\
    \ operand2 = operand.last\n        val op1Int = op1.toInt\n        val op2Int\
    \ = op2.toInt\n        val operand1Int = operand1.toInt\n        val operand2Int\
    \ = operand2.toInt\n        val op1Int = op1Int.toInt\n        val op2Int = op2Int.toInt\n\
    \        val operand1Int = operand1Int.toInt\n        val operand2Int = operand2Int.toInt\n\
    \        val op1Int = op1Int.toInt\n        val op2Int = op2Int.toInt\n      \
    \  val operand1Int = operand1Int.toInt\n        val operand2Int = operand2Int.toInt\n\
    \        val op1Int = op1Int.toInt\n        val op2Int = op2Int.toInt\n      \
    \  val operand1Int = operand1Int.toInt\n        val operand2Int = operand2Int.toInt\n\
    \        val op1Int = op1Int.toInt\n        val op2Int = op2Int.toInt\n      \
    \  val operand1Int = operand1Int.toInt\n        val operand2Int = operand2Int.toInt\n\
    \        val op1Int = op1Int.toInt\n        val op2Int = op2Int.toInt\n      \
    \  val operand1Int = operand1Int.toInt\n        val operand2Int = operand2Int.toInt\n\
    \        val op1Int = op1Int.toInt\n        val op2Int = op2Int.toInt\n      \
    \  val operand1Int = operand1Int.toInt\n        val operand2Int = operand2Int.toInt\n\
    \        val op1Int = op1Int.toInt\n        val op2Int = op2Int.toInt\n      \
    \  val operand1Int = operand1Int.toInt\n        val operand2Int = operand2Int.toInt\n\
    \        val op1Int = op1Int.toInt\n        val op2Int = op2Int.toInt\n      \
    \  val operand1Int = operand1Int.toInt\n        val operand2Int = operand2Int.toInt\n\
    \        val op1Int = op1Int.to\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4jnfkgdm.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mop1Int\e[0m = op1Int.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mop1Int\
    \ is already defined as \e[33mvalue\e[0m \e[35mop1Int\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4jnfkgdm.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mop2Int\e[0m = op2Int.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mop2Int is already defined as \e[33mvalue\e[0m \e[35mop2Int\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp4jnfkgdm.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36moperand1Int\e[0m = operand1Int.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0moperand1Int is already defined as \e[33mvalue\e[0m \e[35moperand1Int\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp4jnfkgdm.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36moperand2Int\e[0m = operand2Int.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0moperand2Int is already defined as \e[33mvalue\e[0m \e[35moperand2Int\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp4jnfkgdm.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mop1Int\e[0m = op1Int.toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mop1Int is\
    \ already defined as \e[33mvalue\e[0m \e[35mop1Int\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded met"
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opList = ops.toList\n\
    \        val operands = operand.toList\n        val operandList = operands.toList\n\
    \        val opLen = opList.size\n        val operandLen = operandList.size\n\
    \        val opIndex = ops.indexOf(\"+\")\n        val opIndex2 = ops.indexOf(\"\
    -\")\n        val opIndex3 = ops.indexOf(\"*\")\n        val opIndex4 = ops.indexOf(\"\
    /\")\n        val opIndex5 = ops.indexOf(\"**\")\n        val opIndex6 = ops.indexOf(\"\
    //\")\n        val opIndex7 = ops.indexOf(\"%\")\n        val opIndex8 = ops.indexOf(\"\
    *\")\n        val opIndex9 = ops.indexOf(\"+\")\n        val opIndex10 = ops.indexOf(\"\
    +\")\n        val opIndex11 = ops.indexOf(\"*\")\n        val opIndex12 = ops.indexOf(\"\
    *\")\n        val opIndex13 = ops.indexOf(\"+\")\n        val opIndex14 = ops.indexOf(\"\
    +\")\n        val opIndex15 = ops.indexOf(\"*\")\n        val opIndex16 = ops.indexOf(\"\
    *\")\n        val opIndex17 = ops.indexOf(\"*\")\n        val opIndex18 = ops.indexOf(\"\
    *\")\n        val opIndex19 = ops.indexOf(\"*\")\n        val opIndex20 = ops.indexOf(\"\
    *\")\n        val opIndex21 = ops.indexOf(\"*\")\n        val opIndex22 = ops.indexOf(\"\
    *\")\n        val opIndex23 = ops.indexOf(\"*\")\n        val opIndex24 = ops.indexOf(\"\
    *\")\n        val opIndex25 = ops.indexOf(\"*\")\n        val opIndex26 = ops.indexOf(\"\
    *\")\n        val opIndex27 = ops.indexOf(\"*\")\n        val opIndex28 = ops.indexOf(\"\
    *\")\n        val opIndex29 = ops.indexOf(\"*\")\n        val opIndex30 = ops.indexOf(\"\
    *\")\n        val opIndex31 = ops.indexOf(\"*\")\n        val opIndex32 = ops.indexOf(\"\
    *\")\n        val opIndex33 = ops.indexOf(\"*\")\n        val opIndex34 = ops.indexOf(\"\
    *\")\n        val opIndex35 = ops.indexOf(\"*\")\n        val opIndex36 = ops.indexOf(\"\
    *\")\n        val opIndex37 = ops.indexOf(\"*\")\n        val opIndex38 = ops.indexOf(\"\
    *\")\n        val opIndex39 = ops.indexOf(\"*\")\n        val opIndex40 = ops.indexOf(\"\
    *\")\n        val opIndex41 = ops.indexOf(\"*\")\n        val opIndex42 = ops.indexOf(\"\
    *\")\n        val opIndex43 = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpxq9zqpmr.scala:71:23 ---------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m        \e[33mval\e[0m \e[36mopIndex43\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpxq9zqpmr.scala:72:5 ---------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length - 1\n        val opMap = new mutable.HashMap[String, Long]()\n\
    \        val operandMap = new mutable.HashMap[String, Long]()\n        val opMapKeys\
    \ = opList.map(x => x.toUpperCase)\n        val operandMapKeys = operandList.map(x\
    \ => x.toUpperCase)\n        val opMapValues = opList.map(x => x.toUpperCase)\n\
    \        val operandMapValues = operandList.map(x => x.toUpperCase)\n        val\
    \ opMapKeysLength = opMapKeys.length\n        val operandMapKeysLength = operandMapKeys.length\n\
    \        val opMapValueLength = opMapValues.length\n        val operandMapValueLength\
    \ = operandMapValues.length\n        val opMapKeysLength = opMapKeysLength\n \
    \       val operandMapKeysLength = operandMapKeysLength\n        val opMapValueLength\
    \ = opMapValueLength\n        val operandMapValueLength = operandMapValueLength\n\
    \        val opMapKeysLength = opMapKeysLength\n        val operandMapKeysLength\
    \ = operandMapKeysLength\n        val opMapValueLength = opMapValueLength\n  \
    \      val operandMapValueLength = operandMapValueLength\n        val opMapKeysLength\
    \ = opMapKeysLength\n        val operandMapKeysLength = operandMapKeysLength\n\
    \        val opMapValueLength = opMapValueLength\n        val operandMapValueLength\
    \ = operandMapValueLength\n        val opMapKeysLength = opMapKeysLength\n   \
    \     val operandMapKeysLength = operandMapKeysLength\n        val opMapValueLength\
    \ = opMapValueLength\n        val operandMapValueLength = operandMapValueLength\n\
    \        val opMapKeysLength = opMapKeysLength\n        val operandMapKeysLength\
    \ = operandMapKeysLength\n        val opMapValueLength = opMapValueLength\n  \
    \      val operandMapValueLength = operandMapValueLength\n        val opMapKeysLength\
    \ = opMapKeysLength\n        val operandMapKeysLength = operandMapKeysLength\n\
    \        val opMapValueLength = opMapValueLength\n        val operandMapValueLength\
    \ = operandMapValueLength\n        val opMapKeysLength = opMapKeysLength\n   \
    \     val operandMapKeysLength = operandMapKeysLength\n        val opMapValueLength\
    \ = opMapValueLength\n        val operandMapValueLength = operandMapValue\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcgju2hg5.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mopMapKeysLength\e[0m = opMapKeysLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mopMapKeysLength is already defined as \e[33mvalue\e[0m \e[35mopMapKeysLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcgju2hg5.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36moperandMapKeysLength\e[0m = operandMapKeysLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandMapKeysLength is already defined as \e[33mvalue\e[0m\
    \ \e[35moperandMapKeysLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcgju2hg5.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mopMapValueLength\e[0m =\
    \ opMapValueLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapValueLength is already defined as \e[33mvalue\e[0m \e\
    [35mopMapValueLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcgju2hg5.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36moperandMapValueLength\e\
    [0m = operandMapValueLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandMapValueLength is already defined as \e[33mvalue\e\
    [0m \e[35moperandMapValueLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcgju2hg5.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mopMapKeysLength\e[0m = opMa"
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = new mutable.HashMap[String, Long]()\n\
    \        val operandMap = new mutable.HashMap[String, Long]()\n        val opMap2\
    \ = new mutable.HashMap[String, Long]()\n        val operandMap2 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap3 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap3 = new mutable.HashMap[String, Long]()\n        val opMap4 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap4 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap5 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap5 = new mutable.HashMap[String, Long]()\n        val opMap6 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap6 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap7 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap7 = new mutable.HashMap[String, Long]()\n        val opMap8 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap8 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap9 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap9 = new mutable.HashMap[String, Long]()\n        val opMap10 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap10 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap11 = new mutable.HashMap[String, Long]()\n       \
    \ val operandMap11 = new mutable.HashMap[String, Long]()\n        val opMap12\
    \ = new mutable.HashMap[String, Long]()\n        val operandMap12 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap13 = new mutable.HashMap[String, Long]()\n       \
    \ val operandMap13 = new mutable.HashMap[String, Long]()\n        val opMap14\
    \ = new mutable.HashMap[String, Long]()\n        val operandMap14 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap15 = new mutable.HashMap[String, Long]()\n       \
    \ val operandMap15 = new mutable.HashMap[String, Long]()\n        val opMap16\
    \ = new mutable.HashMap[String, Long]()\n        val operandMap16 = new mut\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1o6jtrtn.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1o6jtrtn.scala:28:29\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp1o6jtrtn.scala:29:25 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mopMap2\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1o6jtrtn.scala:30:30 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36moperandMap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1o6jtrtn.scala:31:25\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap3\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explana"
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val operatorList = opList.filterNot(_.equals(\"\
    *\"))\n        val operandList = operandList.filterNot(_.equals(\"*\"))\n    \
    \    val operatorList = operatorList.filterNot(_.equals(\"/\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"/\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    **\"))\n        val operandList = operandList.filterNot(_.equals(\"**\"))\n  \
    \      val operatorList = operatorList.filterNot(_.equals(\"+\"))\n        val\
    \ operandList = operandList.filterNot(_.equals(\"+\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"-\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    -\"))\n        val operatorList = operatorList.filterNot(_.equals(\"*\"))\n  \
    \      val operandList = operandList.filterNot(_.equals(\"*\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"//\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    //\"))\n        val operatorList = operatorList.filterNot(_.equals(\"**\"))\n\
    \        val operandList = operandList.filterNot(_.equals(\"**\"))\n        val\
    \ operatorList = operatorList.filterNot(_.equals(\"+\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"+\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    -\"))\n        val operandList = operandList.filterNot(_.equals(\"-\"))\n    \
    \    val operatorList = operatorList.filterNot(_.equals(\"*\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"*\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    //\"))\n        val operandList = operandList.filterNot(_.equals(\"//\"))\n  \
    \      val operatorList = operatorList.filterNot(_.equals(\"**\"))\n        val\
    \ operandList = operandList.filterNot(_.equals(\"**\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"+\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    +\"))\n        val operatorList = operatorList.filterNot(_.equals(\"-\"))\n  \
    \      val operandList = operandList.filterNot(_.equals(\"-\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"*\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    *\"))\n        val operatorList = operatorList.filterNot(\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp32_7ah9t.scala:57:50 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36moperatorList\e[0m = operatorList.filterNot(\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp32_7ah9t.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandList\e[0m = operandList.filterNot(_.equals(\e[31m\"*\"\e[0m))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp32_7ah9t.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36moperatorList\e[0m = operatorList.filterNot(_.equals(\e\
    [31m\"/\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperatorList is already defined as \e[33mvalue\e[0m \e[35moperatorList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp32_7ah9t.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36moperandList\e[0m = operandList.filterNot(_.equals(\e\
    [31m\"/\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp32_7ah9t.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mop"
  stdout: ''
  timestamp: 1659792966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opList = ops.toList\n\
    \        val operands = operand.toList\n        val length = opList.size\n   \
    \     val operandsLength = operands.size\n        val result = operands(0)\n \
    \       val op1 = ops(0)\n        val op2 = ops(1)\n        val op3 = ops(2)\n\
    \        val op4 = ops(3)\n        val op5 = ops(4)\n        val op6 = ops(5)\n\
    \        val op7 = ops(6)\n        val op8 = ops(7)\n        val op9 = ops(8)\n\
    \        val op10 = ops(9)\n        val op11 = ops(10)\n        val op12 = ops(11)\n\
    \        val op13 = ops(12)\n        val op14 = ops(13)\n        val op15 = ops(14)\n\
    \        val op16 = ops(15)\n        val op17 = ops(16)\n        val op18 = ops(17)\n\
    \        val op19 = ops(18)\n        val op20 = ops(19)\n        val op21 = ops(20)\n\
    \        val op22 = ops(21)\n        val op23 = ops(22)\n        val op24 = ops(23)\n\
    \        val op25 = ops(24)\n        val op26 = ops(25)\n        val op27 = ops(26)\n\
    \        val op28 = ops(27)\n        val op29 = ops(28)\n        val op30 = ops(29)\n\
    \        val op31 = ops(30)\n        val op32 = ops(31)\n        val op33 = ops(32)\n\
    \        val op34 = ops(33)\n        val op35 = ops(34)\n        val op36 = ops(35)\n\
    \        val op37 = ops(36)\n        val op38 = ops(37)\n        val op39 = ops(38)\n\
    \        val op40 = ops(39)\n        val op41 = ops(40)\n        val op42 = ops(41)\n\
    \        val op43 = ops(42)\n        val op44 = ops(43)\n        val op45 = ops(44)\n\
    \        val op46 = ops(45)\n        val op47 = ops(46)\n        val op48 = ops(47)\n\
    \        val op49 = ops(48)\n        val op50 = ops(49)\n        val op5\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp90zxiikd.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp90zxiikd.scala:80:5 ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792966
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.mkString(\"+\")\n        val opList2 = op.mkString(\"\
    *\")\n        val opList3 = op.mkString(\"//\")\n        val opList4 = op.mkString(\"\
    **\")\n        val opList5 = op.mkString(\"+\")\n        val opList6 = op.mkString(\"\
    *\")\n        val opList7 = op.mkString(\"//\")\n        val opList8 = op.mkString(\"\
    **\")\n        val opList9 = op.mkString(\"+\")\n        val opList10 = op.mkString(\"\
    *\")\n        val opList11 = op.mkString(\"//\")\n        val opList12 = op.mkString(\"\
    **\")\n        val opList13 = op.mkString(\"+\")\n        val opList14 = op.mkString(\"\
    *\")\n        val opList15 = op.mkString(\"//\")\n        val opList16 = op.mkString(\"\
    **\")\n        val opList17 = op.mkString(\"+\")\n        val opList18 = op.mkString(\"\
    *\")\n        val opList19 = op.mkString(\"//\")\n        val opList20 = op.mkString(\"\
    **\")\n        val opList21 = op.mkString(\"+\")\n        val opList22 = op.mkString(\"\
    *\")\n        val opList23 = op.mkString(\"//\")\n        val opList24 = op.mkString(\"\
    **\")\n        val opList25 = op.mkString(\"+\")\n        val opList26 = op.mkString(\"\
    *\")\n        val opList27 = op.mkString(\"//\")\n        val opList28 = op.mkString(\"\
    **\")\n        val opList29 = op.mkString(\"+\")\n        val opList30 = op.mkString(\"\
    *\")\n        val opList31 = op.mkString(\"//\")\n        val opList32 = op.mkString(\"\
    **\")\n        val opList33 = op.mkString(\"+\")\n        val opList34 = op.mkString(\"\
    *\")\n        val opList35 = op.mkString(\"//\")\n        val opList36 = op.mkString(\"\
    **\")\n        val opList37 = op.mkString(\"+\")\n        val opList38 = op.mkString(\"\
    *\")\n        val opList39 = op.mkString(\"//\")\n        val opList40 = op.mkString(\"\
    **\")\n        val opList41 = op.mkString(\"+\")\n        val opList42 = op.mkString(\"\
    *\")\n        val opList43 = op.mkString(\"//\")\n        val opList44 = op.mkString(\"\
    **\")\n        val opList45 = op.mkString(\"+\")\n        val opList46 = op.mk\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx2degeda.scala:68:26 ------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mopList46\e[0m = op.mk\n\e\
    [31m\e[31m   |\e[0m                       ^^^^^\e[0m\n\e[31m   |\e[0m        \
    \               value mk is not a member of List[String]\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpx2degeda.scala:69:5 ---------------------\e[0m\e\
    [0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val op1 = ops.head\n\
    \        val op2 = ops.last\n        val op1Int = operand.head\n        val op2Int\
    \ = operand.last\n        val op1Int = operand.head\n        val op2Int = operand.last\n\
    \        val op1Int = operand.head\n        val op2Int = operand.last\n      \
    \  val op1Int = operand.head\n        val op2Int = operand.last\n        val op1Int\
    \ = operand.head\n        val op2Int = operand.last\n        val op1Int = operand.head\n\
    \        val op2Int = operand.last\n        val op1Int = operand.head\n      \
    \  val op2Int = operand.last\n        val op1Int = operand.head\n        val op2Int\
    \ = operand.last\n        val op1Int = operand.head\n        val op2Int = operand.last\n\
    \        val op1Int = operand.head\n        val op2Int = operand.last\n      \
    \  val op1Int = operand.head\n        val op2Int = operand.last\n        val op1Int\
    \ = operand.head\n        val op2Int = operand.last\n        val op1Int = operand.head\n\
    \        val op2Int = operand.last\n        val op1Int = operand.head\n      \
    \  val op2Int = operand.last\n        val op1Int = operand.head\n        val op2Int\
    \ = operand.last\n        val op1Int = operand.head\n        val op2Int = operand.last\n\
    \        val op1Int = operand.head\n        val op2Int = operand.last\n      \
    \  val op1Int = operand.head\n        val op2Int = operand.last\n        val op1Int\
    \ = operand.head\n        val op2Int = operand.last\n        val op1Int = operand.head\n\
    \        val op2Int = operand.last\n        val op1Int = operand.head\n      \
    \  val op2Int = operand.last\n        val op1Int = operand.head\n        val op2Int\
    \ = operand.last\n        val op1Int = operand.head\n        val op2Int = operand.last\n\
    \        val op1Int = operand.head\n        val op2Int = operand.last\n      \
    \  val op1In\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpavvr_4kx.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpavvr_4kx.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mop1Int\e[0m = operand.head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mop1Int is already defined as \e[33mvalue\e[0m \e[35mop1Int\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpavvr_4kx.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mop2Int\e[0m = operand.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mop2Int is\
    \ already defined as \e[33mvalue\e[0m \e[35mop2Int\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpavvr_4kx.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mop1Int\e[0m = operand.head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mop1Int is already defined as \e[33mvalue\e[0m \e[35mop1Int\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpavvr_4kx.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mop2Int\e[0m = operand.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mop2Int is\
    \ already defined as \e[33mvalue\e[0m \e[35mop2Int\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpavvr_4kx.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mop1Int\e[0m = operand.head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toLong).toList\n        val operatorList = opList.filterNot(_.equals(\"\
    +\")).filterNot(_.equals(\"-\")).filterNot(_.equals(\"*\")).filterNot(_.equals(\"\
    //\")).filterNot(_.equals(\"**\"))\n        val operandListLength = operandList.length\n\
    \        val operatorListLength = operatorList.length\n        val result = operandList(0)\n\
    \        val operator = operatorList(0)\n        val operand = operandList(1)\n\
    \        val operand2 = operandList(2)\n        val operand3 = operandList(3)\n\
    \        val operand4 = operandList(4)\n        val operand5 = operandList(5)\n\
    \        val operand6 = operandList(6)\n        val operand7 = operandList(7)\n\
    \        val operand8 = operandList(8)\n        val operand9 = operandList(9)\n\
    \        val operand10 = operandList(10)\n        val operand11 = operandList(11)\n\
    \        val operand12 = operandList(12)\n        val operand13 = operandList(13)\n\
    \        val operand14 = operandList(14)\n        val operand15 = operandList(15)\n\
    \        val operand16 = operandList(16)\n        val operand17 = operandList(17)\n\
    \        val operand18 = operandList(18)\n        val operand19 = operandList(19)\n\
    \        val operand20 = operandList(20)\n        val operand21 = operandList(21)\n\
    \        val operand22 = operandList(22)\n        val operand23 = operandList(23)\n\
    \        val operand24 = operandList(24)\n        val operand25 = operandList(25)\n\
    \        val operand26 = operandList(26)\n        val operand27 = operandList(27)\n\
    \        val operand28 = operandList(28)\n        val operand29 = operandList(29)\n\
    \        val operand30 = operandList(30)\n        val operand31 = operandList(31)\n\
    \        val operand32 = operandList(32)\n        val operand33 = operandList(33)\n\
    \        val operand34 = operandList(34)\n        val operand35 = operandList(35)\n\
    \        val operand36 = operandList(36)\n        val operand37 = operandList(37)\n\
    \        val operand38 = operandList(38)\n        val operand39 = operandList(39)\n\
    \        val operand40 = operandList(40)\n        val operand41 = operandList(41)\n\
    \        val operand42 = operandList(42)\n        val operand43 = operandList(43)\n\
    \        val operand44 = operandList(44)\n        val operand\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyp6yqq9p.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyp6yqq9p.scala:30:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperand\e[0m = operandList(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                ^\e[0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e\
    [0m \e[35moperandList\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpyp6yqq9p.scala:75:5 ---------------------\e[0m\e\
    [0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val result = operandArray(0)\n        val op1 = opArray(0)\n        val\
    \ op2 = opArray(1)\n        val op3 = opArray(2)\n        val op4 = opArray(3)\n\
    \        val op5 = opArray(4)\n        val op6 = opArray(5)\n        val op7 =\
    \ opArray(6)\n        val op8 = opArray(7)\n        val op9 = opArray(8)\n   \
    \     val op10 = opArray(9)\n        val op11 = opArray(10)\n        val op12\
    \ = opArray(11)\n        val op13 = opArray(12)\n        val op14 = opArray(13)\n\
    \        val op15 = opArray(14)\n        val op16 = opArray(15)\n        val op17\
    \ = opArray(16)\n        val op18 = opArray(17)\n        val op19 = opArray(18)\n\
    \        val op20 = opArray(19)\n        val op21 = opArray(20)\n        val op22\
    \ = opArray(21)\n        val op23 = opArray(22)\n        val op24 = opArray(23)\n\
    \        val op25 = opArray(24)\n        val op26 = opArray(25)\n        val op27\
    \ = opArray(26)\n        val op28 = opArray(27)\n        val op29 = opArray(28)\n\
    \        val op30 = opArray(29)\n        val op31 = opArray(30)\n        val op32\
    \ = opArray(31)\n        val op33 = opArray(32)\n        val op34 = opArray(33)\n\
    \        val op35 = opArray(34)\n        val op36 = opArray(35)\n        val op37\
    \ = opArray(36)\n        val op38 = opArray(37)\n        val op39 = opArray(38)\n\
    \        val op40 = opArray(39)\n        val op41 = opArray(40)\n        val op42\
    \ = opArray(41)\n        val op43 = opArray(42)\n        val op44 = opArray(43)\n\
    \        val op45 = opArray(44)\n        val op46 = opArray(45)\n        val op47\
    \ = opArray(46)\n        val op48 = opArray(47)\n        val op49 = opArray(48)\n\
    \        val op50 = opArray(49)\n        val op51 = opArray(50)\n\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\"\
    , \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) ==\
    \ (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjzpq6qr3.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLength = ops.size\n        val operandLength\
    \ = operands.size - 1\n        val result = operands(0)\n        ops.zipWithIndex.foreach\
    \ { case (op, i) =>\n            val op1 = ops(i)\n            val op2 = ops(i\
    \ + 1)\n            val operand1 = operands(i)\n            val operand2 = operands(i\
    \ + 1)\n            val op1Length = op1.length\n            val op2Length = op2.length\n\
    \            val operand1Length = operand1.length\n            val operand2Length\
    \ = operand2.length\n            val op1Length = op1Length\n            val op2Length\
    \ = op2Length\n            val operand1Length = operand1Length\n            val\
    \ operand2Length = operand2Length\n            val op1Length = op1Length\n   \
    \         val op2Length = op2Length\n            val operand1Length = operand1Length\n\
    \            val operand2Length = operand2Length\n            val op1Length =\
    \ op1Length\n            val op2Length = op2Length\n            val operand1Length\
    \ = operand1Length\n            val operand2Length = operand2Length\n        \
    \    val op1Length = op1Length\n            val op2Length = op2Length\n      \
    \      val operand1Length = operand1Length\n            val operand2Length = operand2Length\n\
    \            val op1Length = op1Length\n            val op2Length = op2Length\n\
    \            val operand1Length = operand1Length\n            val operand2Length\
    \ = operand2Length\n            val op1Length = op1Length\n            val op2Length\
    \ = op2Length\n            val operand1Length = operand1Length\n            val\
    \ operand2Length = operand2Length\n            val op1Length = op1Length\n   \
    \         val op2Length = op2Length\n            val operand1Length = operand1Length\n\
    \            val operand2Length = operand2Length\n            val op1Length =\
    \ op1Length\n            val op2Length = op2Length\n            val operand1Length\
    \ = operand1Length\n            val operand2Length = operand2Length\n        \
    \    val op1Length = op1Length\n            val op2Length = op2Length\n      \
    \      val operand1Length = operand1Length\n            val operand2Length = operand2Length\n\
    \            val op1Length = op1Length\n            val op2Length = op2Length\n\
    \            val operand1Length = operand1Length\n            val operand2Length\
    \ = operand2Length\n            val op1Length = op1Length\n            val op2Length\
    \ = op2Length\n            val operand\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmperexdzfg.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmperexdzfg.scala:88:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmperexdzfg.scala:37:16 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m            \e[33mval\e[0m \e[36mop1Length\e[0m = op1Length\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mop1Length\
    \ is already defined as \e[33mvalue\e[0m \e[35mop1Length\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmperexdzfg.scala:38:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e\
    [0m \e[36mop2Length\e[0m = op2Length\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mop2Length is already defined as \e[33mvalue\e[0m \e[35mop2Length\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmperexdzfg.scala:41:16 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m            \e[33mval\e[0m \e[36mop1Length\e[0m = op1Length\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mop1Length\
    \ is already defined as \e[33mvalue\e[0m \e[35mop1Length\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmperexdzfg.scala:42:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e\
    [0m \e[36mop2Length\e[0m = op2Length\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mop2Length is already defined as \e[33mvalue\e[0m \e[35mop2Length\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of "
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val operatorList = opList.dropRight(1)\n  \
    \      val operandList = operandList.drop(1)\n        val operatorList = operatorList.map(_.toUpperCase)\n\
    \        val operandList = operandList.map(_.toLong)\n        val operatorList\
    \ = operatorList.dropRight(1)\n        val operandList = operandList.drop(1)\n\
    \        val operatorList = operatorList.map(_.toUpperCase)\n        val operandList\
    \ = operandList.map(_.toLong)\n        val operatorList = operatorList.dropRight(1)\n\
    \        val operandList = operandList.drop(1)\n        val operatorList = operatorList.map(_.toUpperCase)\n\
    \        val operandList = operandList.map(_.toLong)\n        val operatorList\
    \ = operatorList.dropRight(1)\n        val operandList = operandList.drop(1)\n\
    \        val operatorList = operatorList.map(_.toUpperCase)\n        val operandList\
    \ = operandList.map(_.toLong)\n        val operatorList = operatorList.dropRight(1)\n\
    \        val operandList = operandList.drop(1)\n        val operatorList = operatorList.map(_.toUpperCase)\n\
    \        val operandList = operandList.map(_.toLong)\n        val operatorList\
    \ = operatorList.dropRight(1)\n        val operandList = operandList.drop(1)\n\
    \        val operatorList = operatorList.map(_.toUpperCase)\n        val operandList\
    \ = operandList.map(_.toLong)\n        val operatorList = operatorList.dropRight(1)\n\
    \        val operandList = operandList.drop(1)\n        val operatorList = operatorList.map(_.toUpperCase)\n\
    \        val operandList = operandList.map(_.toLong)\n        val operatorList\
    \ = operatorList.dropRight(1)\n        val operandList = operandList.drop(1)\n\
    \        val operatorList = operatorList.map(_.toUpperCase)\n        val operandList\
    \ = operandList.map(_.toLong)\n        val operatorList = operatorList.dropRight(1)\n\
    \        val operandList = operandList.drop(1)\n        val operatorList = operatorList.map(_.toUpperCase)\n\
    \        val operandList = operandList.map(_.toLong)\n        val operatorList\
    \ = operatorList.dropRight(1)\n        val operandList = operandList.drop(1)\n\
    \        val operatorList = operatorList.map(_.toUpperCase)\n        val operandList\
    \ = operandList.map(_.toLong)\n        val operatorList = operatorList.dropRight(1)\n\
    \        val operandList = operandList.drop(1)\n        val operatorList = operatorList.map(_.toUpperCase)\n\
    \        val operandList = operandList.map(_.toLong)\n        val operatorList\
    \ = operatorList.dropRight(1)\n        val operandList = operandList.\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsda2z87e.scala:71:4 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsda2z87e.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36moperandList\e[0m = operandList.drop(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsda2z87e.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36moperatorList\e[0m = operatorList.map(_.toUpperCase)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperatorList is already defined as \e[33mvalue\e[0m \e[35moperatorList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsda2z87e.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36moperandList\e[0m = operandList.map(_.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsda2z87e.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36moperatorList\e[0m = operatorList.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperatorList is already defined as \e[33mvalue\e[0m \e[35moperatorList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel defin"
  stdout: ''
  timestamp: 1659792967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val operands =\
    \ operand.map(x => x.toLong)\n        val opLen = ops.size\n        val operandLen\
    \ = operands.size\n        val opIndex = 0\n        val operandIndex = 0\n   \
    \     val result = operands(operandIndex)\n        while (operandIndex < operandLen)\
    \ {\n            val op = ops(opIndex)\n            val operand = operands(operandIndex)\n\
    \            val opResult = if (op == '+') result + operand else result - operand\n\
    \            val opResult = if (op == '*') result * operand else result / operand\n\
    \            val opResult = if (op == '/') result / operand else result % operand\n\
    \            val opResult = if (op == '%') result % operand else result ** operand\n\
    \            val opResult = if (op == '^') result ^ operand else result & operand\n\
    \            val opResult = if (op == '&') result & operand else result | operand\n\
    \            val opResult = if (op == '|') result | operand else result ^ operand\n\
    \            val opResult = if (op == '-') result - operand else result + operand\n\
    \            val opResult = if (op == '+') result + operand else result - operand\n\
    \            val opResult = if (op == '*') result * operand else result / operand\n\
    \            val opResult = if (op == '/') result / operand else result % operand\n\
    \            val opResult = if (op == '%') result % operand else result ** operand\n\
    \            val opResult = if (op == '^') result ^ operand else result & operand\n\
    \            val opResult = if (op == '&') result & operand else result | operand\n\
    \            val opResult = if (op == '|') result | operand else result ^ operand\n\
    \            val opResult = if (op == '-') result - operand else result + operand\n\
    \            val opResult = if (op == '+') result + operand else result - operand\n\
    \            val opResult = if (op == '*') result * operand else result / operand\n\
    \            val opResult = if (op == '/') result / operand else result % operand\n\
    \            val opResult = if (op == '%') result % operand else result ** operand\n\
    \            val opResult = if (op == '^') result ^ operand else result & operand\n\
    \            val opResult = if (op == '&') result & operand else result | operand\n\
    \            val opResult = if (op == '|') result | operand else result ^ operand\n\
    \            val opResult = if (op == '-') \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaizauj0m.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'then' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaizauj0m.scala:65:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m65 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpaizauj0m.scala:23:32 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e[0m =>\
    \ x.toChar)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              value toChar is not a member of String\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaizauj0m.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mopResult\e[0m = \e[33mif\e\
    [0m (op == \e[31m'*'\e[0m) result * operand \e[33melse\e[0m result / operand\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopResult is already defined as \e[33mvalue\e[0m \e[35mopResult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaizauj0m.scala:35:16 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m            \e[33mval\e[0m \e[36mopResult\e[0m = \e[33mif\e[0m (op\
    \ == \e[31m'/'\e[0m) result / operand \e[33melse\e[0m result % operand\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopResult is already defined as \e[33mvalue\e[0m \e[35mopResult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaizauj0m.scala:36:16 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m            \e[33mval\e[0m \e[36mopResult\e[0m = \e[33mif\e[0m (op\
    \ == \e[31m'%'\e[0m) result % operand \e[33melse\e[0m result ** operand\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659792968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opLen = ops.length\n\
    \        val opArray = ops.toArray\n        val operandArray = operand.toArray\n\
    \        val opArrayLen = opArray.length\n        val operandArrayLen = operandArray.length\n\
    \        val result = operandArray(0)\n        val op1 = opArray(0)\n        val\
    \ op2 = opArray(1)\n        val op3 = opArray(2)\n        val op4 = opArray(3)\n\
    \        val op5 = opArray(4)\n        val op6 = opArray(5)\n        val op7 =\
    \ opArray(6)\n        val op8 = opArray(7)\n        val op9 = opArray(8)\n   \
    \     val op10 = opArray(9)\n        val op11 = opArray(10)\n        val op12\
    \ = opArray(11)\n        val op13 = opArray(12)\n        val op14 = opArray(13)\n\
    \        val op15 = opArray(14)\n        val op16 = opArray(15)\n        val op17\
    \ = opArray(16)\n        val op18 = opArray(17)\n        val op19 = opArray(18)\n\
    \        val op20 = opArray(19)\n        val op21 = opArray(20)\n        val op22\
    \ = opArray(21)\n        val op23 = opArray(22)\n        val op24 = opArray(23)\n\
    \        val op25 = opArray(24)\n        val op26 = opArray(25)\n        val op27\
    \ = opArray(26)\n        val op28 = opArray(27)\n        val op29 = opArray(28)\n\
    \        val op30 = opArray(29)\n        val op31 = opArray(30)\n        val op32\
    \ = opArray(31)\n        val op33 = opArray(32)\n        val op34 = opArray(33)\n\
    \        val op35 = opArray(34)\n        val op36 = opArray(35)\n        val op37\
    \ = opArray(36)\n        val op38 = opArray(37)\n        val op39 = opArray(38)\n\
    \        val op40 = opArray(39)\n        val op41 = opArray(40)\n        val op42\
    \ = opArray(41)\n        val op43 = opArray(42)\n        val op44 = opArray(43)\n\
    \        val op45 = opArray(44)\n        val op46 = opArray(45)\n        val op47\
    \ = opArray(46)\n        val op48 = opArray(47)\n        val op49 = opArray(48\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo_7gupvb.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpo_7gupvb.scala:79:5 ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toInt).toList\n        val opLength = opList.size\n        val\
    \ operandLength = operandList.size\n        val opIndex = 0\n        val operandIndex\
    \ = 0\n        val opStack = mutable.Stack[String]()\n        val operandStack\
    \ = mutable.Stack[Long]()\n        val result = operandStack.last\n        val\
    \ opStackSize = opStack.size()\n        val operandStackSize = operandStack.size()\n\
    \        val opStackIndex = opStackSize - 1\n        val operandStackIndex = operandStackSize\
    \ - 1\n        val opStackElement = opStack(opStackIndex)\n        val operandStackElement\
    \ = operandStack(operandStackIndex)\n        while(opStackIndex >= 0 && operandStackIndex\
    \ >= 0) {\n            val opElement = opStack(opStackIndex)\n            val\
    \ operandElement = operandStack(operandStackIndex)\n            val opElementLower\
    \ = opElement.toLowerCase\n            val operandElementLower = operandElement.toString.toLowerCase\n\
    \            if(opElementLower == opStackElement) {\n                opStackIndex\
    \ -= 1\n                operandStackIndex -= 1\n                opStackElement\
    \ = opStack(opStackIndex)\n                operandStackElement = operandStack(operandStackIndex)\n\
    \            } else {\n                val opElementUpper = opElement.toUpperCase\n\
    \                val operandElementUpper = operandElement.toString.toUpperCase\n\
    \                if(opElementUpper == opStackElement) {\n                    opStackIndex\
    \ -= 1\n                    operandStackIndex -= 1\n                    opStackElement\
    \ = opStack(opStackIndex)\n                    operandStackElement = operandStack(operandStackIndex)\n\
    \                } else {\n                    val opElementDigit = opElementDigit(opElementLower)\n\
    \                    val operandElementDigit = operandElementDigit(operandElementLower)\n\
    \                    if(opElementDigit == opStackElement) {\n                \
    \        opStackIndex -= 1\n                        operandStackIndex -= 1\n \
    \                       opStackElement = opStack(opStackIndex)\n             \
    \           operandStackElement = operandStack(operandStackIndex)\n          \
    \          } else {\n                        val opElementDigit2 = opElementDigit(opElementUpper)\n\
    \                        val operandElementDigit2 = operandElementDigit(operandElementUpper)\n\
    \                        if(opElementDigit2 == opStackElement) {\n           \
    \                 opStackIndex -= 1\n                            operandStackIndex\
    \ -= 1\n                            opStackElement = opStack(opStackIndex)\n \
    \                           operandStackElement = operandStack(operandStackIndex)\n\
    \                        } else {\n                            val opElementDigit3\
    \ = opElementDigit(opElementDigit)\n                            val operandElementDigit3\
    \ = operandElementDigit(operandElementDigit\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplqp3phow.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplqp3phow.scala:83:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m83 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmplqp3phow.scala:29:22 ------------------------\e[0m\e[0m\n\
    \e[31m29 |\e[0m        \e[33mval\e[0m \e[36mopStack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplqp3phow.scala:30:27 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36moperandStack\e[0m = mutable.Stack[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmplqp3phow.scala:46:31 -----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                opStackElement = opStack(opStackIndex)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val opStackElement\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmplqp3phow.scala:47:36 -----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                operandStackElement = operandStack(operandStackIndex)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val operandStackElement\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmplqp3phow.scala:54:35 --------------------"
  stdout: ''
  timestamp: 1659792968
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(x => x.toChar)\n        val operandList\
    \ = operand.map(x => x.toLong)\n        val opLength = opList.length\n       \
    \ val operandLength = operandList.length\n        val opIndex = 0\n        val\
    \ operandIndex = 0\n        val result = 0\n        while(opIndex < opLength &&\
    \ operandIndex < operandLength) {\n            val op = opList(opIndex)\n    \
    \        val operand = operandList(operandIndex)\n            val opResult = if\
    \ (op == '+') operand.plus(result) else operand.minus(result)\n            val\
    \ operandResult = if (op == '-') operand.minus(result) else operand.plus(result)\n\
    \            val opResultFloor = if (op == '/') operand.floorDiv(result) else\
    \ operand.floorMod(result)\n            val operandResultFloor = if (op == '%')\
    \ operand.floorMod(result) else operand.floorDiv(result)\n            val opResultExp\
    \ = if (op == '**') operand.pow(result) else operand.pow(result)\n           \
    \ val operandResultExp = if (op == '**') operand.pow(result) else operand.pow(result)\n\
    \            val opResultMul = if (op == '*') operand.times(result) else operand.times(result)\n\
    \            val operandResultMul = if (op == '*') operand.times(result) else\
    \ operand.times(result)\n            val opResultAdd = if (op == '+') operand.plus(result)\
    \ else operand.minus(result)\n            val operandResultAdd = if (op == '+')\
    \ operand.plus(result) else operand.minus(result)\n            val opResultSub\
    \ = if (op == '-') operand.minus(result) else operand.plus(result)\n         \
    \   val operandResultSub = if (op == '-') operand.minus(result) else operand.plus(result)\n\
    \            val opResultMulFloor = if (op == '*') operand.floorMod(result) else\
    \ operand.floorDiv(result)\n            val operandResultMulFloor = if (op ==\
    \ '*') operand.floorMod(result) else operand.floorDiv(result)\n            val\
    \ opResultMulExp = if (op == '*') operand.pow(result) else operand.pow(result)\n\
    \            val operandResultMulExp = if (op == '*') operand.pow(result) else\
    \ operand.pow(result)\n            val opResultAddFloor = if (op == '+') operand.plus(result)\
    \ else operand.minus(result)\n            val operandResultAddFloor = if (op ==\
    \ '+') operand.plus(result) else operand.minus(result)\n            val opResultAddExp\
    \ = if (op == '+') operand.plus(result) else \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpparwd50f.scala:37:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mopResultExp\e[0m = \e\
    [33mif\e[0m (op == \e[31m'**\e[0m') operand.pow(result) \e[33melse\e[0m operand.pow(result)\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                                           unclosed character literal\n\
    \e[31m\e[31m-- Error: /tmp/tmpparwd50f.scala:38:48 -----------------------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e[0m \e[36moperandResultExp\e[0m\
    \ = \e[33mif\e[0m (op == \e[31m'**\e[0m') operand.pow(result) \e[33melse\e[0m\
    \ operand.pow(result)\n\e[31m\e[31m   |\e[0m                                 \
    \               ^\e[0m\n\e[31m   |\e[0m                                      \
    \        unclosed character literal\n\e[31m\e[31m-- Error: /tmp/tmpparwd50f.scala:37:40\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m37 |\e[0m       \
    \     \e[33mval\e[0m \e[36mopResultExp\e[0m = \e[33mif\e[0m (op == \e[31m'**\e\
    [0m') operand.pow(result) \e[33melse\e[0m operand.pow(result)\n\e[31m\e[31m  \
    \ |\e[0m                                        ^\e[0m\n\e[31m   |\e[0msymbol\
    \ literal '** is no longer supported,\n\e[31m   |\e[0muse a string literal \"\
    **\" or an application Symbol(\"**\") instead,\n\e[31m   |\e[0mor enclose in braces\
    \ '{**} if you want a quoted expression.\n\e[31m   |\e[0mFor now, you can also\
    \ `import language.deprecated.symbolLiterals` to accept\n\e[31m   |\e[0mthe idiom,\
    \ but this possibility might no longer be available in the future.\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpparwd50f.scala:23:35 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mopList\e[0m = op.map(\e\
    [36mx\e[0m => x.toChar)\n\e[31m\e[31m   |\e[0m                               \
    \  ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 value toChar\
    \ is not a member of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpparwd50f.scala:33:50\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m\
    \ \e[36mopResult\e[0m = \e[33mif\e[0m (op == \e[31m'+'\e[0m) operand.plus(result)"
  stdout: ''
  timestamp: 1659792969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val opLen =\
    \ opList.length\n        val operandList = operand.map(_.toLong)\n        val\
    \ operandLen = operandList.length\n        val result = operandList.foldLeft(0)((acc,\
    \ x) => acc + (opList.indexOf(x) * operandList(x)))\n        result\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\"\
    , \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) ==\
    \ (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj4asqypd.scala:27:96\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = operandList.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc\
    \ + (opList.indexOf(x) * operandList(x)))\n\e[31m\e[31m   |\e[0m             \
    \                                                                            \
    \       ^\e[0m\n\e[31m   |\e[0m                                              \
    \      Found:    (x : Long)\n\e[31m   |\e[0m                                 \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operands.size - 1\n        val operandLenMinusOne\
    \ = operandLen - 1\n        val opLenMinusOneMinusOne = opLen - 1 - 1\n      \
    \  val operandLenMinusOneMinusOne = operandLen - 1 - 1\n        val opLenMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOne = operandLen\
    \ - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOne = opLen - 1 -\
    \ 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOne = operandLen\
    \ - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val\
    \ opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = opLen\
    \ - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMin\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6l8riscb.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp6l8riscb.scala:43:5 ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.mkString(\"+\")\n        val operandList\
    \ = operand.mkString(\"+\")\n        val ops = opList.split(\"\\\\+\")\n     \
    \   val operands = operandList.split(\"\\\\+\")\n        val opLen = ops.size\n\
    \        val opLen2 = opLen/2\n        val opLen3 = opLen2/2\n        val opLen4\
    \ = opLen2/3\n        val opLen5 = opLen2/4\n        val opLen6 = opLen2/5\n \
    \       val opLen7 = opLen2/6\n        val opLen8 = opLen2/7\n        val opLen9\
    \ = opLen2/8\n        val opLen10 = opLen2/9\n        val opLen11 = opLen2/10\n\
    \        val opLen12 = opLen2/11\n        val opLen13 = opLen2/12\n        val\
    \ opLen14 = opLen2/13\n        val opLen15 = opLen2/14\n        val opLen16 =\
    \ opLen2/15\n        val opLen17 = opLen2/16\n        val opLen18 = opLen2/17\n\
    \        val opLen19 = opLen2/18\n        val opLen20 = opLen2/19\n        val\
    \ opLen21 = opLen2/20\n        val opLen22 = opLen2/21\n        val opLen23 =\
    \ opLen2/22\n        val opLen24 = opLen2/23\n        val opLen25 = opLen2/24\n\
    \        val opLen26 = opLen2/25\n        val opLen27 = opLen2/26\n        val\
    \ opLen28 = opLen2/27\n        val opLen29 = opLen2/28\n        val opLen30 =\
    \ opLen2/29\n        val opLen31 = opLen2/30\n        val opLen32 = opLen2/31\n\
    \        val opLen33 = opLen2/32\n        val opLen34 = opLen2/33\n        val\
    \ opLen35 = opLen2/34\n        val opLen36 = opLen2/35\n        val opLen37 =\
    \ opLen2/36\n        val opLen38 = opLen2/37\n        val opLen39 = opLen2/38\n\
    \        val opLen40 = opLen2/39\n        val opLen41 = opLen2/40\n        val\
    \ opLen42 = opLen2/41\n        val opLen43 = opLen2/42\n        val opLen44 =\
    \ opLen2/43\n        val opLen\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps0p96v2b.scala:72:4 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmps0p96v2b.scala:72:5 ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toLong).toList\n        val operatorList = opList.filterNot(_.equals(\"\
    *\"))\n        val operandList = operandList.filterNot(_.equals(\"*\"))\n    \
    \    val operatorList = operatorList.filterNot(_.equals(\"/\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"/\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    **\"))\n        val operandList = operandList.filterNot(_.equals(\"**\"))\n  \
    \      val operatorList = operatorList.filterNot(_.equals(\"+\"))\n        val\
    \ operandList = operandList.filterNot(_.equals(\"+\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"-\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    -\"))\n        val operatorList = operatorList.filterNot(_.equals(\"*\"))\n  \
    \      val operandList = operandList.filterNot(_.equals(\"*\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"//\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    //\"))\n        val operatorList = operatorList.filterNot(_.equals(\"**\"))\n\
    \        val operandList = operandList.filterNot(_.equals(\"**\"))\n        val\
    \ operatorList = operatorList.filterNot(_.equals(\"+\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"+\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    -\"))\n        val operandList = operandList.filterNot(_.equals(\"-\"))\n    \
    \    val operatorList = operatorList.filterNot(_.equals(\"*\"))\n        val operandList\
    \ = operandList.filterNot(_.equals(\"*\"))\n        val operatorList = operatorList.filterNot(_.equals(\"\
    //\"))\n        val operandList = operandList.filterNot(_.equals(\"//\"))\n  \
    \      val operatorList = operatorList.filterNot(_.equals(\"**\"))\n        val\
    \ operandList = operandList.filterNot(_.equals(\"**\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"+\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    +\"))\n        val operatorList = operatorList.filterNot(_.equals(\"-\"))\n  \
    \      val operandList = operandList.filterNot(_.equals(\"-\"))\n        val operatorList\
    \ = operatorList.filterNot(_.equals(\"*\"))\n        val operandList = operandList.filterNot(_.equals(\"\
    *\"))\n        val operatorList = operatorList.filterNo\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp07qsb1rq.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36moperandList\e[0m = operandList.filterNot(_.equals(\e\
    [31m\"*\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp07qsb1rq.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36moperatorList\e[0m = operatorList.filterNot(_.equals(\e\
    [31m\"/\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperatorList is already defined as \e[33mvalue\e[0m \e[35moperatorList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp07qsb1rq.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36moperandList\e[0m = operandList.filterNot(_.equals(\e\
    [31m\"/\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp07qsb1rq.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36moperatorList\e[0m = operatorList.filterNot(_.equals(\e\
    [31m\"**\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperatorList is already defined as \e[33mvalue\e[0m \e[35moperatorList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp07qsb1rq.scala:30:12 -------------------"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(x => x.toChar).toList\n        val operandList\
    \ = operand.map(x => x.toLong).toList\n        val opLen = opList.length\n   \
    \     val operandLen = operandList.length\n        val opMap = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap = new mutable.HashMap[String, Long]()\n    \
    \    val opMap2 = new mutable.HashMap[String, Long]()\n        val operandMap2\
    \ = new mutable.HashMap[String, Long]()\n        val opMap3 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap3 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap4 = new mutable.HashMap[String, Long]()\n        val operandMap4\
    \ = new mutable.HashMap[String, Long]()\n        val opMap5 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap5 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap6 = new mutable.HashMap[String, Long]()\n        val operandMap6\
    \ = new mutable.HashMap[String, Long]()\n        val opMap7 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap7 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap8 = new mutable.HashMap[String, Long]()\n        val operandMap8\
    \ = new mutable.HashMap[String, Long]()\n        val opMap9 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap9 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap10 = new mutable.HashMap[String, Long]()\n        val operandMap10\
    \ = new mutable.HashMap[String, Long]()\n        val opMap11 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap11 = new mutable.HashMap[String, Long]()\n  \
    \      val opMap12 = new mutable.HashMap[String, Long]()\n        val operandMap12\
    \ = new mutable.HashMap[String, Long]()\n        val opMap13 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap13 = new mutable.HashMap[String, Long]()\n  \
    \      val opMap14 = new mutable.HashMap[String, Long]()\n        val operandMap14\
    \ = new mutable.HashMap[String, Long]()\n        val opMap15 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap15 = new mutable.HashMap[String, Long]()\n  \
    \      val opMap16 = new mutable.HashMap[String, Long]()\n        val \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp163moacu.scala:58:11 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp163moacu.scala:23:35 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mopList\e[0m = op.map(\e\
    [36mx\e[0m => x.toChar).toList\n\e[31m\e[31m   |\e[0m                        \
    \         ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 value\
    \ toChar is not a member of String\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp163moacu.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp163moacu.scala:28:29 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36moperandMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp163moacu.scala:29:25 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mopMap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp163moacu.scala:30:30\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap2\e[0m = \e[33m"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(x => x.toChar)\n        val operandList\
    \ = operand.map(x => x.toLong)\n        val opLength = opList.length\n       \
    \ val operandLength = operandList.length - 1\n        val opArray = opList.map(x\
    \ => x.toInt)\n        val operandArray = operandList.map(x => x.toInt)\n    \
    \    val opArrayLength = opArray.length\n        val operandArrayLength = operandArray.length\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = op\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8yakcvzo.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8yakcvzo.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m \e[35moperandArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8yakcvzo.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8yakcvzo.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m \e[35moperandArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8yakcvzo.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opArr = ops.toArray\n\
    \        val opLen = opArr.length\n        val opArr_1 = opArr.drop(1)\n     \
    \   val opArr_2 = opArr.drop(2)\n        val opArr_3 = opArr.drop(3)\n       \
    \ val opArr_4 = opArr.drop(4)\n        val opArr_5 = opArr.drop(5)\n        val\
    \ opArr_6 = opArr.drop(6)\n        val opArr_7 = opArr.drop(7)\n        val opArr_8\
    \ = opArr.drop(8)\n        val opArr_9 = opArr.drop(9)\n        val opArr_10 =\
    \ opArr.drop(10)\n        val opArr_11 = opArr.drop(11)\n        val opArr_12\
    \ = opArr.drop(12)\n        val opArr_13 = opArr.drop(13)\n        val opArr_14\
    \ = opArr.drop(14)\n        val opArr_15 = opArr.drop(15)\n        val opArr_16\
    \ = opArr.drop(16)\n        val opArr_17 = opArr.drop(17)\n        val opArr_18\
    \ = opArr.drop(18)\n        val opArr_19 = opArr.drop(19)\n        val opArr_20\
    \ = opArr.drop(20)\n        val opArr_21 = opArr.drop(21)\n        val opArr_22\
    \ = opArr.drop(22)\n        val opArr_23 = opArr.drop(23)\n        val opArr_24\
    \ = opArr.drop(24)\n        val opArr_25 = opArr.drop(25)\n        val opArr_26\
    \ = opArr.drop(26)\n        val opArr_27 = opArr.drop(27)\n        val opArr_28\
    \ = opArr.drop(28)\n        val opArr_29 = opArr.drop(29)\n        val opArr_30\
    \ = opArr.drop(30)\n        val opArr_31 = opArr.drop(31)\n        val opArr_32\
    \ = opArr.drop(32)\n        val opArr_33 = opArr.drop(33)\n        val opArr_34\
    \ = opArr.drop(34)\n        val opArr_35 = opArr.drop(35)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_2qtjzjs.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toLong).toList\n        val operatorList = opList.filter(_.contains(\"\
    +\"))\n        val operatorList2 = opList.filter(_.contains(\"-\"))\n        val\
    \ operatorList3 = opList.filter(_.contains(\"*\"))\n        val operatorList4\
    \ = opList.filter(_.contains(\"//\"))\n        val operatorList5 = opList.filter(_.contains(\"\
    **\"))\n        val operatorList6 = opList.filter(_.contains(\"%\"))\n       \
    \ val operatorList7 = opList.filter(_.contains(\"&\"))\n        val operatorList8\
    \ = opList.filter(_.contains(\"|\"))\n        val operatorList9 = opList.filter(_.contains(\"\
    ^\"))\n        val operatorList10 = opList.filter(_.contains(\"~\"))\n       \
    \ val operatorList11 = opList.filter(_.contains(\"?\"))\n        val operatorList12\
    \ = opList.filter(_.contains(\":\"))\n        val operatorList13 = opList.filter(_.contains(\"\
    ,\"))\n        val operatorList14 = opList.filter(_.contains(\".\"))\n       \
    \ val operatorList15 = opList.filter(_.contains(\":=\"))\n        val operatorList16\
    \ = opList.filter(_.contains(\";\"))\n        val operatorList17 = opList.filter(_.contains(\"\
    :!\"))\n        val operatorList18 = opList.filter(_.contains(\":<\"))\n     \
    \   val operatorList19 = opList.filter(_.contains(\":>\"))\n        val operatorList20\
    \ = opList.filter(_.contains(\":=\"))\n        val operatorList21 = opList.filter(_.contains(\"\
    :!=\"))\n        val operatorList22 = opList.filter(_.contains(\":<=\"))\n   \
    \     val operatorList23 = opList.filter(_.contains(\":>=\"))\n        val operatorList24\
    \ = opList.filter(_.contains(\":=\"))\n        val operatorList25 = opList.filter(_.contains(\"\
    :!=\"))\n        val operatorList26 = opList.filter(_.contains(\":<=\"))\n   \
    \     val operatorList27 = opList.filter(_.contains(\":>=\"))\n        val operatorList28\
    \ = opList.filter(_.contains(\":=\"))\n        val operatorList29 = opList.filter(_.contains(\"\
    :!=\"))\n        val operatorList30 = opList.filter(_.contains(\":<=\"))\n   \
    \     val operatorList31 = opList.filter(_.contains(\":>=\"))\n        val operatorList32\
    \ = opList.filter(_.contain\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp62i72m14.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp62i72m14.scala:56:45\
    \ ------------------------\e[0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e\
    [36moperatorList32\e[0m = opList.filter(_.contain\n\e[31m\e[31m   |\e[0m     \
    \                                      ^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value\
    \ contain is not a member of String - did you mean _$34.contains?\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp62i72m14.scala:57:5 ---------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length\n        val opIndex = opList.indexOf(\"+\")\n        val\
    \ opIndex2 = opList.indexOf(\"-\")\n        val opIndex3 = opList.indexOf(\"*\"\
    )\n        val opIndex4 = opList.indexOf(\"/\")\n        val opIndex5 = opList.indexOf(\"\
    **\")\n        val opIndex6 = opList.indexOf(\"%\")\n        val opIndex7 = opList.indexOf(\"\
    //\")\n        val opIndex8 = opList.indexOf(\"&\")\n        val opIndex9 = opList.indexOf(\"\
    |\")\n        val opIndex10 = opList.indexOf(\"^\")\n        val opIndex11 = opList.indexOf(\"\
    ~\")\n        val opIndex12 = opList.indexOf(\"<<\")\n        val opIndex13 =\
    \ opList.indexOf(\">>\")\n        val opIndex14 = opList.indexOf(\"==\")\n   \
    \     val opIndex15 = opList.indexOf(\"!=\")\n        val opIndex16 = opList.indexOf(\"\
    <\")\n        val opIndex17 = opList.indexOf(\">\")\n        val opIndex18 = opList.indexOf(\"\
    <=\")\n        val opIndex19 = opList.indexOf(\">=\")\n        val opIndex20 =\
    \ opList.indexOf(\"==\")\n        val opIndex21 = opList.indexOf(\"!=\")\n   \
    \     val opIndex22 = opList.indexOf(\"&\")\n        val opIndex23 = opList.indexOf(\"\
    |\")\n        val opIndex24 = opList.indexOf(\"^\")\n        val opIndex25 = opList.indexOf(\"\
    ~\")\n        val opIndex26 = opList.indexOf(\"<<\")\n        val opIndex27 =\
    \ opList.indexOf(\">>\")\n        val opIndex28 = opList.indexOf(\"==\")\n   \
    \     val opIndex29 = opList.indexOf(\"!=\")\n        val opIndex30 = opList.indexOf(\"\
    <\")\n        val opIndex31 = opList.indexOf(\">\")\n        val opIndex32 = opList.indexOf(\"\
    <<\")\n        val opIndex33 = opList.indexOf(\">>\")\n        val opIndex34 =\
    \ opList.indexOf(\"==\")\n        val opIndex35 = opList.indexOf(\"!=\")\n   \
    \     val opIndex36 = opList.indexOf(\"<\")\n        val opIndex37 = opList.indexOf(\"\
    >\")\n        val opIndex38 = opList.indexOf(\"<<\")\n        val opIndex39 =\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpumdyb4sy.scala:65:23 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \e[36mopIndex39\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpumdyb4sy.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toLong).toList\n        val opLength = opList.length\n     \
    \   val operandLength = operandList.length - 1\n        val opMap = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap = new mutable.HashMap[String, Long]()\n    \
    \    val opMapKeys = opList.map(x => x.toLowerCase)\n        val operandMapKeys\
    \ = operandList.map(x => x.toLong)\n        val opMapValues = opList.map(x =>\
    \ x.toLong)\n        val operandMapValues = operandList.map(x => x.toLong)\n \
    \       val opMapKeySet = opMapKeys.toSet\n        val operandMapKeySet = operandMapKeys.toSet\n\
    \        val opMapValueSet = opMapValues.toSet\n        val operandMapValueSet\
    \ = operandMapValues.toSet\n        val opMapKeysLength = opMapKeySet.size\n \
    \       val operandMapKeysLength = operandMapKeySet.size\n        val opMapValuesLength\
    \ = opMapValueSet.size\n        val operandMapValuesLength = operandMapValueSet.size\n\
    \        val opMapKeysSet = opMapKeySet.toSet\n        val operandMapKeysSet =\
    \ operandMapKeySet.toSet\n        val opMapValuesSet = opMapValueSet.toSet\n \
    \       val operandMapValuesSet = operandMapValueSet.toSet\n        val opMapKeysSetLength\
    \ = opMapKeysSet.size\n        val operandMapKeysSetLength = operandMapKeysSet.size\n\
    \        val opMapValuesSetLength = opMapValuesSet.size\n        val operandMapValuesSetLength\
    \ = operandMapValuesSet.size\n        val opMapKeysSetSet = opMapKeysSet.toSet\n\
    \        val operandMapKeysSetSet = operandMapKeysSet.toSet\n        val opMapValuesSetSet\
    \ = opMapValuesSet.toSet\n        val operandMapValuesSetSet = operandMapValuesSet.toSet\n\
    \        val opMapKeysSetSetLength = opMapKeysSetSet.size\n        val operandMapKeysSetSetLength\
    \ = operandMapKeysSetSet.size\n        val opMapValuesSetSetLength = opMapValuesSetSet.size\n\
    \        val operandMapValuesSetSetLength = operandMapValuesSetSet.size\n    \
    \    val opMapKeysSetSetSet = opMapKeysSetSet.toSet\n        val operandMapKeysSetSetSet\
    \ = operandMapKeysSet\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg1hucnhi.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg1hucnhi.scala:28:29\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg1hucnhi.scala:59:5 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length\n        val opArray = Array.ofDim[String](opLength)\n\
    \        val operandArray = Array.ofDim[Long](operandLength)\n        var i =\
    \ 0\n        while (i < opLength) {\n            opArray(i) = opList(i)\n    \
    \        i += 1\n        }\n        var j = 0\n        while (j < operandLength)\
    \ {\n            operandArray(j) = operandList(j)\n            j += 1\n      \
    \  }\n        val opArrayLength = opArray.length\n        val operandArrayLength\
    \ = operandArray.length\n        val opArrayLength = opArrayLength - 1\n     \
    \   val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr3g8kfwy.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpr3g8kfwy.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35moperandArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpr3g8kfwy.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpr3g8kfwy.scala:44:12 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35moperandArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpr3g8kfwy.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m "
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opLen = ops.size\n\
    \        val opList = ops.toList\n        val operandList = operand.toList\n \
    \       val operandLen = operandList.size\n        val operandList = operandList.toList\n\
    \        val operandListLen = operandList.size\n        val operandListLenMinusOne\
    \ = operandListLen - 1\n        val operandListLenMinusOneMinusOne = operandListLen\
    \ - 2\n        val operandListLenMinusOneMinusOneMinusOne = operandListLen - 3\n\
    \        val operandListLenMinusOneMinusOneMinusOneMinusOne = operandListLen -\
    \ 4\n        val operandListLenMinusOneMinusOneMinusOneMinusOneMinusOne = operandListLen\
    \ - 5\n        val operandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandListLen - 6\n        val operandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandListLen - 7\n        val operandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandListLen - 8\n        val operandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandListLen - 9\n        val operandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandListLen - 10\n        val operandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandListLen - 11\n        val operandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandListLen - 12\n        val operandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandListLen - 13\n        val operandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinus\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsiptx615.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsiptx615.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandList\e[0m = operandList.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsiptx615.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36moperandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = operandListLen - \e[31m12\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  operandListLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpsiptx615.scala:44:5 ---------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val operandArrayLength = operandArray.length\n        val result = operandArray(0)\n\
    \        val op1 = opArray(0)\n        val op2 = opArray(1)\n        val op3 =\
    \ opArray(2)\n        val op4 = opArray(3)\n        val op5 = opArray(4)\n   \
    \     val op6 = opArray(5)\n        val op7 = opArray(6)\n        val op8 = opArray(7)\n\
    \        val op9 = opArray(8)\n        val op10 = opArray(9)\n        val op11\
    \ = opArray(10)\n        val op12 = opArray(11)\n        val op13 = opArray(12)\n\
    \        val op14 = opArray(13)\n        val op15 = opArray(14)\n        val op16\
    \ = opArray(15)\n        val op17 = opArray(16)\n        val op18 = opArray(17)\n\
    \        val op19 = opArray(18)\n        val op20 = opArray(19)\n        val op21\
    \ = opArray(20)\n        val op22 = opArray(21)\n        val op23 = opArray(22)\n\
    \        val op24 = opArray(23)\n        val op25 = opArray(24)\n        val op26\
    \ = opArray(25)\n        val op27 = opArray(26)\n        val op28 = opArray(27)\n\
    \        val op29 = opArray(28)\n        val op30 = opArray(29)\n        val op31\
    \ = opArray(30)\n        val op32 = opArray(31)\n        val op33 = opArray(32)\n\
    \        val op34 = opArray(33)\n        val op35 = opArray(34)\n        val op36\
    \ = opArray(35)\n        val op37 = opArray(36)\n        val op38 = opArray(37)\n\
    \        val op39 = opArray(38)\n        val op40 = opArray(39)\n        val op41\
    \ = opArray(40)\n        val op42 = opArray(41)\n        val op43 = opArray(42)\n\
    \        val op44 = opArray(43)\n        val op45 = opArray(44)\n        val op46\
    \ = opArray(45)\n        val op47 = opArray(46)\n        val op48 = opArray(47)\n\
    \        val op49 = opArray(48)\n        val op50 = opArray(49)\n        \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu37k8zgz.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val opArray\
    \ = ops.toArray\n        val operandArray = operand.toArray\n        val length\
    \ = opArray.length\n        val result = operandArray(0)\n        val op1 = opArray(0)\n\
    \        val op2 = opArray(1)\n        val op3 = opArray(2)\n        val op4 =\
    \ opArray(3)\n        val op5 = opArray(4)\n        val op6 = opArray(5)\n   \
    \     val op7 = opArray(6)\n        val op8 = opArray(7)\n        val op9 = opArray(8)\n\
    \        val op10 = opArray(9)\n        val op11 = opArray(10)\n        val op12\
    \ = opArray(11)\n        val op13 = opArray(12)\n        val op14 = opArray(13)\n\
    \        val op15 = opArray(14)\n        val op16 = opArray(15)\n        val op17\
    \ = opArray(16)\n        val op18 = opArray(17)\n        val op19 = opArray(18)\n\
    \        val op20 = opArray(19)\n        val op21 = opArray(20)\n        val op22\
    \ = opArray(21)\n        val op23 = opArray(22)\n        val op24 = opArray(23)\n\
    \        val op25 = opArray(24)\n        val op26 = opArray(25)\n        val op27\
    \ = opArray(26)\n        val op28 = opArray(27)\n        val op29 = opArray(28)\n\
    \        val op30 = opArray(29)\n        val op31 = opArray(30)\n        val op32\
    \ = opArray(31)\n        val op33 = opArray(32)\n        val op34 = opArray(33)\n\
    \        val op35 = opArray(34)\n        val op36 = opArray(35)\n        val op37\
    \ = opArray(36)\n        val op38 = opArray(37)\n        val op39 = opArray(38)\n\
    \        val op40 = opArray(39)\n        val op41 = opArray(40)\n        val op42\
    \ = opArray(41)\n        val op43 = opArray(42)\n        val op44 = opArray(43)\n\
    \        val op45 = opArray(44)\n        val op46 = opArray(45)\n        val op47\
    \ = opArray(46)\n        val op48 = opArray(47)\n        val op49 = opArray(48)\n\
    \        val op50 = opArray(49)\n        val op51 = opArray(50)\n\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\"\
    , \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) ==\
    \ (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5_nikphb.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opCount = ops.size\n        val operandCount\
    \ = operands.size\n        val opIndex = ops.indexOf(\"+\")\n        val opIndex2\
    \ = ops.indexOf(\"-\")\n        val opIndex3 = ops.indexOf(\"*\")\n        val\
    \ opIndex4 = ops.indexOf(\"/\")\n        val opIndex5 = ops.indexOf(\"**\")\n\
    \        val opIndex6 = ops.indexOf(\"//\")\n        val opIndex7 = ops.indexOf(\"\
    %\")\n        val opIndex8 = ops.indexOf(\"*\")\n        val opIndex9 = ops.indexOf(\"\
    +\")\n        val opIndex10 = ops.indexOf(\"*\")\n        val opIndex11 = ops.indexOf(\"\
    +\")\n        val opIndex12 = ops.indexOf(\"*\")\n        val opIndex13 = ops.indexOf(\"\
    +\")\n        val opIndex14 = ops.indexOf(\"*\")\n        val opIndex15 = ops.indexOf(\"\
    +\")\n        val opIndex16 = ops.indexOf(\"*\")\n        val opIndex17 = ops.indexOf(\"\
    +\")\n        val opIndex18 = ops.indexOf(\"*\")\n        val opIndex19 = ops.indexOf(\"\
    +\")\n        val opIndex20 = ops.indexOf(\"*\")\n        val opIndex21 = ops.indexOf(\"\
    +\")\n        val opIndex22 = ops.indexOf(\"*\")\n        val opIndex23 = ops.indexOf(\"\
    +\")\n        val opIndex24 = ops.indexOf(\"*\")\n        val opIndex25 = ops.indexOf(\"\
    +\")\n        val opIndex26 = ops.indexOf(\"*\")\n        val opIndex27 = ops.indexOf(\"\
    +\")\n        val opIndex28 = ops.indexOf(\"*\")\n        val opIndex29 = ops.indexOf(\"\
    +\")\n        val opIndex30 = ops.indexOf(\"*\")\n        val opIndex31 = ops.indexOf(\"\
    +\")\n        val opIndex32 = ops.indexOf(\"*\")\n        val opIndex33 = ops.indexOf(\"\
    +\")\n        val opIndex34 = ops.indexOf(\"*\")\n        val opIndex35 = ops.indexOf(\"\
    +\")\n        val opIndex36 = ops.indexOf(\"*\")\n        val opIndex37 = ops.indexOf(\"\
    +\")\n        val opIndex38 = ops.indexOf(\"*\")\n        val opIndex39 = ops.indexOf(\"\
    +\")\n        val opIndex40 = ops.indexOf(\"*\")\n        val opIndex41 = ops.indexOf(\"\
    +\")\n        val opIndex42 = ops.indexOf(\"*\")\n        val opIndex43 = ops.indexOf(\"\
    +\")\n        val opIndex44 = ops.indexOf(\"*\")\n        val \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpoj0do0f1.scala:71:11 ---------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoj0do0f1.scala:72:5 ---------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operands.size - 1\n        val operandLenMinusOne\
    \ = operandLen - 1\n        val opLenMinusOneMinusOne = opLen - 1 - 1\n      \
    \  val opLenMinusOneMinusOneMinusOne = opLen - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n      \
    \  val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne =\
    \ opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 -\
    \ 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6smod0x3.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp6smod0x3.scala:40:5 ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opList = ops.toList\n\
    \        val opLen = opList.size\n        val operandList = operand.toList\n \
    \       val operandLen = operandList.size\n        val opLenMinusOne = opLen -\
    \ 1\n        val operandLenMinusOne = operandLen - 1\n        val result = operandList(0)\n\
    \        val op1 = operandList(1)\n        val op2 = operandList(2)\n        val\
    \ op3 = operandList(3)\n        val op4 = operandList(4)\n        val op5 = operandList(5)\n\
    \        val op6 = operandList(6)\n        val op7 = operandList(7)\n        val\
    \ op8 = operandList(8)\n        val op9 = operandList(9)\n        val op10 = operandList(10)\n\
    \        val op11 = operandList(11)\n        val op12 = operandList(12)\n    \
    \    val op13 = operandList(13)\n        val op14 = operandList(14)\n        val\
    \ op15 = operandList(15)\n        val op16 = operandList(16)\n        val op17\
    \ = operandList(17)\n        val op18 = operandList(18)\n        val op19 = operandList(19)\n\
    \        val op20 = operandList(20)\n        val op21 = operandList(21)\n    \
    \    val op22 = operandList(22)\n        val op23 = operandList(23)\n        val\
    \ op24 = operandList(24)\n        val op25 = operandList(25)\n        val op26\
    \ = operandList(26)\n        val op27 = operandList(27)\n        val op28 = operandList(28)\n\
    \        val op29 = operandList(29)\n        val op30 = operandList(30)\n    \
    \    val op31 = operandList(31)\n        val op32 = operandList(32)\n        val\
    \ op33 = operandList(33)\n        val op34 = operandList(34)\n        val op35\
    \ = operandList(35)\n        val op36 = operandList(36)\n        val op37 = operandList(37)\n\
    \        val op38 = operandList(38)\n        val op39 = operandList(39)\n    \
    \    val op40 = operandList(40)\n        val op41 = operandList(41)\n        val\
    \ op42 = operandList(42)\n        val op43 = operandList(43)\n        val op44\
    \ = operandList(44)\n        val op45 = operandList(45)\n        val op46 = operandList(46)\n\
    \        val op47 = operandList(47)\n        val op48 = operand\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2daace2d.scala:79:5\
    \ ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val operands\
    \ = operand.map(_.toInt).toList\n        val opLen = ops.size\n        val operandLen\
    \ = operands.size\n        val opIndex = ops.indexOf(\"*\")\n        val opLenMinusOne\
    \ = opLen - 1\n        val opLenMinusOneMinusOne = opLenMinusOne - 1\n       \
    \ val opLenMinusOneMinusOneMinusOne = opLenMinusOneMinusOne - 1\n        val opLenMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOne - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOne - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n\
    \        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp82tskv9x.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp82tskv9x.scala:33:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                              ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp82tskv9x.scala:34:84\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne -\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                        \
    \                                            ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp82tskv9x.scala:35:92\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                      ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-expla"
  stdout: ''
  timestamp: 1659792971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length - 1\n        val opMap = new mutable.HashMap[String, Long]()\n\
    \        val operandMap = new mutable.HashMap[String, Long]()\n        var result\
    \ = 0L\n        val opIndex = 0\n        val operandIndex = 0\n        while(operandIndex\
    \ < operandLength) {\n            val opKey = opList(opIndex)\n            val\
    \ operandValue = operandList(operandIndex)\n            val opValue = opMap.get(opKey)\n\
    \            if(opValue == null) {\n                opMap.put(opKey, operandValue)\n\
    \            } else {\n                operandMap.put(opKey, operandValue)\n \
    \           }\n            operandIndex += 1\n            opIndex += 1\n     \
    \   }\n        val opKeys = opMap.keySet\n        val opValues = opMap.values.toList\n\
    \        val operandKeys = operandMap.keySet\n        val operandValues = operandMap.values.toList\n\
    \        val opLength = opValues.length\n        val operandLength = operandValues.length\n\
    \        val opIndex = 0\n        val operandIndex = 0\n        while(operandIndex\
    \ < operandLength) {\n            val opKey = opKeys(opIndex)\n            val\
    \ operandValue = operandValues(operandIndex)\n            val opValue = opValues.get(opIndex)\n\
    \            result += opValue * operandValue\n            operandIndex += 1\n\
    \            opIndex += 1\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbd01s0yk.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mopLength\e[0m = opValues.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopLength is already defined as \e[33mvalue\e[0m \e[35mopLength\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbd01s0yk.scala:49:12 ---------------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m        \e[33mval\e[0m \e[36moperandLength\e[0m = operandValues.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0moperandLength is already defined as \e[33mvalue\e[0m \e[35moperandLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbd01s0yk.scala:50:12 ---------------------------\e[0m\e[0m\n\e\
    [31m50 |\e[0m        \e[33mval\e[0m \e[36mopIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopIndex is already defined\
    \ as \e[33mvalue\e[0m \e[35mopIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbd01s0yk.scala:51:12 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36moperandIndex\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0moperandIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35moperandIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbd01s0yk.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1659792971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opLen = ops.length\n\
    \        val opList = ops.map(_.toUpperCase)\n        val opLen = opList.length\n\
    \        val operandLen = operand.length\n        val operandList = operand.map(_.toLong)\n\
    \        val operandLen = operandList.length\n        val opListLen = opList.length\n\
    \        val opListLen = opListLen\n        val opListLen = opListLen\n      \
    \  val opListLen = opListLen\n        val opListLen = opListLen\n        val opListLen\
    \ = opListLen\n        val opListLen = opListLen\n        val opListLen = opListLen\n\
    \        val opListLen = opListLen\n        val opListLen = opListLen\n      \
    \  val opListLen = opListLen\n        val opListLen = opListLen\n        val opListLen\
    \ = opListLen\n        val opListLen = opListLen\n        val opListLen = opListLen\n\
    \        val opListLen = opListLen\n        val opListLen = opListLen\n      \
    \  val opListLen = opListLen\n        val opListLen = opListLen\n        val opListLen\
    \ = opListLen\n        val opListLen = opListLen\n        val opListLen = opListLen\n\
    \        val opListLen = opListLen\n        val opListLen = opListLen\n      \
    \  val opListLen = opListLen\n        val opListLen = opListLen\n        val opListLen\
    \ = opListLen\n        val opListLen = opListLen\n        val opListLen = opListLen\n\
    \        val opListLen = opListLen\n        val opListLen = opListLen\n      \
    \  val opListLen = opListLen\n        val opListLen = opListLen\n        val opListLen\
    \ = opListLen\n        val opListLen = opListLen\n        val opListLen = opListLen\n\
    \        val opListLen = opListLen\n        val opListLen = opListLen\n      \
    \  val opListLen = opListLen\n        val opListLen = opListLen\n        val opListLen\
    \ = opListLen\n        val opListLen = opListLen\n        val opListLen = opListLen\n\
    \        val opListLen = opListLen\n        val opList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx7wicp82.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx7wicp82.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLen\e[0m = opList.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopLen is already defined as \e[33mvalue\e[0m \e[35mopLen\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx7wicp82.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36moperandLen\e[0m = operandList.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0moperandLen is already defined as \e[33mvalue\e[0m \e[35moperandLen\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx7wicp82.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mopListLen\e[0m = opListLen\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopListLen\
    \ is already defined as \e[33mvalue\e[0m \e[35mopListLen\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx7wicp82.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopListLen\e[0m = opListLen\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopListLen is already defined as \e[33mvalue\e[0m \e[35mopListLen\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpx7wicp82.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mopListLen\e[0m = opListLen\n\e[31m\e\
    [31m "
  stdout: ''
  timestamp: 1659792971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opLen = ops.size\n\
    \        val opLenMinusOne = opLen - 1\n        val operandLen = operand.size\n\
    \        val operandLenMinusOne = operandLen - 1\n        val ops = ops.toList\n\
    \        val operands = operand.toList\n        val operandsLen = operands.size\n\
    \        val operandsLenMinusOne = operandsLen - 1\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandsLenMinusOne = operandsLen - 1\n        val\
    \ opLenMinusOne = opLen - 1\n        val operandsLenMinusOne = operandsLen - 1\n\
    \        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne = operandsLen\
    \ - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne = opLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val opLenMinusOne\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9ergmgis.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9ergmgis.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mops\e[0m = ops.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mops is already defined as \e[33mvalue\e[0m \e[35mops\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9ergmgis.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mopLenMinusOne\e[0m = opLen - \e[31m1\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopLenMinusOne is already defined as \e[33mvalue\e[0m \e[35mopLenMinusOne\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9ergmgis.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36moperandsLenMinusOne\e[0m = operandsLen\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandsLenMinusOne is already defined as \e[33mvalue\e[0m\
    \ \e[35moperandsLenMinusOne\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9ergmgis.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mopLenMinusOne\e[0m = opLen\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopLenMinusOne is already defined as \e[33mvalue\e[0m \e[35mopLenMinusOne\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9ergmgis.scala:35:12 ---------------------------\e[0m\e[0m\n\e"
  stdout: ''
  timestamp: 1659792971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operands.size - 1\n        val opLenMinusOneMinusOne\
    \ = opLenMinusOne - 1\n        val opLenMinusOneMinusOneMinusOne = opLenMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n      \
    \  val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne =\
    \ opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n\
    \        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\"\
    , \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) ==\
    \ (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6u5bwynj.scala:30:52 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mopLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m = opLenMinusOneMinusOneMinusOneMinusOne - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                    ^\e[0m\n\e[31m   |\e[0m\
    \        Recursive \e[33mvalue\e[0m \e[35mopLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6u5bwynj.scala:31:60\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                      ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mopLenMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6u5bwynj.scala:32:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                              ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6u5bwynj.scala:33:76\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                      ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mopLenMinusOneMinusOneMinusOneMinusOneMinu"
  stdout: ''
  timestamp: 1659792971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val operands =\
    \ operand.map(x => x.toLong)\n        val opLength = ops.size\n        val operandLength\
    \ = operands.size\n        val result = operands.foldLeft(operands.head) { (result,\
    \ operand) =>\n            val op = ops.head\n            val operand1 = operand\n\
    \            val operand2 = result\n            val op1 = operand1 match {\n \
    \               case '+' => operand1 + operand2\n                case '-' => operand1\
    \ - operand2\n                case '*' => operand1 * operand2\n              \
    \  case '/' => operand1 / operand2\n                case '%' => operand1 % operand2\n\
    \                case '^' => operand1 ^ operand2\n            }\n            val\
    \ op2 = operand1 match {\n                case '+' => operand1 + operand2\n  \
    \              case '-' => operand1 - operand2\n                case '*' => operand1\
    \ * operand2\n                case '/' => operand1 / operand2\n              \
    \  case '%' => operand1 % operand2\n                case '^' => operand1 ^ operand2\n\
    \            }\n            val op3 = operand1 match {\n                case '+'\
    \ => operand1 + operand2\n                case '-' => operand1 - operand2\n  \
    \              case '*' => operand1 * operand2\n                case '/' => operand1\
    \ / operand2\n                case '%' => operand1 % operand2\n              \
    \  case '^' => operand1 ^ operand2\n            }\n            val op4 = operand1\
    \ match {\n                case '+' => operand1 + operand2\n                case\
    \ '-' => operand1 - operand2\n                case '*' => operand1 * operand2\n\
    \                case '/' => operand1 / operand2\n                case '%' =>\
    \ operand1 % operand2\n                case '^' => operand1 ^ operand2\n     \
    \       }\n            val op5 = operand1 match {\n                case '+' =>\
    \ operand1 + operand2\n                case '-' => operand1 - operand2\n     \
    \           case '*' => operand1 * operand2\n                case '/' => operand1\
    \ / operand2\n                case '%' => operand1 % operand2\n              \
    \  case '^' => operand1 ^ operand2\n            }\n            val op6 = operand1\
    \ match {\n                case '+' => operand1 + operand2\n                case\
    \ '-' => operand1 - operand2\n                case '*' => operand1 * operand2\n\
    \                case '/' => operand1 / operand2\n                case '%' =>\
    \ operand1 % operand2\n                case '^' => operand1 ^ operand2\n     \
    \       }\n            val op7 = operand1 match {\n                case '+' =>\
    \ operand1 + operand2\n                case '-' => operand1 - operand2\n     \
    \           case '*' => operand1 * operand2\n                case '/' => operand1\
    \ / operand2\n                case '%' => operand1 % operand2\n              \
    \  case '^' => operand1 ^ operand2\n            }\n            val op8 = operand1\
    \ match {\n                case '+' => operand1 + \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpwoxvb0zx.scala:88:38 ---------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m                \e[33mcase\e[0m \e[31m'+'\e[0m => operand1\
    \ + \n\e[31m\e[31m   |\e[0m                                      ^\e[0m\n\e[31m\
    \   |\e[0m                                      expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwoxvb0zx.scala:97:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m97 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpwoxvb0zx.scala:23:32 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e[0m =>\
    \ x.toChar)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              value toChar is not a member of String\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwoxvb0zx.scala:94:5 ---------------------\e\
    [0m\e[0m\n\e[31m94 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwoxvb0zx.scala:96:1 ---------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpwoxvb0zx.scala:90:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m90 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659792973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opList = ops.toList\n\
    \        val opLen = opList.size\n        val opLenMinusOne = opLen - 1\n    \
    \    val operands = operand.toList\n        val operandLen = operands.size\n \
    \       val operandLenMinusOne = operandLen - 1\n        val operandsLenMinusOne\
    \ = operandLen - 2\n        val operandsLen = operandLen + 1\n        val operandsLenMinusTwo\
    \ = operandLen + 2\n        val operandsLenMinusThree = operandLen + 3\n     \
    \   val operandsLenMinusFour = operandLen + 4\n        val operandsLenMinusFive\
    \ = operandLen + 5\n        val operandsLenMinusSix = operandLen + 6\n       \
    \ val operandsLenMinusSeven = operandLen + 7\n        val operandsLenMinusEight\
    \ = operandLen + 8\n        val operandsLenMinusNine = operandLen + 9\n      \
    \  val operandsLenMinusTen = operandLen + 10\n        val operandsLenMinusEleven\
    \ = operandLen + 11\n        val operandsLenMinusTwelve = operandLen + 12\n  \
    \      val operandsLenMinusThirteen = operandLen + 13\n        val operandsLenMinusFourteen\
    \ = operandLen + 14\n        val operandsLenMinusFifteen = operandLen + 15\n \
    \       val operandsLenMinusSixteen = operandLen + 16\n        val operandsLenMinusSeventeen\
    \ = operandLen + 17\n        val operandsLenMinusEighteen = operandLen + 18\n\
    \        val operandsLenMinusNineteen = operandLen + 19\n        val operandsLenMinusTwenty\
    \ = operandLen + 20\n        val operandsLenMinusThirty = operandLen + 21\n  \
    \      val operandsLenMinusFourty = operandLen + 22\n        val operandsLenMinusFifty\
    \ = operandLen + 23\n        val operandsLenMinusSixty = operandLen + 24\n   \
    \     val operandsLenMinusSeventy = operandLen + 25\n        val operandsLenMinusEighty\
    \ = operandLen + 26\n        val operandsLenMinusNinety = operandLen + 27\n  \
    \      val operandsLenMinusTwentyOne = operandLen + 28\n        val operandsLenMinusTw\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1fs2rh_u.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp1fs2rh_u.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLength = ops.size\n        val operandLength\
    \ = operands.size\n        val result = operands.foldLeft(operands.head) { (acc,\
    \ op) =>\n            val opIndex = ops.indexOf(op)\n            val opLength\
    \ = ops.size\n            val operandLength = operands.size\n            val opLength\
    \ = ops.size\n            val operandLength = operands.size\n            val opIndex\
    \ = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n  \
    \          val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operands.indexOf(acc)\n\
    \            val opIndex = ops.indexOf(op)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmkfmdzio.scala:88:0 ----------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmkfmdzio.scala:31:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36mopLength\e[0m = ops.size\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopLength is already defined as \e[33mvalue\e[0m \e[35mopLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmkfmdzio.scala:32:16 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m            \e[33mval\e[0m \e[36moperandLength\e[0m = operands.size\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0moperandLength is already defined as \e[33mvalue\e[0m \e[35moperandLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmkfmdzio.scala:33:16 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m            \e[33mval\e[0m \e[36mopIndex\e[0m = ops.indexOf(op)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mopIndex is already defined as \e[33mvalue\e[0m \e[35mopIndex\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmkfmdzio.scala:35:16 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m            \e[33mval\e[0m \e[36mopIndex\e[0m = ops.indexOf(op)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mopIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmkfmdzio.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mop"
  stdout: ''
  timestamp: 1659792973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.mkString(\"+\")\n        val opArray = ops.split(\"\
    \\\\+\")\n        val opArrayLength = opArray.length\n        val operandArray\
    \ = operand.mkString(\"+\")\n        val operandArrayLength = operandArray.length\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength\n      \
    \  val operandArrayLength = operandArrayLength\n        val opArrayLength = opArrayLength\n\
    \        val operandArrayLength = operandArrayLength\n        val opArrayLength\
    \ = opArrayLength\n        val operandArrayLength = operandArrayLength\n     \
    \   val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operand\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp06kfvjft.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp06kfvjft.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopArrayLength\e[0m = opArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopArrayLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp06kfvjft.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandArrayLength\e[0m = operandArrayLength - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m \e[35moperandArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp06kfvjft.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp06kfvjft.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m \e[35moperandArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions"
  stdout: ''
  timestamp: 1659792973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opLen = ops.size\n\
    \        val opArray = ops.toArray\n        val operandLen = operand.size\n  \
    \      val operandArray = operand.toArray\n        val result = operandArray(0)\n\
    \        val opIndex = 0\n        val operandIndex = 1\n        while (operandIndex\
    \ < operandLen) {\n            val opVal = ops(opIndex)\n            val opValInt\
    \ = opArray[opIndex]\n            val operandVal = operandArray(operandIndex)\n\
    \            val operandValInt = operandArray[operandIndex]\n            val opValInt\
    \ = opVal.toLong\n            val operandValInt = operandVal.toLong\n        \
    \    val opValInt = opVal.toInt\n            val operandValInt = operandVal.toInt\n\
    \            val opValInt = opVal.toFloat\n            val operandValInt = operandVal.toFloat\n\
    \            val opValInt = opVal.toDouble\n            val operandValInt = operandVal.toDouble\n\
    \            val opValInt = opVal.toBoolean\n            val operandValInt = operandVal.toBoolean\n\
    \            val opValInt = opVal.toChar\n            val operandValInt = operandVal.toChar\n\
    \            val opValInt = opVal.toByte\n            val operandValInt = operandVal.toByte\n\
    \            val opValInt = opVal.toShort\n            val operandValInt = operandVal.toShort\n\
    \            val opValInt = opVal.toInt\n            val operandValInt = operandVal.toInt\n\
    \            val opValInt = opVal.toLong\n            val operandValInt = operandVal.toLong\n\
    \            val opValInt = opVal.toFloat\n            val operandValInt = operandVal.toFloat\n\
    \            val opValInt = opVal.toDouble\n            val operandValInt = operandVal.toDouble\n\
    \            val opValInt = opVal.toBoolean\n            val operandValInt = operandVal.toBoolean\n\
    \            val opValInt = opVal.toChar\n            val operandValInt = operandVal.toChar\n\
    \            val opValInt = opVal.toByte\n            val operandValInt = operandVal.toByte\n\
    \            val opValInt = opVal.toShort\n            val operandValInt = operandVal.toShort\n\
    \            val opValInt = opVal.toInt\n            val operandValInt = operandVal.toInt\n\
    \            val opValInt = opVal.toLong\n            val operandValInt = operandVal.toLong\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9mrzi62a.scala:81:0 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9mrzi62a.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mopValInt\e[0m = opVal.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopValInt is already defined as \e[33mvalue\e[0m \e[35mopValInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9mrzi62a.scala:37:16 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m            \e[33mval\e[0m \e[36moperandValInt\e[0m = operandVal.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0moperandValInt is already defined as \e[33mvalue\e[0m \e[35moperandValInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9mrzi62a.scala:38:16 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m            \e[33mval\e[0m \e[36mopValInt\e[0m = opVal.toInt\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopValInt\
    \ is already defined as \e[33mvalue\e[0m \e[35mopValInt\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9mrzi62a.scala:39:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e\
    [0m \e[36moperandValInt\e[0m = operandVal.toInt\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0moperandValInt\
    \ is already defined as \e[33mvalue\e[0m \e[35moperandValInt\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9mrzi62a.scala:40:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m40"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length\n        val opIndex = opList.indexOf(\"+\")\n        val\
    \ opIndex2 = opList.indexOf(\"*\")\n        val opIndex3 = opList.indexOf(\"/\"\
    )\n        val opIndex4 = opList.indexOf(\"//\")\n        val opIndex5 = opList.indexOf(\"\
    **\")\n        val opIndex6 = opList.indexOf(\"%\")\n        val opIndex7 = opList.indexOf(\"\
    &\")\n        val opIndex8 = opList.indexOf(\"|\")\n        val opIndex9 = opList.indexOf(\"\
    ^\")\n        val opIndex10 = opList.indexOf(\"~\")\n        val opIndex11 = opList.indexOf(\"\
    <<\")\n        val opIndex12 = opList.indexOf(\">>\")\n        val opIndex13 =\
    \ opList.indexOf(\"==\")\n        val opIndex14 = opList.indexOf(\"!=\")\n   \
    \     val opIndex15 = opList.indexOf(\"<\")\n        val opIndex16 = opList.indexOf(\"\
    >\")\n        val opIndex17 = opList.indexOf(\"<=\")\n        val opIndex18 =\
    \ opList.indexOf(\">=\")\n        val opIndex19 = opList.indexOf(\"==\")\n   \
    \     val opIndex20 = opList.indexOf(\"!=\")\n        val opIndex21 = opList.indexOf(\"\
    +\")\n        val opIndex22 = opList.indexOf(\"*\")\n        val opIndex23 = opList.indexOf(\"\
    /\")\n        val opIndex24 = opList.indexOf(\"//\")\n        val opIndex25 =\
    \ opList.indexOf(\"**\")\n        val opIndex26 = opList.indexOf(\"%\")\n    \
    \    val opIndex27 = opList.indexOf(\"&\")\n        val opIndex28 = opList.indexOf(\"\
    |\")\n        val opIndex29 = opList.indexOf(\"^\")\n        val opIndex30 = opList.indexOf(\"\
    ~\")\n        val opIndex31 = opList.indexOf(\"<<\")\n        val opIndex32 =\
    \ opList.indexOf(\">>\")\n        val opIndex33 = opList.indexOf(\"==\")\n   \
    \     val opIndex34 = opList.indexOf(\"!=\")\n        val opIndex35 = opList.indexOf(\"\
    <\")\n        val opIndex36 = opList.indexOf(\">\")\n        val opIndex37 = opList.indexOf(\"\
    <=\")\n        val opIndex38 = opList.indexOf(\">=\")\n        val opIndex\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2fw3_wy4.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp2fw3_wy4.scala:66:5 ---------------------\e[0m\e[0m\n\e[31m66 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.mkString(\"+\")\n        val opArray = ops.split(\"\
    \\\\+\")\n        val opArrayLength = opArray.length\n        val operandArray\
    \ = operand.map(_.toLong)\n        val operandArrayLength = operandArray.length\n\
    \        val result = operandArray(0)\n        val operandArrayIndex = 1\n   \
    \     val operandArrayIndexLength = operandArrayIndex.length\n        val operandArrayIndexArray\
    \ = Array.ofDim[Int](operandArrayIndexLength)\n        val operandArrayIndexArrayLength\
    \ = operandArrayIndexArray.length\n        val operandArrayIndexArrayIndex = 0\n\
    \        val operandArrayIndexArrayIndexLength = operandArrayIndexArray.length\n\
    \        val operandArrayIndexArrayIndexArray = Array.ofDim[Int](operandArrayIndexArrayIndexLength)\n\
    \        val operandArrayIndexArrayIndexArrayLength = operandArrayIndexArrayIndexArray.length\n\
    \        val operandArrayIndexArrayIndexArrayIndex = 0\n        val operandArrayIndexArrayIndexArrayIndexLength\
    \ = operandArrayIndexArrayIndexArray.length\n        val operandArrayIndexArrayIndexArrayIndexArray\
    \ = Array.ofDim[Int](operandArrayIndexArrayIndexArrayIndexLength)\n        val\
    \ operandArrayIndexArrayIndexArrayIndexArrayLength = operandArrayIndexArrayIndexArrayIndexArray.length\n\
    \        val operandArrayIndexArrayIndexArrayIndexArrayIndex = 0\n        val\
    \ operandArrayIndexArrayIndexArrayIndexArrayIndexLength = operandArrayIndexArrayIndexArrayIndexArray.length\n\
    \        val operandArrayIndexArrayIndexArrayIndexArrayIndexArray = Array.ofDim[Int](operandArrayIndexArrayIndexArrayIndexArrayIndexLength)\n\
    \        val operandArrayIndexArrayIndexArrayIndexArrayIndexArrayLength = operandArrayIndexArrayIndexArrayIndexArrayIndexArray.length\n\
    \        val operandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndex = 0\n \
    \       val operandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexLength =\
    \ operandArrayIndexArrayIndexArrayIndexArrayIndexArray.length\n        val operandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndex\
    \ = 0\n        val operandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexLength\
    \ = operandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexArray.length\n  \
    \      val operandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexArray = Array.ofDim[Int](operandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexLength)\n\
    \        val operandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexArrayLength\
    \ = operandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexArray.length\n\
    \        val operandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexArrayIndex\
    \ = 0\n        val operandArrayIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxpt2b0tu.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxpt2b0tu.scala:47:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndex\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35moperandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxpt2b0tu.scala:48:12 ---------------------------\e[0m\e[0m\n\e\
    [31m48 |\e[0m        \e[33mval\e[0m \e[36moperandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexLength\e\
    [0m = operandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexArray.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexLength\
    \ is already defined as \e[33mvalue\e[0m \e[35moperandArrayIndexArrayIndexArrayIndexArrayIndexArrayIndexLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpxpt2b0tu.scala:30:56 ------------------------\e[0m\e[0m\n\
    \e[31m30 |\e[0m        \e[33mval\e[0m \e[36moperandArrayIndexLength\e[0m = operandArrayIndex.length\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     value length is not a\
    \ member of Int\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxpt2b0tu.scala:49:94\
    \ ------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e\
    [36m"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = new mutable.HashMap[String, Long]()\n\
    \        val opMap2 = new mutable.HashMap[String, Long]()\n        val opMap3\
    \ = new mutable.HashMap[String, Long]()\n        val opMap4 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap5 = new mutable.HashMap[String, Long]()\n        val\
    \ opMap6 = new mutable.HashMap[String, Long]()\n        val opMap7 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap8 = new mutable.HashMap[String, Long]()\n        val\
    \ opMap9 = new mutable.HashMap[String, Long]()\n        val opMap10 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap11 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap12 = new mutable.HashMap[String, Long]()\n        val opMap13 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap14 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap15 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap16 = new mutable.HashMap[String, Long]()\n        val opMap17 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap18 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap19 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap20 = new mutable.HashMap[String, Long]()\n        val opMap21 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap22 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap23 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap24 = new mutable.HashMap[String, Long]()\n        val opMap25 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap26 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap27 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap28 = new mutable.HashMap[String, Long]()\n        val opMap29 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap30 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap31 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8g2xxsh1.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8g2xxsh1.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8g2xxsh1.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mopMap2\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp8g2xxsh1.scala:29:25 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mopMap3\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8g2xxsh1.scala:30:25\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap4\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8g2xxsh1.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mopMap5\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLo"
  stdout: ''
  timestamp: 1659792973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val opLen\
    \ = ops.size\n        val opLenMinusOne = opLen - 1\n        val operandLen =\
    \ operand.size\n        val operandLenMinusOne = operandLen - 1\n        val opLenMinusOnePlusOne\
    \ = opLen + 1\n        val operandLenMinusOnePlusOne = operandLen + 1\n      \
    \  val opLenMinusOnePlusTwo = opLen + 2\n        val operandLenMinusOnePlusTwo\
    \ = operandLen + 2\n        val opLenMinusOnePlusThree = opLen + 3\n        val\
    \ operandLenMinusOnePlusThree = operandLen + 3\n        val opLenMinusOnePlusFour\
    \ = opLen + 4\n        val operandLenMinusOnePlusFour = operandLen + 4\n     \
    \   val opLenMinusOnePlusFive = opLen + 5\n        val operandLenMinusOnePlusFive\
    \ = operandLen + 5\n        val opLenMinusOnePlusSix = opLen + 6\n        val\
    \ operandLenMinusOnePlusSix = operandLen + 6\n        val opLenMinusOnePlusSeven\
    \ = opLen + 7\n        val operandLenMinusOnePlusSeven = operandLen + 7\n    \
    \    val opLenMinusOnePlusEight = opLen + 8\n        val operandLenMinusOnePlusEight\
    \ = operandLen + 8\n        val opLenMinusOnePlusNine = opLen + 9\n        val\
    \ operandLenMinusOnePlusNine = operandLen + 9\n        val opLenMinusOnePlusTen\
    \ = opLen + 10\n        val operandLenMinusOnePlusTen = operandLen + 10\n    \
    \    val opLenMinusOnePlusEleven = opLen + 11\n        val operandLenMinusOnePlusEleven\
    \ = operandLen + 11\n        val opLenMinusOnePlusTwelve = opLen + 12\n      \
    \  val operandLenMinusOnePlusTwelve = operandLen + 12\n        val opLenMinusOnePlusThirteen\
    \ = opLen + 13\n        val operandLenMinusOnePlusThirteen = operandLen + 13\n\
    \        val opLenMinusOnePlusFourteen = opLen + 14\n        val operandLenMinusOnePlusFourteen\
    \ = operandLen + 14\n        val opLenMinusOnePlusFifteen = opLen + 15\n     \
    \   val operandLenMinusOnePlus\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1r888m0f.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp1r888m0f.scala:58:5 ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val opLen = opArray.length\n\
    \        val operandLen = operandArray.length\n        val result = operandArray(0)\n\
    \        val op1 = opArray(0)\n        val op2 = opArray(1)\n        val op3 =\
    \ opArray(2)\n        val op4 = opArray(3)\n        val op5 = opArray(4)\n   \
    \     val op6 = opArray(5)\n        val op7 = opArray(6)\n        val op8 = opArray(7)\n\
    \        val op9 = opArray(8)\n        val op10 = opArray(9)\n        val op11\
    \ = opArray(10)\n        val op12 = opArray(11)\n        val op13 = opArray(12)\n\
    \        val op14 = opArray(13)\n        val op15 = opArray(14)\n        val op16\
    \ = opArray(15)\n        val op17 = opArray(16)\n        val op18 = opArray(17)\n\
    \        val op19 = opArray(18)\n        val op20 = opArray(19)\n        val op21\
    \ = opArray(20)\n        val op22 = opArray(21)\n        val op23 = opArray(22)\n\
    \        val op24 = opArray(23)\n        val op25 = opArray(24)\n        val op26\
    \ = opArray(25)\n        val op27 = opArray(26)\n        val op28 = opArray(27)\n\
    \        val op29 = opArray(28)\n        val op30 = opArray(29)\n        val op31\
    \ = opArray(30)\n        val op32 = opArray(31)\n        val op33 = opArray(32)\n\
    \        val op34 = opArray(33)\n        val op35 = opArray(34)\n        val op36\
    \ = opArray(35)\n        val op37 = opArray(36)\n        val op38 = opArray(37)\n\
    \        val op39 = opArray(38)\n        val op40 = opArray(39)\n        val op41\
    \ = opArray(40)\n        val op42 = opArray(41)\n        val op43 = opArray(42)\n\
    \        val op44 = opArray(43)\n        val op45 = opArray(44)\n        val op46\
    \ = opArray(45)\n        val op47 = opArray(46)\n        val op48 = opArray(47)\n\
    \        val op49 = opArray(48)\n        val op50 = op\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjkbs1o2h.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e\
    [0m => x.toChar)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value toChar is not a member\
    \ of String\n\e[31m\e[31m-- Error: /tmp/tmpjkbs1o2h.scala:24:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mopArray\e[0m = ops.toArray\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 No ClassTag available for B\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m                                 where:    B is a type variable\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjkbs1o2h.scala:79:5 ---------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opMap = ops.zip(operand).map(x\
    \ => (x._1, x._2)).toMap\n        val opList = ops.toList\n        val operandList\
    \ = operand.toList\n        val operandCount = operandList.size\n        val opCount\
    \ = opList.size\n        val opMapCount = opMap.values.toList\n        val opMapCount\
    \ = opMapCount.size\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMapCount.toInt\n        val opMapCount = opMapCount.toInt\n        val opMapCount\
    \ = opMap\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph10gvlsa.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mopMapCount\e[0m = opMapCount.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopMapCount is already defined as \e[33mvalue\e[0m \e[35mopMapCount\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph10gvlsa.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36mopMapCount\e[0m = opMapCount.toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopMapCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mopMapCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph10gvlsa.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopMapCount\e[0m = opMapCount.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapCount is already defined as \e[33mvalue\e[0m \e[35mopMapCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph10gvlsa.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mopMapCount\e[0m = opMapCount.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mopMapCount is already defined as \e[33mvalue\e[0m \e[35mopMapCount\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph10gvlsa.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mopMapCount\e[0m = opMapCount.toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopMapCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mopMapCou"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val length = ops.length\n        val operators\
    \ = ops(0 until length-1)\n        val operandsLength = operands.length\n    \
    \    val result = operands(0)\n        val operator = operators(0)\n        val\
    \ operand1 = operands(1)\n        val operand2 = operands(2)\n        val operator1\
    \ = operators(1)\n        val operator2 = operators(2)\n        val operand3 =\
    \ operands(3)\n        val operand4 = operands(4)\n        val operator3 = operators(3)\n\
    \        val operator4 = operators(4)\n        val operand5 = operands(5)\n  \
    \      val operand6 = operands(6)\n        val operator5 = operators(5)\n    \
    \    val operator6 = operators(6)\n        val operand7 = operands(7)\n      \
    \  val operand8 = operands(8)\n        val operator7 = operators(7)\n        val\
    \ operator8 = operators(8)\n        val operand9 = operands(9)\n        val operand10\
    \ = operands(10)\n        val operator9 = operators(9)\n        val operator10\
    \ = operators(10)\n        val operand11 = operands(11)\n        val operand12\
    \ = operands(12)\n        val operator11 = operators(11)\n        val operator12\
    \ = operators(12)\n        val operand13 = operands(13)\n        val operand14\
    \ = operands(14)\n        val operator13 = operators(13)\n        val operator14\
    \ = operators(14)\n        val operand15 = operands(15)\n        val operand16\
    \ = operands(16)\n        val operator15 = operators(15)\n        val operator16\
    \ = operators(16)\n        val operand17 = operands(17)\n        val operand18\
    \ = operands(18)\n        val operator17 = operators(17)\n        val operator18\
    \ = operators(18)\n        val operand19 = operands(19)\n        val operand20\
    \ = operands(20)\n        val operator19 = operators(19)\n        val operator20\
    \ = operators(20)\n        val operand21 = operands(21)\n        val operand22\
    \ = operands(22)\n        val operator21 = operators(21)\n        val operator22\
    \ = operators(22)\n        val operand23 = operands(23)\n        val operand24\
    \ = operands(24)\n        val operator23 = operators(23)\n        val operator24\
    \ = operators(24)\n        val operand25 = operands(25)\n        val operand26\
    \ = operands(26)\n        val operator25 = operators(25)\n        val operator26\
    \ = operators(26)\n\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgc1cv0v4.scala:26:28\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36moperators\e\
    [0m = ops(\e[31m0\e[0m until length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                       ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \             Found:    Range\n\e[31m   |\e[0m                            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgc1cv0v4.scala:83:5\
    \ ---------------------\e[0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = new mutable.HashMap[String, Long]()\n\
    \        val operandMap = new mutable.HashMap[String, Long]()\n        val result\
    \ = operandList.foldLeft(0) { (sum, operand) =>\n            val op = opList.head\n\
    \            val operand2 = operandList.tail.head\n            val operand1 =\
    \ operandList.tail.tail.head\n            val operand3 = operandList.tail.tail.tail.head\n\
    \            val operand4 = operandList.tail.tail.tail.tail.head\n           \
    \ val operand5 = operandList.tail.tail.tail.tail.tail.head\n            val operand6\
    \ = operandList.tail.tail.tail.tail.tail.tail.head\n            val operand7 =\
    \ operandList.tail.tail.tail.tail.tail.tail.tail.head\n            val operand8\
    \ = operandList.tail.tail.tail.tail.tail.tail.tail.tail.head\n            val\
    \ operand9 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n \
    \           val operand10 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand11 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand12 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand13 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand14 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand15 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand16 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgifh1yd0.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpgifh1yd0.scala:55:0 ----------------------------\e[0m\e[0m\n\e[31m55\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgifh1yd0.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgifh1yd0.scala:28:29\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgifh1yd0.scala:46:120 -------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m            \e[33mval\e[0m \e[36moperand16\e[0m = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                                                          Found:   \
    \ Unit\n\e[31m   |\e[0m                                                      \
    \    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgifh1yd0.scala:54:1\
    \ ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operands.size - 1\n        val opLenMinusOneMinusOne\
    \ = opLenMinusOne - 1\n        val operandLenMinusOne = operandLen - 1\n     \
    \   val opLenMinusOneMinusOneMinusOne = opLenMinusOneMinusOne - 1\n        val\
    \ operandLenMinusOneMinusOneMinusOne = operandLenMinusOneMinusOne - 1\n      \
    \  val opLenMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOne = operandLenMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOne = operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n \
    \       val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf0n6xzc6.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0n6xzc6.scala:31:49\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36moperandLenMinusOneMinusOneMinusOne\e[0m = operandLenMinusOneMinusOne - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                                            \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \            Not found: operandLenMinusOneMinusOne\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpf0n6xzc6.scala:32:52 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mopLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m = opLenMinusOneMinusOneMinusOneMinusOne - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                    ^\e[0m\n\e[31m   |\e[0m\
    \        Recursive \e[33mvalue\e[0m \e[35mopLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpf0n6xzc6.scala:33:57\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandLenMinusOneMinusOneMinusOneMinusOne\e[0m = operandLenMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                   ^\e[0m\n\e[31m   |\e[0m   Recursive \e[33mvalue\e[0m \e[35moperandLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf0n6xzc6.scala:38:146\
    \ -----------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e\
    [36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \    "
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opMap = ops.zip(operand).map(x\
    \ => (x._1, x._2)).toMap\n        val opList = ops.toList\n        val operandList\
    \ = operand.toList\n        val opLen = opList.size\n        val operandLen =\
    \ operandList.size\n        val opMapLen = opMap.values.toList.size\n        val\
    \ operandMapLen = operandMap.values.toList.size\n        val opMapKeys = opMap.keys.toList\n\
    \        val operandMapKeys = operandMap.keys.toList\n        val opMapValues\
    \ = opMap.values.toList\n        val operandMapValues = operandMap.values.toList\n\
    \        val opMapKeysLen = opMapKeys.size\n        val operandMapKeysLen = operandMapKeys.size\n\
    \        val opMapValuesLen = opMapValues.size\n        val operandMapValuesLen\
    \ = operandMapValues.size\n        val opMapKeysVal = opMapKeys.map(x => x.toLong).toList\n\
    \        val operandMapKeysVal = operandMapKeys.map(x => x.toLong).toList\n  \
    \      val opMapValuesVal = opMapValues.map(x => x.toLong).toList\n        val\
    \ operandMapValuesVal = operandMapValues.map(x => x.toLong).toList\n        val\
    \ opMapKeysValLen = opMapKeysVal.size\n        val operandMapKeysValLen = operandMapKeysVal.size\n\
    \        val opMapValuesValLen = opMapValuesVal.size\n        val operandMapValuesValLen\
    \ = operandMapValuesVal.size\n        val opMapKeysValVal = opMapKeysVal.map(x\
    \ => x.toLong).toList\n        val operandMapKeysValVal = operandMapKeysVal.map(x\
    \ => x.toLong).toList\n        val opMapValuesValVal = opMapValuesVal.map(x =>\
    \ x.toLong).toList\n        val operandMapValuesValVal = operandMapValuesVal.map(x\
    \ => x.toLong).toList\n        val opMapKeysValValLen = opMapKeysValVal.size\n\
    \        val operandMapKeysValValLen = operandMapKeysValVal.size\n        val\
    \ opMapValuesValValLen = opMapValuesValVal.size\n        val operandMapValuesValValLen\
    \ = operandMapValuesValVal.size\n        val opMapKeysValValVal = opMapKeysValVal.map(x\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvcgiuplr.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvcgiuplr.scala:30:28\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMapLen\e[0m = operandMap.values.toList.size\n\e[31m\e[31m   |\e[0m\
    \                            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \            Not found: operandMap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpvcgiuplr.scala:32:29 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m        \e[33mval\e[0m \e[36moperandMapKeys\e[0m = operandMap.keys.toList\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                             Not found: operandMap\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvcgiuplr.scala:34:31 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36moperandMapValues\e[0m =\
    \ operandMap.values.toList\n\e[31m\e[31m   |\e[0m                            \
    \   ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not found:\
    \ operandMap\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvcgiuplr.scala:55:53\
    \ ------------------------\e[0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \e\
    [36mopMapKeysValValVal\e[0m = opMapKeysValVal.map(x \n\e[31m\e[31m   |\e[0m  \
    \                                                   ^\e[0m\n\e[31m   |\e[0m  \
    \                                                   Not found: x\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvcgiuplr.scala:56:5 ---------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opList = ops.toList\n\
    \        val opLen = opList.size\n        val operands = operand.map(_.toLong)\n\
    \        val operandLen = operands.size\n        val opLenMinusOne = opLen - 1\n\
    \        val operandLenMinusOne = operandLen - 1\n        val operandsLenMinusOne\
    \ = operandsLen - 1\n        val operandsLenMinusOneMinusOne = operandsLenMinusOne\
    \ - 1\n        val opLenMinusOneMinusOne = opLenMinusOne - 1\n        val opLenMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOne - 1\n        val opLenMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOne - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n      \
    \  val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne =\
    \ opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n\
    \        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOne\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvwrul90y.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvwrul90y.scala:30:34\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36moperandsLenMinusOne\e[0m = operandsLen - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                                  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                           Not found: operandsLen\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpvwrul90y.scala:35:60 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                                                            ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mopLenMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvwrul90y.scala:36:68\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                              ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvwrul90y.scala:37:76\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                       "
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.mkString(\"+\")\n        val opListLength\
    \ = opList.size\n        val operandList = operand.mkString(\"+\")\n        val\
    \ operandListLength = operandList.size\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_xioaz43.scala:74:31 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_xioaz43.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopListLength\e[0m = opListLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopListLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mopListLength\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_xioaz43.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandListLength\e[0m = operandListLength - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0moperandListLength is already defined as \e[33mvalue\e[0m \e[35moperandListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_xioaz43.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mopListLength\e[0m = opListLength - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopListLength is already defined as \e[33mvalue\e[0m \e[35mopListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_xioaz43.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m = operandListLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opLen = ops.size\n\
    \        val opArray = ops.toArray\n        val operandArray = operand.toArray\n\
    \        val operandLen = operandArray.length\n        val opArrayLen = opArray.length\n\
    \        val result = operandArray(0)\n        val op1 = opArray(0)\n        val\
    \ op2 = opArray(1)\n        val op3 = opArray(2)\n        val op4 = opArray(3)\n\
    \        val op5 = opArray(4)\n        val op6 = opArray(5)\n        val op7 =\
    \ opArray(6)\n        val op8 = opArray(7)\n        val op9 = opArray(8)\n   \
    \     val op10 = opArray(9)\n        val op11 = opArray(10)\n        val op12\
    \ = opArray(11)\n        val op13 = opArray(12)\n        val op14 = opArray(13)\n\
    \        val op15 = opArray(14)\n        val op16 = opArray(15)\n        val op17\
    \ = opArray(16)\n        val op18 = opArray(17)\n        val op19 = opArray(18)\n\
    \        val op20 = opArray(19)\n        val op21 = opArray(20)\n        val op22\
    \ = opArray(21)\n        val op23 = opArray(22)\n        val op24 = opArray(23)\n\
    \        val op25 = opArray(24)\n        val op26 = opArray(25)\n        val op27\
    \ = opArray(26)\n        val op28 = opArray(27)\n        val op29 = opArray(28)\n\
    \        val op30 = opArray(29)\n        val op31 = opArray(30)\n        val op32\
    \ = opArray(31)\n        val op33 = opArray(32)\n        val op34 = opArray(33)\n\
    \        val op35 = opArray(34)\n        val op36 = opArray(35)\n        val op37\
    \ = opArray(36)\n        val op38 = opArray(37)\n        val op39 = opArray(38)\n\
    \        val op40 = opArray(39)\n        val op41 = opArray(40)\n        val op42\
    \ = opArray(41)\n        val op43 = opArray(42)\n        val op44 = opArray(43)\n\
    \        val op45 = opArray(44)\n        val op46 = opArray(45)\n        val op47\
    \ = opArray(46)\n        val op48 = opArray(47)\n        val op49 = opArray(48)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaqz4lajd.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toInt).toList\n        val opLength = opList.length\n      \
    \  val operandLength = operandList.length\n        val opIndex = 0\n        val\
    \ operandIndex = 0\n        val result = operand(0)\n        while(opIndex < opLength\
    \ && operandIndex < operandLength) {\n            val op = opList(opIndex)\n \
    \           val operand = operandList(operandIndex)\n            val opResult\
    \ = if (op == \"+\") {\n                result + operand\n            } else if\
    \ (op == \"-\") {\n                result - operand\n            } else if (op\
    \ == \"*\") {\n                result * operand\n            } else if (op ==\
    \ \"/\") {\n                result / operand\n            } else if (op == \"\
    //\") {\n                result // operand\n            } else if (op == \"**\"\
    ) {\n                result ** operand\n            } else {\n               \
    \ throw new Exception(\"Invalid operator: \" + op)\n            }\n          \
    \  result += opResult\n            opIndex += 1\n            operandIndex += 1\n\
    \        }\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp33pu5xsf.scala:44:23 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                result ** operand\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value ** is\
    \ not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp33pu5xsf.scala:48:19\
    \ ------------------------\e[0m\e[0m\n\e[31m48 |\e[0m            result += opResult\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Long - did you mean result.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp33pu5xsf.scala:49:20 ------------------------\e[0m\e\
    [0m\n\e[31m49 |\e[0m            opIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean opIndex.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp33pu5xsf.scala:50:25\
    \ ------------------------\e[0m\e[0m\n\e[31m50 |\e[0m            operandIndex\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m         value += is not a member of Int - did you mean operandIndex.!=?\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659792975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length - 1\n        val opMap = new mutable.HashMap[String, Long]()\n\
    \        val operandMap = new mutable.HashMap[String, Long]()\n        val opMap2\
    \ = new mutable.HashMap[String, Long]()\n        val operandMap2 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap3 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap3 = new mutable.HashMap[String, Long]()\n        val opMap4 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap4 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap5 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap5 = new mutable.HashMap[String, Long]()\n        val opMap6 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap6 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap7 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap7 = new mutable.HashMap[String, Long]()\n        val opMap8 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap8 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap9 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap9 = new mutable.HashMap[String, Long]()\n        val opMap10 = new\
    \ mutable.HashMap[String, Long]()\n        val operandMap10 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap11 = new mutable.HashMap[String, Long]()\n       \
    \ val operandMap11 = new mutable.HashMap[String, Long]()\n        val opMap12\
    \ = new mutable.HashMap[String, Long]()\n        val operandMap12 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap13 = new mutable.HashMap[String, Long]()\n       \
    \ val operandMap13 = new mutable.HashMap[String, Long]()\n        val opMap14\
    \ = new mutable.HashMap[String, Long]()\n        val operandMap14 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap15 = new mutable.HashMap[String, Long]()\n       \
    \ val operandMap15 = new mutable.HashMap[String, Long]()\n        val opMap16\
    \ = new mutable.HashMap[String, Long]()\n        val operandMap16 = new mutable.HashMap[\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb2ow_nhk.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpb2ow_nhk.scala:27:24 ------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb2ow_nhk.scala:28:29\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpb2ow_nhk.scala:29:25 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mopMap2\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpb2ow_nhk.scala:30:30 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36moperandMap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb2ow_nhk.scala:31:25\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap3\e[0m = \e[33mnew\e[0m mut"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val operatorList = opList.take(operandList.length-1)\n\
    \        val result = operandList.foldLeft(0)((sum, operand) => {\n          \
    \  val op = operatorList.head\n            val operand = operandList.tail.head\n\
    \            val operand2 = operandList.tail.tail.head\n            val operand3\
    \ = operandList.tail.tail.tail.head\n            val operand4 = operandList.tail.tail.tail.tail.head\n\
    \            val operand5 = operandList.tail.tail.tail.tail.tail.head\n      \
    \      val operand6 = operandList.tail.tail.tail.tail.tail.tail.head\n       \
    \     val operand7 = operandList.tail.tail.tail.tail.tail.tail.tail.head\n   \
    \         val operand8 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand9 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand10 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand11 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand12 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand13 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand14 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand15 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand16 = operandList.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.tail.head\n\
    \            val operand17 = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp53v356qa.scala:44:27 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            \e[33mval\e[0m \e[36moperand17\e[0m = \n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m        \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp53v356qa.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp53v356qa.scala:53:0 ----------------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp53v356qa.scala:45:5 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp53v356qa.scala:52:1 ---------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659792975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val opLen =\
    \ opList.length\n        val opMap : Map[String, Long] = opList.zipWithIndex.map(x\
    \ => (x._1, x._2)).toMap\n        val operandList = operand.map(_.toLong)\n  \
    \      val operandLen = operandList.length\n        val operandMap : Map[String,\
    \ Long] = operandList.zipWithIndex.map(x => (x._1, x._2)).toMap\n        val opMapKeys\
    \ = opMap.keys\n        val operandMapKeys = operandMap.keys\n        val opMapValues\
    \ = opMap.values.toList\n        val operandMapValues = operandMap.values.toList\n\
    \        val opMapKeysLen = opMapKeys.length\n        val operandMapKeysLen =\
    \ operandMapKeys.length\n        val opMapValuesLen = opMapValues.length\n   \
    \     val operandMapValuesLen = operandMapValues.length\n        val opMapKeysSet\
    \ = opMapKeys.toSet\n        val operandMapKeysSet = operandMapKeys.toSet\n  \
    \      val opMapValuesSet = opMapValues.toSet\n        val operandMapValuesSet\
    \ = operandMapValues.toSet\n        val opMapKeysSetLen = opMapKeysSet.size\n\
    \        val operandMapKeysSetLen = operandMapKeysSet.size\n        val opMapValuesSetLen\
    \ = opMapValuesSet.size\n        val operandMapValuesSetLen = operandMapValuesSet.size\n\
    \        val opMapKeysSetIntersection = opMapKeysSet.intersect(operandMapKeysSet)\n\
    \        val operandMapKeysSetIntersection = operandMapKeysSet.intersect(opMapKeysSet)\n\
    \        val opMapValuesSetIntersection = opMapValuesSet.intersect(operandMapValuesSet)\n\
    \        val operandMapValuesSetIntersection = operandMapValuesSet.intersect(opMapValuesSet)\n\
    \        val opMapKeysSetDifference = opMapKeysSet.diff(operandMapKeysSet)\n \
    \       val operandMapKeysSetDifference = operandMapKeysSet.diff(opMapKeysSet)\n\
    \        val opMapValuesSetDifference = opMapValuesSet.diff(operandMapValuesSet)\n\
    \        val operandMapValuesSetDifference = operandMapValuesSet.diff(opMapValuesSet)\n\
    \        val opMapKeysSetSymmetricDifference = opMapKeysSet.diff(opMapKeysSet)\n\
    \        val operandMapKey\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnni0gqe8.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpnni0gqe8.scala:25:40 --------------------\e[0m\e[0m\n\e[31m25 |\e[0m\
    \        \e[33mval\e[0m \e[36mopMap\e[0m : \e[35mMap\e[0m[\e[35mString\e[0m, \e\
    [35mLong\e[0m] = opList.zipWithIndex.map(\e[36mx\e[0m => (x._1, x._2)).toMap\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Map[String, Int]\n\e[31m\
    \   |\e[0m                          Required: collection.mutable.Map[String, Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnni0gqe8.scala:28:45\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36moperandMap\e\
    [0m : \e[35mMap\e[0m[\e[35mString\e[0m, \e[35mLong\e[0m] = operandList.zipWithIndex.map(\e\
    [36mx\e[0m => (x._1, x._2)).toMap\n\e[31m\e[31m   |\e[0m                     \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          Found:    Map[Long, Int]\n\e[31m\
    \   |\e[0m                          Required: collection.mutable.Map[String, Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnni0gqe8.scala:33:37\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mopMapKeysLen\e[0m = opMapKeys.length\n\e[31m\e[31m   |\e[0m              \
    \             ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        value\
    \ length is not a member of Iterable[String]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpnni0gqe8.scala:34:47 ------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36moperandMapKeysLen\e[0m = operandMapKeys.length\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                        valu"
  stdout: ''
  timestamp: 1659792975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.asInstanceOf[List[String]]\n        val\
    \ operandList = operand.asInstanceOf[List[Long]]\n        val opLen = opList.size\n\
    \        val opLenMinusOne = opLen - 1\n        val operandLen = operandList.size\n\
    \        val operandLenMinusOne = operandLen - 1\n        val opMap = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap = new mutable.HashMap[String, Long]()\n    \
    \    val opMap2 = new mutable.HashMap[String, Long]()\n        val operandMap2\
    \ = new mutable.HashMap[String, Long]()\n        val opMap3 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap3 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap4 = new mutable.HashMap[String, Long]()\n        val operandMap4\
    \ = new mutable.HashMap[String, Long]()\n        val opMap5 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap5 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap6 = new mutable.HashMap[String, Long]()\n        val operandMap6\
    \ = new mutable.HashMap[String, Long]()\n        val opMap7 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap7 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap8 = new mutable.HashMap[String, Long]()\n        val operandMap8\
    \ = new mutable.HashMap[String, Long]()\n        val opMap9 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap9 = new mutable.HashMap[String, Long]()\n   \
    \     val opMap10 = new mutable.HashMap[String, Long]()\n        val operandMap10\
    \ = new mutable.HashMap[String, Long]()\n        val opMap11 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap11 = new mutable.HashMap[String, Long]()\n  \
    \      val opMap12 = new mutable.HashMap[String, Long]()\n        val operandMap12\
    \ = new mutable.HashMap[String, Long]()\n        val opMap13 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap13 = new mutable.HashMap[String, Long]()\n  \
    \      val opMap14 = new mutable.HashMap[String, Long]()\n        val operandMap14\
    \ = new mutable.HashMap[String, Long]()\n        val opMap15 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap15 = new mutable.HashMap[\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfaz669fk.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpfaz669fk.scala:29:24 ------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfaz669fk.scala:30:29\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpfaz669fk.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mopMap2\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpfaz669fk.scala:32:30 ------------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m        \e[33mval\e[0m \e[36moperandMap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                              Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfaz669fk.scala:33:25\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap3\e[0m = \e[33mnew\e[0m mut"
  stdout: ''
  timestamp: 1659792975
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length - 1\n        val result = operandList.foldLeft(operandList.head)\
    \ { (acc, x) => \n            val opIndex = opList.indexOf(x(0))\n           \
    \ val opVal = opIndex.toLong\n            val opVal2 = opIndex.toLong + 1\n  \
    \          val opVal3 = opIndex.toLong + 2\n            val opVal4 = opIndex.toLong\
    \ + 3\n            val opVal5 = opIndex.toLong + 4\n            val opVal6 = opIndex.toLong\
    \ + 5\n            val opVal7 = opIndex.toLong + 6\n            val opVal8 = opIndex.toLong\
    \ + 7\n            val opVal9 = opIndex.toLong + 8\n            val opVal10 =\
    \ opIndex.toLong + 9\n            val opVal11 = opIndex.toLong + 10\n        \
    \    val opVal12 = opIndex.toLong + 11\n            val opVal13 = opIndex.toLong\
    \ + 12\n            val opVal14 = opIndex.toLong + 13\n            val opVal15\
    \ = opIndex.toLong + 14\n            val opVal16 = opIndex.toLong + 15\n     \
    \       val opVal17 = opIndex.toLong + 16\n            val opVal18 = opIndex.toLong\
    \ + 17\n            val opVal19 = opIndex.toLong + 18\n            val opVal20\
    \ = opIndex.toLong + 19\n            val opVal21 = opIndex.toLong + 20\n     \
    \       val opVal22 = opIndex.toLong + 21\n            val opVal23 = opIndex.toLong\
    \ + 22\n            val opVal24 = opIndex.toLong + 23\n            val opVal25\
    \ = opIndex.toLong + 24\n            val opVal26 = opIndex.toLong + 25\n     \
    \       val opVal27 = opIndex.toLong + 26\n            val opVal28 = opIndex.toLong\
    \ + 27\n            val opVal29 = opIndex.toLong + 28\n            val opVal30\
    \ = opIndex.toLong + 29\n            val opVal31 = opIndex.toLong + 30\n     \
    \       val opVal32 = opIndex.toLong + 31\n            val opVal33 = opIndex.toLong\
    \ + 32\n            val opVal34 = opIndex.toLong + 33\n            val opVal35\
    \ = opIndex.toLong + 34\n            val opVal\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2cm7erw_.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2cm7erw_.scala:73:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E050] Type\
    \ Error: /tmp/tmp2cm7erw_.scala:28:41 -----------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m            \e[33mval\e[0m \e[36mopIndex\e[0m = opList.indexOf(x(\e\
    [31m0\e[0m))\n\e[31m\e[31m   |\e[0m                                         ^\e\
    [0m\n\e[31m   |\e[0m                                    \e[33mparameter\e[0m \e\
    [35mx\e[0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2cm7erw_.scala:72:1 ---------------------\e[0m\e[0m\n\e[31m72\
    \ |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m\
    \   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp2cm7erw_.scala:66:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m66 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659792976
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val operatorList = opList.filterNot(_ == \"\
    *\")\n        val operatorListSize = operatorList.size\n        val operandListSize\
    \ = operandList.size\n        val result = operandList(0)\n        val operator\
    \ = operatorList(0)\n        val operand1 = operandList(1)\n        val operand2\
    \ = operandList(2)\n        val operand3 = operandList(3)\n        val operand4\
    \ = operandList(4)\n        val operand5 = operandList(5)\n        val operand6\
    \ = operandList(6)\n        val operand7 = operandList(7)\n        val operand8\
    \ = operandList(8)\n        val operand9 = operandList(9)\n        val operand10\
    \ = operandList(10)\n        val operand11 = operandList(11)\n        val operand12\
    \ = operandList(12)\n        val operand13 = operandList(13)\n        val operand14\
    \ = operandList(14)\n        val operand15 = operandList(15)\n        val operand16\
    \ = operandList(16)\n        val operand17 = operandList(17)\n        val operand18\
    \ = operandList(18)\n        val operand19 = operandList(19)\n        val operand20\
    \ = operandList(20)\n        val operand21 = operandList(21)\n        val operand22\
    \ = operandList(22)\n        val operand23 = operandList(23)\n        val operand24\
    \ = operandList(24)\n        val operand25 = operandList(25)\n        val operand26\
    \ = operandList(26)\n        val operand27 = operandList(27)\n        val operand28\
    \ = operandList(28)\n        val operand29 = operandList(29)\n        val operand30\
    \ = operandList(30)\n        val operand31 = operandList(31)\n        val operand32\
    \ = operandList(32)\n        val operand33 = operandList(33)\n        val operand34\
    \ = operandList(34)\n        val operand35 = operandList(35)\n        val operand36\
    \ = operandList(36)\n        val operand37 = operandList(37)\n        val operand38\
    \ = operandList(38)\n        val operand39 = operandList(39)\n        val operand40\
    \ = operandList(40)\n        val operand41 = operandList(41)\n        val operand42\
    \ = operandList(42)\n        val operand43 = operandList(43)\n        val operand44\
    \ = operandList(44)\n        val operand45 = operandList(45)\n        val operand46\
    \ = operandList(46)\n        val operand47 = operandList(47)\n        val operand48\
    \ = operandList(48)\n        val operand\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxwhfiaaa.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxwhfiaaa.scala:24:34\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36moperandList\e[0m = operand.map(_.toLong)\n\e[31m\e[31m   |\e[0m          \
    \                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue map is not a member of\
    \ Null, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration\
    \ AsScalaIterator\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator\
    \ asScala\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.map\
    \ AsScalaConcurrentMap\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.set\
    \ asScala\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxwhfiaaa.scala:79:5\
    \ ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val operandLength = operandArray.length\n        val result = 0\n   \
    \     var i = 0\n        while (i < length) {\n            val op = opArray(i)\n\
    \            val operand = operandArray(i)\n            val operand2 = operandArray(i\
    \ + 1)\n            val operand3 = operandArray(i + 2)\n            val operand4\
    \ = operandArray(i + 3)\n            val operand5 = operandArray(i + 4)\n    \
    \        val operand6 = operandArray(i + 5)\n            val operand7 = operandArray(i\
    \ + 6)\n            val operand8 = operandArray(i + 7)\n            val operand9\
    \ = operandArray(i + 8)\n            val operand10 = operandArray(i + 9)\n   \
    \         val operand11 = operandArray(i + 10)\n            val operand12 = operandArray(i\
    \ + 11)\n            val operand13 = operandArray(i + 12)\n            val operand14\
    \ = operandArray(i + 13)\n            val operand15 = operandArray(i + 14)\n \
    \           val operand16 = operandArray(i + 15)\n            val operand17 =\
    \ operandArray(i + 16)\n            val operand18 = operandArray(i + 17)\n   \
    \         val operand19 = operandArray(i + 18)\n            val operand20 = operandArray(i\
    \ + 19)\n            val operand21 = operandArray(i + 20)\n            val operand22\
    \ = operandArray(i + 21)\n            val operand23 = operandArray(i + 22)\n \
    \           val operand24 = operandArray(i + 23)\n            val operand25 =\
    \ operandArray(i + 24)\n            val operand26 = operandArray(i + 25)\n   \
    \         val operand27 = operandArray(i + 26)\n            val operand28 = operandArray(i\
    \ + 27)\n            val operand29 = operandArray(i + 28)\n            val operand30\
    \ = operandArray(i + 29)\n            val operand31 = operandArray(i + 30)\n \
    \           val operand32 = operandArray(i + 31)\n            val operand33 =\
    \ operandArray(i + 32)\n            val operand34 = operandArray(i + 33)\n   \
    \         val operand35 = operandArray(i + 34)\n            val operand36 = operandArray(i\
    \ + 35)\n            val operand37 = operandArray(i + 36)\n            val operand38\
    \ = operandArray(i + 37)\n            val operand39 = operandArray(i + 38)\n \
    \           val operand40 = operandArray(i + 39)\n            val operand41 =\
    \ operandArray(i + 40)\n\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv4exaih9.scala:82:0 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv4exaih9.scala:81:1\
    \ ---------------------\e[0m\e[0m\n\e[31m81 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpv4exaih9.scala:75:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m75 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val result = operandArray(0)\n        val opIndex = 0\n        val operandIndex\
    \ = 1\n        while(opIndex < length) {\n            val op = ops(opIndex)\n\
    \            val operand = operandArray(operandIndex)\n            val opResult\
    \ = opArray(opIndex)(operand)\n            result += opResult\n            opIndex\
    \ += 1\n            operandIndex += 1\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0r2ydun0.scala:33:44\
    \ --------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e\
    [36mopResult\e[0m = opArray(opIndex)(operand)\n\e[31m\e[31m   |\e[0m         \
    \                                   ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                                Found:    (operand : Long)\n\e[31m   |\e[0m \
    \                                           Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp0r2ydun0.scala:34:19 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m            result += opResult\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Long - did you mean result.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0r2ydun0.scala:35:20\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            opIndex += \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value += is not a member of Int - did you mean opIndex.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0r2ydun0.scala:36:25 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            operandIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value += is\
    \ not a member of Int - did you mean operandIndex.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length\n        val opIndex = 0\n        val operandIndex = 0\n\
    \        val opResult = 0\n        val operandResult = 0\n        val opResultIndex\
    \ = 0\n        val operandResultIndex = 0\n        while(opIndex < opLength &&\
    \ operandIndex < operandLength) {\n            val opChar = opList(opIndex)\n\
    \            val operandChar = operandList(operandIndex)\n            val opResultChar\
    \ = opResultChar(operandResultIndex)\n            val operandResultChar = operandResultChar(operandResultIndex)\n\
    \            if(opChar == \"+\") {\n                opResult += operandChar\n\
    \                opResultIndex += 1\n            } else if(opChar == \"-\") {\n\
    \                opResult -= operandChar\n                opResultIndex += 1\n\
    \            } else if(opChar == \"*\") {\n                opResult *= operandChar\n\
    \                opResultIndex += 1\n            } else if(opChar == \"//\") {\n\
    \                opResult /= operandChar\n                opResultIndex += 1\n\
    \            } else if(opChar == \"**\") {\n                opResult **= operandChar\n\
    \                opResultIndex += 1\n            }\n            operandIndex +=\
    \ 1\n        }\n        opResult\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwjgulmjk.scala:36:31 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mopResultChar\e[0m =\
    \ opResultChar(operandResultIndex)\n\e[31m\e[31m   |\e[0m                    \
    \           ^\e[0m\n\e[31m   |\e[0m                               Recursive \e\
    [33mvalue\e[0m \e[35mopResultChar\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpwjgulmjk.scala:37:36 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36moperandResultChar\e\
    [0m = operandResultChar(operandResultIndex)\n\e[31m\e[31m   |\e[0m           \
    \                         ^\e[0m\n\e[31m   |\e[0m                            Recursive\
    \ \e[33mvalue\e[0m \e[35moperandResultChar\e[0m needs type\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpwjgulmjk.scala:39:25 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                opResult += operandChar\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value\
    \ += is not a member of Int - did you mean opResult.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwjgulmjk.scala:40:30 ------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m                opResultIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ += is not a member of Int - did you mean opResultIndex.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpwjgulmjk.scala:42:25 ------------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m                opResult -= operandChar\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             value -= is not\
    \ a member of Int - did you mean opResult.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpwjgulmjk.scala:43:30 ------------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m                opResultIndex += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value += is not\
    \ a member of Int - did you mean o"
  stdout: ''
  timestamp: 1659792978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = new mutable.HashMap[String, Long]()\n\
    \        val opMap2 = new mutable.HashMap[String, Long]()\n        val opMap3\
    \ = new mutable.HashMap[String, Long]()\n        val opMap4 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap5 = new mutable.HashMap[String, Long]()\n        val\
    \ opMap6 = new mutable.HashMap[String, Long]()\n        val opMap7 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap8 = new mutable.HashMap[String, Long]()\n        val\
    \ opMap9 = new mutable.HashMap[String, Long]()\n        val opMap10 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap11 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap12 = new mutable.HashMap[String, Long]()\n        val opMap13 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap14 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap15 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap16 = new mutable.HashMap[String, Long]()\n        val opMap17 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap18 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap19 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap20 = new mutable.HashMap[String, Long]()\n        val opMap21 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap22 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap23 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap24 = new mutable.HashMap[String, Long]()\n        val opMap25 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap26 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap27 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap28 = new mutable.HashMap[String, Long]()\n        val opMap29 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap30 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap31 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8g2xxsh1.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8g2xxsh1.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8g2xxsh1.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mopMap2\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp8g2xxsh1.scala:29:25 ------------------------\e[0m\e[0m\n\e[31m29 |\e\
    [0m        \e[33mval\e[0m \e[36mopMap3\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8g2xxsh1.scala:30:25\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap4\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp8g2xxsh1.scala:31:25 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mopMap5\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLo"
  stdout: ''
  timestamp: 1659792973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val opSet =\
    \ opList.map(_.toChar)\n        val operandList = operand.map(_.toLong)\n    \
    \    val operandSet = operandList.map(_.toChar)\n        val opSetSize = opSet.size\n\
    \        val operandSetSize = operandSet.size\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = opSetSize.toLong\n\
    \        val operandSetSize = operandSetSize.toLong\n        val opSetSize = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp420h5buk.scala:69:23 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mval\e[0m \e[36mopSetSize\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp420h5buk.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mopSetSize\e[0m = opSetSize.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopSetSize is already defined as \e[33mvalue\e[0m \e[35mopSetSize\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp420h5buk.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36moperandSetSize\e[0m = operandSetSize.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandSetSize is already defined as \e[33mvalue\e[0m \e[35moperandSetSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp420h5buk.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mopSetSize\e[0m = opSetSize.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopSetSize is already defined as \e[33mvalue\e[0m \e[35mopSetSize\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp420h5buk.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36moperandSetSize\e[0m = operandSetSize.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandSetSize is already defined as \e[33mvalue\e[0m \e[35moperandSetSize\e\
    [0m\n\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1659792977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toLowerCase)\n        val op1 =\
    \ ops.head\n        val op2 = ops.last\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val operand1 = operand(op1Index)\n\
    \        val operand2 = operand(op2Index)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op1)\n\
    \        val op2Index = ops.indexOf(op2)\n        val op1Index = ops.indexOf(op\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc3wvbvpz.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc3wvbvpz.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mop1Index\e[0m = ops.indexOf(op1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mop1Index is already defined as \e[33mvalue\e[0m \e[35mop1Index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc3wvbvpz.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mop2Index\e[0m = ops.indexOf(op2)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mop2Index is already defined as \e[33mvalue\e[0m \e[35mop2Index\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpc3wvbvpz.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mop1Index\e[0m = ops.indexOf(op1)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mop1Index\
    \ is already defined as \e[33mvalue\e[0m \e[35mop1Index\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc3wvbvpz.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mop2Index\e[0m = ops.indexOf(op2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mop2Index is already defined as \e[33mvalue\e[0m \e[35mop2Index\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc3wvbvpz.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mop1Index\e[0"
  stdout: ''
  timestamp: 1659792977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opList = ops.toList\n\
    \        val opLen = opList.size\n        val opLenMinusOne = opLen - 1\n    \
    \    val operands = operand.map(_.toLong)\n        val operandLen = operands.size\n\
    \        val operandLenMinusOne = operandLen - 1\n        val operandsLen = operandLen\
    \ + opLenMinusOne\n        val operandsLenMinusOne = operandsLen - 1\n       \
    \ val operandsLenMinusOneMinusOne = operandsLenMinusOne - 1\n        val operandsLenMinusOneMinusOneMinusOne\
    \ = operandsLenMinusOneMinusOne - 1\n        val operandsLenMinusOneMinusOneMinusOneMinusOne\
    \ = operandsLenMinusOneMinusOneMinusOne - 1\n        val operandsLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandsLenMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val\
    \ operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinus\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnd2lkdlb.scala:35:66 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36moperandsLenMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = operandsLenMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35moperandsLenMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnd2lkdlb.scala:36:74\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35moperandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnd2lkdlb.scala:37:82\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                                            \
    \                                      ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35moperandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnd2lkdlb.scala:38:90\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = operandsLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e"
  stdout: ''
  timestamp: 1659792977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val operandLen\
    \ = operands.size\n        val opIndex = ops.indexOf(\"+\")\n        val opIndex2\
    \ = ops.indexOf(\"-\")\n        val opIndex3 = ops.indexOf(\"*\")\n        val\
    \ opIndex4 = ops.indexOf(\"/\")\n        val opIndex5 = ops.indexOf(\"**\")\n\
    \        val opIndex6 = ops.indexOf(\"//\")\n        val opIndex7 = ops.indexOf(\"\
    %\")\n        val opIndex8 = ops.indexOf(\"*\")\n        val opIndex9 = ops.indexOf(\"\
    +\")\n        val opIndex10 = ops.indexOf(\"+\")\n        val opIndex11 = ops.indexOf(\"\
    +\")\n        val opIndex12 = ops.indexOf(\"+\")\n        val opIndex13 = ops.indexOf(\"\
    +\")\n        val opIndex14 = ops.indexOf(\"+\")\n        val opIndex15 = ops.indexOf(\"\
    +\")\n        val opIndex16 = ops.indexOf(\"+\")\n        val opIndex17 = ops.indexOf(\"\
    +\")\n        val opIndex18 = ops.indexOf(\"+\")\n        val opIndex19 = ops.indexOf(\"\
    +\")\n        val opIndex20 = ops.indexOf(\"+\")\n        val opIndex21 = ops.indexOf(\"\
    +\")\n        val opIndex22 = ops.indexOf(\"+\")\n        val opIndex23 = ops.indexOf(\"\
    +\")\n        val opIndex24 = ops.indexOf(\"+\")\n        val opIndex25 = ops.indexOf(\"\
    +\")\n        val opIndex26 = ops.indexOf(\"+\")\n        val opIndex27 = ops.indexOf(\"\
    +\")\n        val opIndex28 = ops.indexOf(\"+\")\n        val opIndex29 = ops.indexOf(\"\
    +\")\n        val opIndex30 = ops.indexOf(\"+\")\n        val opIndex31 = ops.indexOf(\"\
    +\")\n        val opIndex32 = ops.indexOf(\"+\")\n        val opIndex33 = ops.indexOf(\"\
    +\")\n        val opIndex34 = ops.indexOf(\"+\")\n        val opIndex35 = ops.indexOf(\"\
    +\")\n        val opIndex36 = ops.indexOf(\"+\")\n        val opIndex37 = ops.indexOf(\"\
    +\")\n        val opIndex38 = ops.indexOf(\"+\")\n        val opIndex39 = ops.indexOf(\"\
    +\")\n        val opIndex40 = ops.indexOf(\"+\")\n        val opIndex41 = ops.indexOf(\"\
    +\")\n        val opIndex42 = ops.indexOf(\"+\")\n        val opIndex43 = ops.indexOf(\"\
    +\")\n        val opIndex44 = ops.indexOf(\"+\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmest821q.scala:71:5\
    \ ---------------------\e[0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val operandLength = operandArray.length\n        val result = operandArray(0)\n\
    \        val op1 = operandArray(1)\n        val op2 = operandArray(2)\n      \
    \  val op3 = operandArray(3)\n        val op4 = operandArray(4)\n        val op5\
    \ = operandArray(5)\n        val op6 = operandArray(6)\n        val op7 = operandArray(7)\n\
    \        val op8 = operandArray(8)\n        val op9 = operandArray(9)\n      \
    \  val op10 = operandArray(10)\n        val op11 = operandArray(11)\n        val\
    \ op12 = operandArray(12)\n        val op13 = operandArray(13)\n        val op14\
    \ = operandArray(14)\n        val op15 = operandArray(15)\n        val op16 =\
    \ operandArray(16)\n        val op17 = operandArray(17)\n        val op18 = operandArray(18)\n\
    \        val op19 = operandArray(19)\n        val op20 = operandArray(20)\n  \
    \      val op21 = operandArray(21)\n        val op22 = operandArray(22)\n    \
    \    val op23 = operandArray(23)\n        val op24 = operandArray(24)\n      \
    \  val op25 = operandArray(25)\n        val op26 = operandArray(26)\n        val\
    \ op27 = operandArray(27)\n        val op28 = operandArray(28)\n        val op29\
    \ = operandArray(29)\n        val op30 = operandArray(30)\n        val op31 =\
    \ operandArray(31)\n        val op32 = operandArray(32)\n        val op33 = operandArray(33)\n\
    \        val op34 = operandArray(34)\n        val op35 = operandArray(35)\n  \
    \      val op36 = operandArray(36)\n        val op37 = operandArray(37)\n    \
    \    val op38 = operandArray(38)\n        val op39 = operandArray(39)\n      \
    \  val op40 = operandArray(40)\n        val op41 = operandArray(41)\n        val\
    \ op42 = operandArray(42)\n        val op43 = operandArray(43)\n        val op44\
    \ = operandArray(44)\n        val op45 = operandArray(45)\n        val op46 =\
    \ operandArray(46)\n        val op47 = operandArray(47)\n        val op48 = operandArray(48)\n\
    \        val op49 = operandArray(49)\n        val op50 = operandArray(50)\n  \
    \      \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8w6gus1.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opLen = ops.size\n\
    \        val opArray = ops.toArray\n        val operandArray = operand.toArray\n\
    \        val opArrayLen = opArray.length\n        val operandArrayLen = operandArray.length\n\
    \        val result = operandArray(0)\n        val op1 = opArray(0)\n        val\
    \ op2 = opArray(1)\n        val op3 = opArray(2)\n        val op4 = opArray(3)\n\
    \        val op5 = opArray(4)\n        val op6 = opArray(5)\n        val op7 =\
    \ opArray(6)\n        val op8 = opArray(7)\n        val op9 = opArray(8)\n   \
    \     val op10 = opArray(9)\n        val op11 = opArray(10)\n        val op12\
    \ = opArray(11)\n        val op13 = opArray(12)\n        val op14 = opArray(13)\n\
    \        val op15 = opArray(14)\n        val op16 = opArray(15)\n        val op17\
    \ = opArray(16)\n        val op18 = opArray(17)\n        val op19 = opArray(18)\n\
    \        val op20 = opArray(19)\n        val op21 = opArray(20)\n        val op22\
    \ = opArray(21)\n        val op23 = opArray(22)\n        val op24 = opArray(23)\n\
    \        val op25 = opArray(24)\n        val op26 = opArray(25)\n        val op27\
    \ = opArray(26)\n        val op28 = opArray(27)\n        val op29 = opArray(28)\n\
    \        val op30 = opArray(29)\n        val op31 = opArray(30)\n        val op32\
    \ = opArray(31)\n        val op33 = opArray(32)\n        val op34 = opArray(33)\n\
    \        val op35 = opArray(34)\n        val op36 = opArray(35)\n        val op37\
    \ = opArray(36)\n        val op38 = opArray(37)\n        val op39 = opArray(38)\n\
    \        val op40 = opArray(39)\n        val op41 = opArray(40)\n        val op42\
    \ = opArray(41)\n        val op43 = opArray(42)\n        val op44 = opArray(43)\n\
    \        val op45 = opArray(44)\n        val op46 = opArray(45)\n        val op47\
    \ = opArray(46)\n        val op48 = opArray(47)\n        val op49 = opArray(48\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy4swqj_l.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpy4swqj_l.scala:79:5 ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opList = ops.toList\n\
    \        val operandList = operand.toList\n        val opLen = opList.size\n \
    \       val operandLen = operandList.size\n        val opIndex = 0\n        val\
    \ operandIndex = 0\n        val result = operandList(0)\n        val op1 = opList(opIndex)\n\
    \        val op2 = opList(opIndex + 1)\n        val op3 = opList(opIndex + 2)\n\
    \        val op4 = opList(opIndex + 3)\n        val op5 = opList(opIndex + 4)\n\
    \        val op6 = opList(opIndex + 5)\n        val op7 = opList(opIndex + 6)\n\
    \        val op8 = opList(opIndex + 7)\n        val op9 = opList(opIndex + 8)\n\
    \        val op10 = opList(opIndex + 9)\n        val op11 = opList(opIndex + 10)\n\
    \        val op12 = opList(opIndex + 11)\n        val op13 = opList(opIndex +\
    \ 12)\n        val op14 = opList(opIndex + 13)\n        val op15 = opList(opIndex\
    \ + 14)\n        val op16 = opList(opIndex + 15)\n        val op17 = opList(opIndex\
    \ + 16)\n        val op18 = opList(opIndex + 17)\n        val op19 = opList(opIndex\
    \ + 18)\n        val op20 = opList(opIndex + 19)\n        val op21 = opList(opIndex\
    \ + 20)\n        val op22 = opList(opIndex + 21)\n        val op23 = opList(opIndex\
    \ + 22)\n        val op24 = opList(opIndex + 23)\n        val op25 = opList(opIndex\
    \ + 24)\n        val op26 = opList(opIndex + 25)\n        val op27 = opList(opIndex\
    \ + 26)\n        val op28 = opList(opIndex + 27)\n        val op29 = opList(opIndex\
    \ + 28)\n        val op30 = opList(opIndex + 29)\n        val op31 = opList(opIndex\
    \ + 30)\n        val op32 = opList(opIndex + 31)\n        val op33 = opList(opIndex\
    \ + 32)\n        val op34 = opList(opIndex + 33)\n        val op35 = opList(opIndex\
    \ + 34)\n        val op36 = opList(opIndex + 35)\n        val op37 = opList(opIndex\
    \ + 36)\n        val op38 = opList(opIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzfeji0fj.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpzfeji0fj.scala:69:5 ---------------------\e[0m\e[0m\n\e[31m69 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val opListSize\
    \ = opList.size\n        val operandList = operand.map(_.toLong)\n        val\
    \ operandListSize = operandList.size\n        val result = operandList(0)\n  \
    \      val op1 = opList(0)\n        val op2 = opList(1)\n        val op3 = opList(2)\n\
    \        val op4 = opList(3)\n        val op5 = opList(4)\n        val op6 = opList(5)\n\
    \        val op7 = opList(6)\n        val op8 = opList(7)\n        val op9 = opList(8)\n\
    \        val op10 = opList(9)\n        val op11 = opList(10)\n        val op12\
    \ = opList(11)\n        val op13 = opList(12)\n        val op14 = opList(13)\n\
    \        val op15 = opList(14)\n        val op16 = opList(15)\n        val op17\
    \ = opList(16)\n        val op18 = opList(17)\n        val op19 = opList(18)\n\
    \        val op20 = opList(19)\n        val op21 = opList(20)\n        val op22\
    \ = opList(21)\n        val op23 = opList(22)\n        val op24 = opList(23)\n\
    \        val op25 = opList(24)\n        val op26 = opList(25)\n        val op27\
    \ = opList(26)\n        val op28 = opList(27)\n        val op29 = opList(28)\n\
    \        val op30 = opList(29)\n        val op31 = opList(30)\n        val op32\
    \ = opList(31)\n        val op33 = opList(32)\n        val op34 = opList(33)\n\
    \        val op35 = opList(34)\n        val op36 = opList(35)\n        val op37\
    \ = opList(36)\n        val op38 = opList(37)\n        val op39 = opList(38)\n\
    \        val op40 = opList(39)\n        val op41 = opList(40)\n        val op42\
    \ = opList(41)\n        val op43 = opList(42)\n        val op44 = opList(43)\n\
    \        val op45 = opList(44)\n        val op46 = opList(45)\n        val op47\
    \ = opList(46)\n        val op48 = opList(47)\n        val op49 = opList(48)\n\
    \        val op50 = opList(49)\n        val op5\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc2gol2i1.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpc2gol2i1.scala:79:5 ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val opLen = opArray.length\n\
    \        val operandLen = operandArray.length\n        val opArrayLen = opLen\
    \ - 1\n        val operandArrayLen = operandLen - 1\n        val opArrayLen2 =\
    \ opArrayLen / 2\n        val operandArrayLen2 = operandArrayLen / 2\n       \
    \ val opArrayLen3 = opArrayLen / 3\n        val operandArrayLen3 = operandArrayLen\
    \ / 3\n        val opArrayLen4 = opArrayLen / 4\n        val operandArrayLen4\
    \ = operandArrayLen / 4\n        val opArrayLen5 = opArrayLen / 5\n        val\
    \ operandArrayLen5 = operandArrayLen / 5\n        val opArrayLen6 = opArrayLen\
    \ / 6\n        val operandArrayLen6 = operandArrayLen / 6\n        val opArrayLen7\
    \ = opArrayLen / 7\n        val operandArrayLen7 = operandArrayLen / 7\n     \
    \   val opArrayLen8 = opArrayLen / 8\n        val operandArrayLen8 = operandArrayLen\
    \ / 8\n        val opArrayLen9 = opArrayLen / 9\n        val operandArrayLen9\
    \ = operandArrayLen / 9\n        val opArrayLen10 = opArrayLen / 10\n        val\
    \ operandArrayLen10 = operandArrayLen / 10\n        val opArrayLen11 = opArrayLen\
    \ / 11\n        val operandArrayLen11 = operandArrayLen / 11\n        val opArrayLen12\
    \ = opArrayLen / 12\n        val operandArrayLen12 = operandArrayLen / 12\n  \
    \      val opArrayLen13 = opArrayLen / 13\n        val operandArrayLen13 = operandArrayLen\
    \ / 13\n        val opArrayLen14 = opArrayLen / 14\n        val operandArrayLen14\
    \ = operandArrayLen / 14\n        val opArrayLen15 = opArrayLen / 15\n       \
    \ val operandArrayLen15 = operandArrayLen / 15\n        val opArrayLen16 = opArrayLen\
    \ / 16\n        val operandArrayLen16 = operandArrayLen / 16\n        val opArrayLen17\
    \ = opArrayLen / 17\n        val operandArrayLen17 = operandArrayLen / 17\n  \
    \      val opArrayLen18 = opArrayLen / 18\n        val operandArrayLen18 = operandArrayLen\
    \ / 18\n        val opArrayLen19 = opArrayLen / 19\n        val operandArrayLen19\
    \ = operandArrayLen \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfnqrmzvf.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e\
    [0m => x.toChar)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value toChar is not a member\
    \ of String\n\e[31m\e[31m-- Error: /tmp/tmpfnqrmzvf.scala:24:33 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mopArray\e[0m = ops.toArray\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 No ClassTag available for B\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m                                 where:    B is a type variable\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfnqrmzvf.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opLen = ops.length\n\
    \        val operandLen = operand.length\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val opArrayLen = opArray.length\n\
    \        val operandArrayLen = operandArray.length\n        val opArrayLenMinusOne\
    \ = opArrayLen - 1\n        val operandArrayLenMinusOne = operandArrayLen - 1\n\
    \        val opArrayLenMinusTwo = opArrayLen - 2\n        val operandArrayLenMinusTwo\
    \ = operandArrayLen - 2\n        val opArrayLenMinusThree = opArrayLen - 3\n \
    \       val operandArrayLenMinusThree = operandArrayLen - 3\n        val opArrayLenMinusFour\
    \ = opArrayLen - 4\n        val operandArrayLenMinusFour = operandArrayLen - 4\n\
    \        val opArrayLenMinusFive = opArrayLen - 5\n        val operandArrayLenMinusFive\
    \ = operandArrayLen - 5\n        val opArrayLenMinusSix = opArrayLen - 6\n   \
    \     val operandArrayLenMinusSix = operandArrayLen - 6\n        val opArrayLenMinusSeven\
    \ = opArrayLen - 7\n        val operandArrayLenMinusSeven = operandArrayLen -\
    \ 7\n        val opArrayLenMinusEight = opArrayLen - 8\n        val operandArrayLenMinusEight\
    \ = operandArrayLen - 8\n        val opArrayLenMinusNine = opArrayLen - 9\n  \
    \      val operandArrayLenMinusNine = operandArrayLen - 9\n        val opArrayLenMinusTen\
    \ = opArrayLen - 10\n        val operandArrayLenMinusTen = operandArrayLen - 10\n\
    \        val opArrayLenMinusEleven = opArrayLen - 11\n        val operandArrayLenMinusEleven\
    \ = operandArrayLen - 11\n        val opArrayLenMinusTwelve = opArrayLen - 12\n\
    \        val operandArrayLenMinusTwelve = operandArrayLen - 12\n        val opArrayLenMinusThirteen\
    \ = opArrayLen - 13\n        val operandArrayLenMinusThirteen = operandArrayLen\
    \ - 13\n        val opArrayLenMinusFourteen = opArrayLen - 14\n        val operandArrayLenMinusFourteen\
    \ = operandArrayLen - 14\n        val opArrayLenMinusFifteen = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpb32_9opo.scala:58:36 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mopArrayLenMinusFifteen\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m\
    \   |\e[0m                                    expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb32_9opo.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(x => x.toUpperCase)\n        val opLen\
    \ = opList.length\n        val operandList = operand.map(x => x.toLong)\n    \
    \    val operandLen = operandList.length\n        val result = operandList.foldLeft(operandList(0))\
    \ { (sum, operand) =>\n            val opIndex = opList.indexOf(operand.asInstanceOf[String])\n\
    \            val opVal = opIndex.toLong\n            val opVal2 = opIndex.toLong\
    \ + 1\n            val opVal3 = opIndex.toLong + 2\n            val opVal4 = opIndex.toLong\
    \ + 3\n            val opVal5 = opIndex.toLong + 4\n            val opVal6 = opIndex.toLong\
    \ + 5\n            val opVal7 = opIndex.toLong + 6\n            val opVal8 = opIndex.toLong\
    \ + 7\n            val opVal9 = opIndex.toLong + 8\n            val opVal10 =\
    \ opIndex.toLong + 9\n            val opVal11 = opIndex.toLong + 10\n        \
    \    val opVal12 = opIndex.toLong + 11\n            val opVal13 = opIndex.toLong\
    \ + 12\n            val opVal14 = opIndex.toLong + 13\n            val opVal15\
    \ = opIndex.toLong + 14\n            val opVal16 = opIndex.toLong + 15\n     \
    \       val opVal17 = opIndex.toLong + 16\n            val opVal18 = opIndex.toLong\
    \ + 17\n            val opVal19 = opIndex.toLong + 18\n            val opVal20\
    \ = opIndex.toLong + 19\n            val opVal21 = opIndex.toLong + 20\n     \
    \       val opVal22 = opIndex.toLong + 21\n            val opVal23 = opIndex.toLong\
    \ + 22\n            val opVal24 = opIndex.toLong + 23\n            val opVal25\
    \ = opIndex.toLong + 24\n            val opVal26 = opIndex.toLong + 25\n     \
    \       val opVal27 = opIndex.toLong + 26\n            val opVal28 = opIndex.toLong\
    \ + 27\n            val opVal29 = opIndex.toLong + 28\n            val opVal30\
    \ = opIndex.toLong + 29\n            val opVal31 = opIndex.toLong + 30\n     \
    \       val opVal32 = opIndex.toLong + 31\n            val opVal33 = opIndex.toLong\
    \ + 32\n            val opVal34 = opIndex.toLong + 33\n            val opVal\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz1zdd86l.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz1zdd86l.scala:72:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m72 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpz1zdd86l.scala:71:1 ---------------------\e[0m\e[0m\n\
    \e[31m71 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpz1zdd86l.scala:65:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m65 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659792978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opLen = ops.size\n\
    \        val opArray = ops.toArray\n        val operandLen = operand.size\n  \
    \      val operandArray = operand.toArray\n        val opArrayLen = opArray.length\n\
    \        val operandArrayLen = operandArray.length\n        val opArrayIndex =\
    \ 0\n        val operandArrayIndex = 0\n        val result = operandArray(0)\n\
    \        val opArrayIndex2 = 0\n        val operandArrayIndex2 = 0\n        while(opArrayIndex\
    \ < opArrayLen && operandArrayIndex < operandArrayLen){\n            val op =\
    \ ops(opArrayIndex)\n            val operand = operandArray(operandArrayIndex)\n\
    \            val opArrayIndex2 = opArrayIndex + 1\n            val operandArrayIndex2\
    \ = operandArrayIndex + 1\n            val opArrayIndex3 = opArrayIndex2 + 1\n\
    \            val operandArrayIndex3 = operandArrayIndex2 + 1\n            val\
    \ opArrayIndex4 = opArrayIndex3 + 1\n            val operandArrayIndex4 = operandArrayIndex3\
    \ + 1\n            val opArrayIndex5 = opArrayIndex4 + 1\n            val operandArrayIndex5\
    \ = operandArrayIndex4 + 1\n            val opArrayIndex6 = opArrayIndex5 + 1\n\
    \            val operandArrayIndex6 = operandArrayIndex5 + 1\n            val\
    \ opArrayIndex7 = opArrayIndex6 + 1\n            val operandArrayIndex7 = operandArrayIndex6\
    \ + 1\n            val opArrayIndex8 = opArrayIndex7 + 1\n            val operandArrayIndex8\
    \ = operandArrayIndex7 + 1\n            val opArrayIndex9 = opArrayIndex8 + 1\n\
    \            val operandArrayIndex9 = operandArrayIndex8 + 1\n            val\
    \ opArrayIndex10 = opArrayIndex9 + 1\n            val operandArrayIndex10 = operandArrayIndex9\
    \ + 1\n            val opArrayIndex11 = opArrayIndex10 + 1\n            val operandArrayIndex11\
    \ = operandArrayIndex10 + 1\n            val opArrayIndex12 = opArrayIndex11 +\
    \ 1\n            val operandArrayIndex12 = operandArrayIndex11 + 1\n         \
    \   val opArrayIndex13 = opArrayIndex12 + 1\n            val operandArrayIndex13\
    \ = operandArrayIndex12 + 1\n            val opArrayIndex14 = opArrayIndex13 +\
    \ 1\n            val operandArrayIndex14 = operandArrayIndex13 + 1\n         \
    \   val opArrayIndex15 = opArrayIndex14 + 1\n            val operandArrayIndex15\
    \ = operandArrayIndex14 + 1\n            val opArrayIndex16 = opArrayIndex15 +\
    \ 1\n            val operandArrayIndex16 = operandArrayIndex15 + 1\n         \
    \   val opArrayIndex17\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0qgsiruu.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0qgsiruu.scala:77:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp0qgsiruu.scala:76:1 ---------------------\e[0m\e[0m\n\
    \e[31m76 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp0qgsiruu.scala:70:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m70 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659792978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val result = operandArray(0)\n        val op1 = opArray(0)\n        val\
    \ op2 = opArray(1)\n        val op3 = opArray(2)\n        val op4 = opArray(3)\n\
    \        val op5 = opArray(4)\n        val op6 = opArray(5)\n        val op7 =\
    \ opArray(6)\n        val op8 = opArray(7)\n        val op9 = opArray(8)\n   \
    \     val op10 = opArray(9)\n        val op11 = opArray(10)\n        val op12\
    \ = opArray(11)\n        val op13 = opArray(12)\n        val op14 = opArray(13)\n\
    \        val op15 = opArray(14)\n        val op16 = opArray(15)\n        val op17\
    \ = opArray(16)\n        val op18 = opArray(17)\n        val op19 = opArray(18)\n\
    \        val op20 = opArray(19)\n        val op21 = opArray(20)\n        val op22\
    \ = opArray(21)\n        val op23 = opArray(22)\n        val op24 = opArray(23)\n\
    \        val op25 = opArray(24)\n        val op26 = opArray(25)\n        val op27\
    \ = opArray(26)\n        val op28 = opArray(27)\n        val op29 = opArray(28)\n\
    \        val op30 = opArray(29)\n        val op31 = opArray(30)\n        val op32\
    \ = opArray(31)\n        val op33 = opArray(32)\n        val op34 = opArray(33)\n\
    \        val op35 = opArray(34)\n        val op36 = opArray(35)\n        val op37\
    \ = opArray(36)\n        val op38 = opArray(37)\n        val op39 = opArray(38)\n\
    \        val op40 = opArray(39)\n        val op41 = opArray(40)\n        val op42\
    \ = opArray(41)\n        val op43 = opArray(42)\n        val op44 = opArray(43)\n\
    \        val op45 = opArray(44)\n        val op46 = opArray(45)\n        val op47\
    \ = opArray(46)\n        val op48 = opArray(47)\n        val op49 = opArray(48)\n\
    \        val op50 = opArray(49)\n        val op51 = opArray(50)\n        \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk3l4bam5.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val opArray\
    \ = ops.toArray\n        val operandArray = operand.toArray\n        val operandLength\
    \ = operandArray.length\n        val opLength = opArray.length\n        val result\
    \ = operandArray(0)\n        val op1 = opArray(0)\n        val op2 = opArray(1)\n\
    \        val op3 = opArray(2)\n        val op4 = opArray(3)\n        val op5 =\
    \ opArray(4)\n        val op6 = opArray(5)\n        val op7 = opArray(6)\n   \
    \     val op8 = opArray(7)\n        val op9 = opArray(8)\n        val op10 = opArray(9)\n\
    \        val op11 = opArray(10)\n        val op12 = opArray(11)\n        val op13\
    \ = opArray(12)\n        val op14 = opArray(13)\n        val op15 = opArray(14)\n\
    \        val op16 = opArray(15)\n        val op17 = opArray(16)\n        val op18\
    \ = opArray(17)\n        val op19 = opArray(18)\n        val op20 = opArray(19)\n\
    \        val op21 = opArray(20)\n        val op22 = opArray(21)\n        val op23\
    \ = opArray(22)\n        val op24 = opArray(23)\n        val op25 = opArray(24)\n\
    \        val op26 = opArray(25)\n        val op27 = opArray(26)\n        val op28\
    \ = opArray(27)\n        val op29 = opArray(28)\n        val op30 = opArray(29)\n\
    \        val op31 = opArray(30)\n        val op32 = opArray(31)\n        val op33\
    \ = opArray(32)\n        val op34 = opArray(33)\n        val op35 = opArray(34)\n\
    \        val op36 = opArray(35)\n        val op37 = opArray(36)\n        val op38\
    \ = opArray(37)\n        val op39 = opArray(38)\n        val op40 = opArray(39)\n\
    \        val op41 = opArray(40)\n        val op42 = opArray(41)\n        val op43\
    \ = opArray(42)\n        val op44 = opArray(43)\n        val op45 = opArray(44)\n\
    \        val op46 = opArray(45)\n        val op47 = opArray(46)\n        val op48\
    \ = opArray(47)\n        val op49 = opArray(48)\n        val op50 = opArray(49)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz2zh__wz.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toDouble)\n        val operands\
    \ = operand.map(x => x.toDouble)\n        val opArray = ops.toArray\n        val\
    \ operandArray = operands.toArray\n        val opLen = opArray.length\n      \
    \  val operandLen = operandArray.length\n        val opArrayLen = opLen + 1\n\
    \        val operandArrayLen = operandLen + 1\n        val opArrayLenMinusOne\
    \ = opArrayLen - 1\n        val operandArrayLenMinusOne = operandArrayLen - 1\n\
    \        val opArrayLenMinusOneMinusOne = opArrayLenMinusOne - 1\n        val\
    \ operandArrayLenMinusOneMinusOne = operandArrayLenMinusOne - 1\n        val opArrayLenMinusOneMinusOneMinusOne\
    \ = opArrayLenMinusOneMinusOne - 1\n        val operandArrayLenMinusOneMinusOneMinusOne\
    \ = operandArrayLenMinusOneMinusOne - 1\n        val opArrayLenMinusOneMinusOneMinusOneMinusOne\
    \ = opArrayLenMinusOneMinusOneMinusOne - 1\n        val operandArrayLenMinusOneMinusOneMinusOneMinusOne\
    \ = operandArrayLenMinusOneMinusOneMinusOne - 1\n        val opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opArrayLenMinusOneMinusOneMinusOneMinusOne - 1\n        val operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandArrayLenMinusOneMinusOneMinusOneMinusOne - 1\n        val opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n    \
    \    val opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne =\
    \ opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n   \
    \     val operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0l05w5nh.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0l05w5nh.scala:42:78\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m =\
    \ operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \                           ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35moperandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0l05w5nh.scala:43:81\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m\
    \ = opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \                              ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mopArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0l05w5nh.scala:45:5\
    \ ---------------------\e[0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659792978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.mkString(\"+\")\n        val operandList\
    \ = operand.mkString(\"+\")\n        val opArray = opList.split(\"\\\\+\")\n \
    \       val operandArray = operandList.split(\"\\\\+\")\n        val opLen = opArray.length\n\
    \        val operandLen = operandArray.length\n        val opArray1 = opArray.take(operandLen\
    \ - 1)\n        val operandArray1 = operandArray.take(operandLen - 1)\n      \
    \  val opArray2 = opArray.drop(operandLen - 1)\n        val operandArray2 = operandArray.drop(operandLen\
    \ - 1)\n        val opArray3 = opArray.take(operandLen - 2)\n        val operandArray3\
    \ = operandArray.take(operandLen - 2)\n        val opArray4 = opArray.drop(operandLen\
    \ - 2)\n        val operandArray4 = operandArray.drop(operandLen - 2)\n      \
    \  val opArray5 = opArray.take(operandLen - 3)\n        val operandArray5 = operandArray.take(operandLen\
    \ - 3)\n        val opArray6 = opArray.drop(operandLen - 3)\n        val operandArray6\
    \ = operandArray.drop(operandLen - 3)\n        val opArray7 = opArray.take(operandLen\
    \ - 4)\n        val operandArray7 = operandArray.take(operandLen - 4)\n      \
    \  val opArray8 = opArray.drop(operandLen - 4)\n        val operandArray8 = operandArray.drop(operandLen\
    \ - 4)\n        val opArray9 = opArray.take(operandLen - 5)\n        val operandArray9\
    \ = operandArray.take(operandLen - 5)\n        val opArray10 = opArray.drop(operandLen\
    \ - 5)\n        val operandArray10 = operandArray.drop(operandLen - 5)\n     \
    \   val opArray11 = opArray.take(operandLen - 6)\n        val operandArray11 =\
    \ operandArray.take(operandLen - 6)\n        val opArray12 = opArray.drop(operandLen\
    \ - 6)\n        val operandArray12 = operandArray.drop(operandLen - 6)\n     \
    \   val opArray13 = opArray.take(operandLen - 7)\n        val operandArray13 =\
    \ operandArray.take(operandLen - 7)\n        val opArray14 = opArray.drop(operandLen\
    \ - 7)\n        val operandArray14 = operandArray.drop(operandLen - 7)\n     \
    \   val opArray15 = opArray.take(operandLen - 8)\n        val operandArray15 =\
    \ operandArray.take(operandLen - 8)\n        val opArray16 = opArray.drop(operandLen\
    \ - 8)\n        val operandArray16 = operandArray.drop(operandLen \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\"\
    , \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) ==\
    \ (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpeq8ugjre.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpeq8ugjre.scala:61:5 ---------------------\e[0m\e[0m\n\e[31m61 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLength = ops.size\n        val operandLength\
    \ = operands.size\n        val opIndex = 0\n        val operandIndex = 0\n   \
    \     val opStack = mutable.Stack[String]()\n        val operandStack = mutable.Stack[Long]()\n\
    \        val result = operandStack.last\n        while(operandIndex < operandLength)\
    \ {\n            val op = ops(opIndex)\n            val operand = operands(operandIndex)\n\
    \            val opResult = opStack.last\n            val operandResult = operandStack.last\n\
    \            val opResultInt = opResult.toInt\n            val operandResultInt\
    \ = operandResult.toInt\n            val opResultDouble = opResult.toDouble\n\
    \            val operandResultDouble = operandResult.toDouble\n            val\
    \ opResultLong = opResult.toLong\n            val operandResultLong = operandResult.toLong\n\
    \            val opResultFloat = opResult.toFloat\n            val operandResultFloat\
    \ = operandResult.toFloat\n            val opResultInt = opResult.toInt\n    \
    \        val operandResultInt = operandResult.toInt\n            val opResultLong\
    \ = opResult.toLong\n            val operandResultLong = operandResult.toLong\n\
    \            val opResultFloat = opResult.toFloat\n            val operandResultFloat\
    \ = operandResult.toFloat\n            val opResultDouble = opResult.toDouble\n\
    \            val operandResultDouble = operandResult.toDouble\n            val\
    \ opResultInt = opResult.toInt\n            val operandResultInt = operandResult.toInt\n\
    \            val opResultLong = opResult.toLong\n            val operandResultLong\
    \ = operandResult.toLong\n            val opResultFloat = opResult.toFloat\n \
    \           val operandResultFloat = operandResult.toFloat\n            val opResultDouble\
    \ = opResult.toDouble\n            val operandResultDouble = operandResult.toDouble\n\
    \            val opResultInt = opResult.toInt\n            val operandResultInt\
    \ = operandResult.toInt\n            val opResultLong = opResult.toLong\n    \
    \        val operandResultLong = operandResult.toLong\n            val opResultFloat\
    \ = opResult.toFloat\n            val operandResultFloat = operandResult.toFloat\n\
    \            val opResultDouble = opResult.toDouble\n            val operandResultDouble\
    \ = operandResult.toDouble\n            val opResultInt = opResult.toInt\n   \
    \         val operandResultInt = operandResult.toInt\n            val opResultLong\
    \ = opResult.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp1i4zfgo.scala:80:0 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp1i4zfgo.scala:29:22\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mopStack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp1i4zfgo.scala:30:27\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36moperandStack\e[0m = mutable.Stack[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpp1i4zfgo.scala:45:16 ---------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m            \e[33mval\e[0m \e[36mopResultInt\e[0m = opResult.toInt\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mopResultInt is already defined as \e[33mvalue\e[0m \e[35mopResultInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpp1i4zfgo.scala:46:16 ---------------------------\e[0m\e[0m\n\e\
    [31m46 |\e[0m            \e[33mval\e[0m \e[36moperandResultInt\e[0m = operandResult.toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandResultInt is already defined as \e[33mvalue\e[0m \e\
    [35moperandResultInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpp1i4zfgo.scala:47:16 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m            \e[33mval\e[0m \e[36mopResultLong\e[0m =\
    \ opResult.toLong\n\e[31m\e"
  stdout: ''
  timestamp: 1659792978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operands.size - 1\n        val opLenMinusOneMinusOne\
    \ = opLenMinusOne - 1\n        val operandLenMinusOne = operandLen - 1\n     \
    \   val opLenMinusOneMinusOneMinusOne = opLenMinusOneMinusOne - 1\n        val\
    \ operandLenMinusOneMinusOneMinusOne = operandLenMinusOneMinusOne - 1\n      \
    \  val opLenMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOne = operandLenMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOne = operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n \
    \       val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf0n6xzc6.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0n6xzc6.scala:31:49\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36moperandLenMinusOneMinusOneMinusOne\e[0m = operandLenMinusOneMinusOne - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                                            \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \            Not found: operandLenMinusOneMinusOne\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmpf0n6xzc6.scala:32:52 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mopLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m = opLenMinusOneMinusOneMinusOneMinusOne - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                    ^\e[0m\n\e[31m   |\e[0m\
    \        Recursive \e[33mvalue\e[0m \e[35mopLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpf0n6xzc6.scala:33:57\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandLenMinusOneMinusOneMinusOneMinusOne\e[0m = operandLenMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                   ^\e[0m\n\e[31m   |\e[0m   Recursive \e[33mvalue\e[0m \e[35moperandLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpf0n6xzc6.scala:38:146\
    \ -----------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e\
    [36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \    "
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val opLen\
    \ = ops.length\n        val operands = operand.map(_.toLong).toList\n        val\
    \ operandLen = operands.length\n        val opIndex = ops.indexOf(\"+\")\n   \
    \     val opIndex2 = ops.indexOf(\"*\")\n        val opIndex3 = ops.indexOf(\"\
    /\")\n        val opIndex4 = ops.indexOf(\"**\")\n        val opIndex5 = ops.indexOf(\"\
    //\")\n        val opIndex6 = ops.indexOf(\"%\")\n        val opIndex7 = ops.indexOf(\"\
    *\")\n        val opIndex8 = ops.indexOf(\"+\")\n        val opIndex9 = ops.indexOf(\"\
    -\")\n        val opIndex10 = ops.indexOf(\"+\")\n        val opIndex11 = ops.indexOf(\"\
    *\")\n        val opIndex12 = ops.indexOf(\"/\")\n        val opIndex13 = ops.indexOf(\"\
    **\")\n        val opIndex14 = ops.indexOf(\"//\")\n        val opIndex15 = ops.indexOf(\"\
    %\")\n        val opIndex16 = ops.indexOf(\"*\")\n        val opIndex17 = ops.indexOf(\"\
    +\")\n        val opIndex18 = ops.indexOf(\"-\")\n        val opIndex19 = ops.indexOf(\"\
    +\")\n        val opIndex20 = ops.indexOf(\"*\")\n        val opIndex21 = ops.indexOf(\"\
    /\")\n        val opIndex22 = ops.indexOf(\"**\")\n        val opIndex23 = ops.indexOf(\"\
    //\")\n        val opIndex24 = ops.indexOf(\"%\")\n        val opIndex25 = ops.indexOf(\"\
    *\")\n        val opIndex26 = ops.indexOf(\"+\")\n        val opIndex27 = ops.indexOf(\"\
    -\")\n        val opIndex28 = ops.indexOf(\"+\")\n        val opIndex29 = ops.indexOf(\"\
    *\")\n        val opIndex30 = ops.indexOf(\"/\")\n        val opIndex31 = ops.indexOf(\"\
    **\")\n        val opIndex32 = ops.indexOf(\"//\")\n        val opIndex33 = ops.indexOf(\"\
    %\")\n        val opIndex34 = ops.indexOf(\"*\")\n        val opIndex35 = ops.indexOf(\"\
    +\")\n        val opIndex36 = ops.indexOf(\"-\")\n        val opIndex37 = ops.indexOf(\"\
    +\")\n        val opIndex38 = ops.indexOf(\"*\")\n        val opIndex39 = ops.indexOf(\"\
    /\")\n        val opIndex40 = ops.indexOf(\"**\")\n        val opIndex41 = ops.indexOf(\"\
    //\")\n        val opIndex42 = ops.indexOf(\"%\")\n        val opIndex43 = ops.indexOf\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E051] Reference Error: /tmp/tmp7pjhgn4l.scala:69:28 ------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mval\e[0m \e[36mopIndex43\e[0m = ops.indexOf\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous\
    \ overload. The overloaded alternatives of \e[33mmethod\e[0m \e[35mindexOf\e[0m\
    \ in \e[33mtrait\e[0m \e[35mSeqOps\e[0m with types\n\e[31m   |\e[0m [B >: String](elem:\
    \ B): Int\n\e[31m   |\e[0m [B >: String](elem: B, from: Int): Int\n\e[31m   |\e\
    [0mboth match expected type <?>\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7pjhgn4l.scala:70:5 ---------------------\e[0m\e[0m\n\e[31m70\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length - 1\n        val opMap = new mutable.HashMap[String, Long]()\n\
    \        val operandMap = new mutable.HashMap[String, Long]()\n        val result\
    \ = new mutable.HashMap[String, Long]()\n        val opIndex = 0\n        val\
    \ operandIndex = 0\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length - 1\n        val opMapLength = opList.length\n        val\
    \ operandMapLength = operandList.length\n        val opMapLength = opList.length\n\
    \        val operandMapLength = operandList.length\n        val opMapLength =\
    \ opList.length\n        val operandMapLength = operandList.length\n        val\
    \ opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = opList.length\n        val operandMapLength = operandList.length\n\
    \        val opMapLength = op\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpol0r3s_1.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mopLength\e[0m = opList.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mopLength\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpol0r3s_1.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandLength\e[0m = operandList.length - \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0moperandLength is already defined as \e[33mvalue\e[0m \e[35moperandLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpol0r3s_1.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mopMapLength\e[0m = opList.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopMapLength is already defined as \e[33mvalue\e[0m \e[35mopMapLength\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpol0r3s_1.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36moperandMapLength\e[0m = operandList.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0moperandMapLength is already defined as \e[33mvalue\e[0m \e[35moperandMapLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpol0r3s_1.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mopMapLength\e[0m = opList.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopMapLength is alr"
  stdout: ''
  timestamp: 1659792980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val result = 0L\n        val stack = mutable.Stack[Long]()\n        val\
    \ stackArray = stack.toArray\n        val stackLength = stackArray.length\n  \
    \      val stackIndex = stackLength - 1\n        val opIndex = 0\n        val\
    \ operandIndex = 0\n        while(opIndex < opArray.length && operandIndex < operandArray.length)\
    \ {\n            val op = ops(opIndex)\n            val operand = operands(operandIndex)\n\
    \            val operandValue = operands(operandIndex)\n            val opValue\
    \ = opArray(opIndex)\n            val opValueInt = opValue.toInt\n           \
    \ val operandValueInt = operandValue.toInt\n            val opValueInt = opValue.toInt\n\
    \            val operandValueInt = operandValue.toInt\n            val opValueInt\
    \ = opValue.toInt\n            val operandValueInt = operandValue.toInt\n    \
    \        val opValueInt = opValue.toInt\n            val operandValueInt = operandValue.toInt\n\
    \            val opValueInt = opValue.toInt\n            val operandValueInt =\
    \ operandValue.toInt\n            val opValueInt = opValue.toInt\n           \
    \ val operandValueInt = operandValue.toInt\n            val opValueInt = opValue.toInt\n\
    \            val operandValueInt = operandValue.toInt\n            val opValueInt\
    \ = opValue.toInt\n            val operandValueInt = operandValue.toInt\n    \
    \        val opValueInt = opValue.toInt\n            val operandValueInt = operandValue.toInt\n\
    \            val opValueInt = opValue.toInt\n            val operandValueInt =\
    \ operandValue.toInt\n            val opValueInt = opValue.toInt\n           \
    \ val operandValueInt = operandValue.toInt\n            val opValueInt = opValue.toInt\n\
    \            val operandValueInt = operandValue.toInt\n            val opValueInt\
    \ = opValue.toInt\n            val operandValueInt = operandValue.toInt\n    \
    \        val opValueInt = opValue.toInt\n            val operandValueInt = operandValue.toInt\n\
    \            val opValueInt = opValue.toInt\n            val operandValueInt =\
    \ operandValue.toInt\n            val opValueInt = opValue.toInt\n           \
    \ val operandValueInt = operandValue.toInt\n            val opValueInt = opValue.toInt\n\
    \            val operandValueInt = operand\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpir_ete82.scala:81:0 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpir_ete82.scala:28:20\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpir_ete82.scala:41:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e\
    [0m \e[36mopValueInt\e[0m = opValue.toInt\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopValueInt is already defined as \e[33mvalue\e[0m \e[35mopValueInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpir_ete82.scala:42:16 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m            \e[33mval\e[0m \e[36moperandValueInt\e[0m = operandValue.toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandValueInt is already defined as \e[33mvalue\e[0m \e[35moperandValueInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpir_ete82.scala:43:16 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m            \e[33mval\e[0m \e[36mopValueInt\e[0m = opValue.toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mopValueInt is already defined as \e[33mvalue\e[0m \e[35mopValueInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpir_ete82.scala:44:16 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m            \e[33mval\e[0m \e[36moperandValueInt\e"
  stdout: ''
  timestamp: 1659792980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toLong).toList\n        val opLen = opList.length\n        val\
    \ operandLen = operandList.length - 1\n        val opMap = {\n            val\
    \ opMap = new mutable.HashMap[String, Long]()\n            opList.foreach(op =>\
    \ {\n                opMap.put(op, 0L)\n            })\n            opMap\n  \
    \      }\n        val operandMap = {\n            val operandMap = new mutable.HashMap[Long,\
    \ Long]()\n            operandList.foreach(operand => {\n                operandMap.put(operand,\
    \ 0L)\n            })\n            operandMap\n        }\n        val opMap2 =\
    \ {\n            val opMap2 = new mutable.HashMap[String, Long]()\n          \
    \  opList.foreach(op => {\n                opMap2.put(op, 0L)\n            })\n\
    \            opMap2\n        }\n        val operandMap2 = {\n            val operandMap2\
    \ = new mutable.HashMap[Long, Long]()\n            operandList.foreach(operand\
    \ => {\n                operandMap2.put(operand, 0L)\n            })\n       \
    \     operandMap2\n        }\n        val opMap3 = {\n            val opMap3 =\
    \ new mutable.HashMap[String, Long]()\n            opList.foreach(op => {\n  \
    \              opMap3.put(op, 0L)\n            })\n            opMap3\n      \
    \  }\n        val operandMap3 = {\n            val operandMap3 = new mutable.HashMap[Long,\
    \ Long]()\n            operandList.foreach(operand => {\n                operandMap3.put(operand,\
    \ 0L)\n            })\n            operandMap3\n        }\n        val opMap4\
    \ = {\n            val opMap4 = new mutable.HashMap[String, Long]()\n        \
    \    opList.foreach(op => {\n                opMap4.put(op, 0L)\n            })\n\
    \            opMap4\n        }\n        val operandMap4 = {\n            val operandMap4\
    \ = new mutable.HashMap[Long, Long]()\n            operandList.foreach(operand\
    \ => {\n                operandMap4.put(operand, 0L)\n            })\n       \
    \     operandMap4\n        }\n        val opMap5 = {\n            val opMap5 =\
    \ new mutable.HashMap[String, Long]()\n            opList.foreach(op => {\n  \
    \              opMap5.put(op, 0L)\n            })\n            opMap5\n      \
    \  }\n        val operandMap5 = {\n            val operandMap5 = new mutable.HashMap[Long,\
    \ Long]()\n            operandList.foreach(operand => {\n                operandMap5.put(operand,\
    \ 0L)\n            })\n            operandMap5\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2z67vl5d.scala:104:0 ---------------------------\e\
    [0m\e[0m\n\e[31m104 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2z67vl5d.scala:28:28\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m\
    \ \e[36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp2z67vl5d.scala:35:33 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36moperandMap\e[0m = \e\
    [33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp2z67vl5d.scala:42:29 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36mopMap2\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp2z67vl5d.scala:49:34 ------------------------\e[0m\e[0m\n\e[31m49 |\e\
    [0m            \e[33mval\e[0m \e[36moperandMap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mLong\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                                  Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2z67vl5d.scala:56:29\
    \ ------------------------\e[0m\e[0m\n\e[31m56 |\e[0m            \e[33mval\e[0m\
    \ \e[36mo"
  stdout: ''
  timestamp: 1659792980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val length = operands.length - 1\n        val\
    \ operators = ops.dropRight(1)\n        val result = operands.foldLeft(operands.head)\
    \ { (res, op) =>\n            val index = ops.indexOf(op)\n            val operand\
    \ = operands(index)\n            val operator = operators(index)\n           \
    \ val newRes = res * operand + operator\n            newRes\n        }\n     \
    \   result\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp7mx94yz.scala:32:12\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m            newRes\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Found:    (newRes\
    \ : String)\n\e[31m   |\e[0m            Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659792980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val opListLength\
    \ = opList.length\n        val operandList = operand.map(_.toLong)\n        val\
    \ operandListLength = operandList.length\n        val result = 0L\n        val\
    \ opIndex = 0\n        val operandIndex = 0\n        while(opIndex < opListLength\
    \ && operandIndex < operandListLength) {\n            val op = opList(opIndex)\n\
    \            val operand = operandList(operandIndex)\n            val result =\
    \ if (op == \"+\") {\n                result + operand\n            } else if\
    \ (op == \"-\") {\n                result - operand\n            } else if (op\
    \ == \"*\") {\n                result * operand\n            } else if (op ==\
    \ \"/\") {\n                result / operand\n            } else if (op == \"\
    //\") {\n                result // operand\n            } else if (op == \"**\"\
    ) {\n                result ** operand\n            }\n            opIndex +=\
    \ 1\n            operandIndex += 1\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa_22bh1h.scala:34:16 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                result + operand\n\e[31m\e[31m   |\e\
    [0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e\
    [0m \e[35mresult\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpa_22bh1h.scala:36:16 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m                result - operand\n\e[31m\e[31m   |\e[0m              \
    \  ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mresult\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa_22bh1h.scala:38:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                result\
    \ * operand\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m    \
    \            Recursive \e[33mvalue\e[0m \e[35mresult\e[0m needs type\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa_22bh1h.scala:40:16 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                result / operand\n\e[31m\e[31m   |\e\
    [0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e\
    [0m \e[35mresult\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpa_22bh1h.scala:42:16 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m                result \e[34m// operand\e[0m\n\e[31m\e[31m   |\e[0m  \
    \              ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e\
    [0m \e[35mresult\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpa_22bh1h.scala:44:16 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m                result ** operand\n\e[31m\e[31m   |\e[0m             \
    \   ^\e[0m\n\e[31m   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mresult\e\
    [0m needs type\n\e"
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val operatorList = opList.dropRight(1)\n  \
    \      val operator = operatorList.mkString(\"+\")\n        val operand = operandList.mkString(\"\
    +\")\n        val expression = s\"$operator $operand\"\n        val result = eval(expression)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3ss2ztnr.scala:27:22 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36moperand\e[0m = operandList.mkString(\e\
    [31m\"+\"\e[0m)\n\e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e\
    [0m                      Recursive \e[33mvalue\e[0m \e[35moperandList\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3ss2ztnr.scala:29:21\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = eval(expression)\n\e[31m\e[31m   |\e[0m                    \
    \ ^^^^\e[0m\n\e[31m   |\e[0m                     Not found: eval\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659792980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length - 1\n        val opArray = opList.map(_.toChar)\n     \
    \   val operandArray = operandList.map(_.toLong)\n        val opArrayLength =\
    \ opArray.length\n        val operandArrayLength = operandArray.length\n     \
    \   val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = operandArrayLength\n\
    \        val opArrayLength = opArrayLength\n        val operandArrayLength = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp97yhot6z.scala:78:32 ---------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e\
    [0m                                expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp97yhot6z.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopArrayLength\e[0m = opArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp97yhot6z.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m \e[35moperandArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp97yhot6z.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp97yhot6z.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandArrayLength is already "
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(x => x.toChar).toList\n        val operandList\
    \ = operand.map(x => x.toLong).toList\n        val opLength = opList.length\n\
    \        val operandLength = operandList.length\n        val opIndex = opList.indexOf(\"\
    +\")\n        val opIndex2 = opList.indexOf(\"-\")\n        val opIndex3 = opList.indexOf(\"\
    *\")\n        val opIndex4 = opList.indexOf(\"/\")\n        val opIndex5 = opList.indexOf(\"\
    **\")\n        val opIndex6 = opList.indexOf(\"%\")\n        val opIndex7 = opList.indexOf(\"\
    //\")\n        val opIndex8 = opList.indexOf(\"&\")\n        val opIndex9 = opList.indexOf(\"\
    |\")\n        val opIndex10 = opList.indexOf(\"^\")\n        val opIndex11 = opList.indexOf(\"\
    ~\")\n        val opIndex12 = opList.indexOf(\"<<\")\n        val opIndex13 =\
    \ opList.indexOf(\">>\")\n        val opIndex14 = opList.indexOf(\"==\")\n   \
    \     val opIndex15 = opList.indexOf(\"!=\")\n        val opIndex16 = opList.indexOf(\"\
    <\")\n        val opIndex17 = opList.indexOf(\">\")\n        val opIndex18 = opList.indexOf(\"\
    <=\")\n        val opIndex19 = opList.indexOf(\">=\")\n        val opIndex20 =\
    \ opList.indexOf(\"+\")\n        val opIndex21 = opList.indexOf(\"-\")\n     \
    \   val opIndex22 = opList.indexOf(\"*\")\n        val opIndex23 = opList.indexOf(\"\
    /\")\n        val opIndex24 = opList.indexOf(\"**\")\n        val opIndex25 =\
    \ opList.indexOf(\"%\")\n        val opIndex26 = opList.indexOf(\"//\")\n    \
    \    val opIndex27 = opList.indexOf(\"&\")\n        val opIndex28 = opList.indexOf(\"\
    |\")\n        val opIndex29 = opList.indexOf(\"^\")\n        val opIndex30 = opList.indexOf(\"\
    ~\")\n        val opIndex31 = opList.indexOf(\"<<\")\n        val opIndex32 =\
    \ opList.indexOf(\">>\")\n        val opIndex33 = opList.indexOf(\"==\")\n   \
    \     val opIndex34 = opList.indexOf(\"!=\")\n        val opIndex35 = opList.indexOf(\"\
    <\")\n        val opIndex36 = opList.indexOf(\">\")\n        val opIndex37 = opList.indexOf(\"\
    <=\")\n        val opIndex38 = opList.indexOf(\">=\")\n        val opIndex\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpit3lv2ez.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpit3lv2ez.scala:23:35\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mopList\e[0m = op.map(\e[36mx\e[0m => x.toChar).toList\n\e[31m\e[31m   |\e\
    [0m                                 ^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                      value toChar is not a member of String\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpit3lv2ez.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toInt)\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opList.zipWithIndex.toMap\n  \
    \      val operandMap = operandList.zipWithIndex.toMap\n        val opKeys = opMap.keys\n\
    \        val operandKeys = operandMap.keys\n        val opKeysLen = opKeys.length\n\
    \        val operandKeysLen = operandKeys.length\n        val opKeysMap = opKeys.zipWithIndex.toMap\n\
    \        val operandKeysMap = operandKeys.zipWithIndex.toMap\n        val opKeysMapLen\
    \ = opKeysMap.length\n        val operandKeysMapLen = operandKeysMap.length\n\
    \        val opKeysMapMap = opKeysMap.zipWithIndex.toMap\n        val operandKeysMapMap\
    \ = operandKeysMap.zipWithIndex.toMap\n        val opKeysMapMapLen = opKeysMapMap.length\n\
    \        val operandKeysMapMapLen = operandKeysMapMap.length\n        val opKeysMapMapMap\
    \ = opKeysMapMap.zipWithIndex.toMap\n        val operandKeysMapMapMap = operandKeysMapMap.zipWithIndex.toMap\n\
    \        val opKeysMapMapMapLen = opKeysMapMapMap.length\n        val operandKeysMapMapMapLen\
    \ = operandKeysMapMapMap.length\n        val opKeysMapMapMapMap = opKeysMapMapMap.zipWithIndex.toMap\n\
    \        val operandKeysMapMapMapMap = operandKeysMapMapMap.zipWithIndex.toMap\n\
    \        val opKeysMapMapMapMapLen = opKeysMapMapMapMap.length\n        val operandKeysMapMapMapMapLen\
    \ = operandKeysMapMapMapMap.length\n        val opKeysMapMapMapMapMap = opKeysMapMapMapMap.zipWithIndex.toMap\n\
    \        val operandKeysMapMapMapMapMap = operandKeysMapMapMapMap.zipWithIndex.toMap\n\
    \        val opKeysMapMapMapMapMapLen = opKeysMapMapMapMapMap.length\n       \
    \ val operandKeysMapMapMapMapMapLen = operandKeysMapMapMapMapMap.length\n    \
    \    val opKeysMapMapMapMapMapMap = opKeysMapMapMapMapMap.zipWithIndex.toMap\n\
    \        val operandKeysMapMapMapMapMapMap = operandKey\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvjfhpgh8.scala:31:31 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mopKeysLen\e[0m = opKeys.length\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        value length is not a member of Iterable[String]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpvjfhpgh8.scala:32:41 ------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36moperandKeysLen\e[0m = operandKeys.length\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                           value length is not a member of Iterable[Int]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvjfhpgh8.scala:35:37 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mopKeysMapLen\e[0m = opKeysMap.length\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        value length is not a member of Map[String,\
    \ Int]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvjfhpgh8.scala:36:47 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36moperandKeysMapLen\e[0m =\
    \ operandKeysMap.length\n\e[31m\e[31m   |\e[0m                               \
    \ ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           value\
    \ length is not a member of Map[Int, Int]\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpvjfhpgh8.scala:39:43 ------------------------\e[0m\e[0m\n\e[31m39 |\e\
    [0m        \e[33mval\e[0m \e[36mopKeysMapMapLen\e[0m = opKeysMapMap.length\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                 value length is not a member of Map[(String, Int),\
    \ Int]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvjfhpgh8.scala:40:53 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36moperandKeysMapMapLen\e[0m\
    \ = operandKeysMapMap.length\n\e[31m\e[31m   |\e[0m                          \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    value\
    \ length is not a member of Map[(Int, Int), Int]\n\e[31m\e[31m-- [E008] Not Found\
    \ Er"
  stdout: ''
  timestamp: 1659792982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toInt)\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = new mutable.HashMap[String, Int]()\n\
    \        val opMap2 = new mutable.HashMap[String, Int]()\n        val opMap3 =\
    \ new mutable.HashMap[String, Int]()\n        val opMap4 = new mutable.HashMap[String,\
    \ Int]()\n        val opMap5 = new mutable.HashMap[String, Int]()\n        val\
    \ opMap6 = new mutable.HashMap[String, Int]()\n        val opMap7 = new mutable.HashMap[String,\
    \ Int]()\n        val opMap8 = new mutable.HashMap[String, Int]()\n        val\
    \ opMap9 = new mutable.HashMap[String, Int]()\n        val opMap10 = new mutable.HashMap[String,\
    \ Int]()\n        val opMap11 = new mutable.HashMap[String, Int]()\n        val\
    \ opMap12 = new mutable.HashMap[String, Int]()\n        val opMap13 = new mutable.HashMap[String,\
    \ Int]()\n        val opMap14 = new mutable.HashMap[String, Int]()\n        val\
    \ opMap15 = new mutable.HashMap[String, Int]()\n        val opMap16 = new mutable.HashMap[String,\
    \ Int]()\n        val opMap17 = new mutable.HashMap[String, Int]()\n        val\
    \ opMap18 = new mutable.HashMap[String, Int]()\n        val opMap19 = new mutable.HashMap[String,\
    \ Int]()\n        val opMap20 = new mutable.HashMap[String, Int]()\n        val\
    \ opMap21 = new mutable.HashMap[String, Int]()\n        val opMap22 = new mutable.HashMap[String,\
    \ Int]()\n        val opMap23 = new mutable.HashMap[String, Int]()\n        val\
    \ opMap24 = new mutable.HashMap[String, Int]()\n        val opMap25 = new mutable.HashMap[String,\
    \ Int]()\n        val opMap26 = new mutable.HashMap[String, Int]()\n        val\
    \ opMap27 = new mutable.HashMap[String, Int]()\n        val opMap28 = new mutable.HashMap[String,\
    \ Int]()\n        val opMap29 = new mutable.HashMap[String, Int]()\n        val\
    \ opMap30 = new mutable.HashMap[String, Int]()\n        val opMap31 = new mutable.HashMap[String,\
    \ Int]()\n        val opMap\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz5c4ycw6.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz5c4ycw6.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpz5c4ycw6.scala:28:25 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mopMap2\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz5c4ycw6.scala:29:25\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap3\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpz5c4ycw6.scala:30:25 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mopMap4\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz5c4ycw6.scala:31:25\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mopMap5\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e\
    [0"
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val length = ops.size - 1\n        val result\
    \ = operands.foldLeft(operands.head) { (acc, op) =>\n            val index = ops.indexOf(op)\n\
    \            val value = acc + operands(index)\n            operands(index) =\
    \ value\n            value\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph4jfs0a1.scala:29:12 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            operands(index) = value\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not a member of List[Long]\
    \ - did you mean operands.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val operands\
    \ = operand.map(_.toLong).toList\n        val opLength = ops.size\n        val\
    \ operandLength = operands.size - 1\n        val opIndex = 0\n        val operandIndex\
    \ = 0\n        val result = operands(operandIndex)\n        while(opIndex < opLength)\
    \ {\n            val op = ops(opIndex)\n            val operand = operands(operandIndex)\n\
    \            val opResult = operand match {\n                case 0 => 0\n   \
    \             case 1 => operand\n                case _ => operand match {\n \
    \                   case 0 => 0\n                    case 1 => operand\n     \
    \               case _ => operand match {\n                        case 0 => 0\n\
    \                        case 1 => operand\n                        case _ =>\
    \ operand match {\n                            case 0 => 0\n                 \
    \           case 1 => operand\n                            case _ => operand match\
    \ {\n                                case 0 => 0\n                           \
    \     case 1 => operand\n                                case _ => operand match\
    \ {\n                                    case 0 => 0\n                       \
    \             case 1 => operand\n                                    case _ =>\
    \ operand match {\n                                        case 0 => 0\n     \
    \                                   case 1 => operand\n                      \
    \                  case _ => operand match {\n                               \
    \             case 0 => 0\n                                            case 1\
    \ => operand\n                                            case _ => operand match\
    \ {\n                                                case 0 => 0\n           \
    \                                     case 1 => operand\n                    \
    \                            case _ => operand match {\n                     \
    \                               case 0 => 0\n                                \
    \                    case 1 => operand\n                                     \
    \               case _ => operand match {\n                                  \
    \                      case 0 => 0\n                                         \
    \               case 1 => operand\n                                          \
    \              case _ => operand match {\n                                   \
    \                         case 0 => 0\n                                      \
    \                      case 1 => operand\n                                   \
    \                         case _ => operand match {\n                        \
    \                                        case 0 => 0\n                       \
    \                                         case 1 => operand\n                \
    \                                                case _ => operand match {\n \
    \                                                                   case 0 =>\
    \ 0\n                                                                    case\
    \ 1 => operand\n                                                             \
    \       case _ => operand match {\n                                          \
    \                              case 0 => 0\n                                 \
    \                                       case 1 => operand\n                  \
    \                                                      case _ => operand match\
    \ {\n                                                                        \
    \    case 0 => 0\n                                                           \
    \                 case 1 => operand\n                                        \
    \                                    case _ => operand match {\n             \
    \                                                                   case 0 =>\
    \ 0\n                                                                        \
    \        case 1 => operand\n                                                 \
    \                               case _ => operand match {\n                  \
    \                                                                  case 0 => 0\n\
    \                                                                            \
    \        case 1 => operand\n                                                 \
    \                                   case _ => operand match {\n              \
    \                                                                          case\
    \ 0 => 0\n                                                                   \
    \                     case 1 => operand\n                                    \
    \                                                    case _ => operand match {\n\
    \                                                                            \
    \                case 0 => 0\n                                               \
    \                                             case 1 => operand\n            \
    \                                                                            \
    \    case _ => operand match {\n                                             \
    \                                                   case 0 => 0\n            \
    \                                                                            \
    \        case 1 \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqzx51it2.scala:96:4 ----------------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqzx51it2.scala:104:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m104 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmpqzx51it2.scala:97:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m97 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659792980
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opLen = ops.length\n\
    \        val operands = operand.map(_.toLong)\n        val operandLen = operands.length\n\
    \        val opMap = new mutable.HashMap[String, Long]()\n        val operandMap\
    \ = new mutable.HashMap[String, Long]()\n        val result = new mutable.HashMap[String,\
    \ Long]()\n        val opMap2 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap2 = new mutable.HashMap[String, Long]()\n        val result2 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap3 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap3 = new mutable.HashMap[String, Long]()\n   \
    \     val result3 = new mutable.HashMap[String, Long]()\n        val opMap4 =\
    \ new mutable.HashMap[String, Long]()\n        val operandMap4 = new mutable.HashMap[String,\
    \ Long]()\n        val result4 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap5 = new mutable.HashMap[String, Long]()\n        val operandMap5 =\
    \ new mutable.HashMap[String, Long]()\n        val result5 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap6 = new mutable.HashMap[String, Long]()\n        val\
    \ operandMap6 = new mutable.HashMap[String, Long]()\n        val result6 = new\
    \ mutable.HashMap[String, Long]()\n        val opMap7 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap7 = new mutable.HashMap[String, Long]()\n   \
    \     val result7 = new mutable.HashMap[String, Long]()\n        val opMap8 =\
    \ new mutable.HashMap[String, Long]()\n        val operandMap8 = new mutable.HashMap[String,\
    \ Long]()\n        val result8 = new mutable.HashMap[String, Long]()\n       \
    \ val opMap9 = new mutable.HashMap[String, Long]()\n        val operandMap9 =\
    \ new mutable.HashMap[String, Long]()\n        val result9 = new mutable.HashMap[String,\
    \ Long]()\n        val opMap10 = new mutable.HashMap[String, Long]()\n       \
    \ val operandMap10 = new mutable.HashMap[String, Long]()\n        val result10\
    \ = new mutable.HashMap[String, Long]()\n        val opMap11 = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap11 = new mutable.HashMap[String, Long]()\n  \
    \      val result11 = new mutable.\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp254n69g0.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmp254n69g0.scala:27:24 ------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp254n69g0.scala:28:29\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp254n69g0.scala:29:25 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp254n69g0.scala:30:25 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mopMap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   \
    \      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp254n69g0.scala:31:30\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap2\e[0m = \e[33mnew\e[0m mutable.HashM"
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val operands\
    \ = operand.map(_.toLong).toList\n        val opLen = ops.size\n        val operandLen\
    \ = operands.size\n        val opIndex = ops.indexOf(\"+\")\n        val opIndex2\
    \ = ops.indexOf(\"-\")\n        val opIndex3 = ops.indexOf(\"*\")\n        val\
    \ opIndex4 = ops.indexOf(\"/\")\n        val opIndex5 = ops.indexOf(\"**\")\n\
    \        val opIndex6 = ops.indexOf(\"//\")\n        val opIndex7 = ops.indexOf(\"\
    %\")\n        val opIndex8 = ops.indexOf(\"*\")\n        val opIndex9 = ops.indexOf(\"\
    +\")\n        val opIndex10 = ops.indexOf(\"+\")\n        val opIndex11 = ops.indexOf(\"\
    *\")\n        val opIndex12 = ops.indexOf(\"+\")\n        val opIndex13 = ops.indexOf(\"\
    *\")\n        val opIndex14 = ops.indexOf(\"+\")\n        val opIndex15 = ops.indexOf(\"\
    *\")\n        val opIndex16 = ops.indexOf(\"+\")\n        val opIndex17 = ops.indexOf(\"\
    *\")\n        val opIndex18 = ops.indexOf(\"+\")\n        val opIndex19 = ops.indexOf(\"\
    *\")\n        val opIndex20 = ops.indexOf(\"+\")\n        val opIndex21 = ops.indexOf(\"\
    *\")\n        val opIndex22 = ops.indexOf(\"+\")\n        val opIndex23 = ops.indexOf(\"\
    *\")\n        val opIndex24 = ops.indexOf(\"+\")\n        val opIndex25 = ops.indexOf(\"\
    *\")\n        val opIndex26 = ops.indexOf(\"+\")\n        val opIndex27 = ops.indexOf(\"\
    *\")\n        val opIndex28 = ops.indexOf(\"+\")\n        val opIndex29 = ops.indexOf(\"\
    *\")\n        val opIndex30 = ops.indexOf(\"+\")\n        val opIndex31 = ops.indexOf(\"\
    *\")\n        val opIndex32 = ops.indexOf(\"+\")\n        val opIndex33 = ops.indexOf(\"\
    *\")\n        val opIndex34 = ops.indexOf(\"+\")\n        val opIndex35 = ops.indexOf(\"\
    *\")\n        val opIndex36 = ops.indexOf(\"+\")\n        val opIndex37 = ops.indexOf(\"\
    *\")\n        val opIndex38 = ops.indexOf(\"+\")\n        val opIndex39 = ops.indexOf(\"\
    *\")\n        val opIndex40 = ops.indexOf(\"+\")\n        val opIndex41 = ops.indexOf(\"\
    *\")\n        val opIndex42 = ops.indexOf(\"+\")\n        val opIndex43 = ops.indexOf(\"\
    *\")\n        val opIndex44 = ops.indexOf(\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpw5vj0mlb.scala:70:36 -----------------------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m        \e[33mval\e[0m \e[36mopIndex44\e[0m = ops.indexOf(\"\
    \n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e\
    [0m                                    unclosed string literal\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpw5vj0mlb.scala:71:5 ---------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operands.size\n        val operandLenMinusOne\
    \ = operandLen - 1\n        val opLenMinusOneMinusOne = opLen - 1 - 1\n      \
    \  val operandLenMinusOneMinusOne = operandLen - 1 - 1\n        val opLenMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOne = operandLen\
    \ - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOne = opLen - 1 -\
    \ 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOne = operandLen\
    \ - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val\
    \ opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = opLen\
    \ - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwse5zoqi.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpwse5zoqi.scala:43:5 ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toLowerCase)\n        val operands\
    \ = operand.map(x => x.toLong)\n        val opCount = ops.size\n        val operandCount\
    \ = operands.size\n        val result = operands.foldLeft(0L) {\n            (acc,\
    \ x) => acc + (ops(x) * x)\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0phvidop.scala:28:35\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            (\e[36macc\e[0m,\
    \ \e[36mx\e[0m) => acc + (ops(x) * x)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   Found:\
    \    (x : Long)\n\e[31m   |\e[0m                                   Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0phvidop.scala:28:40\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m            (\e[36macc\e[0m,\
    \ \e[36mx\e[0m) => acc + (ops(x) * x)\n\e[31m\e[31m   |\e[0m                 \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \          Found:    (x : Long)\n\e[31m   |\e[0m                             \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val operands =\
    \ operand.map(x => x.toLong)\n        val opLen = ops.size\n        val operandLen\
    \ = operands.size\n        val opIndex = ops.indexOf(\"+\")\n        val opIndex2\
    \ = ops.indexOf(\"-\")\n        val opIndex3 = ops.indexOf(\"*\")\n        val\
    \ opIndex4 = ops.indexOf(\"/\")\n        val opIndex5 = ops.indexOf(\"**\")\n\
    \        val opIndex6 = ops.indexOf(\"//\")\n        val opIndex7 = ops.indexOf(\"\
    %\")\n        val opIndex8 = ops.indexOf(\"*\")\n        val opIndex9 = ops.indexOf(\"\
    +\")\n        val opIndex10 = ops.indexOf(\"+\")\n        val opIndex11 = ops.indexOf(\"\
    *\")\n        val opIndex12 = ops.indexOf(\"*\")\n        val opIndex13 = ops.indexOf(\"\
    +\")\n        val opIndex14 = ops.indexOf(\"*\")\n        val opIndex15 = ops.indexOf(\"\
    *\")\n        val opIndex16 = ops.indexOf(\"*\")\n        val opIndex17 = ops.indexOf(\"\
    *\")\n        val opIndex18 = ops.indexOf(\"*\")\n        val opIndex19 = ops.indexOf(\"\
    *\")\n        val opIndex20 = ops.indexOf(\"*\")\n        val opIndex21 = ops.indexOf(\"\
    *\")\n        val opIndex22 = ops.indexOf(\"*\")\n        val opIndex23 = ops.indexOf(\"\
    *\")\n        val opIndex24 = ops.indexOf(\"*\")\n        val opIndex25 = ops.indexOf(\"\
    *\")\n        val opIndex26 = ops.indexOf(\"*\")\n        val opIndex27 = ops.indexOf(\"\
    *\")\n        val opIndex28 = ops.indexOf(\"*\")\n        val opIndex29 = ops.indexOf(\"\
    *\")\n        val opIndex30 = ops.indexOf(\"*\")\n        val opIndex31 = ops.indexOf(\"\
    *\")\n        val opIndex32 = ops.indexOf(\"*\")\n        val opIndex33 = ops.indexOf(\"\
    *\")\n        val opIndex34 = ops.indexOf(\"*\")\n        val opIndex35 = ops.indexOf(\"\
    *\")\n        val opIndex36 = ops.indexOf(\"*\")\n        val opIndex37 = ops.indexOf(\"\
    *\")\n        val opIndex38 = ops.indexOf(\"*\")\n        val opIndex39 = ops.indexOf(\"\
    *\")\n        val opIndex40 = ops.indexOf(\"*\")\n        val opIndex41 = ops.indexOf(\"\
    *\")\n        val opIndex42 = ops.indexOf(\"*\")\n        val opIndex43 = ops.indexOf(\"\
    *\")\n        val opIndex44 = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5pjvuk3t.scala:70:23 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m        \e[33mval\e[0m \e[36mopIndex44\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp5pjvuk3t.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e\
    [0m => x.toChar)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value toChar is not a member\
    \ of String\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5pjvuk3t.scala:71:5\
    \ ---------------------\e[0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val opLen =\
    \ opList.length\n        val operandList = operand.map(_.toLong)\n        val\
    \ operandLen = operandList.length\n        val opMap = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap = new mutable.HashMap[String, Long]()\n    \
    \    val opMapKeys = opList.map(x => x.toUpperCase)\n        val operandMapKeys\
    \ = operandList.map(x => x.toLong)\n        val opMapValues = opList.map(x =>\
    \ x.toUpperCase.charAt(0).toLong)\n        val operandMapValues = operandList.map(x\
    \ => x.toLong)\n        opMapKeys.zip(opMapValues).foreach(x => opMap += x)\n\
    \        operandMapKeys.zip(operandMapValues).foreach(x => operandMap += x)\n\
    \        val opMapKeySet = opMap.keySet\n        val operandMapKeySet = operandMap.keySet\n\
    \        val opMapValueSet = opMap.valueSet\n        val operandMapValueSet =\
    \ operandMap.valueSet\n        val opMapKeySetSize = opMapKeySet.size\n      \
    \  val operandMapKeySetSize = operandMapKeySet.size\n        val opMapValueSetSize\
    \ = opMapValueSet.size\n        val operandMapValueSetSize = operandMapValueSet.size\n\
    \        val opMapKeySetIterator = opMapKeySet.iterator\n        val operandMapKeySetIterator\
    \ = operandMapKeySet.iterator\n        val opMapValueSetIterator = opMapValueSet.iterator\n\
    \        val operandMapValueSetIterator = operandMapValueSet.iterator\n      \
    \  val opMapKeySetIteratorSize = opMapKeySetIterator.size\n        val operandMapKeySetIteratorSize\
    \ = operandMapKeySetIterator.size\n        val opMapValueSetIteratorSize = opMapValueSetIterator.size\n\
    \        val operandMapValueSetIteratorSize = operandMapValueSetIterator.size\n\
    \        val opMapKeySetIteratorIterator = opMapKeySetIterator.iterator\n    \
    \    val operandMapKeySetIteratorIterator = operandMapKeySetIterator.iterator\n\
    \        val opMapValueSetIteratorIterator = opMapValueSetIterator.iterator\n\
    \        val operandMapValueSetIteratorIterator = operandMapValueSetIterator.iterator\n\
    \        val opMapKeySetIteratorIteratorSize = opMapKeySetIteratorIterator.size\n\
    \        val operandMapKeySetIteratorIteratorSize = operandMapKeySetIteratorIterator.size\n\
    \        val opMapValueSetIteratorIteratorSize = opMapValueSetIteratorIter\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptxs9q_9q.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptxs9q_9q.scala:28:29\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmptxs9q_9q.scala:57:48 ------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36mopMapValueSetIteratorIteratorSize\e\
    [0m = opMapValueSetIteratorIter\n\e[31m\e[31m   |\e[0m                       \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                                Not found: opMapValueSetIteratorIter\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptxs9q_9q.scala:58:5 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.mkString(\"+\")\n        val opArray = ops.split(\"\
    \\\\+\")\n        val operands = operand.mkString(\"+\")\n        val operandArray\
    \ = operands.split(\"\\\\+\")\n        val opArrayLength = opArray.length\n  \
    \      val operandArrayLength = operandArray.length\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArrayLength\
    \ = operandArrayLength - 1\n        val opArrayLength = opArrayLength - 1\n  \
    \      val operandArrayLength = operandArrayLength - 1\n        val opArrayLength\
    \ = opArrayLength - 1\n        val operandArrayLength = operandArrayLength - 1\n\
    \        val opArrayLength = opArrayLength - 1\n        val operandArray\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpg8sylz9h.scala:75:4 ----------------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg8sylz9h.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopArrayLength\e[0m = opArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopArrayLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg8sylz9h.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandArrayLength\e[0m = operandArrayLength - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m \e[35moperandArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpg8sylz9h.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArrayLength -\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpg8sylz9h.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArrayLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35moperandArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the "
  stdout: ''
  timestamp: 1659792981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toInt).toList\n        val opLength = opList.size\n        val\
    \ operandLength = operandList.size\n        val opIndex = 0\n        val operandIndex\
    \ = 0\n        val opStack = new mutable.Stack[String]()\n        val operandStack\
    \ = new mutable.Stack[Long]()\n        val result = operandStack.head\n      \
    \  while (operandIndex < operandLength) {\n            while (opIndex < opLength)\
    \ {\n                opStack.push(opList(opIndex))\n                opIndex +=\
    \ 1\n            }\n            while (operandIndex < operandLength) {\n     \
    \           operandStack.push(operandList(operandIndex))\n                operandIndex\
    \ += 1\n            }\n            val op1 = opStack.mkString\n            val\
    \ op2 = operandStack.mkString\n            val opResult = op1 match {\n      \
    \          case \"+\" => op2\n                case \"-\" => op2\n            \
    \    case \"*\" => op2\n                case \"/\" => op2\n                case\
    \ \"%\" => op2\n                case \"^\" => op2\n                case \"**\"\
    \ => op2\n                case _ => throw new Exception(\"Invalid operator: \"\
    \ + op1)\n            }\n            result += opResult\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf7hw5yxz.scala:29:26 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mopStack\e[0m = \e[33mnew\e\
    [0m mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf7hw5yxz.scala:30:31\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36moperandStack\e[0m = \e[33mnew\e[0m mutable.Stack[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                               ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpf7hw5yxz.scala:35:24 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                opIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value\
    \ += is not a member of Int - did you mean opIndex.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpf7hw5yxz.scala:39:29 ------------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m                operandIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value\
    \ += is not a member of Int - did you mean operandIndex.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659792982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length - 1\n        val result = operandList.foldLeft(0)((acc,\
    \ x) => acc + (opList(x) * operandList(x)))\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe6l1bjg_.scala:27:71\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = operandList.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc\
    \ + (opList(x) * operandList(x)))\n\e[31m\e[31m   |\e[0m                     \
    \                                                  ^\e[0m\n\e[31m   |\e[0m   \
    \                                                 Found:    (x : Long)\n\e[31m\
    \   |\e[0m                                                    Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpe6l1bjg_.scala:27:88\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = operandList.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc\
    \ + (opList(x) * operandList(x)))\n\e[31m\e[31m   |\e[0m                     \
    \                                                                   ^\e[0m\n\e\
    [31m   |\e[0m                                                    Found:    (x\
    \ : Long)\n\e[31m   |\e[0m                                                   \
    \ Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length - 1\n        val opMap = new mutable.HashMap[String, Long]()\n\
    \        val operandMap = new mutable.HashMap[String, Long]()\n        val result\
    \ = 0L\n        val opIndex = 0\n        val operandIndex = 0\n        while(opIndex\
    \ < opLength && operandIndex < operandLength) {\n            val op = opList(opIndex)\n\
    \            val operand = operandList(operandIndex)\n            val operandValue\
    \ = operandMap(operand)\n            opMap(op) = operandValue\n            operandIndex\
    \ += 1\n            opIndex += 1\n        }\n        val opKeys = opMap.keys.toList\n\
    \        val opValues = opMap.values.toList\n        val operandKeys = operandMap.keys.toList\n\
    \        val operandValues = operandMap.values.toList\n        val opKeyIndex\
    \ = opKeys.indexOf(op(0))\n        val operandKeyIndex = operandKeys.indexOf(operand(0))\n\
    \        val opValue = opValues(opKeyIndex)\n        val operandValue = operandValues(operandKeyIndex)\n\
    \        val opValueInt = opValue.toInt\n        val operandValueInt = operandValue.toInt\n\
    \        val opValueLong = opValue.toLong\n        val operandValueLong = operandValue.toLong\n\
    \        val opValueFloat = opValue.toFloat\n        val operandValueFloat = operandValue.toFloat\n\
    \        val opValueDouble = opValue.toDouble\n        val operandValueDouble\
    \ = operandValue.toDouble\n        val opValueString = opValue.toString\n    \
    \    val operandValueString = operandValue.toString\n        val opValueBoolean\
    \ = opValue.toBoolean\n        val operandValueBoolean = operandValue.toBoolean\n\
    \        val opValueInt = opValue.toInt\n        val operandValueInt = operandValue.toInt\n\
    \        val opValueLong = opValue.toLong\n        val operandValueLong = operandValue.toLong\n\
    \        val opValueFloat = opValue.toFloat\n        val operandValueFloat = operandValue.toFloat\n\
    \        val opValueDouble = opValue.toDouble\n        val operandValueDouble\
    \ = operandValue.toDouble\n        val opValueString = opValue.toString\n    \
    \    val operandValueString = operandValue.toString\n        val opValueBoolean\
    \ = opValue.toBoolean\n        val operandValueBoolean = operandValue.toBoolean\n\
    \        val opValueInt = opValue.toInt\n        val operandValueInt = operandValue.toInt\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4s_m6oom.scala:60:12 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mopValueInt\e[0m = opValue.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopValueInt is already defined as \e[33mvalue\e[0m \e[35mopValueInt\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4s_m6oom.scala:61:12 ---------------------------\e[0m\e[0m\n\e[31m61\
    \ |\e[0m        \e[33mval\e[0m \e[36moperandValueInt\e[0m = operandValue.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0moperandValueInt is already defined as \e[33mvalue\e[0m \e[35moperandValueInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp4s_m6oom.scala:62:12 ---------------------------\e[0m\e[0m\n\e\
    [31m62 |\e[0m        \e[33mval\e[0m \e[36mopValueLong\e[0m = opValue.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopValueLong is already defined as \e[33mvalue\e[0m \e[35mopValueLong\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4s_m6oom.scala:63:12 ---------------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m        \e[33mval\e[0m \e[36moperandValueLong\e[0m = operandValue.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandValueLong is already defined as \e[33mvalue\e[0m \e[35moperandValueLong\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp4s_m6oom.scala:64:12 ---------------------------\e[0m\e[0m\n\e\
    [31m64 |\e[0m        \e[33mval\e[0m \e[36mopValueFloat\e[0m = opValue.toFloat\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mopValueFl"
  stdout: ''
  timestamp: 1659792982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toLong).toList\n        val operatorList = opList.filterNot(_.equals(\"\
    +\")).filterNot(_.equals(\"-\")).filterNot(_.equals(\"*\")).filterNot(_.equals(\"\
    //\")).filterNot(_.equals(\"**\"))\n        val operandListSize = operandList.size\n\
    \        val operatorListSize = operatorList.size\n        val result = operandListSize\
    \ match {\n            case 1 => operandList(0)\n            case 2 => operandList(0)\
    \ + operandList(1) * (operandListSize - 1)\n            case 3 => operandList(0)\
    \ + operandList(1) * operandList(2) * (operandListSize - 2)\n            case\
    \ 4 => operandList(0) + operandList(1) * operandList(2) * operandList(3) * (operandListSize\
    \ - 3)\n            case 5 => operandList(0) + operandList(1) * operandList(2)\
    \ * operandList(3) * operandList(4) * (operandListSize - 4)\n            case\
    \ 6 => operandList(0) + operandList(1) * operandList(2) * operandList(3) * operandList(4)\
    \ * operandList(5) * (operandListSize - 5)\n            case 7 => operandList(0)\
    \ + operandList(1) * operandList(2) * operandList(3) * operandList(4) * operandList(5)\
    \ * operandList(6) * (operandListSize - 6)\n            case 8 => operandList(0)\
    \ + operandList(1) * operandList(2) * operandList(3) * operandList(4) * operandList(5)\
    \ * operandList(6) * operandList(7) * (operandListSize - 7)\n            case\
    \ 9 => operandList(0) + operandList(1) * operandList(2) * operandList(3) * operandList(4)\
    \ * operandList(5) * operandList(6) * operandList(7) * operandList(8) * (operandListSize\
    \ - 8)\n            case 10 => operandList(0) + operandList(1) * operandList(2)\
    \ * operandList(3) * operandList(4) * operandList(5) * operandList(6) * operandList(7)\
    \ * operandList(8) * operandList(9) * (operandListSize - 9)\n            case\
    \ 11 => operandList(0) + operandList(1) * operandList(2) * operandList(3) * operandList(4)\
    \ * operandList(5) * operandList(6) * operandList(7) * operandList(8) * operandList(9)\
    \ * operandList(10) * (operandListSize - 10)\n            case 12 => operandList(0)\
    \ + operandList(1) * operandList(2) * operandList(3) * operandList(4) * operandList(5)\
    \ * operandList(6) * operandList(7) * operandList(8) * operandList(9) * operandList(10)\
    \ * operandList(11) * (operandListSize - 11)\n            case 13 => operandList(0)\
    \ + operandList(1) * operandList(2) * operandList(\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplw5rit3d.scala:41:86 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mcase\e[0m \e[31m13\e[0m => operandList(\e\
    [31m0\e[0m) + operandList(\e[31m1\e[0m) * operandList(\e[31m2\e[0m) * operandList(\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmplw5rit3d.scala:50:0 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplw5rit3d.scala:49:1\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmplw5rit3d.scala:43:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m43 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659792982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.size\n        val operandLen\
    \ = operandList.size\n        val opSet = opList.map(x => x.toUpperCase)\n   \
    \     val opSetLen = opSet.size\n        val operandSet = operandList.map(x =>\
    \ x.toLong)\n        val operandSetLen = operandSet.size\n        val opSetSet\
    \ = opSet.map(x => x.toUpperCase)\n        val opSetSetLen = opSetSet.size\n \
    \       val operandSetSet = operandSet.map(x => x.toLong)\n        val operandSetSetLen\
    \ = operandSetSet.size\n        val opSetSetSet = opSetSet.map(x => x.toUpperCase)\n\
    \        val opSetSetSetLen = opSetSetSet.size\n        val operandSetSetSet =\
    \ operandSetSet.map(x => x.toLong)\n        val operandSetSetSetLen = operandSetSetSet.size\n\
    \        val opSetSetSetSet = opSetSetSet.map(x => x.toUpperCase)\n        val\
    \ opSetSetSetSetLen = opSetSetSetSet.size\n        val operandSetSetSetSet = operandSetSetSet.map(x\
    \ => x.toLong)\n        val operandSetSetSetSetLen = operandSetSetSetSet.size\n\
    \        val opSetSetSetSetSet = opSetSetSetSet.map(x => x.toUpperCase)\n    \
    \    val opSetSetSetSetSetLen = opSetSetSetSetSet.size\n        val operandSetSetSetSetSet\
    \ = operandSetSetSetSet.map(x => x.toLong)\n        val operandSetSetSetSetSetLen\
    \ = operandSetSetSetSetSet.size\n        val opSetSetSetSetSetSet = opSetSetSetSetSet.map(x\
    \ => x.toUpperCase)\n        val opSetSetSetSetSetSetLen = opSetSetSetSetSetSet.size\n\
    \        val operandSetSetSetSetSetSet = operandSetSetSetSetSet.map(x => x.toLong)\n\
    \        val operandSetSetSetSetSetSetLen = operandSetSetSetSetSetSetSet.size\n\
    \        val opSetSetSetSetSetSetSet = opSetSetSetSetSetSet.map(x => x.toUpperCase)\n\
    \        val opSetSetSetSetSetSetSetLen = opSetSetSetSetSetSetSet.size\n     \
    \   val operandSetSetSetSetSetSetSet = operand\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpequhivq5.scala:54:5\
    \ ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.size\n        val operandLen\
    \ = operandList.size\n        val opArray = opList.map(_.toChar)\n        val\
    \ operandArray = operandList.map(_.toChar)\n        val opArrayLen = opArray.length\n\
    \        val operandArrayLen = operandArray.length\n        val opArrayArray =\
    \ opArray.map(_.toChar)\n        val operandArrayArray = operandArray.map(_.toChar)\n\
    \        val opArrayArrayLen = opArrayArray.length\n        val operandArrayArrayLen\
    \ = operandArrayArray.length\n        val opArrayArrayArray = opArrayArray.map(_.toChar)\n\
    \        val operandArrayArrayArray = operandArrayArray.map(_.toChar)\n      \
    \  val opArrayArrayArrayLen = opArrayArrayArray.length\n        val operandArrayArrayArrayLen\
    \ = operandArrayArrayArray.length\n        val opArrayArrayArrayArray = opArrayArrayArray.map(_.toChar)\n\
    \        val operandArrayArrayArrayArray = operandArrayArrayArray.map(_.toChar)\n\
    \        val opArrayArrayArrayArrayLen = opArrayArrayArrayArray.length\n     \
    \   val operandArrayArrayArrayArrayLen = operandArrayArrayArrayArray.length\n\
    \        val opArrayArrayArrayArrayArray = opArrayArrayArrayArray.map(_.toChar)\n\
    \        val operandArrayArrayArrayArrayArray = operandArrayArrayArrayArray.map(_.toChar)\n\
    \        val opArrayArrayArrayArrayArrayLen = opArrayArrayArrayArrayArray.length\n\
    \        val operandArrayArrayArrayArrayArrayLen = operandArrayArrayArrayArrayArray.length\n\
    \        val opArrayArrayArrayArrayArrayArray = opArrayArrayArrayArrayArray.map(_.toChar)\n\
    \        val operandArrayArrayArrayArrayArrayArray = operandArrayArrayArrayArrayArray.map(_.toChar)\n\
    \        val opArrayArrayArrayArrayArrayLen = opArrayArrayArrayArrayArrayArray.length\n\
    \        val operandArrayArrayArrayArrayArrayArrayLen = operandArrayArrayArrayArrayArrayArrayArray.length\n\
    \        val opArrayArrayArrayArrayArrayArrayArray = opArrayArrayArrayArrayArrayArrayArray.map(_.toChar)\n\
    \        val operandArrayArrayArrayArrayArrayArrayArray = operandArrayArrayArrayArrayArrayArrayArray.map(_.toChar)\n\
    \        val opArrayArrayArrayArrayArrayArrayArrayLen = opArrayArrayArrayArrayArrayArrayArrayArray.length\n\
    \        val operandArrayArrayArrayArrayArrayArrayArrayLen = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"\
    *\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n\
    \    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpl3qa7ros.scala:54:59 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36moperandArrayArrayArrayArrayArrayArrayArrayLen\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \           ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpl3qa7ros.scala:49:12 ---------------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m        \e[33mval\e[0m \e[36mopArrayArrayArrayArrayArrayLen\e[0m = opArrayArrayArrayArrayArrayArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopArrayArrayArrayArrayArrayLen is already defined as \e[33mvalue\e\
    [0m \e[35mopArrayArrayArrayArrayArrayLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl3qa7ros.scala:27:35 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopArray\e[0m = opList.map(_.toChar)\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                 value toChar is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl3qa7ros.scala:31:41 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mopArrayArray\e[0m = opArray.map(_.toChar)\n\
    \e[31m\e[31m   |\e[0m                                       ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue toChar is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2f"
  stdout: ''
  timestamp: 1659792984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toLowerCase)\n        val opLen\
    \ = ops.size\n        val opArray = ops.toArray\n        val operandArray = operand.toArray\n\
    \        val opArrayLen = opArray.length\n        val operandArrayLen = operandArray.length\n\
    \        val opArrayLenMinusOne = opArrayLen - 1\n        val operandArrayLenMinusOne\
    \ = operandArrayLen - 1\n        val opArrayLenMinusOneMinusOne = opArrayLenMinusOne\
    \ - 1\n        val operandArrayLenMinusOneMinusOne = operandArrayLenMinusOne -\
    \ 1\n        val opArrayLenMinusOneMinusOneMinusOne = opArrayLenMinusOneMinusOne\
    \ - 1\n        val operandArrayLenMinusOneMinusOneMinusOne = operandArrayLenMinusOneMinusOne\
    \ - 1\n        val opArrayLenMinusOneMinusOneMinusOneMinusOne = opArrayLenMinusOneMinusOneMinusOne\
    \ - 1\n        val operandArrayLenMinusOneMinusOneMinusOneMinusOne = operandArrayLenMinusOneMinusOneMinusOne\
    \ - 1\n        val opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOne = opArrayLenMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOne = operandArrayLenMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n        val operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n    \
    \    val opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne =\
    \ opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n   \
    \     val operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinus\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzfdqsic_.scala:40:78 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \                           ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35moperandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzfdqsic_.scala:41:81\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m\
    \ = opArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m                                                   \
    \                              ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mopArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzfdqsic_.scala:42:86\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e\
    [36moperandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinus\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: operandArrayLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinus\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzfdqsic_.scala:43:5\
    \ ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     R"
  stdout: ''
  timestamp: 1659792983
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length\n        val opSet = opList.map(_.toChar)\n        val\
    \ opSetLen = opSet.length\n        val operandSet = operandList.map(_.toChar)\n\
    \        val operandSetLen = operandSet.length\n        val opSetSet = opSet.zip(operandSet).map(x\
    \ => x._1 + x._2)\n        val opSetSetLen = opSetSet.length\n        val opSetSetSet\
    \ = opSet.zip(opSet).map(x => x._1 + x._2)\n        val opSetSetSetLen = opSetSetSet.length\n\
    \        val opSetSetSetSet = opSet.zip(opSet).zip(operandSet).map(x => x._1 +\
    \ x._2)\n        val opSetSetSetSetLen = opSetSetSetSet.length\n        val opSetSetSetSetSet\
    \ = opSet.zip(opSet).zip(opSet).zip(operandSet).map(x => x._1 + x._2 + x._3)\n\
    \        val opSetSetSetSetSetLen = opSetSetSetSetSet.length\n        val opSetSetSetSetSetSet\
    \ = opSet.zip(opSet).zip(opSet).zip(opSet).zip(operandSet).map(x => x._1 + x._2\
    \ + x._3 + x._4)\n        val opSetSetSetSetSetSetLen = opSetSetSetSetSetSet.length\n\
    \        val opSetSetSetSetSetSetSet = opSet.zip(opSet).zip(opSet).zip(opSet).zip(opSet).zip(operandSet).map(x\
    \ => x._1 + x._2 + x._3 + x._4 + x._5)\n        val opSetSetSetSetSetSetLen =\
    \ opSetSetSetSetSetSet.length\n        val opSetSetSetSetSetSetSet = opSet.zip(opSet).zip(opSet).zip(opSet).zip(opSet).zip(opSet).zip(operandSet).map(x\
    \ => x._1 + x._2 + x._3 + x._4 + x._5 + x._6)\n        val opSetSetSetSetSetSetSetLen\
    \ = opSetSetSetSetSetSetSet.length\n        val opSetSetSetSetSetSetSetSet = opSet.zip(opSet).zip(opSet).zip(opSet).zip(opSet).zip(opSet).zip(opSet).zip(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpif_wpfe9.scala:45:117 --------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mopSetSetSetSetSetSetSetSet\e\
    [0m = opSet.zip(opSet).zip(opSet).zip(opSet).zip(opSet).zip(opSet).zip(opSet).zip(\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpif_wpfe9.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopSetSetSetSetSetSetLen\e[0m = opSetSetSetSetSetSet.length\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopSetSetSetSetSetSetLen is already defined as \e[33mvalue\e\
    [0m \e[35mopSetSetSetSetSetSetLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpif_wpfe9.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mopSetSetSetSetSetSetSet\e\
    [0m = opSet.zip(opSet).zip(opSet).zip(opSet).zip(opSet).zip(opSet).zip(operandSet).map(\e\
    [36mx\e[0m => x._1 + x._2 + x._3 + x._4 + x._5 + x._6)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopSetSetSetSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mopSetSetSetSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpif_wpfe9.scala:27:33 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopSet\e[0m = opList.map(_.toChar)\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m     "
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.mkString(\"+\")\n        val opListLength\
    \ = opList.length\n        val operandList = operand.mkString(\"+\")\n       \
    \ val operandListLength = operandList.length\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmph2kc89wj.scala:74:31 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph2kc89wj.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopListLength\e[0m = opListLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopListLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mopListLength\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph2kc89wj.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandListLength\e[0m = operandListLength - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0moperandListLength is already defined as \e[33mvalue\e[0m \e[35moperandListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph2kc89wj.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mopListLength\e[0m = opListLength - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopListLength is already defined as \e[33mvalue\e[0m \e[35mopListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph2kc89wj.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m = operandListLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val opLength = opArray.length\n\
    \        val operandLength = operandArray.length\n        val opArrayLength =\
    \ opArray.length\n        val operandArrayLength = operandArray.length\n     \
    \   val opArrayLength = opArray.length\n        val operandArrayLength = operandArray.length\n\
    \        val opArrayLength = opArray.length\n        val operandArrayLength =\
    \ operandArray.length\n        val opArrayLength = opArray.length\n        val\
    \ operandArrayLength = operandArray.length\n        val opArrayLength = opArray.length\n\
    \        val operandArrayLength = operandArray.length\n        val opArrayLength\
    \ = opArray.length\n        val operandArrayLength = operandArray.length\n   \
    \     val opArrayLength = opArray.length\n        val operandArrayLength = operandArray.length\n\
    \        val opArrayLength = opArray.length\n        val operandArrayLength =\
    \ operandArray.length\n        val opArrayLength = opArray.length\n        val\
    \ operandArrayLength = operandArray.length\n        val opArrayLength = opArray.length\n\
    \        val operandArrayLength = operandArray.length\n        val opArrayLength\
    \ = opArray.length\n        val operandArrayLength = operandArray.length\n   \
    \     val opArrayLength = opArray.length\n        val operandArrayLength = operandArray.length\n\
    \        val opArrayLength = opArray.length\n        val operandArrayLength =\
    \ operandArray.length\n        val opArrayLength = opArray.length\n        val\
    \ operandArrayLength = operandArray.length\n        val opArrayLength = opArray.length\n\
    \        val operandArrayLength = operandArray.length\n        val opArrayLength\
    \ = opArray.length\n        val operandArrayLength = operandArray.length\n   \
    \     val opArrayLength = opArray.length\n        val operandArrayLength = operandArray.length\n\
    \        val opArrayLength = opArray.length\n        val operandArrayLength =\
    \ operandArray.length\n        val opArrayLength = opArray.length\n        val\
    \ operandArrayLength = operandArray.length\n        val opArrayLength = opArray.length\n\
    \        val operandArrayLength = operandArray.length\n        val opArrayLength\
    \ = opArray.length\n        val operandArrayLength = operandArray.length\n   \
    \     val opArrayLength = opArray.length\n        val operandArrayLength = operandArray.length\n\
    \        val opArrayLength = opArray.length\n        val operandArrayLength =\
    \ operandArray.length\n        val opArrayLength = opArray.length\n        val\
    \ operandArrayLength = operandArray.length\n        val opArrayLength = opArray.length\n\
    \        val operandArrayLength = operandArray.length\n        val opArrayLength\
    \ = opArray.length\n        val operandArrayLength = operandArray.length\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzhrre2_o.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzhrre2_o.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m \e[35moperandArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzhrre2_o.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mopArrayLength is already defined as \e[33mvalue\e[0m \e[35mopArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzhrre2_o.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36moperandArrayLength\e[0m = operandArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandArrayLength is already defined as \e[33mvalue\e[0m \e[35moperandArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzhrre2_o.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mopArrayLength\e[0m = opArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659792984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opNames = ops.map(_.toString)\n\
    \        val opNamesLength = opNames.map(_.length).sum\n        val opNamesLength\
    \ = opNamesLength.toInt\n        val opNamesLength = opNamesLength + 1\n     \
    \   val opNamesLength = opNamesLength.toInt\n        val opNamesLength = opNamesLength\
    \ + 1\n        val opNamesLength = opNamesLength.toInt\n        val opNamesLength\
    \ = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n     \
    \   val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        val opNamesLength = opNamesLength.toInt\n\
    \        val opNamesLength = opNamesLength + 1\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpadxohblv.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mopNamesLength\e[0m = opNamesLength.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mopNamesLength is already defined as \e[33mvalue\e[0m \e[35mopNamesLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpadxohblv.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mopNamesLength\e[0m = opNamesLength +\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopNamesLength is already defined as \e[33mvalue\e[0m \e[35mopNamesLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpadxohblv.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mopNamesLength\e[0m = opNamesLength.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mopNamesLength is already defined as \e[33mvalue\e[0m \e[35mopNamesLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpadxohblv.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mopNamesLength\e[0m = opNamesLength +\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopNamesLength is already defined as \e[33mvalue\e[0m \e[35mopNamesLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpadxohblv.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mopNamesLength\e[0m = opNamesLength.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659792984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val operandLen\
    \ = operands.size\n        val opArray = ops.toArray\n        val operandArray\
    \ = operands.toArray\n        val opArrayLen = opArray.length\n        val operandArrayLen\
    \ = operandArray.length\n        val opArrayIndex = 0\n        val operandArrayIndex\
    \ = 0\n        var result = 0L\n        while(opArrayIndex < opArrayLen && operandArrayIndex\
    \ < operandArrayLen) {\n            val op = ops(opArrayIndex)\n            val\
    \ operand = operands(operandArrayIndex)\n            val opIndex = ops.indexOf(op)\n\
    \            val operandIndex = operands.indexOf(operand)\n            val opValue\
    \ = (opIndex < opArrayLen) ? opArray(opIndex) : 0L\n            val operandValue\
    \ = (operandIndex < operandArrayLen) ? operandArray(operandIndex) : 0L\n     \
    \       val opValueLen = opValue.length\n            val operandValueLen = operandValue.length\n\
    \            val opValueIndex = 0\n            val operandValueIndex = 0\n   \
    \         val opValueArray = Array(opValueLen)\n            val operandValueArray\
    \ = Array(operandValueLen)\n            val opValueArrayLen = opValueArray.length\n\
    \            val operandValueArrayLen = operandValueArray.length\n           \
    \ val opValueArrayIndex = 0\n            val operandValueArrayIndex = 0\n    \
    \        val opValueArrayIndex2 = 0\n            val operandValueArrayIndex2 =\
    \ 0\n            val opValueArrayIndex3 = 0\n            val operandValueArrayIndex3\
    \ = 0\n            val opValueArrayIndex4 = 0\n            val operandValueArrayIndex4\
    \ = 0\n            val opValueArrayIndex5 = 0\n            val operandValueArrayIndex5\
    \ = 0\n            val opValueArrayIndex6 = 0\n            val operandValueArrayIndex6\
    \ = 0\n            val opValueArrayIndex7 = 0\n            val operandValueArrayIndex7\
    \ = 0\n            val opValueArrayIndex8 = 0\n            val operandValueArrayIndex8\
    \ = 0\n            val opValueArrayIndex9 = 0\n            val operandValueArrayIndex9\
    \ = 0\n            val opValueArrayIndex10 = 0\n            val operandValueArrayIndex10\
    \ = 0\n            val opValueArrayIndex11 = 0\n            val operandValueArrayIndex11\
    \ = 0\n            val opValueArrayIndex12 = 0\n            val operandValueArrayIndex12\
    \ = 0\n            val opValueArrayIndex13 = 0\n            val operandValueArrayIndex13\
    \ = 0\n            val opValueArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1e9df8s_.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1e9df8s_.scala:84:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp1e9df8s_.scala:39:49 ------------------------\e[0m\e[0m\n\
    \e[31m39 |\e[0m            \e[33mval\e[0m \e[36mopValue\e[0m = (opIndex < opArrayLen)\
    \ ? opArray(opIndex) : \e[31m0L\e[0m\n\e[31m\e[31m   |\e[0m                  \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \    value ? is not a member of Boolean\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp1e9df8s_.scala:40:64 ------------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m            \e[33mval\e[0m \e[36moperandValue\e[0m = (operandIndex < operandArrayLen)\
    \ ? operandArray(operandIndex) : \e[31m0L\e[0m\n\e[31m\e[31m   |\e[0m        \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value ? is not a member of Boolean\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp1e9df8s_.scala:41:37 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36mopValueLen\e[0m = opValue.length\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             value length is not a member of Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp1e9df8s_.scala:42:47 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m            \e[33mval\e[0m \e[36moperandValueLen\e[0m\
    \ = operandValue.length\n\e[31m\e[31m   |\e[0m                               \
    \   ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \  value length is not a member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp1e9df8s_.scala:83:1 ---------------------\e[0m\e[0m\n\e[31m83 |\e[0m}\n\
    \e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m\
    \ Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available"
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap : Map[String, Long] = opList.zip(operandList).map(x\
    \ => (x._1, x._2)).toMap\n        val opVal = opMap(\"+\")\n        val opVal2\
    \ = opMap(\"*\")\n        val opVal3 = opMap(\"-\")\n        val opVal4 = opMap(\"\
    /\")\n        val opVal5 = opMap(\"**\")\n        val opVal6 = opMap(\"//\")\n\
    \        val opVal7 = opMap(\"%\")\n        val opVal8 = opMap(\"*\")\n      \
    \  val opVal9 = opMap(\"+\")\n        val opVal10 = opMap(\"+\")\n        val\
    \ opVal11 = opMap(\"*\")\n        val opVal12 = opMap(\"*\")\n        val opVal13\
    \ = opMap(\"*\")\n        val opVal14 = opMap(\"*\")\n        val opVal15 = opMap(\"\
    *\")\n        val opVal16 = opMap(\"*\")\n        val opVal17 = opMap(\"*\")\n\
    \        val opVal18 = opMap(\"*\")\n        val opVal19 = opMap(\"*\")\n    \
    \    val opVal20 = opMap(\"*\")\n        val opVal21 = opMap(\"*\")\n        val\
    \ opVal22 = opMap(\"*\")\n        val opVal23 = opMap(\"*\")\n        val opVal24\
    \ = opMap(\"*\")\n        val opVal25 = opMap(\"*\")\n        val opVal26 = opMap(\"\
    *\")\n        val opVal27 = opMap(\"*\")\n        val opVal28 = opMap(\"*\")\n\
    \        val opVal29 = opMap(\"*\")\n        val opVal30 = opMap(\"*\")\n    \
    \    val opVal31 = opMap(\"*\")\n        val opVal32 = opMap(\"*\")\n        val\
    \ opVal33 = opMap(\"*\")\n        val opVal34 = opMap(\"*\")\n        val opVal35\
    \ = opMap(\"*\")\n        val opVal36 = opMap(\"*\")\n        val opVal37 = opMap(\"\
    *\")\n        val opVal38 = opMap(\"*\")\n        val opVal39 = opMap(\"*\")\n\
    \        val opVal40 = opMap(\"*\")\n        val opVal41 = opMap(\"*\")\n    \
    \    \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3dy4wier.scala:27:40\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopMap\e\
    [0m : \e[35mMap\e[0m[\e[35mString\e[0m, \e[35mLong\e[0m] = opList.zip(operandList).map(\e\
    [36mx\e[0m => (x._1, x._2)).toMap\n\e[31m\e[31m   |\e[0m                     \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Found:    Map[String, Long]\n\e[31m \
    \  |\e[0m                          Required: \e[1m\e[32mcollection\e[0m\e[1m\e\
    [32m.\e[0m\e[1m\e[32mmutable\e[0m\e[1m\e[32m.\e[0mMap[String, Long]\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3dy4wier.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length\n        val result = operandList.foldLeft(operandList.head)\
    \ { (acc, x) => \n            val opIndex = opList.indexOf(\"*\")\n          \
    \  val opIndex = opList.indexOf(\"//\")\n            val opIndex = opList.indexOf(\"\
    **\")\n            val opIndex = opList.indexOf(\"-\")\n            val opIndex\
    \ = opList.indexOf(\"+\")\n            val opIndex = opList.indexOf(\"/\")\n \
    \           val opIndex = opList.indexOf(\"%\")\n            val opIndex = opList.indexOf(\"\
    ^\")\n            val opIndex = opList.indexOf(\"&\")\n            val opIndex\
    \ = opList.indexOf(\"|\")\n            val opIndex = opList.indexOf(\"~\")\n \
    \           val opIndex = opList.indexOf(\"<<\")\n            val opIndex = opList.indexOf(\"\
    >>\")\n            val opIndex = opList.indexOf(\"|=\")\n            val opIndex\
    \ = opList.indexOf(\"==\")\n            val opIndex = opList.indexOf(\"!=\")\n\
    \            val opIndex = opList.indexOf(\"<\")\n            val opIndex = opList.indexOf(\"\
    >\")\n            val opIndex = opList.indexOf(\"<=\")\n            val opIndex\
    \ = opList.indexOf(\">=\")\n            val opIndex = opList.indexOf(\"==\")\n\
    \            val opIndex = opList.indexOf(\"!=\")\n            val opIndex = opList.indexOf(\"\
    &&\")\n            val opIndex = opList.indexOf(\"||\")\n            val opIndex\
    \ = opList.indexOf(\"??\")\n            val opIndex = opList.indexOf(\"??=\")\n\
    \            val opIndex = opList.indexOf(\"???\")\n            val opIndex =\
    \ opList.indexOf(\"????\")\n            val opIndex = opList.indexOf(\"????=\"\
    )\n            val opIndex = opList.indexOf(\"?????\")\n            val opIndex\
    \ = opList.indexOf(\"??????\")\n            val opIndex = opList.indexOf(\"??????=\"\
    )\n            val opIndex = opList.indexOf(\"???????\")\n            val opIndex\
    \ = opList.indexOf(\"????????\")\n            val opIndex = opList.indexOf(\"\
    ????????=\")\n            val opIndex = opList.indexOf(\"?????????\")\n      \
    \      val opIndex = opList.indexOf(\"??????????\")\n            val opIndex =\
    \ opList.indexOf(\"??????????=\")\n            val opIndex = opList.indexOf(\"\
    ???????????\")\n            val opIndex = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpy46xqlo9.scala:67:25 ---------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m            \e[33mval\e[0m \e[36mopIndex\e[0m = \n\e\
    [31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m          \
    \               expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpy46xqlo9.scala:76:0 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy46xqlo9.scala:29:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e\
    [0m \e[36mopIndex\e[0m = opList.indexOf(\e[31m\"//\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mopIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy46xqlo9.scala:30:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mopIndex\e[0m = opList.indexOf(\e[31m\"**\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mopIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy46xqlo9.scala:31:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36mopIndex\e[0m = opList.indexOf(\e[31m\"-\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mopIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy46xqlo9.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mopIndex\e[0m"
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val opLen =\
    \ opList.length\n        val operandList = operand.map(_.toLong)\n        val\
    \ operandLen = operandList.length\n        val opMap = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap = new mutable.HashMap[String, Long]()\n    \
    \    val result = new mutable.HashMap[String, Long]()\n        val opMapKeys =\
    \ opList.map(_.toUpperCase)\n        val opMapValues = opList.map(_.toUpperCase)\n\
    \        val operandMapKeys = operandList.map(_.toLong)\n        val operandMapValues\
    \ = operandList.map(_.toLong)\n        val opMapKeySet = opMapKeys.toSet\n   \
    \     val opMapValueSet = opMapValues.toSet\n        val operandMapKeySet = operandMapKeys.toSet\n\
    \        val operandMapValueSet = operandMapValues.toSet\n        val opMapKeysSet\
    \ = opMapKeys.toSet\n        val opMapValuesSet = opMapValues.toSet\n        val\
    \ operandMapKeysSet = operandMapKeys.toSet\n        val operandMapValuesSet =\
    \ operandMapValues.toSet\n        val opMapKeysSet2 = opMapKeys.toSet\n      \
    \  val opMapValuesSet2 = opMapValues.toSet\n        val operandMapKeysSet2 = operandMapKeys.toSet\n\
    \        val operandMapValuesSet2 = operandMapValues.toSet\n        val opMapKeysSet3\
    \ = opMapKeys.toSet\n        val opMapValuesSet3 = opMapValues.toSet\n       \
    \ val operandMapKeysSet3 = operandMapKeys.toSet\n        val operandMapValuesSet3\
    \ = operandMapValues.toSet\n        val opMapKeysSet4 = opMapKeys.toSet\n    \
    \    val opMapValuesSet4 = opMapValues.toSet\n        val operandMapKeysSet4 =\
    \ operandMapKeys.toSet\n        val operandMapValuesSet4 = operandMapValues.toSet\n\
    \        val opMapKeysSet5 = opMapKeys.toSet\n        val opMapValuesSet5 = opMapValues.toSet\n\
    \        val operandMapKeysSet5 = operandMapKeys.toSet\n        val operandMapValuesSet5\
    \ = operandMapValues.toSet\n        val opMapKeysSet6 = opMapKeys.toSet\n    \
    \    val opMapValuesSet6 = opMapValues.toSet\n        val operandMapKeysSet6 =\
    \ operandMapKeys.to\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5oqyaaf9.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5oqyaaf9.scala:28:29\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp5oqyaaf9.scala:29:25 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp5oqyaaf9.scala:61:5 ---------------------\e[0m\e[0m\n\e[31m61\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659792984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opList = ops.toList\n\
    \        val operands = operand.toList\n        val opLen = opList.size\n    \
    \    val operandLen = operands.size - 1\n        val opMap = opList.zip(operands).toMap\n\
    \        val opMapLen = opMap.size\n        val opMapKeys = opMap.keys\n     \
    \   val opMapValues = opMap.values.toList\n        val opMapValuesLen = opMapValues.size\n\
    \        val opMapValuesSum = opMapValues.sum\n        val opMapValuesSumLen =\
    \ opMapValuesSum.size\n        val opMapValuesSumSum = opMapValuesSum.sum\n  \
    \      val opMapValuesSumSumLen = opMapValuesSumSum.size\n        val opMapValuesSumSumSum\
    \ = opMapValuesSumSum.sum\n        val opMapValuesSumSumSumLen = opMapValuesSumSumSum.size\n\
    \        val opMapValuesSumSumSumSum = opMapValuesSumSumSum.sum\n        val opMapValuesSumSumSumSumLen\
    \ = opMapValuesSumSumSumSum.size\n        val opMapValuesSumSumSumSumSum = opMapValuesSumSumSumSum.sum\n\
    \        val opMapValuesSumSumSumSumLen = opMapValuesSumSumSumSumSum.size\n  \
    \      val opMapValuesSumSumSumSumSum = opMapValuesSumSumSumSumSum.sum\n     \
    \   val opMapValuesSumSumSumSumSumLen = opMapValuesSumSumSumSumSumSum.size\n \
    \       val opMapValuesSumSumSumSumSumSum = opMapValuesSumSumSumSumSumSum.sum\n\
    \        val opMapValuesSumSumSumSumSumSumLen = opMapValuesSumSumSumSumSumSumSum.size\n\
    \        val opMapValuesSumSumSumSumSumSumSum = opMapValuesSumSumSumSumSumSumSum.sum\n\
    \        val opMapValuesSumSumSumSumSumSumLen = opMapValuesSumSumSumSumSumSumSumSum.size\n\
    \        val opMapValuesSumSumSumSumSumSumSumSum = opMapValuesSumSumSumSumSumSumSumSum.sum\n\
    \        val opMapValuesSumSumSumSumSumSumSumLen = opMapValuesSumSumSumSumSumSumSumSumSum.size\n\
    \        val opMapValuesSumSumSumSumSumSumSumSum = opMapValuesSumSumSumSumSumSumSumSumSum.sum\n\
    \        val opMapValues\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2s74v9vr.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2s74v9vr.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopMapValuesSumSumSumSumLen\e[0m = opMapValuesSumSumSumSumSum.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapValuesSumSumSumSumLen is already defined as \e[33mvalue\e\
    [0m \e[35mopMapValuesSumSumSumSumLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2s74v9vr.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mopMapValuesSumSumSumSumSum\e\
    [0m = opMapValuesSumSumSumSumSum.sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapValuesSumSumSumSumSum is already defined as \e[33mvalue\e\
    [0m \e[35mopMapValuesSumSumSumSumSum\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2s74v9vr.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mopMapValuesSumSumSumSumSumSumLen\e\
    [0m = opMapValuesSumSumSumSumSumSumSumSum.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapValuesSumSumSumSumSumSumLen is already defined as \e\
    [33mvalue\e[0m \e[35mopMapValuesSumSumSumSumSumSumLen\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2s74v9vr.scala:51:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopMapValuesSumSumSumSumSumSumSumSum\e[0m = opMapValuesSumSumSumSumSumSumSumSumSum.sum\n\
    \e[31m\e["
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val result = operandList.foldLeft(operandList.head)\
    \ {\n            (acc, x) => acc match {\n                case 0 => x\n      \
    \          case 1 => acc\n                case _ => acc + x * opList(0)\n    \
    \        }\n        }\n        result * operandList(0)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpy03ylrza.scala:31:34 -----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m                \e[33mcase\e[0m _ => acc + x * opList(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                ^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m*\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e\
    [0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments\
    \ (String)\n1 error found\n"
  stdout: ''
  timestamp: 1659792984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.size\n        val operandLen\
    \ = operandList.size\n        val opIndex = opList.indexOf(\"+\")\n        val\
    \ opIndex2 = opList.indexOf(\"*\")\n        val opIndex3 = opList.indexOf(\"/\"\
    )\n        val opIndex4 = opList.indexOf(\"**\")\n        val opIndex5 = opList.indexOf(\"\
    //\")\n        val opIndex6 = opList.indexOf(\"**\")\n        val opIndex7 = opList.indexOf(\"\
    +\")\n        val opIndex8 = opList.indexOf(\"*\")\n        val opIndex9 = opList.indexOf(\"\
    /\")\n        val opIndex10 = opList.indexOf(\"**\")\n        val opIndex11 =\
    \ opList.indexOf(\"//\")\n        val opIndex12 = opList.indexOf(\"**\")\n   \
    \     val opIndex13 = opList.indexOf(\"+\")\n        val opIndex14 = opList.indexOf(\"\
    *\")\n        val opIndex15 = opList.indexOf(\"/\")\n        val opIndex16 = opList.indexOf(\"\
    **\")\n        val opIndex17 = opList.indexOf(\"//\")\n        val opIndex18 =\
    \ opList.indexOf(\"**\")\n        val opIndex19 = opList.indexOf(\"+\")\n    \
    \    val opIndex20 = opList.indexOf(\"*\")\n        val opIndex21 = opList.indexOf(\"\
    /\")\n        val opIndex22 = opList.indexOf(\"**\")\n        val opIndex23 =\
    \ opList.indexOf(\"//\")\n        val opIndex24 = opList.indexOf(\"**\")\n   \
    \     val opIndex25 = opList.indexOf(\"+\")\n        val opIndex26 = opList.indexOf(\"\
    *\")\n        val opIndex27 = opList.indexOf(\"/\")\n        val opIndex28 = opList.indexOf(\"\
    **\")\n        val opIndex29 = opList.indexOf(\"//\")\n        val opIndex30 =\
    \ opList.indexOf(\"**\")\n        val opIndex31 = opList.indexOf(\"+\")\n    \
    \    val opIndex32 = opList.indexOf(\"*\")\n        val opIndex33 = opList.indexOf(\"\
    /\")\n        val opIndex34 = opList.indexOf(\"**\")\n        val opIndex35 =\
    \ opList.indexOf(\"//\")\n        val opIndex36 = opList.indexOf(\"**\")\n   \
    \     val opIndex37 = opList.indexOf(\"+\")\n        val opIndex38 = opList.indexOf(\"\
    *\")\n        val opIndex39 = opList.indexOf(\"/\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpeso6dc9_.scala:65:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \e[36mopIndex39\e[0m = opList.indexOf(\"\
    /\n\e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m\
    \   |\e[0m                                       unclosed string literal\n\e[31m\e\
    [31m-- Error: /tmp/tmpeso6dc9_.scala:67:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpeso6dc9_.scala:66:5 ---------------------\e[0m\e[0m\n\e[31m66 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpeso6dc9_.scala:67:4 -------------------------\e[0m\e[0m\n\e[31m67 |\e\
    [0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e\
    [0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    Not found: /def\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659792984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar).map(x => x.toInt)\n    \
    \    val operands = operand.map(x => x.toLong)\n        val opLength = ops.size\n\
    \        val operandLength = operands.size\n        val result = operands.foldLeft(0)(_\
    \ + _)\n        val opIndex = 0\n        val operandIndex = 0\n        while(opIndex\
    \ < opLength && operandIndex < operandLength) {\n            val op = ops(opIndex)\n\
    \            val operand = operands(operandIndex)\n            val opResult =\
    \ if (op == '+') result + operand else result - operand\n            val opIndex\
    \ = opIndex + 1\n            val operandIndex = operandIndex + 1\n           \
    \ result = opResult\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3qofpsrl.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e\
    [0m => x.toChar).map(\e[36mx\e[0m => x.toInt)\n\e[31m\e[31m   |\e[0m         \
    \                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \     value toChar is not a member of String\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp3qofpsrl.scala:23:51 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e[0m => x.toChar).map(\e\
    [36mx\e[0m => x.toInt)\n\e[31m\e[31m   |\e[0m                                \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toInt is not a member of\
    \ Nothing, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\
    \e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\
    \e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3qofpsrl.scala:27:42\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m = operands.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m          \
    \                                ^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                         Found:    Long\n\e[31m   |\e[0m                    \
    \                      Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp3qofpsrl.scala:34:26 ---------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mopIndex\e[0m = opIndex +\
    \ \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m\
    \   |\e[0m                          Recursive \e[33mvalue\e[0m \e[35mopIndex\e\
    [0m needs t"
  stdout: ''
  timestamp: 1659792985
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val length = operands.length\n        val operators\
    \ = ops.dropRight(1)\n        val operandsLength = operands.length\n        val\
    \ result = operands.foldLeft(operands(0)) { (acc, x) => \n            val opIndex\
    \ = ops.indexOf(x)\n            val opLength = ops.length\n            val op\
    \ = (opIndex + opLength) % opLength\n            val operand = operands(opIndex)\n\
    \            val result = acc + operand * op\n            result\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$3(tmpq4iguu26.scala:32)\n\tat scala.runtime.java8.JFunction2$mcJJJ$sp.apply(JFunction2$mcJJJ$sp.scala:17)\n\
    \tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\
    \tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.doAlgebra(tmpq4iguu26.scala:34)\n\
    \tat Problem$.main(tmpq4iguu26.scala:39)\n\tat Problem.main(tmpq4iguu26.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toUpperCase)\n        val opLen\
    \ = ops.size\n        val opArray = ops.toArray\n        val opArrayLen = opArray.length\n\
    \        val operandLen = operand.size\n        val operandArray = operand.toArray\n\
    \        val operandArrayLen = operandArray.length\n        val result = operandArray(0)\n\
    \        val op1 = opArray(0)\n        val op2 = opArray(1)\n        val op3 =\
    \ opArray(2)\n        val op4 = opArray(3)\n        val op5 = opArray(4)\n   \
    \     val op6 = opArray(5)\n        val op7 = opArray(6)\n        val op8 = opArray(7)\n\
    \        val op9 = opArray(8)\n        val op10 = opArray(9)\n        val op11\
    \ = opArray(10)\n        val op12 = opArray(11)\n        val op13 = opArray(12)\n\
    \        val op14 = opArray(13)\n        val op15 = opArray(14)\n        val op16\
    \ = opArray(15)\n        val op17 = opArray(16)\n        val op18 = opArray(17)\n\
    \        val op19 = opArray(18)\n        val op20 = opArray(19)\n        val op21\
    \ = opArray(20)\n        val op22 = opArray(21)\n        val op23 = opArray(22)\n\
    \        val op24 = opArray(23)\n        val op25 = opArray(24)\n        val op26\
    \ = opArray(25)\n        val op27 = opArray(26)\n        val op28 = opArray(27)\n\
    \        val op29 = opArray(28)\n        val op30 = opArray(29)\n        val op31\
    \ = opArray(30)\n        val op32 = opArray(31)\n        val op33 = opArray(32)\n\
    \        val op34 = opArray(33)\n        val op35 = opArray(34)\n        val op36\
    \ = opArray(35)\n        val op37 = opArray(36)\n        val op38 = opArray(37)\n\
    \        val op39 = opArray(38)\n        val op40 = opArray(39)\n        val op41\
    \ = opArray(40)\n        val op42 = opArray(41)\n        val op43 = opArray(42)\n\
    \        val op44 = opArray(43)\n        val op45 = opArray(44)\n        val op46\
    \ = opArray(45)\n        val op47 = opArray(46)\n        val op48 = opArray(47\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqckkjkek.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpqckkjkek.scala:79:5 ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val opListLength\
    \ = opList.length\n        val operandList = operand.map(_.toLong)\n        val\
    \ operandListLength = operandList.length\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqay08qlx.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopListLength\e[0m = opListLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopListLength is already defined as \e[33mvalue\e[0m \e[35mopListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqay08qlx.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m = operandListLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandListLength is already defined as \e[33mvalue\e[0m \e\
    [35moperandListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqay08qlx.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mopListLength\e[0m = opListLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopListLength is already defined as \e[33mvalue\e[0m \e[35mopListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqay08qlx.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m = operandListLength\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandListLength is already defined as \e[33mvalue\e[0m \e\
    [35moperandListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqay08qlx.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mopListLength\e[0m = opListLength\
    \ - \e[31m1\e["
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val op1 = ops.head\n\
    \        val op2 = ops.last\n        val op3 = ops.dropRight(1)\n        val op4\
    \ = ops.dropRight(2)\n        val op5 = ops.dropRight(3)\n        val op6 = ops.dropRight(4)\n\
    \        val op7 = ops.dropRight(5)\n        val op8 = ops.dropRight(6)\n    \
    \    val op9 = ops.dropRight(7)\n        val op10 = ops.dropRight(8)\n       \
    \ val op11 = ops.dropRight(9)\n        val op12 = ops.dropRight(10)\n        val\
    \ op13 = ops.dropRight(11)\n        val op14 = ops.dropRight(12)\n        val\
    \ op15 = ops.dropRight(13)\n        val op16 = ops.dropRight(14)\n        val\
    \ op17 = ops.dropRight(15)\n        val op18 = ops.dropRight(16)\n        val\
    \ op19 = ops.dropRight(17)\n        val op20 = ops.dropRight(18)\n        val\
    \ op21 = ops.dropRight(19)\n        val op22 = ops.dropRight(20)\n        val\
    \ op23 = ops.dropRight(21)\n        val op24 = ops.dropRight(22)\n        val\
    \ op25 = ops.dropRight(23)\n        val op26 = ops.dropRight(24)\n        val\
    \ op27 = ops.dropRight(25)\n        val op28 = ops.dropRight(26)\n        val\
    \ op29 = ops.dropRight(27)\n        val op30 = ops.dropRight(28)\n        val\
    \ op31 = ops.dropRight(29)\n        val op32 = ops.dropRight(30)\n        val\
    \ op33 = ops.dropRight(31)\n        val op34 = ops.dropRight(32)\n        val\
    \ op35 = ops.dropRight(33)\n        val op36 = ops.dropRight(34)\n        val\
    \ op37 = ops.dropRight(35)\n        val op38 = ops.dropRight(36)\n        val\
    \ op39 = ops.dropRight(37)\n        val op40 = ops.dropRight(38)\n        val\
    \ op41 = ops.dropRight(39)\n        val op42 = ops.dropRight(40)\n        val\
    \ op43 = ops.dropRight(41)\n        val op44 = ops.dropRight(42)\n        val\
    \ op45 = ops.dropRight(43)\n        val op46 = ops.dropRight(44)\n        val\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9tgea42l.scala:70:11 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp9tgea42l.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e\
    [0m => x.toChar)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value toChar is not a member\
    \ of String\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9tgea42l.scala:71:5\
    \ ---------------------\e[0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operands.size - 1\n        val opLenMinusOneMinusOne\
    \ = opLen - 1 - 1\n        val operandLenMinusOne = operandLen - 1\n        val\
    \ opLenMinusOneMinusOneMinusOne = opLen - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val\
    \ operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne =\
    \ operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n\
    \        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1 - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpptdoaome.scala:40:131 --------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                                                                            \
    \       ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpptdoaome.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toInt).toList\n        val opLength = opList.size\n        val\
    \ operandLength = operandList.size\n        val opIndex = opList.indexOf(\"+\"\
    )\n        val opIndex2 = opList.indexOf(\"*\")\n        val opIndex3 = opList.indexOf(\"\
    /\")\n        val opIndex4 = opList.indexOf(\"**\")\n        val opIndex5 = opList.indexOf(\"\
    //\")\n        val opIndex6 = opList.indexOf(\"%\")\n        val opIndex7 = opList.indexOf(\"\
    |\")\n        val opIndex8 = opList.indexOf(\"&\")\n        val opIndex9 = opList.indexOf(\"\
    ^\")\n        val opIndex10 = opList.indexOf(\"~\")\n        val opIndex11 = opList.indexOf(\"\
    <<\")\n        val opIndex12 = opList.indexOf(\">>\")\n        val opIndex13 =\
    \ opList.indexOf(\"==\")\n        val opIndex14 = opList.indexOf(\"!=\")\n   \
    \     val opIndex15 = opList.indexOf(\"<\")\n        val opIndex16 = opList.indexOf(\"\
    >\")\n        val opIndex17 = opList.indexOf(\"<=\")\n        val opIndex18 =\
    \ opList.indexOf(\">=\")\n        val opIndex19 = opList.indexOf(\"!<\")\n   \
    \     val opIndex20 = opList.indexOf(\"!>\")\n        val opIndex21 = opList.indexOf(\"\
    !<=\")\n        val opIndex22 = opList.indexOf(\"!>\")\n        val opIndex23\
    \ = opList.indexOf(\"&&\")\n        val opIndex24 = opList.indexOf(\"||\")\n \
    \       val opIndex25 = opList.indexOf(\"!&&\")\n        val opIndex26 = opList.indexOf(\"\
    !||\")\n        val opIndex27 = opList.indexOf(\"|=\")\n        val opIndex28\
    \ = opList.indexOf(\"&=\")\n        val opIndex29 = opList.indexOf(\"^=\")\n \
    \       val opIndex30 = opList.indexOf(\"~=\")\n        val opIndex31 = opList.indexOf(\"\
    <<=\")\n        val opIndex32 = opList.indexOf(\">>=\")\n        val opIndex33\
    \ = opList.indexOf(\"==\")\n        val opIndex34 = opList.indexOf(\"!=\")\n \
    \       val opIndex35 = opList.indexOf(\"<\")\n        val opIndex36 = opList.indexOf(\"\
    >\")\n        val opIndex37 = opList.indexOf(\"<=\")\n        val opIndex38 =\
    \ opList.indexOf(\">\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbfgvpqlp.scala:64:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \e[36mopIndex38\e[0m = opList.indexOf(\"\
    >\n\e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m\
    \   |\e[0m                                       unclosed string literal\n\e[31m\e\
    [31m-- Error: /tmp/tmpbfgvpqlp.scala:66:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpbfgvpqlp.scala:65:5 ---------------------\e[0m\e[0m\n\e[31m65 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpbfgvpqlp.scala:66:4 -------------------------\e[0m\e[0m\n\e[31m66 |\e\
    [0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e\
    [0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    Not found: >def\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.size\n        val operandLength\
    \ = operandList.size\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n        val operandListIndex\
    \ = 0\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val opListIndex = 0\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_515h39j.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mopListLength\e[0m = opList.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopListLength is already defined as \e[33mvalue\e[0m \e[35mopListLength\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_515h39j.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m = operandList.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandListLength is already defined as \e[33mvalue\e[0m \e[35moperandListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_515h39j.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mopListIndex\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopListIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mopListIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_515h39j.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandListIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandListIndex is already defined as \e[33mvalue\e[0m \e\
    [35moperandListIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_515h39j.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mopListLength\e[0m = opList.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopListLength is already defined as \e[33mv"
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toInt)\n        val opLen = opList.length\n        val operandLen\
    \ = operandList.length - 1\n        val opMap = opList.zip(operandList)\n    \
    \    val opMapLen = opMap.length\n        val opMapMap = opMap.map(x => (x._1,\
    \ x._2))\n        val opMapMapLen = opMapMap.length\n        val opMapMapMap =\
    \ opMapMap.map(x => (x._1, x._2))\n        val opMapMapMapLen = opMapMapMap.length\n\
    \        val opMapMapMapMap = opMapMapMap.map(x => (x._1, x._2))\n        val\
    \ opMapMapMapMapLen = opMapMapMap.length\n        val opMapMapMapMapMap = opMapMapMap.map(x\
    \ => (x._1, x._2))\n        val opMapMapMapMapMapLen = opMapMapMapMap.length\n\
    \        val opMapMapMapMapMapMap = opMapMapMap.map(x => (x._1, x._2))\n     \
    \   val opMapMapMapMapMapMapLen = opMapMapMapMap.length\n        val opMapMapMapMapMapMapMap\
    \ = opMapMapMap.map(x => (x._1, x._2))\n        val opMapMapMapMapMapMapLen =\
    \ opMapMapMapMap.length\n        val opMapMapMapMapMapMapMap = opMapMapMap.map(x\
    \ => (x._1, x._2))\n        val opMapMapMapMapMapMapLen = opMapMapMapMapMap.length\n\
    \        val opMapMapMapMapMapMapMapMap = opMapMapMap.map(x => (x._1, x._2))\n\
    \        val opMapMapMapMapMapMapLen = opMapMapMapMapMap.length\n        val opMapMapMapMapMapMapMap\
    \ = opMapMapMap.map(x => (x._1, x._2))\n        val opMapMapMapMapMapMapLen =\
    \ opMapMapMapMapMap.length\n        val opMapMapMapMapMapMapMap = opMapMapMap.map(x\
    \ => (x._1, x._2))\n        val opMapMapMapMapMapMapLen = opMapMapMapMapMap.length\n\
    \        val opMapMapMapMapMapMapMap = opMapMapMap.map(x => (x._1, x._2))\n  \
    \      val opMapMapMapMapMapMapLen = opMapMapMapMapMap.length\n        val opMapMapMapMapMapMapMap\
    \ = opMapMapMap.\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuqiudw17.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpuqiudw17.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mopMapMapMapMapMapMapLen\e[0m = opMapMapMapMap.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapMapMapMapMapMapLen is already defined as \e[33mvalue\e\
    [0m \e[35mopMapMapMapMapMapMapLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuqiudw17.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mopMapMapMapMapMapMapMap\e\
    [0m = opMapMapMap.map(\e[36mx\e[0m => (x._1, x._2))\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mopMapMapMapMapMapMapMap is already defined as \e[33mvalue\e[0m \e\
    [35mopMapMapMapMapMapMapMap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpuqiudw17.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mopMapMapMapMapMapMapLen\e\
    [0m = opMapMapMapMapMap.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapMapMapMapMapMapLen is already defined as \e[33mvalue\e\
    [0m \e[35mopMapMapMapMapMapMapLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuqiudw17.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mopMapMapMapMapMapMapLen\e\
    [0m = opMapMapMapMapMap.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapMapMapMapMapMapLen "
  stdout: ''
  timestamp: 1659792986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opLen = ops.size\n\
    \        val opArray = ops.toArray\n        val operandArray = operand.toArray\n\
    \        val opArrayLen = opArray.length\n        val operandArrayLen = operandArray.length\n\
    \        val result = operandArray(0)\n        val op1 = opArray(0)\n        val\
    \ op2 = opArray(1)\n        val op3 = opArray(2)\n        val op4 = opArray(3)\n\
    \        val op5 = opArray(4)\n        val op6 = opArray(5)\n        val op7 =\
    \ opArray(6)\n        val op8 = opArray(7)\n        val op9 = opArray(8)\n   \
    \     val op10 = opArray(9)\n        val op11 = opArray(10)\n        val op12\
    \ = opArray(11)\n        val op13 = opArray(12)\n        val op14 = opArray(13)\n\
    \        val op15 = opArray(14)\n        val op16 = opArray(15)\n        val op17\
    \ = opArray(16)\n        val op18 = opArray(17)\n        val op19 = opArray(18)\n\
    \        val op20 = opArray(19)\n        val op21 = opArray(20)\n        val op22\
    \ = opArray(21)\n        val op23 = opArray(22)\n        val op24 = opArray(23)\n\
    \        val op25 = opArray(24)\n        val op26 = opArray(25)\n        val op27\
    \ = opArray(26)\n        val op28 = opArray(27)\n        val op29 = opArray(28)\n\
    \        val op30 = opArray(29)\n        val op31 = opArray(30)\n        val op32\
    \ = opArray(31)\n        val op33 = opArray(32)\n        val op34 = opArray(33)\n\
    \        val op35 = opArray(34)\n        val op36 = opArray(35)\n        val op37\
    \ = opArray(36)\n        val op38 = opArray(37)\n        val op39 = opArray(38)\n\
    \        val op40 = opArray(39)\n        val op41 = opArray(40)\n        val op42\
    \ = opArray(41)\n        val op43 = opArray(42)\n        val op44 = opArray(43)\n\
    \        val op45 = opArray(44)\n        val op46 = opArray(45)\n        val op47\
    \ = opArray(46)\n        val op48 = opArray(47)\n        val op49 = opArray(48)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa42mxp8l.scala:79:5\
    \ ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val operands\
    \ = operand.map(_.toInt).toList\n        val length = ops.length\n        val\
    \ result = operands.foldLeft(operands(0))((acc, x) => acc + x * ops(length - 1))\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpm_xjwd5p.scala:26:72 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = operands.foldLeft(operands(\e\
    [31m0\e[0m))((\e[36macc\e[0m, \e[36mx\e[0m) => acc + x * ops(length - \e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                                 \
    \                     ^^^\e[0m\n\e[31m   |\e[0m None of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m*\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\
    \e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m\
    \   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m \
    \ (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte):\
    \ Int\n\e[31m   |\e[0m match arguments (String)\n1 error found\n"
  stdout: ''
  timestamp: 1659792986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operands.size - 1\n        val opLenMinusOneMinusOne\
    \ = opLen - 1 - 1\n        val opLenMinusOneMinusOneMinusOne = opLen - 1 - 1 -\
    \ 1\n        val opLenMinusOneMinusOneMinusOneMinusOne = opLen - 1 - 1 - 1 - 1\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne = opLen - 1 -\
    \ 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\n  \
    \      val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1\
    \ - 1 - 1 - 1 - 1 - 1 - 1 - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = opLen - 1 - 1 - 1 - 1 - 1 - 1 - 1 - 1 - \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnzxy3kyz.scala:38:163 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e\
    [0m = opLen - \e[31m1\e[0m - \e[31m1\e[0m - \e[31m1\e[0m - \e[31m1\e[0m - \e[31m1\e\
    [0m - \e[31m1\e[0m - \e[31m1\e[0m - \e[31m1\e[0m - \n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \                                                                            \
    \        ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpnzxy3kyz.scala:39:5 ---------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opList = ops.toList\n\
    \        val operandList = operand.toList\n        val opLen = opList.size\n \
    \       val operandLen = operandList.size\n        val opIndex = ops.indexOf(\"\
    +\")\n        val opIndex2 = ops.indexOf(\"-\")\n        val opIndex3 = ops.indexOf(\"\
    *\")\n        val opIndex4 = ops.indexOf(\"/\")\n        val opIndex5 = ops.indexOf(\"\
    **\")\n        val opIndex6 = ops.indexOf(\"//\")\n        val opIndex7 = ops.indexOf(\"\
    %\")\n        val opIndex8 = ops.indexOf(\"&\")\n        val opIndex9 = ops.indexOf(\"\
    |\")\n        val opIndex10 = ops.indexOf(\"^\")\n        val opIndex11 = ops.indexOf(\"\
    ~\")\n        val opIndex12 = ops.indexOf(\"<<\")\n        val opIndex13 = ops.indexOf(\"\
    >>\")\n        val opIndex14 = ops.indexOf(\"==\")\n        val opIndex15 = ops.indexOf(\"\
    !=\")\n        val opIndex16 = ops.indexOf(\"<\")\n        val opIndex17 = ops.indexOf(\"\
    >\")\n        val opIndex18 = ops.indexOf(\"<=\")\n        val opIndex19 = ops.indexOf(\"\
    >=\")\n        val opIndex20 = ops.indexOf(\"==\")\n        val opIndex21 = ops.indexOf(\"\
    !=\")\n        val opIndex22 = ops.indexOf(\"&\")\n        val opIndex23 = ops.indexOf(\"\
    |\")\n        val opIndex24 = ops.indexOf(\"^\")\n        val opIndex25 = ops.indexOf(\"\
    ~\")\n        val opIndex26 = ops.indexOf(\"<<\")\n        val opIndex27 = ops.indexOf(\"\
    >>\")\n        val opIndex28 = ops.indexOf(\"==\")\n        val opIndex29 = ops.indexOf(\"\
    !=\")\n        val opIndex30 = ops.indexOf(\"<\")\n        val opIndex31 = ops.indexOf(\"\
    >\")\n        val opIndex32 = ops.indexOf(\"<=\")\n        val opIndex33 = ops.indexOf(\"\
    >=\")\n        val opIndex34 = ops.indexOf(\"==\")\n        val opIndex35 = ops.indexOf(\"\
    !=\")\n        val opIndex36 = ops.indexOf(\"&\")\n        val opIndex37 = ops.indexOf(\"\
    |\")\n        val opIndex38 = ops.indexOf(\"^\")\n        val opIndex39 = ops.indexOf(\"\
    ~\")\n        val opIndex40 = ops.indexOf(\"<<\")\n        val opIndex41 = ops.indexOf(\"\
    >>\")\n        val opIndex\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3d2lce_0.scala:70:4 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3d2lce_0.scala:70:5 ---------------------\e[0m\e[0m\n\e[31m70 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val operatorList = opList.take(operandList.length-1)\n\
    \        val operandList2 = operandList.drop(1)\n        val operatorList2 = opList.drop(operandList.length-1)\n\
    \        val operatorList3 = opList.drop(operandList.length-1)\n        val operandList3\
    \ = operandList.drop(1)\n        val operatorList4 = opList.drop(operandList.length-1)\n\
    \        val operandList4 = operandList.drop(1)\n        val operatorList5 = opList.drop(operandList.length-1)\n\
    \        val operandList5 = operandList.drop(1)\n        val operatorList6 = opList.drop(operandList.length-1)\n\
    \        val operandList6 = operandList.drop(1)\n        val operatorList7 = opList.drop(operandList.length-1)\n\
    \        val operandList7 = operandList.drop(1)\n        val operatorList8 = opList.drop(operandList.length-1)\n\
    \        val operandList8 = operandList.drop(1)\n        val operatorList9 = opList.drop(operandList.length-1)\n\
    \        val operandList9 = operandList.drop(1)\n        val operatorList10 =\
    \ opList.drop(operandList.length-1)\n        val operandList10 = operandList.drop(1)\n\
    \        val operatorList11 = opList.drop(operandList.length-1)\n        val operandList11\
    \ = operandList.drop(1)\n        val operatorList12 = opList.drop(operandList.length-1)\n\
    \        val operandList12 = operandList.drop(1)\n        val operatorList13 =\
    \ opList.drop(operandList.length-1)\n        val operandList13 = operandList.drop(1)\n\
    \        val operatorList14 = opList.drop(operandList.length-1)\n        val operandList14\
    \ = operandList.drop(1)\n        val operatorList15 = opList.drop(operandList.length-1)\n\
    \        val operandList15 = operandList.drop(1)\n        val operatorList16 =\
    \ opList.drop(operandList.length-1)\n        val operandList16 = operandList.drop(1)\n\
    \        val operatorList17 = opList.drop(operandList.length-1)\n        val operandList17\
    \ = operandList.drop(1)\n        val operatorList18 = opList.drop(operandList.length-1)\n\
    \        val operandList18 = operandList.drop(1)\n        val operatorList19 =\
    \ opList.drop(operandList.length-1)\n        val operandList19 = operandList.drop(1)\n\
    \        val operatorList20 = opList.drop(operandList.length-1)\n        val operandList20\
    \ = operandList.drop(1)\n        val operatorList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqhdrc0tk.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpqhdrc0tk.scala:65:5 ---------------------\e[0m\e[0m\n\e[31m65 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opList = ops.toList\n\
    \        val operandList = operand.toList\n        val opLen = opList.size\n \
    \       val operandLen = operandList.size\n        val opLenMinusOne = opLen -\
    \ 1\n        val operandLenMinusOne = operandLen - 1\n        val opLenMinusOneOpLen\
    \ = opLenMinusOne * opLen\n        val operandLenMinusOneOpLen = operandLenMinusOne\
    \ * operandLen\n        val opLenMinusOneOpLenMinusOne = opLenMinusOneOpLen -\
    \ 1\n        val operandLenMinusOneOpLenMinusOne = operandLenMinusOneOpLen - 1\n\
    \        val opLenMinusOneOpLenMinusOneOpLen = opLenMinusOneOpLenMinusOne * opLenMinusOne\n\
    \        val operandLenMinusOneOpLenMinusOneOpLen = operandLenMinusOneOpLenMinusOne\
    \ * operandLenMinusOne\n        val opLenMinusOneOpLenMinusOneOpLenMinusOne =\
    \ opLenMinusOneOpLenMinusOneOpLen * opLenMinusOneOpLen\n        val operandLenMinusOneOpLenMinusOneOpLenMinusOne\
    \ = operandLenMinusOneOpLenMinusOneOpLen * operandLenMinusOneOpLenMinusOne\n \
    \       val opLenMinusOneOpLenMinusOneOpLenMinusOneOpLen = opLenMinusOneOpLenMinusOneOpLenMinusOne\
    \ * opLenMinusOneOpLenMinusOneOpLen\n        val operandLenMinusOneOpLenMinusOneOpLenMinusOneOpLen\
    \ = operandLenMinusOneOpLenMinusOneOpLenMinusOne * operandLenMinusOneOpLenMinusOneOpLenMinusOne\n\
    \        val opLenMinusOneOpLenMinusOneOpLenMinusOneOpLenMinusOne = opLenMinusOneOpLenMinusOneOpLenMinusOneOpLen\
    \ * opLenMinusOneOpLenMinusOneOpLenMinusOneOpLen\n        val operandLenMinusOneOpLenMinusOneOpLenMinusOneOpLenMinusOne\
    \ = operandLenMinusOneOpLenMinusOneOpLenMinusOneOpLen * operandLenMinusOneOpLenMinusOneOpLenMinusOneOp\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5m7ol6ls.scala:41:124 -----------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36moperandLenMinusOneOpLenMinusOneOpLenMinusOneOpLenMinusOne\e\
    [0m = operandLenMinusOneOpLenMinusOneOpLenMinusOneOpLen * operandLenMinusOneOpLenMinusOneOpLenMinusOneOp\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m               Not found: operandLenMinusOneOpLenMinusOneOpLenMinusOneOp\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5m7ol6ls.scala:42:5\
    \ ---------------------\e[0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opLen = ops.size\n\
    \        val opArray = ops.toArray\n        val operandArray = operand.toArray\n\
    \        val operandLen = operandArray.length\n        val opArrayLen = opArray.length\n\
    \        val result = operandArray(0)\n        val op1 = opArray(0)\n        val\
    \ op2 = opArray(1)\n        val op3 = opArray(2)\n        val op4 = opArray(3)\n\
    \        val op5 = opArray(4)\n        val op6 = opArray(5)\n        val op7 =\
    \ opArray(6)\n        val op8 = opArray(7)\n        val op9 = opArray(8)\n   \
    \     val op10 = opArray(9)\n        val op11 = opArray(10)\n        val op12\
    \ = opArray(11)\n        val op13 = opArray(12)\n        val op14 = opArray(13)\n\
    \        val op15 = opArray(14)\n        val op16 = opArray(15)\n        val op17\
    \ = opArray(16)\n        val op18 = opArray(17)\n        val op19 = opArray(18)\n\
    \        val op20 = opArray(19)\n        val op21 = opArray(20)\n        val op22\
    \ = opArray(21)\n        val op23 = opArray(22)\n        val op24 = opArray(23)\n\
    \        val op25 = opArray(24)\n        val op26 = opArray(25)\n        val op27\
    \ = opArray(26)\n        val op28 = opArray(27)\n        val op29 = opArray(28)\n\
    \        val op30 = opArray(29)\n        val op31 = opArray(30)\n        val op32\
    \ = opArray(31)\n        val op33 = opArray(32)\n        val op34 = opArray(33)\n\
    \        val op35 = opArray(34)\n        val op36 = opArray(35)\n        val op37\
    \ = opArray(36)\n        val op38 = opArray(37)\n        val op39 = opArray(38)\n\
    \        val op40 = opArray(39)\n        val op41 = opArray(40)\n        val op42\
    \ = opArray(41)\n        val op43 = opArray(42)\n        val op44 = opArray(43)\n\
    \        val op45 = opArray(44)\n        val op46 = opArray(45)\n        val op47\
    \ = opArray(46)\n        val op48 = opArray(47)\n        val op49 = opArray(48)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaqz4lajd.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.size\n        val operandLen\
    \ = operandList.size\n        val opIndex = opList.indexOf(\"+\")\n        val\
    \ opLenMinusOne = opLen - 1\n        val operandIndexMinusOne = operandLen - 1\n\
    \        val opIndexMinusOne = opIndex - 1\n        val opIndexMinusTwo = opIndex\
    \ - 1\n        val opIndexMinusThree = opIndex - 1\n        val opIndexMinusFour\
    \ = opIndex - 1\n        val opIndexMinusFive = opIndex - 1\n        val opIndexMinusSix\
    \ = opIndex - 1\n        val opIndexMinusSeven = opIndex - 1\n        val opIndexMinusEight\
    \ = opIndex - 1\n        val opIndexMinusNine = opIndex - 1\n        val opIndexMinusTen\
    \ = opIndex - 1\n        val opIndexMinusEleven = opIndex - 1\n        val opIndexMinusTwelve\
    \ = opIndex - 1\n        val opIndexMinusThirteen = opIndex - 1\n        val opIndexMinusFourteen\
    \ = opIndex - 1\n        val opIndexMinusFifteen = opIndex - 1\n        val opIndexMinusSixteen\
    \ = opIndex - 1\n        val opIndexMinusSeventeen = opIndex - 1\n        val\
    \ opIndexMinusEighteen = opIndex - 1\n        val opIndexMinusNineteen = opIndex\
    \ - 1\n        val opIndexMinusTwenty = opIndex - 1\n        val opIndexMinusThirty\
    \ = opIndex - 1\n        val opIndexMinusFourty = opIndex - 1\n        val opIndexMinusFifty\
    \ = opIndex - 1\n        val opIndexMinusSixty = opIndex - 1\n        val opIndexMinusSeventy\
    \ = opIndex - 1\n        val opIndexMinusEighty = opIndex - 1\n        val opIndexMinusNinety\
    \ = opIndex - 1\n        val opIndexMinusOne = opIndex - 1\n        val opIndexMinusTwo\
    \ = opIndex - 1\n        val opIndexMinusThree = opIndex - 1\n        val opIndexMinusFour\
    \ = opIndex - 1\n        val opIndexMinusFive = opIndex - 1\n        val opIndexMinusSix\
    \ = opIndex - 1\n        val opIndexMinusSeven = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpuj5b4egr.scala:63:31 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mopIndexMinusSeven\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m\
    \                               expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuj5b4egr.scala:57:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopIndexMinusOne\e[0m = opIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopIndexMinusOne\
    \ is already defined as \e[33mvalue\e[0m \e[35mopIndexMinusOne\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuj5b4egr.scala:58:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopIndexMinusTwo\e[0m = opIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopIndexMinusTwo\
    \ is already defined as \e[33mvalue\e[0m \e[35mopIndexMinusTwo\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuj5b4egr.scala:59:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopIndexMinusThree\e[0m = opIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopIndexMinusThree\
    \ is already defined as \e[33mvalue\e[0m \e[35mopIndexMinusThree\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpuj5b4egr.scala:60:12 ---------------------------\e[0m\e[0m\n\e[31m60\
    \ |\e[0m        \e[33mval\e[0m \e[36mopIndexMinusFour\e[0m = opIndex - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mopIndexMinusFour is alrea"
  stdout: ''
  timestamp: 1659792987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val opList = ops.toList\n\
    \        val operands = operand.toList\n        val opLen = opList.size\n    \
    \    val operandLen = operands.size\n        val opLenMinusOne = opLen - 1\n \
    \       val operandLenMinusOne = operandLen - 1\n        val opLenMinusTwo = opLen\
    \ - 2\n        val operandLenMinusTwo = operandLen - 2\n        val opLenMinusThree\
    \ = opLen - 3\n        val operandLenMinusThree = operandLen - 3\n        val\
    \ opLenMinusFour = opLen - 4\n        val operandLenMinusFour = operandLen - 4\n\
    \        val opLenMinusFive = opLen - 5\n        val operandLenMinusFive = operandLen\
    \ - 5\n        val opLenMinusSix = opLen - 6\n        val operandLenMinusSix =\
    \ operandLen - 6\n        val opLenMinusSeven = opLen - 7\n        val operandLenMinusSeven\
    \ = operandLen - 7\n        val opLenMinusEight = opLen - 8\n        val operandLenMinusEight\
    \ = operandLen - 8\n        val opLenMinusNine = opLen - 9\n        val operandLenMinusNine\
    \ = operandLen - 9\n        val opLenMinusTen = opLen - 10\n        val operandLenMinusTen\
    \ = operandLen - 10\n        val opLenMinusEleven = opLen - 11\n        val operandLenMinusEleven\
    \ = operandLen - 11\n        val opLenMinusTwelve = opLen - 12\n        val operandLenMinusTwelve\
    \ = operandLen - 12\n        val opLenMinusThirteen = opLen - 13\n        val\
    \ operandLenMinusThirteen = operandLen - 13\n        val opLenMinusFourteen =\
    \ opLen - 14\n        val operandLenMinusFourteen = operandLen - 14\n        val\
    \ opLenMinusFifteen = opLen - 15\n        val operandLenMinusFifteen = operandLen\
    \ - 15\n        val opLenMinusSixteen = opLen - 16\n        val operandLenMinusSixteen\
    \ = operandLen - 16\n        val opLenMinusSeventeen = opLen - 17\n        val\
    \ operandLenMinusSeventeen = operand\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3qf5ta0k.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e\
    [0m => x.toChar)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value toChar is not a member\
    \ of String\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3qf5ta0k.scala:62:5\
    \ ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opList = ops.toList\n\
    \        val opLen = opList.size\n        val opLenMinusOne = opLen - 1\n    \
    \    val operandLen = operand.size\n        val operandLenMinusOne = operandLen\
    \ - 1\n        val operandList = new mutable.MutableList[Long]()\n        val\
    \ operandListLen = operandList.size\n        val operandListLenMinusOne = operandListLen\
    \ - 1\n        val operandList2 = new mutable.MutableList[Long]()\n        val\
    \ operandList2Len = operandList2.size\n        val operandList2LenMinusOne = operandList2Len\
    \ - 1\n        val operandList3 = new mutable.MutableList[Long]()\n        val\
    \ operandList3Len = operandList3.size\n        val operandList3LenMinusOne = operandList3Len\
    \ - 1\n        val operandList4 = new mutable.MutableList[Long]()\n        val\
    \ operandList4Len = operandList4.size\n        val operandList4LenMinusOne = operandList4Len\
    \ - 1\n        val operandList5 = new mutable.MutableList[Long]()\n        val\
    \ operandList5Len = operandList5.size\n        val operandList5LenMinusOne = operandList5Len\
    \ - 1\n        val operandList6 = new mutable.MutableList[Long]()\n        val\
    \ operandList6Len = operandList6.size\n        val operandList6LenMinusOne = operandList6Len\
    \ - 1\n        val operandList7 = new mutable.MutableList[Long]()\n        val\
    \ operandList7Len = operandList7.size\n        val operandList7LenMinusOne = operandList7Len\
    \ - 1\n        val operandList8 = new mutable.MutableList[Long]()\n        val\
    \ operandList8Len = operandList8.size\n        val operandList8LenMinusOne = operandList8Len\
    \ - 1\n        val operandList9 = new mutable.MutableList[Long]()\n        val\
    \ operandList9Len = operandList9.size\n        val operandList9LenMinusOne = operandList9Len\
    \ - 1\n        val operandList10 = new mutable.MutableList[Long]()\n        val\
    \ operandList10Len = operandList10.size\n        val operandList10LenMinusOne\
    \ = operandList10Len - 1\n        val operandList11 = new mutable.MutableList[Long]()\n\
    \        val operandList11Len = operandList11.size\n        val operandList11LenMinusOne\
    \ = operand\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5k8na_fu.scala:29:30 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36moperandList\e[0m = \e[33mnew\e\
    [0m mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5k8na_fu.scala:32:31\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36moperandList2\e[0m = \e[33mnew\e[0m mutable.MutableList[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5k8na_fu.scala:35:31 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36moperandList3\e[0m = \e[33mnew\e\
    [0m mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5k8na_fu.scala:38:31\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e\
    [36moperandList4\e[0m = \e[33mnew\e[0m mutable.MutableList[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                               ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5k8na_fu.scala:41:31 ------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36moperandList5\e[0m = \e[33mnew\e\
    [0m mutable.MutableList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanati"
  stdout: ''
  timestamp: 1659792988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toInt).toList\n        val opLen = opList.size\n        val\
    \ opLenMinusOne = opLen - 1\n        val operandLen = operandList.size\n     \
    \   val operandLenMinusOne = operandLen - 1\n        val opMap = new mutable.HashMap[String,\
    \ Long]()\n        val operandMap = new mutable.HashMap[String, Long]()\n    \
    \    val opMapKeys = opList.map(_.toLowerCase)\n        val operandMapKeys = operandList.map(_.toInt)\n\
    \        val opMapValues = opList.map(x => opMap.getOrElse(x, 0L))\n        val\
    \ operandMapValues = operandList.map(x => operandMap.getOrElse(x, 0L))\n     \
    \   val opMapKeysLen = opMapKeys.size\n        val opMapValuesLen = opMapValues.size\n\
    \        val operandMapKeysLen = operandMapKeys.size\n        val operandMapValuesLen\
    \ = operandMapValues.size\n        val opMapKeysMinusOne = opMapKeysLen - 1\n\
    \        val opMapValuesMinusOne = opMapValuesLen - 1\n        val operandMapKeysMinusOne\
    \ = operandMapKeysLen - 1\n        val operandMapValuesMinusOne = operandMapValuesLen\
    \ - 1\n        val opMapKeysMinusOneOpLen = opMapKeysMinusOne + opMapValuesMinusOne\n\
    \        val opMapKeysMinusOneOpLenMinusOne = opMapKeysMinusOneOpLen - 1\n   \
    \     val opMapKeysMinusOneOpLenMinusOneOpLen = opMapKeysMinusOneOpLenMinusOne\
    \ + opMapKeysMinusOneOpLenMinusOne\n        val opMapKeysMinusOneOpLenMinusOneOpLenMinusOne\
    \ = opMapKeysMinusOneOpLenMinusOneOpLen - 1\n        val opMapKeysMinusOneOpLenMinusOneOpLenMinusOneOpLen\
    \ = opMapKeysMinusOneOpLenMinusOneOpLenMinusOne + opMapKeysMinusOneOpLenMinusOneOpLenMinusOneOpLen\n\
    \        val opMapKeysMinusOneOpLenMinusOneOpLenMinusOneOpLenMinusOne = opMapKeysMinusOneOpLenMinusOneOpLenMinusOneOpLen\
    \ - 1\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ywpqa4g.scala:29:24 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mopMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7ywpqa4g.scala:30:29\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36moperandMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7ywpqa4g.scala:47:109 --------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mopMapKeysMinusOneOpLenMinusOneOpLenMinusOneOpLen\e\
    [0m = opMapKeysMinusOneOpLenMinusOneOpLenMinusOne + opMapKeysMinusOneOpLenMinusOneOpLenMinusOneOpLen\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                     ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mopMapKeysMinusOneOpLenMinusOneOpLenMinusOneOpLen\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7ywpqa4g.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659792988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.size\n        val operandLength\
    \ = operandList.size\n        val opIndex = 0\n        val operandIndex = 0\n\
    \        val opResult = 0\n        val operandResult = 0\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        val opLength\
    \ = opList.size\n        val operandLength = operandList.size\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfntvtemg.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mopLength\e[0m = opList.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mopLength\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfntvtemg.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandLength\e[0m = operandList.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandLength is already defined as \e[33mvalue\e[0m \e[35moperandLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfntvtemg.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mopLength\e[0m = opList.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mopLength\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfntvtemg.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandLength\e[0m = operandList.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandLength is already defined as \e[33mvalue\e[0m \e[35moperandLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfntvtemg.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mopLength\e[0m = opList.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mopLength\e[0m\n\e[31m   |\e[0m\n\
    \e[31m  "
  stdout: ''
  timestamp: 1659792988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val opLen =\
    \ opList.length\n        val operandList = operand.map(_.toLong)\n        val\
    \ operandLen = operandList.length\n        val opArray = Array.ofDim[String](opLen)\n\
    \        val operandArray = Array.ofDim[Long](operandLen)\n        var i = 0\n\
    \        while (i < opLen) {\n            opArray(i) = opList(i)\n           \
    \ i += 1\n        }\n        var j = 0\n        while (j < operandLen) {\n   \
    \         operandArray(j) = operandList(j)\n            j += 1\n        }\n  \
    \      val opArrayLen = opArray.length\n        val operandArrayLen = operandArray.length\n\
    \        val opArrayLen2 = opArrayLen / 2\n        val opArrayLen3 = opArrayLen\
    \ - opArrayLen2\n        val operandArrayLen2 = operandArrayLen / 2\n        val\
    \ operandArrayLen3 = operandArrayLen - operandArrayLen2\n        val opArray2\
    \ = Array.ofDim[String](opArrayLen2)\n        val opArray3 = Array.ofDim[String](opArrayLen3)\n\
    \        val operandArray2 = Array.ofDim[Long](operandArrayLen2)\n        val\
    \ operandArray3 = Array.ofDim[Long](operandArrayLen3)\n        var k = 0\n   \
    \     while (k < (opArrayLen2 + opArrayLen3)) {\n            opArray2(k) = opArray(k)\n\
    \            opArray3(k) = opArray(k)\n            operandArray2(k) = operandArray(k)\n\
    \            operandArray3(k) = operandArray(k)\n            k += 1\n        }\n\
    \        val opArray2Len = opArray2.length\n        val opArray3Len = opArray3.length\n\
    \        val operandArray2Len = operandArray2.length\n        val operandArray3Len\
    \ = operandArray3.length\n        val opArray2Len2 = opArray2Len / 2\n       \
    \ val opArray2Len3 = opArray2Len - opArray2Len2\n        val opArray3Len2 = opArray3Len\
    \ / 2\n        val opArray3Len3 = opArray3Len - opArray3Len2\n        val operandArray2Len2\
    \ = operandArray2Len / 2\n        val operandArray2Len3 = operandArray2Len - operandArray2Len2\n\
    \        val operandArray3Len2 = operandArray3Len / 2\n        val operandArray3Len3\
    \ = operandArray3Len - operandArray3Len2\n        val opArray4 = Array.ofDim[String](opArray2Len2)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpd6w8s_ch.scala:70:11 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd6w8s_ch.scala:71:5 ---------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val op1 = ops(0)\n\
    \        val op2 = ops(1)\n        val op3 = ops(2)\n        val op4 = ops(3)\n\
    \        val op5 = ops(4)\n        val op6 = ops(5)\n        val op7 = ops(6)\n\
    \        val op8 = ops(7)\n        val op9 = ops(8)\n        val op10 = ops(9)\n\
    \        val op11 = ops(10)\n        val op12 = ops(11)\n        val op13 = ops(12)\n\
    \        val op14 = ops(13)\n        val op15 = ops(14)\n        val op16 = ops(15)\n\
    \        val op17 = ops(16)\n        val op18 = ops(17)\n        val op19 = ops(18)\n\
    \        val op20 = ops(19)\n        val op21 = ops(20)\n        val op22 = ops(21)\n\
    \        val op23 = ops(22)\n        val op24 = ops(23)\n        val op25 = ops(24)\n\
    \        val op26 = ops(25)\n        val op27 = ops(26)\n        val op28 = ops(27)\n\
    \        val op29 = ops(28)\n        val op30 = ops(29)\n        val op31 = ops(30)\n\
    \        val op32 = ops(31)\n        val op33 = ops(32)\n        val op34 = ops(33)\n\
    \        val op35 = ops(34)\n        val op36 = ops(35)\n        val op37 = ops(36)\n\
    \        val op38 = ops(37)\n        val op39 = ops(38)\n        val op40 = ops(39)\n\
    \        val op41 = ops(40)\n        val op42 = ops(41)\n        val op43 = ops(42)\n\
    \        val op44 = ops(43)\n        val op45 = ops(44)\n        val op46 = ops(45)\n\
    \        val op47 = ops(46)\n        val op48 = ops(47)\n        val op49 = ops(48)\n\
    \        val op50 = ops(49)\n        val op51 = ops(50)\n        val op52 = ops(51)\n\
    \        val op53 = ops(52)\n        val op54 = ops(53)\n        val op\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1bcu6jau.scala:79:4 ----------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1bcu6jau.scala:23:21\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mops\e[0m = op.map(_.toLowerCase)\n\e[31m\e[31m   |\e[0m                  ^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue map is not a member of Null, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.set asScala\n\e\
    [31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1bcu6jau.scala:79:5\
    \ ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toLowerCase)\n        val opLen\
    \ = ops.length\n        val operandLen = operand.length - 1\n        val opMap\
    \ = ops.zip(operand)\n        val opMapLen = opMap.length\n        val opMapSet\
    \ = opMap.map(x => x._1)\n        val opMapSetLen = opMapSet.length\n        val\
    \ opMapSetSet = opMapSet.map(x => x._1)\n        val opMapSetSetLen = opMapSetSet.length\n\
    \        val opMapSetSetSet = opMapSetSet.map(x => x._1)\n        val opMapSetSetSetLen\
    \ = opMapSetSetLen\n        val opMapSetSetSetLen = opMapSetSetLen\n        val\
    \ opMapSetSetSetLen = opMapSetSetLen\n        val opMapSetSetSetLen = opMapSetSetLen\n\
    \        val opMapSetSetSetLen = opMapSetSetLen\n        val opMapSetSetSetLen\
    \ = opMapSetSetLen\n        val opMapSetSetSetLen = opMapSetSetLen\n        val\
    \ opMapSetSetSetLen = opMapSetSetLen\n        val opMapSetSetSetLen = opMapSetSetLen\n\
    \        val opMapSetSetSetLen = opMapSetSetLen\n        val opMapSetSetSetLen\
    \ = opMapSetSetLen\n        val opMapSetSetSetLen = opMapSetSetLen\n        val\
    \ opMapSetSetSetLen = opMapSetSetLen\n        val opMapSetSetSetLen = opMapSetSetLen\n\
    \        val opMapSetSetSetLen = opMapSetSetLen\n        val opMapSetSetSetLen\
    \ = opMapSetSetLen\n        val opMapSetSetSetLen = opMapSetSetLen\n        val\
    \ opMapSetSetSetLen = opMapSetSetLen\n        val opMapSetSetSetLen = opMapSetSetLen\n\
    \        val opMapSetSetSetLen = opMapSetSetLen\n        val opMapSetSetSetLen\
    \ = opMapSetSetLen\n        val opMapSetSetSetLen = opMapSetSetLen\n        val\
    \ opMapSetSetSetLen = opMapSetSetLen\n        val opMapSetSetSetLen = opMapSetSetLen\n\
    \        val opMapSetSetSetLen = opMapSetSetLen\n        val opMapSetSetSetLen\
    \ = opMapSet\n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsfo7098p.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mopMapSetSetSetLen\e[0m =\
    \ opMapSetSetLen\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapSetSetSetLen is already defined as \e[33mvalue\e[0m \e\
    [35mopMapSetSetSetLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsfo7098p.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mopMapSetSetSetLen\e[0m =\
    \ opMapSetSetLen\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapSetSetSetLen is already defined as \e[33mvalue\e[0m \e\
    [35mopMapSetSetSetLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsfo7098p.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mopMapSetSetSetLen\e[0m =\
    \ opMapSetSetLen\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapSetSetSetLen is already defined as \e[33mvalue\e[0m \e\
    [35mopMapSetSetSetLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsfo7098p.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mopMapSetSetSetLen\e[0m =\
    \ opMapSetSetLen\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapSetSetSetLen is already defined as \e[33mvalue\e[0m \e\
    [35mopMapSetSetSetLen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsfo7098p.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mopMapSetSetSetLen\e[0m =\
    \ opMapSetSetLen\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^"
  stdout: ''
  timestamp: 1659792989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val operandLen\
    \ = operands.size\n        val opIndex = ops.indexOf(\"+\")\n        val opIndex2\
    \ = ops.indexOf(\"*\")\n        val opIndex3 = ops.indexOf(\"/\")\n        val\
    \ opIndex4 = ops.indexOf(\"**\")\n        val opIndex5 = ops.indexOf(\"//\")\n\
    \        val opIndex6 = ops.indexOf(\"%\")\n        val opIndex7 = ops.indexOf(\"\
    &\")\n        val opIndex8 = ops.indexOf(\"|\")\n        val opIndex9 = ops.indexOf(\"\
    ^\")\n        val opIndex10 = ops.indexOf(\"~\")\n        val opIndex11 = ops.indexOf(\"\
    <<\")\n        val opIndex12 = ops.indexOf(\">>\")\n        val opIndex13 = ops.indexOf(\"\
    ==\")\n        val opIndex14 = ops.indexOf(\"!=\")\n        val opIndex15 = ops.indexOf(\"\
    <\")\n        val opIndex16 = ops.indexOf(\">\")\n        val opIndex17 = ops.indexOf(\"\
    <=\")\n        val opIndex18 = ops.indexOf(\">=\")\n        val opIndex19 = ops.indexOf(\"\
    ==\")\n        val opIndex20 = ops.indexOf(\"!=\")\n        val opIndex21 = ops.indexOf(\"\
    <<\")\n        val opIndex22 = ops.indexOf(\">>\")\n        val opIndex23 = ops.indexOf(\"\
    &\")\n        val opIndex24 = ops.indexOf(\"|\")\n        val opIndex25 = ops.indexOf(\"\
    ^\")\n        val opIndex26 = ops.indexOf(\"~\")\n        val opIndex27 = ops.indexOf(\"\
    <<\")\n        val opIndex28 = ops.indexOf(\">>\")\n        val opIndex29 = ops.indexOf(\"\
    &\")\n        val opIndex30 = ops.indexOf(\"|\")\n        val opIndex31 = ops.indexOf(\"\
    ^\")\n        val opIndex32 = ops.indexOf(\"~\")\n        val opIndex33 = ops.indexOf(\"\
    <<\")\n        val opIndex34 = ops.indexOf(\">>\")\n        val opIndex35 = ops.indexOf(\"\
    &\")\n        val opIndex36 = ops.indexOf(\"|\")\n        val opIndex37 = ops.indexOf(\"\
    ^\")\n        val opIndex38 = ops.indexOf(\"~\")\n        val opIndex39 = ops.indexOf(\"\
    <<\")\n        val opIndex40 = ops.indexOf(\">>\")\n        val opIndex41 = ops.indexOf(\"\
    &\")\n        val opIndex42 = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj967td8n.scala:68:23 ---------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m        \e[33mval\e[0m \e[36mopIndex42\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpj967td8n.scala:69:5 ---------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val operands\
    \ = operand.map(_.toLong).toList\n        val length = operands.length - 1\n \
    \       val stack = mutable.Stack[Long]()\n        val result = operands.head\n\
    \        val operator = ops.head\n        val operators = ops.tail\n        val\
    \ operand = operands.tail\n\n        while(operand.length > 0) {\n           \
    \ val operandValue = operand.head\n            val operatorValue = operator.head\n\
    \            val operatorValues = operators.tail\n            val operandValues\
    \ = operands.tail\n\n            val operatorResult = operatorValues.foldLeft(operandValue){\n\
    \                case (acc, value) => acc + value\n            }\n\n         \
    \   val operandResult = operandValues.foldLeft(operatorResult){\n            \
    \    case (acc, value) => acc * value\n            }\n\n            val operatorStack\
    \ = stack.push(operatorResult)\n            val operandStack = stack.push(operandResult)\n\
    \n            val operatorResult = operandStack.foldLeft(operatorStack){\n   \
    \             case (acc, value) => acc // + value\n            }\n\n         \
    \   val operandResult = operatorStack.foldLeft(operandStack){\n              \
    \  case (acc, value) => acc // - value\n            }\n\n            val operatorStack\
    \ = stack.push(operatorResult)\n            val operandStack = stack.push(operandResult)\n\
    \n            val operatorResult = operandStack.foldLeft(operatorStack){\n   \
    \             case (acc, value) => acc // + value\n            }\n\n         \
    \   val operandResult = operatorStack.foldLeft(operandStack){\n              \
    \  case (acc, value) => acc // - value\n            }\n\n            val operatorStack\
    \ = stack.push(operatorResult)\n            val operandStack = stack.push(operandResult)\n\
    \n            val operatorResult = operandStack.foldLeft(operatorStack){\n   \
    \             case (acc, value) => acc // + value\n            }\n\n         \
    \   val operandResult = operatorStack.foldLeft(operandStack){\n              \
    \  case (acc, value) => acc // - value\n            }\n\n            val operatorStack\
    \ = stack.push(operatorResult)\n            val operandStack = stack.push(operandResult)\n\
    \n            val operatorResult = operandStack.foldLeft(operatorStack){\n   \
    \             case (acc, value) => acc // + value\n            }\n\n         \
    \   val operandResult = operatorStack.foldLeft(operandStack){\n              \
    \  case (acc, value) => acc // - value\n            }\n\n            val operatorStack\
    \ = stack.push(operatorResult)\n            val operandStack = stack.push(operandResult)\n\
    \n            val operatorResult = operandStack.foldLeft(operator\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\"\
    , \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) ==\
    \ (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp90akr_22.scala:94:4 ----------------------------\e\
    [0m\e[0m\n\e[31m94 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp90akr_22.scala:102:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m102 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp90akr_22.scala:30:22 ---------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36moperand\e[0m = operands.tail\n\
    \e[31m\e[31m   |\e[0m                      ^\e[0m\n\e[31m   |\e[0m           \
    \           Recursive \e[33mvalue\e[0m \e[35moperands\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp90akr_22.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp90akr_22.scala:49:16 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m            \e[33mval\e[0m \e[36moperatorResult\e[0m\
    \ = operandStack.foldLeft(operatorStack){\n\e[31m\e[31m   |\e[0m            ^\e\
    [0m\n\e[31m   |\e[0moperatorResult is already defined as \e[33mvalue\e[0m \e[35moperatorResult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m50 |\e[0m         \
    \       \e[33mcase\e[0m (acc, value) => acc \e[34m// + value\e[0m\n\e[31m51 |\e\
    [0m            }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp90akr_22.scala:53:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m53 |\e[0m            \e[33mval\e\
    [0m \e[36moperandResult\e[0m = operatorStack.foldLeft(operandStack){\n\e[31m\e\
    [31m   |\e[0m            ^\e[0m\n\e[31m   |\e[0moperandResult is already defined\
    \ as \e[33mvalue\e[0m \e[35moperandResult\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that ov"
  stdout: ''
  timestamp: 1659792989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val operands =\
    \ operand.map(x => x.toLong)\n        val opLength = ops.size\n        val operandLength\
    \ = operands.size\n        val opIndex = 0\n        val operandIndex = 0\n   \
    \     var result = 0L\n        while(operandIndex < operandLength) {\n       \
    \     val opChar = ops(opIndex)\n            val operand = operands(operandIndex)\n\
    \            val opFunc = opChar.toDouble\n            val operandFunc = operand.toDouble\n\
    \            val opResult = opFunc(operand)\n            result += opResult\n\
    \            opIndex += 1\n            operandIndex += 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpplzlfj49.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e\
    [0m => x.toChar)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value toChar is not a member\
    \ of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpplzlfj49.scala:33:32\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m\
    \ \e[36mopFunc\e[0m = opChar.toDouble\n\e[31m\e[31m   |\e[0m                 \
    \        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toDouble is not a member of\
    \ Nothing, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\
    \e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\
    \e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpplzlfj49.scala:37:20\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            opIndex += \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value += is not a member of Int - did you mean opIndex.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpplzlfj49.scala:38:25 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            operandIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         value += is\
    \ not a member of Int - did you mean operandIndex.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659792989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLength = opList.length\n        val operandLength\
    \ = operandList.length - 1\n        val result = operandList.foldLeft(0L) { (acc,\
    \ x) =>\n            val opIndex = opList.indexOf(x.toUpperCase)\n           \
    \ val opVal = opIndex.toLong\n            val opVal2 = opIndex.toLong + 1\n  \
    \          val opVal3 = opIndex.toLong + 2\n            val opVal4 = opIndex.toLong\
    \ + 3\n            val opVal5 = opIndex.toLong + 4\n            val opVal6 = opIndex.toLong\
    \ + 5\n            val opVal7 = opIndex.toLong + 6\n            val opVal8 = opIndex.toLong\
    \ + 7\n            val opVal9 = opIndex.toLong + 8\n            val opVal10 =\
    \ opIndex.toLong + 9\n            val opVal11 = opIndex.toLong + 10\n        \
    \    val opVal12 = opIndex.toLong + 11\n            val opVal13 = opIndex.toLong\
    \ + 12\n            val opVal14 = opIndex.toLong + 13\n            val opVal15\
    \ = opIndex.toLong + 14\n            val opVal16 = opIndex.toLong + 15\n     \
    \       val opVal17 = opIndex.toLong + 16\n            val opVal18 = opIndex.toLong\
    \ + 17\n            val opVal19 = opIndex.toLong + 18\n            val opVal20\
    \ = opIndex.toLong + 19\n            val opVal21 = opIndex.toLong + 20\n     \
    \       val opVal22 = opIndex.toLong + 21\n            val opVal23 = opIndex.toLong\
    \ + 22\n            val opVal24 = opIndex.toLong + 23\n            val opVal25\
    \ = opIndex.toLong + 24\n            val opVal26 = opIndex.toLong + 25\n     \
    \       val opVal27 = opIndex.toLong + 26\n            val opVal28 = opIndex.toLong\
    \ + 27\n            val opVal29 = opIndex.toLong + 28\n            val opVal30\
    \ = opIndex.toLong + 29\n            val opVal31 = opIndex.toLong + 30\n     \
    \       val opVal32 = opIndex.toLong + 31\n            val opVal33 = opIndex.toLong\
    \ + 32\n            val opVal34 = opIndex.toLong + 33\n            val opVal35\
    \ = opIndex.toLong + 34\n            val op\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpac7helcy.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpac7helcy.scala:73:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpac7helcy.scala:28:43 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m            \e[33mval\e[0m \e[36mopIndex\e[0m = opList.indexOf(x.toUpperCase)\n\
    \e[31m\e[31m   |\e[0m                                         ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Long\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpac7helcy.scala:72:1\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Long\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpac7helcy.scala:66:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m66 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659792989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val op1 = ops.head\n\
    \        val op2 = ops.last\n        val op3 = ops.dropRight(1)\n        val op4\
    \ = ops.dropRight(2)\n        val op5 = ops.dropRight(3)\n        val op6 = ops.dropRight(4)\n\
    \        val op7 = ops.dropRight(5)\n        val op8 = ops.dropRight(6)\n    \
    \    val op9 = ops.dropRight(7)\n        val op10 = ops.dropRight(8)\n       \
    \ val op11 = ops.dropRight(9)\n        val op12 = ops.dropRight(10)\n        val\
    \ op13 = ops.dropRight(11)\n        val op14 = ops.dropRight(12)\n        val\
    \ op15 = ops.dropRight(13)\n        val op16 = ops.dropRight(14)\n        val\
    \ op17 = ops.dropRight(15)\n        val op18 = ops.dropRight(16)\n        val\
    \ op19 = ops.dropRight(17)\n        val op20 = ops.dropRight(18)\n        val\
    \ op21 = ops.dropRight(19)\n        val op22 = ops.dropRight(20)\n        val\
    \ op23 = ops.dropRight(21)\n        val op24 = ops.dropRight(22)\n        val\
    \ op25 = ops.dropRight(23)\n        val op26 = ops.dropRight(24)\n        val\
    \ op27 = ops.dropRight(25)\n        val op28 = ops.dropRight(26)\n        val\
    \ op29 = ops.dropRight(27)\n        val op30 = ops.dropRight(28)\n        val\
    \ op31 = ops.dropRight(29)\n        val op32 = ops.dropRight(30)\n        val\
    \ op33 = ops.dropRight(31)\n        val op34 = ops.dropRight(32)\n        val\
    \ op35 = ops.dropRight(33)\n        val op36 = ops.dropRight(34)\n        val\
    \ op37 = ops.dropRight(35)\n        val op38 = ops.dropRight(36)\n        val\
    \ op39 = ops.dropRight(37)\n        val op40 = ops.dropRight(38)\n        val\
    \ op41 = ops.dropRight(39)\n        val op42 = ops.dropRight(40)\n        val\
    \ op43 = ops.dropRight(41)\n        val op44 = ops.dropRight(42)\n        val\
    \ op45 = ops.dropRight(43)\n        val op46 = ops.dropRight(44)\n        val\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9tgea42l.scala:70:11 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp9tgea42l.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e\
    [0m => x.toChar)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value toChar is not a member\
    \ of String\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9tgea42l.scala:71:5\
    \ ---------------------\e[0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659792985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(x => x.toLowerCase)\n        val operandList\
    \ = operand.map(x => x.toLong)\n        val opLength = opList.length\n       \
    \ val operandLength = operandList.length\n        val opIndex = 0\n        val\
    \ operandIndex = 0\n        val result = operandList(0)\n        while (operandIndex\
    \ < operandLength) {\n            val op1 = opList(opIndex)\n            val op2\
    \ = opList(opIndex + 1)\n            val op3 = opList(opIndex + 2)\n         \
    \   val op4 = opList(opIndex + 3)\n            val op5 = opList(opIndex + 4)\n\
    \            val op6 = opList(opIndex + 5)\n            val op7 = opList(opIndex\
    \ + 6)\n            val op8 = opList(opIndex + 7)\n            val op9 = opList(opIndex\
    \ + 8)\n            val op10 = opList(opIndex + 9)\n            val op11 = opList(opIndex\
    \ + 10)\n            val op12 = opList(opIndex + 11)\n            val op13 = opList(opIndex\
    \ + 12)\n            val op14 = opList(opIndex + 13)\n            val op15 = opList(opIndex\
    \ + 14)\n            val op16 = opList(opIndex + 15)\n            val op17 = opList(opIndex\
    \ + 16)\n            val op18 = opList(opIndex + 17)\n            val op19 = opList(opIndex\
    \ + 18)\n            val op20 = opList(opIndex + 19)\n            val op21 = opList(opIndex\
    \ + 20)\n            val op22 = opList(opIndex + 21)\n            val op23 = opList(opIndex\
    \ + 22)\n            val op24 = opList(opIndex + 23)\n            val op25 = opList(opIndex\
    \ + 24)\n            val op26 = opList(opIndex + 25)\n            val op27 = opList(opIndex\
    \ + 26)\n            val op28 = opList(opIndex + 27)\n            val op29 = opList(opIndex\
    \ + 28)\n            val op30 = opList(opIndex + 29)\n            val op31 = opList(opIndex\
    \ + 30)\n            val op32 = opList(opIndex + 31)\n            val op33 = opList(opIndex\
    \ + 32)\n            val op34 = opList(opIndex + 33)\n            val op35 = opList(opIndex\
    \ + 34)\n            val op36 = opList(opIndex + 35)\n            val op37 = opList(opIndex\
    \ + 36)\n            val op\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpprzynh6w.scala:69:4 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpprzynh6w.scala:77:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpprzynh6w.scala:76:1 ---------------------\e[0m\e[0m\n\
    \e[31m76 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpprzynh6w.scala:70:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m70 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1659792989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.mkString(\"+\")\n        val opListLength\
    \ = opList.length\n        val operandList = operand.mkString(\"+\")\n       \
    \ val operandListLength = operandList.length\n        val operandListLength =\
    \ operandList.length\n        val opListLength = opList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList.length\n        val operandListLength\
    \ = operandList.length\n        val operandListLength = operandList.length\n \
    \       val operandListLength = operandList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp37ji3gce.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m =\
    \ operandList.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandListLength is already defined as \e[33mvalue\e[0m \e\
    [35moperandListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp37ji3gce.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mopListLength\e[0m = opList.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopListLength is already defined as \e[33mvalue\e[0m \e[35mopListLength\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp37ji3gce.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m = operandList.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandListLength is already defined as \e[33mvalue\e[0m \e[35moperandListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp37ji3gce.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m = operandList.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandListLength is already defined as \e[33mvalue\e[0m \e[35moperandListLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp37ji3gce.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36moperandListLength\e[0m = operandList.length\n\
    \e[31m\e[31m   |\e[0m        ^^^"
  stdout: ''
  timestamp: 1659792989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val opArray = ops.toArray\n\
    \        val operandArray = operand.toArray\n        val length = opArray.length\n\
    \        val operandLength = operandArray.length\n        val result = operandArray(0)\n\
    \        val op1 = opArray(0)\n        val op2 = opArray(1)\n        val op3 =\
    \ opArray(2)\n        val op4 = opArray(3)\n        val op5 = opArray(4)\n   \
    \     val op6 = opArray(5)\n        val op7 = opArray(6)\n        val op8 = opArray(7)\n\
    \        val op9 = opArray(8)\n        val op10 = opArray(9)\n        val op11\
    \ = opArray(10)\n        val op12 = opArray(11)\n        val op13 = opArray(12)\n\
    \        val op14 = opArray(13)\n        val op15 = opArray(14)\n        val op16\
    \ = opArray(15)\n        val op17 = opArray(16)\n        val op18 = opArray(17)\n\
    \        val op19 = opArray(18)\n        val op20 = opArray(19)\n        val op21\
    \ = opArray(20)\n        val op22 = opArray(21)\n        val op23 = opArray(22)\n\
    \        val op24 = opArray(23)\n        val op25 = opArray(24)\n        val op26\
    \ = opArray(25)\n        val op27 = opArray(26)\n        val op28 = opArray(27)\n\
    \        val op29 = opArray(28)\n        val op30 = opArray(29)\n        val op31\
    \ = opArray(30)\n        val op32 = opArray(31)\n        val op33 = opArray(32)\n\
    \        val op34 = opArray(33)\n        val op35 = opArray(34)\n        val op36\
    \ = opArray(35)\n        val op37 = opArray(36)\n        val op38 = opArray(37)\n\
    \        val op39 = opArray(38)\n        val op40 = opArray(39)\n        val op41\
    \ = opArray(40)\n        val op42 = opArray(41)\n        val op43 = opArray(42)\n\
    \        val op44 = opArray(43)\n        val op45 = opArray(44)\n        val op46\
    \ = opArray(45)\n        val op47 = opArray(46)\n        val op48 = opArray(47)\n\
    \        val op49 = opArray(48)\n        val op50 = opArray(49)\n        val \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp9ui5_2he.scala:79:11 ---------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9ui5_2he.scala:80:5 ---------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792963
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toUpperCase)\n        val operandList\
    \ = operand.map(_.toLong)\n        val opLen = opList.size\n        val operandLen\
    \ = operandList.size\n        val opArray = opList.map(_.toChar)\n        val\
    \ operandArray = operandList.map(_.toChar)\n        val opArrayLen = opArray.length\n\
    \        val operandArrayLen = operandArray.length\n        val opArraySum = opArray.reduceLeft(_\
    \ + _)\n        val operandArraySum = operandArray.reduceLeft(_ + _)\n       \
    \ val opArrayDiff = opArrayLen - opArraySum\n        val operandArrayDiff = operandArrayLen\
    \ - operandArraySum\n        val opArrayMul = opArrayLen - opArrayDiff\n     \
    \   val operandArrayMul = operandArrayLen - operandArrayDiff\n        val opArrayDiv\
    \ = opArrayLen - opArrayMul\n        val operandArrayDiv = operandArrayLen - operandArrayMul\n\
    \        val opArrayExp = opArrayLen - opArrayDiv\n        val operandArrayExp\
    \ = operandArrayLen - operandArrayDiv\n        val opArraySumExp = opArrayLen\
    \ - opArrayExp\n        val operandArraySumExp = operandArrayLen - operandArrayExp\n\
    \        val opArrayDiffExp = opArrayLen - opArraySumExp\n        val operandArrayDiffExp\
    \ = operandArrayLen - operandArraySumExp\n        val opArrayMulExp = opArrayLen\
    \ - opArrayDiffExp\n        val operandArrayMulExp = operandArrayLen - operandArrayDiffExp\n\
    \        val opArrayDivExp = opArrayLen - opArrayMulExp\n        val operandArrayDivExp\
    \ = operandArrayLen - operandArrayMulExp\n        val opArrayExp2 = opArrayLen\
    \ - opArrayDivExp\n        val operandArrayExp2 = operandArrayLen - operandArrayDivExp\n\
    \        val opArraySumExp2 = opArrayLen - opArrayExp2\n        val operandArraySumExp2\
    \ = operandArrayLen - operandArrayExp2\n        val opArrayDiffExp2 = opArrayLen\
    \ - opArraySumExp2\n        val operandArrayDiffExp2 = operandArrayLen - operandArraySumExp2\n\
    \        val opArrayMulExp2 = opArrayLen - opArrayDiffExp2\n        val operandArrayMulExp2\
    \ = operandArrayLen - operandArrayDiffExp2\n        val opArrayDivExp2 = opArrayLen\
    \ - opArrayMulExp2\n        val operandArray\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphksfbwkf.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphksfbwkf.scala:27:35\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mopArray\e[0m = opList.map(_.toChar)\n\e[31m\e[31m   |\e[0m               \
    \                  ^^^^^^^^\e[0m\n\e[31m   |\e[0m                            \
    \     value toChar is not a member of String\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmphksfbwkf.scala:31:46 ------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36mopArraySum\e[0m = opArray.reduceLeft(_ +\
    \ _)\n\e[31m\e[31m   |\e[0m                                            ^^^\e[0m\n\
    \e[31m   |\e[0mvalue + is not a member of Any, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphksfbwkf.scala:32:54\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36moperandArraySum\e\
    [0m = operandArray.reduceLeft(_ + _)\n\e[31m\e[31m   |\e[0m                  \
    \                                    ^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                                         Found:    Int\n\e[31m   |\e[0m     \
    \                                                 Required: Char\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmphksfbwkf.scala:33:37 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mopArrayDiff\e[0m = opArrayLen\
    \ - opArraySum\n\e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m\
    \ \e[35m-\e[0m in \e[33mclass\e[0m \e"
  stdout: ''
  timestamp: 1659792989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val opLen\
    \ = ops.size\n        val opArray = ops.toArray\n        val operandArray = operand.toArray\n\
    \        val operandLen = operandArray.length\n        val opArrayLen = opArray.length\n\
    \        val result = operandArray(0)\n        val op1 = opArray(0)\n        val\
    \ op2 = opArray(1)\n        val op3 = opArray(2)\n        val op4 = opArray(3)\n\
    \        val op5 = opArray(4)\n        val op6 = opArray(5)\n        val op7 =\
    \ opArray(6)\n        val op8 = opArray(7)\n        val op9 = opArray(8)\n   \
    \     val op10 = opArray(9)\n        val op11 = opArray(10)\n        val op12\
    \ = opArray(11)\n        val op13 = opArray(12)\n        val op14 = opArray(13)\n\
    \        val op15 = opArray(14)\n        val op16 = opArray(15)\n        val op17\
    \ = opArray(16)\n        val op18 = opArray(17)\n        val op19 = opArray(18)\n\
    \        val op20 = opArray(19)\n        val op21 = opArray(20)\n        val op22\
    \ = opArray(21)\n        val op23 = opArray(22)\n        val op24 = opArray(23)\n\
    \        val op25 = opArray(24)\n        val op26 = opArray(25)\n        val op27\
    \ = opArray(26)\n        val op28 = opArray(27)\n        val op29 = opArray(28)\n\
    \        val op30 = opArray(29)\n        val op31 = opArray(30)\n        val op32\
    \ = opArray(31)\n        val op33 = opArray(32)\n        val op34 = opArray(33)\n\
    \        val op35 = opArray(34)\n        val op36 = opArray(35)\n        val op37\
    \ = opArray(36)\n        val op38 = opArray(37)\n        val op39 = opArray(38)\n\
    \        val op40 = opArray(39)\n        val op41 = opArray(40)\n        val op42\
    \ = opArray(41)\n        val op43 = opArray(42)\n        val op44 = opArray(43)\n\
    \        val op45 = opArray(44)\n        val op46 = opArray(45)\n        val op47\
    \ = opArray(46)\n        val op48 = opArray(47)\n        val op49 = opArray(48)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7xpl64b_.scala:79:5\
    \ ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659792989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val op1 = ops(0)\n\
    \        val op2 = ops(1)\n        val op3 = ops(2)\n        val op4 = ops(3)\n\
    \        val op5 = ops(4)\n        val op6 = ops(5)\n        val op7 = ops(6)\n\
    \        val op8 = ops(7)\n        val op9 = ops(8)\n        val op10 = ops(9)\n\
    \        val op11 = ops(10)\n        val op12 = ops(11)\n        val op13 = ops(12)\n\
    \        val op14 = ops(13)\n        val op15 = ops(14)\n        val op16 = ops(15)\n\
    \        val op17 = ops(16)\n        val op18 = ops(17)\n        val op19 = ops(18)\n\
    \        val op20 = ops(19)\n        val op21 = ops(20)\n        val op22 = ops(21)\n\
    \        val op23 = ops(22)\n        val op24 = ops(23)\n        val op25 = ops(24)\n\
    \        val op26 = ops(25)\n        val op27 = ops(26)\n        val op28 = ops(27)\n\
    \        val op29 = ops(28)\n        val op30 = ops(29)\n        val op31 = ops(30)\n\
    \        val op32 = ops(31)\n        val op33 = ops(32)\n        val op34 = ops(33)\n\
    \        val op35 = ops(34)\n        val op36 = ops(35)\n        val op37 = ops(36)\n\
    \        val op38 = ops(37)\n        val op39 = ops(38)\n        val op40 = ops(39)\n\
    \        val op41 = ops(40)\n        val op42 = ops(41)\n        val op43 = ops(42)\n\
    \        val op44 = ops(43)\n        val op45 = ops(44)\n        val op46 = ops(45)\n\
    \        val op47 = ops(46)\n        val op48 = ops(47)\n        val op49 = ops(48)\n\
    \        val op50 = ops(49)\n        val op51 = ops(50)\n        val op52 = ops(51)\n\
    \        val op53 = ops(52)\n        val op54 = ops(53)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0vneg13p.scala:23:32 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e\
    [0m => x.toChar)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value toChar is not a member\
    \ of String\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0vneg13p.scala:79:5\
    \ ---------------------\e[0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792989
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val operandLen\
    \ = operands.size - 1\n        val opArray = ops.toArray\n        val operandArray\
    \ = operands.toArray\n        val opArrayLen = opArray.length\n        val operandArrayLen\
    \ = operandArray.length\n        val result = operandArray(0)\n        val opIndex\
    \ = 0\n        val operandIndex = 1\n        while(opIndex < opArrayLen && operandIndex\
    \ < operandArrayLen) {\n            val op = ops(opIndex)\n            val operand\
    \ = operands(operandIndex)\n            val opVal = opArray(opIndex)\n       \
    \     val operandVal = operandArray(operandIndex)\n            val opValInt =\
    \ opVal.toInt\n            val operandValInt = operandVal.toInt\n            val\
    \ opValLong = opVal.toLong\n            val operandValLong = operandVal.toLong\n\
    \            val opValFloat = opVal.toFloat\n            val operandValFloat =\
    \ operandVal.toFloat\n            val opValDouble = opVal.toDouble\n         \
    \   val operandValDouble = operandVal.toDouble\n            val opValBool = opVal.toBoolean\n\
    \            val operandValBool = operandVal.toBoolean\n            val opValString\
    \ = opVal.toString\n            val operandValString = operandVal.toString\n \
    \           val opValChar = opVal.toChar\n            val operandValChar = operandVal.toChar\n\
    \            val opValByte = opVal.toByte\n            val operandValByte = operandVal.toByte\n\
    \            val opValShort = opVal.toShort\n            val operandValShort =\
    \ operandVal.toShort\n            val opValInt = opVal.toInt\n            val\
    \ operandValInt = operandVal.toInt\n            val opValLong = opVal.toLong\n\
    \            val operandValLong = operandVal.toLong\n            val opValFloat\
    \ = opVal.toFloat\n            val operandValFloat = operandVal.toFloat\n    \
    \        val opValDouble = opVal.toDouble\n            val operandValDouble =\
    \ operandVal.toDouble\n            val opValBool = opVal.toBoolean\n         \
    \   val operandValBool = operandVal.toBoolean\n            val opValString = opVal.toString\n\
    \            val operandValString = operandVal.toString\n            val opValChar\
    \ = opVal.toChar\n            val operandValChar = operandVal.toChar\n       \
    \     val opValByte = opVal.toByte\n            val operandValByte\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"**\"\
    , \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) ==\
    \ (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpko8fgf4y.scala:73:4 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpko8fgf4y.scala:81:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m81 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpko8fgf4y.scala:57:16 ---------------------------\e[0m\e[0m\n\e\
    [31m57 |\e[0m            \e[33mval\e[0m \e[36mopValInt\e[0m = opVal.toInt\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopValInt\
    \ is already defined as \e[33mvalue\e[0m \e[35mopValInt\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpko8fgf4y.scala:58:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m58 |\e[0m            \e[33mval\e\
    [0m \e[36moperandValInt\e[0m = operandVal.toInt\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0moperandValInt\
    \ is already defined as \e[33mvalue\e[0m \e[35moperandValInt\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpko8fgf4y.scala:59:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m59 |\e[0m            \e[33mval\e\
    [0m \e[36mopValLong\e[0m = opVal.toLong\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopValLong is already defined as \e[33mvalue\e[0m \e[35mopValLong\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpko8fgf4y.scala:60:16 ---------------------------\e[0m\e[0m\n\e\
    [31m60 |\e[0m            \e[33mval\e[0m \e[36moperandValLong\e[0m = operandVal.toLong\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0moperandValLong is already defined as \e[33mvalue\e[0m \e[35moperandValLong\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1659792990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.mkString(\"+\")\n        val opList = opList.split(\"\
    \\\\+\").map(_.trim).toList\n        val opList = opList.filter(_ != \"\")\n \
    \       val operandList = operand.mkString(\"+\")\n        val operandList = operandList.split(\"\
    \\\\+\").map(_.trim).toList\n        val operandList = operandList.filter(_ !=\
    \ \"\")\n        val opListLength = opList.size\n        val operandListLength\
    \ = operandList.size\n        val opListLength = opListLength - 1\n        val\
    \ operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        val opListLength = opListLength\
    \ - 1\n        val operandListLength = operandListLength - 1\n        val opListLength\
    \ = opListLength - 1\n        val operandListLength = operandListLength - 1\n\
    \        val opListLength = opListLength - 1\n        val operandListLength =\
    \ operandListLength - 1\n        val opListLength = opListLength - 1\n       \
    \ val operandListLength = operandListLength - 1\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\"\
    )), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n   \
    \ assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8n0gltat.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mopList\e[0m = opList.split(\e\
    [31m\"\\\\+\"\e[0m).map(_.trim).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopList is already defined as \e[33mvalue\e[0m \e[35mopList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8n0gltat.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mopList\e[0m = opList.filter(_ != \e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopList is already defined as \e[33mvalue\e[0m \e[35mopList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8n0gltat.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36moperandList\e[0m = operandList.split(\e\
    [31m\"\\\\+\"\e[0m).map(_.trim).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8n0gltat.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36moperandList\e[0m = operandList.filter(_\
    \ != \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandList is already defined as \e[33mvalue\e[0m \e[35moperandList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8n0gltat.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mopListLength\e[0m = opListL"
  stdout: ''
  timestamp: 1659792990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val opList = ops.toList\n\
    \        val operandList = operand.toList\n        val length = opList.size\n\
    \        val operandLength = operandList.size\n        val result = operandList.foldLeft(operandList.head)\
    \ { (acc, elem) =>\n            val op = opList.head\n            val operand\
    \ = operandList.head\n            val opIndex = ops.indexOf(op)\n            val\
    \ operandIndex = operandList.indexOf(operand)\n            val opLength = opList.size\n\
    \            val operandLength = operandList.size\n            val opLength =\
    \ ops.size\n            val operandLength = operandList.size\n            val\
    \ opIndex = ops.indexOf(op)\n            val operandIndex = operandList.indexOf(operand)\n\
    \            val opLength = opList.size\n            val operandLength = operandList.size\n\
    \            val opLength = ops.size\n            val operandLength = operandList.size\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operandList.indexOf(operand)\n\
    \            val opLength = opList.size\n            val operandLength = operandList.size\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operandList.indexOf(operand)\n\
    \            val opLength = opList.size\n            val operandLength = operandList.size\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operandList.indexOf(operand)\n\
    \            val opLength = opList.size\n            val operandLength = operandList.size\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operandList.indexOf(operand)\n\
    \            val opLength = opList.size\n            val operandLength = operandList.size\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operandList.indexOf(operand)\n\
    \            val opLength = opList.size\n            val operandLength = operandList.size\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operandList.indexOf(operand)\n\
    \            val opLength = opList.size\n            val operandLength = operandList.size\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operandList.indexOf(operand)\n\
    \            val opLength = opList.size\n            val operandLength = operandList.size\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operandList.indexOf(operand)\n\
    \            val opLength = opList.size\n            val operandLength = operandList.size\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operandList.indexOf(operand)\n\
    \            val opLength = opList.size\n            val operandLength = operandList.size\n\
    \            val opIndex = ops.indexOf(op)\n            val operandIndex = operandList.indexOf(operand)\n\
    \            val opLength = opList.size\n            val operandLength = operandList.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmb7meri9.scala:83:4 ----------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpmb7meri9.scala:91:0 ----------------------------\e[0m\e[0m\n\e[31m91\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmb7meri9.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mopLength\e[0m = ops.size\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mopLength\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmb7meri9.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36moperandLength\e[0m = operandList.size\n\e[31m\e[31m   |\e[0m       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0moperandLength\
    \ is already defined as \e[33mvalue\e[0m \e[35moperandLength\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmb7meri9.scala:37:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mopIndex\e[0m = ops.indexOf(op)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopIndex is already defined as \e[33mvalue\e[0m \e[35mopIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmb7meri9.scala:38:16 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m            \e[33mval\e[0m \e[36moperandIndex\e[0m = operandList.indexOf(operand)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandIndex is already defined as \e[33mvalue\e[0m \e[35moperandIndex\e\
    [0m\n\e[31m   |"
  stdout: ''
  timestamp: 1659792990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val opList = op.map(_.toLowerCase).toList\n        val operandList\
    \ = operand.map(_.toInt).toList\n        val opLength = opList.length\n      \
    \  val operandLength = operandList.length\n        val opIndex = opList.indexOf(\"\
    +\")\n        val opIndex2 = opList.indexOf(\"*\")\n        val opIndex3 = opList.indexOf(\"\
    /\")\n        val opIndex4 = opList.indexOf(\"**\")\n        val opIndex5 = opList.indexOf(\"\
    //\")\n        val opIndex6 = opList.indexOf(\"%\")\n        val opIndex7 = opList.indexOf(\"\
    ^\")\n        val opIndex8 = opList.indexOf(\"|\")\n        val opIndex9 = opList.indexOf(\"\
    &\")\n        val opIndex10 = opList.indexOf(\"==\")\n        val opIndex11 =\
    \ opList.indexOf(\"!=\")\n        val opIndex12 = opList.indexOf(\"<\")\n    \
    \    val opIndex13 = opList.indexOf(\">\")\n        val opIndex14 = opList.indexOf(\"\
    <=\")\n        val opIndex15 = opList.indexOf(\">=\")\n        val opIndex16 =\
    \ opList.indexOf(\"!\")\n        val opIndex17 = opList.indexOf(\"&&\")\n    \
    \    val opIndex18 = opList.indexOf(\"||\")\n        val opIndex19 = opList.indexOf(\"\
    ?\")\n        val opIndex20 = opList.indexOf(\":\")\n        val opIndex21 = opList.indexOf(\"\
    ,\")\n        val opIndex22 = opList.indexOf(\";\")\n        val opIndex23 = opList.indexOf(\"\
    (\")\n        val opIndex24 = opList.indexOf(\")\")\n        val opIndex25 = opList.indexOf(\"\
    [\")\n        val opIndex26 = opList.indexOf(\"]\")\n        val opIndex27 = opList.indexOf(\"\
    {\")\n        val opIndex28 = opList.indexOf(\"}\")\n        val opIndex29 = opList.indexOf(\"\
    (\")\n        val opIndex30 = opList.indexOf(\")\")\n        val opIndex31 = opList.indexOf(\"\
    ,\")\n        val opIndex32 = opList.indexOf(\";\")\n        val opIndex33 = opList.indexOf(\"\
    (\")\n        val opIndex34 = opList.indexOf(\")\")\n        val opIndex35 = opList.indexOf(\"\
    [\")\n        val opIndex36 = opList.indexOf(\"]\")\n        val opIndex37 = opList.indexOf(\"\
    {\")\n        val opIndex38 = opList.indexOf(\"}\")\n        val opIndex39 = opList.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3trhqvcg.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp3trhqvcg.scala:66:5 ---------------------\e[0m\e[0m\n\e[31m66\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659792990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val operands =\
    \ operand.map(x => x.toLong)\n        val opMap = ops.zip(operands).toMap\n  \
    \      val opList = ops.toList\n        val operandList = operands.toList\n  \
    \      val opLen = opList.size\n        val opMapLen = opMap.length\n        val\
    \ operandLen = operandList.size\n        val opMapIndex = 0\n        val operandIndex\
    \ = 0\n        val opMapValue = opMap.get(opList(0))\n        val operandValue\
    \ = operandList(0)\n        val result = opMapValue\n        val opMapKeys = opMap.keys\n\
    \        val operandKeys = operandList.tail\n        while(operandIndex < operandLen)\
    \ {\n            val opMapValue = opMap.get(opList(0))\n            val operandValue\
    \ = operandList(0)\n            val opMapKeys = opMap.keys\n            val operandKeys\
    \ = operandList.tail\n            val opMapValue = opMap.get(opList(0))\n    \
    \        val operandValue = operandList(0)\n            val opMapKeys = opMap.keys\n\
    \            val operandKeys = operandList.tail\n            val opMapValue =\
    \ opMap.get(opList(0))\n            val operandValue = operandList(0)\n      \
    \      val opMapKeys = opMap.keys\n            val operandKeys = operandList.tail\n\
    \            val opMapValue = opMap.get(opList(0))\n            val operandValue\
    \ = operandList(0)\n            val opMapKeys = opMap.keys\n            val operandKeys\
    \ = operandList.tail\n            val opMapValue = opMap.get(opList(0))\n    \
    \        val operandValue = operandList(0)\n            val opMapKeys = opMap.keys\n\
    \            val operandKeys = operandList.tail\n            val opMapValue =\
    \ opMap.get(opList(0))\n            val operandValue = operandList(0)\n      \
    \      val opMapKeys = opMap.keys\n            val operandKeys = operandList.tail\n\
    \            val opMapValue = opMap.get(opList(0))\n            val operandValue\
    \ = operandList(0)\n            val opMapKeys = opMap.keys\n            val operandKeys\
    \ = operandList.tail\n            val opMapValue = opMap.get(opList(0))\n    \
    \        val operandValue = operandList(0)\n            val opMapKeys = opMap.keys\n\
    \            val operandKeys = operandList.tail\n            val opMapValue =\
    \ opMap.get(opList(0))\n            val operandValue = operandList(0)\n      \
    \      val opMapKeys = opMap.keys\n            val operandKeys = operandList.tail\n\
    \            val opMapValue = opMap.get(opList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0leugnl1.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0leugnl1.scala:84:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp0leugnl1.scala:23:32 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e[0m =>\
    \ x.toChar)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                              value toChar is not a member of String\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0leugnl1.scala:29:29 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mopMapLen\e[0m = opMap.length\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                      value length is not a member of Map[Nothing, Long]\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp0leugnl1.scala:43:16 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m            \e[33mval\e[0m \e[36mopMapValue\e[0m = opMap.get(opList(\e\
    [31m0\e[0m))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopMapValue is already defined as \e[33mvalue\e[0m \e[35mopMapValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0leugnl1.scala:44:16 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m            \e[33mval\e[0m \e[36moperandValue\e[0m = operandList(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0moperandValue is already defined as \e[33mvalue\e[0m \e[35moperandValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0leugnl1.scala:45:16 ---------------------------\e[0m\e[0m\n\e\
    [31m45 |\e[0m            \e[33mva"
  stdout: ''
  timestamp: 1659792991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(x => x.toChar)\n        val opLen = ops.length\n\
    \        val opArray = ops.map(x => x.toLong)\n        val opArrayLen = opArray.length\n\
    \        val operandArray = operand.map(x => x.toLong)\n        val operandArrayLen\
    \ = operandArray.length\n        val result = operandArray(0)\n        val op1\
    \ = opArray(0)\n        val op2 = opArray(1)\n        val op3 = opArray(2)\n \
    \       val op4 = opArray(3)\n        val op5 = opArray(4)\n        val op6 =\
    \ opArray(5)\n        val op7 = opArray(6)\n        val op8 = opArray(7)\n   \
    \     val op9 = opArray(8)\n        val op10 = opArray(9)\n        val op11 =\
    \ opArray(10)\n        val op12 = opArray(11)\n        val op13 = opArray(12)\n\
    \        val op14 = opArray(13)\n        val op15 = opArray(14)\n        val op16\
    \ = opArray(15)\n        val op17 = opArray(16)\n        val op18 = opArray(17)\n\
    \        val op19 = opArray(18)\n        val op20 = opArray(19)\n        val op21\
    \ = opArray(20)\n        val op22 = opArray(21)\n        val op23 = opArray(22)\n\
    \        val op24 = opArray(23)\n        val op25 = opArray(24)\n        val op26\
    \ = opArray(25)\n        val op27 = opArray(26)\n        val op28 = opArray(27)\n\
    \        val op29 = opArray(28)\n        val op30 = opArray(29)\n        val op31\
    \ = opArray(30)\n        val op32 = opArray(31)\n        val op33 = opArray(32)\n\
    \        val op34 = opArray(33)\n        val op35 = opArray(34)\n        val op36\
    \ = opArray(35)\n        val op37 = opArray(36)\n        val op38 = opArray(37)\n\
    \        val op39 = opArray(38)\n        val op40 = opArray(39)\n        val op41\
    \ = opArray(40)\n        val op42 = opArray(41)\n        val op43 = opArray(42)\n\
    \        val op44 = opArray(43)\n        val op45 = opArray(44)\n        val op46\
    \ = opArray(45)\n        val op47 = opArray(46)\n        val op48 = \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp16hdejgt.scala:77:18 ---------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m        \e[33mval\e[0m \e[36mop48\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp16hdejgt.scala:23:32 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mops\e[0m = op.map(\e[36mx\e[0m => x.toChar)\n\e\
    [31m\e[31m   |\e[0m                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                              value toChar is not a member of String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp16hdejgt.scala:25:37 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mopArray\e[0m = ops.map(\e\
    [36mx\e[0m => x.toLong)\n\e[31m\e[31m   |\e[0m                               \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue toLong is not a member of Nothing, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\
    \e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\
    \e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import math.BigDecimal.javaBigDecimal2bigDecimal\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp16hdejgt.scala:78:5\
    \ ---------------------\e[0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659792991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toUpperCase)\n        val operands =\
    \ operand.map(_.toLong)\n        val opLen = ops.size\n        val opLenMinusOne\
    \ = opLen - 1\n        val operandLen = operands.size - 1\n        val opLenMinusOneMinusOne\
    \ = opLenMinusOne - 1\n        val operandLenMinusOne = operandLen - 1\n     \
    \   val opLenMinusOneMinusOneMinusOne = opLenMinusOneMinusOne - 1\n        val\
    \ operandLenMinusOneMinusOneMinusOne = operandLenMinusOneMinusOne - 1\n      \
    \  val opLenMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOne = operandLenMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOne = operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne - 1\n \
    \       val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ = operandLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - 1\n        val opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinus\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(doAlgebra((List[String](\"\
    **\", \"*\", \"+\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (37l));\n    assert(doAlgebra((List[String](\"+\", \"*\", \"-\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (9l));\n    assert(doAlgebra((List[String](\"\
    //\", \"*\")), (List[Long](7l.toLong, 3l.toLong, 4l.toLong))) == (8l));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5uyjr928.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5uyjr928.scala:31:49\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36moperandLenMinusOneMinusOneMinusOne\e[0m = operandLenMinusOneMinusOne - \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                                            \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \            Not found: operandLenMinusOneMinusOne\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E045] Cyclic Error: /tmp/tmp5uyjr928.scala:32:52 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mopLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m = opLenMinusOneMinusOneMinusOneMinusOne - \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                                                    ^\e[0m\n\e[31m   |\e[0m\
    \        Recursive \e[33mvalue\e[0m \e[35mopLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5uyjr928.scala:33:57\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36moperandLenMinusOneMinusOneMinusOneMinusOne\e[0m = operandLenMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                   ^\e[0m\n\e[31m   |\e[0m   Recursive \e[33mvalue\e[0m \e[35moperandLenMinusOneMinusOneMinusOneMinusOne\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5uyjr928.scala:38:76\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e\
    [36mopLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\e[0m = opLenMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOneMinusOne\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \    "
  stdout: ''
  timestamp: 1659792990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Given two lists operator, and operand. The first list has basic algebra\
    \ operations, and \n    // the second list is a list of integers. Use the two\
    \ given lists to build the algebric \n    // expression and return the evaluation\
    \ of this expression.\n    // The basic algebra operations:\n    // Addition (\
    \ + ) \n    // Subtraction ( - ) \n    // Multiplication ( * ) \n    // Floor\
    \ division ( // ) \n    // Exponentiation ( ** ) \n    // Example:\n    // operator['+',\
    \ '*', '-']\n    // array = [2, 3, 4, 5]\n    // result = 2 + 3 * 4 - 5\n    //\
    \ => result = 9\n    // Note:\n    // The length of operator list is equal to\
    \ the length of operand list minus one.\n    // Operand is a list of of non-negative\
    \ integers.\n    // Operator list has at least one operator, and operand list\
    \ has at least two operands.\n    def doAlgebra(op : List[String], operand : List[Long])\
    \ : Long = {\n        val ops = op.map(_.toLowerCase).toList\n        val operands\
    \ = operand.map(_.toLong).toList\n        val opLen = ops.size\n        val operandLen\
    \ = operands.size\n        val opIndex = ops.indexOf(\"+\")\n        val opIndex2\
    \ = ops.indexOf(\"-\")\n        val opIndex3 = ops.indexOf(\"*\")\n        val\
    \ opIndex4 = ops.indexOf(\"/\")\n        val opIndex5 = ops.indexOf(\"**\")\n\
    \        val opIndex6 = ops.indexOf(\"%\")\n        val opIndex7 = ops.indexOf(\"\
    &\")\n        val opIndex8 = ops.indexOf(\"|\")\n        val opIndex9 = ops.indexOf(\"\
    ~\")\n        val opIndex10 = ops.indexOf(\"^\")\n        val opIndex11 = ops.indexOf(\"\
    <<\")\n        val opIndex12 = ops.indexOf(\">>\")\n        val opIndex13 = ops.indexOf(\"\
    ==\")\n        val opIndex14 = ops.indexOf(\"!=\")\n        val opIndex15 = ops.indexOf(\"\
    <\")\n        val opIndex16 = ops.indexOf(\">\")\n        val opIndex17 = ops.indexOf(\"\
    <=\")\n        val opIndex18 = ops.indexOf(\">=\")\n        val opIndex19 = ops.indexOf(\"\
    ==\")\n        val opIndex20 = ops.indexOf(\"!=\")\n        val opIndex21 = ops.indexOf(\"\
    &&\")\n        val opIndex22 = ops.indexOf(\"||\")\n        val opIndex23 = ops.indexOf(\"\
    ??\")\n        val opIndex24 = ops.indexOf(\"??=\")\n        val opIndex25 = ops.indexOf(\"\
    ???\")\n        val opIndex26 = ops.indexOf(\"????\")\n        val opIndex27 =\
    \ ops.indexOf(\"????=\")\n        val opIndex28 = ops.indexOf(\"?????\")\n   \
    \     val opIndex29 = ops.indexOf(\"??????\")\n        val opIndex30 = ops.indexOf(\"\
    ??????=\")\n        val opIndex31 = ops.indexOf(\"???????\")\n        val opIndex32\
    \ = ops.indexOf(\"????????\")\n        val opIndex33 = ops.indexOf(\"????????=\"\
    )\n        val opIndex34 = ops.indexOf(\"?????????\")\n        val opIndex35 =\
    \ ops.indexOf(\"??????????\")\n        val opIndex36 = ops.indexOf(\"??????????=\"\
    )\n        val opIndex37 = ops.indexOf(\"???????????\")\n        val opIndex38\
    \ = ops.indexOf(\"????????????\")\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(doAlgebra((List[String](\"**\", \"*\", \"+\")), (List[Long](2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong))) == (37l));\n    assert(doAlgebra((List[String](\"\
    +\", \"*\", \"-\")), (List[Long](2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong)))\
    \ == (9l));\n    assert(doAlgebra((List[String](\"//\", \"*\")), (List[Long](7l.toLong,\
    \ 3l.toLong, 4l.toLong))) == (8l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpd1fy7p35.scala:65:11 ---------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpd1fy7p35.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659792990
