language: scala
name: HumanEval_49_modp
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (r == 0) 1 else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl6mzp_24.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (r < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp883mj5tv.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2,n)\n\
    \        val r = math.mod(m, p)\n        val r2 = math.pow(2,r)\n        val r3\
    \ = math.pow(2,r2)\n        val r4 = math.pow(2,r3)\n        val r5 = math.pow(2,r4)\n\
    \        val r6 = math.pow(2,r5)\n        val r7 = math.pow(2,r6)\n        val\
    \ r8 = math.pow(2,r7)\n        val r9 = math.pow(2,r8)\n        val r10 = math.pow(2,r9)\n\
    \        val r11 = math.pow(2,r10)\n        val r12 = math.pow(2,r11)\n      \
    \  val r13 = math.pow(2,r12)\n        val r14 = math.pow(2,r13)\n        val r15\
    \ = math.pow(2,r14)\n        val r16 = math.pow(2,r15)\n        val r17 = math.pow(2,r16)\n\
    \        val r18 = math.pow(2,r17)\n        val r19 = math.pow(2,r18)\n      \
    \  val r20 = math.pow(2,r19)\n        val r21 = math.pow(2,r20)\n        val r22\
    \ = math.pow(2,r21)\n        val r23 = math.pow(2,r22)\n        val r24 = math.pow(2,r23)\n\
    \        val r25 = math.pow(2,r24)\n        val r26 = math.pow(2,r25)\n      \
    \  val r27 = math.pow(2,r26)\n        val r28 = math.pow(2,r27)\n        val r29\
    \ = math.pow(2,r28)\n        val r30 = math.pow(2,r29)\n        val r31 = math.pow(2,r30)\n\
    \        val r32 = math.pow(2,r31)\n        val r33 = math.pow(2,r32)\n      \
    \  val r34 = math.pow(2,r33)\n        val r35 = math.pow(2,r34)\n        val r36\
    \ = math.pow(2,r35)\n        val r37 = math.pow(2,r36)\n        val r38 = math.pow(2,r37)\n\
    \        val r39 = math.pow(2,r38)\n        val r40 = math.pow(2,r39)\n      \
    \  val r41 = math.pow(2,r40)\n        val r42 = math.pow(2,r41)\n        val r43\
    \ = math.pow(2,r42)\n        val r44 = math.pow(2,r43)\n        val r45 = math.pow(2,r44)\n\
    \        val r46 = math.pow(2,r\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbsnq_d20.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbsnq_d20.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mr\e[0m = math.mod(m, p)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                value mod is not a member of math\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpbsnq_d20.scala:63:5 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n = n.toInt\n      \
    \  val p = p.toInt\n        val r = scala.math.pow(2, n)\n        val m = scala.math.mod(r,\
    \ p)\n        if (m == 0) 1 else m\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpz7x8e46r.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpz7x8e46r.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpz7x8e46r.scala:19:27 ------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \            value mod is not a member of math\n3 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if\
    \ (m == 0) 1\n        else m + 1\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxl9q6pca.scala:21)\n\tat Problem.main(tmpxl9q6pca.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.BigInt(n).mod(scala.math.BigInt(p))\n\
    \        r.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp72dbixpk.scala:21)\n\tat Problem.main(tmp72dbixpk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        val s = math.signum(r)\n        if (s\
    \ == -1) 1 else s\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppwasesgy.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n = n.toInt\n      \
    \  val p = p.toInt\n        if (n == 0 || p == 0) 1\n        else if (n % p ==\
    \ 0) n\n        else n % p + modp(n / p, p)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpn5nxdok2.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpn5nxdok2.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800382
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.pow(2,\
    \ n) % p\n        if (r < 0) r + p else r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpydfx7zra.scala:17:19\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m   |\e[0m                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Double\n\e[31m   |\e[0m     \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpydfx7zra.scala:17:30 --------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m           \
    \                   Found:    (r : Double)\n\e[31m   |\e[0m                  \
    \            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        val s = math.signum(r)\n        if (s\
    \ == 0) 1 else s\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm8r8rjq_.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        val s = math.signum(r)\n        if (s\
    \ == -1) 1 else s\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppwasesgy.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if\
    \ (m == 0) 1\n        else (n / p) * p + m\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptcu17fu8.scala:22)\n\tat Problem.main(tmptcu17fu8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1\n        else if (r > 0) modp(r, p) + p\n        else modp(r, p)\
    \ - p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.scala:18)\n\tat Problem$.modp(tmppyw_0ioo.scala:18)\n\
    \tat Problem$.modp(tmppyw_0ioo.sc"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2,n)\n\
    \        val r = math.mod(m, p)\n        if (r == 0) 1 else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmiarl5yr.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n = n.toInt\n      \
    \  val p = p.toInt\n        val result = 1L\n        val r = n % p\n        val\
    \ q = p / r\n        val t = 1L\n        val k = 1L\n        while (k <= r) {\n\
    \            t = t * q\n            k += 1\n        }\n        result = result\
    \ * t + r\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpl1fs4v77.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpl1fs4v77.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpl1fs4v77.scala:24:14 -----------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            t = t * q\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Reassignment to val t\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpl1fs4v77.scala:25:14 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            k += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Long - did you mean k.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpl1fs4v77.scala:27:15\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        result = result\
    \ * t + r\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m        Reassignment to val result\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (r < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp883mj5tv.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p22\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph92nghl7.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmph92nghl7.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2,n)\n\
    \        val r = math.mod(m,p)\n        val s = math.signum(r)\n        if (s\
    \ == 0) 1 else s\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpulu1cnam.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m,p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = n / p\n        if\
    \ (m == 0) 1\n        else if (m == 1) p\n        else modp(m, p) * p\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphjfk6d9q.scala:22)\n\tat Problem.main(tmphjfk6d9q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (r < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp883mj5tv.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp1lns69.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptp1lns69.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n1 = n % p\n       \
    \ if (n1 == 0) 1\n        else n1 ^ modp(n / p, p)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf_id8xzl.scala:21)\n\tat Problem.main(tmpf_id8xzl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (r < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp883mj5tv.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n = n.toInt\n      \
    \  val p = p.toInt\n        if (n == 0) 1\n        else if (n == 1) p\n      \
    \  else if (n % 2 == 0) modp(n / 2, p) * p + modp(n / 2, p)\n        else modp(n\
    \ / 2, p) * p + modp(n / 2, p) * p\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3ox1d9p4.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp3ox1d9p4.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800383
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (n < 0) r + p\n        else r\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyk6627px.scala:22)\n\tat Problem.main(tmpyk6627px.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800394
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (n < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplr0cx23k.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800393
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = scala.math.pow(2,\
    \ n)\n        val r = scala.math.mod(m, p)\n        val s = scala.math.signum(r)\n\
    \        if (s == 0) 1 else s\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp18b5znqq.scala:17:27 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(m,\
    \ p)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = scala.math.pow(2,\
    \ n)\n        val r = scala.math.mod(m, p)\n        if (r < 0) r + p else r\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5tmatpsp.scala:17:27 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(m,\
    \ p)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.pow(2,\
    \ n) % p\n        if (n < 0) r + p\n        else r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpouljutk7.scala:17:19\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (n < \e\
    [31m0\e[0m) r + p\n\e[31m\e[31m   |\e[0m                   ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Found:    Double\n\e[31m   |\e[0m               \
    \    Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpouljutk7.scala:18:13\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33melse\e[0m r\n\e\
    [31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0m             Found:   \
    \ (r : Double)\n\e[31m   |\e[0m             Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2,n)\n\
    \        val r = math.mod(m, p)\n        if (r == 0) 1 else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmiarl5yr.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1\n        else (r + p) % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa2e5birj.scala:22)\n\tat Problem.main(tmpa2e5birj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        val s = math.abs(r) % p\n        if (s\
    \ == 0) r else r + p\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4xl9ku3b.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.max(math.min(math.pow(n,\
    \ p), p), 0L)\n        math.abs(m) % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpoqrbo8gr.scala:17:8\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m        math.abs(m) % p\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    Double\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) -\
    \ p7\n        val p8 = (p7 * p7) - p8\n        val n9 = (n8 * n8) - p8\n     \
    \   val p9 = (p8 * p8) - p9\n        val n10 = (n9 * n9) - p9\n        val p10\
    \ = (p9 * p9) - p10\n        val n11 = (n10 * n10) - p10\n        val p11 = (p10\
    \ * p10) - p11\n        val n12 = (n11 * n11) - p11\n        val p12 = (p11 *\
    \ p11) - p12\n        val n13 = (n12 * n12) - p12\n        val p13 = (p12 * p12)\
    \ - p13\n        val n14 = (n13 * n13) - p13\n        val p14 = (p13 * p13) -\
    \ p14\n        val n15 = (n14 * n14) - p14\n        val p15 = (p14 * p14) - p15\n\
    \        val n16 = (n15 * n15) - p15\n        val p16 = (p15 * p15) - p16\n  \
    \      val n17 = (n16 * n16) - p16\n        val p17 = (p16 * p16) - p17\n    \
    \    val n18 = (n17 * n17) - p17\n        val p18 = (p17 * p17) - p18\n      \
    \  val n19 = (n18 * n18) - p18\n        val p19 = (p18 * p18) - p19\n        val\
    \ n20 = (n19 * n19) - p19\n        val p20 = (p19 * p19) - p20\n        val n21\
    \ = (n20 * n20) - p20\n        val p21 = (p20 * p20) - p21\n        val n22 =\
    \ (n21 * n21) - p21\n        val p22 = (p21\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu9adfxws.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpu9adfxws.scala:29:29\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mp8\e[0m = (p7 * p7) - p8\n\e[31m\e[31m   |\e[0m                      \
    \       ^\e[0m\n\e[31m   |\e[0m                             Recursive \e[33mvalue\e\
    [0m \e[35mp8\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpu9adfxws.scala:58:5 ---------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (n < 0) -r\n        else r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfyj0d40i.scala:22)\n\tat Problem.main(tmpfyj0d40i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.pow(2,\
    \ n)\n        val q = scala.math.pow(2, p) % r\n        if (q == 0) 1 else q\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptrq72w1m.scala:18:27\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (q == \e\
    [31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m q\n\e[31m\e[31m   |\e[0m            \
    \               ^\e[0m\n\e[31m   |\e[0m                           Found:    (q\
    \ : Double)\n\e[31m   |\e[0m                           Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.pow(2,\
    \ n) % p\n        if (r < 0) r + p else r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpydfx7zra.scala:17:19\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m   |\e[0m                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Double\n\e[31m   |\e[0m     \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpydfx7zra.scala:17:30 --------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m           \
    \                   Found:    (r : Double)\n\e[31m   |\e[0m                  \
    \            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (r < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp883mj5tv.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp1lns69.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptp1lns69.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p > 0)\n            modp(r, p - 1)\n        else\n            r\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.modp(tmpx_77w_55.scala:16)\n\
    \tat Problem$.main(tmpx_77w_55.scala:23)\n\tat Problem.main(tmpx_77w_55.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp1lns69.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptp1lns69.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp1lns69.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptp1lns69.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p > 0)\n            modp(r, p - 1)\n        else\n            r\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.modp(tmpx_77w_55.scala:16)\n\
    \tat Problem$.main(tmpx_77w_55.scala:23)\n\tat Problem.main(tmpx_77w_55.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n = n.toInt\n      \
    \  val p = p.toInt\n        val result = 1L\n        val m = 1L\n        val q\
    \ = p\n        val r = p\n        while (n > 1) {\n            val t = n % q\n\
    \            n /= q\n            result *= t\n            m %= q\n           \
    \ q /= r\n            r /= p\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqmy2l8nq.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpqmy2l8nq.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpqmy2l8nq.scala:25:19 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m            result *= t\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Long\
    \ - did you mean result.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqmy2l8nq.scala:26:14\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            m %= q\n\e[31m\e\
    [31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value %= is not\
    \ a member of Long - did you mean m.!=?\n4 errors found\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n = n.toInt\n      \
    \  val p = p.toInt\n        val result = 1L\n        val q = p / 2\n        val\
    \ r = n % q\n        val t = r * q\n        val u = t % p\n        val v = u *\
    \ p\n        result = result + v\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprntpzsl2.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmprntpzsl2.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmprntpzsl2.scala:24:15 -----------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        result = result + v\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Reassignment to val result\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659800393
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 + p7) %\
    \ p\n        val p8 = (p7 + n7) % p\n        val n9 = (n8 + p8) % p\n        val\
    \ p9 = (p8 + n8) % p\n        val n10 = (n9 + p9) % p\n        val p10 = (p9 +\
    \ n9) % p\n        val n11 = (n10 + p10) % p\n        val p11 = (p10 + n10) %\
    \ p\n        val n12 = (n11 + p11) % p\n        val p12 = (p11 + n11) % p\n  \
    \      val n13 = (n12 + p12) % p\n        val p13 = (p12 + n12) % p\n        val\
    \ n14 = (n13 + p13) % p\n        val p14 = (p13 + n13) % p\n        val n15 =\
    \ (n14 + p14) % p\n        val p15 = (p14 + n14) % p\n        val n16 = (n15 +\
    \ p15) % p\n        val p16 = (p15 + n15) % p\n        val n17 = (n16 + p16) %\
    \ p\n        val p17 = (p16 + n16) % p\n        val n18 = (n17 + p17) % p\n  \
    \      val p18 = (p17 + n17) % p\n        val n19 = (n18 + p18) % p\n        val\
    \ p19 = (p18 + n18) % p\n        val n20 = (n19 + p19) % p\n        val p20 =\
    \ (p19 + n19) % p\n        val n21 = (n20 + p20) % p\n        val p21 = (p20 +\
    \ n20) % p\n        val n22 = (n21 + p21) % p\n        val p22 = (p21 + n21) %\
    \ p\n        val n23 = (n22 + p22) % p\n        val p23 = (p22 + n22\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv6_jowih.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpv6_jowih.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (n < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_3yiy3x.scala:21)\n\tat Problem.main(tmpa_3yiy3x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp1lns69.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptp1lns69.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        val s = math.signum(r)\n        if (s\
    \ == 0) 1 else s\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm8r8rjq_.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (r < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp883mj5tv.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp1lns69.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptp1lns69.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1\n        else if (r > 0) modp(r, p) + 1\n        else modp(r, p)\
    \ - 1\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.sc"
  stdout: ''
  timestamp: 1659800398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n1 = n % p\n       \
    \ val n2 = n / p\n        val n3 = n2 / p\n        val n4 = n3 / p\n        val\
    \ n5 = n4 / p\n        val n6 = n5 / p\n        val n7 = n6 / p\n        val n8\
    \ = n7 / p\n        val n9 = n8 / p\n        val n10 = n9 / p\n        val n11\
    \ = n10 / p\n        val n12 = n11 / p\n        val n13 = n12 / p\n        val\
    \ n14 = n13 / p\n        val n15 = n14 / p\n        val n16 = n15 / p\n      \
    \  val n17 = n16 / p\n        val n18 = n17 / p\n        val n19 = n18 / p\n \
    \       val n20 = n19 / p\n        val n21 = n20 / p\n        val n22 = n21 /\
    \ p\n        val n23 = n22 / p\n        val n24 = n23 / p\n        val n25 = n24\
    \ / p\n        val n26 = n25 / p\n        val n27 = n26 / p\n        val n28 =\
    \ n27 / p\n        val n29 = n28 / p\n        val n30 = n29 / p\n        val n31\
    \ = n30 / p\n        val n32 = n31 / p\n        val n33 = n32 / p\n        val\
    \ n34 = n33 / p\n        val n35 = n34 / p\n        val n36 = n35 / p\n      \
    \  val n37 = n36 / p\n        val n38 = n37 / p\n        val n39 = n38 / p\n \
    \       val n40 = n39 / p\n        val n41 = n40 / p\n        val n42 = n41 /\
    \ p\n        val n43 = n42 / p\n        val n44 = n43 / p\n        val n45 = n44\
    \ / p\n        val n46 = n45 / p\n        val n47 = n46 / p\n        val n48 =\
    \ n47 / p\n        val n49 = n48 / p\n        val n50 = n49 / p\n        val n51\
    \ = n50 / p\n        val n52 = n51 / p\n        val n53 = n52 / p\n        val\
    \ n54 = n53 / p\n        val n55 = n54 / p\n        val n56 = n55 / p\n      \
    \  \n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpegy33tc9.scala:73:5\
    \ ---------------------\e[0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2,n)\n\
    \        val r = math.mod(m,p)\n        if (r < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa2vkp_z0.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m,p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n % p\n       \
    \ if (n2 == 0) 1\n        else if (n2 == p) 2\n        else modp(n2, p)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659800401
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp1lns69.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptp1lns69.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (n < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_3yiy3x.scala:21)\n\tat Problem.main(tmpa_3yiy3x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.pow(2,\
    \ n) % p\n        if (r < 0) r + p else r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpydfx7zra.scala:17:19\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m   |\e[0m                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Double\n\e[31m   |\e[0m     \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpydfx7zra.scala:17:30 --------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m           \
    \                   Found:    (r : Double)\n\e[31m   |\e[0m                  \
    \            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n = n.toInt\n      \
    \  val p = p.toInt\n        if (n == 0) 1\n        else if (n == 1) p\n      \
    \  else if (n % 2 == 0) modp(n / 2, p) * p + modp(n / 2, p)\n        else modp(n\
    \ / 2, p) * p + modp(n / 2, p) * p\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) ==\
    \ (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3ox1d9p4.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp3ox1d9p4.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800383
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n = n.toInt\n      \
    \  val p = p.toInt\n        if (n == 0) 1\n        else if (n == 1) p\n      \
    \  else if (n % 2 == 0) modp(n / 2, p) * p + modp((n / 2) * p, p)\n        else\
    \ modp((n / 2) * p, p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjy1ong_r.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpjy1ong_r.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp1lns69.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptp1lns69.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        r.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6f3qbfm9.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if\
    \ (m == 0) 1\n        else (n / p) * p + m\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptcu17fu8.scala:22)\n\tat Problem.main(tmptcu17fu8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.BigInt(n)\n\
    \        val q = scala.math.BigInt(p)\n        val r = r.mod(q)\n        r.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) ==\
    \ (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l))\
    \ == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdu53k_0l.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = r.mod(q)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800395
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.pow(2,\
    \ n) % p\n        if (r < 0) r + p else r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpydfx7zra.scala:17:19\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m   |\e[0m                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Double\n\e[31m   |\e[0m     \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpydfx7zra.scala:17:30 --------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m           \
    \                   Found:    (r : Double)\n\e[31m   |\e[0m                  \
    \            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1yf9sy4m.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.pow(2,\
    \ n)\n        val m = scala.math.mod(r, p)\n        if (m == 0) 1 else m\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1e802mn4.scala:17:27 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = scala.math.mod(r,\
    \ p)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800405
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 + p7) %\
    \ p\n        val p8 = (p7 + n7) % p\n        val n9 = (n8 + p8) % p\n        val\
    \ p9 = (p8 + n8) % p\n        val n10 = (n9 + p9) % p\n        val p10 = (p9 +\
    \ n9) % p\n        val n11 = (n10 + p10) % p\n        val p11 = (p10 + n10) %\
    \ p\n        val n12 = (n11 + p11) % p\n        val p12 = (p11 + n11) % p\n  \
    \      val n13 = (n12 + p12) % p\n        val p13 = (p12 + n12) % p\n        val\
    \ n14 = (n13 + p13) % p\n        val p14 = (p13 + n13) % p\n        val n15 =\
    \ (n14 + p14) % p\n        val p15 = (p14 + n14) % p\n        val n16 = (n15 +\
    \ p15) % p\n        val p16 = (p15 + n15) % p\n        val n17 = (n16 + p16) %\
    \ p\n        val p17 = (p16 + n16) % p\n        val n18 = (n17 + p17) % p\n  \
    \      val p18 = (p17 + n17) % p\n        val n19 = (n18 + p18) % p\n        val\
    \ p19 = (p18 + n18) % p\n        val n20 = (n19 + p19) % p\n        val p20 =\
    \ (p19 + n19) % p\n        val n21 = (n20 + p20) % p\n        val p21 = (p20 +\
    \ n20) % p\n        val n22 = (n21 + p21) % p\n        val p22 = (p21 + n21) %\
    \ p\n        val n23 = (n22 + p22) % p\n        val p23 = (p22 + n\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw7bwxqqe.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpw7bwxqqe.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800404
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (r < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp883mj5tv.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = n % p\n        if\
    \ (m == 0) 1\n        else modp(n / p, p)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq86ahw8o.scala:21)\n\tat Problem.main(tmpq86ahw8o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800405
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1\n        else if (r < 0) (p - (p % r)) % r\n        else r\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplj4ylu2q.scala:23)\n\tat Problem.main(tmplj4ylu2q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800406
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            -r\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpia_hrzuh.scala:24)\n\tat Problem.main(tmpia_hrzuh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n1 = n % p\n       \
    \ val n2 = n - n1\n        val n3 = n2 % p\n        val n4 = n2 - n3\n       \
    \ val n5 = n4 % p\n        val n6 = n4 - n5\n        val n7 = n6 % p\n       \
    \ val n8 = n6 - n7\n        val n9 = n8 % p\n        val n10 = n8 - n9\n     \
    \   val n11 = n10 % p\n        val n12 = n10 - n11\n        val n13 = n12 % p\n\
    \        val n14 = n12 - n13\n        val n15 = n14 % p\n        val n16 = n14\
    \ - n15\n        val n17 = n16 % p\n        val n18 = n16 - n17\n        val n19\
    \ = n18 % p\n        val n20 = n18 - n19\n        val n21 = n20 % p\n        val\
    \ n22 = n20 - n21\n        val n23 = n22 % p\n        val n24 = n22 - n23\n  \
    \      val n25 = n24 % p\n        val n26 = n24 - n25\n        val n27 = n26 %\
    \ p\n        val n28 = n26 - n27\n        val n29 = n28 % p\n        val n30 =\
    \ n28 - n29\n        val n31 = n30 % p\n        val n32 = n30 - n31\n        val\
    \ n33 = n32 % p\n        val n34 = n32 - n33\n        val n35 = n34 % p\n    \
    \    val n36 = n34 - n35\n        val n37 = n36 % p\n        val n38 = n36 - n37\n\
    \        val n39 = n38 % p\n        val n40 = n38 - n39\n        val n41 = n40\
    \ % p\n        val n42 = n40 - n41\n        val n43 = n42 % p\n        val n44\
    \ = n42 - n43\n        val n45 = n44 % p\n        val n46 = n44 - n45\n      \
    \  val n47 = n46 % p\n        val n48 = n46 - n47\n        val n49 = n48 % p\n\
    \        val n50 = n48 - n49\n        val n51 = n50 % p\n        val n52 = n50\
    \ - n51\n        val n53 = n52 % p\n        val n54 = n5\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqcojarmc.scala:70:5\
    \ ---------------------\e[0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val n3 = n2 * n2\n        val n4 = n3 * n3\n        val n5 = n4 * n4\n     \
    \   val n6 = n5 * n5\n        val n7 = n6 * n6\n        val n8 = n7 * n7\n   \
    \     val n9 = n8 * n8\n        val n10 = n9 * n9\n        val n11 = n10 * n10\n\
    \        val n12 = n11 * n11\n        val n13 = n12 * n12\n        val n14 = n13\
    \ * n13\n        val n15 = n14 * n14\n        val n16 = n15 * n15\n        val\
    \ n17 = n16 * n16\n        val n18 = n17 * n17\n        val n19 = n18 * n18\n\
    \        val n20 = n19 * n19\n        val n21 = n20 * n20\n        val n22 = n21\
    \ * n21\n        val n23 = n22 * n22\n        val n24 = n23 * n23\n        val\
    \ n25 = n24 * n24\n        val n26 = n25 * n25\n        val n27 = n26 * n26\n\
    \        val n28 = n27 * n27\n        val n29 = n28 * n28\n        val n30 = n29\
    \ * n29\n        val n31 = n30 * n30\n        val n32 = n31 * n31\n        val\
    \ n33 = n32 * n32\n        val n34 = n33 * n33\n        val n35 = n34 * n34\n\
    \        val n36 = n35 * n35\n        val n37 = n36 * n36\n        val n38 = n37\
    \ * n37\n        val n39 = n38 * n38\n        val n40 = n39 * n39\n        val\
    \ n41 = n40 * n40\n        val n42 = n41 * n41\n        val n43 = n42 * n42\n\
    \        val n44 = n43 * n43\n        val n45 = n44 * n44\n        val n46 = n45\
    \ * n45\n        val n47 = n46 * n46\n        val n48 = n47 * n47\n        val\
    \ n49 = n48 * n48\n        val n50 = n49 * n49\n        val n51 = n50 * n50\n\
    \        val n52 = n51 * n51\n        val n53 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8xjjfyxt.scala:67:17 ---------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m        \e[33mval\e[0m \e[36mn53\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8xjjfyxt.scala:68:5 ---------------------\e[0m\e[0m\n\e[31m68\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0 || r < 0) r + p\n        else r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmgbjguxl.scala:22)\n\tat Problem.main(tmpmgbjguxl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            -r\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpia_hrzuh.scala:24)\n\tat Problem.main(tmpia_hrzuh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2,n)\n\
    \        val r = math.mod(m,p)\n        if(r == 0) 1 else r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5e13n3o8.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m,p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800408
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1\n        else r\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi1jxh8wq.scala:22)\n\tat Problem.main(tmpi1jxh8wq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800408
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (n < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_3yiy3x.scala:21)\n\tat Problem.main(tmpa_3yiy3x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: -1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n % p\n       \
    \ if (n2 == 0) n\n        else modp(n2, p)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1659800411
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (r < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp883mj5tv.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = n % (p + 1)\n  \
    \      if (m == 0) 1\n        else m\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw3_bf84t.scala:22)\n\tat Problem.main(tmpw3_bf84t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800408
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2,n)\n\
    \        val r = math.mod(m, p)\n        val s = math.signum(r)\n        if (s\
    \ == 0) 1 else s\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_sf0tmlt.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n = n.toInt\n      \
    \  val p = p.toInt\n        val result = 1L\n        val mask = (1L << p) - 1L\n\
    \        while (n > 1) {\n            result *= n\n            n -= mask\n   \
    \     }\n        result % p\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7a88t95y.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmp7a88t95y.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp7a88t95y.scala:21:19 ------------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m            result *= n\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value *= is not a member of Long\
    \ - did you mean result.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0 || r < 0) r + p\n        else r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmgbjguxl.scala:22)\n\tat Problem.main(tmpmgbjguxl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0 || r < 0) r + p\n        else r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmgbjguxl.scala:22)\n\tat Problem.main(tmpmgbjguxl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2,n)\n\
    \        val r = math.mod(m,p)\n        if (r < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa2vkp_z0.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m,p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2,n)\n\
    \        val r = math.mod(m,p)\n        if (r == 0) 1 else r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphu4ddaby.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m,p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800408
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p22\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph92nghl7.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmph92nghl7.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.pow(2,\
    \ n) % p\n        if (r < 0) r + p else r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpydfx7zra.scala:17:19\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m   |\e[0m                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Double\n\e[31m   |\e[0m     \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpydfx7zra.scala:17:30 --------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m           \
    \                   Found:    (r : Double)\n\e[31m   |\e[0m                  \
    \            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.pow(2,\
    \ n)\n        val q = scala.math.pow(p, r)\n        val r = scala.math.mod(q,\
    \ p)\n        r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyk37h95e.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(q,\
    \ p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyk37h95e.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        r\n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0m        Found:    (r : Double)\n\e[31m   |\e\
    [0m        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1\n        else modp(r, p) + 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.scala:18)\n\tat Problem$.modp(tmpum69gz9p.scala:18)\n\
    \tat Problem$.modp(tmpum69gz9p.sc"
  stdout: ''
  timestamp: 1659800407
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        r match {\n            case 0 => 1\n\
    \            case _ => r\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpn3bn5vf9.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800408
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.pow(2,\
    \ n) % p\n        if (r < 0) r + p else r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpydfx7zra.scala:17:19\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mif\e[0m (r < \e\
    [31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e[31m   |\e[0m                   ^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Found:    Double\n\e[31m   |\e[0m     \
    \              Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpydfx7zra.scala:17:30 --------------------\e[0m\e[0m\n\e[31m17\
    \ |\e[0m        \e[33mif\e[0m (r < \e[31m0\e[0m) r + p \e[33melse\e[0m r\n\e[31m\e\
    [31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m           \
    \                   Found:    (r : Double)\n\e[31m   |\e[0m                  \
    \            Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p > 0)\n            modp(r, p - 1)\n        else\n            r\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArithmeticException: / by zero\n\tat Problem$.modp(tmpx_77w_55.scala:16)\n\
    \tat Problem$.main(tmpx_77w_55.scala:23)\n\tat Problem.main(tmpx_77w_55.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = n % (p + 1)\n  \
    \      if (m == 0) 1\n        else m\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw3_bf84t.scala:22)\n\tat Problem.main(tmpw3_bf84t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800408
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 + p7) %\
    \ p\n        val p8 = (p7 + n7) % p\n        val n9 = (n8 + p8) % p\n        val\
    \ p9 = (p8 + n8) % p\n        val n10 = (n9 + p9) % p\n        val p10 = (p9 +\
    \ n9) % p\n        val n11 = (n10 + p10) % p\n        val p11 = (p10 + n10) %\
    \ p\n        val n12 = (n11 + p11) % p\n        val p12 = (p11 + n11) % p\n  \
    \      val n13 = (n12 + p12) % p\n        val p13 = (p12 + n12) % p\n        val\
    \ n14 = (n13 + p13) % p\n        val p14 = (p13 + n13) % p\n        val n15 =\
    \ (n14 + p14) % p\n        val p15 = (p14 + n14) % p\n        val n16 = (n15 +\
    \ p15) % p\n        val p16 = (p15 + n15) % p\n        val n17 = (n16 + p16) %\
    \ p\n        val p17 = (p16 + n16) % p\n        val n18 = (n17 + p17) % p\n  \
    \      val p18 = (p17 + n17) % p\n        val n19 = (n18 + p18) % p\n        val\
    \ p19 = (p18 + n18) % p\n        val n20 = (n19 + p19) % p\n        val p20 =\
    \ (p19 + n19) % p\n        val n21 = (n20 + p20) % p\n        val p21 = (p20 +\
    \ n20) % p\n        val n22 = (n21 + p21) % p\n        val p22 = (p21 + n21) %\
    \ p\n        val n23 = (n22 + p22) % p\n        val p23 = (p22 + n\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw7bwxqqe.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpw7bwxqqe.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800404
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n = n.toInt\n      \
    \  val p = p.toInt\n        val result = 1L\n        val mask = -1L\n        val\
    \ mask2 = 1L\n        val mask3 = 1L\n        val mask4 = 1L\n        val mask5\
    \ = 1L\n        val mask6 = 1L\n        val mask7 = 1L\n        val mask8 = 1L\n\
    \        val mask9 = 1L\n        val mask10 = 1L\n        val mask11 = 1L\n  \
    \      val mask12 = 1L\n        val mask13 = 1L\n        val mask14 = 1L\n   \
    \     val mask15 = 1L\n        val mask16 = 1L\n        val mask17 = 1L\n    \
    \    val mask18 = 1L\n        val mask19 = 1L\n        val mask20 = 1L\n     \
    \   val mask21 = 1L\n        val mask22 = 1L\n        val mask23 = 1L\n      \
    \  val mask24 = 1L\n        val mask25 = 1L\n        val mask26 = 1L\n       \
    \ val mask27 = 1L\n        val mask28 = 1L\n        val mask29 = 1L\n        val\
    \ mask30 = 1L\n        val mask31 = 1L\n        val mask32 = 1L\n        val mask33\
    \ = 1L\n        val mask34 = 1L\n        val mask35 = 1L\n        val mask36 =\
    \ 1L\n        val mask37 = 1L\n        val mask38 = 1L\n        val mask39 = 1L\n\
    \        val mask40 = 1L\n        val mask41 = 1L\n        val mask42 = 1L\n \
    \       val mask43 = 1L\n        val mask44 = 1L\n        val mask45 = 1L\n  \
    \      val mask46 = 1L\n        val mask47 = 1L\n        val mask48 = 1L\n   \
    \     val mask49 = 1L\n        val mask50 = 1L\n        val mask51 = 1L\n    \
    \    val mask52 = 1L\n        val mask53 = 1L\n        val mask54 = 1L\n     \
    \   val mask55 = 1L\n        val mask56 = 1L\n        val mask57 = 1L\n      \
    \  val mask58 = 1L\n        val mask59 = 1L\n        val mask60 = 1L\n       \
    \ val mask61 = 1L\n        val mask62 = 1L\n        val mask63 = 1L\n        val\
    \ mask64 = 1L\n        val mask65 = 1L\n        val mask66 = 1L\n        val mask67\
    \ = 1L\n        val mask68 = 1L\n        val mask69\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqphw0uab.scala:88:4 ----------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqphw0uab.scala:16:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = n.toInt\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m\
    \   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqphw0uab.scala:17:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mp\e[0m = p.toInt\n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m\
    \   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mp\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqphw0uab.scala:88:5\
    \ ---------------------\e[0m\e[0m\n\e[31m88 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659800408
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n = n.toInt\n      \
    \  val p = p.toInt\n        if (n < 0 || p < 0)\n            throw new IllegalArgumentException(\"\
    n and p must be non-negative\")\n        if (n == 0)\n            return p\n \
    \       if (p == 0)\n            return 1\n        if (n == 1)\n            return\
    \ p\n        if (p == 1)\n            return 1\n        val q = p / n\n      \
    \  val r = p % n\n        val s = modp(q, p)\n        val t = modp(r, p)\n   \
    \     s * t + q * r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpc83_ucia.scala:16:16 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = n.toInt\n\e[31m\e\
    [31m   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive\
    \ \e[33mvalue\e[0m \e[35mn\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpc83_ucia.scala:17:16 ---------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mp\e[0m = p.toInt\n\e[31m\e[31m\
    \   |\e[0m                ^\e[0m\n\e[31m   |\e[0m                Recursive \e\
    [33mvalue\e[0m \e[35mp\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800406
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1\n        else if (r > 0) modp(r, p) + 1\n        else modp(r, p)\
    \ - 1\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.sc"
  stdout: ''
  timestamp: 1659800398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (r == 0) 1 else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpl6mzp_24.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp1lns69.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptp1lns69.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2.0, n)\n\
    \        math.mod(m, p)\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmyqqgdfp.scala:17:13 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        math.mod(m, p)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0m        value mod is not a member of math\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659800408
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (n < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_3yiy3x.scala:21)\n\tat Problem.main(tmpa_3yiy3x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = n % (p - 1)\n  \
    \      if (m == 0) 1 else m\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5w_kqs3w.scala:21)\n\tat Problem.main(tmp5w_kqs3w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800409
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1\n        else if (r > 0) modp(r, p) + 1\n        else modp(r, p)\
    \ - 1\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l), (5l))\
    \ == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.scala:18)\n\tat Problem$.modp(tmpy7anugyx.scala:18)\n\
    \tat Problem$.modp(tmpy7anugyx.sc"
  stdout: ''
  timestamp: 1659800398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val n3 = n2 * n2\n        val n4 = n3 * n3\n        val n5 = n4 * n4\n     \
    \   val n6 = n5 * n5\n        val n7 = n6 * n6\n        val n8 = n7 * n7\n   \
    \     val n9 = n8 * n8\n        val n10 = n9 * n9\n        val n11 = n10 * n10\n\
    \        val n12 = n11 * n11\n        val n13 = n12 * n12\n        val n14 = n13\
    \ * n13\n        val n15 = n14 * n14\n        val n16 = n15 * n15\n        val\
    \ n17 = n16 * n16\n        val n18 = n17 * n17\n        val n19 = n18 * n18\n\
    \        val n20 = n19 * n19\n        val n21 = n20 * n20\n        val n22 = n21\
    \ * n21\n        val n23 = n22 * n22\n        val n24 = n23 * n23\n        val\
    \ n25 = n24 * n24\n        val n26 = n25 * n25\n        val n27 = n26 * n26\n\
    \        val n28 = n27 * n27\n        val n29 = n28 * n28\n        val n30 = n29\
    \ * n29\n        val n31 = n30 * n30\n        val n32 = n31 * n31\n        val\
    \ n33 = n32 * n32\n        val n34 = n33 * n33\n        val n35 = n34 * n34\n\
    \        val n36 = n35 * n35\n        val n37 = n36 * n36\n        val n38 = n37\
    \ * n37\n        val n39 = n38 * n38\n        val n40 = n39 * n39\n        val\
    \ n41 = n40 * n40\n        val n42 = n41 * n41\n        val n43 = n42 * n42\n\
    \        val n44 = n43 * n43\n        val n45 = n44 * n44\n        val n46 = n45\
    \ * n45\n        val n47 = n46 * n46\n        val n48 = n47 * n47\n        val\
    \ n49 = n48 * n48\n        val n50 = n49 * n49\n        val n51 = n50 * n50\n\
    \        val n52 = n51 * n51\n        val n53 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8xjjfyxt.scala:67:17 ---------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m        \e[33mval\e[0m \e[36mn53\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8xjjfyxt.scala:68:5 ---------------------\e[0m\e[0m\n\e[31m68\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = scala.math.pow(2,\
    \ n)\n        val q = scala.math.pow(p, r)\n        val r = scala.math.mod(q,\
    \ p)\n        r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyk37h95e.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = scala.math.mod(q,\
    \ p)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyk37h95e.scala:19:8\
    \ ---------------------\e[0m\e[0m\n\e[31m19 |\e[0m        r\n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0m        Found:    (r : Double)\n\e[31m   |\e\
    [0m        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800407
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (n < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpa_3yiy3x.scala:21)\n\tat Problem.main(tmpa_3yiy3x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val n2 = n * n\n       \
    \ val p2 = p * p\n        val n3 = n2 * n2\n        val p3 = p2 * p2\n       \
    \ val n4 = n3 * n3\n        val p4 = p3 * p3\n        val n5 = n4 * n4\n     \
    \   val p5 = p4 * p4\n        val n6 = n5 * n5\n        val p6 = p5 * p5\n   \
    \     val n7 = n6 * n6\n        val p7 = p6 * p6\n        val n8 = (n7 * n7) %\
    \ p\n        val p8 = (p7 * p7) % p\n        val n9 = (n8 * n8) % p\n        val\
    \ p9 = (p8 * p8) % p\n        val n10 = (n9 * n9) % p\n        val p10 = (p9 *\
    \ p9) % p\n        val n11 = (n10 * n10) % p\n        val p11 = (p10 * p10) %\
    \ p\n        val n12 = (n11 * n11) % p\n        val p12 = (p11 * p11) % p\n  \
    \      val n13 = (n12 * n12) % p\n        val p13 = (p12 * p12) % p\n        val\
    \ n14 = (n13 * n13) % p\n        val p14 = (p13 * p13) % p\n        val n15 =\
    \ (n14 * n14) % p\n        val p15 = (p14 * p14) % p\n        val n16 = (n15 *\
    \ n15) % p\n        val p16 = (p15 * p15) % p\n        val n17 = (n16 * n16) %\
    \ p\n        val p17 = (p16 * p16) % p\n        val n18 = (n17 * n17) % p\n  \
    \      val p18 = (p17 * p17) % p\n        val n19 = (n18 * n18) % p\n        val\
    \ p19 = (p18 * p18) % p\n        val n20 = (n19 * n19) % p\n        val p20 =\
    \ (p19 * p19) % p\n        val n21 = (n20 * n20) % p\n        val p21 = (p20 *\
    \ p20) % p\n        val n22 = (n21 * n21) % p\n        val p22 = (p21 * p21) %\
    \ p\n        val n23 = (n22 * n22) % p\n        val p23 = (p22 * p\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n\
    \    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l), (101l)) ==\
    \ (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l), (101l))\
    \ == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l), (5l))\
    \ == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptp1lns69.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmptp1lns69.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (p < 0)\n            r + p\n        else\n            r\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprk_mxjx7.scala:24)\n\tat Problem.main(tmprk_mxjx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r < 0) r + p else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptssq8td3.scala:21)\n\tat Problem.main(tmptssq8td3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800386
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.max(math.min(n,\
    \ p), 0L)\n        math.pow(2, m) % p\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l))\
    \ == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l))\
    \ == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl1v2_d0n.scala:17:8\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m        math.pow(\e[31m2\e[0m,\
    \ m) % p\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    Double\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800409
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = n % (p - 1)\n  \
    \      if (m == 0) 1 else m\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n\
    \    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n\
    \    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n\
    \    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5w_kqs3w.scala:21)\n\tat Problem.main(tmp5w_kqs3w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800409
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val m = math.pow(2, n)\n\
    \        val r = math.mod(m, p)\n        if (r < 0) r + p else r\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(modp((3l), (5l)) == (3l));\n    assert(modp((1101l),\
    \ (101l)) == (2l));\n    assert(modp((0l), (101l)) == (1l));\n    assert(modp((3l),\
    \ (11l)) == (8l));\n    assert(modp((100l), (101l)) == (1l));\n    assert(modp((30l),\
    \ (5l)) == (4l));\n    assert(modp((31l), (5l)) == (3l));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp883mj5tv.scala:17:21 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = math.mod(m, p)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \      value mod is not a member of math\n1 error found\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Return 2^n modulo p (be aware of numerics).\n    // >>> modp(3, 5)\n\
    \    // 3\n    // >>> modp(1101, 101)\n    // 2\n    // >>> modp(0, 101)\n   \
    \ // 1\n    // >>> modp(3, 11)\n    // 8\n    // >>> modp(100, 101)\n    // 1\n\
    \    def modp(n : Long, p : Long) : Long = {\n        val r = n % p\n        if\
    \ (r == 0) 1 else r\n    }\n    def main(args: Array[String]) = {\n    assert(modp((3l),\
    \ (5l)) == (3l));\n    assert(modp((1101l), (101l)) == (2l));\n    assert(modp((0l),\
    \ (101l)) == (1l));\n    assert(modp((3l), (11l)) == (8l));\n    assert(modp((100l),\
    \ (101l)) == (1l));\n    assert(modp((30l), (5l)) == (4l));\n    assert(modp((31l),\
    \ (5l)) == (3l));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi44u56oi.scala:21)\n\tat Problem.main(tmpi44u56oi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800387
